language: cs
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long onesMin = ones * min;\n        long\
    \ zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long\
    \ onesMinMax = onesMin + onesMax;\n        long zerosMinMax = zerosMin + zerosMax;\n\
    \        long onesMinMaxZeros = onesMin + zerosMax;\n        long zerosMinMaxZeros\
    \ = zerosMin + zerosMax;\n        long onesMinMaxOnes = onesMin + onesMax;\n \
    \       long zerosMinMaxOnes = zerosMin + onesMax;\n        long onesMinMaxOnesZeros\
    \ = onesMin + zerosMax;\n        long zerosMinMaxOnesZeros = zerosMin + zerosMax;\n\
    \        long onesMinMaxOnesOnes = onesMin + onesMax;\n        long zerosMinMaxOnesOnes\
    \ = zerosMin + onesMax;\n        long onesMinMaxOnesOnesZeros = onesMin + zerosMax;\n\
    \        long zerosMinMaxOnesOnesZeros = zerosMin + zerosMax;\n        long onesMinMaxOnesOnesOnes\
    \ = onesMin + onesMax;\n        long zerosMinMaxOnesOnesOnes = zerosMin + onesMax;\n\
    \        long onesMinMaxOnesOnesOnesZeros = onesMin + zerosMax;\n        long\
    \ zerosMinMaxOnesOnesOnesZeros = zerosMin + zerosMax;\n        long onesMinMaxOnesOnesOnesOnes\
    \ = onesMin + onesMax;\n        long zerosMinMaxOnesOnesOnesOnes = zerosMin +\
    \ onesMax;\n        long onesMinMaxOnesOnesOnesOnesZeros = onesMin + zerosMax;\n\
    \        long zerosMinMaxOnesOnesOnesOnesZeros = zerosMin + zerosMax;\n      \
    \  long onesMinMaxOnesOnesOnesOnesOnes = onesMin + onesMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp33blmxid.cs(62,64): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) ones++;\n            else if (num == 0) zeros++;\n   \
    \         else if (num > max) max = num;\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        foreach (long num in arr) {\n      \
    \      if (num == 1) onesCount++;\n            else if (num == 0) zerosCount++;\n\
    \            else if (num > maxCount) maxCount = num;\n        }\n        long\
    \ onesPercent = onesCount * 100 / arr.Count;\n        long zerosPercent = zerosCount\
    \ * 100 / arr.Count;\n        long maxPercent = maxCount * 100 / arr.Count;\n\
    \        bool ascending = true;\n        if (onesCount > zerosCount) {\n     \
    \       ascending = false;\n        }\n        if (onesCount < zerosCount) {\n\
    \            ascending = true;\n        }\n        long onesDecimal = onesCount\
    \ * 10 / arr.Count;\n        long zerosDecimal = zerosCount * 10 / arr.Count;\n\
    \        long maxDecimal = maxCount * 10 / arr.Count;\n        if (onesPercent\
    \ > zerosPercent) {\n            ascending = false;\n        }\n        if (onesPercent\
    \ < zerosPercent) {\n            ascending = true;\n        }\n        if (onesDecimal\
    \ > zerosDecimal) {\n            ascending = false;\n        }\n        if (onesDecimal\
    \ < zerosDecimal) {\n            ascending = true;\n        }\n        if (ascending)\
    \ {\n            foreach (long num in arr) {\n                if (num == 1) result.Add(num);\n\
    \                else if (num == 0) result.Add(num);\n                else if\
    \ (num > max) result.Add(num);\n            }\n        } else {\n            foreach\
    \ (long num in arr) {\n                if (num == 1) result.Add(num);\n      \
    \          else if (num == 0) result.Add(num);\n                else if (num <\
    \ max) result.Add(num);\n            }\n        }\n        return result;\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <016bf993e8d0418cacccc9b67c588853>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <016bf993e8d0418cacccc9b67c588853>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        if (i == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            int onesIndex = arr.IndexOf(1L);\n \
    \           int zerosIndex = arr.IndexOf(0L);\n            int onesCount = 0;\n\
    \            int zerosCount = 0;\n            int minIndex = onesIndex;\n    \
    \        int maxIndex = zerosIndex;\n            while (onesCount < ones && zerosCount\
    \ < zeros) {\n                if (arr[minIndex] == 1L) {\n                   \
    \ onesCount++;\n                    minIndex++;\n                }\n         \
    \       else if (arr[minIndex] == 0L) {\n                    zerosCount++;\n \
    \                   minIndex++;\n                }\n                else {\n \
    \                   minIndex++;\n                }\n            }\n          \
    \  while (minIndex < maxIndex) {\n                if (arr[minIndex] == 1L) {\n\
    \                    onesCount++;\n                }\n                else if\
    \ (arr[minIndex] == 0L) {\n                    zerosCount++;\n               \
    \ }\n                else {\n                    minIndex++;\n               \
    \ }\n            }\n            while (onesCount < ones) {\n                result.Add(arr[minIndex]);\n\
    \                minIndex++;\n            }\n            while (zerosCount < zeros)\
    \ {\n                result.Add(arr[minIndex]);\n                minIndex++;\n\
    \            }\n        }\n        else if (ones < zeros) {\n            int zerosIndex\
    \ = arr.IndexOf(0L);\n            int zerosCount = 0;\n            int minIndex\
    \ = zerosIndex;\n            int maxIndex = zerosIndex;\n            while (zerosCount\
    \ < zeros && onesCount < ones) {\n                if (arr[minIndex] == 0L) {\n\
    \                    zerosCount++;\n                    minIndex++;\n        \
    \        }\n                else if (arr[minIndex] == 1L) {\n                \
    \    onesCount++;\n                    minIndex++;\n                }\n      \
    \          else {\n                    minIndex++;\n                }\n      \
    \      }\n            while (minIndex < maxIndex) {\n                if (arr[minIndex]\
    \ == 0L) {\n                    zerosCount++;\n                }\n           \
    \     else if (arr[minIndex] == 1L) {\n                    onesCount++;\n    \
    \            }\n                else {\n                    minIndex++;\n    \
    \            }\n            }\n            while (zerosCount < zeros) {\n    \
    \            result.Add(arr[minIndex]);\n                minIndex++;\n       \
    \     }\n            while (onesCount < ones) {\n                result.Add(arr[minIndex]);\n\
    \                minIndex++;\n            }\n        }\n        else {\n     \
    \       int minIndex = arr.IndexOf(1L);\n            int maxIndex = arr.\n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpd5m1mbqz.cs(111,32): error CS1001: Identifier expected

    /tmp/tmpd5m1mbqz.cs(111,32): error CS1002: ; expected

    /tmp/tmpd5m1mbqz.cs(113,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpd5m1mbqz.cs(124,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long onesMin = ones * min;\n        long\
    \ zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long\
    \ maxOnes = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes\
    \ = ones * min;\n        long minZeros = zeros * min;\n        List<long> res\
    \ = new List<long>();\n        long onesSum = 0;\n        long zerosSum = 0;\n\
    \        long maxOnesSum = 0;\n        long maxZerosSum = 0;\n        long minOnesSum\
    \ = 0;\n        long minZerosSum = 0;\n        long maxOnesCount = 0;\n      \
    \  long maxZerosCount = 0;\n        long minOnesCount = 0;\n        long minZerosCount\
    \ = 0;\n        long maxOnesSumCount = 0;\n        long maxZerosSumCount = 0;\n\
    \        long minOnesSumCount = 0;\n        long minZerosSumCount = 0;\n     \
    \   long maxOnesCountCount = 0;\n        long maxZerosSumCountCount = 0;\n   \
    \     long minOnesSumCountCount = 0;\n        long minZerosSumCountCount = 0;\n\
    \        long maxOnesSumCountCount = 0;\n        long maxZerosSumCountCount =\
    \ 0;\n        long minOnesSumCountCount = 0;\n        long minZerosSumCountCount\
    \ = 0;\n        long maxOnesSumCountCount = 0;\n        long maxZerosSumCountCount\
    \ = 0;\n        long minOnesSumCountCount = 0;\n        long minZerosSumCountCount\
    \ = 0;\n        long maxOnesSumCountCount = 0;\n        long maxZerosSumCountCount\
    \ = 0;\n        long minOnesSumCountCount = 0;\n        long minZerosSumCountCount\
    \ = 0;\n        long maxOnesSumCountCount = 0;\n        long maxZerosSumCountCount\
    \ = 0;\n        long minOnesSumCountCount = 0;\n        long minZerosSumCountCount\
    \ = 0;\n        long maxOnesSumCountCount = 0;\n        long maxZeros\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1qxl_fzj.cs(82,22): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    long min = 0;\n        foreach (long i in arr) {\n            if (i == 1L)\
    \ {\n                ones++;\n            } else {\n                zeros++;\n\
    \            }\n            if (ones > zeros) {\n                max = i;\n  \
    \          } else if (zeros > ones) {\n                min = i;\n            }\n\
    \        }\n        long onesMax = ones == 0 ? 0 : max;\n        long zerosMax\
    \ = zeros == 0 ? 0 : max;\n        long onesMin = ones == 0 ? 0 : min;\n     \
    \   long zerosMin = zeros == 0 ? 0 : min;\n        long onesMaxMin = onesMax <\
    \ onesMin ? onesMax : onesMin;\n        long zerosMaxMin = zerosMax < zerosMin\
    \ ? zerosMax : zerosMin;\n        long onesMaxMinZeros = onesMaxMin < zerosMin\
    \ ? onesMaxMin : zerosMin;\n        long zerosMaxMinZeros = zerosMaxMin < zerosMin\
    \ ? zerosMaxMin : zerosMin;\n        long onesMaxMinZerosZeros = onesMaxMinZeros\
    \ == zerosMin ? onesMaxMinZeros : zerosMin;\n        long zerosMaxMinZerosZeros\
    \ = zerosMaxMinZeros == zerosMin ? zerosMaxMinZeros : zerosMin;\n        long\
    \ onesMaxMinZerosZerosZeros = onesMaxMinZerosZeros == zerosMin ? onesMaxMinZerosZeros\
    \ : zerosMin;\n        long zerosMaxMinZerosZerosZeros = zerosMaxMinZerosZeros\
    \ == zerosMin ? zerosMaxMinZerosZeros : zerosMin;\n        long onesMaxMinZerosZerosZerosZeros\
    \ = onesMaxMinZerosZerosZeros == zerosMin ? onesMaxMinZerosZerosZeros : zerosMin;\n\
    \        long zerosMaxMinZerosZerosZerosZeros = zerosMaxMinZerosZerosZeros ==\
    \ zerosMin ? zerosMaxMinZerosZerosZeros : zerosMin;\n        long onesMaxMinZerosZerosZerosZerosZeros\
    \ = onesMaxMinZerosZerosZerosZeros == zerosMin ? onesMaxMinZerosZerosZerosZeros\
    \ : zerosMin;\n        long zerosMaxMinZerosZer\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgs15xof7.cs(52,33): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ Convert.ToInt64(Math.Pow(2, ones));\n            long zerosMax = Convert.ToInt64(Math.Pow(2,\
    \ zeros));\n            long onesMin = Convert.ToInt64(Math.Pow(2, ones - 1));\n\
    \            long zerosMin = Convert.ToInt64(Math.Pow(2, zeros - 1));\n      \
    \      long onesMax2 = Convert.ToInt64(Math.Pow(2, ones - 1));\n            long\
    \ zerosMax2 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long onesMin2\
    \ = Convert.ToInt64(Math.Pow(2, ones - 1));\n            long zerosMin2 = Convert.ToInt64(Math.Pow(2,\
    \ zeros - 1));\n            long onesMax3 = Convert.ToInt64(Math.Pow(2, ones -\
    \ 1));\n            long zerosMax3 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n\
    \            long onesMin3 = Convert.ToInt64(Math.Pow(2, ones - 1));\n       \
    \     long zerosMin3 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long\
    \ onesMax4 = Convert.ToInt64(Math.Pow(2, ones - 1));\n            long zerosMax4\
    \ = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long onesMin4 = Convert.ToInt64(Math.Pow(2,\
    \ ones - 1));\n            long zerosMin4 = Convert.ToInt64(Math.Pow(2, zeros\
    \ - 1));\n            long onesMax5 = Convert.ToInt64(Math.Pow(2, ones - 1));\n\
    \            long zerosMax5 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n     \
    \       long onesMin5 = Convert.ToInt64(Math.Pow(2, ones - 1));\n            long\
    \ zerosMin5 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long onesMax6\
    \ = Convert.ToInt64(Math.Pow(2, ones - 1));\n            long zerosMax6 = Convert.ToInt64(Math.Pow(2,\
    \ zeros - 1));\n            long onesMin6 = Convert.ToInt64(Math.Pow(2, ones -\
    \ 1));\n            long zerosMin6 = Convert.ToInt64(Math.Pow(2, zeros - 1));\n\
    \            long onesMax7 = Convert.ToInt64(Math.Pow(2, ones - 1));\n\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp721vcjgs.cs(63,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp721vcjgs.cs(74,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  List<long> result = new List<long>();\n        if (onesMax < zerosMax) {\n\
    \            onesMax = zerosMax;\n            zerosMax = maxMax;\n           \
    \ maxMax = max;\n        }\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long maxMin = max;\n        while (onesMin < zerosMin) {\n\
    \            onesMin++;\n            zerosMin++;\n            maxMin++;\n    \
    \    }\n        while (zerosMin < maxMin) {\n            zerosMin++;\n       \
    \     maxMin++;\n        }\n        while (onesMin < zerosMin) {\n           \
    \ onesMin++;\n            zerosMin++;\n            maxMin++;\n        }\n    \
    \    while (zerosMin < maxMin) {\n            zerosMin++;\n            maxMin++;\n\
    \        }\n        while (onesMin < zerosMin) {\n            onesMin++;\n   \
    \         zerosMin++;\n            maxMin++;\n        }\n        while (zerosMin\
    \ < maxMin) {\n            zerosMin++;\n            maxMin++;\n        }\n   \
    \     while (onesMin < zerosMin) {\n            onesMin++;\n            zerosMin++;\n\
    \            maxMin++;\n        }\n        while (zerosMin < maxMin) {\n     \
    \       zerosMin++;\n            maxMin++;\n        }\n        while (onesMin\
    \ < zerosMin) {\n            onesMin++;\n            zerosMin++;\n           \
    \ maxMin++;\n        }\n        while (zerosMin < maxMin) {\n            zerosMin++;\n\
    \            maxMin++;\n        }\n        while (onesMin < zerosMin) {\n    \
    \        onesMin++;\n            zerosMin++;\n            maxMin++;\n        }\n\
    \        while (zerosMin < maxMin) {\n            zerosMin++;\n            maxMin++;\n\
    \        }\n        while (onesMin < zerosMin) {\n            onesMin++;\n   \
    \         zerosMin++;\n            maxMin++;\n        }\n        while (zerosMin\
    \ < maxMin) {\n            zerosMin++;\n            maxMin++;\n        }\n   \
    \     while (onesMin < zerosMin) {\n            onesMin++;\n            zerosMin++;\n\
    \            maxMin++;\n        }\n        while (zerosMin < maxMin) {\n     \
    \       zerosMin++;\n            maxMin++;\n\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjh56frus.cs(119,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpjh56frus.cs(130,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            }\n            if\
    \ (n == 0L) {\n                zeros++;\n            }\n            if (n > max)\
    \ {\n                max = n;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesMax = ones;\n        long zerosMax = zeros;\n\
    \        long maxMax = max;\n        while (onesMax < maxMax) {\n            result.Add(0L);\n\
    \            onesMax++;\n        }\n        while (zerosMax < maxMax) {\n    \
    \        result.Add(1L);\n            zerosMax++;\n        }\n        while (onesMax\
    \ < maxMax) {\n            result.Add(1L);\n            onesMax++;\n        }\n\
    \        while (zerosMax < maxMax) {\n            result.Add(0L);\n          \
    \  zerosMax++;\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <54a091fdcef94d28a82dc9126e01b30f>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <54a091fdcef94d28a82dc9126e01b30f>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            zeros -= i;\n\
    \            if (ones > max) {\n                max = ones;\n            }\n \
    \           if (zeros > max) {\n                max = zeros;\n            }\n\
    \        }\n        long onesMax = max;\n        long zerosMax = max;\n      \
    \  long onesMin = max;\n        long zerosMin = max;\n        foreach (long i\
    \ in arr) {\n            onesMax += i;\n            zerosMax -= i;\n         \
    \   if (onesMax < onesMin) {\n                onesMin = onesMax;\n           \
    \ }\n            if (zerosMax < zerosMin) {\n                zerosMin = zerosMax;\n\
    \            }\n        }\n        long onesMaxMin = onesMax;\n        long zerosMaxMin\
    \ = zerosMax;\n        long onesMinMax = onesMin;\n        long zerosMinMax =\
    \ zerosMin;\n        foreach (long i in arr) {\n            onesMaxMin += i;\n\
    \            zerosMaxMin -= i;\n            if (onesMaxMin > onesMinMax) {\n \
    \               onesMinMax = onesMaxMin;\n            }\n            if (zerosMaxMin\
    \ > zerosMinMax) {\n                zerosMinMax = zerosMaxMin;\n            }\n\
    \        }\n        long onesMaxMinMin = onesMaxMin;\n        long zerosMaxMinMin\
    \ = zerosMaxMin;\n        long onesMinMaxMin = onesMinMax;\n        long zerosMinMaxMin\
    \ = zerosMinMax;\n        foreach (long i in arr) {\n            onesMaxMinMin\
    \ += i;\n            zerosMaxMinMin -= i;\n            if (onesMaxMinMin > onesMinMaxMin)\
    \ {\n                onesMinMaxMin = onesMaxMinMin;\n            }\n         \
    \   if (zerosMaxMinMin > zerosMinMaxMin) {\n                zerosMinMaxMin = zerosMaxMinMin;\n\
    \            }\n        }\n        long onesMaxMinMinMin = onesMaxMinMin;\n  \
    \      long zerosMaxMinMinMin = zerosMaxMinMin;\n        long onesMinMaxMinMin\
    \ = onesMinMaxMin;\n        long zerosMinMaxMinMin = zerosMinMaxMin;\n       \
    \ foreach (long i in arr) {\n            onesMaxMinMinMin += i;\n            zerosMaxMinMinMin\
    \ -= i;\n            if (onesMaxMinMinMin > one\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpicd53mvj.cs(83,39): error CS1026: ) expected

    /tmp/tmpicd53mvj.cs(83,39): error CS1525: Invalid expression term ''}''

    /tmp/tmpicd53mvj.cs(83,39): error CS1002: ; expected

    /tmp/tmpicd53mvj.cs(85,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpicd53mvj.cs(96,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) + 1);\n     \
    \       long zeroesMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2))) - 1);\n            long onesMax2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 1));\n            long zeroesMax2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 1));\n            long onesMax3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 2));\n            long zeroesMax3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 2));\n            long onesMax4 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 3));\n            long zeroesMax4 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 3));\n            long onesMax5 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 4));\n            long zeroesMax5 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 4));\n            long onesMax6 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 5));\n            long zeroesMax6 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 5));\n            long onesMax7 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 6));\n            long zeroesMax7 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 6));\n            long onesMax8 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 7));\n            long zeroesMax8 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) + 7));\n            long onesMax9 = Convert.ToInt\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbtdv5vyy.cs(52,42): error CS1002: ; expected

    /tmp/tmpbtdv5vyy.cs(54,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpbtdv5vyy.cs(65,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros += (long)Math.Abs(i);\n            if (max\
    \ < zeros) {\n                max = zeros;\n            }\n        }\n       \
    \ long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax =\
    \ max;\n        List<long> result = new List<long>();\n        List<long> tmp\
    \ = new List<long>();\n        long onesTmp = 0;\n        long zerosTmp = 0;\n\
    \        long maxTmp = 0;\n        long onesMaxTmp = 0;\n        long zerosMaxTmp\
    \ = 0;\n        long maxMaxTmp = 0;\n        foreach (long i in arr) {\n     \
    \       onesTmp += i;\n            zerosTmp += (long)Math.Abs(i);\n          \
    \  if (maxTmp < zerosTmp) {\n                maxTmp = zerosTmp;\n            }\n\
    \            if (onesTmp > onesMaxTmp) {\n                onesMaxTmp = onesTmp;\n\
    \            }\n            if (zerosTmp > zerosMaxTmp) {\n                zerosMaxTmp\
    \ = zerosTmp;\n            }\n            if (maxTmp > maxMaxTmp) {\n        \
    \        maxMaxTmp = maxTmp;\n            }\n            tmp.Add(i);\n       \
    \ }\n        long onesTmpMax = onesMaxTmp;\n        long zerosTmpMax = zerosMaxTmp;\n\
    \        long maxTmpMax = maxMaxTmp;\n        foreach (long i in tmp) {\n    \
    \        onesTmp -= i;\n            zerosTmp -= (long)Math.Abs(i);\n         \
    \   if (maxTmp < zerosTmp) {\n                maxTmp = zerosTmp;\n           \
    \ }\n            if (onesTmp < onesTmpMax) {\n                onesTmpMax = onesTmp;\n\
    \            }\n            if (zerosTmp < zerosTmpMax) {\n                zerosTmpMax\
    \ = zerosTmp;\n            }\n            if (maxTmp < maxTmpMax) {\n        \
    \        maxTmpMax = maxTmp;\n            }\n        }\n        long onesTmpMaxMax\
    \ = onesTmpMax;\n        long zerosTmpMaxMax = zerosTmpMax;\n        long maxTmpMaxMax\
    \ = maxTmpMax;\n        foreach (long i in tmp) {\n            onesTmpMax -= i;\n\
    \            zerosTmpMax -= (long)\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmprrkgii0_.cs(82,34): error CS1525: Invalid expression term ''}''

    /tmp/tmprrkgii0_.cs(82,34): error CS1002: ; expected

    /tmp/tmprrkgii0_.cs(84,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmprrkgii0_.cs(95,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones < zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n\
    \        }\n        return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <6db09dce2939496693a416bb9aa25324>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <6db09dce2939496693a416bb9aa25324>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_3 (System.Int64 x) [0x00015] in <6db09dce2939496693a416bb9aa25324>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TE"
  stdout: ''
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    List<long> result = new List<long>();\n        long onesMax = ones;\n   \
    \     long zerosMax = zeros;\n        long maxMax = max;\n        long minMin\
    \ = min;\n        long onesMin = ones;\n        long zerosMin = zeros;\n     \
    \   long maxMin = max;\n        long minMax = min;\n        long onesMaxMin =\
    \ ones;\n        long zerosMaxMin = zeros;\n        long maxMaxMin = max;\n  \
    \      long minMinMax = min;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long minMaxMin = min;\n   \
    \     long onesMaxMinMax = ones;\n        long zerosMaxMinMax = zeros;\n     \
    \   long maxMaxMinMax = max;\n        long minMinMaxMin = min;\n        long onesMinMaxMin\
    \ = ones;\n        long zerosMinMaxMin = zeros;\n        long maxMinMaxMin = max;\n\
    \        long minMaxMinMax = min;\n        long onesMaxMinMaxMin = ones;\n   \
    \     long zerosMaxMinMaxMin = zeros;\n        long maxMaxMinMaxMin = max;\n \
    \       long minMinMaxMinMax = min;\n        long onesMinMaxMinMaxMin = ones;\n\
    \        long zerosMinMaxMinMaxMin = zeros;\n        long maxMaxMinMaxMinMax =\
    \ max;\n        long minMinMaxMinMaxMin = min;\n        long onesMinMaxMinMaxMinMax\
    \ = ones;\n        long zerosMinMaxMinMaxMinMax = zeros;\n        long maxMaxMinMaxMinMaxMax\
    \ = max;\n        long minMinMaxMinMaxMinMax = min;\n        long onesMinMaxMinMaxMinMaxMin\
    \ = ones;\n        long zerosMinMaxMinMaxMinMaxMin = zeros;\n        long maxMaxMinMaxMinMaxMinMax\
    \ = max;\n        long minMinMaxMinMaxMinMaxMinMax = min;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2x85xijp.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min;\n        long zerosMin = zeros * min;\n        long onesMaxMin =\
    \ onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMax\
    \ = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax\
    \ = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin * max;\n    \
    \    long onesMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMax\
    \ = zerosMinMax * max;\n        long onesMinMaxMinMaxMin = onesMinMaxMin * min;\n\
    \        long zerosMinMaxMinMax = zerosMinMax * min;\n        long onesMinMaxMinMaxMinMax\
    \ = onesMinMaxMinMax * max;\n        long zerosMinMaxMinMaxMinMax = zerosMinMaxMinMax\
    \ * max;\n        long onesMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n\
    \        long zerosMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n        long\
    \ onesMinMaxMinMaxMinMaxMinMax = onesMinMaxMinMaxMinMax * min;\n        long zerosMinMaxMinMaxMinMaxMinMax\
    \ = zerosMinMaxMinMax * min;\n        long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax\
    \ * min;\n        long zerosMinMaxMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n\
    \        long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n\
    \        long zerosMinMaxMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n     \
    \   long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n   \
    \     long zerosMinMaxMinMaxMinMaxMinMaxMin = \n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp92v3n6nt.cs(59,48): error CS1525: Invalid expression term ''}''

    /tmp/tmp92v3n6nt.cs(59,48): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1);\n        if (ones == 0) return arr;\n        long zeros = arr.Sum(x => ~x);\n\
    \        long maxOnes = arr.Max(x => x & 1);\n        long maxZeros = arr.Max(x\
    \ => ~x);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long maxOnesOnes\
    \ = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n\
    \        long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros\
    \ = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n\
    \        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long\
    \ maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long\
    \ maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnes\
    \ = maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes\
    \ = maxOnesOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes\
    \ = maxOnesOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOne\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7q_6tffp.cs(42,24): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesCount\
    \ = arr.Count(x => x & 1L);\n        long maxZerosCount = arr.Count(x => x >>\
    \ 1);\n        long maxOnesDecimal = arr.Max(x => (long)Math.Pow(2, (int)Math.Log10(x\
    \ & 1L)));\n        long maxZerosDecimal = arr.Max(x => (long)Math.Pow(2, (int)Math.Log10(x\
    \ >> 1)));\n        long maxOnesDecimalCount = arr.Count(x => (long)Math.Pow(2,\
    \ (int)Math.Log10(x & 1L)));\n        long maxZerosDecimalCount = arr.Count(x\
    \ => (long)Math.Pow(2, (int)Math.Log10(x >> 1)));\n        long maxOnesDecimalCount\
    \ = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x & 1L)));\n        long\
    \ maxZerosDecimalCount = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x >>\
    \ 1)));\n        long maxOnesDecimalCount = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x\
    \ & 1L)));\n        long maxZerosDecimalCount = arr.Count(x => (long)Math.Pow(2,\
    \ (int)Math.Log10(x >> 1)));\n        long maxOnesDecimalCount = arr.Count(x =>\
    \ (long)Math.Pow(2, (int)Math.Log10(x & 1L)));\n        long maxZerosDecimalCount\
    \ = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x >> 1)));\n        long\
    \ maxOnesDecimalCount = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x & 1L)));\n\
    \        long maxZerosDecimalCount = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x\
    \ >> 1)));\n        long maxOnesDecimalCount = arr.Count(x => (long)Math.Pow(2,\
    \ (int)Math.Log10(x & 1L)));\n        long maxZerosDecimalCount = arr.Count(x\
    \ => (long)Math.Pow(2, (int)Math.Log10(x >> 1)));\n        long maxOnesDecimalCount\
    \ = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x & 1L)));\n        long\
    \ maxZerosDecimalCount = arr.Count(x => (long)Math.Pow(2, (int)Math.Log10(x >>\
    \ 1)));\n        long maxOnes\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp826ihlab.cs(42,21): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   } else if (i == 0L) {\n                zeros++;\n            } else {\n  \
    \              max = Math.Max(max, i);\n                min = Math.Min(min, i);\n\
    \            }\n        }\n        List<long> result = new List<long>();\n   \
    \     if (ones > zeros) {\n            long onesMax = ones;\n            long\
    \ onesMin = ones;\n            long zeroMax = zeros;\n            long zeroMin\
    \ = zeros;\n            while (onesMax > zeroMax) {\n                result.Add(zeroMin);\n\
    \                onesMax--;\n                zeroMax--;\n            }\n     \
    \       while (onesMin < zeroMin) {\n                result.Add(zeroMax);\n  \
    \              onesMin++;\n                zeroMin++;\n            }\n       \
    \ } else {\n            long zerosMax = zeros;\n            long zerosMin = zeros;\n\
    \            long onesMax = ones;\n            long onesMin = ones;\n        \
    \    while (zerosMax > onesMax) {\n                result.Add(onesMin);\n    \
    \            zerosMax--;\n                onesMax--;\n            }\n        \
    \    while (zerosMin < onesMin) {\n                result.Add(onesMax);\n    \
    \            zerosMin++;\n                onesMin++;\n            }\n        }\n\
    \        return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659794978
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = Convert.ToInt64(Math.Pow(2, ones));\n        long zerosMax\
    \ = Convert.ToInt64(Math.Pow(2, zeros));\n        long maxOnes = Convert.ToInt64(Math.Pow(2,\
    \ max));\n        long minOnes = Convert.ToInt64(Math.Pow(2, min));\n        long\
    \ maxZeros = Convert.ToInt64(Math.Pow(2, maxOnes));\n        long minZeros = Convert.ToInt64(Math.Pow(2,\
    \ minOnes));\n        long maxOnesMax = Convert.ToInt64(Math.Pow(2, maxOnes));\n\
    \        long minOnesMax = Convert.ToInt64(Math.Pow(2, minOnes));\n        long\
    \ maxZerosMax = Convert.ToInt64(Math.Pow(2, maxZeros));\n        long minZerosMax\
    \ = Convert.ToInt64(Math.Pow(2, minZeros));\n        long maxOnesMin = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesMax));\n        long minOnesMin = Convert.ToInt64(Math.Pow(2, minOnesMax));\n\
    \        long maxZerosMin = Convert.ToInt64(Math.Pow(2, maxZerosMax));\n     \
    \   long minZerosMin = Convert.ToInt64(Math.Pow(2, minZerosMax));\n        long\
    \ maxOnesMinMax = Convert.ToInt64(Math.Pow(2, maxOnesMin));\n        long minOnesMinMax\
    \ = Convert.ToInt64(Math.Pow(2, minOnesMin));\n        long maxZerosMinMax = Convert.ToInt64(Math.Pow(2,\
    \ maxZerosMin));\n        long minZerosMinMax = Convert.ToInt64(Math.Pow(2, minZerosMin));\n\
    \        long maxOnesMinMaxMin = Convert.ToInt64(Math.Pow(2, maxOnesMinMax));\n\
    \        long minOnesMinMaxMin = Convert.ToInt64(Math.Pow(2, minOnesMinMax));\n\
    \        long maxZerosMinMaxMin = Convert.ToInt64(Math.Pow(2, maxZerosMinMax));\n\
    \        long minZer\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8p7743de.cs(59,20): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesTwos = maxOnes - twos;\n        long maxOnesThrees = maxOnes - threes;\n\
    \        long maxOnesFours = maxOnes - fours;\n        long maxOnesFives = maxOnes\
    \ - fives;\n        long maxOnesSixes = maxOnes - sixes;\n        long maxOnesSevens\
    \ = maxOnes - sevens;\n        long maxOnesEights = maxOnes - eights;\n      \
    \  long maxOnesNines = maxOnes - nines;\n        long maxOnesTens = maxOnes -\
    \ tens;\n        long maxOnesElevens = maxOnes - elevens;\n        long maxOnesTwelves\
    \ = maxOnes - twelves;\n        long maxOnesThirteens = maxOnes - thirteens;\n\
    \        long maxOnesFourteens = maxOnes - fourteens;\n        long maxOnesFifteens\
    \ = maxOnes - fifteens;\n        long maxOnesSixteens = maxOnes - sixteens;\n\
    \        long maxOnesSeventeens = maxOnes - seventeens;\n        long maxOnesEighteens\
    \ = maxOnes - eighteens;\n        long maxOnesNineteens = maxOnes - nineteens;\n\
    \        long maxOnesTwenty = maxOnes - twenty;\n        long maxOnesThirty =\
    \ maxOnes - thirty;\n        long maxOnesForty = maxOnes - forty;\n        long\
    \ maxOnesFifty = maxOnes - fifty;\n        long maxOnesSixty = maxOnes - sixty;\n\
    \        long maxOnesSeventy = maxOnes - seventy;\n        long maxOnesEighty\
    \ = maxOnes - eighty;\n        long maxOnesNinety = maxOnes - ninety;\n      \
    \  long maxOnesTwentyOnes = maxOnes - twentyOnes;\n        long maxOnesTwenty\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2pguupc0.cs(53,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            }\n            if\
    \ (n == 0L) {\n                zeros++;\n            }\n            if (n > max)\
    \ {\n                max = n;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesMax = ones;\n        long zerosMax = zeros;\n\
    \        long maxMax = max;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long maxMin = max;\n        long onesCur = ones;\n       \
    \ long zerosCur = zeros;\n        long maxCur = max;\n        long onesMaxCur\
    \ = ones;\n        long zerosMaxCur = zeros;\n        long maxMaxCur = max;\n\
    \        long onesMinCur = ones;\n        long zerosMinCur = zeros;\n        long\
    \ maxMinCur = max;\n        long onesCurCur = ones;\n        long zerosCurCur\
    \ = zeros;\n        long maxCurCur = max;\n        long onesMaxCurCur = ones;\n\
    \        long zerosMaxCurCur = zeros;\n        long maxMaxCurCur = max;\n    \
    \    long onesMinCurCur = ones;\n        long zerosMinCurCur = zeros;\n      \
    \  long maxMinCurCur = max;\n        long onesCurCurCur = ones;\n        long\
    \ zerosCurCurCur = zeros;\n        long maxCurCurCur = max;\n        long onesMaxCurCurCur\
    \ = ones;\n        long zerosMaxCurCurCur = zeros;\n        long maxMaxCurCurCur\
    \ = max;\n        long onesMinCurCurCur = ones;\n        long zerosMinCurCurCur\
    \ = zeros;\n        long maxMinCurCurCur = max;\n        long onesCurCurCurCur\
    \ = ones;\n        long zerosCurCurCurCur = zeros;\n        long maxCurCurCurCur\
    \ = max;\n        long onesMaxCurCurCur = ones;\n        long zerosMaxCurCurCur\
    \ = zeros;\n        long maxMaxCurCurCur = max;\n        long onesMinCurCurCur\
    \ = ones;\n        long zerosMinCurCurCur = zeros;\n        long maxMinCurCurCur\
    \ = max;\n        long onesCurCurCurCur = ones;\n        long zerosCurCurCurCur\
    \ = \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwsn1k14r.cs(78,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpwsn1k14r.cs(78,33): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        foreach\
    \ (long i in arr) {\n            ones += i;\n            zeros += (long)Math.Abs(i);\n\
    \            if (i > maxOnes) maxOnes = i;\n            if (i < maxZeros) maxZeros\
    \ = i;\n        }\n        long maxOnesCount = maxOnes - ones;\n        long maxZerosCount\
    \ = maxZeros - zeros;\n        long maxCount = Math.Max(maxOnesCount, maxZerosCount);\n\
    \        long onesCount = ones - maxOnes;\n        long zerosCount = zeros - maxZeros;\n\
    \        long count = Math.Max(onesCount, zerosCount);\n        long onesCount2\
    \ = ones - maxOnesCount;\n        long zerosCount2 = zeros - maxZerosCount;\n\
    \        long count2 = Math.Max(onesCount2, zerosCount2);\n        long onesCount3\
    \ = ones - maxCount;\n        long zerosCount3 = zeros - maxCount;\n        long\
    \ count3 = Math.Max(onesCount3, zerosCount3);\n        long onesCount4 = ones\
    \ - count;\n        long zerosCount4 = zeros - count;\n        long count4 = Math.Max(onesCount4,\
    \ zerosCount4);\n        long onesCount5 = ones - count2;\n        long zerosCount5\
    \ = zeros - count2;\n        long count5 = Math.Max(onesCount5, zerosCount5);\n\
    \        long onesCount6 = ones - count3;\n        long zerosCount6 = zeros -\
    \ count3;\n        long count6 = Math.Max(onesCount6, zerosCount6);\n        long\
    \ onesCount7 = ones - count4;\n        long zerosCount7 = zeros - count4;\n  \
    \      long count7 = Math.Max(onesCount7, zerosCount7);\n        long onesCount8\
    \ = ones - count5;\n        long zerosCount8 = zeros - count5;\n        long count8\
    \ = Math.Max(onesCount8, zerosCount8);\n        long onesCount9 = ones - count6;\n\
    \        long zerosCount9 = zeros - count6;\n        long count9 = Math.Max(onesCount9,\
    \ zerosCount9);\n        long onesCount10 = ones - count7;\n        long zerosCount10\
    \ = zeros - count7;\n        long count10 = Math.Max(onesCount10, zerosCount10);\n\
    \        long onesCount11 = ones - count8;\n        long zerosCount11 = zeros\
    \ - count8;\n        long count11 = Math.Max(onesCount11, \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpq2_sbg75.cs(65,45): error CS1525: Invalid expression term ''}''

    /tmp/tmpq2_sbg75.cs(65,45): error CS1026: ) expected

    /tmp/tmpq2_sbg75.cs(65,45): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            if (i == 1L)\
    \ {\n                zeros++;\n            }\n            if (i == 0L) {\n   \
    \             zeros++;\n            }\n            if (i == -1L) {\n         \
    \       zeros++;\n            }\n            if (i == -2L) {\n               \
    \ zeros++;\n            }\n            if (i == -3L) {\n                zeros++;\n\
    \            }\n            if (i == -4L) {\n                zeros++;\n      \
    \      }\n            if (i == -5L) {\n                zeros++;\n            }\n\
    \            if (i == -6L) {\n                zeros++;\n            }\n      \
    \      if (i == -7L) {\n                zeros++;\n            }\n            if\
    \ (i == -8L) {\n                zeros++;\n            }\n            if (i ==\
    \ -9L) {\n                zeros++;\n            }\n            if (i == -10L)\
    \ {\n                zeros++;\n            }\n            if (i == -11L) {\n \
    \               zeros++;\n            }\n            if (i == -12L) {\n      \
    \          zeros++;\n            }\n            if (i == -13L) {\n           \
    \     zeros++;\n            }\n            if (i == -14L) {\n                zeros++;\n\
    \            }\n            if (i == -15L) {\n                zeros++;\n     \
    \       }\n            if (i == -16L) {\n                zeros++;\n          \
    \  }\n            if (i == -17L) {\n                zeros++;\n            }\n\
    \            if (i == -18L) {\n                zeros++;\n            }\n     \
    \       if (i == -19L) {\n                zeros++;\n            }\n          \
    \  if (i == -20L) {\n                zeros++;\n            }\n            if (i\
    \ == -21L) {\n                zeros++;\n            }\n            if (i == -22L)\
    \ {\n                zeros++;\n            }\n            if (i == -23L) {\n \
    \               zeros++;\n            }\n            if (i == -24L) {\n      \
    \          zeros++;\n            }\n            if (i == -25L) {\n           \
    \     zeros++;\n            }\n            if (i == -26L) {\n                zeros++;\n\
    \            }\n            if (i == -27L) {\n                zeros++;\n     \
    \       }\n            if (i == -28L) {\n                zeros++;\n          \
    \  }\n            if (i == -29L) {\n                zeros++;\n            }\n\
    \            if (i == -30L) {\n                zeros++;\n            }\n     \
    \       if (i == -31L) {\n                zeros++;\n            }\n          \
    \  if (i == -32L) {\n                zeros++;\n            }\n            if (i\
    \ == -33L) {\n                zeros++;\n            }\n            if (i == -34L)\
    \ {\n                zeros++;\n            }\n            if (i == -35L) {\n \
    \               zeros++;\n            }\n            if (i == -36L) {\n      \
    \          zeros++;\n            }\n            if (i == -37\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3r_lnnee.cs(140,25): error CS1026: ) expected

    /tmp/tmp3r_lnnee.cs(140,25): error CS1525: Invalid expression term ''}''

    /tmp/tmp3r_lnnee.cs(140,25): error CS1002: ; expected

    /tmp/tmp3r_lnnee.cs(142,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp3r_lnnee.cs(153,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ ones;\n            long zerosMax = zeros;\n            while (onesMax > zerosMax)\
    \ {\n                result.Add(max);\n                zerosMax--;\n         \
    \   }\n            while (zerosMax > onesMax) {\n                result.Add(max);\n\
    \                onesMax--;\n            }\n            while (onesMax < zerosMax)\
    \ {\n                result.Add(max);\n                onesMax++;\n          \
    \  }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n\
    \                zerosMax++;\n            }\n        }\n        if (ones < zeros)\
    \ {\n            long onesMax = ones;\n            long zerosMax = zeros;\n  \
    \          while (onesMax > zerosMax) {\n                result.Add(max);\n  \
    \              zerosMax--;\n            }\n            while (zerosMax > onesMax)\
    \ {\n                result.Add(max);\n                onesMax--;\n          \
    \  }\n            while (onesMax < zerosMax) {\n                result.Add(max);\n\
    \                onesMax++;\n            }\n            while (zerosMax < onesMax)\
    \ {\n                result.Add(max);\n                zerosMax++;\n         \
    \   }\n        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659794979
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Where(x => x\
    \ != 0).Count();\n        long zeros = arr.Where(x => x == 0).Count();\n     \
    \   long maxOnes = arr.Where(x => x == 1).Count();\n        long maxZeros = arr.Where(x\
    \ => x == 0).Count();\n        long maxOnesZeros = arr.Where(x => x == 1 && x\
    \ == 0).Count();\n        long maxOnesOnes = arr.Where(x => x == 1 && x == 1).Count();\n\
    \        long maxOnesTwos = arr.Where(x => x == 1 && x == 2).Count();\n      \
    \  long maxOnesThrees = arr.Where(x => x == 1 && x == 3).Count();\n        long\
    \ maxOnesFours = arr.Where(x => x == 1 && x == 4).Count();\n        long maxOnesFives\
    \ = arr.Where(x => x == 1 && x == 5).Count();\n        long maxOnesSixes = arr.Where(x\
    \ => x == 1 && x == 6).Count();\n        long maxOnesSevens = arr.Where(x => x\
    \ == 1 && x == 7).Count();\n        long maxOnesEights = arr.Where(x => x == 1\
    \ && x == 8).Count();\n        long maxOnesNines = arr.Where(x => x == 1 && x\
    \ == 9).Count();\n        long maxOnesTens = arr.Where(x => x == 1 && x == 10).Count();\n\
    \        long maxOnesElevens = arr.Where(x => x == 1 && x == 11).Count();\n  \
    \      long maxOnesTwelves = arr.Where(x => x == 1 && x == 12).Count();\n    \
    \    long maxOnesThirteens = arr.Where(x => x == 1 && x == 13).Count();\n    \
    \    long maxOnesFourteens = arr.Where(x => x == 1 && x == 14).Count();\n    \
    \    long maxOnesFifteens = arr.Where(x => x == 1 && x == 15).Count();\n     \
    \   long maxOnesSixteens = arr.Where(x => x == 1 && x == 16).Count();\n      \
    \  long maxOnesSeventeens = arr.Where(x => x == 1 && x == 17).Count();\n     \
    \   long maxOnesEighteens = arr.Where(x => x == 1 && x == 18).Count();\n     \
    \   long maxOnesNineteens = arr.Where(x => x == 1 && x == 19).Count();\n     \
    \   long maxOnesTwenty = arr.Where(x => x == 1 && x == 20).Count();\n        long\
    \ maxOnesTwentyOnes = arr.Where(x => x == \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw7ci0dl_.cs(45,53): error CS1525: Invalid expression term ''}''

    /tmp/tmpw7ci0dl_.cs(45,53): error CS1026: ) expected

    /tmp/tmpw7ci0dl_.cs(45,53): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesZeros = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesZeroOnes = maxOnes - ones - zeros - ones;\n        long\
    \ maxOnesZeroOnesOnes = maxOnes - zeros - ones - ones;\n        long maxOnesOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - ones - zeros - ones;\n        long maxOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - ones;\n        long maxOnesZeroOnesOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - ones - zeros - ones - ones - ones;\n        long\
    \ maxOnesOnesZeroOnesZeroOnesZeroOnesOnes = maxOnes - ones - zeros - ones - zeros\
    \ - ones - zeros - ones - ones - ones;\n        long maxOnesZeroOnesZeroOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - ones - zeros - ones\
    \ - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones\
    \ - zeros - ones - ones - ones;\n        long maxOnesZeroOnesOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros\
    \ - ones - zeros - ones - zeros - ones - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnesZeroOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvc7y7e0d.cs(39,57): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        if (i == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            int onesIndex = arr.FindIndex(i => i\
    \ == 1L);\n            int zerosIndex = arr.FindIndex(i => i == 0L);\n       \
    \     int onesCount = ones - zeros;\n            int zerosCount = zeros - ones;\n\
    \            int minOnesIndex = onesIndex - zerosCount;\n            int minZeroIndex\
    \ = zerosIndex + onesCount;\n            int minOnesCount = minOnesIndex - minZeroIndex;\n\
    \            int minZeroCount = minZeroIndex + minOnesCount;\n            int\
    \ minOnesIndex = Math.Min(minOnesIndex, arr.Count - 1);\n            int minZeroIndex\
    \ = Math.Min(minZeroIndex, arr.Count - 1);\n            int minOnesCount = Math.Min(minOnesCount,\
    \ arr.Count - minZeroIndex);\n            int minZeroCount = Math.Min(minZeroCount,\
    \ arr.Count - minOnesIndex);\n            int minOnesIndex = Math.Max(minOnesIndex,\
    \ 0);\n            int minZeroIndex = Math.Max(minZeroIndex, 0);\n           \
    \ int minOnesCount = Math.Max(minOnesCount, 0);\n            int minZeroCount\
    \ = Math.Max(minZeroCount, 0);\n            int minOnesIndex = Math.Max(minOnesIndex,\
    \ 0);\n            int minZeroIndex = Math.Max(minZeroIndex, 0);\n           \
    \ int minOnesCount = Math.Max(minOnesCount, 0);\n            int minZeroCount\
    \ = Math.Max(minZeroCount, 0);\n            int minOnesIndex = Math.Max(minOnesIndex,\
    \ 0);\n            int minZeroIndex = Math.Max(minZeroIndex, 0);\n           \
    \ int minOnesCount = Math.Max(minOnesCount, 0);\n            int minZeroCount\
    \ = Math.Max(minZeroCount, 0);\n            int minOnesIndex = Math.Max(minOnesIndex,\
    \ 0);\n            int minZeroIndex = Math.Max(minZeroIndex, 0);\n           \
    \ int minOnesCount = Math.Max(minOnesCount, 0);\n            int minZeroCount\
    \ = Math.Max(minZeroCount, 0);\n            int minOnesIndex = Math.Max(minOnesIndex,\
    \ 0);\n            int minZeroIndex = Math.Max(minZeroIndex, 0);\n           \
    \ int minOnesCount = Math.Max(minOnesCount, 0);\n            int minZeroCount\
    \ = Math.Max(minZeroCount, 0);\n            int minOnesIndex = \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7dkld9n.cs(64,31): error CS1525: Invalid expression term ''}''

    /tmp/tmpc7dkld9n.cs(64,31): error CS1002: ; expected

    /tmp/tmpc7dkld9n.cs(66,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpc7dkld9n.cs(77,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n        long\
    \ zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax\
    \ = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n\
    \        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n   \
    \     long zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n       \
    \ long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n        long\
    \ zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax\
    \ = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n\
    \        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n   \
    \     long zerosMinMaxMax = zeros;\n        long maxMinMaxMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0_87f71_.cs(78,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long zeros = arr.Sum(x =>\
    \ x & 0L);\n        long maxOnes = ones;\n        long maxZeros = zeros;\n   \
    \     long maxDiff = maxOnes - maxZeros;\n        long maxDiffIndex = arr.Count\
    \ - 1;\n        long maxDiffIndex2 = arr.Count - 2;\n        long maxDiffIndex3\
    \ = arr.Count - 3;\n        long maxDiffIndex4 = arr.Count - 4;\n        long\
    \ maxDiffIndex5 = arr.Count - 5;\n        long maxDiffIndex6 = arr.Count - 6;\n\
    \        long maxDiffIndex7 = arr.Count - 7;\n        long maxDiffIndex8 = arr.Count\
    \ - 8;\n        long maxDiffIndex9 = arr.Count - 9;\n        long maxDiffIndex10\
    \ = arr.Count - 10;\n        long maxDiffIndex11 = arr.Count - 11;\n        long\
    \ maxDiffIndex12 = arr.Count - 12;\n        long maxDiffIndex13 = arr.Count -\
    \ 13;\n        long maxDiffIndex14 = arr.Count - 14;\n        long maxDiffIndex15\
    \ = arr.Count - 15;\n        long maxDiffIndex16 = arr.Count - 16;\n        long\
    \ maxDiffIndex17 = arr.Count - 17;\n        long maxDiffIndex18 = arr.Count -\
    \ 18;\n        long maxDiffIndex19 = arr.Count - 19;\n        long maxDiffIndex20\
    \ = arr.Count - 20;\n        long maxDiffIndex21 = arr.Count - 21;\n        long\
    \ maxDiffIndex22 = arr.Count - 22;\n        long maxDiffIndex23 = arr.Count -\
    \ 23;\n        long maxDiffIndex24 = arr.Count - 24;\n        long maxDiffIndex25\
    \ = arr.Count - 25;\n        long maxDiffIndex26 = arr.Count - 26;\n        long\
    \ maxDiffIndex27 = arr.Count - 27;\n        long maxDiffIndex28 = arr.Count -\
    \ 28;\n        long maxDiffIndex29 = arr.Count - 29;\n        long maxDiffIndex30\
    \ = arr.Count - 30;\n        long maxDiffIndex31 = arr.Count - 31;\n        long\
    \ maxDiffIndex32 = arr.Count - 32;\n        long maxDiffIndex33 = arr.Count -\
    \ 33;\n        long maxDiffIndex34 = arr.Count - 34;\n        long maxDiffIndex35\
    \ = arr.Count - 35;\n        long maxDiffIndex36 = arr.Count - 36;\n        long\
    \ maxDiffIndex37 = \n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6tvk5nh6.cs(62,30): error CS1525: Invalid expression term ''}''

    /tmp/tmp6tvk5nh6.cs(62,30): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesOnesZeros = maxOnesOnes - maxZeros;\n        long maxOnesOnesOnes = maxOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesZeros = maxOnesOnesOnes - maxZeros;\n \
    \       long maxOnesOnesOnesOnes = maxOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros -\
    \ maxZeros;\n        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesZeros -\
    \ ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnes - maxZeros;\n\
    \        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesZeros - ones;\n\
    \        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesOnes - maxZeros;\n\
    \        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnesZeros -\
    \ ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesOnesOnes\
    \ - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnwf9cc4q.cs(40,72): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n\
    \            }\n            if (i == 0L) {\n                zeros++;\n       \
    \     }\n            if (i == max) {\n                max = i;\n            }\n\
    \        }\n        long onesMax = ones;\n        long zerosMax = zeros;\n   \
    \     long maxMax = max;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long maxMin = max;\n        while (onesMax < zerosMax && onesMin\
    \ > zerosMin && maxMin > maxMax) {\n            if (arr[onesMax] == 1L) {\n  \
    \              onesMax++;\n            }\n            if (arr[zerosMax] == 0L)\
    \ {\n                zerosMax++;\n            }\n            if (arr[maxMax] ==\
    \ max) {\n                maxMax++;\n            }\n            if (arr[onesMin]\
    \ == 1L) {\n                onesMin--;\n            }\n            if (arr[zerosMin]\
    \ == 0L) {\n                zerosMin--;\n            }\n            if (arr[maxMin]\
    \ == max) {\n                maxMin--;\n            }\n        }\n        if (onesMax\
    \ < zerosMax) {\n            while (onesMax < zerosMax && onesMin > zerosMin)\
    \ {\n                if (arr[onesMax] == 1L) {\n                    onesMax++;\n\
    \                }\n                if (arr[zerosMax] == 0L) {\n             \
    \       zerosMax++;\n                }\n                if (arr[onesMin] == 1L)\
    \ {\n                    onesMin--;\n                }\n                if (arr[zerosMin]\
    \ == 0L) {\n                    zerosMin--;\n                }\n            }\n\
    \        }\n        if (onesMax < zerosMax) {\n            while (onesMax < zerosMax\
    \ && maxMin > maxMax) {\n                if (arr[onesMax] == 1L) {\n         \
    \           onesMax++;\n                }\n                if (arr[zerosMax] ==\
    \ 0L) {\n                    zerosMax++;\n                }\n                if\
    \ (arr[maxMin] == max) {\n                    maxMin--;\n                }\n \
    \           }\n        }\n        if (onesMax < zerosMax) {\n            while\
    \ (onesMax < zerosMax && onesMin > zerosMin) {\n                if (arr[onesMax]\
    \ == 1L) {\n                    onesMax++;\n                }\n              \
    \  if (arr[zerosMax] == 0L) {\n                    zerosMax++;\n             \
    \   }\n                if (arr[onesMin] == 1L) {\n                    onesMin--;\n\
    \                }\n                if (arr[zerosMin] == 0L) {\n             \
    \       zerosMin--;\n                }\n\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpczkct4d8.cs(106,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpczkct4d8.cs(117,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x\
    \ & 1L) + 1)))).ToList();\n        } else {\n            return arr.OrderBy(x\
    \ => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x & 0L) + 1)))).ToList();\n\
    \        }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.OverflowException: Value was either too\
    \ large or too small for an Int32.\n  at System.Convert.ToInt32 (System.Double\
    \ value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem+<>c.<SortArray>b__0_2\
    \ (System.Int64 x) [0x00013] in <90576e1419ed445da1af9d1eca0458a8>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys\
    \ (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1[TElement].ToList () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.Enumerable.ToList[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.SortArray\
    \ (System.Collections.Generic.List`1[T] arr) [0x0007b] in <90576e1419ed445da1af9d1eca0458a8>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00017] in <90576e1419ed445da1af9d1eca0458a8>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.OverflowException: Value was either\
    \ too large or too small for an Int32.\n  at System.Convert.ToInt32 (System.Double\
    \ value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem+<>c.<SortArray>b__0_2\
    \ (System.Int64 x) [0x00013] in <90576e1419ed445da1af9d1eca0458a8>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys\
    \ (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TE"
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        if (ones\
    \ == maxOnes && zeros == maxZeros)\n            return arr;\n        if (ones\
    \ == maxOnes)\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log10(x) + 1)))).ToList();\n        if (zeros == maxZeros)\n\
    \            return arr.OrderByDescending(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x)\
    \ + 1)))).ToList();\n        if (ones == maxOnes && zeros == maxZeros)\n     \
    \       return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x)\
    \ + 1)))).ToList();\n        if (ones == maxOnes)\n            return arr.OrderByDescending(x\
    \ => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x) + 1)))).ToList();\n\
    \        if (zeros == maxZeros)\n            return arr.OrderByDescending(x =>\
    \ Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x) + 1)))).ToList();\n\
    \        return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x)\
    \ + 1)))).ToList();\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <dd4aa73b965744b6b3e4be80bc551c79>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_9 (System.Int64 x) [0x00010] in <dd4aa73b965744b6b3e4be80bc551c79>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[]\
    \ elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1[TElement].ToList () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.Enumerable.ToList[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.SortArray\
    \ (System.Colle"
  stdout: ''
  timestamp: 1659794974
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) {\n                ones++;\n            }\n          \
    \  if (num == 0) {\n                zeros++;\n            }\n            if (num\
    \ > max) {\n                max = num;\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        if (ones > zeros) {\n            long onesMax\
    \ = ones;\n            long zerosMax = zeros;\n            long maxOnes = max;\n\
    \            long maxZeros = max;\n            while (onesMax < zerosMax) {\n\
    \                result.Add(maxOnes);\n                onesMax--;\n          \
    \      zerosMax--;\n                maxOnes--;\n                maxZeros--;\n\
    \            }\n            while (zerosMax < onesMax) {\n                result.Add(maxZeros);\n\
    \                zerosMax--;\n                onesMax--;\n                maxZeros--;\n\
    \                maxOnes--;\n            }\n        }\n        if (ones < zeros)\
    \ {\n            long onesMin = ones;\n            long zerosMin = zeros;\n  \
    \          long minOnes = max;\n            long minZeros = max;\n           \
    \ while (onesMin > zerosMin) {\n                result.Add(minOnes);\n       \
    \         onesMin--;\n                zerosMin--;\n                minOnes--;\n\
    \                minZeros--;\n            }\n            while (zerosMin > onesMin)\
    \ {\n                result.Add(minZeros);\n                zerosMin--;\n    \
    \            onesMin--;\n                minZeros--;\n                minOnes--;\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659794978
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        if (ones > zeros)\
    \ {\n            arr = arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n\
    \        } else {\n            arr = arr.OrderByDescending(x => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n        }\n        return arr;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwp93qmzd.cs(23,19): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    /tmp/tmpwp93qmzd.cs(25,19): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones > zeros ? ones : zeros;\n        long zerosMax = zeros > ones ? zeros\
    \ : ones;\n        long maxMax = max > onesMax ? max : onesMax;\n        long\
    \ maxMin = max < zerosMax ? max : zerosMax;\n        long minMax = max > maxMax\
    \ ? max : maxMax;\n        long minMin = max < minMax ? max : minMax;\n      \
    \  long minMinMin = min < minMin ? min : minMin;\n        long minMinMinMin =\
    \ min < minMinMin ? min : minMinMin;\n        long minMinMinMinMin = min < minMinMinMin\
    \ ? min : minMinMinMin;\n        long minMinMinMinMinMin = min < minMinMinMinMin\
    \ ? min : minMinMinMinMin;\n        long minMinMinMinMinMinMin = min < minMinMinMinMinMin\
    \ ? min : minMinMinMinMinMin;\n        long minMinMinMinMinMinMin = min < minMinMinMinMinMinMin\
    \ ? min : minMinMinMinMinMinMin;\n        long minMinMinMinMinMinMin = min < minMinMinMinMinMinMinMin\
    \ ? min : minMinMinMinMinMinMinMin;\n        long minMinMinMinMinMinMinMin = min\
    \ < minMinMinMinMinMinMinMin ? min : minMinMinMinMinMinMinMin;\n        long minMinMinMinMinMinMinMin\
    \ = min < minMinMinMinMinMinMinMinMin ? min : minMinMinMinMinMinMinMinMin;\n \
    \       long minMinMinMinMinMinMinMin = min < minMinMinMinMinMinMinMinMin ? min\
    \ : minMinMinMinMinMinMinMin;\n        long minMinMinMinMinMinMinMin = min < minMinMinMinMinMinMinMinMin\
    \ ? min : minMinMinMinMinMinMinMinMin;\n        long minMinMinMinMinMinMinMin\
    \ = min < minMinMinMinMinMinMinMinMin ? min : minMinMinMinMinMinMinMinMin;\n \
    \       \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9izcci9w.cs(40,26): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(40,41): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(41,29): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(41,47): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(42,32): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(42,53): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(43,35): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(43,59): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(44,38): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(44,65): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(45,14): error CS0128: A local variable or function named ''minMinMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmp9izcci9w.cs(45,38): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(45,68): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(46,14): error CS0128: A local variable or function named ''minMinMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmp9izcci9w.cs(46,38): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(46,44): error CS0841: Cannot use local variable ''minMinMinMinMinMinMinMin''
    before it is declared

    /tmp/tmp9izcci9w.cs(46,71): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmp9izcci9w.cs(46,77): error CS0841: Cannot use local variable ''minMinMinMinMinMinMinMin''
    before it is declared

    /tmp/tmp9izcci9w.cs(47,41): error CS0103: The name ''min'' does not exist in the
    current co'
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) ones++;\n            else if (num == 0) zeros++;\n   \
    \         else if (num > max) max = num;\n        }\n        if (ones > zeros)\
    \ {\n            long temp = ones;\n            ones = zeros;\n            zeros\
    \ = temp;\n        }\n        long onesCount = 0;\n        long zerosCount = 0;\n\
    \        long maxCount = 0;\n        long temp = 0;\n        foreach (long num\
    \ in arr) {\n            if (num == 1) onesCount++;\n            else if (num\
    \ == 0) zerosCount++;\n            else if (num > maxCount) maxCount = num;\n\
    \        }\n        long onesCountTemp = 0;\n        long zerosCountTemp = 0;\n\
    \        long maxCountTemp = 0;\n        long temp2 = 0;\n        foreach (long\
    \ num in arr) {\n            if (num == 1) onesCountTemp++;\n            else\
    \ if (num == 0) zerosCountTemp++;\n            else if (num > maxCountTemp) maxCountTemp\
    \ = num;\n        }\n        long onesCountTemp2 = 0;\n        long zerosCountTemp2\
    \ = 0;\n        long maxCountTemp2 = 0;\n        long temp3 = 0;\n        foreach\
    \ (long num in arr) {\n            if (num == 1) onesCountTemp2++;\n         \
    \   else if (num == 0) zerosCountTemp2++;\n            else if (num > maxCountTemp2)\
    \ maxCountTemp2 = num;\n        }\n        long onesCountTemp3 = 0;\n        long\
    \ zerosCountTemp3 = 0;\n        long maxCountTemp3 = 0;\n        long temp4 =\
    \ 0;\n        foreach (long num in arr) {\n            if (num == 1) onesCountTemp3++;\n\
    \            else if (num == 0) zerosCountTemp3++;\n            else if (num >\
    \ maxCountTemp3) maxCountTemp3 = num;\n        }\n        long onesCountTemp4\
    \ = 0;\n        long zerosCountTemp4 = 0;\n        long maxCountTemp4 = 0;\n \
    \       long temp5 = 0;\n        foreach (long num in arr) {\n            if (num\
    \ == 1) onesCountTemp4++;\n            else if (num == 0) zerosCountTemp4++;\n\
    \            else if (num > maxCountTemp4) maxCountTemp4 = num;\n        }\n \
    \       long onesCountTemp5 = 0;\n        long zerosCountTemp5 = 0;\n        long\
    \ maxCountTemp5 = 0;\n        long temp6 = 0;\n        foreach (long num in arr)\
    \ {\n            if (num == 1) onesCountTemp5++;\n            else if (num ==\
    \ 0) zerosCountTemp5++;\n            else if (num > maxCountTemp5) maxCountTemp5\
    \ = num;\n        }\n        long \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdkgqds21.cs(87,13): error CS1001: Identifier expected

    /tmp/tmpdkgqds21.cs(87,13): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) ones++;\n            else if (num == 0) zeros++;\n   \
    \         else if (num > max) max = num;\n        }\n        long onesMax = ones\
    \ == 0 ? 0 : ones == 1 ? max : ones * max;\n        long zerosMax = zeros == 0\
    \ ? 0 : zeros == 1 ? max : zeros * max;\n        long onesMin = ones == 0 ? 0\
    \ : ones == 1 ? max : ones * max;\n        long zerosMin = zeros == 0 ? 0 : zeros\
    \ == 1 ? max : zeros * max;\n        long onesMaxMin = onesMax == 0 ? 0 : onesMax\
    \ == 1 ? max : onesMax * max;\n        long zerosMaxMin = zerosMax == 0 ? 0 :\
    \ zerosMax == 1 ? max : zerosMax * max;\n        long onesMinMin = onesMin ==\
    \ 0 ? 0 : onesMin == 1 ? max : onesMin * max;\n        long zerosMinMin = zerosMin\
    \ == 0 ? 0 : zerosMin == 1 ? max : zerosMin * max;\n        long onesMaxMinMin\
    \ = onesMaxMin == 0 ? 0 : onesMaxMin == 1 ? max : onesMaxMin * max;\n        long\
    \ zerosMaxMinMin = zerosMaxMin == 0 ? 0 : zerosMaxMin == 1 ? max : zerosMaxMin\
    \ * max;\n        long onesMinMinMin = onesMinMin == 0 ? 0 : onesMinMin == 1 ?\
    \ max : onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin == 0 ? 0\
    \ : zerosMinMin == 1 ? max : zerosMinMin * max;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin == 0 ? 0 : onesMaxMinMin == 1 ? max : onesMaxMinMin * max;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin == 0 ? 0 : zerosMaxMinMin ==\
    \ 1 ? max : zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin\
    \ == 0 ? 0 : onesMinMinMin == 1 ? max : onesMinMinMin * max;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin == 0 ? 0 : zerosMinMinMin == 1 ? max : zerosMinMinMin * max;\n\
    \        long onesMaxMinMinMin = onesMaxMinMinMin == 0 ? 0 : onesMaxMinMinMin\
    \ == 1 ? max : onesMaxMinMinMin * \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9qcs5wz8.cs(44,109): error CS1525: Invalid expression term ''}''

    /tmp/tmp9qcs5wz8.cs(44,109): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(max);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(i);\n                }\n  \
    \              else {\n                    result.Add(max);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesOnes = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesZeroOnes = maxOnes - ones - zeros - ones;\n        long\
    \ maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - zeros;\n        long maxOnesOnesZeroOnesOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros;\n        long maxOnesZeroOnesOnesOnesZeros\
    \ = maxOnes - zeros - ones - zeros - ones;\n        long maxOnesOnesZeroOnesOnesOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros - ones;\n        long maxOnesZeroOnesOnesOnesOnesZeros\
    \ = maxOnes - zeros - ones - zeros - ones - ones - zeros;\n        long maxOnesOnesZeroOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros - ones - ones - zeros;\n        long\
    \ maxOnesZeroOnesOnesOnesOnesOnesOnesZeros = maxOnes - zeros - ones - zeros -\
    \ ones - ones - ones - ones - zeros;\n        long maxOnesOnesZeroOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros - ones - ones - ones - ones - zeros;\n\
    \        long maxOnesZeroOnesOnesOnesOnesOnesOnesOnesZeros = maxOnes - zeros -\
    \ ones - zeros - ones - ones - ones - ones - ones - ones - zeros;\n        long\
    \ maxOnesOnesZeroOnesOnesOnesOnesOnesOnesOnesZeros = maxOnes - ones - zeros -\
    \ ones - zeros - ones - ones - ones - ones - ones - ones - zeros;\n        long\
    \ \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzxhk1d_s.cs(40,13): error CS1001: Identifier expected

    /tmp/tmpzxhk1d_s.cs(40,13): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n        \
    \    if (i == 1L) {\n                onesCount++;\n            }\n           \
    \ if (i == 0L) {\n                zerosCount++;\n            }\n            if\
    \ (i > max) {\n                maxCount++;\n            }\n        }\n       \
    \ if (onesCount > zerosCount) {\n            long onesCount2 = zerosCount - onesCount;\n\
    \            long zerosCount2 = onesCount - zerosCount;\n            long maxCount2\
    \ = onesCount2 - zerosCount2;\n            long maxCount3 = maxCount2 + maxCount;\n\
    \            long maxCount4 = maxCount3 + maxCount;\n            long maxCount5\
    \ = maxCount4 + maxCount;\n            long maxCount6 = maxCount5 + maxCount;\n\
    \            long maxCount7 = maxCount6 + maxCount;\n            long maxCount8\
    \ = maxCount7 + maxCount;\n            long maxCount9 = maxCount8 + maxCount;\n\
    \            long maxCount10 = maxCount9 + maxCount;\n            long maxCount11\
    \ = maxCount10 + maxCount;\n            long maxCount12 = maxCount11 + maxCount;\n\
    \            long maxCount13 = maxCount12 + maxCount;\n            long maxCount14\
    \ = maxCount13 + maxCount;\n            long maxCount15 = maxCount14 + maxCount;\n\
    \            long maxCount16 = maxCount15 + maxCount;\n            long maxCount17\
    \ = maxCount16 + maxCount;\n            long maxCount18 = maxCount17 + maxCount;\n\
    \            long maxCount19 = maxCount18 + maxCount;\n            long maxCount20\
    \ = maxCount19 + maxCount;\n            long maxCount21 = maxCount20 + maxCount;\n\
    \            long maxCount22 = maxCount21 + maxCount;\n            long maxCount23\
    \ = maxCount22 + maxCount;\n            long maxCount24 = maxCount23 + maxCount;\n\
    \            long maxCount25 = maxCount24 + maxCount;\n            long maxCount26\
    \ = maxCount25 + maxCount;\n            long max\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe1msrlg3.cs(77,21): error CS1002: ; expected

    /tmp/tmpe1msrlg3.cs(79,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpe1msrlg3.cs(90,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(x))))).ToList();\n\
    \        }\n        return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(x))))).ThenBy(x\
    \ => x).ToList();\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <4e3f2e841f014aceb628947dc1d41541>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_2 (System.Int64 x) [0x00010] in <4e3f2e841f014aceb628947dc1d41541>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[]\
    \ elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1[TElement].ToList () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.Enumerable.ToList[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.SortArray\
    \ (System.Colle"
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long\
    \ maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n     \
    \   long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n  \
    \      long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuaviubh3.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxZeros - maxOnes;\n    \
    \    long maxOnesTwos = maxOnes - maxOnesOnes;\n        long maxOnesThrees = maxOnes\
    \ - maxOnesTwos;\n        long maxOnesFours = maxOnes - maxOnesThrees;\n     \
    \   long maxOnesFives = maxOnes - maxOnesFours;\n        long maxOnesSixes = maxOnes\
    \ - maxOnesFives;\n        long maxOnesSevens = maxOnes - maxOnesSixes;\n    \
    \    long maxOnesEights = maxOnes - maxOnesSevens;\n        long maxOnesNines\
    \ = maxOnes - maxOnesEights;\n        long maxOnesTens = maxOnes - maxOnesNines;\n\
    \        long maxOnesElevens = maxOnes - maxOnesTens;\n        long maxOnesTwelves\
    \ = maxOnes - maxOnesElevens;\n        long maxOnesThirteens = maxOnes - maxOnesTwelves;\n\
    \        long maxOnesFourteens = maxOnes - maxOnesThirteens;\n        long maxOnesFifteens\
    \ = maxOnes - maxOnesFourteens;\n        long maxOnesSixteens = maxOnes - maxOnesFifteens;\n\
    \        long maxOnesSeventeens = maxOnes - maxOnesSixteens;\n        long maxOnesEighteens\
    \ = maxOnes - maxOnesSeventeens;\n        long maxOnesNineteens = maxOnes - maxOnesEighteens;\n\
    \        long maxOnesTwenty = maxOnes - maxOnesNineteens;\n        long maxOnesTwentyOnes\
    \ = maxOnes - maxOnesTwenty;\n        long maxOnesTwentyTwos = maxOnes - maxOnesTwentyOnes;\n\
    \        long maxOnesTwentyThrees = maxOnes - maxOnesTwentyTwos;\n        long\
    \ maxOnesTwentyFours = maxOnes - max\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmps52k2xos.cs(48,48): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesOnesOnes = maxOnes - ones - ones;\n   \
    \     long maxOnesOnesOnesZeros = maxOnes - ones - ones - zeros;\n        long\
    \ maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - ones - ones - ones - zeros;\n      \
    \  long maxOnesOnesOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnes\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpioi66ls9.cs(41,37): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long tenths = 0;\n        long oneths =\
    \ 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens = 0;\n\
    \        long hundreds = 0;\n        long thousands = 0;\n        long tenths\
    \ = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth\
    \ = 0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands\
    \ = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth\
    \ = 0;\n        long oneth = 0;\n        long tens = 0;\n        long hundreds\
    \ = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long oneths\
    \ = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens =\
    \ 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths\
    \ = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth\
    \ = 0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands\
    \ = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth\
    \ = 0;\n        long oneth = 0;\n        long tens = 0;\n        long hundreds\
    \ = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long oneths\
    \ = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens =\
    \ 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths\
    \ = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth\
    \ = 0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands\
    \ = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth\
    \ = 0;\n        long oneth = 0;\n        long tens = 0;\n        long hundreds\
    \ = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long oneths\
    \ = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens =\
    \ 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths\
    \ = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth\
    \ = 0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands\
    \ = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth\
    \ = 0;\n        long oneth = 0;\n        long tens = 0;\n\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphs_ep148.cs(29,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(30,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(31,14): error CS0128: A local variable or function named ''thousands''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(32,14): error CS0128: A local variable or function named ''tenths''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(33,14): error CS0128: A local variable or function named ''oneths''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(34,14): error CS0128: A local variable or function named ''tenth''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(35,14): error CS0128: A local variable or function named ''oneth''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(36,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(37,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(38,14): error CS0128: A local variable or function named ''thousands''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(39,14): error CS0128: A local variable or function named ''tenths''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(40,14): error CS0128: A local variable or function named ''oneths''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(41,14): error CS0128: A local variable or function named ''tenth''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(42,14): error CS0128: A local variable or function named ''oneth''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(43,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmphs_ep148.cs(44,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmphs_ep14'
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(zeros);\n            }\n            else if (i == max) {\n\
    \                result.Add(max);\n            }\n            else {\n       \
    \         result.Add(i);\n            }\n        }\n        return result;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <b343757bab4546308affca6fe06dced1>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <b343757bab4546308affca6fe06dced1>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros -= i;\n            if (ones > max) {\n \
    \               max = ones;\n            }\n            if (zeros > max) {\n \
    \               max = zeros;\n            }\n        }\n        long onesCount\
    \ = 0;\n        long zerosCount = 0;\n        long maxCount = 0;\n        foreach\
    \ (long i in arr) {\n            onesCount += i;\n            zerosCount -= i;\n\
    \            if (onesCount > maxCount) {\n                maxCount = onesCount;\n\
    \            }\n            if (zerosCount > maxCount) {\n                maxCount\
    \ = zerosCount;\n            }\n        }\n        long onesCount2 = 0;\n    \
    \    long zerosCount2 = 0;\n        long maxCount2 = 0;\n        foreach (long\
    \ i in arr) {\n            onesCount2 += i;\n            zerosCount2 -= i;\n \
    \           if (onesCount2 > maxCount2) {\n                maxCount2 = onesCount2;\n\
    \            }\n            if (zerosCount2 > maxCount2) {\n                maxCount2\
    \ = zerosCount2;\n            }\n        }\n        long onesCount3 = 0;\n   \
    \     long zerosCount3 = 0;\n        long maxCount3 = 0;\n        foreach (long\
    \ i in arr) {\n            onesCount3 += i;\n            zerosCount3 -= i;\n \
    \           if (onesCount3 > maxCount3) {\n                maxCount3 = onesCount3;\n\
    \            }\n            if (zerosCount3 > maxCount3) {\n                maxCount3\
    \ = zerosCount3;\n            }\n        }\n        long onesCount4 = 0;\n   \
    \     long zerosCount4 = 0;\n        long maxCount4 = 0;\n        foreach (long\
    \ i in arr) {\n            onesCount4 += i;\n            zerosCount4 -= i;\n \
    \           if (onesCount4 > maxCount4) {\n                maxCount4 = onesCount4;\n\
    \            }\n            if (zerosCount4 > maxCount4) {\n                maxCount4\
    \ = zerosCount4;\n            }\n        }\n        long onesCount5 = 0;\n   \
    \     long zerosCount5 = 0;\n        long maxCount5 = 0;\n        foreach (long\
    \ i in arr) {\n            onesCount5 += i;\n            zerosCount5 -= i;\n \
    \           if (onesCount5 > maxCount5) {\n                maxCount5 = onesCount5;\n\
    \            }\n            if (zerosCount5 > maxCount5) {\n                maxCount5\
    \ = zerosCount5;\n            }\n        }\n        long onesCount6 = 0;\n   \
    \     long zerosCount6 = 0;\n        long maxCount6 = 0;\n        foreach (long\
    \ i in arr) {\n            onesCount6 += i;\n            \n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8284n1nm.cs(105,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp8284n1nm.cs(116,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones < zeros)\
    \ {\n            long temp = ones;\n            ones = zeros;\n            zeros\
    \ = temp;\n        }\n        long maxOnes = ones;\n        long maxZeros = zeros;\n\
    \        long maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long\
    \ maxOnesCount2 = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3\
    \ = 0;\n        long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n  \
    \      long maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long\
    \ maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6\
    \ = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n  \
    \      long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long\
    \ maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10\
    \ = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n\
    \        long maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n       \
    \ long maxZerosCount12 = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13\
    \ = 0;\n        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n\
    \        long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n       \
    \ long maxOnesCount16 = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17\
    \ = 0;\n        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n\
    \        long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n       \
    \ long maxZerosCount19 = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20\
    \ = 0;\n        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n\
    \        long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n       \
    \ long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24\
    \ = 0;\n        long maxZ\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpx_2to1vt.cs(76,18): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            if (i == 1)\
    \ {\n                zeros++;\n            }\n            if (ones > max) {\n\
    \                max = ones;\n            }\n        }\n        long onesMax =\
    \ max - ones;\n        long zeroMax = zeros - max;\n        long maxOnes = ones\
    \ - onesMax;\n        long maxZeros = zeros - zeroMax;\n        long maxOnesMax\
    \ = onesMax - maxOnes;\n        long maxZerosMax = zerosMax - maxZeros;\n    \
    \    long maxOnesMaxMinusOnes = maxOnesMax - 1;\n        long maxZerosMaxMinusOnes\
    \ = maxZerosMax - 1;\n        long maxOnesMaxMinusOnesPlusOne = maxOnesMax - 1\
    \ + 1;\n        long maxZerosMaxMinusOnesPlusOne = maxZerosMax - 1 + 1;\n    \
    \    long maxOnesMaxMinusOnesPlusOnePlusOne = maxOnesMax - 1 + 1 + 1;\n      \
    \  long maxZerosMaxMinusOnesPlusOnePlusOne = maxZerosMax - 1 + 1 + 1;\n      \
    \  long maxOnesMaxMinusOnesPlusOnePlusOnePlusOne = maxOnesMax - 1 + 1 + 1 + 1;\n\
    \        long maxZerosMaxMinusOnesPlusOnePlusOnePlusOne = maxZerosMax - 1 + 1\
    \ + 1 + 1;\n        long maxOnesMaxMinusOnesPlusOnePlusOnePlusOnePlusOne = maxOnesMax\
    \ - 1 + 1 + 1 + 1 + 1;\n        long maxZerosMaxMinusOnesPlusOnePlusOnePlusOnePlusOne\
    \ = maxZerosMax - 1 + 1 + 1 + 1 + 1;\n        long maxOnesMaxMinusOnesPlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = maxOnesMax - 1 + 1 + 1 + 1 + 1 + 1;\n        long maxZerosMaxMinusOnesPlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = maxZerosMax - 1 + 1 + 1 + 1 + 1 + 1 + 1;\n        long maxOnesMaxMinusOnesPlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = maxOnesMax - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1;\n        long maxZerosMaxMinusOnesPlusOnePlusOnePlusOnePlusOnePlus\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzl03211e.cs(52,66): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long\
    \ maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n     \
    \   long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n  \
    \      long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuaviubh3.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin\
    \ = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin\
    \ * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmrruv2xz.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(max);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(i);\n                }\n  \
    \              else {\n                    result.Add(max);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesOnes = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesOnesZeros = maxOnes - ones - ones - zeros;\n        long\
    \ maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - ones - zeros;\n        long\
    \ maxOnesOnesZeroOnesOnesZeros = maxOnes - ones - ones - zeros - ones - ones -\
    \ zeros;\n        long maxOnesZeroOnesOnesOnesZeros = maxOnes - zeros - ones -\
    \ ones - zeros - ones - ones - zeros;\n        long maxOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - ones - zeros - ones - zeros - ones - ones - ones;\n     \
    \   long maxOnesZeroOnesOnesZeroOnesOnes = maxOnes - zeros - ones - ones - zeros\
    \ - ones - ones - zeros - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnes\
    \ = maxOnes - ones - ones - zeros - ones - zeros - ones - zeros - ones - zeros\
    \ - ones;\n        long maxOnesZeroOnesOnesZeroOnesZeroOnes = maxOnes - zeros\
    \ - ones - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones;\n\
    \        long maxOnesOnesZeroOnesZeroOnesZeroOnes = maxOnes - ones - ones - zeros\
    \ - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones;\n      \
    \  long maxOnesZeroOnesOnesZeroOnesZeroOnes = maxOnes - zeros - ones - ones -\
    \ zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones;\n\
    \        long maxOnesOnesZeroOnesZeroOnesZeroOnes = maxOnes - ones - \n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp89jbojyv.cs(39,68): error CS1525: Invalid expression term ''}''

    /tmp/tmp89jbojyv.cs(39,68): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin\
    \ = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin\
    \ * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmrruv2xz.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1) {\n                ones++;\n            }\n            if\
    \ (i == 0) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMin = ones;\n        long zerosMinMin\
    \ = zeros;\n        long maxMinMin = max;\n        long onesMaxMinMin = ones;\n\
    \        long zerosMaxMinMin = zeros;\n        long maxMaxMinMin = max;\n    \
    \    long onesMinMinMin = ones;\n        long zerosMinMinMin = zeros;\n      \
    \  long maxMinMinMin = max;\n        long onesMaxMinMinMin = ones;\n        long\
    \ zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin = max;\n        long\
    \ onesMinMinMinMin = ones;\n        long zerosMinMinMinMin = zeros;\n        long\
    \ maxMinMinMinMin = max;\n        long onesMaxMinMinMin = ones;\n        long\
    \ zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin = max;\n        long\
    \ onesMinMinMinMin = ones;\n        long zerosMinMinMinMin = zeros;\n        long\
    \ maxMinMinMinMin = max;\n        long onesMaxMinMinMin = ones;\n        long\
    \ zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin = max;\n        long\
    \ onesMinMinMinMin = ones;\n        long zerosMinMinMinMin = zeros;\n        long\
    \ maxMinMinMinMin = max;\n        long onesMaxMinMinMin = ones;\n        long\
    \ zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin = max;\n        long\
    \ onesMinMinMinMin = ones;\n        long zerosMinMinMinMin = zeros;\n        long\
    \ maxMinMinMinMin = max;\n        long onesMaxMinMinMin = ones;\n        long\
    \ zerosMax\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3i0i1m80.cs(77,22): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesMax = ones;\n        long zerosMax = zeros;\n\
    \        long maxMax = max;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long maxMin = max;\n        long onesCur = ones;\n       \
    \ long zerosCur = zeros;\n        long maxCur = max;\n        long onesPrev =\
    \ ones;\n        long zerosPrev = zeros;\n        long maxPrev = max;\n      \
    \  long onesNext = ones;\n        long zerosNext = zeros;\n        long maxNext\
    \ = max;\n        long onesCurPrev = ones;\n        long zerosCurPrev = zeros;\n\
    \        long maxCurPrev = max;\n        long onesCurNext = ones;\n        long\
    \ zerosCurNext = zeros;\n        long maxCurNext = max;\n        long onesPrevPrev\
    \ = ones;\n        long zerosPrevPrev = zeros;\n        long maxPrevPrev = max;\n\
    \        long onesPrevNext = ones;\n        long zerosPrevNext = zeros;\n    \
    \    long maxPrevNext = max;\n        long onesNextPrev = ones;\n        long\
    \ zerosNextPrev = zeros;\n        long maxNextPrev = max;\n        long onesNextNext\
    \ = ones;\n        long zerosNextNext = zeros;\n        long maxNextNext = max;\n\
    \        long onesPrevPrevPrev = ones;\n        long zerosPrevPrevPrev = zeros;\n\
    \        long maxPrevPrevPrev = max;\n        long onesPrevNextPrev = ones;\n\
    \        long zerosPrevNextPrev = zeros;\n        long maxPrevNextPrev = max;\n\
    \        long onesPrevNextNext = ones;\n        long zerosPrevNextNext = zeros;\n\
    \        long maxPrevNextNext = max;\n        long onesNextPrevPrev = ones;\n\
    \        long zerosNextPrevPrev = zeros;\n        long maxNextPrevPrev = max;\n\
    \        long onesNextNextPrev = ones;\n        long zerosNextNextPrev = zeros;\n\
    \        long maxNext\n    }\n    public static void Main(string[] args) {\n \
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmprzj1c8l_.cs(82,21): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin =\
    \ onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMax\
    \ = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax\
    \ = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin * max;\n    \
    \    long onesMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMax\
    \ = zerosMinMax * max;\n        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n\
    \        long zerosMinMaxMinMax = zerosMinMax * max;\n        long onesMinMaxMinMaxMin\
    \ = onesMinMaxMin * max;\n        long zerosMinMaxMinMax = zerosMinMax * max;\n\
    \        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n        long zerosMinMaxMinMax\
    \ = zerosMinMax * max;\n        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n\
    \        long zerosMinMaxMinMax = zerosMinMax * max;\n        long onesMinMaxMinMaxMin\
    \ = onesMinMaxMin * max;\n        long zerosMinMaxMinMax = zerosMinMax * max;\n\
    \        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n        long zerosMinMaxMinMax\
    \ = zerosMinMax * max;\n        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n\
    \        long zerosMinMaxMinMax = zerosMinMax * max;\n        long onesMinMaxMinMaxMin\
    \ = onesMinMaxMin * max;\n        long zerosMinMaxMinMax = zerosMinMax * max;\n\
    \        long onesMinMaxMinMaxMin = onesMinMaxMin * max;\n        long zerosMinMax\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzh83xp13.cs(63,25): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ ones;\n            long zerosMax = zeros;\n            while (onesMax > zerosMax)\
    \ {\n                result.Add(max);\n                zerosMax--;\n         \
    \   }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n\
    \                onesMax--;\n            }\n        }\n        else {\n      \
    \      long zerosMax = zeros;\n            long onesMax = ones;\n            while\
    \ (zerosMax > onesMax) {\n                result.Add(max);\n                zerosMax--;\n\
    \            }\n            while (onesMax < zerosMax) {\n                result.Add(max);\n\
    \                onesMax--;\n            }\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659794979
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        if (arr.Count == 0) return arr;\n\
    \        long ones = 0;\n        long zeros = 0;\n        long maxOnes = 0;\n\
    \        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long maxZerosCount\
    \ = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2 = 0;\n  \
    \      long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long\
    \ maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5\
    \ = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n  \
    \      long maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long\
    \ maxZerosCount7 = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8\
    \ = 0;\n        long maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n  \
    \      long maxOnesCount10 = 0;\n        long maxZerosCount10 = 0;\n        long\
    \ maxOnesCount11 = 0;\n        long maxZerosCount11 = 0;\n        long maxOnesCount12\
    \ = 0;\n        long maxZerosCount12 = 0;\n        long maxOnesCount13 = 0;\n\
    \        long maxZerosCount13 = 0;\n        long maxOnesCount14 = 0;\n       \
    \ long maxZerosCount14 = 0;\n        long maxOnesCount15 = 0;\n        long maxZerosCount15\
    \ = 0;\n        long maxOnesCount16 = 0;\n        long maxZerosCount16 = 0;\n\
    \        long maxOnesCount17 = 0;\n        long maxZerosCount17 = 0;\n       \
    \ long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long maxOnesCount19\
    \ = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20 = 0;\n\
    \        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n       \
    \ long maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22\
    \ = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n\
    \        long maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n       \
    \ long maxOnesCount25 = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26\
    \ = 0;\n        long maxZerosCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphb4te031.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            }\n            if\
    \ (n == 0L) {\n                zeros++;\n            }\n            if (n > max)\
    \ {\n                max = n;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long\
    \ maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n     \
    \   long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n  \
    \      long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3lti4rde.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long maxOnes = 0;\n\
    \        long maxZeros = 0;\n        foreach (long num in arr) {\n           \
    \ ones += num;\n            zeros -= num;\n            if (ones > maxOnes) {\n\
    \                maxOnes = ones;\n            }\n            if (zeros > maxZeros)\
    \ {\n                maxZeros = zeros;\n            }\n        }\n        long\
    \ maxOnesCount = maxOnes;\n        long maxZerosCount = maxZeros;\n        long\
    \ maxCount = maxOnesCount + maxZerosCount;\n        long onesCount = 0;\n    \
    \    long zerosCount = 0;\n        long count = 0;\n        foreach (long num\
    \ in arr) {\n            onesCount += num;\n            zerosCount -= num;\n \
    \           if (onesCount > maxOnesCount) {\n                maxOnesCount = onesCount;\n\
    \            }\n            if (zerosCount > maxZerosCount) {\n              \
    \  maxZerosCount = zerosCount;\n            }\n            count += num;\n   \
    \     }\n        long maxOnesCount2 = maxOnesCount;\n        long maxZerosCount2\
    \ = maxZerosCount;\n        long maxCount2 = maxOnesCount2 + maxZerosCount2;\n\
    \        long onesCount2 = 0;\n        long zerosCount2 = 0;\n        long count2\
    \ = 0;\n        foreach (long num in arr) {\n            onesCount2 += num;\n\
    \            zerosCount2 -= num;\n            if (onesCount2 > maxOnesCount2)\
    \ {\n                maxOnesCount2 = onesCount2;\n            }\n            if\
    \ (zerosCount2 > maxZerosCount2) {\n                maxZerosCount2 = zerosCount2;\n\
    \            }\n            count2 += num;\n        }\n        long maxOnesCount3\
    \ = maxOnesCount2;\n        long maxZerosCount3 = maxZerosCount2;\n        long\
    \ maxCount3 = maxOnesCount3 + maxZerosCount3;\n        long onesCount3 = 0;\n\
    \        long zerosCount3 = 0;\n        long count3 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount3 += num;\n            zerosCount3 -= num;\n\
    \            if (onesCount3 > maxOnesCount3) {\n                maxOnesCount3\
    \ = onesCount3;\n            }\n            if (zerosCount3 > maxZerosCount3)\
    \ {\n                maxZerosCount3 = zerosCount3;\n            }\n          \
    \  count3 += num\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpf52a37rb.cs(84,26): error CS1002: ; expected

    /tmp/tmpf52a37rb.cs(86,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpf52a37rb.cs(97,2): error CS1513: } expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesOnes = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesOnesZeros = maxOnes - ones - ones - zeros;\n        long\
    \ maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - ones - zeros;\n        long\
    \ maxOnesOnesZeroOnesOnesZeros = maxOnes - ones - zeros - ones - ones - ones -\
    \ zeros;\n        long maxOnesZeroOnesOnesOnesZeros = maxOnes - zeros - ones -\
    \ ones - ones - ones - ones - zeros;\n        long maxOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - ones - ones - zeros;\n    \
    \    long maxOnesZeroOnesOnesZeroOnesOnes = maxOnes - zeros - ones - ones - zeros\
    \ - ones - ones - zeros - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones\
    \ - ones;\n        long maxOnesZeroOnesOnesZeroOnesZeroOnes = maxOnes - zeros\
    \ - ones - ones - zeros - ones - zeros - ones - zeros - ones - ones - ones;\n\
    \        long maxOnesOnesZeroOnesZeroOnesZeroOnes = maxOnes - ones - zeros - ones\
    \ - zeros - ones - zeros - ones - zeros - ones - zeros - ones - ones;\n      \
    \  long maxOnesZeroOnesOnesZeroOnesZeroOnes = maxOnes - zeros - ones - ones -\
    \ zeros - ones - zeros - ones - zeros - ones - zeros - ones - ones - ones;\n \
    \       long maxOnesOnesZeroOnesZeroOnesZeroOnes = maxOnes - ones - zeros - ones\
    \ - \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpddpr1exa.cs(39,83): error CS1525: Invalid expression term ''}''

    /tmp/tmpddpr1exa.cs(39,83): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            } else if (i == 0L)\
    \ {\n                zeros++;\n            } else {\n                if (ones\
    \ > zeros) {\n                    max = i;\n                } else if (ones <\
    \ zeros) {\n                    max = -i;\n                }\n            }\n\
    \        }\n        List<long> result = new List<long>();\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n  \
    \          } else if (i == 0L) {\n                result.Add(-i);\n          \
    \  } else if (i == max) {\n                result.Add(i);\n            } else\
    \ {\n                result.Add(-i);\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d80d6292addf4494b1456d5a3827cb01>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d80d6292addf4494b1456d5a3827cb01>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            if (i == 1) {\n                ones++;\n\
    \            } else if (i == 0) {\n                zeros++;\n            } else\
    \ {\n                if (ones > zeros) {\n                    result.Add(i);\n\
    \                    ones = 0;\n                    zeros = 0;\n             \
    \   } else if (ones < zeros) {\n                    result.Add(0);\n         \
    \           ones = 0;\n                    zeros = 0;\n                } else\
    \ {\n                    max = Math.Max(max, i);\n                }\n        \
    \    }\n        }\n        if (ones > zeros) {\n            result.Add(max);\n\
    \        } else if (ones < zeros) {\n            result.Add(0);\n        }\n \
    \       return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <472528f93d80465fa270e349df967ab7>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <472528f93d80465fa270e349df967ab7>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long num in arr) {\n            ones += num;\n            zeros\
    \ -= num;\n            if (ones > max) {\n                max = ones;\n      \
    \      }\n            if (zeros > max) {\n                max = zeros;\n     \
    \       }\n        }\n        long onesCount = 0;\n        long zerosCount = 0;\n\
    \        long maxCount = 0;\n        foreach (long num in arr) {\n           \
    \ onesCount += num;\n            zerosCount -= num;\n            if (onesCount\
    \ > maxCount) {\n                maxCount = onesCount;\n            }\n      \
    \      if (zerosCount > maxCount) {\n                maxCount = zerosCount;\n\
    \            }\n        }\n        long onesCount2 = 0;\n        long zerosCount2\
    \ = 0;\n        long maxCount2 = 0;\n        foreach (long num in arr) {\n   \
    \         onesCount2 += num;\n            zerosCount2 -= num;\n            if\
    \ (onesCount2 > maxCount2) {\n                maxCount2 = onesCount2;\n      \
    \      }\n            if (zerosCount2 > maxCount2) {\n                maxCount2\
    \ = zerosCount2;\n            }\n        }\n        long onesCount3 = 0;\n   \
    \     long zerosCount3 = 0;\n        long maxCount3 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount3 += num;\n            zerosCount3 -= num;\n\
    \            if (onesCount3 > maxCount3) {\n                maxCount3 = onesCount3;\n\
    \            }\n            if (zerosCount3 > maxCount3) {\n                maxCount3\
    \ = zerosCount3;\n            }\n        }\n        long onesCount4 = 0;\n   \
    \     long zerosCount4 = 0;\n        long maxCount4 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount4 += num;\n            zerosCount4 -= num;\n\
    \            if (onesCount4 > maxCount4) {\n                maxCount4 = onesCount4;\n\
    \            }\n            if (zerosCount4 > maxCount4) {\n                maxCount4\
    \ = zerosCount4;\n            }\n        }\n        long onesCount5 = 0;\n   \
    \     long zerosCount5 = 0;\n        long maxCount5 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount5 += num;\n            zerosCount5 -= num;\n\
    \            if (onesCount5 > maxCount5) {\n                maxCount5 = onesCount5;\n\
    \            }\n            if (zerosCount5 > maxCount5) {\n                maxCount5\
    \ = zerosCount5;\n            }\n        }\n        long onesCount6 = 0;\n   \
    \     long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkq7ba5jt.cs(100,13): error CS1001: Identifier expected

    /tmp/tmpkq7ba5jt.cs(100,13): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long zeros = arr.Sum(x =>\
    \ x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros\
    \ = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n \
    \       long maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnesZeros\
    \ - ones;\n        long maxOnesOnesZeros = maxOnesOnes - ones;\n        long maxOnesOnesOnes\
    \ = maxOnesOnes - ones;\n        long maxOnesZeroZeroOnes = maxOnesZeroZeros -\
    \ ones;\n        long maxOnesZeroOnesOnes = maxOnesOnesZeros - ones;\n       \
    \ long maxOnesOnesZeroZeros = maxOnesZeroOnesOnes - ones;\n        long maxOnesOnesOnesOnes\
    \ = maxOnesOnesZeroZeros - ones;\n        long maxOnesZeroZeroOnesOnes = maxOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesZeroOnesZeroOnes = maxOnesZeroZeroOnesOnes - ones;\n\
    \        long maxOnesOnesZeroZeroOnes = maxOnesOnesOnesZeroZeros - ones;\n   \
    \     long maxOnesZeroOnesOnesOnes = maxOnesZeroOnesZeroOnesOnes - ones;\n   \
    \     long maxOnesOnesZeroZeroOnes = maxOnesOnesOnesZeroZeroOnes - ones;\n   \
    \     long maxOnesZeroOnesOnesZeroOnes = maxOnesZeroOnesOnesOnesZeros - ones;\n\
    \        long maxOnesOnesZeroZeroOnesOnes = maxOnesOnesZeroZeroOnesOnesOnes -\
    \ ones;\n        long maxOnesZeroOnesOnesZeroZeroOnes = maxOnesOnesOnesZeroZeroOnesOnes\
    \ - ones;\n        long maxOnesOnesZeroZeroOnesOnesOnes = maxOnesZeroOnesZeroOnesOnesZeroOnes\
    \ - ones;\n        long maxOnesZeroOnesOnesZeroZeroOnesOnes = maxOnesOnesZeroZeroOnesOnesOnesZeroOnes\
    \ - ones;\n        long maxOnesOnes\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpogicc38z.cs(44,25): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n        \
    \    if (i == 1L) {\n                onesCount++;\n            }\n           \
    \ if (i == 0L) {\n                zerosCount++;\n            }\n            if\
    \ (i > max) {\n                maxCount = i;\n            }\n        }\n     \
    \   long onesCountMax = onesCount > maxCount ? onesCount : maxCount;\n       \
    \ long zerosCountMax = zerosCount > maxCount ? zerosCount : maxCount;\n      \
    \  long maxCountMax = max > maxCount ? max : maxCount;\n        long onesCountMin\
    \ = onesCount < maxCount ? onesCount : maxCount;\n        long zerosCountMin =\
    \ zerosCount < maxCount ? zerosCount : maxCount;\n        long maxCountMin = max\
    \ < maxCount ? max : maxCount;\n        long onesCountMaxMin = onesCountMax <\
    \ maxCountMax ? onesCountMax : maxCountMax;\n        long zerosCountMaxMin = zerosCountMax\
    \ < maxCountMax ? zerosCountMax : maxCountMax;\n        long maxCountMaxMin =\
    \ maxCountMax < maxCountMin ? maxCountMax : maxCountMin;\n        long onesCountMinMin\
    \ = onesCountMin < maxCountMin ? onesCountMin : maxCountMin;\n        long zerosCountMinMin\
    \ = zerosCountMin < maxCountMin ? zerosCountMin : maxCountMin;\n        long maxCountMinMin\
    \ = maxCountMin < maxCountMin ? maxCountMin : maxCountMin;\n        long onesCountMinMinMin\
    \ = onesCountMinMin < maxCountMinMin ? onesCountMinMin : maxCountMinMin;\n   \
    \     long zerosCountMinMinMin = zerosCountMinMin < maxCountMinMin ? zerosCountMinMin\
    \ : maxCountMinMin;\n        long maxCountMinMinMin = maxCountMinMin < maxCountMinMin\
    \ ? maxCountMinMin : maxCountMinMin;\n        long onesCountMinMinMinMin = onesCountMinMinMin\
    \ < maxCount\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1oyng49e.cs(64,67): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            zeros -= i;\n\
    \            if (ones > max) {\n                max = ones;\n            }\n \
    \           if (zeros > max) {\n                max = zeros;\n            }\n\
    \        }\n        long onesMax = max;\n        long zerosMax = max;\n      \
    \  long onesMin = max;\n        long zerosMin = max;\n        foreach (long i\
    \ in arr) {\n            onesMax += i;\n            zerosMax -= i;\n         \
    \   if (onesMax < onesMin) {\n                onesMin = onesMax;\n           \
    \ }\n            if (zerosMax < zerosMin) {\n                zerosMin = zerosMax;\n\
    \            }\n        }\n        long onesMinMax = onesMin;\n        long zerosMinMax\
    \ = zerosMin;\n        long onesMaxMin = onesMax;\n        long zerosMaxMin =\
    \ zerosMax;\n        long onesMaxMinMax = onesMaxMin;\n        long zerosMaxMinMax\
    \ = zerosMaxMin;\n        long onesMaxMinMaxMin = onesMaxMinMax;\n        long\
    \ zerosMaxMinMaxMin = zerosMaxMinMax;\n        long onesMaxMinMaxMinMax = onesMaxMinMaxMin;\n\
    \        long zerosMaxMinMaxMinMax = zerosMaxMinMaxMinMax;\n        long onesMaxMinMaxMinMaxMin\
    \ = onesMaxMinMaxMinMax;\n        long zerosMaxMinMaxMinMaxMin = zerosMaxMinMaxMinMaxMinMax;\n\
    \        long onesMaxMinMaxMinMaxMinMax = onesMaxMinMaxMinMaxMinMax;\n       \
    \ long zerosMaxMinMaxMinMaxMinMax = zerosMaxMinMaxMinMaxMinMax;\n        long\
    \ onesMaxMinMaxMinMaxMinMaxMin = onesMaxMinMaxMinMaxMinMax;\n        long zerosMaxMinMaxMinMaxMinMax\
    \ = zerosMaxMinMaxMinMaxMinMax;\n        long onesMaxMinMaxMinMaxMinMaxMin = onesMaxMinMaxMinMaxMinMax;\n\
    \        long zerosMaxMinMaxMinMaxMinMaxMin = zerosMaxMinMaxMinMaxMinMaxMinMax;\n\
    \        long onesMaxMinMaxMinMaxMinMaxMinMax = onesMaxMinMaxMinMaxMinMaxMinMax;\n\
    \        long zerosMaxMinMax\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyh2ktavj.cs(67,28): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         ones += num;\n            zeros -= num;\n            if (ones > max)\
    \ {\n                max = ones;\n            }\n            if (zeros > max)\
    \ {\n                max = zeros;\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        foreach (long num in arr) {\n          \
    \  if (num == 1) {\n                result.Add(num);\n            } else {\n \
    \               result.Add(num - max);\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8eeb053ba2c64dbcb201b5b45da2efe5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8eeb053ba2c64dbcb201b5b45da2efe5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesTwos = maxOnes - twos;\n        long maxOnesThrees = maxOnes - threes;\n\
    \        long maxOnesFours = maxOnes - fours;\n        long maxOnesFives = maxOnes\
    \ - fives;\n        long maxOnesSixes = maxOnes - sixes;\n        long maxOnesSevens\
    \ = maxOnes - sevens;\n        long maxOnesEights = maxOnes - eights;\n      \
    \  long maxOnesNines = maxOnes - nines;\n        long maxOnesTens = maxOnes -\
    \ tens;\n        long maxOnesElevens = maxOnes - elevens;\n        long maxOnesTwelves\
    \ = maxOnes - twelves;\n        long maxOnesThirteens = maxOnes - thirteens;\n\
    \        long maxOnesFourteens = maxOnes - fourteens;\n        long maxOnesFifteens\
    \ = maxOnes - fifteens;\n        long maxOnesSixteens = maxOnes - sixteens;\n\
    \        long maxOnesSeventeens = maxOnes - seventeens;\n        long maxOnesEighteens\
    \ = maxOnes - eighteens;\n        long maxOnesNineteens = maxOnes - nineteens;\n\
    \        long maxOnesTwenty = maxOnes - twenty;\n        long maxOnesThirty =\
    \ maxOnes - thirty;\n        long maxOnesFourty = maxOnes - fourty;\n        long\
    \ maxOnesFifty = maxOnes - fifty;\n        long maxOnesSixty = maxOnes - sixty;\n\
    \        long maxOnesSeventy = maxOnes - seventy;\n        long maxOnesEighty\
    \ = maxOnes - eighty;\n        long maxOnesNinety = maxOnes - ninety;\n      \
    \  long maxOnesOne = maxOnes - one;\n        long maxOnesTwo = maxOnes - \n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpopicbv31.cs(53,36): error CS1525: Invalid expression term ''}''

    /tmp/tmpopicbv31.cs(53,36): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n        \
    \    if (i == 1L) {\n                onesCount++;\n            }\n           \
    \ if (i == 0L) {\n                zerosCount++;\n            }\n            if\
    \ (i > max) {\n                maxCount = i;\n            }\n        }\n     \
    \   long onesCountMax = onesCount > maxCount ? onesCount : maxCount;\n       \
    \ long zerosCountMax = zerosCount > maxCount ? zerosCount : maxCount;\n      \
    \  long onesCountMin = onesCount < maxCount ? onesCount : maxCount;\n        long\
    \ zerosCountMin = zerosCount < maxCount ? zerosCount : maxCount;\n        long\
    \ onesCountMaxMin = onesCount > maxCount ? onesCount > maxCount ? onesCount :\
    \ maxCount : maxCount;\n        long zerosCountMaxMin = zerosCount > maxCount\
    \ ? zerosCount > maxCount ? zerosCount : maxCount : maxCount;\n        long onesCountMaxMinMin\
    \ = onesCount > maxCount ? onesCount > maxCount ? onesCount > maxCount ? onesCount\
    \ : maxCount : maxCount : maxCount;\n        long zerosCountMaxMinMin = zerosCount\
    \ > maxCount ? zerosCount > maxCount ? zerosCount > maxCount ? zerosCount : maxCount\
    \ : maxCount : maxCount;\n        long onesCountMaxMinMinMin = onesCount > maxCount\
    \ ? onesCount > maxCount ? onesCount > maxCount ? onesCount > maxCount ? onesCount\
    \ : maxCount : maxCount : maxCount : maxCount;\n        long zerosCountMaxMinMinMin\
    \ = zerosCount > maxCount ? zerosCount > maxCount ? zerosCount > maxCount ? zerosCount\
    \ > maxCount ? zerosCount : maxCount : maxCount : maxCount : maxCount;\n     \
    \   long onesCountMaxMinMinMinMin = onesCount > maxCount ? onesCount > maxCount\
    \ ? onesCount > maxCount ? onesCount > maxCount ? onesCount > max\n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4u3hzzaa.cs(59,148): error CS1003: Syntax error, '':'' expected

    /tmp/tmp4u3hzzaa.cs(59,148): error CS1525: Invalid expression term ''}''

    /tmp/tmp4u3hzzaa.cs(59,148): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long tenths = 0;\n        long oneths =\
    \ 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tenths =\
    \ 0;\n        long oneths = 0;\n        long tenthth = 0;\n        long onethth\
    \ = 0;\n        long tenthths = 0;\n        long onethths = 0;\n        long tenththth\
    \ = 0;\n        long onethths = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        long tenththth = 0;\n        long oneththth = 0;\n\
    \        long tenththths = 0;\n        long oneththths = 0;\n        long tenththth\
    \ = 0;\n        long oneththth = 0;\n        long tenththths = 0;\n        long\
    \ oneththths = 0;\n        \n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpl9ecgyze.cs(29,14): error CS0128: A local variable or function named ''tenths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(30,14): error CS0128: A local variable or function named ''oneths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(36,14): error CS0128: A local variable or function named ''onethths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(39,14): error CS0128: A local variable or function named ''tenththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(41,14): error CS0128: A local variable or function named ''tenththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(42,14): error CS0128: A local variable or function named ''oneththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(43,14): error CS0128: A local variable or function named ''tenththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(44,14): error CS0128: A local variable or function named ''oneththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(45,14): error CS0128: A local variable or function named ''tenththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(46,14): error CS0128: A local variable or function named ''oneththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(47,14): error CS0128: A local variable or function named ''tenththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(48,14): error CS0128: A local variable or function named ''oneththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(49,14): error CS0128: A local variable or function named ''tenththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(50,14): error CS0128: A local variable or function named ''oneththths''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(51,14): error CS0128: A local variable or function named ''tenththth''
    is already defined in this scope

    /tmp/tmpl9ecgyze.cs(52,14): error CS0128: A local variable or function named ''oneththth''
    is '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnesZeros - ones;\n        long maxOnesOnesZeros = maxOnesOnes\
    \ - ones;\n        long maxOnesZeroOnesOnes = maxOnesZeroOnes - ones;\n      \
    \  long maxOnesOnesZeroOnes = maxOnesOnesZeros - ones;\n        long maxOnesZeroOnesOnesZeros\
    \ = maxOnesZeroOnesOnes - ones;\n        long maxOnesOnesZeroOnesOnesZeros = maxOnesOnesZeroOnesOnes\
    \ - ones;\n        long maxOnesZeroOnesOnesOnesZeros = maxOnesZeroOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesZeroOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnes\
    \ - ones;\n        long maxOnesZeroOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesOnesZeros\
    \ - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesOne\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzyaywo0a.cs(40,48): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr;\n        }\n        long maxOnes = ones;\n      \
    \  long maxZeros = zeros;\n        long maxOnesDecimal = maxOnes / 10;\n     \
    \   long maxZerosDecimal = maxZeros / 10;\n        long maxOnesDecimalDecimal\
    \ = maxOnesDecimal / 10;\n        long maxZerosDecimalDecimal = maxZerosDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal / 10;\n\
    \        long maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal / 10;\n \
    \       long maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal\
    \ / 10;\n        long maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10;\n\
    \        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10;\n        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimal\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7w3fui1a.cs(44,131): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesMax = 0;\n        long zerosMax = 0;\n\
    \        long maxOnes = 0;\n        long maxZeros = 0;\n        long maxOnesMax\
    \ = 0;\n        long maxZerosMax = 0;\n        long maxOnesMax2 = 0;\n       \
    \ long maxZerosMax2 = 0;\n        long maxOnesMax3 = 0;\n        long maxZerosMax3\
    \ = 0;\n        long maxOnesMax4 = 0;\n        long maxZerosMax4 = 0;\n      \
    \  long maxOnesMax5 = 0;\n        long maxZerosMax5 = 0;\n        long maxOnesMax6\
    \ = 0;\n        long maxZerosMax6 = 0;\n        long maxOnesMax7 = 0;\n      \
    \  long maxZerosMax7 = 0;\n        long maxOnesMax8 = 0;\n        long maxZerosMax8\
    \ = 0;\n        long maxOnesMax9 = 0;\n        long maxZerosMax9 = 0;\n      \
    \  long maxOnesMax10 = 0;\n        long maxZerosMax10 = 0;\n        long maxOnesMax11\
    \ = 0;\n        long maxZerosMax11 = 0;\n        long maxOnesMax12 = 0;\n    \
    \    long maxZerosMax12 = 0;\n        long maxOnesMax13 = 0;\n        long maxZerosMax13\
    \ = 0;\n        long maxOnesMax14 = 0;\n        long maxZerosMax14 = 0;\n    \
    \    long maxOnesMax15 = 0;\n        long maxZerosMax15 = 0;\n        long maxOnesMax16\
    \ = 0;\n        long maxZerosMax16 = 0;\n        long maxOnesMax17 = 0;\n    \
    \    long maxZerosMax17 = 0;\n        long maxOnesMax18 = 0;\n        long maxZerosMax18\
    \ = 0;\n        long maxOnesMax19 = 0;\n        long maxZerosMax19 = 0;\n    \
    \    long maxOnesMax20 = 0;\n        long maxZerosMax20 = 0;\n        long maxOnesMax21\
    \ = 0;\n        long maxZerosMax21 = 0;\n        long maxOnesMax22 = 0;\n    \
    \    long maxZerosMax22 = 0;\n        long maxOnesMax23 = 0;\n\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp634w9p55.cs(35,14): warning CS0219: The variable ''onesMax'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(36,14): warning CS0219: The variable ''zerosMax'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(37,14): warning CS0219: The variable ''maxOnes'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(38,14): warning CS0219: The variable ''maxZeros'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(39,14): warning CS0219: The variable ''maxOnesMax'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(40,14): warning CS0219: The variable ''maxZerosMax'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(41,14): warning CS0219: The variable ''maxOnesMax2'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(42,14): warning CS0219: The variable ''maxZerosMax2'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(43,14): warning CS0219: The variable ''maxOnesMax3'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(44,14): warning CS0219: The variable ''maxZerosMax3'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(45,14): warning CS0219: The variable ''maxOnesMax4'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(46,14): warning CS0219: The variable ''maxZerosMax4'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(47,14): warning CS0219: The variable ''maxOnesMax5'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(48,14): warning CS0219: The variable ''maxZerosMax5'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(49,14): warning CS0219: The variable ''maxOnesMax6'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(50,14): warning CS0219: The variable ''maxZerosMax6'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(51,14): warning CS0219: The variable ''maxOnesMax7'' is assigned
    but its value is never used

    /tmp/tmp634w9p55.cs(52,14): warning CS0219: '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long maxOnes = arr.Max(x =>\
    \ x & 1L);\n        long maxOnesIndex = arr.FindIndex(x => x & 1L == maxOnes);\n\
    \        long maxOnesValue = arr[maxOnesIndex];\n        long maxOnesValueIndex\
    \ = arr.FindIndex(x => x == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x\
    \ => x & 1L == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x\
    \ => x == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x =>\
    \ x & 1L == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x =>\
    \ x == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x &\
    \ 1L == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x\
    \ == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x & 1L\
    \ == maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x ==\
    \ maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x & 1L ==\
    \ maxOnesValue);\n        long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n\
    \        long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n\
    \        long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n   \
    \     long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n \
    \       long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n    \
    \    long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n  \
    \      long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n     \
    \   long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n   \
    \     long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n      \
    \  long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n    \
    \    long maxOnesValueIndex = arr.FindIndex(x => x == maxOnesValue);\n       \
    \ long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n\n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpr73o7lrb.cs(23,48): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''bool''

    /tmp/tmpr73o7lrb.cs(24,33): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmpr73o7lrb.cs(26,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(26,53): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''bool''

    /tmp/tmpr73o7lrb.cs(27,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(28,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(28,53): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''bool''

    /tmp/tmpr73o7lrb.cs(29,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(30,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(30,53): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''bool''

    /tmp/tmpr73o7lrb.cs(31,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(32,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(32,53): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''bool''

    /tmp/tmpr73o7lrb.cs(33,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(34,14): error CS0128: A local variable or function named ''maxOnesValueIndex''
    is already defined in this scope

    /tmp/tmpr73o7lrb.cs(34,53): error CS0019: Operator ''&'' cannot be applied to
    operands of type ''long'' and ''b'
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(max);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(i);\n                }\n  \
    \              else {\n                    result.Add(max);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0b187555360848608c4ac9bdd3cfb7c5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long zeros = arr.Sum(x =>\
    \ x & 0L);\n        long maxOnes = ones;\n        long maxZeros = zeros;\n   \
    \     long maxDiff = maxOnes - maxZeros;\n        long minOnes = maxOnes - 1;\n\
    \        long minZeros = maxZeros - 1;\n        long minDiff = minOnes - minZeros;\n\
    \        long diff = maxDiff;\n        long minDiffIndex = arr.IndexOf(arr.Min(x\
    \ => x & 1L));\n        long maxDiffIndex = arr.IndexOf(arr.Max(x => x & 1L));\n\
    \        long minDiffIndex = arr.IndexOf(arr.Min(x => x & 0L));\n        long\
    \ maxDiffIndex = arr.IndexOf(arr.Max(x => x & 0L));\n        long minDiffIndex\
    \ = arr.IndexOf(arr.Min(x => x & 1L));\n        long maxDiffIndex = arr.IndexOf(arr.Max(x\
    \ => x & 1L));\n        long minDiffIndex = arr.IndexOf(arr.Min(x => x & 0L));\n\
    \        long maxDiffIndex = arr.IndexOf(arr.Max(x => x & 0L));\n        long\
    \ minDiffIndex = arr.IndexOf(arr.Min(x => x & 1L));\n        long maxDiffIndex\
    \ = arr.IndexOf(arr.Max(x => x & 1L));\n        long minDiffIndex = arr.IndexOf(arr.Min(x\
    \ => x & 0L));\n        long maxDiffIndex = arr.IndexOf(arr.Max(x => x & 0L));\n\
    \        long minDiffIndex = arr.IndexOf(arr.Min(x => x & 1L));\n        long\
    \ maxDiffIndex = arr.IndexOf(arr.Max(x => x & 1L));\n        long minDiffIndex\
    \ = arr.IndexOf(arr.Min(x => x & 0L));\n        long maxDiffIndex = arr.IndexOf(arr.Max(x\
    \ => x & 0L));\n        long minDiffIndex = arr.IndexOf(arr.Min(x => x & 1L));\n\
    \        long maxDiffIndex = arr.IndexOf(arr.Max(x => x & 1L));\n        long\
    \ minDiffIndex = arr.IndexOf(arr.Min(x => x & 0L));\n        long maxDiffIndex\
    \ = arr.IndexOf(arr.Max(x => x & 0L));\n        long minDiffIndex = arr.IndexOf(arr.Min(x\
    \ => x & 1L));\n        long maxDiff\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1n1bzbqt.cs(51,21): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros += (long)Math.Abs(i);\n            if (i\
    \ > max) {\n                max = i;\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        long onesCount = 0;\n        long zerosCount\
    \ = 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n      \
    \      onesCount += i;\n            zerosCount += (long)Math.Abs(i);\n       \
    \     if (i > maxCount) {\n                maxCount = i;\n            }\n    \
    \    }\n        if (onesCount > zerosCount) {\n            long temp = ones;\n\
    \            ones = zeros;\n            zeros = temp;\n        }\n        long\
    \ onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n\
    \        long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin\
    \ = max;\n        long onesCurr = ones;\n        long zerosCurr = zeros;\n   \
    \     long maxCurr = max;\n        long onesNext = ones;\n        long zerosNext\
    \ = zeros;\n        long maxNext = max;\n        long onesPrev = 0;\n        long\
    \ zerosPrev = 0;\n        long maxPrev = 0;\n        long onesCurrNext = ones;\n\
    \        long zerosCurrNext = zeros;\n        long maxCurrNext = max;\n      \
    \  long onesCurrPrev = 0;\n        long zerosCurrPrev = 0;\n        long maxCurrPrev\
    \ = 0;\n        long onesCurrPrevNext = ones;\n        long zerosCurrPrevNext\
    \ = zeros;\n        long maxCurrPrevNext = max;\n        long onesCurrPrevPrev\
    \ = 0;\n        long zerosCurrPrevPrev = 0;\n        long maxCurrPrevPrev = 0;\n\
    \        long onesCurrPrevPrevNext = ones;\n        long zerosCurrPrevPrevNext\
    \ = zeros;\n        long maxCurrPrevPrevNext = max;\n        long onesCurrPrevPrevPrev\
    \ = 0;\n        long zerosCurrPrevPrevPrev = 0;\n        long maxCurrPrevPrevPrev\
    \ = 0;\n        long onesCurrPrevPrevPrevNext = ones;\n        long zerosCurrPrevPrevPrevNext\
    \ = zeros;\n        long maxCurrPrevPrevPrevNext = max;\n        long onesCurrPrevPrevPrevPrev\
    \ = 0;\n        long zerosCurrPrevPrevPrev\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpemfnjhpt.cs(83,35): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            } else if (i == 0L)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt64(Math.Log(max, 2) + 1)))).ToList());\n        } else {\n    \
    \        result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log(max,\
    \ 2) + 1)))).Reverse().ToList());\n        }\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <b5e942e4d16f465e8119f2557021e835>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Arithmetic operation resulted in an overflow.\n  at\
    \ (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n\
    \  at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c__DisplayClass0_0.<SortArray>b__1 (System.Int64 i) [0x0001e]\
    \ in <b5e942e4d16f465e8119f2557021e835>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys\
    \ (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1[TElement].ToList () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.Enumerable.ToList[TSource] (System.Collections.Generic.IEnumerable"
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long onesMin = ones * min;\n        long\
    \ zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long\
    \ onesDiff = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n\
    \        long onesDiffMax = onesDiff > zerosDiff ? onesDiff : zerosDiff;\n   \
    \     long onesDiffMin = onesDiff < zerosDiff ? onesDiff : zerosDiff;\n      \
    \  long onesDiffMaxMin = onesDiffMax * min;\n        long onesDiffMinMax = onesDiffMin\
    \ * max;\n        long onesDiffMaxMinMax = onesDiffMaxMin * max;\n        long\
    \ onesDiffMaxMinMaxMin = onesDiffMaxMinMax * min;\n        long onesDiffMaxMinMaxMin\
    \ = onesDiffMaxMinMax * min;\n        long onesDiffMaxMinMaxMinMax = onesDiffMaxMinMaxMin\
    \ * max;\n        long onesDiffMaxMinMaxMinMax = onesDiffMaxMinMaxMin * max;\n\
    \        long onesDiffMaxMinMaxMinMaxMin = onesDiffMaxMinMaxMinMax * min;\n  \
    \      long onesDiffMaxMinMaxMinMaxMin = onesDiffMaxMinMaxMinMax * min;\n    \
    \    long onesDiffMaxMinMaxMinMaxMinMax = onesDiffMaxMinMaxMinMaxMin * max;\n\
    \        long onesDiffMaxMinMaxMinMaxMinMax = onesDiffMaxMinMaxMinMaxMin * max;\n\
    \        long onesDiffMaxMinMaxMinMaxMinMaxMin = onesDiffMaxMinMaxMinMaxMinMax\
    \ * min;\n        long onesDiffMaxMinMaxMinMaxMinMaxMin = onesDiffMaxMinMaxMinMaxMinMax\
    \ * min;\n        long onesDiffMaxMinMaxMinMaxMinMaxMinMax = onesDiffMaxMinMaxMinMaxMinMaxMin\
    \ * max;\n        \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphawm03n9.cs(50,14): error CS0128: A local variable or function named ''onesDiffMaxMinMaxMin''
    is already defined in this scope

    /tmp/tmphawm03n9.cs(52,14): error CS0128: A local variable or function named ''onesDiffMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmphawm03n9.cs(54,14): error CS0128: A local variable or function named ''onesDiffMaxMinMaxMinMaxMin''
    is already defined in this scope

    /tmp/tmphawm03n9.cs(56,14): error CS0128: A local variable or function named ''onesDiffMaxMinMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmphawm03n9.cs(58,14): error CS0128: A local variable or function named ''onesDiffMaxMinMaxMinMaxMinMaxMin''
    is already defined in this scope

    /tmp/tmphawm03n9.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesZeros = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesOnes = maxOnes - ones - ones;\n        long maxOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - ones;\n        long maxOnesOnesZeroOnes = maxOnes\
    \ - ones - zeros - ones;\n        long maxOnesZeroOnesZeroOnes = maxOnes - zeros\
    \ - ones - zeros - ones;\n        long maxOnesOnesOnesOnes = maxOnes - ones -\
    \ ones - ones;\n        long maxOnesZeroOnesZeroOnes = maxOnes - zeros - ones\
    \ - zeros - ones;\n        long maxOnesOnesZeroOnesOnes = maxOnes - ones - zeros\
    \ - ones - ones - ones;\n        long maxOnesZeroOnesZeroOnesOnes = maxOnes -\
    \ zeros - ones - zeros - ones - ones - ones;\n        long maxOnesOnesOnesZeroOnes\
    \ = maxOnes - ones - ones - ones - zeros - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnes\
    \ = maxOnes - zeros - ones - zeros - ones - ones - zeros - ones;\n        long\
    \ maxOnesOnesZeroOnesOnesOnes = maxOnes - ones - ones - ones - zeros - ones -\
    \ ones - ones - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesOnes = maxOnes\
    \ - zeros - ones - zeros - ones - ones - zeros - ones - ones - ones;\n       \
    \ long maxOnesOnesOnesZeroOnesZeroOnesOnes = maxOnes - ones - ones - ones - zeros\
    \ - ones - ones - zeros - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - \n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptyb7oo3f.cs(42,77): error CS1525: Invalid expression term ''}''

    /tmp/tmptyb7oo3f.cs(42,77): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            else if (i == 0L) {\n                zeros++;\n           \
    \ }\n            else {\n                max = Math.Max(max, i);\n           \
    \     min = Math.Min(min, i);\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n\
    \            result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones\
    \ - 1));\n            result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(zeros\
    \ - 1));\n        }\n        else if (zeros > ones) {\n            result.AddRange(arr.Where(i\
    \ => i == min).OrderBy(i => i).Take(zeros - 1));\n            result.Add(max);\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(ones\
    \ - 1));\n        }\n        else {\n            result.AddRange(arr.Where(i =>\
    \ i == min).OrderBy(i => i).Take(ones - 1));\n            result.AddRange(arr.Where(i\
    \ => i == max).OrderBy(i => i).Take(zeros - 1));\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphcsge9xu.cs(39,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmphcsge9xu.cs(40,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmphcsge9xu.cs(43,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmphcsge9xu.cs(45,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmphcsge9xu.cs(48,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmphcsge9xu.cs(49,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMaxMax = onesMax;\n        long zerosMaxMax = zerosMax;\n        long\
    \ maxMaxMax = maxMax;\n        long onesMaxMaxMax = onesMaxMax;\n        long\
    \ zerosMaxMaxMax = zerosMaxMax;\n        long maxMaxMaxMax = maxMaxMax;\n    \
    \    long onesMaxMaxMaxMax = onesMaxMaxMax;\n        long zerosMaxMaxMaxMax =\
    \ zerosMaxMaxMax;\n        long maxMaxMaxMaxMax = maxMaxMaxMax;\n        long\
    \ onesMaxMaxMaxMaxMax = onesMaxMaxMaxMax;\n        long zerosMaxMaxMaxMaxMax =\
    \ zerosMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMax;\n\
    \        long onesMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMax;\n        long zerosMaxMaxMaxMaxMaxMax\
    \ = zerosMaxMaxMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMaxMaxMax;\n\
    \        long onesMaxMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMaxMax;\n       \
    \ long zerosMaxMaxMaxMaxMaxMaxMax = zerosMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ maxMaxMaxMaxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ onesMaxMaxMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ zerosMaxMaxMaxMaxMaxMaxMaxMax = zerosMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ maxMaxMaxMaxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ onesMaxMaxMaxMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n    \
    \    long zerosMaxMaxMaxMaxMaxMaxMaxMaxMax = zerosMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n\
    \        long maxMax\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp02e9se2_.cs(60,20): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            zeros -= i;\n\
    \            if (ones > max) {\n                max = ones;\n            }\n \
    \           if (zeros > max) {\n                max = zeros;\n            }\n\
    \        }\n        long onesMax = max;\n        long zerosMax = max;\n      \
    \  long maxOnes = 0;\n        long maxZeros = 0;\n        long maxOnesMax = 0;\n\
    \        long maxZerosMax = 0;\n        foreach (long i in arr) {\n          \
    \  onesMax += i;\n            zerosMax -= i;\n            if (onesMax < maxOnesMax)\
    \ {\n                maxOnesMax = onesMax;\n            }\n            if (zerosMax\
    \ < maxZerosMax) {\n                maxZerosMax = zerosMax;\n            }\n \
    \           if (onesMax < maxOnes) {\n                maxOnes = onesMax;\n   \
    \         }\n            if (zerosMax < maxZeros) {\n                maxZeros\
    \ = zerosMax;\n            }\n        }\n        long onesMaxMinusOnes = maxOnesMax\
    \ - maxOnes;\n        long zerosMaxMinusOnes = maxZerosMax - maxZeros;\n     \
    \   long maxOnesMinusOnes = maxOnes - maxOnesMax;\n        long maxZerosMinusOnes\
    \ = maxZeros - maxZerosMax;\n        long maxOnesMinusOnesMax = maxOnesMax - maxOnesMaxMinusOnes;\n\
    \        long maxZerosMinusOnesMax = maxZerosMax - maxZerosMaxMinusOnes;\n   \
    \     long maxOnesMinusOnesMaxMinusOnes = maxOnesMaxMinusOnes - maxOnesMinusOnes;\n\
    \        long maxZerosMinusOnesMaxMinusOnes = maxZerosMaxMinusOnes - maxZerosMinusOnes;\n\
    \        long maxOnesMinusOnesMaxMinusOnesMax = maxOnesMinusOnesMaxMinusOnes -\
    \ maxOnesMinusOnesMax;\n        long maxZerosMinusOnesMaxMinusOnesMax = maxZerosMinusOnesMaxMinusOnes\
    \ - maxZerosMinusOnesMax;\n        long maxOnesMinusOnesMaxMinusOnesMaxMin\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsbfbou_r.cs(66,48): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesOnesOnes = maxOnes - ones - ones;\n   \
    \     long maxOnesOnesZeroOnes = maxOnes - ones - zeros - ones;\n        long\
    \ maxOnesOnesOnesZeros = maxOnes - ones - ones - zeros;\n        long maxOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones;\n        long maxOnesOnesOnesZeroOnes = maxOnes\
    \ - ones - ones - zeros - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeroOnes = maxOnes\
    \ - ones - ones - ones - zeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeroOnes\
    \ = maxOnes - ones - ones - ones - ones - zeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros\
    \ = maxOnes - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeroOnes\
    \ = maxOnes - ones - ones - ones - ones - ones - zeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpea78pr7d.cs(42,45): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros += (long)Math.Abs(i);\n            if (i\
    \ > max) {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones - max;\n        long zerosMax = zeros - max;\n        long onesMin =\
    \ ones - 1;\n        long zerosMin = zeros - 1;\n        long onesMaxMin = ones\
    \ - max;\n        long zerosMaxMin = zeros - max;\n        long onesMinMax = ones\
    \ - min;\n        long zerosMinMax = zeros - min;\n        long onesMaxMinMax\
    \ = ones - max - min;\n        long zerosMaxMinMax = zeros - max - min;\n    \
    \    long onesMinMaxMinMax = ones - max - min - min;\n        long zerosMaxMinMaxMin\
    \ = zeros - max - min - min;\n        long onesMinMaxMinMaxMin = ones - max -\
    \ min - min - min;\n        long zerosMaxMinMaxMinMax = zeros - max - min - min\
    \ - min;\n        long onesMinMaxMinMaxMinMax = ones - max - min - min - min -\
    \ min;\n        long zerosMaxMinMaxMinMax = zeros - max - min - min - min - min;\n\
    \        long onesMinMaxMinMaxMinMax = ones - max - min - min - min - min - min;\n\
    \        long zerosMaxMinMaxMinMaxMin = zeros - max - min - min - min - min -\
    \ min;\n        long onesMinMaxMinMaxMinMaxMin = ones - max - min - min - min\
    \ - min - min - min;\n        long zerosMaxMinMaxMinMaxMinMax = zeros - max -\
    \ min - min - min - min - min - min;\n        long onesMinMaxMinMaxMinMaxMinMax\
    \ = ones - max - min - min - min - min - min - min - min;\n        long zerosMaxMinMaxMinMaxMinMax\
    \ = zeros - max - min - min - min - min - min - min - min;\n        long onesMinMaxMinMaxMinMaxMinMax\
    \ = ones - max - min - min - min - min - min - min - min - min;\n        long\
    \ zerosMaxMinMaxMinMaxMinMax = zeros - max - min - min - min - min - min - min\
    \ - min - min;\n        long onesMin\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpshg5d3h4.cs(54,21): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros -= i;\n            if (ones > max) {\n \
    \               max = ones;\n            }\n            if (zeros > max) {\n \
    \               max = zeros;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        foreach (long i in arr) {\n            if (i ==\
    \ 1) {\n                result.Add(i);\n            } else {\n               \
    \ result.Add(max - (long)i);\n            }\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <10aa26ae54764c82b5658bd272e0940b>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <10aa26ae54764c82b5658bd272e0940b>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : maxZeros;\n        long maxOnesOrZerosOrZeros\
    \ = maxOnes > maxZeros ? maxOnes : max\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpas36z918.cs(40,72): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long maxOnes = 0;\n\
    \        long maxZeros = 0;\n        foreach (long i in arr) {\n            ones\
    \ += i;\n            zeros += (long)Math.Abs(i);\n            if (ones > maxOnes)\
    \ maxOnes = ones;\n            if (zeros > maxZeros) maxZeros = zeros;\n     \
    \   }\n        long onesMax = maxOnes;\n        long zerosMax = maxZeros;\n  \
    \      long onesMin = ones;\n        long zerosMin = zeros;\n        long onesSum\
    \ = 0;\n        long zerosSum = 0;\n        long onesCount = 0;\n        long\
    \ zerosCount = 0;\n        long onesSum2 = 0;\n        long zerosSum2 = 0;\n \
    \       long onesCount2 = 0;\n        long zerosCount2 = 0;\n        long onesSum3\
    \ = 0;\n        long zerosSum3 = 0;\n        long onesCount3 = 0;\n        long\
    \ zerosCount3 = 0;\n        long onesSum4 = 0;\n        long zerosSum4 = 0;\n\
    \        long onesCount4 = 0;\n        long zerosCount4 = 0;\n        long onesSum5\
    \ = 0;\n        long zerosSum5 = 0;\n        long onesCount5 = 0;\n        long\
    \ zerosCount5 = 0;\n        long onesSum6 = 0;\n        long zerosSum6 = 0;\n\
    \        long onesCount6 = 0;\n        long zerosCount6 = 0;\n        long onesSum7\
    \ = 0;\n        long zerosSum7 = 0;\n        long onesCount7 = 0;\n        long\
    \ zerosCount7 = 0;\n        long onesSum8 = 0;\n        long zerosSum8 = 0;\n\
    \        long onesCount8 = 0;\n        long zerosCount8 = 0;\n        long onesSum9\
    \ = 0;\n        long zerosSum9 = 0;\n        long onesCount9 = 0;\n        long\
    \ zerosCount9 = 0;\n        long onesSum10 = 0;\n        long zerosSum10 = 0;\n\
    \        long onesCount10 = 0;\n        long zerosCount10 = 0;\n        long onesSum11\
    \ = 0;\n        long zerosSum11 = 0;\n        long onesCount11 = 0;\n        long\
    \ zerosCount11 = 0;\n        long onesSum12 = 0;\n        long zerosSum12 = 0;\n\
    \        long onesCount12 = 0;\n        long zerosCount12 = 0;\n        long onesSum13\
    \ = 0;\n        long zerosSum13 = 0;\n        long onesCount13 = 0;\n        long\
    \ zerosCount13 = 0;\n        long onesSum14 = 0;\n        long zerosSum14 = 0;\n\
    \        long onesCount14 = 0;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv7j_12wk.cs(35,14): warning CS0219: The variable ''onesSum'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(36,14): warning CS0219: The variable ''zerosSum'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(37,14): warning CS0219: The variable ''onesCount'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(38,14): warning CS0219: The variable ''zerosCount'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(39,14): warning CS0219: The variable ''onesSum2'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(40,14): warning CS0219: The variable ''zerosSum2'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(41,14): warning CS0219: The variable ''onesCount2'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(42,14): warning CS0219: The variable ''zerosCount2'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(43,14): warning CS0219: The variable ''onesSum3'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(44,14): warning CS0219: The variable ''zerosSum3'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(45,14): warning CS0219: The variable ''onesCount3'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(46,14): warning CS0219: The variable ''zerosCount3'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(47,14): warning CS0219: The variable ''onesSum4'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(48,14): warning CS0219: The variable ''zerosSum4'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(49,14): warning CS0219: The variable ''onesCount4'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(50,14): warning CS0219: The variable ''zerosCount4'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(51,14): warning CS0219: The variable ''onesSum5'' is assigned
    but its value is never used

    /tmp/tmpv7j_12wk.cs(52,14): warning CS0219: The variable ''zerosSu'
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                max = Math.Max(max, Math.Abs(i - ones));\n            }\n   \
    \     }\n        List<long> result = new List<long>();\n        long onesMax =\
    \ ones + zeros;\n        long zeroMax = zeros + ones;\n        if (onesMax > zeroMax)\
    \ {\n            long onesMaxDiff = onesMax - zeroMax;\n            long zeroMaxDiff\
    \ = zeroMax - onesMax;\n            long onesMaxDiffDiff = onesMaxDiff - zeroMaxDiff;\n\
    \            long zeroMaxDiffDiff = zeroMaxDiff - onesMaxDiff;\n            long\
    \ onesMaxDiffDiffDiff = onesMaxDiffDiff - zeroMaxDiffDiff;\n            long zeroMaxDiffDiffDiff\
    \ = zeroMaxDiffDiff - onesMaxDiffDiff;\n            long onesMaxDiffDiffDiffDiff\
    \ = onesMaxDiffDiffDiff - zeroMaxDiffDiffDiff;\n            long zeroMaxDiffDiffDiffDiff\
    \ = zeroMaxDiffDiffDiff - onesMaxDiffDiffDiff;\n            long onesMaxDiffDiffDiffDiffDiff\
    \ = onesMaxDiffDiffDiffDiff - zeroMaxDiffDiffDiffDiff;\n            long zeroMaxDiffDiffDiffDiffDiff\
    \ = zeroMaxDiffDiffDiffDiff - onesMaxDiffDiffDiffDiffDiff;\n            long onesMaxDiffDiffDiffDiffDiffDiff\
    \ = onesMaxDiffDiffDiffDiffDiff - zeroMaxDiffDiffDiffDiffDiff;\n            long\
    \ zeroMaxDiffDiffDiffDiffDiffDiff = zeroMaxDiffDiffDiffDiffDiff - onesMaxDiffDiffDiffDiffDiffDiff;\n\
    \            long onesMaxDiffDiffDiffDiffDiffDiffDiff = onesMaxDiffDiffDiffDiffDiffDiffDiff\
    \ - zeroMaxDiffDiffDiffDiffDiffDiffDiff;\n            long zeroMaxDiffDiffDiffDiffDiffDiffDiff\
    \ = zeroMaxDiffDiffDiffDiffDiffDiffDiff - onesMaxDiffDiffDiffDiffDiffDiffDiff;\n\
    \            long onesMaxDiffDiffDiffDiffDiffDiffDiffDiff = onesMaxDiffDiffDiffDiffDiffDiffDiffDiffDiff\
    \ - zeroMaxDiffDiffDiffDiffDiffDiffDiffDiff;\n            long zeroMaxDiffDiffDiffDiffDiffDiffDiffDiff\
    \ = zeroMaxDiffDiffDiff\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp314t0yty.cs(53,79): error CS1002: ; expected

    /tmp/tmp314t0yty.cs(55,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp314t0yty.cs(66,2): error CS1513: } expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) {\n                ones++;\n            }\n          \
    \  if (num == 0) {\n                zeros++;\n            }\n            if (num\
    \ > max) {\n                max = num;\n            }\n        }\n        long\
    \ onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n\
    \        long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin\
    \ = max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n\
    \        long maxMaxMin = max;\n        long onesMinMax = ones;\n        long\
    \ zerosMinMax = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax\
    \ = ones;\n        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n\
    \        long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n  \
    \      long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n     \
    \   long zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n   \
    \     long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnr70di18.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x >> 1);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesOnes = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesZeroOnes = maxOnes - ones - zeros - ones;\n        long\
    \ maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - zeros;\n        long maxOnesOnesZeroOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros;\n        long maxOnesZeroOnesOnesZeroOnes\
    \ = maxOnes - zeros - ones - zeros - ones;\n        long maxOnesOnesZeroOnesZeroOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones;\n        long maxOnesZeroOnesOnesZeroOnesZeros\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones;\n        long\
    \ maxOnesZeroOnesOnesZeroOnesZeroOnesZeros = maxOnes - zeros - ones - zeros -\
    \ ones - zeros - ones - zeros - ones - zeros;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnesZeroOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones\
    \ - zeros - ones;\n        long maxOnesZeroOnesOnesZeroOnesZeroOnesZeroOnesZeros\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros\
    \ - ones - zeros - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesZeros\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones\
    \ - zeros - ones - zeros - ones - zeros;\n        long max\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjl6lh4_v.cs(40,17): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr;\n        }\n        long maxOnes = arr.Max(x => x\
    \ & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        if (maxOnes ==\
    \ maxZeros) {\n            return arr.OrderBy(x => x).ToList();\n        }\n \
    \       long maxOnesDec = arr.Max(x => Convert.ToInt32(Math.Pow(2, Convert.ToInt32(Math.Log(x)))));\n\
    \        long maxZerosDec = arr.Max(x => Convert.ToInt32(Math.Pow(2, Convert.ToInt32(Math.Log(x)))));\n\
    \        if (maxOnesDec == maxZerosDec) {\n            return arr.OrderBy(x =>\
    \ x).ToList();\n        }\n        long maxOnesBin = arr.Max(x => Convert.ToInt32(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(x)))));\n        long maxZerosBin = arr.Max(x => Convert.ToInt32(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(x)))));\n        if (maxOnesBin == maxZerosBin) {\n\
    \            return arr.OrderBy(x => x).ToList();\n        }\n        long maxOnesBinDec\
    \ = arr.Max(x => Convert.ToInt32(Math.Pow(2, Convert.ToInt32(Math.Log(x)))));\n\
    \        long maxZerosBinDec = arr.Max(x => Convert.ToInt32(Math.Pow(2, Convert.ToInt32(Math.Log(x)))));\n\
    \        if (maxOnesBinDec == maxZerosBinDec) {\n            return arr.OrderBy(x\
    \ => x).ToList();\n        }\n        long maxOnesBinBin = arr.Max(x => Convert.ToInt32(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(x)))));\n        long maxZerosBinBin = arr.Max(x =>\
    \ Convert.ToInt32(Math.Pow(2, Convert.ToInt32(Math.Log(x)))));\n        if (maxOnesBinBin\
    \ == maxZerosBinBin) {\n            return arr.OrderBy(x => x).ToList();\n   \
    \     }\n        long maxOnesBinBinDec = arr.Max(x => Convert.ToInt32(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(x)))));\n        long maxZerosBinBinDec = arr.Max(x\
    \ => Convert.To\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpix84je4h.cs(51,57): error CS1026: ) expected

    /tmp/tmpix84je4h.cs(51,57): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long\
    \ maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n     \
    \   long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n  \
    \      long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuaviubh3.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long onesMin = ones * min;\n        long\
    \ zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long\
    \ maxOnesMax = onesMax * max;\n        long maxOnesMin = onesMax * min;\n    \
    \    long maxZerosMax = zerosMax * max;\n        long maxZerosMin = zerosMax *\
    \ min;\n        long minOnesMax = onesMin * max;\n        long minOnesMin = onesMin\
    \ * min;\n        long minZerosMax = zerosMin * max;\n        long minZerosMin\
    \ = zerosMin * min;\n        long maxOnesMin = onesMin * max;\n        long maxOnesMax\
    \ = onesMax * max;\n        long minOnesMax = onesMin * max;\n        long minOnesMin\
    \ = onesMin * min;\n        long minZerosMin = zerosMin * min;\n        long minZerosMax\
    \ = zerosMax * min;\n        long maxOnesMax = onesMax * max;\n        long maxOnesMin\
    \ = onesMax * min;\n        long minOnesMax = onesMin * max;\n        long minOnesMin\
    \ = onesMin * min;\n        long minZerosMin = zerosMin * min;\n        long minZerosMax\
    \ = zerosMax * min;\n        long maxOnesMin = onesMin * max;\n        long maxOnesMax\
    \ = onesMax * max;\n        long minOnesMax = onesMin * max;\n        long minOnesMin\
    \ = onesMin * min;\n        long minZerosMin = zerosMin * min;\n        long minZerosMax\
    \ = zerosMax * min;\n        long maxOnesMin = onesMin * max;\n        long maxOnesMax\
    \ = onesMax * max;\n        long \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqx9l2s6n.cs(70,13): error CS1001: Identifier expected

    /tmp/tmpqx9l2s6n.cs(70,13): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long total = 0;\n        foreach (long i\
    \ in arr) {\n            total += i;\n            if (i < 0) continue;\n     \
    \       if (i >= 1000) {\n                thousands += i;\n                continue;\n\
    \            }\n            if (i >= 100) {\n                hundreds += i;\n\
    \                continue;\n            }\n            if (i >= 10) {\n      \
    \          tens += i;\n                continue;\n            }\n            if\
    \ (i >= 1) {\n                ones += i;\n                continue;\n        \
    \    }\n        }\n        long onesCount = ones;\n        long tensCount = tens;\n\
    \        long hundredsCount = hundreds;\n        long thousandsCount = thousands;\n\
    \        long totalCount = total;\n        if (onesCount > hundredsCount) {\n\
    \            hundredsCount = onesCount;\n        }\n        if (hundredsCount\
    \ > thousandsCount) {\n            thousandsCount = hundredsCount;\n        }\n\
    \        if (thousandsCount > totalCount) {\n            totalCount = thousandsCount;\n\
    \        }\n        if (totalCount > 1) {\n            onesCount = totalCount;\n\
    \        }\n        if (onesCount > 1) {\n            tensCount = onesCount;\n\
    \        }\n        if (tensCount > 1) {\n            hundredsCount = tensCount;\n\
    \        }\n        if (hundredsCount > 1) {\n            thousandsCount = hundredsCount;\n\
    \        }\n        if (thousandsCount > 1) {\n            totalCount = thousandsCount;\n\
    \        }\n        if (totalCount > 1) {\n            onesCount = totalCount;\n\
    \        }\n        if (onesCount > 1) {\n            tensCount = onesCount;\n\
    \        }\n        if (tensCount > 1) {\n            hundredsCount = tensCount;\n\
    \        }\n        if (hundredsCount > 1) {\n            thousandsCount = hundredsCount;\n\
    \        }\n        if (thousandsCount > 1) {\n            totalCount = thousandsCount;\n\
    \        }\n        if (totalCount > 1) {\n            onesCount = totalCount;\n\
    \        }\n        if (onesCount > 1) {\n            tensCount = onesCount;\n\
    \        }\n        if (tensCount > 1) {\n            hundredsCount = tensCount;\n\
    \        }\n        if (hundredsCount > 1) {\n            thousandsCount = hundredsCount;\n\
    \        }\n        if (thousandsCount > 1) {\n            totalCount = thousandsCount;\n\
    \        }\n        if (totalCount > \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgf48lrxj.cs(105,25): error CS1525: Invalid expression term ''}''

    /tmp/tmpgf48lrxj.cs(105,25): error CS1026: ) expected

    /tmp/tmpgf48lrxj.cs(105,25): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        long max = Math.Max(ones,\
    \ zeros);\n        long min = Math.Min(ones, zeros);\n        long mid = max /\
    \ 2;\n        long mid2 = min / 2;\n        long mid3 = mid / 3;\n        long\
    \ mid4 = mid2 / 3;\n        long mid5 = mid3 / 3;\n        long mid6 = mid4 /\
    \ 3;\n        long mid7 = mid5 / 3;\n        long mid8 = mid6 / 3;\n        long\
    \ mid9 = mid7 / 3;\n        long mid10 = mid8 / 3;\n        long mid11 = mid9\
    \ / 3;\n        long mid12 = mid10 / 3;\n        long mid13 = mid11 / 3;\n   \
    \     long mid14 = mid12 / 3;\n        long mid15 = mid13 / 3;\n        long mid16\
    \ = mid14 / 3;\n        long mid17 = mid15 / 3;\n        long mid18 = mid16 /\
    \ 3;\n        long mid19 = mid17 / 3;\n        long mid20 = mid18 / 3;\n     \
    \   long mid21 = mid19 / 3;\n        long mid22 = mid20 / 3;\n        long mid23\
    \ = mid21 / 3;\n        long mid24 = mid22 / 3;\n        long mid25 = mid23 /\
    \ 3;\n        long mid26 = mid24 / 3;\n        long mid27 = mid25 / 3;\n     \
    \   long mid28 = mid26 / 3;\n        long mid29 = mid27 / 3;\n        long mid30\
    \ = mid28 / 3;\n        long mid31 = mid29 / 3;\n        long mid32 = mid30 /\
    \ 3;\n        long mid33 = mid31 / 3;\n        long mid34 = mid32 / 3;\n     \
    \   long mid35 = mid33 / 3;\n        long mid36 = mid34 / 3;\n        long mid37\
    \ = mid35 / 3;\n        long mid38 = mid36 / 3;\n        long mid39 = mid37 /\
    \ 3;\n        long mid40 = mid38 / 3;\n        long mid41 = mid39 / 3;\n     \
    \   long mid42 = mid40 / 3;\n        long mid43 = mid41 / 3;\n        long mid44\
    \ = mid42 / 3;\n        long mid45 = mid43 / 3;\n        long mid46 = mid44 /\
    \ 3;\n        long mid47 = mid45 / 3;\n        long mid48 = mid\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp14g4epmk.cs(71,25): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ maxOnes = arr.Max(x => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n\
    \        if (maxOnes == maxZeros) {\n            return arr.OrderBy(x => x).ToList();\n\
    \        }\n        long maxOnesPow2 = maxOnes >> 1;\n        long maxZerosPow2\
    \ = maxZeros >> 1;\n        long maxOnesPow2PlusOne = maxOnesPow2 + 1L;\n    \
    \    long maxZerosPow2PlusOne = maxZerosPow2 + 1L;\n        long maxOnesPow2MinusOne\
    \ = maxOnesPow2 - 1L;\n        long maxZerosPow2MinusOne = maxZerosPow2 - 1L;\n\
    \        long maxOnesPow2PlusOneMinusOne = maxOnesPow2PlusOne - 1L;\n        long\
    \ maxZerosPow2PlusOneMinusOne = maxZerosPow2PlusOne - 1L;\n        long maxOnesPow2MinusOneMinusOne\
    \ = maxOnesPow2MinusOne - 1L;\n        long maxZerosPow2MinusOneMinusOne = maxZerosPow2MinusOne\
    \ - 1L;\n        long maxOnesPow2PlusOneMinusOneMinusOne = maxOnesPow2PlusOneMinusOne\
    \ - 1L;\n        long maxZerosPow2PlusOneMinusOneMinusOne = maxZerosPow2PlusOneMinusOne\
    \ - 1L;\n        long maxOnesPow2MinusOneMinusOneMinusOne = maxOnesPow2MinusOneMinusOne\
    \ - 1L;\n        long maxZerosPow2MinusOneMinusOneMinusOne = maxZerosPow2MinusOneMinusOne\
    \ - 1L;\n        long maxOnesPow2PlusOneMinusOneMinusOneMinusOne = maxOnesPow2PlusOneMinusOneMinusOne\
    \ - 1L;\n        long maxZerosPow2PlusOneMinusOneMinusOneMinusOne = maxZerosPow2PlusOneMinusOneMinus\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpi8wg9ycp.cs(45,92): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1);\n        long zeros = arr.Sum(x => ~x);\n        long maxOnes = arr.Max(x\
    \ => x & 1);\n        long maxZeros = arr.Max(x => ~x);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnesZeros - ones;\n        long maxOnesOnesOnes = maxOnesOnes\
    \ - ones;\n        long maxOnesZeroZeroOnes = maxOnesZeroOnes - ones;\n      \
    \  long maxOnesOnesZeroOnes = maxOnesOnesOnes - ones;\n        long maxOnesZeroZeroOnes\
    \ = maxOnesZeroZeroOnes - ones;\n        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroOnes\
    \ - ones;\n        long maxOnesZeroZeroZeroOnes = maxOnesZeroZeroOnes - ones;\n\
    \        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes - ones;\n    \
    \    long maxOnesZeroZeroZeroOnes = maxOnesZeroZeroZeroOnes - ones;\n        long\
    \ maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes - ones;\n        long maxOnesZeroZeroZeroOnes\
    \ = maxOnesZeroZeroZeroOnes - ones;\n        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes\
    \ - ones;\n        long maxOnesZeroZeroZeroOnes = maxOnesZeroZeroZeroOnes - ones;\n\
    \        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes - ones;\n    \
    \    long maxOnesZeroZeroZeroOnes = maxOnesZeroZeroZeroOnes - ones;\n        long\
    \ maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes - ones;\n        long maxOnesZeroZeroZeroOnes\
    \ = maxOnesZeroZeroZeroOnes - ones;\n        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes\
    \ - ones;\n        long maxOnesZeroZeroZeroOnes = maxOnesZeroZeroZeroOnes - ones;\n\
    \        long maxOnesOnesZeroZeroOnes = maxOnesOnesZeroZeroOnes - ones;\n    \
    \    long maxOnesZeroZeroZeroOnes = maxOne\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp64i68qp5.cs(46,46): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            } else if (i == 0L)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            long onesMax = ones > max ? max : ones;\n\
    \            long zerosMax = zeros > max ? max : zeros;\n            long onesMin\
    \ = ones < min ? min : ones;\n            long zerosMin = zeros < min ? min :\
    \ zeros;\n            long onesMaxMin = onesMax < onesMin ? onesMax : onesMin;\n\
    \            long zerosMaxMin = zerosMax < zerosMin ? zerosMax : zerosMin;\n \
    \           long onesMaxMinMin = onesMaxMin < onesMaxMin ? onesMaxMin : onesMaxMin;\n\
    \            long zerosMaxMinMin = zerosMaxMin < zerosMaxMin ? zerosMaxMin : zerosMaxMin;\n\
    \            long onesMaxMinMinMin = onesMaxMinMin < onesMaxMinMin ? onesMaxMinMin\
    \ : onesMaxMinMin;\n            long zerosMaxMinMinMin = zerosMaxMinMin < zerosMaxMinMin\
    \ ? zerosMaxMinMin : zerosMaxMinMin;\n            long onesMaxMinMinMinMin = onesMaxMinMinMin\
    \ < onesMaxMinMinMin ? onesMaxMinMinMin : onesMaxMinMinMin;\n            long\
    \ zerosMaxMinMinMinMin = zerosMaxMinMinMin < zerosMaxMinMinMin ? zerosMaxMinMinMin\
    \ : zerosMaxMinMinMin;\n            long onesMaxMinMinMinMinMin = onesMaxMinMinMinMin\
    \ < onesMaxMinMinMinMin ? onesMaxMinMinMinMin : onesMaxMinMinMinMinMin;\n    \
    \        long zerosMaxMinMinMinMinMin = zerosMaxMinMinMinMin < zerosMaxMinMinMinMin\
    \ ? zerosMaxMinMinMinMin : zerosMaxMinMinMinMinMin;\n            long onesMaxMinMinMinMinMin\
    \ = onesMaxMinMinMinMinMin < onesMaxMinMinMinMinMin ? onesMaxMinMinMinMinMin :\
    \ onesMaxMinMinMinMinMin;\n            long zerosMaxMinMinMinMinMin = zerosMaxMinMinMinMin\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbohmlmdq.cs(49,64): error CS1002: ; expected

    /tmp/tmpbohmlmdq.cs(51,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpbohmlmdq.cs(62,2): error CS1513: } expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            ones += i;\n            zeros -= i;\n            max\
    \ = Math.Max(max, i);\n            min = Math.Min(min, i);\n        }\n      \
    \  long onesCount = 0;\n        long zerosCount = 0;\n        long maxCount =\
    \ 0;\n        long minCount = 0;\n        foreach (long i in arr) {\n        \
    \    onesCount += i;\n            zerosCount -= i;\n            maxCount = Math.Max(maxCount,\
    \ i);\n            minCount = Math.Min(minCount, i);\n        }\n        long\
    \ onesCountMinusOnes = onesCount - 1;\n        long zerosCountMinusOnes = zerosCount\
    \ - 1;\n        long maxCountMinusOnes = maxCount - 1;\n        long minCountMinusOnes\
    \ = minCount - 1;\n        long onesCountMinusOnesMinusOnes = onesCountMinusOnes\
    \ - 1;\n        long zerosCountMinusOnesMinusOnes = zerosCountMinusOnes - 1;\n\
    \        long maxCountMinusOnesMinusOnes = maxCountMinusOnes - 1;\n        long\
    \ minCountMinusOnesMinusOnes = minCountMinusOnes - 1;\n        long onesCountMinusOnesMinusOnesMinusOnes\
    \ = onesCountMinusOnesMinusOnes - 1;\n        long zerosCountMinusOnesMinusOnesMinusOnes\
    \ = zerosCountMinusOnesMinusOnes - 1;\n        long maxCountMinusOnesMinusOnesMinusOnes\
    \ = maxCountMinusOnesMinusOnes - 1;\n        long minCountMinusOnesMinusOnesMinusOnes\
    \ = minCountMinusOnesMinusOnes - 1;\n        long onesCountMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = onesCountMinusOnesMinusOnesMinusOnes - 1;\n        long zerosCountMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = zerosCountMinusOnesMinusOnesMinusOnes - 1;\n        long maxCountMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxCountMinusOnesMinusOnesMinusOnes - 1;\n        long minCountMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = minCountMinusOnesMinusOne\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzeu01yh3.cs(55,86): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesOnesZeros = maxOnesOnes - maxZeros;\n        long maxOnesOnesOnes = maxOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesZeros = maxOnesOnesOnes - maxZeros;\n \
    \       long maxOnesOnesOnesOnes = maxOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros\
    \ = maxOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros -\
    \ maxZeros;\n        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnes -\
    \ ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n\
    \        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnes - ones;\n\
    \        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros - maxZeros;\n\
    \        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnesOnes -\
    \ ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros\
    \ - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnesOnesOnes\
    \ - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpssvuktv0.cs(40,76): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMaxMax = onesMax;\n        long zerosMaxMax = zerosMax;\n        long\
    \ maxMaxMax = maxMax;\n        long onesMaxMaxMax = onesMaxMax;\n        long\
    \ zerosMaxMaxMax = zerosMaxMax;\n        long maxMaxMaxMax = maxMaxMax;\n    \
    \    long onesMaxMaxMaxMax = onesMaxMaxMax;\n        long zerosMaxMaxMaxMax =\
    \ zerosMaxMaxMax;\n        long maxMaxMaxMaxMax = maxMaxMaxMaxMax;\n        long\
    \ onesMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMax;\n        long zerosMaxMaxMaxMaxMax\
    \ = zerosMaxMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMax;\n\
    \        long onesMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMax;\n        long zerosMaxMaxMaxMaxMaxMax\
    \ = zerosMaxMaxMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMaxMaxMax;\n\
    \        long onesMaxMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMaxMaxMax;\n    \
    \    long zerosMaxMaxMaxMaxMaxMaxMax = zerosMaxMaxMaxMaxMaxMaxMaxMax;\n      \
    \  long maxMaxMaxMaxMaxMaxMaxMax = maxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ onesMaxMaxMaxMaxMaxMaxMaxMax = onesMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long\
    \ zerosMaxMaxMaxMaxMaxMaxMax = zerosMaxMaxMaxMaxMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMaxMaxMax\
    \ = maxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long onesMaxMaxMaxMaxMaxMaxMaxMax\
    \ = onesMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long zerosMaxMaxMaxMaxMaxMaxMaxMax\
    \ = zerosMaxMaxMaxMaxMaxMaxMaxMaxMaxMax;\n        long maxMaxMaxMaxMaxMaxMax\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp47acous_.cs(60,35): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroOnesZeros = maxOnes - zeros - ones;\n\
    \        long maxOnesOnesZeroOnes = maxOnes - ones - zeros - zeros;\n        long\
    \ maxOnesZeroOnesOnes = maxOnes - zeros - ones - ones;\n        long maxOnesOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - ones;\n        long\
    \ maxOnesOnesZeroOnesZeroOnesZeroOnesOnes = maxOnes - ones - zeros - ones - zeros\
    \ - ones - zeros - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros\
    \ - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones\
    \ - zeros - ones - zeros - ones - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros\
    \ - ones - zeros - ones - zeros - ones - zeros - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnesZeroOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp35eai_zv.cs(39,49): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ num in arr) {\n            ones += num;\n            zeros -= num;\n       \
    \     if (ones > max) {\n                max = ones;\n            }\n        \
    \    if (zeros > min) {\n                min = zeros;\n            }\n       \
    \ }\n        List<long> result = new List<long>();\n        foreach (long num\
    \ in arr) {\n            if (num == 1) {\n                result.Add(num);\n \
    \           }\n            else if (num == 0) {\n                result.Add(zeros);\n\
    \            }\n            else {\n                result.Add(max - min);\n \
    \           }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <3944cc590cca4e26966ee125ed34e261>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <3944cc590cca4e26966ee125ed34e261>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnesZeros - ones;\n        long maxOnesOneOnes = maxOnesOnes\
    \ - ones;\n        long maxOnesZeroZeroOnes = maxOnesZeroZeros - ones;\n     \
    \   long maxOnesOneZeroOnes = maxOnesOneZeroOnes - ones;\n        long maxOnesZeroOneOnes\
    \ = maxOnesZeroOneOnes - ones;\n        long maxOnesOneZeroZeroOnes = maxOnesOneZeroZeroOnes\
    \ - ones;\n        long maxOnesZeroZeroZeros = maxOnesZeroOneZeroOnes - ones;\n\
    \        long maxOnesOneZeroZeroOnes = maxOnesOneZeroZeroZeros - ones;\n     \
    \   long maxOnesZeroOneOneOnes = maxOnesZeroZeroOneOnes - ones;\n        long\
    \ maxOnesOneZeroZeroZeros = maxOnesOneZeroOneOnes - ones;\n        long maxOnesZeroZeroOneOnes\
    \ = maxOnesOneZeroZeroZeros - ones;\n        long maxOnesOneZeroZeroZeros = maxOnesZeroOneOneOnes\
    \ - ones;\n        long maxOnesZeroOneOneOnes = maxOnesOneZeroZeros - ones;\n\
    \        long maxOnesOneZeroZeroZeros = maxOnesZeroOneOneOnes - ones;\n      \
    \  long maxOnesZeroZeroOneOnes = maxOnesOneZeroZeroZeros - ones;\n        long\
    \ maxOnesOneZeroZeroZeros = maxOnesZeroOneOneOnes - ones;\n        long maxOnesZeroOneOneOnes\
    \ = maxOnesOneZeroZeros - ones;\n        long maxOnesOneZeroZeroZeros = maxOnesZeroOneOneOnes\
    \ - ones;\n        long maxOnesZeroZeroOneOnes = maxOnesOneZeroZeroZeros - ones;\n\
    \        long maxOnesOneZeroZeroZeros = maxOnesZeroOneOneOnes - ones;\n      \
    \  long maxOnesZeroOneOneOnes = maxOnesOneZeroZeros - ones;\n        \n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpaj9as64z.cs(28,36): error CS0103: The name ''maxOnesZeroZeros'' does not
    exist in the current context

    /tmp/tmpaj9as64z.cs(32,37): error CS0103: The name ''maxOnesZeroOneZeroOnes''
    does not exist in the current context

    /tmp/tmpaj9as64z.cs(33,14): error CS0128: A local variable or function named ''maxOnesOneZeroZeroOnes''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(33,39): error CS0841: Cannot use local variable ''maxOnesOneZeroZeroZeros''
    before it is declared

    /tmp/tmpaj9as64z.cs(34,38): error CS0841: Cannot use local variable ''maxOnesZeroZeroOneOnes''
    before it is declared

    /tmp/tmpaj9as64z.cs(35,40): error CS0103: The name ''maxOnesOneZeroOneOnes'' does
    not exist in the current context

    /tmp/tmpaj9as64z.cs(37,14): error CS0128: A local variable or function named ''maxOnesOneZeroZeroZeros''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(38,14): error CS0128: A local variable or function named ''maxOnesZeroOneOneOnes''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(38,38): error CS0103: The name ''maxOnesOneZeroZeros'' does
    not exist in the current context

    /tmp/tmpaj9as64z.cs(39,14): error CS0128: A local variable or function named ''maxOnesOneZeroZeroZeros''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(40,14): error CS0128: A local variable or function named ''maxOnesZeroZeroOneOnes''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(41,14): error CS0128: A local variable or function named ''maxOnesOneZeroZeroZeros''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(42,14): error CS0128: A local variable or function named ''maxOnesZeroOneOneOnes''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(42,38): error CS0103: The name ''maxOnesOneZeroZeros'' does
    not exist in the current context

    /tmp/tmpaj9as64z.cs(43,14): error CS0128: A local variable or function named ''maxOnesOneZeroZeroZeros''
    is already defined in this scope

    /tmp/tmpaj9as64z.cs(44,14): error CS0128: A local v'
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            arr.Sort((x, y) => Compare(ones, zeros, x, y));\n        } else\
    \ {\n            arr.Sort((x, y) => Compare(zeros, ones, x, y));\n        }\n\
    \        return arr;\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyxgsrhyh.cs(23,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    /tmp/tmpyxgsrhyh.cs(25,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         if (num == 1) {\n                ones++;\n            } else if (num\
    \ == 0) {\n                zeros++;\n            } else {\n                max\
    \ = Math.Max(num, max);\n            }\n        }\n        List<long> result =\
    \ new List<long>();\n        long onesCount = 0;\n        long zerosCount = 0;\n\
    \        long maxCount = 0;\n        foreach (long num in arr) {\n           \
    \ if (num == 1) {\n                onesCount++;\n            } else if (num ==\
    \ 0) {\n                zerosCount++;\n            } else {\n                maxCount\
    \ = Math.Max(num, maxCount);\n            }\n        }\n        if (onesCount\
    \ > zerosCount) {\n            long onesCount2 = onesCount - zerosCount;\n   \
    \         long zerosCount2 = zerosCount - onesCount;\n            long maxCount2\
    \ = max - maxCount;\n            long onesCount3 = onesCount2 + zerosCount2;\n\
    \            long zerosCount3 = zerosCount2 + onesCount2;\n            long maxCount3\
    \ = maxCount2 + maxCount2;\n            long onesCount4 = onesCount3 + zerosCount3;\n\
    \            long zerosCount4 = zerosCount3 + onesCount3;\n            long maxCount4\
    \ = maxCount3 + maxCount3;\n            long onesCount5 = onesCount4 + zerosCount4;\n\
    \            long zerosCount5 = zerosCount4 + onesCount4;\n            long maxCount5\
    \ = maxCount4 + maxCount4;\n            long onesCount6 = onesCount5 + zerosCount5;\n\
    \            long zerosCount6 = zerosCount5 + onesCount5;\n            long maxCount6\
    \ = maxCount5 + maxCount5;\n            long onesCount7 = onesCount6 + zerosCount6;\n\
    \            long zerosCount7 = zerosCount6 + onesCount6;\n            long maxCount7\
    \ = maxCount6 + maxCount6;\n            long onesCount8 = onesCount7 + zerosCount7;\n\
    \            long zerosCount8 = zerosCount7 + onesCount7;\n            long maxCount8\
    \ = maxCount7 + maxCount7;\n            long onesCount9 = onesCount8 + zerosCount8;\n\
    \            long zerosCount9 = zerosCount8 + onesCount8;\n            long maxCount9\
    \ = maxCount8 + maxCount8;\n            long onesCount10 = onesCount9 + zerosCount9;\n\
    \            long zerosCount10 = zerosCount9 + onesCount9;\n            long maxCount10\
    \ = maxCount9 + maxCount9;\n            long onesCount11 = onesCount\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp96tf3uhv.cs(73,41): error CS1002: ; expected

    /tmp/tmp96tf3uhv.cs(75,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp96tf3uhv.cs(86,2): error CS1513: } expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - max;\n        long zerosMin = zeros * min - max;\n        long\
    \ onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n  \
    \      long onesMaxMinZeros = onesMaxMin * zeros;\n        long zerosMaxMinZeros\
    \ = zerosMaxMin * zeros;\n        long onesMaxMinZerosZeros = onesMaxMinZeros\
    \ * zeros;\n        long zerosMaxMinZerosZeros = zerosMaxMinZeros * zeros;\n \
    \       long onesMaxMinZerosOnes = onesMaxMinZerosZeros * ones;\n        long\
    \ zerosMaxMinZerosOnes = zerosMaxMinZerosZeros * ones;\n        long onesMaxMinZerosOnesZeros\
    \ = onesMaxMinZerosOnes * ones;\n        long zerosMaxMinZerosOnesZeros = zerosMaxMinZerosOnes\
    \ * ones;\n        long onesMaxMinZerosOnesOnes = onesMaxMinZerosOnesZeros * ones;\n\
    \        long zerosMaxMinZerosOnesOnes = zerosMaxMinZerosOnesZeros * ones;\n \
    \       long onesMaxMinZerosOnesOnesZeros = onesMaxMinZerosOnesOnes * ones;\n\
    \        long zerosMaxMinZerosOnesOnesZeros = zerosMaxMinZerosOnesOnes * ones;\n\
    \        long onesMaxMinZerosOnesOnesOnes = onesMaxMinZerosOnesOnesZeros * ones;\n\
    \        long zerosMaxMinZerosOnesOnesOnes = zerosMaxMinZerosOnesOnesZeros * ones;\n\
    \        long onesMaxMinZerosOnesOnesOnesZeros = onesMaxMinZerosOnesOnesOnes *\
    \ ones;\n        long zerosMaxMinZerosOnesOnesOnesZeros = zerosMaxMin\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp51cyplvf.cs(55,61): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            } else if (i == 0L)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i => Math.Abs((long)Math.Log10(i))));\n\
    \        } else {\n            result.AddRange(arr.OrderBy(i => Math.Abs((long)Math.Log10(i)\
    \ - Math.Abs((long)Math.Log10(max)))));\n        }\n        return result;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <989e2c830b684fc792362fcf8b72d8bc>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Negating the minimum value of a twos complement number\
    \ is invalid.\n  at Problem+<>c__DisplayClass0_0.<SortArray>b__1 (System.Int64\
    \ i) [0x00014] in <989e2c830b684fc792362fcf8b72d8bc>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys\
    \ (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext\
    \ () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable\
    \ (System.Collections.Generic.IEnumerable`1[T] enumerable) [0x00059] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Collections.Generic.List`1[T].InsertRange (System.Int32 ind"
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesCurr = ones;\n        long zerosCurr = zeros;\n     \
    \   long maxCurr = max;\n        long onesNext = ones;\n        long zerosNext\
    \ = zeros;\n        long maxNext = max;\n        long onesPrev = ones;\n     \
    \   long zerosPrev = zeros;\n        long maxPrev = max;\n        long onesCurrPrev\
    \ = ones;\n        long zerosCurrPrev = zeros;\n        long maxCurrPrev = max;\n\
    \        long onesNextPrev = ones;\n        long zerosNextPrev = zeros;\n    \
    \    long maxNextPrev = max;\n        long onesPrevPrev = ones;\n        long\
    \ zerosPrevPrev = zeros;\n        long maxPrevPrev = max;\n        long onesPrevCurr\
    \ = ones;\n        long zerosPrevCurr = zeros;\n        long maxPrevCurr = max;\n\
    \        long onesPrevNext = ones;\n        long zerosPrevNext = zeros;\n    \
    \    long maxPrevNext = max;\n        long onesPrevPrev = ones;\n        long\
    \ zerosPrevPrev = zeros;\n        long maxPrevPrev = max;\n        long onesPrevCurrPrev\
    \ = ones;\n        long zerosPrevCurrPrev = zeros;\n        long maxPrevCurrPrev\
    \ = max;\n        long onesPrevNextPrev = ones;\n        long zerosPrevNextPrev\
    \ = zeros;\n        long maxPrevNextPrev = max;\n        long onesPrevPrevPrev\
    \ = ones;\n        long zerosPrevPrevPrev = zeros;\n        long maxPrevPrevPrev\
    \ = max;\n        long onesPrevCurrPrev = ones;\n        long zerosPrevCurrPrev\
    \ = zeros;\n        long maxPrevCurrPrev = max;\n        long onesPrevNextPrev\
    \ = ones;\n        long zerosPrevNextPrev = zeros;\n        long maxPrevNext\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc_jfn19_.cs(81,25): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                max = Math.Max(max, i);\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        if (ones > zeros) {\n            foreach\
    \ (long i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(0L);\n\
    \                }\n                else {\n                    result.Add(max);\n\
    \                }\n            }\n        }\n        else if (ones < zeros) {\n\
    \            foreach (long i in arr) {\n                if (i == 1L) {\n     \
    \               result.Add(0L);\n                }\n                else if (i\
    \ == 0L) {\n                    result.Add(i);\n                }\n          \
    \      else {\n                    result.Add(max);\n                }\n     \
    \       }\n        }\n        else {\n            foreach (long i in arr) {\n\
    \                if (i == 1L) {\n                    result.Add(max);\n      \
    \          }\n                else if (i == 0L) {\n                    result.Add(max);\n\
    \                }\n                else {\n                    result.Add(i);\n\
    \                }\n            }\n        }\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f8f7eac9f1dd42d2a21397c03ce49d3d>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f8f7eac9f1dd42d2a21397c03ce49d3d>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr;\n        }\n        List<long> result = new List<long>();\n\
    \        long maxOnes = ones;\n        long maxZeros = zeros;\n        long maxOnesCount\
    \ = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n   \
    \     long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n        long\
    \ maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long maxZerosCount4\
    \ = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5 = 0;\n  \
    \      long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n        long\
    \ maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long maxOnesCount8\
    \ = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9 = 0;\n  \
    \      long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n        long\
    \ maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long maxZerosCount11\
    \ = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12 = 0;\n\
    \        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n       \
    \ long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15\
    \ = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n\
    \        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n       \
    \ long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18\
    \ = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n\
    \        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n       \
    \ long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n        long maxOnesCount22\
    \ = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23 = 0;\n\
    \        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n       \
    \ long maxZerosCount24\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgsahmjy2.cs(75,29): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Where(x => x\
    \ == 1).Count();\n        long zeros = arr.Where(x => x == 0).Count();\n     \
    \   long maxOnes = arr.Where(x => x == 1).Max();\n        long maxZeros = arr.Where(x\
    \ => x == 0).Max();\n        long maxOnesDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnes));\n        long maxZerosDecimal = Convert.ToInt64(Math.Pow(2, maxZeros));\n\
    \        long maxOnesDecimalDecimal = Convert.ToInt64(Math.Pow(2, maxOnesDecimal));\n\
    \        long maxZerosDecimalDecimal = Convert.ToInt64(Math.Pow(2, maxZerosDecimal));\n\
    \        long maxOnesDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2, maxOnesDecimalDecimal));\n\
    \        long maxZerosDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2, maxZerosDecimalDecimal));\n\
    \        long maxOnesDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesDecimalDecimalDecimal));\n        long maxZerosDecimalDecimalDecimalDecimal\
    \ = Convert.ToInt64(Math.Pow(2, maxZerosDecimalDecimalDecimalDecimal));\n    \
    \    long maxOnesDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesDecimalDecimalDecimalDecimalDecimal));\n        long maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToInt64(Math.Pow(2, maxZerosDecimalDecimalDecimalDecimalDecimal));\n\
    \        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal));\n        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToInt64(Math.Pow(2, maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal));\n\
    \        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal));\n       \
    \ long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal));\n      \
    \  long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal));\n\
    \        long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToInt64(Math.Pow(2,\
    \ maxZerosDecimalDecimalDecimalDecimalDecimal\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpt9n59y9r.cs(39,145): error CS1026: ) expected

    /tmp/tmpt9n59y9r.cs(39,145): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            } else {\n\
    \                zeros++;\n            }\n        }\n        long onesMax = ones;\n\
    \        long zerosMax = zeros;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n\
    \        long onesMinMax = ones;\n        long zerosMinMax = zeros;\n        long\
    \ onesMaxMinMax = ones;\n        long zerosMaxMinMax = zeros;\n        long onesMinMaxMinMax\
    \ = ones;\n        long zerosMaxMinMaxMin = zeros;\n        long onesMaxMinMaxMinMax\
    \ = ones;\n        long zerosMaxMinMaxMinMax = zeros;\n        long onesMaxMinMaxMinMaxMin\
    \ = ones;\n        long zerosMaxMinMaxMinMaxMin = zeros;\n        long onesMaxMinMaxMinMaxMinMax\
    \ = ones;\n        long zerosMaxMinMaxMinMaxMinMax = zeros;\n        long onesMaxMinMaxMinMaxMinMaxMin\
    \ = ones;\n        long zerosMaxMinMaxMinMaxMinMaxMin = zeros;\n        long onesMaxMinMaxMinMaxMinMaxMinMax\
    \ = ones;\n        long zerosMaxMinMaxMinMaxMinMaxMinMax = zeros;\n        long\
    \ onesMaxMinMaxMinMaxMinMaxMinMaxMin = ones;\n        long zerosMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = zeros;\n        long onesMaxMinMaxMinMaxMinMaxMinMaxMinMax = ones;\n     \
    \   long zerosMaxMinMaxMinMaxMinMaxMinMaxMinMax = zeros;\n        long onesMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = ones;\n        long zerosMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = zeros;\n \
    \       long onesMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = ones;\n        long zerosMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = zeros;\n        long onesMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = ones;\n\
    \        long zerosMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = zeros;\n        long\
    \ onesMaxMinMaxMinMaxMinMaxMin\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxuzd6nh2.cs(62,42): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            } else if (n == 0L)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ n);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            long onesMax = ones;\n            long\
    \ zerosMax = zeros;\n            while (onesMax < zerosMax) {\n              \
    \  result.Add(max);\n                onesMax++;\n                zerosMax--;\n\
    \            }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n\
    \                zerosMax++;\n                onesMax--;\n            }\n    \
    \    } else {\n            long zerosMax = zeros;\n            long onesMax =\
    \ ones;\n            while (zerosMax < onesMax) {\n                result.Add(max);\n\
    \                zerosMax++;\n                onesMax--;\n            }\n    \
    \        while (onesMax < zerosMax) {\n                result.Add(max);\n    \
    \            onesMax++;\n                zerosMax--;\n            }\n        }\n\
    \        return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1f8a662da78747c4927924a7ee4a74b5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1f8a662da78747c4927924a7ee4a74b5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesTwos = maxOnes - twos;\n        long maxOnesThrees = maxOnes - threes;\n\
    \        long maxOnesFours = maxOnes - fours;\n        long maxOnesFives = maxOnes\
    \ - fives;\n        long maxOnesSixes = maxOnes - sixes;\n        long maxOnesSevens\
    \ = maxOnes - sevens;\n        long maxOnesEights = maxOnes - eights;\n      \
    \  long maxOnesNines = maxOnes - nines;\n        long maxOnesTens = maxOnes -\
    \ tens;\n        long maxOnesElevens = maxOnes - elevens;\n        long maxOnesTwelves\
    \ = maxOnes - twelves;\n        long maxOnesThirteens = maxOnes - thirteens;\n\
    \        long maxOnesFourteens = maxOnes - fourteens;\n        long maxOnesFifteens\
    \ = maxOnes - fifteens;\n        long maxOnesSixteens = maxOnes - sixteens;\n\
    \        long maxOnesSeventeens = maxOnes - seventeens;\n        long maxOnesEighteens\
    \ = maxOnes - eighteens;\n        long maxOnesNineteens = maxOnes - nineteens;\n\
    \        long maxOnesTwenty = maxOnes - twenty;\n        long maxOnesThirty =\
    \ maxOnes - thirty;\n        long maxOnesFourty = maxOnes - fourty;\n        long\
    \ maxOnesFifty = maxOnes - fifty;\n        long maxOnesSixty = maxOnes - sixty;\n\
    \        long maxOnesSeventy = maxOnes - seventy;\n        long maxOnesEighty\
    \ = maxOnes - eighty;\n        long maxOnesNinety = maxOnes - ninety;\n      \
    \  long maxOnesOne = maxOnes - one;\n        long maxOnesTwo = maxOnes - \n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpopicbv31.cs(53,36): error CS1525: Invalid expression term ''}''

    /tmp/tmpopicbv31.cs(53,36): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) + 1);\n     \
    \       long onesMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 1) + 1);\n            long onesMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 2));\n            long onesMinMaxMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 3));\n            long onesMinMaxMinMinMax = Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(max, 2)) - 4));\n            long onesMinMaxMinMaxMinMaxMin\
    \ = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2)) - 5));\n   \
    \         long onesMinMaxMinMaxMinMaxMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,\
    \ 2)) - 6));\n            long onesMinMaxMinMaxMinMaxMinMaxMin = Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(max, 2)) - 7));\n            long onesMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2)) - 8));\n   \
    \         long onesMinMaxMinMaxMinMaxMinMaxMinMaxMin = Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(max, 2)) - 9));\n            long onesMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2)) - 10));\n  \
    \          long onesMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log(max, 2)) - 11));\n            long onesMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2)) - 12));\n  \
    \          long onesMinMaxMin\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcmhsvb3p.cs(49,31): error CS1002: ; expected

    /tmp/tmpcmhsvb3p.cs(51,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpcmhsvb3p.cs(62,2): error CS1513: } expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n\
    \            }\n            if (i == 0L) {\n                zeros++;\n       \
    \     }\n            if (i > max) {\n                max = i;\n            }\n\
    \        }\n        if (ones > zeros) {\n            long temp = ones;\n     \
    \       ones = zeros;\n            zeros = temp;\n        }\n        long temp\
    \ = 0;\n        if (ones > 0) {\n            temp = ones;\n            ones =\
    \ 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = ones;\n            ones\
    \ = 0;\n        }\n        if (zeros > 0) {\n            zeros = zeros - ones;\n\
    \        }\n        if (ones > 0) {\n            temp = one\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgoawavtn.cs(133,23): error CS1002: ; expected

    /tmp/tmpgoawavtn.cs(135,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpgoawavtn.cs(146,2): error CS1513: } expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i\
    \ => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n       \
    \ }\n        else {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log10(i))))));\n        }\n        return result;\n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <12cb05e9eb6c41e5ae3728effa3ef856>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_1 (System.Int64 i) [0x00010] in <12cb05e9eb6c41e5ae3728effa3ef856>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[]\
    \ elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext\
    \ () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable\
    \ (System.Collections.Generic.IEnumerable`1[T] enumerable) [0x00059] in <aa5dff9b31c64fce86559bbbf6cd364f>:0"
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            } else {\n\
    \                zeros++;\n            }\n        }\n        if (ones > zeros)\
    \ {\n            long temp = 0;\n            long temp2 = 0;\n            long\
    \ temp3 = 0;\n            long temp4 = 0;\n            long temp5 = 0;\n     \
    \       long temp6 = 0;\n            long temp7 = 0;\n            long temp8 =\
    \ 0;\n            long temp9 = 0;\n            long temp10 = 0;\n            long\
    \ temp11 = 0;\n            long temp12 = 0;\n            long temp13 = 0;\n  \
    \          long temp14 = 0;\n            long temp15 = 0;\n            long temp16\
    \ = 0;\n            long temp17 = 0;\n            long temp18 = 0;\n         \
    \   long temp19 = 0;\n            long temp20 = 0;\n            long temp21 =\
    \ 0;\n            long temp22 = 0;\n            long temp23 = 0;\n           \
    \ long temp24 = 0;\n            long temp25 = 0;\n            long temp26 = 0;\n\
    \            long temp27 = 0;\n            long temp28 = 0;\n            long\
    \ temp29 = 0;\n            long temp30 = 0;\n            long temp31 = 0;\n  \
    \          long temp32 = 0;\n            long temp33 = 0;\n            long temp34\
    \ = 0;\n            long temp35 = 0;\n            long temp36 = 0;\n         \
    \   long temp37 = 0;\n            long temp38 = 0;\n            long temp39 =\
    \ 0;\n            long temp40 = 0;\n            long temp41 = 0;\n           \
    \ long temp42 = 0;\n            long temp43 = 0;\n            long temp44 = 0;\n\
    \            long temp45 = 0;\n            long temp46 = 0;\n            long\
    \ temp47 = 0;\n            long temp48 = 0;\n            long temp49 = 0;\n  \
    \          long temp50 = 0;\n            long temp51 = 0;\n            long temp52\
    \ = 0;\n            long temp53 = 0;\n            long temp54 = 0;\n         \
    \   long temp55 = 0;\n            long temp56 = 0;\n            long temp57 =\
    \ 0;\n            long temp58 = 0;\n            long temp59 = 0;\n           \
    \ long temp60 = 0;\n            long temp61 = 0;\n            long temp62 = 0;\n\
    \            long temp63 = 0;\n            long temp64 = 0;\n            long\
    \ temp65 = 0;\n            long temp66 = 0;\n            long temp67 = 0;\n  \
    \          long temp68 = 0;\n            long temp69 = 0;\n            long temp70\
    \ = 0;\n            long temp71 = 0;\n            long temp72 = 0;\n         \
    \   long temp73 = 0;\n            long temp74 = 0;\n            long temp75 =\
    \ 0;\n            long temp76 = 0;\n            long temp77 = 0;\n           \
    \ \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxg8215pj.cs(110,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpxg8215pj.cs(121,2): error CS1513: } expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n\
    \            }\n            if (i == 0L) {\n                zeros++;\n       \
    \     }\n            if (i > max) {\n                max = i;\n            }\n\
    \        }\n        if (ones > zeros) {\n            result.Add(max);\n      \
    \      result.AddRange(arr.Where(i => i == max).OrderBy(i => i).ToList());\n \
    \       } else {\n            result.AddRange(arr.Where(i => i == max).OrderByDescending(i\
    \ => i).ToList());\n            result.Add(max);\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d357a03b6d3d447591db12ce5d94c8f8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d357a03b6d3d447591db12ce5d94c8f8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt32(Math.Log10(x)).ToString()).ToList();\n\
    \        }\n        return arr.OrderBy(x => Convert.ToInt32(Math.Log10(x - ones)).ToString()).ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <02edec6ebcdb4e39ac7912c195ab8740>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_2 (System.Int64 x) [0x00007] in <02edec6ebcdb4e39ac7912c195ab8740>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[]\
    \ elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1[TElement].ToList () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.Enumerable.ToList[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.SortArray\
    \ (System.Colle"
  stdout: ''
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ maxOnes = arr.Max(x => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n\
    \        if (maxOnes == maxZeros) {\n            return arr.OrderBy(x => x).ToList();\n\
    \        }\n        long maxOnesMaxZeros = arr.Max(x => x & 1L & 0L);\n      \
    \  long maxOnesMaxZerosMaxOnes = arr.Max(x => x & 1L & 0L & 1L);\n        if (maxOnesMaxZeros\
    \ == maxOnesMaxZerosMaxOnes) {\n            return arr.OrderBy(x => x).ToList();\n\
    \        }\n        long maxOnesMaxZerosMaxOnesMaxZeros = arr.Max(x => x & 1L\
    \ & 0L & 1L & 0L);\n        if (maxOnesMaxZerosMaxOnes == maxOnesMaxZerosMaxOnesMaxZeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ maxOnesMaxZerosMaxOnesMaxZerosMaxOnes = arr.Max(x => x & 1L & 0L & 1L & 0L &\
    \ 1L);\n        if (maxOnesMaxZerosMaxOnesMaxZeros == maxOnesMaxZerosMaxOnesMaxZerosMaxOnes)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ maxOnesMaxZerosMaxOnesMaxZerosMaxOnesMaxZeros = arr.Max(x => x & 1L & 0L & 1L\
    \ & 0L & 1L & 0L);\n        if (maxOnesMaxZerosMaxOnesMaxZerosMaxOnes == maxOnesMaxZerosMaxOnesMaxZerosMaxOnesMaxZeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ maxOnesMaxZerosMaxOnesMaxZerosMaxOnesMaxZerosMaxOnes = arr.Max(x => x & 1L &\
    \ 0L & 1L & 0L & 1L & 0L & 1L & 0L);\n        if (maxOnesMaxZerosMaxOne\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpns__n6w7.cs(48,34): error CS1026: ) expected

    /tmp/tmpns__n6w7.cs(48,34): error CS1525: Invalid expression term ''}''

    /tmp/tmpns__n6w7.cs(48,34): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n\
    \            }\n            if (i == 0L) {\n                zeros++;\n       \
    \     }\n            if (i > max) {\n                max = i;\n            }\n\
    \        }\n        long onesMax = ones;\n        long zerosMax = zeros;\n   \
    \     long maxMax = max;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long maxMin = max;\n        long onesMaxMin = ones;\n    \
    \    long zerosMaxMin = zeros;\n        long maxMaxMin = max;\n        long onesMinMin\
    \ = ones;\n        long zerosMinMin = zeros;\n        long maxMinMin = max;\n\
    \        long onesMaxMinMin = ones;\n        long zerosMaxMinMin = zeros;\n  \
    \      long maxMaxMinMin = max;\n        long onesMinMinMin = ones;\n        long\
    \ zerosMinMinMin = zeros;\n        long maxMinMinMin = max;\n        long onesMaxMinMinMin\
    \ = ones;\n        long zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin\
    \ = max;\n        long onesMinMinMinMin = ones;\n        long zerosMinMinMinMin\
    \ = zeros;\n        long maxMinMinMinMin = max;\n        long onesMaxMinMinMin\
    \ = ones;\n        long zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin\
    \ = max;\n        long onesMinMinMinMin = ones;\n        long zerosMinMinMinMin\
    \ = zeros;\n        long maxMinMinMinMin = max;\n        long onesMaxMinMinMin\
    \ = ones;\n        long zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin\
    \ = max;\n        long onesMinMinMinMin = ones;\n        long zerosMinMinMinMin\
    \ = zeros;\n        long maxMinMinMinMin = max;\n        long onesMaxMinMinMin\
    \ = ones;\n        long zerosMaxMinMinMin = zeros;\n        long maxMaxMinMinMin\
    \ = max;\n        long onesMinMinMinMin = ones;\n        long zerosMinMinMinMin\
    \ = zeros;\n        long maxMinMinMinMin = max;\n        long \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv3c8hh_e.cs(77,13): error CS1001: Identifier expected

    /tmp/tmpv3c8hh_e.cs(77,13): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       ones += i;\n            zeros -= i;\n            if (ones > max) {\n \
    \               max = ones;\n            }\n            if (zeros > max) {\n \
    \               max = zeros;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        foreach (long i in arr) {\n            long ones\
    \ = i;\n            long zeros = max - ones;\n            if (ones > zeros) {\n\
    \                result.Add(ones);\n            } else {\n                result.Add(zeros);\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp08_awae2.cs(35,18): error CS0136: A local or parameter named ''ones''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmp08_awae2.cs(36,18): error CS0136: A local or parameter named ''zeros''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        if (arr.Count == 0) return arr;\n\
    \        long maxOnes = arr.Max(x => x.ToString().Count(y => y == '1'));\n   \
    \     long maxDec = arr.Max(x => x.ToString().Length);\n        long maxOnesDec\
    \ = maxOnes / maxDec;\n        long maxOnesDec2 = maxOnesDec / 2;\n        long\
    \ maxOnesDec3 = maxOnesDec2 / 2;\n        long maxOnesDec4 = maxOnesDec3 / 2;\n\
    \        long maxOnesDec5 = maxOnesDec4 / 2;\n        long maxOnesDec6 = maxOnesDec5\
    \ / 2;\n        long maxOnesDec7 = maxOnesDec6 / 2;\n        long maxOnesDec8\
    \ = maxOnesDec7 / 2;\n        long maxOnesDec9 = maxOnesDec8 / 2;\n        long\
    \ maxOnesDec10 = maxOnesDec9 / 2;\n        long maxOnesDec11 = maxOnesDec10 /\
    \ 2;\n        long maxOnesDec12 = maxOnesDec11 / 2;\n        long maxOnesDec13\
    \ = maxOnesDec12 / 2;\n        long maxOnesDec14 = maxOnesDec13 / 2;\n       \
    \ long maxOnesDec15 = maxOnesDec14 / 2;\n        long maxOnesDec16 = maxOnesDec15\
    \ / 2;\n        long maxOnesDec17 = maxOnesDec16 / 2;\n        long maxOnesDec18\
    \ = maxOnesDec17 / 2;\n        long maxOnesDec19 = maxOnesDec18 / 2;\n       \
    \ long maxOnesDec20 = maxOnesDec19 / 2;\n        long maxOnesDec21 = maxOnesDec20\
    \ / 2;\n        long maxOnesDec22 = maxOnesDec21 / 2;\n        long maxOnesDec23\
    \ = maxOnesDec22 / 2;\n        long maxOnesDec24 = maxOnesDec23 / 2;\n       \
    \ long maxOnesDec25 = maxOnesDec24 / 2;\n        long maxOnesDec26 = maxOnesDec25\
    \ / 2;\n        long maxOnesDec27 = maxOnesDec26 / 2;\n        long maxOnesDec28\
    \ = maxOnesDec27 / 2;\n        long maxOnesDec29 = maxOnesDec28 / 2;\n       \
    \ long maxOnesDec30 = maxOnesDec29 / 2;\n\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkd9sfo10.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        if (maxOnes\
    \ == maxZeros) {\n            return arr.OrderBy(x => x).ToList();\n        }\n\
    \        if (maxZeros == maxOnes) {\n            return arr.OrderByDescending(x\
    \ => x).ToList();\n        }\n        long maxOnesBits = maxOnes;\n        long\
    \ maxZerosBits = maxZeros;\n        long maxOnesBitsPower = maxOnesBits;\n   \
    \     long maxZerosBitsPower = maxZerosBits;\n        while (maxOnesBitsPower\
    \ > 1L) {\n            maxOnesBitsPower /= 2L;\n            maxOnesBits = maxOnesBits\
    \ * maxOnesBitsPower;\n        }\n        while (maxZerosBitsPower > 1L) {\n \
    \           maxZerosBitsPower /= 2L;\n            maxZerosBits = maxZerosBits\
    \ * maxZerosBitsPower;\n        }\n        long maxOnesBitsPower2 = maxOnesBitsPower;\n\
    \        long maxZerosBitsPower2 = maxZerosBitsPower;\n        while (maxOnesBitsPower2\
    \ > 1L) {\n            maxOnesBitsPower2 /= 2L;\n            maxOnesBits = maxOnesBits\
    \ * maxOnesBitsPower2;\n        }\n        while (maxZerosBitsPower2 > 1L) {\n\
    \            maxZerosBitsPower2 /= 2L;\n            maxZerosBits = maxZerosBits\
    \ * maxZerosBitsPower2;\n        }\n        long maxOnesBitsPower3 = maxOnesBitsPower2;\n\
    \        long maxZerosBitsPower3 = maxZerosBitsPower2;\n        while (maxOnesBitsPower3\
    \ > 1L) {\n            maxOnesBitsPower3 /= 2L;\n            maxOnesBits = maxOnesBits\
    \ * maxOnesBitsPower3;\n        }\n        while (maxZerosBitsPower3 > 1L) {\n\
    \            maxZerosBitsPower3 /= 2L;\n            maxZerosBits = maxZerosBits\
    \ * maxZ\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4eo6df87.cs(60,47): error CS1002: ; expected

    /tmp/tmp4eo6df87.cs(62,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp4eo6df87.cs(73,2): error CS1513: } expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   } else if (i == 0L) {\n                zeros++;\n            } else {\n  \
    \              max = Math.Max(max, i);\n                min = Math.Min(min, i);\n\
    \            }\n        }\n        long onesMax = ones * max;\n        long onesMin\
    \ = ones * min;\n        long zerosMax = zeros * max;\n        long zerosMin =\
    \ zeros * min;\n        long maxDiff = max - min;\n        long minDiff = min\
    \ - max;\n        long onesDiff = ones - zeros;\n        long zerosDiff =  zeros\
    \ - ones;\n        long onesDiffDiff = onesMax - onesMin;\n        long zerosDiff\
    \ =  zeros - zerosMin;\n        long onesDiffDiffDiff = zerosMax - zerosMin;\n\
    \        long onesDiffDiffDiffDiff = onesDiffDiff - onesDiff;\n        long zerosDiff\
    \ =  zeros - zerosMin;\n        long onesDiffDiffDiffDiff = zerosMax - zerosMin;\n\
    \        long onesDiffDiffDiffDiffDiff = onesDiffDiffDiff - onesDiffDiff;\n  \
    \      long zerosDiff =  zeros - zerosMin;\n        long onesDiffDiffDiffDiffDiff\
    \ = zerosMax - zerosMin;\n        long onesDiffDiffDiffDiffDiff = onesDiffDiffDiffDiff\
    \ - onesDiffDiffDiff;\n        long zerosDiff =  zeros - zerosMin;\n        long\
    \ onesDiffDiffDiffDiffDiff = zerosMax - zerosMin;\n        long onesDiffDiffDiffDiffDiff\
    \ = onesDiffDiffDiffDiffDiff - onesDiffDiffDiffDiff;\n        long zerosDiff =\
    \  zeros - zerosMin;\n        long onesDiffDiffDiffDiffDiff = zerosMax - zerosMin;\n\
    \        long onesDiffDiffDiffDiffDiff = onesDiffDiffDiffDiffDiff - onesDiffDiffDiffDiff;\n\
    \        long zerosDiff =  zeros - zerosMin;\n        long onesDiffDiffDiffDiffDiff\
    \ = zerosMax - zerosMin;\n        long onesDiffDiffDiffDiffDiff = onesDiffDiffDiffDiffDiffDiff\
    \ - onesDiffDiffDiffDiff;\n        long zerosDiff =  zeros - zerosMin;\n     \
    \   long onesDiffDiffDiffDiffDiff = \n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpl_zinm99.cs(62,40): error CS1525: Invalid expression term ''}''

    /tmp/tmpl_zinm99.cs(62,40): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n\
    \        } else {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n        }\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgmg41itg.cs(23,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    /tmp/tmpgmg41itg.cs(25,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long maxOnes =\
    \ ones * max;\n        long maxZeros = zeros * max;\n        long maxOnesMax =\
    \ onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long maxOnesMaxMinusOnes\
    \ = maxOnesMax - 1L;\n        long maxZerosMaxMinusOnes = maxZerosMax - 1L;\n\
    \        long maxOnesMaxMinusOnesMinusOnes = maxOnesMaxMinusOnes - 1L;\n     \
    \   long maxZerosMaxMinusOnesMinusOnes = maxZerosMaxMinusOnes - 1L;\n        long\
    \ maxOnesMaxMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnes - 1L;\n\
    \        long maxZerosMaxMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = max\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7omrcxs.cs(50,84): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            } else if (i == 0L)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            foreach (long i in arr) {\n        \
    \        if (i == 1L) {\n                    result.Add(i);\n                }\
    \ else if (i == 0L) {\n                    result.Add(0L);\n                }\
    \ else {\n                    result.Add(i);\n                }\n            }\n\
    \        } else {\n            foreach (long i in arr) {\n                if (i\
    \ == 1L) {\n                    result.Add(0L);\n                } else if (i\
    \ == 0L) {\n                    result.Add(i);\n                } else {\n   \
    \                 result.Add(i);\n                }\n            }\n        }\n\
    \        Array.Sort(result.ToArray());\n        return result;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7d07ac4da2044863a46e8fc2e42cdb44>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7d07ac4da2044863a46e8fc2e42cdb44>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeroOnes = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes\
    \ - ones - zeros;\n        long maxOnesZeroZeros = maxOnes - zeros - ones;\n \
    \       long maxOnesOnesOnes = maxOnes - ones - ones;\n        long maxOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - ones;\n        long maxOnesOnesZeroOnes = maxOnes\
    \ - ones - ones - zeros;\n        long maxOnesZeroOnesZeros = maxOnes - zeros\
    \ - ones - zeros;\n        long maxOnesOnesOnesZeros = maxOnes - ones - ones -\
    \ ones;\n        long maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - ones\
    \ - zeros;\n        long maxOnesOnesZeroOnesOnes = maxOnes - ones - ones - zeros\
    \ - ones;\n        long maxOnesZeroOnesZeroOnes = maxOnes - zeros - ones - zeros\
    \ - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones\
    \ - ones - zeros;\n        long maxOnesZeroOnesZeroOnesOnes = maxOnes - zeros\
    \ - ones - zeros - ones - ones;\n        long maxOnesOnesZeroOnesZeroOnes = maxOnes\
    \ - ones - ones - zeros - ones - zeros;\n        long maxOnesZeroOnesOnesOnesZeros\
    \ = maxOnes - zeros - ones - ones - ones - ones - zeros;\n        long maxOnesOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - ones - ones - zeros - ones - zeros - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesOnes\
    \ = maxOnes - zeros - ones - ones - zeros - ones - ones - ones;\n        long\
    \ maxOnesOnesZeroOnesOnesZeroOnesOnes = maxOnes - ones - ones - zeros - ones -\
    \ zero\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqnti56rl.cs(43,95): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        long maxCount2 = 0;\n        long maxCount3\
    \ = 0;\n        long maxCount4 = 0;\n        long maxCount5 = 0;\n        long\
    \ maxCount6 = 0;\n        long maxCount7 = 0;\n        long maxCount8 = 0;\n \
    \       long maxCount9 = 0;\n        long maxCount10 = 0;\n        long maxCount11\
    \ = 0;\n        long maxCount12 = 0;\n        long maxCount13 = 0;\n        long\
    \ maxCount14 = 0;\n        long maxCount15 = 0;\n        long maxCount16 = 0;\n\
    \        long maxCount17 = 0;\n        long maxCount18 = 0;\n        long maxCount19\
    \ = 0;\n        long maxCount20 = 0;\n        long maxCount21 = 0;\n        long\
    \ maxCount22 = 0;\n        long maxCount23 = 0;\n        long maxCount24 = 0;\n\
    \        long maxCount25 = 0;\n        long maxCount26 = 0;\n        long maxCount27\
    \ = 0;\n        long maxCount28 = 0;\n        long maxCount29 = 0;\n        long\
    \ maxCount30 = 0;\n        long maxCount31 = 0;\n        long maxCount32 = 0;\n\
    \        long maxCount33 = 0;\n        long maxCount34 = 0;\n        long maxCount35\
    \ = 0;\n        long maxCount36 = 0;\n        long maxCount37 = 0;\n        long\
    \ maxCount38 = 0;\n        long maxCount39 = 0;\n        long maxCount40 = 0;\n\
    \        long maxCount41 = 0;\n        long maxCount42 = 0;\n        long maxCount43\
    \ = 0;\n        long maxCount44 = 0;\n        long maxCount45 = 0;\n        long\
    \ maxCount46 = 0;\n        long maxCount47 = 0;\n        long maxCount48 = 0;\n\
    \        long maxCount49 = 0;\n        long maxCount50 = 0;\n        long maxCount51\
    \ = 0;\n        long maxCount52 = 0;\n        long maxCount53 = 0;\n        long\
    \ maxCount54 = 0;\n        long maxCount55 = 0;\n        long maxCount56 = 0;\n\
    \        long maxCount57 = 0;\n        long maxCount58 = 0;\n        long maxCount59\
    \ = 0;\n        long maxCount60 = 0;\n        long maxCount61 = 0;\n        long\
    \ maxCount62 = 0;\n\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw5uvdk2q.cs(35,14): warning CS0219: The variable ''onesCount'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(36,14): warning CS0219: The variable ''zerosCount'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(37,14): warning CS0219: The variable ''maxCount'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(38,14): warning CS0219: The variable ''maxCount2'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(39,14): warning CS0219: The variable ''maxCount3'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(40,14): warning CS0219: The variable ''maxCount4'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(41,14): warning CS0219: The variable ''maxCount5'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(42,14): warning CS0219: The variable ''maxCount6'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(43,14): warning CS0219: The variable ''maxCount7'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(44,14): warning CS0219: The variable ''maxCount8'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(45,14): warning CS0219: The variable ''maxCount9'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(46,14): warning CS0219: The variable ''maxCount10'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(47,14): warning CS0219: The variable ''maxCount11'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(48,14): warning CS0219: The variable ''maxCount12'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(49,14): warning CS0219: The variable ''maxCount13'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(50,14): warning CS0219: The variable ''maxCount14'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(51,14): warning CS0219: The variable ''maxCount15'' is assigned
    but its value is never used

    /tmp/tmpw5uvdk2q.cs(52,14): warning CS0219: The variable ''maxC'
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    long onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n      \
    \  long maxMinMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long\
    \ maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMax = ones;\n        long\
    \ zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n        long\
    \ onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n     \
    \   long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n  \
    \      long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax = ones;\n\
    \        long zerosMinMaxMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMinMaxMaxMaxMax = ones;\n        long zerosMinMaxMaxMax = zeros;\n\
    \        long maxMinMaxMaxMax = max;\n        long onesMaxMinMax\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuaviubh3.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long tenths = 0;\n        long hundredths\
    \ = 0;\n        long thousandths = 0;\n        long tenthhundredths = 0;\n   \
    \     long hundredththousandths = 0;\n        long thousandthhundredths = 0;\n\
    \        long hundredththousandthhundredths = 0;\n        long thousandthhundredththousandths\
    \ = 0;\n        long hundredththousandthhundredththousandths = 0;\n        long\
    \ thousandthhundredththousandthhundredththousandths = 0;\n        long hundredththousandthhundredththousandthhundredththousandths\
    \ = 0;\n        long thousandthhundredththousandthhundredththousandthhundredththousandths\
    \ = 0;\n        long hundredththousandthhundredththousandthhundredththousandthhundredththousandths\
    \ = 0;\n        long thousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredths\
    \ = 0;\n        long hundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandths\
    \ = 0;\n        long thousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredths\
    \ = 0;\n        long hundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredths\
    \ = 0;\n        long thousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredths\
    \ = 0;\n        long hundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandthhundredththousandth\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp02zcztdg.cs(43,185): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ num in arr) {\n            if (num > 0) {\n                ones += num;\n  \
    \          } else {\n                zeros += num;\n            }\n          \
    \  max = Math.Max(max, num);\n            min = Math.Min(min, num);\n        }\n\
    \        List<long> result = new List<long>();\n        if (ones > 0) {\n    \
    \        result.Add(ones);\n        }\n        if (zeros > 0) {\n            result.Add(zeros);\n\
    \        }\n        if (min > 0) {\n            result.Add(min);\n        }\n\
    \        if (max > 0) {\n            result.Add(max);\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7538bc593fb54b8aa9f190480bdf5123>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7538bc593fb54b8aa9f190480bdf5123>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            if (i == 1L)\
    \ {\n                result.Add(i);\n                zeros++;\n            }\n\
    \            else if (i == 0L) {\n                result.Add(i);\n           \
    \     zeros++;\n            }\n            else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        if (ones > zeros) {\n            result.Sort((x,\
    \ y) => Compare(ones, zeros, x, y));\n        }\n        else {\n            result.Sort((x,\
    \ y) => Compare(ones, zeros, x, y));\n            result.Sort((x, y) => Compare(max,\
    \ x, y));\n        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp21mfid7_.cs(39,35): error CS0103: The name ''Compare'' does not exist
    in the current context

    /tmp/tmp21mfid7_.cs(42,35): error CS0103: The name ''Compare'' does not exist
    in the current context

    /tmp/tmp21mfid7_.cs(43,35): error CS0103: The name ''Compare'' does not exist
    in the current context

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        if (i == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            long temp = ones;\n            ones\
    \ = zeros;\n            zeros = temp;\n        }\n        long max = 0;\n    \
    \    long min = 0;\n        long max2 = 0;\n        long min2 = 0;\n        foreach\
    \ (long i in arr) {\n            if (i == 1L) {\n                max++;\n    \
    \            if (max > max2) {\n                    max2 = max;\n            \
    \    }\n                if (min > min2) {\n                    min2 = min;\n \
    \               }\n            }\n            if (i == 0L) {\n               \
    \ min++;\n                if (max > max2) {\n                    max2 = max;\n\
    \                }\n                if (min > min2) {\n                    min2\
    \ = min;\n                }\n            }\n        }\n        if (max2 > min2)\
    \ {\n            max = max2;\n            min = min2;\n        }\n        long\
    \ temp = 0;\n        long temp2 = 0;\n        long temp3 = 0;\n        long temp4\
    \ = 0;\n        long temp5 = 0;\n        long temp6 = 0;\n        long temp7 =\
    \ 0;\n        long temp8 = 0;\n        long temp9 = 0;\n        long temp10 =\
    \ 0;\n        long temp11 = 0;\n        long temp12 = 0;\n        long temp13\
    \ = 0;\n        long temp14 = 0;\n        long temp15 = 0;\n        long temp16\
    \ = 0;\n        long temp17 = 0;\n        long temp18 = 0;\n        long temp19\
    \ = 0;\n        long temp20 = 0;\n        long temp21 = 0;\n        long temp22\
    \ = 0;\n        long temp23 = 0;\n        long temp24 = 0;\n        long temp25\
    \ = 0;\n        long temp26 = 0;\n        long temp27 = 0;\n        long temp28\
    \ = 0;\n        long temp29 = 0;\n        long temp30 = 0;\n        long temp31\
    \ = 0;\n        long temp32 = 0;\n        long temp33 = 0;\n        long temp34\
    \ = 0;\n        long temp35 = 0;\n        long temp36 = 0;\n        long temp37\
    \ = 0;\n        long temp38 = 0;\n        long temp39 = 0;\n        long temp40\
    \ = 0;\n        long temp41 = 0;\n        long temp42 = 0;\n        long temp43\
    \ = 0;\n        long temp44 = 0;\n        long temp45 = 0;\n        long temp46\
    \ = 0;\n        long temp47 = 0;\n        long temp48 = 0;\n        long temp49\
    \ = 0;\n        long temp50 = 0;\n        long temp51 = 0;\n        long temp\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4tlclovt.cs(115,18): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            }\n            else\
    \ if (n == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = n;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long n in arr) {\n            if (n == 1L) {\n             \
    \   result.Add(n);\n            }\n            else if (n == 0L) {\n         \
    \       result.Add(max);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(n);\n                }\n  \
    \              else {\n                    result.Add(max);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7a0988edae43418bac8cc5345714c34a>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <7a0988edae43418bac8cc5345714c34a>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            else if (i == 0L) {\n                zeros++;\n           \
    \ }\n            else {\n                if (ones > zeros) {\n               \
    \     max = i;\n                }\n                else {\n                  \
    \  min = i;\n                }\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            foreach (long\
    \ i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(i);\n\
    \                }\n                else {\n                    if (i > max &&\
    \ i < min) {\n                        result.Add(i);\n                    }\n\
    \                }\n            }\n        }\n        else {\n            foreach\
    \ (long i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(i);\n\
    \                }\n                else {\n                    if (i < max &&\
    \ i > min) {\n                        result.Add(i);\n                    }\n\
    \                }\n            }\n        }\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <64488cfa65c0449eb92c2885a1c27198>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <64488cfa65c0449eb92c2885a1c27198>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long maxMax = max;\n      \
    \  long onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin =\
    \ max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n \
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax\
    \ = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n\
    \        long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n    \
    \    List<long> result = new List<long>();\n        long onesMaxMinMaxMax = ones;\n\
    \        long zerosMaxMinMaxMax = zeros;\n        long maxMaxMinMaxMax = max;\n\
    \        long onesMaxMinMaxMaxMax = ones;\n        long zerosMaxMinMaxMaxMax =\
    \ zeros;\n        long maxMaxMinMaxMaxMax = max;\n        long onesMaxMinMaxMaxMaxMax\
    \ = ones;\n        long zerosMaxMinMaxMaxMaxMax = zeros;\n        long maxMaxMinMaxMaxMaxMax\
    \ = max;\n        long onesMaxMinMaxMaxMaxMaxMax = ones;\n        long zerosMaxMinMaxMaxMaxMaxMax\
    \ = zeros;\n        long maxMaxMinMaxMaxMaxMaxMax = max;\n        long onesMaxMinMaxMaxMaxMaxMaxMax\
    \ = ones;\n        long zerosMaxMinMaxMaxMaxMaxMax = zeros;\n        long maxMaxMinMaxMaxMaxMaxMaxMax\
    \ = max;\n        long onesMaxMinMaxMaxMaxMaxMaxMax = ones;\n        long zerosMaxMinMaxMaxMaxMaxMaxMax\
    \ = zeros;\n        long maxMaxMinMaxMaxMaxMaxMaxMaxMax = max;\n        long onesMaxMinMaxMaxMaxMaxMaxMaxMax\
    \ = ones;\n        long zerosMaxMinMaxMaxMaxMaxMaxMaxMax = zeros;\n        long\
    \ maxMaxMinMaxMaxMaxMaxMaxMaxMaxMax = max;\n        long onesMaxMinMaxMaxMax\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp22bwbpfu.cs(71,33): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    List<long> result = new List<long>();\n        if (ones > zeros) {\n    \
    \        result.Add(min);\n            result.AddRange(arr.Where(i => i == min).OrderBy(i\
    \ => Math.Abs(i - min)).Take(ones).ToList());\n            result.Add(max);\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => Math.Abs(i\
    \ - max)).Take(ones).ToList());\n        }\n        if (zeros > ones) {\n    \
    \        result.Add(min);\n            result.AddRange(arr.Where(i => i == min).OrderBy(i\
    \ => Math.Abs(i - min)).Take(zeros).ToList());\n            result.Add(max);\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => Math.Abs(i\
    \ - max)).Take(zeros).ToList());\n        }\n        if (ones == zeros) {\n  \
    \          result.Add(min);\n            result.AddRange(arr.Where(i => i == min).OrderBy(i\
    \ => Math.Abs(i - min)).Take(ones).ToList());\n            result.Add(max);\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => Math.Abs(i\
    \ - max)).Take(ones).ToList());\n        }\n        return result;\n    }\n  \
    \  public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp96gbcueb.cs(41,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmp96gbcueb.cs(43,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmp96gbcueb.cs(47,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmp96gbcueb.cs(49,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmp96gbcueb.cs(53,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmp96gbcueb.cs(55,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        else if (i == 0L) {\n                zeros++;\n            }\n      \
    \      else {\n                result.Add(i);\n            }\n        }\n    \
    \    if (ones > zeros) {\n            long temp = ones;\n            ones = zeros;\n\
    \            zeros = temp;\n        }\n        Array.Sort(arr, (x, y) => Compare(ones,\
    \ zeros, x, y));\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1d2vtp9b.cs(39,20): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.List<long>''
    to ''System.Array''

    /tmp/tmp1d2vtp9b.cs(39,25): error CS1660: Cannot convert lambda expression to
    type ''IComparer'' because it is not a delegate type

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        foreach\
    \ (long i in arr) {\n            ones += i;\n            zeros += (long)0;\n \
    \           if (i > maxOnes) {\n                maxOnes = i;\n            }\n\
    \            if (i < maxZeros) {\n                maxZeros = i;\n            }\n\
    \        }\n        List<long> result = new List<long>();\n        foreach (long\
    \ i in arr) {\n            long onesCount = 0;\n            long zerosCount =\
    \ 0;\n            long maxOnesCount = 0;\n            long maxZerosCount = 0;\n\
    \            long maxOnesCount2 = 0;\n            long maxZerosCount2 = 0;\n \
    \           long maxOnesCount3 = 0;\n            long maxZerosCount3 = 0;\n  \
    \          long maxOnesCount4 = 0;\n            long maxZerosCount4 = 0;\n   \
    \         long maxOnesCount5 = 0;\n            long maxZerosCount5 = 0;\n    \
    \        long maxOnesCount6 = 0;\n            long maxZerosCount6 = 0;\n     \
    \       long maxOnesCount7 = 0;\n            long maxZerosCount7 = 0;\n      \
    \      long maxOnesCount8 = 0;\n            long maxZerosCount8 = 0;\n       \
    \     long maxOnesCount9 = 0;\n            long maxZerosCount9 = 0;\n        \
    \    long maxOnesCount10 = 0;\n            long maxZerosCount10 = 0;\n       \
    \     long maxOnesCount11 = 0;\n            long maxZerosCount11 = 0;\n      \
    \      long maxOnesCount12 = 0;\n            long maxZerosCount12 = 0;\n     \
    \       long maxOnesCount13 = 0;\n            long maxZerosCount13 = 0;\n    \
    \        long maxOnesCount14 = 0;\n            long maxZerosCount14 = 0;\n   \
    \         long maxOnesCount15 = 0;\n            long maxZerosCount15 = 0;\n  \
    \          long maxOnesCount16 = 0;\n            long maxZerosCount16 = 0;\n \
    \           long maxOnesCount17 = 0;\n            long maxZerosCount17 = 0;\n\
    \            long maxOnesCount18 = 0;\n            long maxZerosCount18 = 0;\n\
    \            long maxOnesCount19 = 0;\n            long maxZerosCount19 = 0;\n\
    \            long maxOnesCount20 = 0;\n            long maxZerosCount20 = 0;\n\
    \            long maxOnesCount21 = 0;\n            long maxZerosCount21 = 0;\n\
    \            long maxOnesCount22 = 0;\n            long maxZerosCount22 = 0;\n\
    \            long max\n    }\n    public static void Main(string[] args) {\n \
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpodz75lx7.cs(82,21): error CS1002: ; expected

    /tmp/tmpodz75lx7.cs(84,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpodz75lx7.cs(95,2): error CS1513: } expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        if (ones == zeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ max = arr.Max();\n        long min = arr.Min();\n        long mid = max / 2;\n\
    \        long midOnes = arr.Sum(x => x & 1L);\n        long midZeros = arr.Sum(x\
    \ => x >> 1);\n        if (midOnes == midZeros) {\n            return arr.OrderBy(x\
    \ => x).ToList();\n        }\n        long midMax = arr.Max();\n        long midMin\
    \ = arr.Min();\n        long midMid = (midMax + midMin) / 2;\n        long midOnesMid\
    \ = (midOnes + midZeros) / 2;\n        long midZerosMid = (midZeros + midOnes)\
    \ / 2;\n        if (midOnesMid == midZerosMid) {\n            return arr.OrderBy(x\
    \ => x).ToList();\n        }\n        long midMaxOnes = arr.Sum(x => x & 1L);\n\
    \        long midMaxZeros = arr.Sum(x => x >> 1);\n        if (midMaxOnes == midMaxZeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ midMaxMax = arr.Max();\n        long midMaxMin = arr.Min();\n        long midMaxMid\
    \ = (midMaxMax + midMaxMin) / 2;\n        long midMaxOnesMid = (midMaxOnes + midMaxZeros)\
    \ / 2;\n        long midMaxZerosMid = (midMaxZeros + midMaxOnes) / 2;\n      \
    \  if (midMaxOnesMid == midMaxZerosMid) {\n            return arr.OrderBy(x =>\
    \ x).ToList();\n        }\n        long midMaxMaxOnes = arr.Sum(x => x & 1L);\n\
    \        long midMaxMaxZeros = arr.Sum(x => x >> 1);\n        if (midMaxMaxOnes\
    \ == midMaxMaxZeros) {\n            return arr.OrderBy(x => x).ToList();\n   \
    \     }\n        long midMaxMaxMax = arr.Max();\n        long midMaxMaxMin = arr.Min();\n\
    \        long midMaxMaxMid = (midMaxMaxMax + midMaxMaxMin) / 2;\n        long\
    \ midMaxMaxOnesMid = (midMaxMaxOnes + midMaxMaxZeros) / 2;\n        long midMaxMaxZerosMid\
    \ = (midMaxMaxZeros + midMaxMaxOne\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsqal_s7n.cs(63,64): error CS1026: ) expected

    /tmp/tmpsqal_s7n.cs(63,64): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long maxOnes =\
    \ ones * max;\n        long maxZeros = zeros * max;\n        long maxOnesMax =\
    \ onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long maxOnesMaxMinusOnes\
    \ = maxOnesMax - 1L;\n        long maxZerosMaxMinusOnes = maxZerosMax - 1L;\n\
    \        long maxOnesMaxMinusOnesMinusOnes = maxOnesMaxMinusOnes - 1L;\n     \
    \   long maxZerosMaxMinusOnesMinusOnes = maxZerosMaxMinusOnes - 1L;\n        long\
    \ maxOnesMaxMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnes - 1L;\n\
    \        long maxZerosMaxMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = max\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7omrcxs.cs(50,84): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long maxOnes = arr.Max(x =>\
    \ x & 1L);\n        long maxOnesIndex = arr.IndexOf(maxOnes);\n        long maxOnesCount\
    \ = (maxOnes - maxOnesIndex) + 1;\n        long maxOnesCountIndex = arr.IndexOf(maxOnesCount);\n\
    \        long maxOnesCountCount = (maxOnesCount - maxOnesCountIndex) + 1;\n  \
    \      long maxOnesCountCountIndex = arr.IndexOf(maxOnesCountCount);\n       \
    \ long maxOnesCountCountCount = (maxOnesCountCount - maxOnesCountCountIndex) +\
    \ 1;\n        long maxOnesCountCountCountIndex = arr.IndexOf(maxOnesCountCountCount);\n\
    \        long maxOnesCountCountCountCount = (maxOnesCountCountCount - maxOnesCountCountCountIndex)\
    \ + 1;\n        long maxOnesCountCountCountCountIndex = arr.IndexOf(maxOnesCountCountCountCount);\n\
    \        long maxOnesCountCountCountCountCount = (maxOnesCountCountCountCount\
    \ - maxOnesCountCountCountCountIndex) + 1;\n        long maxOnesCountCountCountCountCountIndex\
    \ = arr.IndexOf(maxOnesCountCountCountCountCount);\n        long maxOnesCountCountCountCountCountCount\
    \ = (maxOnesCountCountCountCountCount - maxOnesCountCountCountCountCountIndex)\
    \ + 1;\n        long maxOnesCountCountCountCountCountCountIndex = arr.IndexOf(maxOnesCountCountCountCountCountCountCount);\n\
    \        long maxOnesCountCountCountCountCountCountCount = (maxOnesCountCountCountCountCountCount\
    \ - maxOnesCountCountCountCountCountCountIndex) + 1;\n        long maxOnesCountCountCountCountCountCountIndex\
    \ = arr.IndexOf(maxOnesCountCountCountCountCountCountCount);\n        long maxOnesCountCountCountCountCountCountCount\
    \ = (maxOnesCountCountCountCountCountCountCount - maxOnesCountCountCountCountCountCountIndex)\
    \ + 1;\n        long maxOnesCountCountCountCountCountCountCountIndex = arr.IndexOf(maxOnesCountCountCountCountCountCountCountCount);\n\
    \        long maxOnesCountCountCountCountCountCountCountCount = (maxOnesCountCountCountCountCountCountCountCount\
    \ - maxOnesCountCountCountCountCountCountCountIndex) + 1;\n        long maxOnesCountCountCountCountCountCountCount\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpre69ky4k.cs(41,56): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        if (ones\
    \ == maxOnes && zeros == maxZeros)\n            return arr;\n        if (ones\
    \ == maxOnes)\n            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x\
    \ / 1L))));\n        if (zeros == maxZeros)\n            return arr.OrderBy(x\
    \ => Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n        if (ones == maxOnes\
    \ && zeros == maxZeros)\n            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x\
    \ / 1L))));\n        if (ones == maxOnes)\n            return arr.OrderBy(x =>\
    \ Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n        if (zeros == maxZeros)\n\
    \            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x /\
    \ 1L))));\n        if (ones == maxOnes && zeros == maxZeros)\n            return\
    \ arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n       \
    \ if (ones == maxOnes)\n            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x\
    \ / 1L))));\n        if (zeros == maxZeros)\n            return arr.OrderBy(x\
    \ => Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n        if (ones == maxOnes\
    \ && zeros == maxZeros)\n            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x\
    \ / 1L))));\n        if (ones == maxOnes)\n            return arr.OrderBy(x =>\
    \ Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n        if (zeros == maxZeros)\n\
    \            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x /\
    \ 1L))));\n        if (ones == maxOnes && zeros == maxZeros)\n            return\
    \ arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x / 0L))));\n       \
    \ if (ones == maxOnes)\n            return arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x\
    \ / 1L))));\n        if (zeros == maxZeros)\n            return arr.OrderBy(\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsatu6csf.cs(53,32): error CS1026: ) expected

    /tmp/tmpsatu6csf.cs(53,32): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            ones += i;\n            zeros -= i;\n            if\
    \ (ones > max) {\n                max = ones;\n            }\n            if (zeros\
    \ > min) {\n                min = zeros;\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        long onesCount = 0;\n        long zerosCount\
    \ = 0;\n        long maxCount = 0;\n        long minCount = 0;\n        foreach\
    \ (long i in arr) {\n            onesCount += i;\n            zerosCount -= i;\n\
    \            if (onesCount > maxCount) {\n                maxCount = onesCount;\n\
    \            }\n            if (zerosCount > minCount) {\n                minCount\
    \ = zerosCount;\n            }\n        }\n        long onesSum = 0;\n       \
    \ long zerosSum = 0;\n        long maxSum = 0;\n        long minSum = 0;\n   \
    \     foreach (long i in arr) {\n            onesSum += i;\n            zerosSum\
    \ -= i;\n            if (onesSum > maxSum) {\n                maxSum = onesSum;\n\
    \            }\n            if (zerosSum > minSum) {\n                minSum =\
    \ zerosSum;\n            }\n        }\n        long onesAvg = 0;\n        long\
    \ zerosAvg = 0;\n        long maxAvg = 0;\n        long minAvg = 0;\n        foreach\
    \ (long i in arr) {\n            onesAvg += i;\n            zerosAvg -= i;\n \
    \           if (onesAvg > maxAvg) {\n                maxAvg = onesAvg;\n     \
    \       }\n            if (zerosAvg > minAvg) {\n                minAvg = zerosAvg;\n\
    \            }\n        }\n        long onesMax = 0;\n        long zerosMax =\
    \ 0;\n        long maxMax = 0;\n        long minMax = 0;\n        foreach (long\
    \ i in arr) {\n            onesMax += i;\n            zerosMax -= i;\n       \
    \     if (onesMax < maxMax) {\n                maxMax = onesMax;\n           \
    \ }\n            if (zerosMax < minMax) {\n                minMax = zerosMax;\n\
    \            }\n        }\n        long onesMin = 0;\n        long zerosMin =\
    \ 0;\n        long maxMin = 0;\n        long minMin = 0;\n        foreach (long\
    \ i in arr) {\n            onesMin += i;\n            zerosMin -= i;\n       \
    \     if (onesMin < maxMin) {\n                maxMin = onesMin;\n           \
    \ }\n            if (zerosMin < minMin) {\n                minMin = zerosMin;\n\
    \            }\n        }\n        long onesDiff = max - min;\n        \n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpoj54uyir.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long maxOnes = 0;\n\
    \        long maxZeros = 0;\n        foreach (long i in arr) {\n            if\
    \ (i == 1L) {\n                ones++;\n                if (ones > maxOnes) maxOnes\
    \ = ones;\n            } else {\n                zeros++;\n                if\
    \ (zeros > maxZeros) maxZeros = zeros;\n            }\n        }\n        if (maxOnes\
    \ == maxZeros) return arr;\n        if (maxOnes > maxZeros) maxOnes = maxZeros;\n\
    \        long maxOnesDecimal = Convert.ToDecimal(maxOnes);\n        long maxZerosDecimal\
    \ = Convert.ToDecimal(maxZeros);\n        long maxDecimal = Convert.ToDecimal(maxOnesDecimal).CompareTo(maxZerosDecimal);\n\
    \        if (maxDecimal != 0) return arr;\n        long maxDecimalDecimal = Convert.ToDecimal(maxDecimal);\n\
    \        long maxDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        long maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = Convert.ToDecimal(maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal);\n\
    \        \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7bsr7ka.cs(36,31): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(37,32): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(40,34): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(41,41): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(42,48): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(43,55): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpc7bsr7ka.cs(44,80): error CS0841: Cannot use local variable ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    before it is declared

    /tmp/tmpc7bsr7ka.cs(45,87): error CS0841: Cannot use local variable ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    before it is declared

    /tmp/tmpc7bsr7ka.cs(46,14): error CS0128: A local variable or function named ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    is already defined in this scope

    /tmp/tmpc7bsr7ka.cs(46,87): error CS0841: Cannot use local variable ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    before it is declared

    /tmp/tmpc7bsr7ka.cs(47,94): error CS0103: The name ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    does not exist in the current context

    /tmp/tmpc7bsr7ka.cs(48,101): error CS0103: The name ''maxDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal''
    does not exist in the current context

    /tmp/tmpc7bsr7ka.cs(49,14):'
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long tenths = 0;\n        long onehundreds\
    \ = 0;\n        long onethousands = 0;\n        long onetenths = 0;\n        long\
    \ onehundredths = 0;\n        long onethousandths = 0;\n        long onetenthths\
    \ = 0;\n        long onehundredthths = 0;\n        long onethousandthths = 0;\n\
    \        long onetenththths = 0;\n        long onehundredthths = 0;\n        long\
    \ onethousandthths = 0;\n        long onetenththths = 0;\n        long onehundredthths\
    \ = 0;\n        long onethousandthths = 0;\n        long onetenththths = 0;\n\
    \        long onehundredthths = 0;\n        long onethousandthths = 0;\n     \
    \   long onetenththths = 0;\n        long onehundredthths = 0;\n        long onethousandthths\
    \ = 0;\n        long onetenththths = 0;\n        long onehundredthths = 0;\n \
    \       long onethousandths = 0;\n        long onetenththths = 0;\n        long\
    \ onehundredthths = 0;\n        long onethousandths = 0;\n        long onetenththths\
    \ = 0;\n        long onehundredthths = 0;\n        long onethousandths = 0;\n\
    \        long onetenththths = 0;\n        long onehundredthths = 0;\n        long\
    \ onethousandths = 0;\n        long onetenththths = 0;\n        long onehundredthths\
    \ = 0;\n        long onethousandths = 0;\n        long onetenththths = 0;\n  \
    \      long onehundredthths = 0;\n        long onethousandths = 0;\n        long\
    \ onetenththths = 0;\n        long onehundredthths = 0;\n        long onethousandths\
    \ = 0;\n        long onetenththths = 0;\n        long onehundredthths = 0;\n \
    \       long onethousandths = 0;\n        long onetenththths = 0;\n        long\
    \ onehundredthths = 0;\n        long onethousandths = 0;\n        long onetenththths\
    \ = 0;\n        long onehundredthths = 0;\n        long onethousandths = 0;\n\
    \        long onetenththths = 0;\n        long onehundredthths = 0;\n        long\
    \ onethousandths = 0;\n        long onetenththths = 0;\n        long onehundredthths\
    \ = 0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpg20zsopq.cs(35,14): error CS0128: A local variable or function named ''onehundredthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(36,14): error CS0128: A local variable or function named ''onethousandthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(37,14): error CS0128: A local variable or function named ''onetenththths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(38,14): error CS0128: A local variable or function named ''onehundredthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(39,14): error CS0128: A local variable or function named ''onethousandthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(40,14): error CS0128: A local variable or function named ''onetenththths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(41,14): error CS0128: A local variable or function named ''onehundredthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(42,14): error CS0128: A local variable or function named ''onethousandthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(43,14): error CS0128: A local variable or function named ''onetenththths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(44,14): error CS0128: A local variable or function named ''onehundredthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(45,14): error CS0128: A local variable or function named ''onethousandthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(46,14): error CS0128: A local variable or function named ''onetenththths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(47,14): error CS0128: A local variable or function named ''onehundredthths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(48,14): error CS0128: A local variable or function named ''onethousandths''
    is already defined in this scope

    /tmp/tmpg20zsopq.cs(49,14): error CS0128: A local variable or function named ''onetenththths''
    is already defined in this scope

    /tmp/tmp'
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            ones += i;\n            zeros -= i;\n            max\
    \ = Math.Max(max, i);\n            min = Math.Min(min, i);\n        }\n      \
    \  long onesCount = ones;\n        long zerosCount = zeros;\n        long maxCount\
    \ = max;\n        long minCount = min;\n        long maxOnesCount = maxCount -\
    \ onesCount;\n        long maxZeroesCount = maxCount - zerosCount;\n        long\
    \ minOnesCount = minCount - onesCount;\n        long minZeroesCount = minCount\
    \ - zerosCount;\n        long maxOnesMinZeroesCount = Math.Max(maxOnesCount, minZeroesCount);\n\
    \        long maxZeroesMinOnesCount = Math.Max(maxZeroesCount, minOnesCount);\n\
    \        long minOnesMaxZeroesCount = Math.Min(minOnesCount, maxZeroesCount);\n\
    \        long minZeroesMaxOnesCount = Math.Min(minZeroesCount, maxOnesCount);\n\
    \        long maxOnesMaxMinOnesCount = Math.Max(maxOnesCount, minOnesMaxZeroesCount);\n\
    \        long maxZeroesMaxMinOnesCount = Math.Max(maxZeroesCount, minOnesMaxZeroesCount);\n\
    \        long minOnesMaxMinZeroesCount = Math.Min(minOnesCount, maxZeroesMaxOnesCount);\n\
    \        long minZeroesMaxMinOnesCount = Math.Min(minZeroesCount, maxOnesMaxMinOnesCount);\n\
    \        long maxOnesMaxMinZeroesMinOnesCount = Math.Max(maxOnesCount, minZeroesMaxMinOnesCount);\n\
    \        long maxZeroesMaxMinOnesMinZeroesCount = Math.Max(maxZeroesCount, minOnesMaxMinZeroesCount);\n\
    \        long minOnesMaxMinZeroesMinZeroesCount = Math.Min(minOnesCount, maxZeroesMaxMinOnesMinZeroesCount);\n\
    \        long minZeroesMaxMinOnesMinZeroesCount = Math.Min(minZeroesCount, maxOnesMaxMinZeroesMinOnesCount);\n\
    \        long maxOnesMaxMinZeroesMinZeroesMinOnesCount = Math.Max(maxOnesCount,\
    \ minZeroesMaxMinZeroesMinOnesCount);\n        long maxZeroesMaxMinOnesMinZero\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvngauo1n.cs(51,40): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long num in arr) {\n            ones += num;\n            zeros\
    \ -= num;\n            if (ones > max) {\n                max = ones;\n      \
    \      }\n            if (zeros > max) {\n                max = zeros;\n     \
    \       }\n        }\n        long onesCount = 0;\n        long zerosCount = 0;\n\
    \        long maxCount = 0;\n        foreach (long num in arr) {\n           \
    \ onesCount += num;\n            zerosCount -= num;\n            if (onesCount\
    \ > maxCount) {\n                maxCount = onesCount;\n            }\n      \
    \      if (zerosCount > maxCount) {\n                maxCount = zerosCount;\n\
    \            }\n        }\n        long onesCount2 = 0;\n        long zerosCount2\
    \ = 0;\n        long maxCount2 = 0;\n        foreach (long num in arr) {\n   \
    \         onesCount2 += num;\n            zerosCount2 -= num;\n            if\
    \ (onesCount2 > maxCount2) {\n                maxCount2 = onesCount2;\n      \
    \      }\n            if (zerosCount2 > maxCount2) {\n                maxCount2\
    \ = zerosCount2;\n            }\n        }\n        long onesCount3 = 0;\n   \
    \     long zerosCount3 = 0;\n        long maxCount3 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount3 += num;\n            zerosCount3 -= num;\n\
    \            if (onesCount3 > maxCount3) {\n                maxCount3 = onesCount3;\n\
    \            }\n            if (zerosCount3 > maxCount3) {\n                maxCount3\
    \ = zerosCount3;\n            }\n        }\n        long onesCount4 = 0;\n   \
    \     long zerosCount4 = 0;\n        long maxCount4 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount4 += num;\n            zerosCount4 -= num;\n\
    \            if (onesCount4 > maxCount4) {\n                maxCount4 = onesCount4;\n\
    \            }\n            if (zerosCount4 > maxCount4) {\n                maxCount4\
    \ = zerosCount4;\n            }\n        }\n        long onesCount5 = 0;\n   \
    \     long zerosCount5 = 0;\n        long maxCount5 = 0;\n        foreach (long\
    \ num in arr) {\n            onesCount5 += num;\n            zerosCount5 -= num;\n\
    \            if (onesCount5 > maxCount5) {\n                maxCount5 = onesCount5;\n\
    \            }\n            if (zerosCount5 > maxCount5) {\n                maxCount5\
    \ = zerosCount5;\n            }\n        }\n        long onesCount6 = 0;\n   \
    \     long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkq7ba5jt.cs(100,13): error CS1001: Identifier expected

    /tmp/tmpkq7ba5jt.cs(100,13): error CS1002: ; expected

    '
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n\
    \        }\n        return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ThenBy(x\
    \ => Math.Abs(x));\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpt5eumpzc.cs(25,128): error CS1026: ) expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr;\n        }\n        long maxOnes = arr.Max(x => x\
    \ & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesDiff\
    \ = maxOnes - ones;\n        long maxZerosDiff = maxZeros - zeros;\n        long\
    \ maxOnesDiffDiff = maxOnesDiff - maxOnes;\n        long maxZerosDiffDiff = maxZerosDiff\
    \ - maxZeros;\n        long maxOnesDiffDiffDiff = maxOnesDiffDiff - maxOnesDiff;\n\
    \        long maxZerosDiffDiffDiff = maxZerosDiffDiff - maxZerosDiff;\n      \
    \  long maxOnesDiffDiffDiffDiff = maxOnesDiffDiffDiff - maxOnesDiffDiff;\n   \
    \     long maxZerosDiffDiffDiffDiff = maxZerosDiffDiffDiff - maxZerosDiffDiff;\n\
    \        long maxOnesDiffDiffDiffDiffDiff = maxOnesDiffDiffDiffDiff - maxOnesDiffDiffDiff;\n\
    \        long maxZerosDiffDiffDiffDiffDiff = maxZerosDiffDiffDiffDiff - maxZerosDiffDiffDiff;\n\
    \        long maxOnesDiffDiffDiffDiffDiffDiff = maxOnesDiffDiffDiffDiffDiff -\
    \ maxOnesDiffDiffDiffDiff;\n        long maxZerosDiffDiffDiffDiffDiffDiff = maxZerosDiffDiffDiffDiffDiff\
    \ - maxZerosDiffDiffDiffDiff;\n        long maxOnesDiffDiffDiffDiffDiffDiffDiff\
    \ = maxOnesDiffDiffDiffDiffDiffDiff - maxOnesDiffDiffDiffDiffDiff;\n        long\
    \ maxZerosDiffDiffDiffDiffDiffDiffDiff = maxZerosDiffDiffDiffDiffDiffDiff - maxZerosDiffDiffDiffDiffDiff;\n\
    \        long maxOnesDiffDiffDiffDiffDiffDiffDiffDiff = maxOnesDiffDiffDiffDiffDiffDiffDiffDiff\
    \ - maxOnesDiffDiffDiffDiffDiffDiffDiff;\n        long maxZerosDiffDiffDiffDiffDiffDiffDiffDiff\
    \ = maxZerosDiffDiffDiffDiffDiffDiffDiff - maxZerosDiffDiffDiffDiffDiffDiff\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphx8ie900.cs(42,128): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ ones;\n            long zerosMax = zeros;\n            while (onesMax < zerosMax)\
    \ {\n                result.Add(max);\n                onesMax++;\n          \
    \      zerosMax--;\n            }\n            while (zerosMax < onesMax) {\n\
    \                result.Add(max);\n                zerosMax++;\n             \
    \   onesMax--;\n            }\n        }\n        else {\n            long zerosMax\
    \ = zeros;\n            long onesMax = ones;\n            while (zerosMax < onesMax)\
    \ {\n                result.Add(max);\n                zerosMax++;\n         \
    \       onesMax--;\n            }\n            while (onesMax < zerosMax) {\n\
    \                result.Add(max);\n                onesMax++;\n              \
    \  zerosMax--;\n            }\n        }\n        return result;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1c7b2455c417403887b4143c078bcb75>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1c7b2455c417403887b4143c078bcb75>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin\
    \ = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin\
    \ * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmrruv2xz.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long tens = 0;\n        long hundreds = 0;\n\
    \        long thousands = 0;\n        long total = 0;\n        foreach (long num\
    \ in arr) {\n            ones += num;\n            tens += num * 10;\n       \
    \     hundreds += num * 100;\n            thousands += num * 1000;\n         \
    \   total += num;\n        }\n        long onesTotal = ones;\n        long tensTotal\
    \ = tens;\n        long hundredsTotal = hundreds;\n        long thousandsTotal\
    \ = thousands;\n        long totalTotal = total;\n        bool swap = false;\n\
    \        while (onesTotal > 0 || tensTotal > 0 || hundredsTotal > 0 || thousandsTotal\
    \ > 0) {\n            if (onesTotal > 0 && tensTotal > 0 && hundredsTotal > 0\
    \ && thousandsTotal > 0) {\n                if (onesTotal > onesTotal) {\n   \
    \                 if (tensTotal > tensTotal) {\n                        if (hundredsTotal\
    \ > hundredsTotal) {\n                            if (thousandsTotal > thousandsTotal)\
    \ {\n                                swap = true;\n                          \
    \      break;\n                            }\n                            else\
    \ {\n                                swap = true;\n                          \
    \      break;\n                            }\n                        }\n    \
    \                    else {\n                            swap = true;\n      \
    \                      break;\n                        }\n                   \
    \ }\n                    else {\n                        swap = true;\n      \
    \                  break;\n                    }\n                }\n        \
    \        else {\n                    swap = true;\n                    break;\n\
    \                }\n            }\n            else {\n                swap =\
    \ true;\n                break;\n            }\n        }\n        if (swap) {\n\
    \            long temp = onesTotal;\n            onesTotal = tensTotal;\n    \
    \        tensTotal = hundredsTotal;\n            hundredsTotal = thousandsTotal;\n\
    \            thousandsTotal = totalTotal;\n            totalTotal = temp;\n  \
    \          temp = ones;\n            ones = tens;\n            tens = hundreds;\n\
    \            hundreds = thousands;\n            thousands = total;\n         \
    \   total = temp;\n        }\n        long onesLeft = onesTotal - ones;\n    \
    \    long tensLeft = tensTotal - tens;\n        long hundredsLeft = hundredsTotal\
    \ - hundreds;\n        long thousandsLeft = thousandsTotal - thousands;\n    \
    \    long totalLeft = totalTotal - total;\n        if (onesLeft > 0)\n       \
    \     result.AddRange(arr.Take(onesLeft).Select(num => num * 10).ToList());\n\
    \        if (tensLeft > 0)\n            result.AddRange(arr.Take(tensLeft\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpftphe9o3.cs(95,46): error CS1026: ) expected

    /tmp/tmpftphe9o3.cs(95,46): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones < zeros)\
    \ {\n            int sign = arr.Sum(x => x & 1L) < 0 ? -1 : 1;\n            return\
    \ arr.OrderBy(x => sign * x).ToList();\n        }\n        if (zeros < ones) {\n\
    \            return arr.OrderBy(x => -x - 1).ToList();\n        }\n        long\
    \ max = arr.Max();\n        long min = arr.Min();\n        long diff = max - min;\n\
    \        if (diff == 0) {\n            return arr.OrderBy(x => x).ToList();\n\
    \        }\n        long onesDiff = ones - diff;\n        long zerosDiff = zeros\
    \ - diff;\n        long maxDiff = max - diff;\n        long minDiff = min - diff;\n\
    \        long maxOnesDiff = onesDiff > zerosDiff ? onesDiff : zerosDiff;\n   \
    \     long minOnesDiff = onesDiff < zerosDiff ? onesDiff : zerosDiff;\n      \
    \  long maxZerosDiff = zerosDiff > onesDiff ? zerosDiff : onesDiff;\n        long\
    \ minZerosDiff = zerosDiff < onesDiff ? zerosDiff : onesDiff;\n        long maxDiffOnes\
    \ = maxDiff > minDiff ? maxDiff : minDiff;\n        long minDiffOnes = maxDiff\
    \ < minDiff ? maxDiff : minDiff;\n        long maxDiffZeros = maxDiff > minDiffZeros\
    \ ? maxDiff : minDiffZeros;\n        long minDiffZeros = maxDiff < minDiffZeros\
    \ ? maxDiff : minDiffZeros;\n        long maxDiffOnesZeros = maxDiffOnes > minDiffOnes\
    \ ? maxDiffOnes : minDiffOnes;\n        long minDiffOnesZeros = maxDiffOnes <\
    \ minDiffOnes ? maxDiffOnes : minDiffOnes;\n        long maxDiffZerosZeros = maxDiffZeros\
    \ > minDiffZeros ? maxDiffZeros : minDiffZeros;\n        long minDiffZerosZeros\
    \ = maxDiffZeros < minDiffZeros ? maxDiffZeros : minDiffZeros;\n        long maxDiffOnesZerosZeros\
    \ = maxDiffOnesZeros > minDiffOnesZeros ? maxDiffOnesZeros : minDiffOnesZeros;\n\
    \        long minDiffOnesZeros\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxz2hrfsu.cs(52,30): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1) {\n                ones++;\n          \
    \  }\n            else if (i == 0) {\n                zeros++;\n            }\n\
    \            else {\n                max = Math.Max(max, i);\n               \
    \ min = Math.Min(min, i);\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            foreach (long\
    \ i in arr) {\n                if (i == 1) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0) {\n                    result.Add(zeros);\n\
    \                }\n                else {\n                    long temp = i;\n\
    \                    temp -= min;\n                    temp *= 2;\n          \
    \          temp += zeros;\n                    temp -= max;\n                \
    \    result.Add(temp);\n                }\n            }\n        }\n        else\
    \ {\n            foreach (long i in arr) {\n                if (i == 1) {\n  \
    \                  result.Add(zeros);\n                }\n                else\
    \ if (i == 0) {\n                    result.Add(i);\n                }\n     \
    \           else {\n                    long temp = i;\n                    temp\
    \ -= min;\n                    temp *= 2;\n                    temp += ones;\n\
    \                    temp -= max;\n                    result.Add(temp);\n   \
    \             }\n            }\n        }\n        return result;\n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d02795fc56b34d45b703c4554a573f94>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d02795fc56b34d45b703c4554a573f94>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesCount = 0;\n        long zerosCount =\
    \ 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n        \
    \    if (i == 1L) {\n                onesCount++;\n            }\n           \
    \ if (i == 0L) {\n                zerosCount++;\n            }\n            if\
    \ (i > max) {\n                maxCount = i;\n            }\n        }\n     \
    \   long onesCount2 = onesCount / maxCount;\n        long zerosCount2 = zerosCount\
    \ / maxCount;\n        long maxCount2 = maxCount / maxCount;\n        long onesCount3\
    \ = onesCount / maxCount2;\n        long zerosCount3 = zerosCount / maxCount2;\n\
    \        long maxCount3 = maxCount / maxCount2;\n        long onesCount4 = onesCount\
    \ / maxCount3;\n        long zerosCount4 = zerosCount / maxCount3;\n        long\
    \ maxCount4 = maxCount / maxCount3;\n        long onesCount5 = onesCount / maxCount4;\n\
    \        long zerosCount5 = zerosCount / maxCount4;\n        long maxCount5 =\
    \ maxCount / maxCount4;\n        long onesCount6 = onesCount / maxCount5;\n  \
    \      long zerosCount6 = zerosCount / maxCount5;\n        long maxCount6 = maxCount\
    \ / maxCount5;\n        long onesCount7 = onesCount / maxCount6;\n        long\
    \ zerosCount7 = zerosCount / maxCount6;\n        long maxCount7 = maxCount / maxCount6;\n\
    \        long onesCount8 = onesCount / maxCount7;\n        long zerosCount8 =\
    \ zerosCount / maxCount7;\n        long maxCount8 = maxCount / maxCount7;\n  \
    \      long onesCount9 = onesCount / maxCount8;\n        long zerosCount9 = zerosCount\
    \ / maxCount8;\n        long maxCount9 = maxCount / maxCount8;\n        long onesCount10\
    \ = onesCount / maxCount9;\n        long zerosCount10 = zerosCount / maxCount9;\n\
    \        long maxCount10 = maxCount / maxCount9;\n        long onesCount11 = onesCount\
    \ / maxCount10;\n        long zerosCount11 = zerosCount / maxCount10;\n      \
    \  long maxCount11 = maxCount \n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjmgf1jnt.cs(78,35): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x\
    \ => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros\
    \ = maxOnes + maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long\
    \ maxOnesZeros = maxOnes - zeros;\n        long maxOnesOnesZeros = maxOnes - ones\
    \ - zeros;\n        long maxOnesOnesOnes = maxOnes - ones - ones;\n        long\
    \ maxOnesOnesOnesZeros = maxOnes - ones - ones - zeros;\n        long maxOnesOnesOnesOnes\
    \ = maxOnes - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnes = maxOnes\
    \ - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnes\
    \ - ones - ones - ones - zeros;\n        long maxOnesOnes\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpr9qk21wz.cs(44,25): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       ones += n;\n            zeros -= n;\n            if (ones > max) {\n \
    \               max = ones;\n            }\n            if (zeros > max) {\n \
    \               max = zeros;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        foreach (long n in arr) {\n            long ones\
    \ = n;\n            long zeros = max - ones;\n            if (ones > zeros) {\n\
    \                result.Add(ones);\n            } else {\n                result.Add(zeros);\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgbd34zaj.cs(35,18): error CS0136: A local or parameter named ''ones''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmpgbd34zaj.cs(36,18): error CS0136: A local or parameter named ''zeros''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long maxOnes =\
    \ ones * max;\n        long maxZeros = zeros * max;\n        long maxOnesMax =\
    \ onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long maxOnesMaxMinusOnes\
    \ = maxOnesMax - 1L;\n        long maxZerosMaxMinusOnes = maxZerosMax - 1L;\n\
    \        long maxOnesMaxMinusOnesMinusOnes = maxOnesMaxMinusOnes - 1L;\n     \
    \   long maxZerosMaxMinusOnesMinusOnes = maxZerosMaxMinusOnes - 1L;\n        long\
    \ maxOnesMaxMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnes - 1L;\n\
    \        long maxZerosMaxMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxOnesMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes = maxZerosMaxMinusOnesMinusOnesMinusOnes\
    \ - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = maxZerosMaxMinusOnesMinusOnesMinusOnesMinusOnes - 1L;\n        long maxOnesMaxMinusOnesMinusOnesMinusOnesMinusOnesMinusOnesMinusOnes\
    \ = max\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7omrcxs.cs(50,84): error CS1002: ; expected

    '
  timestamp: 1659794975
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        long onesCount = 0;\n        long zerosCount = 0;\n        long maxCount\
    \ = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n      \
    \          onesCount++;\n            }\n            else if (i == 0L) {\n    \
    \            zerosCount++;\n            }\n            else {\n              \
    \  if (onesCount > zerosCount) {\n                    maxCount = i;\n        \
    \        }\n                else {\n                    maxCount = zerosCount;\n\
    \                }\n            }\n        }\n        if (onesCount > zerosCount)\
    \ {\n            result.Add(max);\n        }\n        else {\n            result.Add(maxCount);\n\
    \        }\n        List<long> sortedArr = new List<long>();\n        foreach\
    \ (long i in arr) {\n            if (i == 1L) {\n                sortedArr.Add(1L);\n\
    \            }\n            else if (i == 0L) {\n                sortedArr.Add(0L);\n\
    \            }\n            else {\n                if (onesCount > zerosCount)\
    \ {\n                    sortedArr.Add(i);\n                }\n              \
    \  else {\n                    sortedArr.Add(zerosCount);\n                }\n\
    \            }\n        }\n        sortedArr.Sort();\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8e2281475c1c44ad80d829d45782cc98>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8e2281475c1c44ad80d829d45782cc98>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            else if (i == 0L) {\n                zeros++;\n           \
    \ }\n            else {\n                if (ones > zeros) {\n               \
    \     max = i;\n                }\n                else {\n                  \
    \  min = i;\n                }\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            foreach (long\
    \ i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(0L);\n\
    \                }\n                else {\n                    if (i < min) {\n\
    \                        result.Add(i);\n                    }\n             \
    \       else if (i > max) {\n                        result.Add(0L);\n       \
    \             }\n                    else {\n                        if (i ==\
    \ max) {\n                            result.Add(i);\n                       \
    \ }\n                        else if (i == min) {\n                          \
    \  result.Add(0L);\n                        }\n                        else {\n\
    \                            result.Add(i);\n                        }\n     \
    \               }\n                }\n            }\n        }\n        else {\n\
    \            foreach (long i in arr) {\n                if (i == 1L) {\n     \
    \               result.Add(0L);\n                }\n                else if (i\
    \ == 0L) {\n                    result.Add(i);\n                }\n          \
    \      else {\n                    if (i < min) {\n                        result.Add(0L);\n\
    \                    }\n                    else if (i > max) {\n            \
    \            result.Add(i);\n                    }\n                    else {\n\
    \                        if (i == max) {\n                            result.Add(0L);\n\
    \                        }\n                        else if (i == min) {\n   \
    \                         result.Add(i);\n                        }\n        \
    \                else {\n                            result.Add(i);\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <74962bd3691945a1a49ea577b76d4a15>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <74962bd3691945a1a49ea577b76d4a15>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long num in arr) {\n            ones += num;\n            zeros\
    \ -= num;\n            if (ones > max) {\n                max = ones;\n      \
    \      }\n        }\n        long onesCount = 0;\n        long zerosCount = 0;\n\
    \        foreach (long num in arr) {\n            onesCount += num;\n        \
    \    zerosCount -= num;\n        }\n        long maxOnes = max;\n        long\
    \ maxZeros = max - maxOnes;\n        long maxOnesCount = maxOnes;\n        long\
    \ maxZerosCount = maxZeros - maxOnesCount;\n        long maxOnesCount2 = maxOnesCount\
    \ * maxOnesCount;\n        long maxZerosCount2 = maxZerosCount * maxZerosCount;\n\
    \        long maxOnesCount3 = maxOnesCount * maxOnesCount * maxOnesCount;\n  \
    \      long maxZerosCount3 = maxZerosCount * maxZerosCount * maxZerosCount;\n\
    \        long maxOnesCount4 = maxOnesCount * maxOnesCount * maxOnesCount * maxOnesCount;\n\
    \        long maxZerosCount4 = maxZerosCount * maxZerosCount * maxZerosCount *\
    \ maxZerosCount;\n        long maxOnesCount5 = maxOnesCount * maxOnesCount * maxOnesCount\
    \ * maxOnesCount * maxOnesCount;\n        long maxZerosCount5 = maxZerosCount\
    \ * maxZerosCount * maxZerosCount * maxZerosCount * maxZerosCount;\n        long\
    \ maxOnesCount6 = maxOnesCount * maxOnesCount * maxOnesCount * maxOnesCount *\
    \ maxOnesCount * maxOnesCount * maxOnesCount;\n        long maxZerosCount6 = maxZerosCount\
    \ * maxZerosCount * maxZerosCount * maxZerosCount * maxZerosCount * maxZerosCount\
    \ * maxZerosCount;\n        long maxOnesCount7 = maxOnesCount * maxOnesCount *\
    \ maxOnesCount * maxOnesCount * maxOnesCount * maxOnesCount * maxOnesCount * maxOnesCount\
    \ * maxOnesCount;\n\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp54q_kcg0.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> res\
    \ = new List<long>();\n        if (ones > zeros) {\n            foreach (long\
    \ i in arr) {\n                if (i == 1L) {\n                    res.Add(i);\n\
    \                }\n            }\n            Array.Sort(res);\n        }\n \
    \       else {\n            foreach (long i in arr) {\n                if (i ==\
    \ 0L) {\n                    res.Add(i);\n                }\n            }\n \
    \           Array.Sort(res);\n        }\n        if (max > 0) {\n            foreach\
    \ (long i in arr) {\n                if (i == max) {\n                    res.Add(i);\n\
    \                }\n            }\n        }\n        return res;\n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzma15bwn.cs(41,24): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.List<long>''
    to ''System.Array''

    /tmp/tmpzma15bwn.cs(49,24): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.List<long>''
    to ''System.Array''

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i\
    \ => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n       \
    \     result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(i))))));\n\
    \            result.\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_qz9l68e.cs(51,20): error CS1001: Identifier expected

    /tmp/tmp_qz9l68e.cs(51,20): error CS1002: ; expected

    /tmp/tmp_qz9l68e.cs(53,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp_qz9l68e.cs(64,2): error CS1513: } expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            ones += i;\n            zeros += (long)Math.Pow(2, (int)Math.Log10(i));\n\
    \        }\n        long onesCount = 0;\n        long zerosCount = 0;\n      \
    \  long onesSum = 0;\n        long zerosSum = 0;\n        foreach (long i in arr)\
    \ {\n            onesCount += i;\n            zerosCount += (long)Math.Pow(2,\
    \ (int)Math.Log10(i));\n            onesSum += i;\n            zerosSum += (long)Math.Pow(2,\
    \ (int)Math.Log10(i));\n        }\n        bool isAscending = true;\n        if\
    \ (onesCount > zerosCount) {\n            isAscending = false;\n        }\n  \
    \      long onesSumPow = 0;\n        long zerosSumPow = 0;\n        long onesCountPow\
    \ = 0;\n        long zerosCountPow = 0;\n        long onesSumPow2 = 0;\n     \
    \   long zerosSumPow2 = 0;\n        long onesCountPow2 = 0;\n        long zerosCountPow2\
    \ = 0;\n        long onesSumPow3 = 0;\n        long zerosSumPow3 = 0;\n      \
    \  long onesCountPow3 = 0;\n        long zerosCountPow3 = 0;\n        long onesSumPow4\
    \ = 0;\n        long zerosSumPow4 = 0;\n        long onesCountPow4 = 0;\n    \
    \    long zerosCountPow4 = 0;\n        long onesSumPow5 = 0;\n        long zerosSumPow5\
    \ = 0;\n        long onesCountPow5 = 0;\n        long zerosCountPow5 = 0;\n  \
    \      long onesSumPow6 = 0;\n        long zerosSumPow6 = 0;\n        long onesCountPow6\
    \ = 0;\n        long zerosCountPow6 = 0;\n        long onesSumPow7 = 0;\n    \
    \    long zerosSumPow7 = 0;\n        long onesCountPow7 = 0;\n        long zerosCountPow7\
    \ = 0;\n        long onesSumPow8 = 0;\n        long zerosSumPow8 = 0;\n      \
    \  long onesCountPow8 = 0;\n        long zerosCountPow8 = 0;\n        long onesSumPow9\
    \ = 0;\n        long zerosSumPow9 = 0;\n        long onesCountPow9 = 0;\n    \
    \    long zerosCountPow9 = 0;\n        long onesSumPow10 = 0;\n        long zerosSumPow10\
    \ = 0;\n        long onesCountPow10 = 0;\n        long zerosCountPow10 = 0;\n\
    \        long onesSumPow11 = 0;\n        long zerosSumPow11 = 0;\n        long\
    \ onesCountPow11 = 0;\n        long zerosCountPow11 = 0;\n        long \n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvcuzptts.cs(85,13): error CS1001: Identifier expected

    /tmp/tmpvcuzptts.cs(85,13): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            if (i == 1)\
    \ {\n                result.Add(i);\n            }\n            zeros += (long)Math.Pow(2,\
    \ (int)Math.Log10(i));\n            if (zeros > max) {\n                max =\
    \ zeros;\n            }\n        }\n        if (max > 0) {\n            long onesCount\
    \ = 0;\n            long zerosCount = 0;\n            long maxCount = 0;\n   \
    \         foreach (long i in arr) {\n                onesCount += i;\n       \
    \         if (i == 1) {\n                    result.Add(i);\n                }\n\
    \                zerosCount += (long)Math.Pow(2, (int)Math.Log10(i));\n      \
    \          if (zerosCount > maxCount) {\n                    maxCount = zerosCount;\n\
    \                }\n            }\n            long onesSum = 0;\n           \
    \ long zerosSum = 0;\n            long maxSum = 0;\n            foreach (long\
    \ i in arr) {\n                onesSum += i;\n                if (i == 1) {\n\
    \                    result.Add(i);\n                }\n                zerosSum\
    \ += (long)Math.Pow(2, (int)Math.Log10(i));\n                if (zerosSum > maxSum)\
    \ {\n                    maxSum = zerosSum;\n                }\n            }\n\
    \            long onesDiff = onesSum - onesCount;\n            long zerosDiff\
    \ = zerosSum - zerosCount;\n            long maxDiff = maxSum - maxCount;\n  \
    \          long onesDiffDiff = onesDiff - onesSum;\n            long zerosDiffDiff\
    \ = zerosDiff - zerosSum;\n            long maxDiffDiff = maxDiff - maxSum;\n\
    \            long onesDiffDiffDiffDiff = onesDiffDiff - onesSum;\n           \
    \ long zerosDiffDiffDiff = zerosDiffDiff - zerosSum;\n            long maxDiffDiffDiff\
    \ = maxDiffDiff - maxSum;\n            long onesDiffDiffDiffDiffDiff = onesDiffDiffDiff\
    \ - onesSum;\n            long zerosDiffDiffDiffDiff = zerosDiffDiffDiff - zerosSum;\n\
    \            long maxDiffDiffDiffDiff = maxDiffDiffDiff - maxSum;\n          \
    \  long onesDiffDiffDiffDiffDiffDiff = onesDiffDiffDiffDiff - onesSum;\n     \
    \       long zerosDiffDiffDiffDiff = zerosDiffDiffDiff - zerosSum;\n         \
    \   long maxDiffDiffDiffDiff = maxDiffDiffDiff - maxSum;\n            long onesDiffDiffDiffDiffDiffDiffDiff\
    \ = onesDiffDiffDiffDiff\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpfyshimj3.cs(76,73): error CS1002: ; expected

    /tmp/tmpfyshimj3.cs(78,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpfyshimj3.cs(89,2): error CS1513: } expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin\
    \ = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin\
    \ * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmrruv2xz.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        if (ones == 0) return arr;\n        long maxOnes = arr.Max(x =>\
    \ x & 1L);\n        long maxOnesIndex = arr.IndexOf(maxOnes);\n        long maxOnesValue\
    \ = arr[maxOnesIndex];\n        long maxOnesIndex = maxOnesIndex + 1;\n      \
    \  long maxOnesValue = arr[maxOnesIndex];\n        long maxOnesIndex = maxOnesIndex\
    \ + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n        long maxOnesIndex\
    \ = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n      \
    \  long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnesIndex];\n\
    \        long maxOnesIndex = maxOnesIndex + 1;\n        long maxOnesValue = arr[maxOnes\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4xp941e7.cs(60,40): error CS1003: Syntax error, '']'' expected

    /tmp/tmp4xp941e7.cs(60,40): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            else if (i == 0L) {\n                zeros++;\n           \
    \ }\n            else {\n                if (ones > zeros) {\n               \
    \     max = i;\n                }\n                else {\n                  \
    \  min = i;\n                }\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long temp;\n \
    \           long temp2;\n            temp = ones;\n            temp2 = zeros;\n\
    \            while (temp > temp2) {\n                result.Add(min);\n      \
    \          temp--;\n            }\n            while (temp2 > temp) {\n      \
    \          result.Add(max);\n                temp2--;\n            }\n       \
    \ }\n        else {\n            long temp;\n            long temp2;\n       \
    \     temp = zeros;\n            temp2 = ones;\n            while (temp > temp2)\
    \ {\n                result.Add(max);\n                temp--;\n            }\n\
    \            while (temp2 > temp) {\n                result.Add(min);\n      \
    \          temp2--;\n            }\n        }\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1529818d746b4ebc8e261fddd5ffdc68>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1529818d746b4ebc8e261fddd5ffdc68>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones > zeros)\
    \ {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n\
    \        }\n        return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <66d6e9cb559f42249cfed79da3f1f23b>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <66d6e9cb559f42249cfed79da3f1f23b>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Value was either too large or too small for an Int32.\n\
    \  at System.Convert.ToInt32 (System.Double value) [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_2 (System.Int64 x) [0x00015] in <66d6e9cb559f42249cfed79da3f1f23b>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TE"
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            zeros -= i;\n\
    \            if (ones > max) {\n                max = ones;\n            }\n \
    \           if (zeros > max) {\n                max = zeros;\n            }\n\
    \        }\n        long onesCount = 0;\n        long zerosCount = 0;\n      \
    \  long maxCount = 0;\n        foreach (long i in arr) {\n            onesCount\
    \ += i;\n            zerosCount -= i;\n            if (onesCount > maxCount) {\n\
    \                maxCount = onesCount;\n            }\n            if (zerosCount\
    \ > maxCount) {\n                maxCount = zerosCount;\n            }\n     \
    \   }\n        long onesCount2 = 0;\n        long zerosCount2 = 0;\n        long\
    \ maxCount2 = 0;\n        foreach (long i in arr) {\n            onesCount2 +=\
    \ i;\n            zerosCount2 -= i;\n            if (onesCount2 > maxCount2) {\n\
    \                maxCount2 = onesCount2;\n            }\n            if (zerosCount2\
    \ > maxCount2) {\n                maxCount2 = zerosCount2;\n            }\n  \
    \      }\n        long onesCount3 = 0;\n        long zerosCount3 = 0;\n      \
    \  long maxCount3 = 0;\n        foreach (long i in arr) {\n            onesCount3\
    \ += i;\n            zerosCount3 -= i;\n            if (onesCount3 > maxCount3)\
    \ {\n                maxCount3 = onesCount3;\n            }\n            if (zerosCount3\
    \ > maxCount3) {\n                maxCount3 = zerosCount3;\n            }\n  \
    \      }\n        long onesCount4 = 0;\n        long zerosCount4 = 0;\n      \
    \  long maxCount4 = 0;\n        foreach (long i in arr) {\n            onesCount4\
    \ += i;\n            zerosCount4 -= i;\n            if (onesCount4 > maxCount4)\
    \ {\n                maxCount4 = onesCount4;\n            }\n            if (zerosCount4\
    \ > maxCount4) {\n                maxCount4 = zerosCount4;\n            }\n  \
    \      }\n        long onesCount5 = 0;\n        long zerosCount5 = 0;\n      \
    \  long maxCount5 = 0;\n        foreach (long i in arr) {\n            onesCount5\
    \ += i;\n            zerosCount5 -= i;\n            if (onesCount5 > maxCount5)\
    \ {\n                maxCount5 = onesCount5;\n            }\n            if (zerosCount5\
    \ > maxCount5) {\n                maxCount5 = zerosCount5;\n            }\n  \
    \      }\n        long onesCount6 = 0;\n        long zerosCount6 = 0;\n      \
    \  long maxCount6 = 0;\n        foreach (long i in arr) {\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpky9lt6bv.cs(104,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpky9lt6bv.cs(115,2): error CS1513: } expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> res = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            } else {\n\
    \                zeros++;\n            }\n        }\n        long onesMax = ones;\n\
    \        long zerosMax = zeros;\n        long onesMin = ones;\n        long zerosMin\
    \ = zeros;\n        long onesCur = ones;\n        long zerosCur = zeros;\n   \
    \     long onesPrev = ones;\n        long zerosPrev = zeros;\n        long onesNext\
    \ = ones;\n        long zerosNext = zeros;\n        long onesCurPrev = ones;\n\
    \        long zerosCurPrev = zeros;\n        long onesCurNext = ones;\n      \
    \  long zerosCurNext = zeros;\n        long onesCurPrev = ones;\n        long\
    \ zerosCurPrev = zeros;\n        long onesCurNext = ones;\n        long zerosCurNext\
    \ = zeros;\n        long onesCurPrev = ones;\n        long zerosCurPrev = zeros;\n\
    \        long onesCurNext = ones;\n        long zerosCurNext = zeros;\n      \
    \  long onesCurPrev = ones;\n        long zerosCurPrev = zeros;\n        long\
    \ onesCurNext = ones;\n        long zerosCurNext = zeros;\n        long onesCurPrev\
    \ = ones;\n        long zerosCurPrev = zeros;\n        long onesCurNext = ones;\n\
    \        long zerosCurNext = zeros;\n        long onesCurPrev = ones;\n      \
    \  long zerosCurPrev = zeros;\n        long onesCurNext = ones;\n        long\
    \ zerosCurNext = zeros;\n        long onesCurPrev = ones;\n        long zerosCurPrev\
    \ = zeros;\n        long onesCurNext = ones;\n        long zerosCurNext = zeros;\n\
    \        long onesCurPrev = ones;\n        long zerosCurPrev = zeros;\n      \
    \  long onesCurNext = ones;\n        long zerosCurNext = zeros;\n        long\
    \ onesCurPrev = ones;\n        long zerosCurPrev = zeros;\n        long onesCurNext\
    \ = ones;\n        long zerosCurNext = zeros;\n        long onesCurPrev = ones;\n\
    \        long zerosCurPrev = zeros;\n        long onesCurNext = ones;\n      \
    \  long zerosCurNext = zeros;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcdvp1z35.cs(44,14): error CS0128: A local variable or function named ''onesCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(45,14): error CS0128: A local variable or function named ''zerosCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(46,14): error CS0128: A local variable or function named ''onesCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(47,14): error CS0128: A local variable or function named ''zerosCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(48,14): error CS0128: A local variable or function named ''onesCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(49,14): error CS0128: A local variable or function named ''zerosCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(50,14): error CS0128: A local variable or function named ''onesCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(51,14): error CS0128: A local variable or function named ''zerosCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(52,14): error CS0128: A local variable or function named ''onesCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(53,14): error CS0128: A local variable or function named ''zerosCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(54,14): error CS0128: A local variable or function named ''onesCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(55,14): error CS0128: A local variable or function named ''zerosCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(56,14): error CS0128: A local variable or function named ''onesCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(57,14): error CS0128: A local variable or function named ''zerosCurPrev''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(58,14): error CS0128: A local variable or function named ''onesCurNext''
    is already defined in this scope

    /tmp/tmpcdvp1z35.cs(59,14): error CS0128: A local vari'
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp30wa7n54.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        foreach (long i\
    \ in arr) {\n            if (i == 1L) {\n                ones++;\n           \
    \     if (maxOnesCount < ones) {\n                    maxOnesCount = ones;\n \
    \               }\n                if (maxOnes < ones) {\n                   \
    \ maxOnes = ones;\n                }\n            }\n            else if (i ==\
    \ 0L) {\n                zeros++;\n                if (maxZerosCount < zeros)\
    \ {\n                    maxZerosCount = zeros;\n                }\n         \
    \       if (maxZeros < zeros) {\n                    maxZeros = zeros;\n     \
    \           }\n            }\n        }\n        long maxOnesDecimal = maxOnes\
    \ / maxOnesCount;\n        long maxZerosDecimal = maxZeros / maxZerosCount;\n\
    \        List<long> result = new List<long>();\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                result.Add(i);\n            }\n\
    \            else if (i == 0L) {\n                result.Add(-i);\n          \
    \  }\n            else {\n                long onesDecimal = i / maxOnesCount;\n\
    \                long zerosDecimal = i / maxZerosCount;\n                if (onesDecimal\
    \ > maxOnesDecimal) {\n                    result.Add(maxOnesDecimal);\n     \
    \           }\n                else if (onesDecimal < maxOnesDecimal) {\n    \
    \                result.Add(onesDecimal);\n                }\n               \
    \ if (zerosDecimal > maxZerosDecimal) {\n                    result.Add(maxZerosDecimal);\n\
    \                }\n                else if (zerosDecimal < maxZerosDecimal) {\n\
    \                    result.Add(zerosDecimal);\n                }\n          \
    \  }\n        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.DivideByZeroException: Attempted to divide\
    \ by zero.\n  at Problem.SortArray (System.Collections.Generic.List`1[T] arr)\
    \ [0x000af] in <004ee71c82a14c6782998628deb262ce>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00017] in <004ee71c82a14c6782998628deb262ce>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.DivideByZeroException: Attempted to divide by zero.\n  at\
    \ Problem.SortArray (System.Collections.Generic.List`1[T] arr) [0x000af] in <004ee71c82a14c6782998628deb262ce>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00017] in <004ee71c82a14c6782998628deb262ce>:0\
    \ \n"
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long maxOnes = 0;\n\
    \        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long maxZerosCount\
    \ = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n      \
    \          ones++;\n                if (ones > maxOnes) {\n                  \
    \  maxOnes = ones;\n                    maxOnesCount = maxOnes;\n            \
    \    }\n            } else if (i == 0L) {\n                zeros++;\n        \
    \        if (zeros > maxZeros) {\n                    maxZeros = zeros;\n    \
    \                maxZerosCount = maxZeros;\n                }\n            } else\
    \ {\n                ones++;\n                zeros++;\n            }\n      \
    \  }\n        long onesCount = maxOnesCount;\n        long zerosCount = maxZerosCount;\n\
    \        long maxOnesCount2 = maxOnesCount - onesCount;\n        long maxZerosCount2\
    \ = maxZerosCount - zerosCount;\n        long maxOnesCount3 = maxOnesCount2 -\
    \ onesCount;\n        long maxZerosCount3 = maxZerosCount2 - zerosCount;\n   \
    \     long maxOnesCount4 = maxOnesCount3 - onesCount;\n        long maxZerosCount4\
    \ = maxZerosCount3 - zerosCount;\n        long maxOnesCount5 = maxOnesCount4 -\
    \ onesCount;\n        long maxZerosCount5 = maxZerosCount4 - zerosCount;\n   \
    \     long maxOnesCount6 = maxOnesCount5 - onesCount;\n        long maxZerosCount6\
    \ = maxZerosCount5 - zerosCount;\n        long maxOnesCount7 = maxOnesCount6 -\
    \ onesCount;\n        long maxZerosCount7 = maxZerosCount6 - zerosCount;\n   \
    \     long maxOnesCount8 = maxOnesCount7 - onesCount;\n        long maxZerosCount8\
    \ = maxZerosCount7 - zerosCount;\n        long maxOnesCount9 = maxOnesCount8 -\
    \ onesCount;\n        long maxZerosCount9 = maxZerosCount8 - zerosCount;\n   \
    \     long maxOnesCount10 = maxOnesCount9 - onesCount;\n        long maxZerosCount10\
    \ = maxZerosCount9 - zerosCount;\n        long maxOnesCount11 = maxOnesCount10\
    \ - onesCount;\n        long \n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpx117889l.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpx117889l.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - onesMax;\n        long zerosMin = zeros * min - zerosMax;\n   \
    \     long onesDiff = onesMax - onesMin;\n        long zerosDiff = zerosMax -\
    \ zerosMin;\n        long onesDiffMin = onesMax - onesMin;\n        long zerosDiffMin\
    \ = zerosMax - zerosMin;\n        long onesDiffMax = onesMax - onesMax;\n    \
    \    long zerosDiffMax = zerosMax - zerosMax;\n        long onesDiffMinMax = onesMax\
    \ - onesMax;\n        long zerosDiffMinMax = zerosMax - zerosMax;\n        long\
    \ onesDiffMinMaxDiff = onesMax - onesMax;\n        long zerosDiffMinMaxDiff =\
    \ zerosMax - zerosMax;\n        long onesDiffMinMaxDiffMin = onesMax - onesMin;\n\
    \        long zerosDiffMinMaxDiffMin = zerosMax - zerosMin;\n        long onesDiffMinMaxDiffMax\
    \ = onesMax - onesMax;\n        long zerosDiffMinMaxDiffMax = zerosMax - zerosMax;\n\
    \        long onesDiffMinMaxDiffMinMax = onesMax - onesMax;\n        long zerosDiffMinMaxDiffMinMax\
    \ = zerosMax - zerosMax;\n        long onesDiffMinMaxDiffMinMaxDiff = onesMax\
    \ - onesMax;\n        long zerosDiffMinMaxDiffMinMaxDiff = zerosMax - zerosMax;\n\
    \        long onesDiffMinMaxDiffMinMaxDiffMin = onesMax - onesMin;\n        long\
    \ zerosDiffMinMaxDiffMinMaxDiffMin = zerosMax - zerosMin;\n        long onesDiffMinMaxDiffMinMaxDiffMax\
    \ = onesMax - onesMax;\n        long zerosDiffMinMaxDiffMinMaxDiffMax = zerosMax\
    \ - zerosMax;\n        long onesDiffMinMaxDiffMinMaxDiffMinMax = onesMax - onesMax;\n\
    \        long zeros\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphcm3auvc.cs(61,19): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> res = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   res.Add(i);\n            }\n            else if (i == 0L) {\n            \
    \    res.Add(max);\n            }\n            else {\n                if (ones\
    \ > zeros) {\n                    res.Add(i);\n                }\n           \
    \     else {\n                    res.Add(max);\n                }\n         \
    \   }\n        }\n        return res;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f8c6315c853f4c158746cb5ee9d4865e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f8c6315c853f4c158746cb5ee9d4865e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794977
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        foreach\
    \ (long i in arr) {\n            if (i == 1L) {\n                ones++;\n   \
    \             if (ones > maxOnes) maxOnes = ones;\n            } else {\n    \
    \            zeros++;\n                if (zeros > maxZeros) maxZeros = zeros;\n\
    \            }\n        }\n        List<long> result = new List<long>();\n   \
    \     foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n\
    \            } else {\n                result.Add(zeros);\n            }\n   \
    \     }\n        foreach (long i in arr) {\n            if (i == 1L) {\n     \
    \           result.Add(maxOnes);\n            } else {\n                result.Add(maxZeros);\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f1e4924821b7456d9a4b09c9f0c27d7b>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f1e4924821b7456d9a4b09c9f0c27d7b>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       ones += n;\n            zeros -= n;\n            if (ones > max) {\n \
    \               max = ones;\n            }\n            if (zeros > max) {\n \
    \               max = zeros;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        foreach (long n in arr) {\n            if (n >\
    \ 0) {\n                result.Add(n);\n            }\n        }\n        foreach\
    \ (long n in arr) {\n            if (n < 0) {\n                result.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult.Add(n);\n            }\n        }\n        foreach (long n in\
    \ result) {\n            if (n < 0) {\n                sortedResult.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult2 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult2.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult2.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult3 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult3.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult3.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult4 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult4.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult4.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult5 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult5.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult5.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult6 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult6.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult6.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult7 = new List<long>();\n\
    \        foreach (long n in result) {\n            if (n > 0) {\n            \
    \    sortedResult7.Add(n);\n            }\n        }\n        foreach (long n\
    \ in result) {\n            if (n < 0) {\n                sortedResult7.Add(-(n));\n\
    \            }\n        }\n        List<long> sortedResult8 = new List<long\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpscqhy0mw.cs(121,49): error CS1003: Syntax error, ''>'' expected

    /tmp/tmpscqhy0mw.cs(121,49): error CS1526: A new expression requires (), [], or
    {} after type

    /tmp/tmpscqhy0mw.cs(121,49): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       if (n == 1L) {\n                ones++;\n            }\n            if\
    \ (n == 0L) {\n                zeros++;\n            }\n            if (n > max)\
    \ {\n                max = n;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        long onesMax = 0;\n        long zerosMax = 0;\n\
    \        long maxOnes = 0;\n        long maxZeros = 0;\n        long maxOnesMax\
    \ = 0;\n        long maxZerosMax = 0;\n        foreach (long n in arr) {\n   \
    \         if (n == 1L) {\n                if (onesMax < ones) {\n            \
    \        onesMax = ones;\n                }\n                if (onesMax < maxOnes)\
    \ {\n                    maxOnes = onesMax;\n                }\n             \
    \   result.Add(n);\n                ones++;\n            }\n            if (n\
    \ == 0L) {\n                if (zerosMax < zeros) {\n                    zerosMax\
    \ = zeros;\n                }\n                if (zerosMax < maxZeros) {\n  \
    \                  maxZeros = zerosMax;\n                }\n                result.Add(n);\n\
    \                zeros++;\n            }\n            if (n > max) {\n       \
    \         max = n;\n            }\n        }\n        if (maxOnes > maxOnesMax)\
    \ {\n            maxOnesMax = maxOnes;\n        }\n        if (maxZeros > maxZerosMax)\
    \ {\n            maxZerosMax = maxZeros;\n        }\n        long onesMax2 = onesMax;\n\
    \        long zerosMax2 = zerosMax;\n        long maxOnesMax2 = maxOnesMax;\n\
    \        long maxZerosMax2 = maxZerosMax;\n        long maxOnesMax3 = maxOnesMax2;\n\
    \        long maxZerosMax3 = maxZerosMax2;\n        long maxOnesMax4 = maxOnesMax3;\n\
    \        long maxZerosMax4 = maxZerosMax3;\n        long maxOnesMax5 = maxOnesMax4;\n\
    \        long maxZerosMax5 = maxZerosMax4;\n        long maxOnesMax6 = maxOnesMax5;\n\
    \        long maxZerosMax6 = maxZerosMax5;\n        long maxOnesMax7 = maxOnesMax6;\n\
    \        long maxZerosMax7 = maxZerosMax6;\n        long maxOnesMax8 = maxOnesMax7;\n\
    \        long maxZerosMax8 = maxZerosMax7;\n        long maxOnesMax9 = maxOnesMax\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4gclxy1q.cs(88,38): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n    \
    \    foreach (long i in arr) {\n            ones += i;\n            zeros -= i;\n\
    \            if (ones > max) {\n                max = ones;\n            }\n \
    \           if (zeros > max) {\n                max = zeros;\n            }\n\
    \        }\n        long onesMax = max;\n        long zerosMax = max;\n      \
    \  long maxOnes = 0;\n        long maxZeros = 0;\n        long maxOnesMax = 0;\n\
    \        long maxZerosMax = 0;\n        foreach (long i in arr) {\n          \
    \  onesMax += i;\n            zerosMax -= i;\n            if (onesMax < maxOnesMax)\
    \ {\n                maxOnesMax = onesMax;\n            }\n            if (zerosMax\
    \ < maxZerosMax) {\n                maxZerosMax = zerosMax;\n            }\n \
    \           if (onesMax < maxOnes) {\n                maxOnes = onesMax;\n   \
    \         }\n            if (zerosMax < maxZeros) {\n                maxZeros\
    \ = zerosMax;\n            }\n        }\n        long onesMaxMax = maxOnesMax;\n\
    \        long zerosMaxMax = maxZerosMax;\n        long maxOnesMaxMax = 0;\n  \
    \      long maxZerosMaxMax = 0;\n        long maxOnesMaxMin = 0;\n        long\
    \ maxZerosMaxMin = 0;\n        foreach (long i in arr) {\n            onesMaxMax\
    \ += i;\n            zerosMaxMax -= i;\n            if (onesMaxMax < maxOnesMaxMax)\
    \ {\n                maxOnesMaxMax = onesMaxMax;\n            }\n            if\
    \ (zerosMaxMax < maxZerosMaxMax) {\n                maxZerosMaxMax = zerosMaxMax;\n\
    \            }\n            if (onesMaxMax < maxOnesMaxMin) {\n              \
    \  maxOnesMaxMin = onesMaxMax;\n            }\n            if (zerosMaxMax < maxZerosMaxMin)\
    \ {\n                maxZerosMaxMin = zerosMaxMax;\n            }\n        }\n\
    \        long onesMaxMaxMax = maxOnesMaxMax;\n        long zerosMaxMaxMax = maxZerosMaxMax;\n\
    \        long maxOnesMaxMaxMax = 0;\n        long maxZerosMaxMaxMax = 0;\n   \
    \     long maxOnesMaxMaxMin = 0;\n        long maxZerosMaxMaxMin = 0;\n      \
    \  foreach (long i in arr) {\n            onesMaxMaxMax += i;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmppibm34wo.cs(87,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmppibm34wo.cs(98,2): error CS1513: } expected

    '
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long num in arr) {\n   \
    \         ones += num;\n            zeros -= num;\n            if (ones > max)\
    \ {\n                max = ones;\n            }\n            if (zeros > max)\
    \ {\n                max = zeros;\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        foreach (long num in arr) {\n          \
    \  if (num == 1) {\n                result.Add(num);\n            } else {\n \
    \               result.Add(num - max);\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8eeb053ba2c64dbcb201b5b45da2efe5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8eeb053ba2c64dbcb201b5b45da2efe5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794974
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin\
    \ = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin\
    \ * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmrruv2xz.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659794973
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                max = Math.Max(max, i);\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        if (ones > zeros) {\n            foreach\
    \ (long i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(0L);\n\
    \                }\n                else {\n                    result.Add(max);\n\
    \                }\n            }\n        }\n        else {\n            foreach\
    \ (long i in arr) {\n                if (i == 1L) {\n                    result.Add(0L);\n\
    \                }\n                else if (i == 0L) {\n                    result.Add(i);\n\
    \                }\n                else {\n                    result.Add(max);\n\
    \                }\n            }\n        }\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d90969ae855d4dce9b3ed76150ea7515>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d90969ae855d4dce9b3ed76150ea7515>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        foreach\
    \ (long i in arr) {\n            ones += i;\n            zeros += (long)0;\n \
    \           if (i > maxOnes) {\n                maxOnes = i;\n            }\n\
    \            if (i < maxZeros) {\n                maxZeros = i;\n            }\n\
    \        }\n        long onesMax = maxOnes;\n        long zerosMax = maxZeros;\n\
    \        long maxOnesMax = maxOnes;\n        long maxZerosMax = maxZeros;\n  \
    \      long maxOnesMin = maxOnes;\n        long maxZerosMin = maxZeros;\n    \
    \    long maxOnesMaxMin = maxOnes;\n        long maxZerosMaxMin = maxZeros;\n\
    \        long maxOnesMinMax = maxOnes;\n        long maxZerosMinMax = maxZeros;\n\
    \        long maxOnesMaxMinMax = maxOnes;\n        long maxZerosMaxMinMax = maxZeros;\n\
    \        long maxOnesMaxMinMaxMin = maxOnes;\n        long maxZerosMaxMinMaxMin\
    \ = maxZeros;\n        long maxOnesMaxMinMaxMinMax = maxOnes;\n        long maxZerosMaxMinMaxMinMax\
    \ = maxZeros;\n        long maxOnesMaxMinMaxMinMaxMax = maxOnes;\n        long\
    \ maxZerosMaxMinMaxMinMaxMax = maxZeros;\n        long maxOnesMaxMinMaxMinMaxMaxMax\
    \ = maxOnes;\n        long maxZerosMaxMinMaxMinMaxMax = maxZeros;\n        long\
    \ maxOnesMaxMinMaxMinMaxMaxMax = maxOnes;\n        long maxZerosMaxMinMaxMinMaxMaxMax\
    \ = maxZeros;\n        long maxOnesMaxMinMaxMinMaxMaxMaxMax = maxOnes;\n     \
    \   long maxZerosMaxMinMaxMinMaxMaxMax = maxZeros;\n        long maxOnesMaxMinMaxMinMaxMaxMaxMax\
    \ = maxOnes;\n        long maxZerosMaxMinMaxMinMaxMaxMaxMax = maxZeros;\n    \
    \    long maxOnesMaxMinMaxMinMaxMaxMaxMaxMax = maxOnes;\n        long maxZerosMaxMinMaxMinMaxMaxMaxMaxMax\
    \ = maxZer\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptnbptc1d.cs(61,58): error CS1002: ; expected

    '
  timestamp: 1659794976
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1) {\n                ones++;\n            } else if (i == 0)\
    \ {\n                zeros++;\n            } else {\n                max = Math.Max(max,\
    \ i);\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        if (ones > zeros) {\n            foreach (long i in arr) {\n        \
    \        if (i == 1) {\n                    result.Add(i);\n                }\
    \ else if (i == 0) {\n                    result.Add(max);\n                }\
    \ else {\n                    result.Add(Math.Max(max, i));\n                }\n\
    \            }\n        } else {\n            foreach (long i in arr) {\n    \
    \            if (i == 1) {\n                    result.Add(max);\n           \
    \     } else if (i == 0) {\n                    result.Add(i);\n             \
    \   } else {\n                    result.Add(Math.Max(max, i));\n            \
    \    }\n            }\n        }\n        return result;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d236716e726a4a01be66388071eaa7f4>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d236716e726a4a01be66388071eaa7f4>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659794977
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        if (i == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            int onesIndex = arr.FindIndex(i => i\
    \ == 1L);\n            int zerosIndex = arr.FindIndex(i => i == 0L);\n       \
    \     int onesIndex2 = arr.FindIndex(i => i == 1L);\n            int zerosIndex2\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex3 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex3 = arr.FindIndex(i => i == 0L);\n \
    \           int onesIndex4 = arr.FindIndex(i => i == 1L);\n            int zerosIndex4\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex5 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex5 = arr.FindIndex(i => i == 0L);\n \
    \           int onesIndex6 = arr.FindIndex(i => i == 1L);\n            int zerosIndex6\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex7 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex7 = arr.FindIndex(i => i == 0L);\n \
    \           int onesIndex8 = arr.FindIndex(i => i == 1L);\n            int zerosIndex8\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex9 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex9 = arr.FindIndex(i => i == 0L);\n \
    \           int onesIndex10 = arr.FindIndex(i => i == 1L);\n            int zerosIndex10\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex11 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex11 = arr.FindIndex(i => i == 0L);\n\
    \            int onesIndex12 = arr.FindIndex(i => i == 1L);\n            int zerosIndex12\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex13 = arr.FindIndex(i\
    \ => i == 1L);\n            int zerosIndex13 = arr.FindIndex(i => i == 0L);\n\
    \            int onesIndex14 = arr.FindIndex(i => i == 1L);\n            int zerosIndex14\
    \ = arr.FindIndex(i => i == 0L);\n            int onesIndex15 = arr.FindIndex(i\
    \ => i == 1L);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp64i5y9vv.cs(62,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp64i5y9vv.cs(73,2): error CS1513: } expected

    '
  timestamp: 1659794976
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort a list of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin\
    \ = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMaxMinMin\
    \ = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n    \
    \    long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMaxMinMinMinMin = onesMaxMinMinMin\
    \ * min;\n        long zerosMaxMinMinMinMin = zerosMaxMinMinMin * min;\n     \
    \   long onesMaxMinMinMinMinMin = onesMaxMinMinMinMin * min;\n        long zerosMaxMinMinMinMin\
    \ = zerosMaxMinMinMinMin * min;\n        long onesMaxMinMinMinMinMin = onesMaxMinMinMinMinMin\
    \ * min;\n        long zerosMaxMinMinMinMinMin = zerosMaxMinMinMinMinMin * min;\n\
    \        long onesMaxMinMinMinMinMinMin = onesMaxMinMinMinMinMinMin * min;\n \
    \       long zerosMaxMinMinMinMinMin = zerosMaxMinMinMinMinMinMin * min;\n   \
    \     long onesMaxMinMinMinMinMinMin = onesMaxMinMinMinMinMinMinMin * min;\n \
    \       long zerosMaxMinMinMinMinMinMin = zerosMaxMinMinMinMinMinMinMin * min;\n\
    \        long onesMaxMinMinMinMinMinMin = onesMaxMinMinMinMinMinMinMin * min;\n\
    \        long zerosMaxMinMinMinMinMinMin = zerosMaxMinMinMinMinMinMinMin * min;\n\
    \        long onesMaxMinMinMinMinMinMin = onesMaxMinMinMinMinMinMinMin * min;\n\
    \        long zerosMaxMinMinMinMinMinMin = zerosMaxMinMinMinMinMinMinMin * min\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyhtjiisv.cs(57,78): error CS1002: ; expected

    '
  timestamp: 1659794976
