{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "ts",
  "prompt": "//Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunction k_smallest_pairs(nums1: number[], nums2: number[], k: number): number[][] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = k_smallest_pairs;\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 1),[[1, 2]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    let visited: { [key: string]: boolean } = {};\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    visited[`0,0`] = true;\n    while (k > 0 && heap.length > 0) {\n        let [_, i, j] = heap.shift()!;\n        result.push([nums1[i], nums2[j]]);\n        k--;\n        if (i + 1 < nums1.length && !visited[`${i + 1},${j}`]) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n            visited[`${i + 1},${j}`] = true;\n        }\n        if (j + 1 < nums2.length && !visited[`${i},${j + 1}`]) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n            visited[`${i},${j + 1}`] = true;\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return res;\n    }\n    let pq = new PriorityQueue<number[]>(k);\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (pq.size() < k) {\n                pq.add([nums1[i], nums2[j]]);\n            } else if (sum < pq.peek()[0] + pq.peek()[1]) {\n                pq.poll();\n                pq.add([nums1[i], nums2[j]]);\n            }\n        }\n    }\n    while (!pq.isEmpty()) {\n        res.push(pq.poll());\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const queue = new PriorityQueue({ comparator: (a, b) => a[0] + a[1] - (b[0] + b[1]) });\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            queue.enqueue([nums1[i], nums2[j]]);\n        }\n    }\n    while (k-- > 0 && !queue.isEmpty()) {\n        result.push(queue.dequeue());\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            queue.push([nums1[i], nums2[j]]);\n        }\n    }\n    queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k; i++) {\n        result.push(queue[i]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let heapSize: number = 0;\n    let temp: number[];\n    let temp1: number;\n    let temp2: number;\n    let temp3: number;\n    let temp4: number;\n    let temp5: number;\n    let temp6: number;\n    let temp7: number;\n    let temp8: number;\n    let temp9: number;\n    let temp10: number;\n    let temp11: number;\n    let temp12: number;\n    let temp13: number;\n    let temp14: number;\n    let temp15: number;\n    let temp16: number;\n    let temp17: number;\n    let temp18: number;\n    let temp19: number;\n    let temp20: number;\n    let temp21: number;\n    let temp22: number;\n    let temp23: number;\n    let temp24: number;\n    let temp25: number;\n    let temp26: number;\n    let temp27: number;\n    let temp28: number;\n    let temp29: number;\n    let temp30: number;\n    let temp31: number;\n    let temp32: number;\n    let temp33: number;\n    let temp34: number;\n    let temp35: number;\n    let temp36: number;\n    let temp37: number;\n    let temp38: number;\n    let temp39: number;\n    let temp40: number;\n    let temp41: number;\n    let temp42: number;\n    let temp43: number;\n    let temp44: number;\n    let temp45: number;\n    let temp46: number;\n    let temp47: number;\n    let temp48: number;\n    let temp49: number;\n    let temp50: number;\n    let temp51: number;\n    let temp52: number;\n    let temp53: number;\n    let temp54: number;\n    let temp55: number;\n    let temp56: number;\n    let temp57:",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let i: number = 0;\n    let j: number = 0;\n    let count: number = 0;\n    while (count < k && i < len1 && j < len2) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let cur_min = Number.MAX_SAFE_INTEGER;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < cur_min) {\n                cur_min = nums1[i] + nums2[index[i]];\n                t = i;\n            }\n        }\n        if (t === -1) {\n            break;\n        }\n        res.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let i: number = 0;\n    let j: number = 0;\n\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n\n    while (heapSize < k && i < nums1.length) {\n        heap.push([nums1[i], nums2[j], i, j]);\n        heapSize++;\n        i++;\n    }\n\n    heapify(heap, heapSize);\n\n    while (heapSize > 0 && result.length < k) {\n        let pair: number[] = heap.shift();\n        result.push([pair[0], pair[1]]);\n        heapSize--;\n\n        if (pair[3] < nums2.length - 1) {\n            heap.push([nums1[pair[2]], nums2[pair[3] + 1], pair[2], pair[3] + 1]);\n            heapSize++;\n        }\n\n        heapify(heap, heapSize);\n    }\n\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    while (k > 0 && pq.length > 0) {\n        let [a, b, j] = pq.shift();\n        res.push([a, b]);\n        if (j + 1 < nums2.length) {\n            pq.push([a, nums2[j + 1], j + 1]);\n        }\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        k--;\n    }\n    return res;\n}\n",
    "    let arr: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        let i: number = heapSize;\n        let j: number = Math.floor((i - 1) / 2);\n        while (i > 0 && heap[i][0] + heap[i][1] < heap[j][0] + heap[j][1]) {\n            let temp: number[] = heap[i];\n            heap[i] = heap[j];\n            heap[j] = temp;\n            i = j;\n            j = Math.floor((i - 1) / 2);\n        }\n        heapSize++;\n    }\n\n    function pop(): number[] {\n        let result: number[] = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        let i: number = 0;\n        let j: number = 1;\n        while (j < heapSize) {\n            if (j + 1 < heapSize && heap[j + 1][0] + heap[j + 1][1] < heap[j][0] + heap[j][1]) {\n                j++;\n            }\n            if (heap[i][0] + heap[i][1] <= heap[j][0] + heap[j][1]) {\n                break;\n            }\n            let temp: number[] = heap[i];\n            heap[i] = heap[j];\n            heap[j] = temp;\n            i = j;\n            j = 2 * i + 1;\n        }\n        return result;\n    }\n\n    for (let i: number = 0; i < nums1.length; i++) {\n        for (let j: number = 0; j < nums2.length; j++) {\n            push([nums1[i], nums2[j]]);\n        }\n    }\n    while (k > 0 && heapSize > 0) {\n        result.push(pop());\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index1 = 0;\n    let index2 = 0;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    while (k > 0) {\n        let a = nums1[index1];\n        let b = nums2[index2];\n        let pair = [a, b];\n        result.push(pair);\n        if (index1 === len1 - 1) {\n            index2++;\n        } else if (index2 === len2 - 1) {\n            index1++;\n        } else {\n            if (a + nums2[index2 + 1] < b + nums1[index1 + 1]) {\n                index2++;\n            } else {\n                index1++;\n            }\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const queue: number[][] = [];\n    for (let i = 0; i < len1; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < Math.min(k, len1 * len2); i++) {\n        const cur = queue.shift();\n        result.push([cur[0], cur[1]]);\n        if (cur[2] === len2 - 1) {\n            continue;\n        }\n        queue.push([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n        queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && queue.length > 0) {\n        queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        const cur = queue.shift();\n        res.push([cur[0], cur[1]]);\n        if (cur[2] === nums2.length - 1) {\n            continue;\n        }\n        queue.push([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let pq: number[][] = [];\n    let n1: number = nums1.length;\n    let n2: number = nums2.length;\n    if (n1 === 0 || n2 === 0 || k === 0) {\n        return result;\n    }\n    for (let i: number = 0; i < n1; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && pq.length > 0) {\n        let [num1, num2, index]: number[] = pq.shift();\n        result.push([num1, num2]);\n        if (index === n2 - 1) {\n            continue;\n        }\n        pq.push([num1, nums2[index + 1], index + 1]);\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let pq = new PriorityQueue<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        pq.enqueue([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && pq.size() > 0) {\n        let [n1, n2, index] = pq.dequeue();\n        result.push([n1, n2]);\n        k--;\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        pq.enqueue([n1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let maxHeap = new MaxHeap();\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (maxHeap.size() < k) {\n                maxHeap.insert(sum, [nums1[i], nums2[j]]);\n            } else if (maxHeap.peek() > sum) {\n                maxHeap.pop();\n                maxHeap.insert(sum, [nums1[i], nums2[j]]);\n            }\n        }\n    }\n    while (maxHeap.size() > 0) {\n        result.push(maxHeap.pop());\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) return res;\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && pq.length > 0) {\n        let [n1, n2, idx] = pq.shift();\n        res.push([n1, n2]);\n        if (idx === nums2.length - 1) continue;\n        pq.push([n1, nums2[idx + 1], idx + 1]);\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while (i < len1 && j < len2 && count < k) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        count++;\n    }\n    while (i < len1 && count < k) {\n        result.push([nums1[i], nums2[j - 1]]);\n        i++;\n        count++;\n    }\n    while (j < len2 && count < k) {\n        result.push([nums1[i - 1], nums2[j]]);\n        j++;\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let count: number = 0;\n    while (i < nums1.length && j < nums2.length && count < k) {\n        result.push([nums1[i], nums2[j]]);\n        if (i === nums1.length - 1) {\n            j++;\n        } else if (j === nums2.length - 1) {\n            i++;\n        } else if (nums1[i + 1] < nums2[j + 1]) {\n            i++;\n        } else {\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let n1: number = nums1.length;\n    let n2: number = nums2.length;\n    if (n1 == 0 || n2 == 0 || k == 0) {\n        return result;\n    }\n    for (let i: number = 0; i < n1; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heapify(heap);\n    for (let i: number = 0; i < k && heap.length > 0; i++) {\n        let [sum, i1, i2]: number[] = heap.shift();\n        result.push([nums1[i1], nums2[i2]]);\n        if (i2 + 1 < n2) {\n            heap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n            heapify(heap);\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && pq.length > 0) {\n        let [n1, n2, index] = pq.shift();\n        result.push([n1, n2]);\n        if (index < nums2.length - 1) {\n            pq.push([n1, nums2[index + 1], index + 1]);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && pairs.length < k) {\n        let pair: number[] = [nums1[i], nums2[j]];\n        pairs.push(pair);\n        if (j < nums2.length - 1 && (i === nums1.length - 1 || nums1[i] + nums2[j + 1] < nums1[i + 1] + nums2[j])) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return pairs;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            heap.push([sum, i, j]);\n        }\n    }\n\n    heap.sort((a, b) => a[0] - b[0]);\n\n    for (let i = 0; i < k; i++) {\n        if (heap[i]) {\n            result.push([nums1[heap[i][1]], nums2[heap[i][2]]]);\n        }\n    }\n\n    return result;\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && k > 0) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        k--;\n    }\n    while (i < nums1.length && k > 0) {\n        result.push([nums1[i], nums2[j - 1]]);\n        i++;\n        k--;\n    }\n    while (j < nums2.length && k > 0) {\n        result.push([nums1[i - 1], nums2[j]]);\n        j++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k && i < nums1.length * nums2.length; i++) {\n        let cur = pq.shift();\n        res.push([cur[0], cur[1]]);\n        if (cur[2] === nums2.length - 1) {\n            continue;\n        }\n        pq.push([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const minHeap = new MinHeap(k);\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            const sum = nums1[i] + nums2[j];\n            if (minHeap.size() < k) {\n                minHeap.add(sum, [nums1[i], nums2[j]]);\n            } else if (sum < minHeap.peek()) {\n                minHeap.poll();\n                minHeap.add(sum, [nums1[i], nums2[j]]);\n            }\n        }\n    }\n    while (!minHeap.isEmpty()) {\n        result.push(minHeap.poll());\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], nums1[i], nums2[0]]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < k && i < nums1.length * nums2.length; i++) {\n        let cur = heap.shift();\n        result.push([cur[1], cur[2]]);\n        if (cur[2] < nums2[nums2.length - 1]) {\n            let index = binary_search(nums2, cur[2]);\n            heap.push([cur[1] + nums2[index + 1], cur[1], nums2[index + 1]]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while (count < k) {\n        if (i < len1 && j < len2) {\n            if (nums1[i] < nums2[j]) {\n                result.push([nums1[i], nums2[j]]);\n                i++;\n            } else {\n                result.push([nums1[i], nums2[j]]);\n                j++;\n            }\n        } else if (i < len1) {\n            result.push([nums1[i], nums2[j - 1]]);\n            i++;\n        } else if (j < len2) {\n            result.push([nums1[i - 1], nums2[j]]);\n            j++;\n        } else {\n            break;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        let temp: number[] = [];\n        temp.push(nums1[t]);\n        temp.push(nums2[index[t]]);\n        result.push(temp);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let index: number[] = [];\n    if (len1 * len2 === 0) return result;\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i: number = 0; i < k && i < len1 * len2; i++) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let j: number = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) return res;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Infinity;\n        let min_pair = [];\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_pair = [nums1[i], nums2[index[i]]];\n            }\n        }\n        res.push(min_pair);\n        index[res.length - 1]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    while (result.length < k && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        if (j < nums2.length - 1) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        heapSize++;\n        let i: number = heapSize - 1;\n        let parent: number = Math.floor((i - 1) / 2);\n        while (i > 0 && heap[i][0] + heap[i][1] < heap[parent][0] + heap[parent][1]) {\n            let temp: number[] = heap[i];\n            heap[i] = heap[parent];\n            heap[parent] = temp;\n            i = parent;\n            parent = Math.floor((i - 1) / 2);\n        }\n    }\n\n    function pop(): number[] {\n        let result: number[] = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heap.pop();\n        let i: number = 0;\n        let left: number = 2 * i + 1;\n        let right: number = 2 * i + 2;\n        while (left < heapSize) {\n            let smallest: number = i;\n            if (heap[left][0] + heap[left][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = left;\n            }\n            if (right < heapSize && heap[right][0] + heap[right][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = right;\n            }\n            if (smallest === i) {\n                break;\n            }\n            let temp: number[] = heap[i];\n            heap[i] = heap[smallest];\n            heap[smallest] = temp;\n            i = smallest;\n            left = 2 * i + 1;\n            right = 2 * i + 2;\n        }\n        return result;\n    }\n\n    for (let i: number = 0; i < nums1.length; i++) {\n        for (let j: number = 0; j < nums2.length; j++) {\n            push([nums",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let arr: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n",
    "  let result: number[][] = [];\n  let heap: number[][] = [];\n  let heapSize = 0;\n  let i = 0;\n  let j = 0;\n\n  while (i < nums1.length && j < nums2.length) {\n    if (heapSize < k) {\n      heap.push([nums1[i], nums2[j]]);\n      heapSize++;\n      j++;\n    } else {\n      if (nums1[i] + nums2[j] < heap[0][0] + heap[0][1]) {\n        heap[0] = [nums1[i], nums2[j]];\n        j++;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  while (heapSize > 0) {\n    result.push(heap.shift());\n    heapSize--;\n  }\n\n  return result;\n}\n",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let pq = new PriorityQueue<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.push([nums1[i], nums2[j]]);\n        }\n    }\n    while (k-- > 0 && !pq.isEmpty()) {\n        result.push(pq.pop());\n    }\n    return result;\n}\n",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k && i < pq.length; i++) {\n        let cur = pq.shift();\n        res.push([cur[0], cur[1]]);\n        if (cur[2] === nums2.length - 1) {\n            continue;\n        }\n        pq.push([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heapify(heap);\n    while (k > 0 && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        if (j < nums2.length - 1) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n            heapify(heap);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (heap.length < k) {\n                heap.push([nums1[i], nums2[j]]);\n                if (heap.length === k) {\n                    heap.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n                }\n            } else {\n                if (sum < heap[0][0] + heap[0][1]) {\n                    heap[0] = [nums1[i], nums2[j]];\n                    heap.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n                }\n            }\n        }\n    }\n    return heap;\n}\n",
    "    let result: number[][] = [];\n    let heap = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            if (heap.size() < k) {\n                heap.push([nums1[i], nums2[j]]);\n            } else {\n                if (nums1[i] + nums2[j] < heap.peek()[0] + heap.peek()[1]) {\n                    heap.pop();\n                    heap.push([nums1[i], nums2[j]]);\n                }\n            }\n        }\n    }\n    while (heap.size() > 0) {\n        result.push(heap.pop());\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.push([nums1[i], nums2[j]]);\n        }\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k; i++) {\n        result.push(pq[i]);\n    }\n    return result;\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index1: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index1.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index1[i] < len2 && nums1[i] + nums2[index1[i]] < min_val) {\n                min_val = nums1[i] + nums2[index1[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index1[min_index]]]);\n        index1[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    for (let i: number = 0; i < nums1.length; i++) {\n        for (let j: number = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) return result;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_pair = [-1, -1];\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) continue;\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_pair = [nums1[i], nums2[index[i]]];\n            }\n        }\n        result.push(min_pair);\n        index[min_pair[0]]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && pq.length > 0) {\n        let [x, y, i] = pq.shift();\n        result.push([x, y]);\n        if (i + 1 < nums2.length) {\n            pq.push([x, nums2[i + 1], i + 1]);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let pq: Heap<number[]> = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.push([nums1[i], nums2[j]]);\n        }\n    }\n    while (k-- > 0) {\n        result.push(pq.pop());\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index: number[] = [];\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return result.slice(0, k);\n}\n",
    "    if (nums1.length === 0 || nums2.length === 0) {\n        return [];\n    }\n    const result: number[][] = [];\n    const queue: number[][] = [];\n    const visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    queue.push([0, 0]);\n    visited[0][0] = true;\n    while (queue.length > 0 && result.length < k) {\n        const [i, j] = queue.shift()!;\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            queue.push([i + 1, j]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            queue.push([i, j + 1]);\n            visited[i][j + 1] = true;\n        }\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && pairs.length < k) {\n        pairs.push([nums1[i], nums2[j]]);\n        if (j === nums2.length - 1) {\n            i++;\n            j = 0;\n        } else {\n            j++;\n        }\n    }\n    return pairs;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return result.slice(0, k);\n}\n",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    const queue = new PriorityQueue<number[]>({\n        comparator: (a, b) => a[0] + a[1] - b[0] - b[1],\n    });\n    for (let i = 0; i < nums1.length; i++) {\n        queue.enqueue([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && !queue.isEmpty()) {\n        const [n1, n2, index] = queue.dequeue();\n        result.push([n1, n2]);\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        queue.enqueue([n1, nums2[index + 1], index + 1]);\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let maxHeap: number[][] = [];\n    let maxHeapSize: number = 0;\n\n    function push(pair: number[]) {\n        maxHeap.push(pair);\n        maxHeapSize++;\n        let i: number = maxHeapSize - 1;\n        while (i > 0) {\n            let parent: number = Math.floor((i - 1) / 2);\n            if (maxHeap[i][0] + maxHeap[i][1] <= maxHeap[parent][0] + maxHeap[parent][1]) {\n                break;\n            }\n            let temp: number[] = maxHeap[i];\n            maxHeap[i] = maxHeap[parent];\n            maxHeap[parent] = temp;\n            i = parent;\n        }\n    }\n\n    function pop(): number[] {\n        let result: number[] = maxHeap[0];\n        maxHeap[0] = maxHeap[maxHeapSize - 1];\n        maxHeapSize--;\n        maxHeap.pop();\n        let i: number = 0;\n        while (i < maxHeapSize) {\n            let left: number = i * 2 + 1;\n            let right: number = i * 2 + 2;\n            let largest: number = i;\n            if (left < maxHeapSize && maxHeap[left][0] + maxHeap[left][1] > maxHeap[largest][0] + maxHeap[largest][1]) {\n                largest = left;\n            }\n            if (right < maxHeapSize && maxHeap[right][0] + maxHeap[right][1] > maxHeap[largest][0] + maxHeap[largest][1]) {\n                largest = right;\n            }\n            if (largest === i) {\n                break;\n            }\n            let temp: number[] = maxHeap[i];\n            maxHeap[i] = maxHeap[largest];\n            maxHeap[largest] = temp;\n            i = largest;\n        }\n        return result;\n    }\n\n    if (nums1.length",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index1: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index1.push(0);\n    }\n    while (k > 0) {\n        let min = Number.MAX_VALUE;\n        let minIndex = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index1[i] < len2 && nums1[i] + nums2[index1[i]] < min) {\n                min = nums1[i] + nums2[index1[i]];\n                minIndex = i;\n            }\n        }\n        if (minIndex === -1) {\n            break;\n        }\n        result.push([nums1[minIndex], nums2[index1[minIndex]]]);\n        index1[minIndex]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let heap: number[] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (heap.length < k) {\n                heap.push(sum);\n                heapify(heap, heap.length - 1);\n            } else if (heap[0] > sum) {\n                heap[0] = sum;\n                heapify(heap, 0);\n            }\n        }\n    }\n    for (let i = 0; i < heap.length; i++) {\n        let num1 = Math.floor(heap[i] / 10);\n        let num2 = heap[i] % 10;\n        result.push([num1, num2]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index1 = 0;\n    let index2 = 0;\n    let count = 0;\n    while (index1 < len1 && index2 < len2 && count < k) {\n        let sum = nums1[index1] + nums2[index2];\n        if (index1 + 1 < len1 && nums1[index1 + 1] + nums2[index2] < sum) {\n            index1++;\n        } else if (index2 + 1 < len2 && nums1[index1] + nums2[index2 + 1] < sum) {\n            index2++;\n        } else {\n            result.push([nums1[index1], nums2[index2]]);\n            index1++;\n            index2++;\n            count++;\n        }\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    const heap = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        heap.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && heap.size() > 0) {\n        const [n1, n2, index] = heap.pop();\n        result.push([n1, n2]);\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        heap.push([n1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let i: number = 0;\n    let j: number = 0;\n    let count: number = 0;\n    while (count < k && i < len1 && j < len2) {\n        let min: number = Math.min(nums1[i], nums2[j]);\n        if (min === nums1[i]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const minHeap = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < len1; i++) {\n        minHeap.push([nums1[i], nums2[0], 0]);\n    }\n    for (let i = 0; i < k && !minHeap.isEmpty(); i++) {\n        const [n1, n2, index] = minHeap.pop();\n        result.push([n1, n2]);\n        if (index === len2 - 1) {\n            continue;\n        }\n        minHeap.push([n1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            heap.push([nums1[i], nums2[j]]);\n        }\n    }\n    heap.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k; i++) {\n        result.push(heap[i]);\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const queue = new PriorityQueue<number[]>({\n        comparator: (a, b) => a[0] + a[1] - b[0] - b[1],\n    });\n    for (let i = 0; i < len1; i++) {\n        queue.enqueue([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && !queue.isEmpty()) {\n        const [n1, n2, idx] = queue.dequeue();\n        result.push([n1, n2]);\n        if (idx === len2 - 1) {\n            continue;\n        }\n        queue.enqueue([n1, nums2[idx + 1], idx + 1]);\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const heap = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < len1; i++) {\n        heap.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && heap.size() > 0) {\n        const [n1, n2, index] = heap.pop();\n        result.push([n1, n2]);\n        if (index === len2 - 1) {\n            continue;\n        }\n        heap.push([n1, nums2[index + 1], index + 1]);\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let heapSize: number = 0;\n    let temp: number[];\n    let temp1: number;\n    let temp2: number;\n\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n\n    while (i < nums1.length && j < nums2.length && heapSize < k) {\n        heap.push([nums1[i] + nums2[j], i, j]);\n        heapSize++;\n        j++;\n    }\n\n    while (heapSize > 0) {\n        temp = heap.shift();\n        result.push([nums1[temp[1]], nums2[temp[2]]]);\n        heapSize--;\n\n        if (temp[2] + 1 < nums2.length) {\n            temp1 = temp[1];\n            temp2 = temp[2] + 1;\n            heap.push([nums1[temp1] + nums2[temp2], temp1, temp2]);\n            heapSize++;\n        }\n\n        if (temp[2] === 0) {\n            i++;\n            if (i < nums1.length) {\n                temp1 = i;\n                temp2 = 0;\n                heap.push([nums1[temp1] + nums2[temp2], temp1, temp2]);\n                heapSize++;\n            }\n        }\n\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const minHeap = new MinHeap();\n    for (let i = 0; i < len1; i++) {\n        minHeap.insert(nums1[i] + nums2[0], [nums1[i], nums2[0]]);\n    }\n    for (let i = 0; i < k && !minHeap.isEmpty(); i++) {\n        const pair = minHeap.pop();\n        result.push(pair);\n        if (pair[1] < nums2[len2 - 1]) {\n            const index = nums2.indexOf(pair[1]);\n            minHeap.insert(pair[0] + nums2[index + 1], [pair[0], nums2[index + 1]]);\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        heapSize++;\n        let i: number = heapSize - 1;\n        while (i > 0) {\n            let parent: number = Math.floor((i - 1) / 2);\n            if (heap[i][0] + heap[i][1] >= heap[parent][0] + heap[parent][1]) {\n                break;\n            }\n            let temp: number[] = heap[i];\n            heap[i] = heap[parent];\n            heap[parent] = temp;\n            i = parent;\n        }\n    }\n\n    function pop(): number[] {\n        let result: number[] = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        let i: number = 0;\n        while (i < heapSize) {\n            let left: number = i * 2 + 1;\n            let right: number = i * 2 + 2;\n            let smallest: number = i;\n            if (left < heapSize && heap[left][0] + heap[left][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = left;\n            }\n            if (right < heapSize && heap[right][0] + heap[right][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = right;\n            }\n            if (smallest === i) {\n                break;\n            }\n            let temp: number[] = heap[i];\n            heap[i] = heap[smallest];\n            heap[smallest] = temp;\n            i = smallest;\n        }\n        return result;\n    }\n\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    for (let i: number = 0; i < nums1.length; i++) {\n        push([nums1[i], nums2[0], 0]);\n    }\n   ",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) return res;\n    let heap: number[][] = [];\n    let visited: boolean[][] = [];\n    for (let i = 0; i < len1; i++) {\n        visited[i] = [];\n        for (let j = 0; j < len2; j++) {\n            visited[i][j] = false;\n        }\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    visited[0][0] = true;\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let [sum, x, y] = heap.shift();\n        res.push([nums1[x], nums2[y]]);\n        if (x + 1 < len1 && !visited[x + 1][y]) {\n            heap.push([nums1[x + 1] + nums2[y], x + 1, y]);\n            visited[x + 1][y] = true;\n        }\n        if (y + 1 < len2 && !visited[x][y + 1]) {\n            heap.push([nums1[x] + nums2[y + 1], x, y + 1]);\n            visited[x][y + 1] = true;\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return res;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_pair: number[] = [];\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_pair = [nums1[i], nums2[index[i]]];\n            }\n        }\n        result.push(min_pair);\n        index[result.length - 1]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && result.length < k) {\n        result.push([nums1[i], nums2[j]]);\n        if (j + 1 < nums2.length && (i + 1 >= nums1.length || nums1[i + 1] + nums2[j] > nums1[i] + nums2[j + 1])) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    while (i < len1 && j < len2 && res.length < k) {\n        let sum = nums1[i] + nums2[j];\n        if (res.length === 0) {\n            res.push([nums1[i], nums2[j]]);\n        } else {\n            let len = res.length;\n            let index = len - 1;\n            while (index >= 0 && res[index][0] + res[index][1] > sum) {\n                index--;\n            }\n            res.splice(index + 1, 0, [nums1[i], nums2[j]]);\n        }\n        if (j < len2 - 1) {\n            j++;\n        } else {\n            i++;\n            j = 0;\n        }\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let pq: PriorityQueue<number[]> = new PriorityQueue<number[]>();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.enqueue([nums1[i], nums2[j]], nums1[i] + nums2[j]);\n        }\n    }\n    while (k > 0 && !pq.isEmpty()) {\n        result.push(pq.dequeue());\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (heap.length < k) {\n                heap.push([nums1[i], nums2[j]]);\n                heap.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n            } else if (sum < heap[0][0] + heap[0][1]) {\n                heap.shift();\n                heap.push([nums1[i], nums2[j]]);\n                heap.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n            }\n        }\n    }\n    return heap;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) return result;\n    let index1: number[] = [];\n    let index2: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index1.push(0);\n    }\n    for (let i = 0; i < len2; i++) {\n        index2.push(0);\n    }\n    while (k > 0) {\n        let min = Number.MAX_VALUE;\n        let minIndex = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index1[i] >= len2) continue;\n            if (nums1[i] + nums2[index1[i]] < min) {\n                min = nums1[i] + nums2[index1[i]];\n                minIndex = i;\n            }\n        }\n        result.push([nums1[minIndex], nums2[index1[minIndex]]]);\n        index1[minIndex]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let i = 0;\n    let j = 0;\n    while (i < len1 && j < len2 && result.length < k) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n    }\n    return result;\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let indexs: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let inx = -1;\n        for (let i = 0; i < len1; i++) {\n            if (indexs[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[indexs[i]] < min_val) {\n                min_val = nums1[i] + nums2[indexs[i]];\n                inx = i;\n            }\n        }\n        if (inx === -1) {\n            break;\n        }\n        result.push([nums1[inx], nums2[indexs[inx]]]);\n        indexs[inx]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length, len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) return res;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) index[i] = 0;\n    while (k-- > 0) {\n        let min_val = Infinity, min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) continue;\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (heap.length < k) {\n                heap.push([nums1[i], nums2[j]]);\n                heapify_up(heap, heap.length - 1);\n            } else if (heap[0][0] + heap[0][1] > sum) {\n                heap[0] = [nums1[i], nums2[j]];\n                heapify_down(heap, 0);\n            }\n        }\n    }\n\n    for (let i = 0; i < k; i++) {\n        result.push(heap[0]);\n        heap[0] = heap[heap.length - 1];\n        heap.pop();\n        heapify_down(heap, 0);\n    }\n\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let heapify = function (i: number) {\n        let l: number = 2 * i + 1, r: number = 2 * i + 2, largest: number = i;\n        if (l < heapSize && heap[l][0] + heap[l][1] < heap[largest][0] + heap[largest][1]) {\n            largest = l;\n        }\n        if (r < heapSize && heap[r][0] + heap[r][1] < heap[largest][0] + heap[largest][1]) {\n            largest = r;\n        }\n        if (largest != i) {\n            let temp: number[] = heap[i];\n            heap[i] = heap[largest];\n            heap[largest] = temp;\n            heapify(largest);\n        }\n    };\n    let buildHeap = function () {\n        heapSize = nums1.length;\n        for (let i: number = Math.floor(heapSize / 2); i >= 0; i--) {\n            heapify(i);\n        }\n    };\n    let insert = function (val: number[]) {\n        heapSize++;\n        let i: number = heapSize - 1;\n        while (i && val[0] + val[1] < heap[Math.floor((i - 1) / 2)][0] + heap[Math.floor((i - 1) / 2)][1]) {\n            heap[i] = heap[Math.floor((i - 1) / 2)];\n            i = Math.floor((i - 1) / 2);\n        }\n        heap[i] = val;\n    };\n    let extractMin = function (): number[] {\n        let popped: number[] = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heapify(0);\n        return popped;\n    };\n    let index: number[] = [];\n    for (let i: number = 0; i < nums1.length; i++) {\n        index[i] = 0;",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 * len2 === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i: number = 0; i < k && i < len1 * len2; i++) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let j: number = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize = 0;\n    let push = (pair: number[]) => {\n        heap.push(pair);\n        let i = heapSize++;\n        while (i > 0) {\n            let parent = (i - 1) >> 1;\n            if (heap[parent][0] + heap[parent][1] <= heap[i][0] + heap[i][1]) break;\n            [heap[parent], heap[i]] = [heap[i], heap[parent]];\n            i = parent;\n        }\n    }\n    let pop = () => {\n        let pair = heap[0];\n        let i = 0;\n        while (true) {\n            let left = (i << 1) + 1;\n            let right = left + 1;\n            if (left >= heapSize) break;\n            let next = right < heapSize && heap[right][0] + heap[right][1] < heap[left][0] + heap[left][1] ? right : left;\n            if (heap[next][0] + heap[next][1] >= heap[heapSize - 1][0] + heap[heapSize - 1][1]) break;\n            [heap[next], heap[i]] = [heap[i], heap[next]];\n            i = next;\n        }\n        heap[i] = heap[--heapSize];\n        heap.pop();\n        return pair;\n    }\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && heapSize > 0) {\n        let [n1, n2, index] = pop();\n        result.push([n1, n2]);\n        if (index === nums2.length - 1) continue;\n        push([n1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && index.length > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < index.length; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        if (index[min_index] === len2) {\n            index.splice(min_index, 1);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let minHeap: MinHeap = new MinHeap();\n    for (let i: number = 0; i < nums1.length && i < k; i++) {\n        minHeap.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && minHeap.size() > 0) {\n        let [num1, num2, index]: number[] = minHeap.pop();\n        result.push([num1, num2]);\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        minHeap.push([num1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "  const result: number[][] = [];\n  const len1 = nums1.length;\n  const len2 = nums2.length;\n  if (len1 === 0 || len2 === 0) {\n    return result;\n  }\n  const minHeap: number[][] = [];\n  for (let i = 0; i < len1; i++) {\n    minHeap.push([nums1[i] + nums2[0], i, 0]);\n  }\n  heapify(minHeap);\n  for (let i = 0; i < k && minHeap.length > 0; i++) {\n    const [sum, i1, i2] = minHeap.shift();\n    result.push([nums1[i1], nums2[i2]]);\n    if (i2 + 1 < len2) {\n      minHeap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n    }\n    heapify(minHeap);\n  }\n  return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index1 = 0;\n    let index2 = 0;\n    while (k > 0) {\n        if (index1 === len1) {\n            result.push([nums1[index1 - 1], nums2[index2]]);\n            index2++;\n        } else if (index2 === len2) {\n            result.push([nums1[index1], nums2[index2 - 1]]);\n            index1++;\n        } else if (nums1[index1] < nums2[index2]) {\n            result.push([nums1[index1], nums2[index2 - 1]]);\n            index1++;\n        } else {\n            result.push([nums1[index1 - 1], nums2[index2]]);\n            index2++;\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let i: number = 0;\n    let j: number = 0;\n    let pair: number[];\n    let sum: number;\n    let left: number;\n    let right: number;\n    let temp: number[];\n\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n\n    while (i < nums1.length && j < nums2.length) {\n        pair = [nums1[i], nums2[j]];\n        sum = nums1[i] + nums2[j];\n        if (heapSize < k) {\n            heap.push(pair);\n            heapSize++;\n            if (heapSize === k) {\n                heapify(heap, heapSize);\n            }\n        } else {\n            if (sum < heap[0][0] + heap[0][1]) {\n                heap[0] = pair;\n                heapify(heap, heapSize);\n            }\n        }\n        if (j < nums2.length - 1) {\n            j++;\n        } else {\n            i++;\n            j = 0;\n        }\n    }\n\n    while (heapSize > 0) {\n        result.push(heap[0]);\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heapify(heap, heapSize);\n    }\n\n    return result;\n\n    function heapify(heap: number[][], heapSize: number): void {\n        let i: number = 0;\n        let left: number;\n        let right: number;\n        let temp: number[];\n        while (i < heapSize) {\n            left = 2 * i + 1;\n            right = 2 * i + 2;\n            if (left < heapSize && heap[left][0] + heap[left][1] < heap[i][0] + heap[i][1]) {\n                temp = heap[i];\n                heap[i] = heap",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let index: number[] = [];\n    if (len1 * len2 === 0) return result;\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i: number = 0; i < k && i < len1 * len2; i++) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let j: number = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (heap.length < k) {\n                heap.push([nums1[i], nums2[j]]);\n            } else {\n                if (sum < nums1[heap[0][0]] + nums2[heap[0][1]]) {\n                    heap[0] = [nums1[i], nums2[j]];\n                }\n            }\n            heapify(heap, 0);\n        }\n    }\n\n    return heap;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index = new Array(len1).fill(0);\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Infinity;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n\n    pairs.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));"
  ]
}