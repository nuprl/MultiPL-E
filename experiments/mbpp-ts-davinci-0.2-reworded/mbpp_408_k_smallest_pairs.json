{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "ts",
  "prompt": "//Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunction k_smallest_pairs(nums1: number[], nums2: number[], k: number): number[][] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = k_smallest_pairs;\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 1),[[1, 2]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    let visited: { [key: string]: boolean } = {};\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    visited[`0,0`] = true;\n    while (k > 0 && heap.length > 0) {\n        let [_, i, j] = heap.shift()!;\n        result.push([nums1[i], nums2[j]]);\n        k--;\n        if (i + 1 < nums1.length && !visited[`${i + 1},${j}`]) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n            visited[`${i + 1},${j}`] = true;\n        }\n        if (j + 1 < nums2.length && !visited[`${i},${j + 1}`]) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n            visited[`${i},${j + 1}`] = true;\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return res;\n    }\n    let pq = new PriorityQueue<number[]>(k);\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            let sum = nums1[i] + nums2[j];\n            if (pq.size() < k) {\n                pq.add([nums1[i], nums2[j]]);\n            } else if (sum < pq.peek()[0] + pq.peek()[1]) {\n                pq.poll();\n                pq.add([nums1[i], nums2[j]]);\n            }\n        }\n    }\n    while (!pq.isEmpty()) {\n        res.push(pq.poll());\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const queue = new PriorityQueue({ comparator: (a, b) => a[0] + a[1] - (b[0] + b[1]) });\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            queue.enqueue([nums1[i], nums2[j]]);\n        }\n    }\n    while (k-- > 0 && !queue.isEmpty()) {\n        result.push(queue.dequeue());\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            queue.push([nums1[i], nums2[j]]);\n        }\n    }\n    queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < k; i++) {\n        result.push(queue[i]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let heapSize: number = 0;\n    let temp: number[];\n    let temp1: number;\n    let temp2: number;\n    let temp3: number;\n    let temp4: number;\n    let temp5: number;\n    let temp6: number;\n    let temp7: number;\n    let temp8: number;\n    let temp9: number;\n    let temp10: number;\n    let temp11: number;\n    let temp12: number;\n    let temp13: number;\n    let temp14: number;\n    let temp15: number;\n    let temp16: number;\n    let temp17: number;\n    let temp18: number;\n    let temp19: number;\n    let temp20: number;\n    let temp21: number;\n    let temp22: number;\n    let temp23: number;\n    let temp24: number;\n    let temp25: number;\n    let temp26: number;\n    let temp27: number;\n    let temp28: number;\n    let temp29: number;\n    let temp30: number;\n    let temp31: number;\n    let temp32: number;\n    let temp33: number;\n    let temp34: number;\n    let temp35: number;\n    let temp36: number;\n    let temp37: number;\n    let temp38: number;\n    let temp39: number;\n    let temp40: number;\n    let temp41: number;\n    let temp42: number;\n    let temp43: number;\n    let temp44: number;\n    let temp45: number;\n    let temp46: number;\n    let temp47: number;\n    let temp48: number;\n    let temp49: number;\n    let temp50: number;\n    let temp51: number;\n    let temp52: number;\n    let temp53: number;\n    let temp54: number;\n    let temp55: number;\n    let temp56: number;\n    let temp57:",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let i: number = 0;\n    let j: number = 0;\n    let count: number = 0;\n    while (count < k && i < len1 && j < len2) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let cur_min = Number.MAX_SAFE_INTEGER;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < cur_min) {\n                cur_min = nums1[i] + nums2[index[i]];\n                t = i;\n            }\n        }\n        if (t === -1) {\n            break;\n        }\n        res.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let i: number = 0;\n    let j: number = 0;\n\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n\n    while (heapSize < k && i < nums1.length) {\n        heap.push([nums1[i], nums2[j], i, j]);\n        heapSize++;\n        i++;\n    }\n\n    heapify(heap, heapSize);\n\n    while (heapSize > 0 && result.length < k) {\n        let pair: number[] = heap.shift();\n        result.push([pair[0], pair[1]]);\n        heapSize--;\n\n        if (pair[3] < nums2.length - 1) {\n            heap.push([nums1[pair[2]], nums2[pair[3] + 1], pair[2], pair[3] + 1]);\n            heapSize++;\n        }\n\n        heapify(heap, heapSize);\n    }\n\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    while (k > 0 && pq.length > 0) {\n        let [a, b, j] = pq.shift();\n        res.push([a, b]);\n        if (j + 1 < nums2.length) {\n            pq.push([a, nums2[j + 1], j + 1]);\n        }\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        k--;\n    }\n    return res;\n}\n",
    "    let arr: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        let i: number = heapSize;\n        let j: number = Math.floor((i - 1) / 2);\n        while (i > 0 && heap[i][0] + heap[i][1] < heap[j][0] + heap[j][1]) {\n            let temp: number[] = heap[i];\n            heap[i] = heap[j];\n            heap[j] = temp;\n            i = j;\n            j = Math.floor((i - 1) / 2);\n        }\n        heapSize++;\n    }\n\n    function pop(): number[] {\n        let result: number[] = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        let i: number = 0;\n        let j: number = 1;\n        while (j < heapSize) {\n            if (j + 1 < heapSize && heap[j + 1][0] + heap[j + 1][1] < heap[j][0] + heap[j][1]) {\n                j++;\n            }\n            if (heap[i][0] + heap[i][1] <= heap[j][0] + heap[j][1]) {\n                break;\n            }\n            let temp: number[] = heap[i];\n            heap[i] = heap[j];\n            heap[j] = temp;\n            i = j;\n            j = 2 * i + 1;\n        }\n        return result;\n    }\n\n    for (let i: number = 0; i < nums1.length; i++) {\n        for (let j: number = 0; j < nums2.length; j++) {\n            push([nums1[i], nums2[j]]);\n        }\n    }\n    while (k > 0 && heapSize > 0) {\n        result.push(pop());\n        k--;\n    }\n    return result;\n}\n"
  ]
}