name: HumanEval_104_unique_digits
language: rb
prompt: "# Given an array of positive integers x. return a sorted array of all \n\
  # elements that hasn't any even digit.\n# Note: Returned array should be sorted\
  \ in increasing order.\n# For example:\n# >>> unique_digits.call([15, 33, 1422,\
  \ 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef\
  \ unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ > 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. `unique_digits([152,\
    \ 323, 1422, 10])` returns `[152, 1422, 323]` instead of `[152, 323]`.\n<|/ c\
    \ |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work. `unique_digits([152, 323, 1422, 10])` returns\
    \ `[152, 1422, 323]` instead of `[152, 323]`.\n<|/ c |>\n<| c |>\nI fixed the\
    \ bug, thanks for pointing it out. Now it works.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. `unique_digits([152, 323, 1422, 10])` returns `[152, 1422, 323]` instead\
    \ of `[152, 323]`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |x|\n    if\
    \ x.to_s.chars.uniq.count != 1\n      result << x\n    end\n  end\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.size <= 1\n  end\n  result\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != i.to_s.chars.count\n\
    \  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.count != 1\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size <= 1\n  end\n\
    \  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size <= 1\n  end\n  result\nend", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each do |x|\n    result << x if x % 2 ==\
    \ 0\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size <=\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.size <= 1\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |x|\n    result << x unless x.to_s.chars.uniq.count > 1\n\
    \  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |x|\n    result\
    \ << x if x % 2 == 0\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
