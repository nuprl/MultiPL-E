name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>>\
  \ count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like your\
    \ solution. I'm going to try it out and see if it works. Thanks!\n<|/ c |>\n<|\
    \ c |>\nI added a benchmark test to my answer. Your solution is about twice as\
    \ fast as mine.\n<|/ c |>\n<| c |>\nI added a benchmark test to my answer. Your\
    \ solution is about twice as fast as mine.\n<|/ c |>\n<| c |>\nI added a benchmark\
    \ test to my answer. Your solution is about twice as fast as mine.\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.size }\nend",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have a string like\
    \ \"abCdEfGhIjKlM\"\n<|/ c |>\n<| c |>\n: I agree, that's why I added the disclaimer\
    \ at the top. But I didn't want to give the OP an answer that would fail on that\
    \ input. :-)\n<|/ c |>\n<| c |>\nI agree with you, just wanted to point out that\
    \ your solution doesn't work if you have a string like \"abCdEfGhIjKlM\"\n<|/\
    \ c |>\n<| c |>\n: Yes, I agree. That's why I added the disclaimer at the top.\
    \ But I didn't want to give the OP an answer that would fail on that input. :-)\n\
    <|/ c |>\n<| c |>\nI agree with you and I upvoted your answer. Just wanted to\
    \ point out that your solution doesn't work if you have a string like \"abCdEfGhIjKlM\"\
    \n<|/ c |>\n<| a dscore=2 |>\n<code>", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution,\
    \ but I wonder why you used `downcase!` instead of `downcase`?\n<|/ c |>\n<| c\
    \ |>\n`downcase!` will modify the string in place. `downcase` returns a new string\
    \ without modifying the original string.\n<|/ c |>\n<| c |>\nI see. Thanks for\
    \ explaining!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  string.split(\"\
    \").uniq.size\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/, '').length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.size }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
