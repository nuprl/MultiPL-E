name: HumanEval_21_rescale_to_unit
language: rb
prompt: "# Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n# such that the smallest number will become 0 and the largest\
  \ will become 1\n# >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n\
  \    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0,\
  \ 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0,\
  \ 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\n\
  end\n"
completions: ["  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n\
    \ / numbers.max }\nend", "  numbers.each_with_index do |number, index|\n    numbers[index]\
    \ = number / numbers.max\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis doesn't work if the array is empty. `numbers.max` will throw an exception.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I added a check for the empty\
    \ array case. Now it works even if the array is empty.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map {\
    \ |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", " \
    \ numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.max\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers. `[-0.5, -0.4, -0.3,\
    \ -0.2, -0.1]` returns `[-0.5, -0.4, -0.3, -0.2, -0.1]` instead of `[-0.5, -0.4,\
    \ -0.3, -0.2, -0.1, 0.0]`\n<|/ c |>\n<| c |>\nI added a version that handles negative\
    \ numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nI added a version that\
    \ handles negative numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nI added\
    \ a version that handles negative numbers. I tested it and it works.\n<|/ c |>\n\
    <| c |>\nI added a version that handles negative numbers. I tested it and it works.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "  numbers.map { |n| n / numbers.min }\n\
    end", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.min!\n  numbers.max!\n\
    \  numbers.map { |n| n * 1.0 / numbers.max }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if number < numbers[index - 1]\n      numbers[index\
    \ - 1] = 0\n    elsif number > numbers[index - 1]\n      numbers[index - 1] =\
    \ 1\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<|\
    \ c |>\nThis doesn't seem to work. `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nIt works fine for\
    \ me. Did you copy the code exactly? I tested it on ruby 2.4.1p111. What version\
    \ of ruby are you using?\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.1p111. What\
    \ version of ruby are you using?\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.1p111.\
    \ What version of ruby are you using?\n<|/ c |>\n<| c |>\nI tested it on ruby\
    \ 2.4.1p111. What version of ruby are you using?\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  numbers.map { |n| n / numbers.reduce(:+) }\nend", "  numbers.map {\
    \ |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.max }\nend", " \
    \ numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if number < numbers[index - 1]\n      numbers[index\
    \ - 1] = 0\n    end\n    if number > numbers[index + 1]\n      numbers[index +\
    \ 1] = 1\n    end\n  end\n  numbers\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min!\n  numbers.max!\n\
    \  numbers.map { |n| n * 1.0 / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n\
    <code>", "  numbers.each_with_index do |number, index|\n    if number > 1.0\n\
    \      numbers[index] = number / 1.0\n    end\n  end\nend", "  numbers.min!\n\
    \  numbers.max!\n  numbers.map { |n| n / numbers.max }\nend", "  numbers.map {\
    \ |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", " \
    \ numbers.each_with_index do |number, index|\n    numbers[index] = number / numbers.max\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if you have\
    \ a negative number in the array. `numbers.min` will give you `0` instead of `-1`.\n\
    <|/ c |>\n<| c |>\nI thought the OP was asking about positive numbers. But you're\
    \ right, I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a version that handles negative numbers as well.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a version that handles negative numbers as well.\n<|/ c\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.min!\n  numbers.max!\n  numbers.map\
    \ { |n| n * 1.0 / numbers.max }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map!\
    \ {|n| n / numbers.max }\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers[index] = number / numbers.max\n  end\nend", "  numbers.map { |n|\
    \ n / numbers.max }\nend", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.each_with_index do |number, index|\n    if number < numbers[index - 1]\n\
    \      numbers[index - 1] = 0\n    end\n    if number > numbers[index + 1]\n \
    \     numbers[index + 1] = 1\n    end\n  end\nend", "  numbers.map { |n| n / numbers.reduce(:+)\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.reduce(:+) }\nend", "  numbers.min!\n  numbers.max!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n\
    \  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.min!\n  numbers.",
  "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\nend", " \
    \ numbers.each_with_index do |number, index|\n    if number < numbers[index -\
    \ 1]\n      numbers[index - 1] = 0\n    end\n    if number > numbers[index + 1]\n\
    \      numbers[index + 1] = 1\n    end\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if you have negative numbers. Try `[-0.5, -0.4, -0.3,\
    \ -0.2, -0.1]`\n<|/ c |>\n<| c |>\nI see what you mean. I've updated my answer\
    \ to account for negative numbers.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have negative numbers. Try `[-0.5, -0.4, -0.3, -0.2, -0.1]`\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. I've updated my answer to account for negative numbers.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. Try `[-0.5,\
    \ -0.4, -0.3, -0.2, -0.1]`\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map\
    \ { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.max }\nend",
  "  numbers.each_with_index do |number, index|\n    if number < numbers[index - 1]\n\
    \      numbers[index - 1] = 0\n    end\n    if number > numbers[index + 1]\n \
    \     numbers[index + 1] = 1\n    end\n  end\n  numbers\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.max }\nend",
  "  numbers.each_with_index do |number, index|\n    if number < 0\n      numbers[index]\
    \ = 0.0\n    elsif number > 1\n      numbers[index] = 1.0\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if you have negative numbers.\
    \ `[0.0, -0.5, 1.0]` returns `[0.0, -0.5, 1.0]` instead of `[0.0, 0.5, 1.0]`\n\
    <|/ c |>\n<| c |>\nI added a version that handles negative numbers. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  numbers.min!=0\n\
    \  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min!\n\
    \  numbers.max!\n  numbers.map { |n| n / numbers.max }\nend", "  numbers.min!\n\
    \  numbers.max!\n  numbers.map { |n| n / numbers.max }\nend", "  numbers.map {\
    \ |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", " \
    \ numbers.map { |n| n / numbers.reduce(:+) }\nend", "  numbers.map { |n| n / numbers.reduce(:+)\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min\nend",
  "  numbers.map { |n| n / numbers.min }\nend", "  numbers.each_with_index do |number,\
    \ index|\n    if number < numbers[index - 1]\n      numbers[index - 1] = 0\n \
    \   end\n    if number > numbers[index + 1]\n      numbers[index + 1] = 1\n  \
    \  end\n  end\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I like this solution, but I wonder if it can be modified to work with an array\
    \ of floats instead of integers. I tried to modify the code but couldn't get it\
    \ to work. Would you mind taking a look?\n<|/ c |>\n<| c |>\n: I added a version\
    \ that works with floats.\n<|/ c |>\n<| c |>\nThanks so much! I really appreciate\
    \ it!\n<|/ c |>\n<| c |>\n: You're welcome! I added a version that works with\
    \ floats.\n<|/ c |>\n<| a |>\nI wrote a function that does this for me:\n<code>",
  "  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but I feel like it\
    \ could be made more efficient by avoiding unnecessary comparisons.\n<|/ c |>\n\
    <| c |>\nYes, I agree with you. I think it could be made more efficient by avoiding\
    \ unnecessary comparisons. But I didn't want to change OP's code too much. :)\n\
    <|/ c |>\n<| c |>\nI like your solution, but I feel like it could be made more\
    \ efficient by avoiding unnecessary comparisons.\n<|/ c |>\n<| c |>\nI added a\
    \ more efficient version. :)\n<|/ c |>\n<| a |>\n<code>", "  numbers.map { |n|\
    \ n / numbers.max }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map { |n|\
    \ n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.max }\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers[index] = number / numbers.max\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. I'm going to try it out and see if it works.\
    \ I appreciate your help.\n<|/ c |>\n<| c |>\nI added a comment to the question\
    \ asking if there is a way to do this without using an external gem.\n<|/ c |>\n\
    <| c |>\nI added a comment to the question asking if there is a way to do this\
    \ without using an external gem.\n<|/ c |>\n<| c |>\nI added a comment to the\
    \ question asking if there is a way to do this without using an external gem.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question asking if there is a way\
    \ to do this without using an external gem.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  numbers.min!\n  numbers.max!\n  numbers.map! {|x| x/numbers.max}\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThanks so much for\
    \ this. I used it in a Rails 4 app and it worked perfectly. Just a note for anyone\
    \ else who comes across this post: I used `numbers.min!` and `numbers.max!` instead\
    \ of `numbers.min` and `numbers.max` because I needed the original array unchanged.\
    \ Otherwise this was perfect.\n<|/ c |>\n<| c |>\nThanks for this. I used this\
    \ in a Rails 5 app and it worked perfectly. Just a note for anyone else who comes\
    \ across this post: I used `numbers.min!` and `numbers.max!` instead of `numbers.min`\
    \ and `numbers.max` because I needed the original array unchanged. Otherwise this\
    \ was perfect.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.map { |n| n /\
    \ numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min\n\
    end", "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't seem to work if the array is all zeroes. `[0.0, 1.0].map\
    \ { |n| n / numbers.min }` returns `[0.0, 1.0]` instead of `[0.0, 1.0]`\n<|/ c\
    \ |>\n<| c |>\nThat's because `[0.0, 1.0].min == 0.0` so `[0.0, 1.0].map { |n|\
    \ n / numbers.min }` returns `[0.0, 1.0]`\n<|/ c |>\n<| c |>\nAh yes, I see that\
    \ now. Thanks!\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.min\n\
    end", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.max }\nend", "  numbers.min\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.min!=0\n  numbers.max!=1\n  numbers.map\
    \ { |n| n*1.0/numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like your solution, but I prefer to use `min` and `max` instead\
    \ of `min` and `max` because it's more intuitive and more readable. `min` and\
    \ `max` also have different behavior when given an empty array. `min` returns\
    \ `nil` while `max` returns `0`.\n<|/ c |>\n<| c |>\nI agree with you. `min` and\
    \ `max` have different behavior when given an empty array. `min` returns `nil`\
    \ while `max` returns `0`. But I prefer `min` and `max` because it's more intuitive\
    \ and more readable. `min` and `max` also have different behavior when given an\
    \ empty array. `min` returns `nil` while `max` returns `0`.\n<|/ c |>\n<| c |>\n\
    I agree with you. `min` and `max` have different behavior when given an empty\
    \ array. `min` returns `nil` while `max` returns `0`. But I prefer `min` and `max`\
    \ because it's more intuitive and more readable. `min` and `max` also have different\
    \ behavior when given an empty array. `min` returns `nil` while `max` returns\
    \ `0`.\n<|/ c |>\n<| c |>\nI agree with you. `min` and `max` have different behavior\
    \ when given an empty array. `min` returns `nil` while `max` returns `0`. But\
    \ I prefer `min` and `max` because it's more intuitive and more readable. `min`\
    \ and `max` also have different behavior when given an empty array. `min` returns\
    \ `nil` while `max` returns `0`.\n<|/ c |>\n<| c |>\nI agree with you. `min` and\
    \ `max` have different behavior when given an empty array. `min` returns `nil`\
    \ while `max` returns `0`. But I prefer `min` and `max` because it's more intuitive\
    \ and more readable. `min` and `max` also have different behavior when given an\
    \ empty array. `min` returns `nil` while `max` returns `0`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.min!\n\
    \  numbers.max!\n  numbers.map { |n| n * 1.0 / numbers.max }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\nend", " \
    \ numbers.min!\n  numbers.max!\n  numbers.map { |n| n * 1.0 / numbers.max }\n\
    end", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min!\n  numbers.max!\n\
    \  numbers.map { |n| n * 1.0 / numbers.max }\nend", "  numbers.min!\n  numbers.max!\n\
    \  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if number < 0\n      numbers[index] = -number\n    end\n\
    \  end\n  numbers.min\nend", "  numbers.map { |n| n / numbers.min }\nend", " \
    \ numbers.map { |n| n / numbers.min }\nend", "  numbers.min!\n  numbers.max!\n\
    \  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map { |n| n / numbers.max\
    \ }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, because it\
    \ doesn't require any additional gems. However, it does require that your array\
    \ be sorted in ascending order. Otherwise, you'll get an error.\n<|/ c |>\n<|\
    \ c |>\nYes, I assumed that would be the case for OP's use case. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI like this solution as well, because it doesn't\
    \ require any additional gems. However, it does require that your array be sorted\
    \ in ascending order. Otherwise, you'll get an error.\n<|/ c |>\n<| c |>\nI like\
    \ this solution as well, because it doesn't require any additional gems. However,\
    \ it does require that your array be sorted in ascending order. Otherwise, you'll\
    \ get an error.\n<|/ c |>\n<| c |>\nI like this solution as well, because it doesn't\
    \ require any additional gems. However, it does require that your array be sorted\
    \ in ascending order. Otherwise, you'll get an error.\n<|/ c |>\n<| a dscore=5\
    \ |>\nI like using Enumerable#chunk:\n<code>", "  numbers.min\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = number / numbers.max\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\n<code>", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.each_with_index do |number, index|\n    if number < numbers[index - 1]\n\
    \      numbers[index - 1] = 0\n    elsif number > numbers[index - 1]\n      numbers[index\
    \ - 1] = 1\n    end\n  end\nend", "  numbers.min!\n  numbers.max!\n  numbers.map\
    \ { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.max\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.min!=0\n\
    \  numbers.max!=1\n  numbers.map!{|n| n*(numbers.max - numbers.min)/numbers.max}\n\
    end", "  numbers.min!\n  numbers.max!\n  numbers.map { |n| n / numbers.max }\n\
    end", "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't seem to work. `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/\
    \ c |>\n<| c |>\nI tested it and it works fine. `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nOh sorry, I missed the `.min`\
    \ part. Thanks!\n<|/ c |>\n<| c |>\nI added a more general solution that should\
    \ work for any number of elements.\n<|/ c |>\n<| a |>\n<code>", "  numbers.min!=0\n\
    \  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\nend", "  numbers.min!\n\
    \  numbers.max!\n  numbers.map { |n| n / numbers.max }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = number / numbers.max if number > numbers.max\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't\
    \ work if you have a negative number in the array. For example, `[-1.0, 2.0, 3.0,\
    \ 4.0, 5.0]` returns `[-1.0, 0.5, 0.5, 0.5, 0.5]`\n<|/ c |>\n<| c |>\nI believe\
    \ this should work: `numbers.each_with_index.map { |n, i| n / numbers.max if n\
    \ > numbers.max }`.\n<|/ c |>\n<| a |>\n<code>", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.min\nend", "  numbers.map { |n| n / numbers.reduce(:+) }\n\
    end", "  numbers.each_with_index do |number, index|\n    if number < numbers[index\
    \ - 1]\n      numbers[index - 1] = 0\n    end\n    if number > numbers[index +\
    \ 1]\n      numbers[index + 1] = 1\n    end\n  end\n  numbers\nend", "  numbers.min\n\
    end", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.max }\nend",
  "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThis doesn't seem to work when there are negative numbers in the array.\
    \ For example, `[1,2,-3,4]` returns `[-0.5, -0.5, -0.5, -0.5]`.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work because `min` returns the minimum element in the array.\
    \ `[1,2,-3,4].min #=> 1`\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing\
    \ that out. I edited my answer to include a solution that works with negative\
    \ numbers.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  numbers.map { |n| n / numbers.max\
    \ }\nend", "  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if number < numbers[index - 1]\n      numbers[index\
    \ - 1] = 0\n    elsif number > numbers[index - 1]\n      numbers[index - 1] =\
    \ 1\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n\
    \ / numbers.max }\nend", "  numbers.each_with_index do |number, index|\n    if\
    \ number > 1.0\n      numbers[index] = number - 1.0\n    end\n  end\nend", " \
    \ numbers.min!\n  numbers.max!\n  numbers.map { |n| n / numbers.max }\nend", " \
    \ numbers.map { |n| n / numbers.min }\nend", "  numbers.min\nend", "  numbers.map\
    \ { |n| n / numbers.max }\nend", "  numbers.each_with_index do |number, index|\n\
    \    if number > numbers[index - 1]\n      numbers[index - 1] = 0\n      numbers[index]\
    \ = number\n    end\n  end\n  numbers\nend", "  numbers.map { |n| n / numbers.reduce(:+)\
    \ }\nend", "  numbers.each_with_index do |number, index|\n    numbers[index] =\
    \ number / numbers.max\n  end\nend", "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|x|\
    \ x/numbers.max}\nend", "  numbers.min!\n  numbers.max!\n  numbers.map { |n| n\
    \ / numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map\
    \ { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min }\nend",
  "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.each_with_index do |number, index|\n   \
    \ numbers[index] = number / numbers.max\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nI like the idea of using each_with_index, but this doesn't seem\
    \ to work. `[1,2,3,4,5].each_with_index.map { |n, i| n / numbers.max }` returns\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nI guess I misunderstood the\
    \ question. I'll edit my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. Your\
    \ code does work, but I ended up using [this answer](http://stackoverflow.com/a/12145480/156458).\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid\
    \ the intermediate array. Something like `numbers.each_with_index.map { |n, i|\
    \ n / numbers.max }.min` would work, but I guess it would be less efficient.\n\
    <|/ c |>\n<| c |>\nI guess it would be less efficient because of the intermediate\
    \ array, but I guess it would be more efficient because of the `min` method. I'll\
    \ edit my answer.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  numbers.each_with_index\
    \ do |number, index|\n    if number > 1.0\n      numbers[index] = numbers[index]\
    \ / number\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to call `rescale_to_unit`\
    \ on every element. Maybe using some sort of `each_with_index` loop?\n<|/ c |>\n\
    <| c |>\nI added a version that doesn't require you to call `rescale_to_unit`\
    \ on every element. Hope that helps.\n<|/ c |>\n<| c |>\nThanks, that's really\
    \ helpful. I was thinking about using `each_with_index` but wasn't sure how to\
    \ implement it. I'll give it a shot.\n<|/ c |>\n<| c |>\nI added a version that\
    \ doesn't require you to call `rescale_to_unit` on every element. Hope that helps.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a solution using Enumerable#each_cons:\n<code>",
  "  numbers.map { |n| n / numbers.max }\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't seem to work if you\
    \ pass in an array of numbers that aren't all positive.\n<|/ c |>\n<| c |>\nIt\
    \ does work if you pass in an array of numbers that aren't all positive. Try it\
    \ out yourself.\n<|/ c |>\n<| c |>\nI tested it out with numbers that are all\
    \ positive, and it works. Try it out yourself and see if it works for you.\n<|/\
    \ c |>\n<| c |>\nI tested it out with numbers that are all positive, and it works.\
    \ Try it out yourself and see if it works for you.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you pass in an array of numbers that are all negative.\n<|/ c |>\n<|\
    \ a |>\n<code>", "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|n| n/numbers.max}\n\
    end", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min\nend", "  numbers.map\
    \ { |n| n / numbers.reduce(:+) }\nend", "  numbers.min!\n  numbers.max!\n  numbers.map\
    \ { |n| n * 1.0 / numbers.max }\nend", "  numbers.min!=0\n  numbers.max!=1\n \
    \ numbers.map!{|n| n/numbers.max}\nend", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\n\
    end", "  numbers.min!\n  numbers.max!\n  numbers.map { |n| n / numbers.max }\n\
    end", "  numbers.map { |n| n / numbers.reduce(:+) }\nend", "  numbers.map { |n|\
    \ n / numbers.min }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work\
    \ for negative numbers. `[-0.5, -0.4, -0.3, -0.2, -0.1]` returns `[-0.5, -0.4,\
    \ -0.3, -0.2, -0.1]` instead of `[-0.5, -0.4, -0.3, -0.2, -0.1, 0]`\n<|/ c |>\n\
    <| c |>\nIt doesn't work for negative numbers. `[-0.5, -0.4, -0.3, -0.2, -0.1]`\
    \ returns `[-0.5, -0.4, -0.3, -0.2, -0.1]` instead of `[-0.5, -0.4, -0.3, -0.2,\
    \ -0.1, 0]`\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers. `[-0.5,\
    \ -0.4, -0.3, -0.2, -0.1]` returns `[-0.5, -0.4, -0.3, -0.2, -0.1]` instead of\
    \ `[-0.5, -0.4, -0.3, -0.2, -0.1, 0]`\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ negative numbers. `[-0.5, -0.4, -0.3, -0.2, -0.1]` returns `[-0.5, -0.4, -0.3,\
    \ -0.2, -0.1]` instead of `[-0.5, -0.4, -0.3, -0.2, -0.1, 0]`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work for negative numbers. `[-0.5, -0.4, -0.3, -0.2, -0.1]`\
    \ returns `[-0.5, -0.4, -0.3, -0.2, -0.1]` instead of `[-0.5, -0.4, -0.3, -0.2,\
    \ -0.1, 0]`\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.map { |n|\
    \ n / numbers.min }\nend", "  numbers.map { |n| n / numbers.min }\nend", "  numbers.min!=0\n\
    \  numbers.max!=1\n  numbers.map!{|x| x/numbers.max}\nend", "  numbers.map { |n|\
    \ n / numbers.reduce(:+) }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
