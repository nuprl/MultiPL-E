name: HumanEval_69_search
language: rb
prompt: "# You are given a non-empty array of positive integers. Return the greatest\
  \ integer that is greater than \n# zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n# The frequency of an integer is the number\
  \ of times it appears in the array.\n# If no such a value exist, return -1.\n# Examples:\n\
  # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3,\
  \ 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n\
  \    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5,\
  \ 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1,\
  \ candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8,\
  \ 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1,\
  \ candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10,\
  \ 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1,\
  \ candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8,\
  \ 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7,\
  \ 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1,\
  \ candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7,\
  \ 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1,\
  \ candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5,\
  \ 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1,\
  \ candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10,\
  \ 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9,\
  \ 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9,\
  \ 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1,\
  \ candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"
completions: ["  lst.sort\n  lst.each_with_index do |x, i|\n    return i if x > 0\
    \ && x.to_i == lst[0]\n  end\n  return -1\nend", "  lst.sort.reverse\n  lst.each_with_index\
    \ do |e, i|\n    return i if e > 0 && lst.count(e) >= i\n  end\n  -1\nend", " \
    \ lst.sort.reverse\n  lst.each_with_index do |e, i|\n    return i if e == 0\n\
    \    return -1 if e == lst.max\n  end\nend", "  lst.sort.reverse\n  lst.each_with_index\
    \ do |e, i|\n    return i if e == 0\n    return -1 if e == lst.max\n  end\nend",
  "  lst.sort!\n  lst.each_with_index do |e, i|\n    if e > 0 && lst.count(e) >= i\n\
    \      return e\n    end\n  end\n  return -1\nend", "  lst.sort!\n  lst.each_with_index\
    \ do |x, i|\n    if x==0 && lst[i-1]==0\n      return i\n    elsif x==0 && lst[i-1]!=0\n\
    \      return -1\n    elsif x>0 && lst[i-1]==0\n      return i\n    elsif x>0\
    \ && lst[i-1]!=0\n      return i\n    end\n  end\nend", "  lst.sort.reverse!\n\
    \  lst.each_with_index do |x, i|\n    if i > 0 && x > lst[i-1]\n      return i\n\
    \    end\n  end\n  -1\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ doesn't work if the array is empty or has only a single element. Also, it doesn't\
    \ return the greatest integer that is greater than zero.\n<|/ c |>\n<| c |>\n\
    I fixed the problem you mentioned. I also added a solution that returns the greatest\
    \ integer that is greater than zero.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ returns the greatest integer that is greater than zero.\n<|/ c |>\n<| c |>\n\
    I added a solution that returns the greatest integer that is greater than zero.\n\
    <|/ c |>\n<| c |>\nI added a solution that returns the greatest integer that is\
    \ greater than zero.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.sort.each do\
    \ |i|\n    return i if i > 0 && i.to_s.size >= i.to_s.size\n  end\n  return -1\n\
    end", "  lst.each_with_index do |e, i|\n    if e > 0 && lst.count(e) >= i\n  \
    \    return e\n    end\n  end\n  return -1\nend", "  lst.sort.reverse\n  lst.each\
    \ do |i|\n    return i if i > 0 && i.to_s.size >= i.to_s.size\n  end\n  return\
    \ -1\nend", "  lst.sort.reverse\n  lst.each do |i|\n    return i if i > 0 && i.to_s.split('').uniq.count\
    \ > i.to_s.split('').count\n  end\n  -1\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't work for the OP's test case: `search.call([4, 1, 2, 2, 3, 1])`\
    \ returns `2` instead of `3`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. I just added a comment to the OP's question to clarify that they\
    \ were looking for the greatest integer that is greater than zero.\n<|/ c |>\n\
    <| c |>\nI see what you mean. My mistake.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't require sorting. Hopefully it's more efficient than sorting and\
    \ searching twice.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ sorting. Hopefully it's more efficient than sorting and searching twice.\n<|/\
    \ c |>\n<| a |>\n<code>", "  lst.sort.reverse\n  lst.each_with_index do |x, i|\n\
    \    return i if x > 0 && lst.count(x) >= i\n  end\n  return -1\nend", "  lst.sort.each\
    \ do |x|\n    if x > 0 && lst.count(x) >= x\n      return x\n    end\n  end\n\
    \  return -1\nend", "  lst.each do |x|\n    if x > 0 && freq[x] >= x\n      return\
    \ x\n    end\n  end\n  return -1\nend", "  lst.sort.reverse!\n  lst.each_with_index\
    \ do |x,i|\n    if x > 0 && lst.count(x) >= i\n      return x\n    end\n  end\n\
    \  return -1\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  lst.sort.reverse\n\
    \  lst.each_with_index do |val, i|\n    if val > 0\n      return i if lst.count(val)\
    \ >= val\n    end\n  end\n  return -1\nend", "  lst.each do |x|\n    if x > 0\
    \ \n      break\n    elsif lst.count(x) >= x\n      return x\n    end\n  end\n\
    \  return -1\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if\
    \ there are multiple occurrences of the same number.\n<|/ c |>\n<| c |>\nI didn't\
    \ know that about Ruby, but that doesn't seem to be the case here. I tested it\
    \ and it works as expected.\n<|/ c |>\n<| c |>\nI tested it and it works as expected.\
    \ `[4, 1, 2, 2, 3, 1].grep_v(0) { |x| x > 0 }.max_by(&:last)` returns `2`.\n<|/\
    \ c |>\n<| c |>\nI tested it and it works as expected. `[4, 1, 2, 2, 3, 1].grep_v(0)\
    \ { |x| x > 0 }.max_by(&:last)` returns `2`.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works as expected. `[4, 1, 2, 2, 3, 1].grep_v(0) { |x| x > 0 }.max_by(&:last)`\
    \ returns `2`.\n<|/ c |>\n<| a |>\n<code>", "  lst.sort.reverse!\n  lst.each_with_index\
    \ do |x, i|\n    if i > 0 && lst[i-1] == x\n      return i\n    end\n  end\n \
    \ return -1\nend", "  lst.each_with_index do |e, i|\n    return i if e > 0 &&\
    \ freq[e] >= freq[i]\n  end\n  -1\nend", "  lst.sort.reverse\n  lst.each_with_index\
    \ do |e, i|\n    return i if e > 0 && lst.count(e) >= i\n  end\n  return -1\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
