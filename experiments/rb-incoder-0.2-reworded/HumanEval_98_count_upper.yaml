name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"\
  abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  s.gsub!(/[AEIOU]/, '')\n  s.each_char.with_index do |c, i|\n    if\
    \ i % 2 == 0 && c.upcase != c\n      0\n    elsif i % 2 == 1 && c.upcase == c\n\
    \      1\n    else\n      0\n    end\n  end\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }\nend", "  s.gsub(/[AEIOU]/, '').length\n\
    end", "  s.gsub(/[AEIOU]/).with_index { |c,i| i % 2 == 0 ? c.upcase : 0 }\nend",
  "  s.scan(/[aeiou]/).inject(0) { |sum, char| sum + 1 if char.upcase }\nend", " \
    \ s.gsub(/[AEIOU]/) do |match|\n    match.to_i.even? ? 1 : 0\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + (char.upcase\
    \ ? i : 0)\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| return 0 if c =~ /[AEIOU]/;\
    \ 1 }\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.scan(/[AEIOU]/).inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }\nend", "  s.gsub(/[aeiou]/) { |c| c.upcase\
    \ }.size\nend", "  s.gsub!(/[aeiou]/) do |c|\n    (c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') ? 1 : 0\n  end\n  s.count('e') + s.count('i') + s.count('o')\
    \ + s.count('u')\nend", "  s.gsub(/[AEIOU]/) do |match|\n    match.to_s.size %\
    \ 2 == 0 ? match.to_s.size : 0\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| c == 'A'\
    \ ? 1 : 0 }\nend", "  s.gsub(/[aeiou]/) { |c| c.upcase }.size\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", " \
    \ s.gsub(/[AEIOU]/) do |match|\n    match.to_s.size % 2 == 0 ? match.to_s.size\
    \ : match.to_s.size/2\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\nend", " \
    \ s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\nend", "  s.gsub(/[AEIOU]/) { |c|\
    \ c.upcase }.length\nend", "  s.gsub(/[AEIOU]/) do |match|\n    match.to_s.count(\"\
    A\") + match.to_s.count(\"E\") + match.to_s.count(\"I\") + match.to_s.count(\"\
    O\") + match.to_s.count(\"U\")\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c.upcase == c\n    i += 1\n  end\n\
    end", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + case char\n      when 'A'..'Z' then 1\n     \
    \ when 'a'..'z' then -1\n      else 0\n    end\n  end\nend", "  s.gsub(/[AEIOU]/)\
    \ {|c| return c.upcase if $&.odd?}.length\nend", "  s.gsub(/[AEIOU]/) { |c| c\
    \ == 'A' ? 1 : 0 }\nend", "  s.gsub!(/[AEIOU]/) do |c|\n    (c == 'A') ? 1 : 0\n\
    \  end\n  s.count(\"A\")\nend", "  s.scan(/[AEIOU]/).inject(0) { |sum, char| sum\
    \ + 1 if char.upcase }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |sum, el| sum + 1 if el =~ /[AEIOU]/; sum }\nend", "  s.gsub(/[AEIOU]/) do\
    \ |c|\n    cased = c.upcase\n    cased.length if cased.length % 2 == 0\n  end\n\
    end", "  s.each_char.with_index do |c,i|\n    if i % 2 == 0\n      c =~ /[AEIOU]/\n\
    \      next if $~.nil?\n      next if $~.empty?\n      next if $~.size != 1\n\
    \      next if $~.size != 0\n      next if $~.size != 1\n      next if $~.size\
    \ != 0\n      next if $~.size != 1\n      next if $~.size != 0\n      next if\
    \ $~.size != 1\n      next if $~.size != 0\n      next if $~.size != 1\n     \
    \ next if $~.size != 0\n      next if $~.size != 1\n      next if $~.size != 0\n\
    \      next if $~.size != 1\n      next if $~.size != 0\n      next if $~.size\
    \ != 1\n      next if $~.size != 0\n      next if $~.size != 1\n      next if\
    \ $~.size != 0\n      next if $~.size != 1\n      next if $~.size != 0\n     \
    \ next if $~.size != 1\n      next if $~.size != 0\n      next if $~.size != 1\n\
    \      next if $~.size != 0\n      next if $~.size != 1\n      next if $~.size\
    \ != 0\n      next if $~.size != 1\n      next if $~.size != 0\n      next if\
    \ $~.size != 1\n      next if $~.size != 0\n      next if $~.size != 1\n     \
    \ next if $~.size != 0\n      next if $~.size != 1\n      next if $~.size != 0\n\
    \      next if $~.size != 1\n      next if $~.size != 0\n      next if $~.size\
    \ != 1\n      next if $~.size != 0\n      next if $~.size != 1\n      next if\
    \ $~.size != 0\n      next if $~.size != 1\n      next if $~.size != 0\n     \
    \ next if $~.size != 1\n      next if $~.size != 0\n      next if $~.size != 1\n\
    \      next if $~.size != 0\n      next if $~", "  s.gsub(/[AEIOU]/) do |c|\n\
    \    case = c.upcase\n    case[/[AEIOU]/].nil? ? 0 : case == \"A\" ? 1 : case\
    \ == \"E\" ? 2 : case == \"I\" ? 3 : case == \"O\" ? 4 : case == \"U\" ? 5 : 6\n\
    \  end\nend", "  s.each_char.with_index do |c, i|\n    if i % 2 == 0 && c.upcase\
    \ == c\n      yield i + 1\n    end\n  end\nend", "  s.gsub(/[AEIOU]/) do |match|\n\
    \    match.to_i.even? ? 1 : 0\n  end\nend", "  s.scan(/[AEIOU]/)\n  s.count(\"\
    A\") + s.count(\"E\") + s.count(\"I\") + s.count(\"O\") + s.count(\"U\")\nend",
  "  s.gsub(/[AEIOU]/) do |c|\n    cased = c.upcase\n    cased.length if cased =~\
    \ /[AEIOU]/\n  end\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n \
    \   case[/[AEIOU]/].nil? ? 0 : case == \"A\" ? 1 : case == \"E\" ? 2 : case ==\
    \ \"I\" ? 3 : case == \"O\" ? 4 : case == \"U\" ? 5 : 6\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (ch, i)| sum + 1 if i % 2 == 0 && ch.upcase == ch }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + case char\n\
    \      when 'A'..'Z' then 1\n      when 'a'..'z' then -1\n      else 0\n    end\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) { |sum, (ch, i)| sum + 1 if\
    \ i % 2 == 0 && ch.upcase == ch }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", " \
    \ s.scan(/[aeiou]/).inject(0) { |sum, char| sum + char.upcase if char.upcase }\n\
    end", "  s.gsub(/[aeiou]/) { |c| c.upcase }.size\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |sum, e| sum + e.length if e.upcase }\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (ch, i)| sum + 1 if i % 2 == 0 && ch.upcase == ch }\nend", "  s.scan(/[AEIOU]/).inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }\nend", "  s.gsub(/[aeiou]/) { |c| c ==\
    \ 'A' ? 1 : 0 }\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", " \
    \ s.gsub(/[AEIOU]/) do |match|\n    match.length / 2\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase && index%2 == 0\n  end\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum +\
    \ 1 if char.upcase && index%2 == 0\n  end\nend", "  s.gsub(/[AEIOU]/) {|c| c ==\
    \ 'A' ? 1 : c == 'E' ? 2 : c == 'I' ? 3 : c == 'O' ? 4 : c == 'U' ? 5 : 0}\nend",
  "  s.gsub(/[AEIOU]/, '').length\nend", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, i)|\n    sum + 1 if char.upcase && i % 2 == 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\n\
    end", "  s.scan(/[AEIOU]/)\n  s.count(\"A\") + s.count(\"E\") + s.count(\"I\"\
    ) + s.count(\"O\") + s.count(\"U\")\nend", "  s.scan(/[AEIOU]/).inject(0) { |sum,\
    \ char| sum + 1 if char.upcase }\nend", "  s.chars.each_with_index.inject(0) {\
    \ |sum, (ch, i)| sum + 1 if i % 2 == 0 && ch.upcase == ch }\nend", "  s.scan(/[AEIOU]/)\n\
    \  s.count(\"A\") + s.count(\"E\") + s.count(\"I\") + s.count(\"O\") + s.count(\"\
    U\")\nend", "  s.gsub(/[AEIOU]/).to_s.each_char.with_object(Hash.new(0)) { |c,h|\
    \ h[c] += 1 if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' }\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + case char\n\
    \      when 'A'..'Z'\n        1\n      when 'a'..'z'\n        -1\n      else\n\
    \        0\n    end\n  end\nend", "  s.scan(/[AEIOU]/).inject(0) { |sum, letter|\
    \ sum + 1 if letter == 'A' or letter == 'E' or letter == 'I' or letter == 'O'\
    \ or letter == 'U' }\nend", "  s.gsub(/[aeiou]/).inject(0) { |sum, letter| sum\
    \ + 1 if letter == \"A\" || letter == \"E\" || letter == \"I\" || letter == \"\
    O\" || letter == \"U\" }\nend", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks for the answer. I am not able to understand why\
    \ you used `each_with_index` instead of `each_char`? Also, why did you use `inject`\
    \ instead of `reduce`?\n<|/ c |>\n<| c |>\n`each_char` gives you the character\
    \ and the index of the character in the string. `each_with_index` gives you the\
    \ character and the index of the character in the string and the character itself.\
    \ `inject` gives you the character and the index of the character in the string\
    \ and the character itself. `reduce` gives you the character and the index of\
    \ the character in the string and the character itself.\n<|/ c |>\n<| c |>\nThanks.\
    \ I understood now. One more question: why did you use `each_char` instead of\
    \ `each_with_index`?\n<|/ c |>\n<| c |>\n`each_char` gives you the character and\
    \ the index of the character in the string. `each_with_index` gives you the character\
    \ and the index of the character in the string and the character itself. `inject`\
    \ gives you the character and the index of the character in the string and the\
    \ character itself. `reduce` gives you the character and the index of the character\
    \ in the string and the character itself.\n<|/ c |>\n<| c |>\nThanks. I understood\
    \ now. One more question: why did you use `each_char` instead of `each_with_index`?\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.scan(/[AEIOU]/).inject(0) {\
    \ |sum, letter| sum + 1 if letter == 'A' or letter == 'E' or letter == 'I' or\
    \ letter == 'O' or letter == 'U' }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) { |sum, (_, i)| sum + i.upcase\
    \ if i.odd? }\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.gsub(/[aeiou]/)\
    \ do |match|\n    match.to_s.size % 2 == 0 ? match.size : 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) { |sum, (_, i)| sum + i.upcase\
    \ if i.odd? }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i % 2 == 0\n  end\nend",
  "  s.chars.each_with_index.inject(0) { |sum, (_, i)| sum + i.upcase if i.odd? }\n\
    end", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n    case[/[aeiou]/].to_i.even?\
    \ ? case : 0\n  end\nend", "  s.scan(/[aeiou]/).inject(0) { |sum, el| sum + el.length\
    \ if el =~ /[AEIOU]/i }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ i)|\n    sum + 1 if char.upcase == char\n  end\nend", "  s.gsub(/[AEIOU]/, '').length\n\
    end", "  s.chars.each_with_index.inject(0) { |sum, (_, i)| sum + i.upcase if i.odd?\
    \ }\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n    case.length %\
    \ 2 == 0 ? case : case + 'A'\n  end\nend", "  s.scan(/[aeiou]/)\n  s.count(\"\
    A\"..\"Z\").to_i\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + 1 if index % 2 == 0 && char.upcase == \"A\"\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c }\nend", "  s.gsub(/[AEIOU]/,\
    \ '').length\nend", "  s.gsub(/[AEIOU]/) { |m| m.size % 2 == 0 ? m.size : m.size\
    \ + 1 }\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] +=1; h[c].even? }.\n    values.\n    reduce(:+)\nend", "  s.scan(/[AEIOU]/).inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }\nend", "  s.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] +=1; h[c].even? }.\n    values.\n    reduce(:+)\nend", "  s.gsub(/[aeiou]/)\
    \ { |match| match.size % 2 == 0 ? match.size : match.size - 1 }\nend", "  s.scan(/[AEIOU]/).inject(0)\
    \ { |sum, e| sum + 1 if e == \"A\" || e == \"E\" || e == \"I\" || e == \"O\" ||\
    \ e == \"U\" }\nend", "  s.chars.each_with_index.inject(0) {|sum, (_, i)| sum\
    \ + 1 if i.odd? && i.upcase }\nend", "  s.scan(/[aeiou]/).inject(0) { |sum, char|\
    \ sum + 1 if char.upcase }\nend", "  s.gsub!(/[AEIOU]/, '')\n  s.each_char.with_index\
    \ do |c, i|\n    if i % 2 == 0 && c.upcase != c\n      0\n    elsif i % 2 == 1\
    \ && c.upcase == c\n      1\n    else\n      0\n    end\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase && index % 2 == 0\n  end\n\
    end", "  s.gsub(/[AEIOU]/) do |match|\n    match.to_i.even? ? 1 : 0\n  end\nend",
  "  s.gsub(/[aeiou]/) { |match| match.size % 2 == 0 ? match.size : match.size - 1\
    \ }\nend", "  s.gsub(/[AEIOU]/) do |match|\n    match.length / 2\n  end\nend",
  "  s.gsub(/[aeiou]/) { |c| c == 'A' ? 1 : 0 }\nend", "  s.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] +=1; h[c].even? }.\n    values.\n    reduce(:+)\nend", "  s.gsub(/[AEIOU]/)\
    \ { |c| return 0 if c =~ /[AEIOU]/; 1 }\nend", "  s.gsub(/[aeiou]/) { |match|\
    \ match.upcase }.length\nend", "  s.gsub!(/[^aeiouAEIOU]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '').length\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.gsub(/[AEIOU]/)\
    \ {|c| c == 'A' ? 1 : c == 'E' ? 2 : c == 'I' ? 3 : c == 'O' ? 4 : c == 'U' ?\
    \ 5 : 0}\nend", "  s.chars.each_with_index.inject(0) { |sum, (char, i)| sum +\
    \ 1 if i % 2 == 0 && char.upcase }\nend", "  s.gsub(/[AEIOU]/) do |match|\n  \
    \  match.to_s.size % 2 == 0 ? match.to_s.size : 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i % 2 == 0\n  end\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + 1 if index\
    \ % 2 == 0 && char.upcase == char\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| c.upcase\
    \ }.length\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.gsub!(/[^aeiouAEIOU]/,\
    \ '')\n  s.each_char.with_object(Hash.new(0)) { |c,h| h[c] += 1 if c.upcase ==\
    \ c }\nend", "  s.gsub!(/[AEIOU]/, '')\n  s.each_char.with_index.with_object(Hash.new(0))\
    \ { |c,i| c == 'A' ? i += 1 : c == 'E' ? i += 2 : c == 'I' ? i += 2 : c == 'O'\
    \ ? i += 2 : c == 'U' ? i += 2 : c == 'a' ? i += 1 : c == 'e' ? i += 1 : c ==\
    \ 'i' ? i += 1 : c == 'o' ? i += 1 : c == 'u' ? i += 1 : c == 'A' ? i += 2 : c\
    \ == 'E' ? i += 2 : c == 'I' ? i += 2 : c == 'O' ? i += 2 : c == 'U' ? i += 2\
    \ : c == 'a' ? i += 2 : c == 'e' ? i += 2 : c == 'i' ? i += 2 : c == 'o' ? i +=\
    \ 2 : c == 'u' ? i += 2 : c == 'A' ? i += 4 : c == 'E' ? i += 4 : c == 'I' ? i\
    \ += 4 : c == 'O' ? i += 4 : c == 'U' ? i += 4 : c == 'a' ? i += 4 : c == 'e'\
    \ ? i += 4 : c == 'i' ? i += 4 : c == 'o' ? i += 4 : c == 'u' ? i += 4 : c ==\
    \ 'A' ? i += 6 : c == 'E' ? i += 6 : c == 'I' ? i += 6 : c == 'O' ? i += 6 : c\
    \ == 'U' ? i += 6 : c == 'a' ? i += 6 : c == 'e' ? i += 6 : c == 'i' ? i += 6\
    \ : c == 'o' ? i += 6 : c == 'u' ? i += 6 : c == 'A' ? i += 8 : c == 'E' ? i +=\
    \ 8 : c == 'I' ? i += 8 : c == 'O' ? i += 8 : c == 'U' ? i += 8 : c == 'a' ? i\
    \ += 8 : c == 'e' ? i += 8 : c == 'i' ? i += 8 : c == 'o' ? i += 8 : c == 'u'\
    \ ? i += 8 : c == 'A' ? i += 10 : c == 'E' ? i += 10 : c == 'I' ? i += 10 : c\
    \ == 'O' ? i += 10 : c == 'U' ? i += 10 : c == 'a' ? i += 10 : c == 'e' ? i +=\
    \ 10 : c == 'i' ? i += 10 : c == 'o' ? i += 10 : c == 'u' ? i += 10 : c == 'A'\
    \ ? i += 12 : c == 'E' ? i += 12 : c == 'I' ? i += 12 : c == 'O' ? i += 12 : c\
    \ == 'U' ? i += 12 : c == 'a' ? i += 12 : c == 'e' ? i += 12 : c == 'i' ? i +=\
    \ 12 : c == 'o' ? i += 12 : c == 'u' ? i += 12 : c == 'A' ? i += 14 : c == 'E'\
    \ ? i += 14 : c == 'I' ? i += 14", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, index)|\n    sum + 1 if index&1 == 0 && char == char.upcase\n  end\n\
    end", "  s.scan(/[aeiou]/).inject(0) { |sum, el| sum + el.length % 2 == 0 ? sum\
    \ + el.length : sum }\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\").to_i\n\
    end", "  s.gsub(/[AEIOU]/).with_index { |c,i| c == 'A' ? 0 : (c != 'E' ? 1 : 2)\
    \ }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum\
    \ + 1 if char.upcase && index % 2 == 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + (char.upcase ? 1 : 0)\n  end\nend", "  s.gsub(/[AEIOU]/)\
    \ { |c| c.upcase }.length\nend", "  s.gsub(/[aeiou]/i) { |c| c.upcase }.size\n\
    end", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (_, i)| sum + i.upcase if i.odd? }\nend", "  s.gsub(/[AEIOU]/) do |match|\n\
    \    match.size % 2 == 0 ? match.size : match.size - 1\n  end\nend", "  s.scan(/[aeiou]/)\n\
    \  s.count(\"A\"..\"Z\").to_i\nend", "  s.chars.each_with_index.inject(0) {|sum,\
    \ (c, i)| sum + c if i % 2 == 0 && c.upcase == c}\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", " \
    \ s.scan(/[AEIOU]/).inject(0) { |sum, letter| sum + letter.upcase if letter ==\
    \ 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U' }\n\
    end", "  s.scan(/[AEIOU]/).inject(0) { |sum, char| sum + 1 if char.upcase }\n\
    end", "  s.gsub!(/[AEIOU]/) { |c| c.upcase }\n  s.scan(/[AEIOU]/).size\nend",
  "  s.gsub(/[aeiou]/i) { |c| c == 'A' ? 1 : 0 }\nend", "  s.gsub(/[aeiou]/) { |m|\
    \ m.upcase }.length\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |sum, char| sum + 1 if char.upcase }\nend", "  s.gsub!(/[AEIOU]/, '')\n  s.each_char.with_index\
    \ do |c, i|\n    if i % 2 == 0 && c.upcase == c\n      yield i\n    end\n  end\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + 1 if\
    \ i % 2 == 0 && char.upcase == char\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| c\
    \ == 'A' ? 1 : 0 }\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.gsub(/[AEIOU]/).with_index\
    \ { |match,i| match[0].upcase == match[0] ? 0 : 1 }\nend", "  s.gsub(/[AEIOU]/,\
    \ '').length\nend", "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\nend", "  s.scan(/[aeiou]/)\n\
    \  s.count(\"AEIOU\")\nend", "  s.scan(/[AEIOU]/).inject(0) { |sum, char| sum\
    \ + 1 if char.upcase }\nend", "  s.scan(/[aeiou]/).inject(0) { |sum, element|\
    \ sum + element == \"A\" ? 1 : 0 }\nend", "  s.gsub!(/[AEIOU]/) do |c|\n    case\
    \ = case c\n    when 'A'..'E'\n      1\n    when 'I'..'O'\n      0\n    else\n\
    \      0\n    end\n  end\n  s.count('AEIOU')\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i % 2 == 0\n  end\nend",
  "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i.even?\n  end\nend", " \
    \ s.scan(/[AEIOU]/).inject(0) { |sum, letter| sum + letter.upcase if letter.upcase\
    \ }\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n    case[/[aeiou]/i].nil?\
    \ ? case : 0\n  end\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n\
    \    case[0,1] == case ? 1 : 0\n  end\nend", "  s.gsub(/[AEIOU]/, '').length\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + 1 if\
    \ i % 2 == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\n\
    end", "  s.scan(/[aeiou]/).inject(0) { |sum, char| sum + 1 if char.upcase }\n\
    end", "  s.gsub(/[AEIOU]/) do |match|\n    match.to_s.count(\"A\") + match.to_s.count(\"\
    E\") + match.to_s.count(\"I\") + match.to_s.count(\"O\") + match.to_s.count(\"\
    U\")\n  end\nend", "  s.gsub(/[AEIOU]/) { |m| m.length % 2 == 0 ? m.upcase : 0\
    \ }\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.scan(/[AEIOU]/).inject(0) { |sum, char| sum + 1 if char.upcase\
    \ }\nend", "  s.gsub(/[AEIOU]/) {|c| c.upcase if $even_odd[$&] }.length\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + (char ==\
    \ char.upcase ? 0 : 1)\n  end\nend", "  s.scan(/[aeiou]/).inject(0) { |sum, char|\
    \ sum + 1 if char.upcase }\nend", "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0\
    \ }\nend", "  s.gsub(/[aeiou]/) do |match|\n    match.to_s.size % 2 == 0 ? match.to_s.size\
    \ : 0\n  end\nend", "  s.scan(/[aeiou]/).inject(0) { |sum, e| sum + e.to_i.even?\
    \ }\nend", "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.gsub(/[AEIOU]/)\
    \ { |c| c == 'A' ? 1 : 0 }\nend", "  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(/[AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/, '')\n  s.gsub!(", "  s.each_char.with_index do |c,\
    \ i|\n    if i % 2 == 0 && c.upcase != c\n      0\n    else\n      1\n    end\n\
    \  end\nend", "  s.gsub(/[aeiou]/) do |match|\n    match.length % 2 == 0 ? match.length\
    \ : match.length / 2\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| c.upcase }.length\n\
    end", "  s.each_char.with_index do |c, i|\n    if i % 2 == 0 && c.upcase == c\n\
    \      yield i\n    end\n  end\nend", "  s.chars.each_with_index.inject(0) do\
    \ |sum, (char, index)|\n    sum + 1 if char.upcase && index % 2 == 0\n  end\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + 1 if\
    \ char.upcase && i.even?\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your answer. Your solution works perfectly for strings with even number\
    \ of characters. But what if I want to count the number of uppercase vowels in\
    \ strings with odd number of characters?\n<|/ c |>\n<| c |>\n: I updated my answer\
    \ to include a solution for strings with an odd number of characters.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\nend",
  "  s.gsub(/[aeiou]/) do |match|\n    match.size % 2 == 0 ? match.size : match.size\
    \ - 1\n  end\nend", "  s.gsub(/[aeiou]/) { |m| m.upcase }.length\nend", "  s.gsub(/[AEIOU]/,\
    \ '').length\nend", "  s.scan(/[AEIOU]/)\n  s.count(\"A\") + s.count(\"E\") +\
    \ s.count(\"I\") + s.count(\"O\") + s.count(\"U\")\nend", "  s.gsub(/[AEIOU]/,\
    \ '').length\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.gsub!(/[^AEIOU]/,\
    \ '')\n  s.gsub!(/[AEIOU]/) { |c| c.upcase }\n  s.count('AEIOU')\nend", "  s.gsub(/[AEIOU]/)\
    \ do |c|\n    case = c.upcase\n    case[/[AEIOU]/].nil? ? 0 : case == \"A\" ?\
    \ 1 : case == \"E\" ? 2 : case == \"I\" ? 3 : case == \"O\" ? 4 : case == \"U\"\
    \ ? 5 : 6\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n\
    \    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\nend", "  s.gsub(/[AEIOU]/,\
    \ '').length\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n\
    \    sum + 1 if char.upcase && i.even?\n  end\nend", "  s.gsub(/[aeiou]/i) { |c|\
    \ c.upcase }.length\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n\
    \    case[/[aeiou]/i].nil? ? case : 0\n  end\nend", "  s.gsub(/[AEIOU]/) { |c|\
    \ return 0 if c.upcase == c }\n  s.count(\"A\") + s.count(\"E\") + s.count(\"\
    I\") + s.count(\"O\") + s.count(\"U\")\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase && i % 2 == 0\n  end\nend",
  "  s.scan(/[AEIOU]/).inject(0) { |sum, letter| sum + 1 if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' }\nend", "  s.gsub(/[aeiou]/)\
    \ { |c| c.upcase }.size\nend", "  s.gsub(/[aeiou]/) do |match|\n    match.size\
    \ % 2 == 0 ? match.size : match.size - 1\n  end\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |sum, el| sum + 1 if el =~ /[AEIOU]/i }\nend", "  s.gsub(/[AEIOU]/) {|c| c\
    \ == 'A' ? 1 : c == 'E' ? 2 : c == 'I' ? 3 : c == 'O' ? 4 : c == 'U' ? 5 : 0}\n\
    end", "  s.gsub(/[AEIOU]/).with_index { |c, i| i % 2 == 0 && c.upcase }.length\n\
    end", "  s.gsub(/[aeiou]/) do |match|\n    match.to_i.even? ? 1 : 0\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
