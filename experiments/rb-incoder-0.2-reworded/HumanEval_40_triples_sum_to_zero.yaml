name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are three distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>>\
  \ triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1,\
  \ 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n\
  # >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return\
    \ true if i != j && i != k && j != k\n      end\n    end\n  end\n  return false\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x + y + z == 0\n      end\n\
    \    end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x + y +\
    \ z == 0 && i != j && j != k && k != i\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis code does not work for the case `triples_sum_to_zero.call([1,2,3])`\n\
    <|/ c |>\n<| c |>\nIt does work for the case `triples_sum_to_zero.call([1,2,3])`\n\
    <|/ c |>\n<| c |>\nIt does work for the case `triples_sum_to_zero.call([1,2,3])`\n\
    <|/ c |>\n<| c |>\nIt does work for the case `triples_sum_to_zero.call([1,2,3])`\n\
    <|/ c |>\n<| c |>\nIt does work for the case `triples_sum_to_zero.call([1,2,3])`\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each do |i|\n    l.each do |j|\n  \
    \    l.each do |k|\n        return true if i + j + k == 0\n      end\n    end\n\
    \  end\n  false\nend", "  l.each_with_index do |e, i|\n    l.each_with_index do\
    \ |e2, j|\n      l.each_with_index do |e3, k|\n        return true if e + e2 +\
    \ e3 == 0\n      end\n    end\n  end\n  false\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x + y + z == 0\n      end\n\
    \    end\n  end\n  return false\nend", "  l.each do |x|\n    l.each do |y|\n \
    \     l.each do |z|\n        return true if x + y + z == 0\n      end\n    end\n\
    \  end\n  return false\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not\
    \ the most efficient solution. Try running it on `[1, 1, 1]`.\n<|/ c |>\n<| c\
    \ |>\nI agree with you. I've edited my answer to include a more efficient solution.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x + y + z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work\
    \ if there are multiple triplets that sum to zero.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are multiple triplets that sum to zero. Try it out yourself.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if there are multiple triplets that sum to\
    \ zero. Try it out yourself. Try it out yourself. Try it out yourself. Try it\
    \ out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out yourself.\
    \ Try it out yourself. Try it out yourself. Try it out yourself. Try it out ",
  "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\nThis solution will run into problems if you\
    \ have a large array and you have a lot of zeros in the array. For example, `triples_sum_to_zero.call([0,1,2,0])`\
    \ will return `true` even though there are only three distinct elements that sum\
    \ to zero.\n<|/ c |>\n<| c |>\nYes, I agree. My solution was meant to be a proof\
    \ of concept, not an efficient solution. I'll edit my answer to include a more\
    \ efficient solution.\n<|/ c |>\n<| c |>\nI added a more efficient solution that\
    \ doesn't require any loops.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using\
    \ Array#combination:\n<code>", "  l.each_with_index do |e, i|\n    l.each_with_index\
    \ do |f, j|\n      l.each_with_index do |g, k|\n        return true if e + f +\
    \ g == 0 && i != j && i != k && j != k\n      end\n    end\n  end\n  false\nend",
  "  l.each do |x|\n    next if x == 0\n    l.each do |y|\n      next if y == 0\n\
    \      l.each do |z|\n        next if z == 0 || x + y + z == 0\n        break\n\
    \      end\n      break\n    end\n    break\n  end\n  false\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    l.each_with_index do |e2, j|\n      l.each_with_index\
    \ do |e3, k|\n        return true if e + e2 + e3 == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x == y && y == z &&\
    \ z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index do |e,\
    \ i|\n    next if i == 0\n    next if e == 0\n    next if e == l[i-1]\n    next\
    \ if e == l[i-2]\n    next if e == l[i-3]\n    next if e == l[i-4]\n    next if\
    \ e == l[i-5]\n    next if e == l[i-6]\n    next if e == l[i-7]\n    next if e\
    \ == l[i-8]\n    next if e == l[i-9]\n    next if e == l[i-10]\n    next if e\
    \ == l[i-11]\n    next if e == l[i-12]\n    next if e == l[i-13]\n    next if\
    \ e == l[i-14]\n    next if e == l[i-15]\n    next if e == l[i-16]\n    next if\
    \ e == l[i-17]\n    next if e == l[i-18]\n    next if e == l[i-19]\n    next if\
    \ e == l[i-20]\n    next if e == l[i-21]\n    next if e == l[i-22]\n    next if\
    \ e == l[i-23]\n    next if e == l[i-24]\n    next if e == l[i-25]\n    next if\
    \ e == l[i-26]\n    next if e == l[i-27]\n    next if e == l[i-28]\n    next if\
    \ e == l[i-29]\n    next if e == l[i-30]\n    next if e == l[i-31]\n    next if\
    \ e == l[i-32]\n    next if e == l[i-33]\n    next if e == l[i-34]\n    next if\
    \ e == l[i-35]\n    next if e == l[i-36]\n    next if e == l[i-37]\n    next if\
    \ e == l[i-38]\n    next if e == l[i-39]\n    next if e == l[i-40]\n    next if\
    \ e == l[i-41]\n    next if e == l[i-42]\n    next if e == l[i-43]\n    next if\
    \ e == l[i-44]\n    next if e == l[i-45]\n    next if e == l[i-46]\n    next if\
    \ e == l[i-47]\n", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n\
    \        return true if x + y + z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |x, i|\n    next if i == 0\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x + y +\
    \ z == 0 && i != j && i != k && j != k\n      end\n    end\n  end\n  false\nend",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        if i == j && j == k\n          return false if x == y\n \
    \       end\n      end\n    end\n  end\n  true\nend", "  l.each_with_index do\
    \ |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        if i != j && i != k && j != k && x + y + z == 0 \n          return true\n\
    \        end\n      end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if there are three or more zeroes in the array.\n\
    <|/ c |>\n<| c |>\nI added a solution that works with three or more zeroes.\n\
    <|/ c |>\n<| c |>\nI added a solution that works with three or more zeroes.\n\
    <|/ c |>\n<| c |>\nI added a solution that works with three or more zeroes.\n\
    <|/ c |>\n<| c |>\nI added a solution that works with three or more zeroes.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    l.each_with_index do |e2, j|\n      next\
    \ if j == 0\n      l.each_with_index do |e3, k|\n        next if k == 0\n    \
    \    l.each_with_index do |e4, l|\n          next if l == 0\n          next if\
    \ e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e +\
    \ e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 +\
    \ e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3 ==\
    \ 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n\
    \          next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n    \
    \      next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n        \
    \  next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next\
    \ if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e\
    \ + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2\
    \ + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3\
    \ == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n\
    \          next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n    \
    \      next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n        \
    \  next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next\
    \ if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e\
    \ + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2\
    \ + e3 == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3\
    \ == 0\n          next if e + e2 + e3 == 0\n          next if e + e2 + e3 == 0\n\
    \          next if e + e2 + e3 == 0\n", "  l.each_with_index do |e, i|\n    l.delete_at(i)\n\
    \    break if l.length < 3\n  end\n  l.length == 0 || l.length == l.uniq.size\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are multiple\
    \ triplets that sum to zero.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The OP didn't specify that there could be multiple triplets that\
    \ sum to zero.\n<|/ c |>\n<| c |>\nI see what you mean. My bad.\n<|/ c |>\n<|\
    \ c |>\nI added a second solution that doesn't require the triplets to sum to\
    \ zero.\n<|/ c |>\n<| c |>\nThe second solution doesn't work if there are multiple\
    \ triplets that sum to zero. Try it with `[1,2,-3,-5,-7,-9,0]`.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.each_cons(3).all? { |a,b,c|\
    \ a + b + c == 0 }\nend", "  l.each_with_index do |e, i|\n    l.slice!(i..i+3)\n\
    \    break if l.uniq.size == 3\n  end\n  l.size == 0\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    next if e == 0\n    next if e == l[i-1]\n\
    \    next if e == l[i-2]\n    next if e == l[i-3]\n    next if e == l[i-4]\n \
    \   next if e == l[i-5]\n    next if e == l[i-6]\n    next if e == l[i-7]\n  \
    \  next if e == l[i-8]\n    next if e == l[i-9]\n    next if e == l[i-10]\n  \
    \  next if e == l[i-11]\n    next if e == l[i-12]\n    next if e == l[i-13]\n\
    \    next if e == l[i-14]\n    next if e == l[i-15]\n    next if e == l[i-16]\n\
    \    next if e == l[i-17]\n    next if e == l[i-18]\n    next if e == l[i-19]\n\
    \    next if e == l[i-20]\n    next if e == l[i-21]\n    next if e == l[i-22]\n\
    \    next if e == l[i-23]\n    next if e == l[i-24]\n    next if e == l[i-25]\n\
    \    next if e == l[i-26]\n    next if e == l[i-27]\n    next if e == l[i-28]\n\
    \    next if e == l[i-29]\n    next if e == l[i-30]\n    next if e == l[i-31]\n\
    \    next if e == l[i-32]\n    next if e == l[i-33]\n    next if e == l[i-34]\n\
    \    next if e == l[i-35]\n    next if e == l[i-36]\n    next if e == l[i-37]\n\
    \    next if e == l[i-38]\n    next if e == l[i-39]\n    next if e == l[i-40]\n\
    \    next if e == l[i-41]\n    next if e == l[i-42]\n    next if e == l[i-43]\n\
    \    next if e == l[i-44]\n    next if e == l[i-45]\n    next if e == l[i-46]\n\
    \    next if e == l[i-47]\n", "  l.each do |i|\n    l.each do |j|\n      l.each\
    \ do |k|\n        if i + j + k == 0 \n          return true\n        end\n   \
    \   end\n    end\n  end\n  return false\nend", "  l.each_with_index do |x, i|\n\
    \    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        if\
    \ i != j && j != k && k != i && x + y + z == 0 \n          return true\n     \
    \   end\n      end\n    end\n  end\n  return false\nend", "  l.each_with_index\
    \ do |e, i|\n    l.delete_at(i)\n    break if l.length < 3\n  end\n  l.length\
    \ == 0 || l.length == 1 && l[0] == 0\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work if the array is `[1,2,3]`. It returns `true` when it should\
    \ return `false`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work if the array is `[1,2,3]`.\
    \ It returns `true` when it should return `false`.\n<|/ c |>\n<| c |>\nYes, I\
    \ noticed that and fixed it. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the array is `[1,2,3]`. It returns `true` when it should\
    \ return `false`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return false if (x + y + z == 0)\n\
    \      end\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is not an answer to the question. Also, your code is O(n^3). Which is unacceptable.\n\
    <|/ c |>\n<| c |>\nI agree with you, my code is not the most efficient one, but\
    \ I wanted to show how it could be done in Ruby. And I agree with you that my\
    \ code is O(n^3), but it is O(n^2) in terms of Big O notation.\n<|/ c |>\n<| c\
    \ |>\nI agree with you, but I wanted to show how it could be done in Ruby. And\
    \ I agree with you that my code is O(n^3), but it is O(n^2) in terms of Big O\
    \ notation.\n<|/ c |>\n<| c |>\nI agree with you, but I wanted to show how it\
    \ could be done in Ruby. And I agree with you that my code is O(n^3), but it is\
    \ O(n^2) in terms of Big O notation.\n<|/ c |>\n<| c |>\nI agree with you, but\
    \ I wanted to show how it could be done in Ruby. And I agree with you that my\
    \ code is O(n^3), but it is O(n^2) in terms of Big O notation.\n<|/ c |>\n<| a\
    \ tags=ruby,arrays |>\n<code>", "  l.each_with_index do |e, i|\n    next if i\
    \ == 0\n    next if e == 0\n    l.delete_at(i)\n    break if l.length < 3\n  end\n\
    \  l.length == 0 || l.length == 3\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        return true if i != j && i != k && j != k\n    \
    \  end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis solution doesn't work if there are duplicate elements in the array.\
    \ For example, `[1,1,2,3]` returns `true`, but `[1,1,2,3]` should return `false`.\n\
    <|/ c |>\n<| c |>\nThis solution doesn't work if there are duplicate elements\
    \ in the array. For example, `[1,1,2,3]` returns `true`, but `[1,1,2,3]` should\
    \ return `false`.\n<|/ c |>\n<| c |>\nI added a solution that doesn't have this\
    \ problem.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  l.each_with_index do |x, i|\n\
    \    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ true if x == y && y == z && z == 0\n      end\n    end\n  end\n  false\nend",
  "  l.each_with_index do |e, i|\n    l.slice(i..i+3).all? { |e2, j| e + e2 == 0 }\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if\
    \ there are multiple zeros in the array. For example, `[1, 1, 0]` returns `true`,\
    \ but `[1, 1, 0, 0]` returns `false`.\n<|/ c |>\n<| c |>\n: Good catch. Fixed.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |x|\n    l.each do |y|\n\
    \      l.each do |z|\n        return true if x+y+z == 0\n      end\n    end\n\
    \  end\n  return false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  true\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x+y+z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code\
    \ doesn't work for the case `l = [1, 3, -2, 1]`\n<|/ c |>\n<| c |>\nIt does work\
    \ for the case `l = [1, 3, -2, 1]`\n<|/ c |>\n<| c |>\nIt does work for the case\
    \ `l = [1, 3, -2, 1]`\n<|/ c |>\n<| c |>\nIt does work for the case `l = [1, 3,\
    \ -2, 1]`\n<|/ c |>\n<| c |>\nIt does work for the case `l = [1, 3, -2, 1]`\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis code will fail\
    \ for `[1, 1, 1]`\n<|/ c |>\n<| c |>\nIt will also fail for `[1, 1, 0]`\n<|/ c\
    \ |>\n<| c |>\nIt will also fail for `[1, 1, -1]`\n<|/ c |>\n<| c |>\nIt will\
    \ also fail for `[1, 1, -1]`\n<|/ c |>\n<| c |>\nIt will also fail for `[1, 1,\
    \ -1]`\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |i|\n    l.each\
    \ do |j|\n      l.each do |k|\n        return true if i + j + k == 0\n      end\n\
    \    end\n  end\n  false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.each_with_index do |e, i|\n    next if i == 0\n    l.each_with_index do |e2,\
    \ j|\n      l.each_with_index do |e3, k|\n        return true if e + e2 + e3 ==\
    \ 0\n      end\n    end\n  end\n  false\nend", "  l.each do |x|\n    l.each do\
    \ |y|\n      l.each do |z|\n        return true if x+y+z == 0\n      end\n   \
    \ end\n  end\n  return false\nend", "  l.each do |i|\n    l.each do |j|\n    \
    \  l.each do |k|\n        return true if i+j+k == 0\n      end\n    end\n  end\n\
    \  false\nend\n</code>\n<|/ a |>\n<| c |>\nI like the idea of using three nested\
    \ loops, but this solution doesn't scale well for large lists. I believe that\
    \ `O(n^3)` solutions are possible in some cases, but not here.\n<|/ c |>\n<| c\
    \ |>\nI agree with you, but I believe that this is one of the most efficient solutions\
    \ possible. Of course, there might be other solutions that can scale better, but\
    \ this one is the most efficient one I can think of.\n<|/ c |>\n<| c |>\nI agree\
    \ with you, but I believe that this is one of the most efficient solutions possible.\
    \ Of course, there might be other solutions that can scale better, but this one\
    \ is the most efficient one I can think of.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I believe that this is one of the most efficient solutions possible. Of\
    \ course, there might be other solutions that can scale better, but this one is\
    \ the most efficient one I can think of.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I believe that this is one of the most efficient solutions possible. Of\
    \ course, there might be other solutions that can scale better, but this one is\
    \ the most efficient one I can think of.\n<|/ c |>\n<| a |>\nI believe that this\
    \ is one of the most efficient solutions possible. Of course, there might be other\
    \ solutions that can scale better, but this one is the most efficient one I can\
    \ think of.\n<code>", "  l.each_with_index do |e, i|\n    l.each_with_index do\
    \ |f, j|\n      l.each_with_index do |g, k|\n        return true if e + f + g\
    \ == 0 && i != j && i != k && j != k\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1, 1, 1]`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `[1, 1, 1]`. `triples_sum_to_zero`\
    \ returns `true` for `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it\
    \ with `[1, 1, 1]`. `triples_sum_to_zero` returns `true` for `[1, 1, 1]`.\n<|/\
    \ c |>\n<| c |>\nIt does work. Try it with `[1, 1, 1]`. `triples_sum_to_zero`\
    \ returns `true` for `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with\
    \ `[1, 1, 1]`. `triples_sum_to_zero` returns `true` for `[1, 1, 1]`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  l.each do |i|\n    l.each do |j|\n      l.each do\
    \ |k|\n        return true if i != j && i != k && j != k\n      end\n    end\n\
    \  end\n  return false\nend", "  l.each_with_index do |x, i|\n    next if i ==\
    \ 0\n    l.each_with_index do |y, j|\n      next if j == i\n      l.each_with_index\
    \ do |z, k|\n        next if k == j\n        return true if x + y + z == 0\n \
    \     end\n    end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n   \
    \ l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ false if i == j && j == k && x == y\n      end\n    end\n  end\n  true\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your efforts, but I believe\
    \ that your solution is too complicated for my level of understanding. I am not\
    \ looking for an answer that solves my problem, but an explanation of why my solution\
    \ does not work. Thank you anyway!\n<|/ c |>\n<| c |>\nI added some comments to\
    \ my solution. Hope it helps.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but\
    \ I believe that your solution is too complicated for my level of understanding.\
    \ I am not looking for an answer that solves my problem, but an explanation of\
    \ why my solution does not work. Thank you anyway!\n<|/ c |>\n<| c |>\nI added\
    \ some comments to my solution. Hope it helps.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x == y && y == z &&\
    \ z == 0\n      end\n    end\n  end\n  false\nend", "  l.each do |i|\n    l.each\
    \ do |j|\n      l.each do |k|\n        return true if i + j + k == 0\n      end\n\
    \    end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if i == j\
    \ && j == k && x + y + z == 0\n      end\n    end\n  end\n  false\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like the idea of using each_with_index but this doesn't work\
    \ for me because I need to return true if the sum of the three numbers is zero.\
    \ Your code returns true if the sum is zero for all three numbers. I edited my\
    \ question to clarify this.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a solution that returns true if the sum is zero.\n<|/ c |>\n<| c |>\nI like\
    \ your solution but I think it can be made more efficient by using a hash to store\
    \ the sum of the three numbers and then checking if the sum is zero.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a solution that uses hashes to store the\
    \ sum of the three numbers and then checks if the sum is zero.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    next if i == 0\n    l.each_with_index do |y, j|\n      next if\
    \ j == i\n      l.each_with_index do |z, k|\n        next if k == j\n        return\
    \ false if x + y + z == 0\n      end\n    end\n  end\n  true\nend", "  l.each_with_index\
    \ do |x, i|\n    next if i == 0\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x == y && y == z && z == 0\n      end\n  \
    \  end\n  end\n  false\nend", "  l.each do |x|\n    next if x == 0\n    l.each\
    \ do |y|\n      next if y == 0\n      l.each do |z|\n        return true if x\
    \ + y + z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        if i != j && j != k && k != i && x + y + z == 0 \n          return true\n\
    \        end\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work. Try `triples_sum_to_zero.call([1,3,-2,1])`\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I've fixed the code.\n<|/ c |>\n\
    <| c |>\nI like the idea of using each_with_index, but I think it would be better\
    \ to use a `break` statement instead of `return` in the inner loops.\n<|/ c |>\n\
    <| c |>\nI agree with you. I've edited the code to use `break` instead of `return`.\n\
    <|/ c |>\n<| c |>\nI like the idea of using each_with_index, but I think it would\
    \ be better to use a `break` statement instead of `return` in the inner loops.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l.each_with_index do |e, i|\n    l.each_with_index\
    \ do |f, j|\n      l.each_with_index do |g, k|\n        next if i == j && j ==\
    \ k\n        next if e + f + g == 0\n        return false if e + f + g > 0\n \
    \     end\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are multiple triplets that sum to zero. For\
    \ example, `[1, 1, 1]` returns `true`, but `[1, 1, 2]` returns `false`.\n<|/ c\
    \ |>\n<| c |>\nI added a version that returns `true` when there are multiple triplets\
    \ that sum to zero.\n<|/ c |>\n<| c |>\nI added a version that returns `true`\
    \ when there are multiple triplets that sum to zero.\n<|/ c |>\n<| c |>\nI added\
    \ a version that returns `true` when there are multiple triplets that sum to zero.\n\
    <|/ c |>\n<| c |>\nI added a version that returns `true` when there are multiple\
    \ triplets that sum to zero.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        if x + y + z\
    \ == 0 then return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x == y && y == z && z == 0\n      end\n  \
    \  end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k && x == y\n      end\n    end\n  end\n  true\nend\n</cell>\n<cell>",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k && x + y + z == 0\n    \
    \  end\n    end\n  end\n  true\nend", "  l.each do |i|\n    l.each do |j|\n  \
    \    l.each do |k|\n        return true if i + j + k == 0\n      end\n    end\n\
    \  end\n  false\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n\
    \        return true if i + j + k == 0\n      end\n    end\n  end\n  false\nend",
  "  l.each_with_index do |e, i|\n    l.each_with_index do |f, j|\n      l.each_with_index\
    \ do |g, k|\n        return true if e + f + g == 0 && i != j && i != k && j !=\
    \ k\n      end\n    end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n\
    \    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ false if i == j && j == k && z == 0\n      end\n    end\n  end\n  true\nend",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return true if\
    \ i + j + k == 0\n      end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work. Try it\
    \ with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a |>\n<code>",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x+y+z == 0 && i != j && j != k && k != i\n\
    \      end\n    end\n  end\n  false\nend", "  l.sort!\n  l.each_cons(3).any? {\
    \ |a,b,c| a+b+c == 0 }\nend", "  l.each_with_index do |e, i|\n    l.delete_at(i)\n\
    \    break if l.length < 3\n  end\n  l.length < 3\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are multiple zeros in the array. For\
    \ example, `[0, 0, 0, 0]` returns `true`, but `[0, 0, 0, 1]` returns `false`.\n\
    <|/ c |>\n<| c |>\nI added a version that works with multiple zeros in the array.\n\
    <|/ c |>\n<| c |>\nI added a version that works with multiple zeros in the array.\n\
    <|/ c |>\n<| c |>\nI added a version that works with multiple zeros in the array.\n\
    <|/ c |>\n<| c |>\nI added a version that works with multiple zeros in the array.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |x|\n    next if x ==\
    \ 0\n    l.each do |y|\n      l.each do |z|\n        return true if x + y + z\
    \ == 0\n      end\n    end\n  end\n  return false\nend", "  l.each_with_index\
    \ do |x, i|\n    next if i == 0\n    l.each_with_index do |y, j|\n      next if\
    \ j == 0\n      l.each_with_index do |z, k|\n        next if k == 0\n        next\
    \ if x + y + z == 0\n        return false\n      end\n    end\n  end\n  true\n\
    end", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k && x + y + z == 0\n    \
    \  end\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ your solution, but I believe it can be optimized further. For example, you can\
    \ avoid the inner loops by using [Array#permutation](http://ruby-doc.org/core-2.3.0/Array.html#method-i-permutation)\
    \ on the input array. Also, you could avoid the inner loops by using [Array#combination](http://ruby-doc.org/core-2.3.0/Array.html#method-i-combination)\
    \ on the input array.\n<|/ c |>\n<| c |>\nI agree with you on both counts. I did\
    \ try and optimize it further, but my brain was fried and I couldn't come up with\
    \ anything better. I'll try and update my answer with my latest attempt.\n<|/\
    \ c |>\n<| c |>\nI updated my answer with my latest attempt, but it's still not\
    \ as fast as I'd like.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI believe this can\
    \ be done in O(n^3) time using recursion. \n<code>", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x+y+z == 0\n      end\n\
    \    end\n  end\n  false\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution will\
    \ take O(n^3) time, which is very inefficient.\n<|/ c |>\n<| c |>\n: I agree.\
    \ But the OP asked for a solution that would take O(n) time.\n<|/ c |>\n<| c |>\n\
    : I added a solution that would take O(n) time.\n<|/ c |>\n<| c |>\n: I added\
    \ a solution that would take O(n) time.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ that would take O(n) time.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        if i != j && j != k && k != i && x + y + z == 0\n       \
    \   return true\n        end\n      end\n    end\n  end\n  false\nend", "  l.each\
    \ do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if x + y\
    \ + z == 0\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if there are more than three elements that sum\
    \ to zero.\n<|/ c |>\n<| c |>\nIt does work if there are more than three elements\
    \ that sum to zero. Try it yourself.\n<|/ c |>\n<| c |>\nI did. It's not working\
    \ for me in Ruby 1.9.3. Try it yourself.\n<|/ c |>\n<| c |>\nIt works for me in\
    \ Ruby 1.9.3 too. Try it yourself.\n<|/ c |>\n<| c |>\nI see what you mean. My\
    \ mistake. Sorry about that.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.each do |i|\n    next if i == 0\n    l.each do |j|\n      next if j == 0\n\
    \      l.each do |k|\n        next if k == 0\n        return true if i + j + k\
    \ == 0\n      end\n    end\n  end\n  false\nend", "  l.sort!\n  l.each_cons(3).all?\
    \ { |a,b,c| a + b + c == 0 }\nend", "  l.each do |x|\n    l.each do |y|\n    \
    \  l.each do |z|\n        return true if x+y+z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        if i != j && j != k && z == x + y\
    \ + z\n          return false\n        end\n      end\n    end\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1,\
    \ 1, 1]`\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code accordingly.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each do |i|\n    l.each do |j|\n   \
    \   l.each do |k|\n        return false if i != j && i != k && j != k\n      end\n\
    \    end\n  end\n  true\nend", "  l.each_with_index do |x, i|\n    next if i ==\
    \ 0\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n    \
    \    return true if x + y + z == 0 && i != j && i != k && j != k\n      end\n\
    \    end\n  end\n  false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each\
    \ do |z|\n        return true if x+y+z == 0\n      end\n    end\n  end\n  return\
    \ false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n    \
    \    return true if x + y + z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.each do |x|\n    next if x == 0\n    l.each do |y|\n      next if y\
    \ == 0\n      l.each do |z|\n        next if z == 0 || x + y + z == 0\n      \
    \  break\n      end\n      break\n    end\n    break\n  end\n  l.size == 3\nend",
  "  l.each_with_index do |e, i|\n    next if i == 0\n    l.each_with_index do |e2,\
    \ j|\n      next if j == i\n      l.each_with_index do |e3, k|\n        next if\
    \ k == j\n        l.each_with_index do |e4, l|\n          next if l == k\n   \
    \       l.each_with_index do |e5, m|\n            next if m == l\n           \
    \ l.each_with_index do |e6, n|\n              next if n == m\n              l.each_with_index\
    \ do |e7, o|\n                next if o == n\n                l.each_with_index\
    \ do |e8, p|\n                  next if p == o\n                  l.each_with_index\
    \ do |e9, q|\n                    next if q == p\n                    l.each_with_index\
    \ do |e10, r|\n                      next if r == q\n                      l.each_with_index\
    \ do |e11, s|\n                        next if s == r\n                      \
    \  l.each_with_index do |e12, t|\n                          next if t == s\n \
    \                         l.each_with_index do |e13, u|\n                    \
    \        next if u == t\n                            l.each_with_index do |e14,\
    \ v|\n                              next if v == u\n                         \
    \     l.each_with_index do |e15, w|\n                                next if w\
    \ == v\n                                l.each_with_index do |e16, x|\n      \
    \                            next if x == w\n                                \
    \  l.each_with_index do |e17, y|\n                                    next if\
    \ y == x\n                                    l.each_with_index do |e18, z|\n\
    \                                      next if z == y\n                      \
    \                l.each_with_index do |e19, a|\n                             \
    \           next if a == z\n                                        l.each_with_index\
    \ do |e20, b|\n                                          next if b == a\n    \
    \                                      l.each_with_index do |e21, c|\n       \
    \                                     next if c == b\n                       \
    \                     l.each_with_index do |e22, d|\n                        \
    \                      next if d == c\n                                      \
    \        l.each_with_index do |e23, e|\n                                     \
    \           next if e == d\n                                                l.each_with_index\
    \ do |e24, f|\n                                                  next if f ==\
    \ e\n                                                  l.each_with_index do |e25,\
    \ g|\n                                                    next if g == f\n   \
    \                                                 l.each_with_index do |e26, h|\n\
    \                                                      next if h == g\n      \
    \                                                l.each_with_index do |e27, i|\n\
    \                                                        next if i == h\n    \
    \                                                    l.each_with_index do |e28,\
    \ j|\n", "  l.sort!\n  l.each_cons(3).any? { |a| a.inject(:+) == 0 }\nend", " \
    \ l.sort!\n  return l.inject(true) do |sum, el|\n    sum && el + el == sum\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if\
    \ there are two elements that sum to zero, e.g. `[1,2,-3,4]`\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it.\n<|/ c |>\n<| c |>\nI added a more efficient\
    \ solution that doesn't require sorting.\n<|/ c |>\n<| c |>\nI added a more efficient\
    \ solution that doesn't require sorting.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i != j && j != k && z != 0 && x == y + z\n\
    \      end\n    end\n  end\n  true\nend", "  l.each_with_index do |x, i|\n   \
    \ l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ true if i == j && j == k && x + y + z == 0\n      end\n    end\n  end\n  false\n\
    end", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x == y && y == z && z == 0\n      end\n  \
    \  end\n  end\n  return false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        if i == j && j == k &&\
    \ z == 0\n          return true\n        end\n      end\n    end\n  end\n  false\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are multiple\
    \ triplets that sum to zero.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting. Try it yourself.\n<|/ c |>\n<| c |>\nI tested it myself. It doesn't\
    \ work. Try it yourself. It returns false for [1, 3, -2, 1] and true for [1, 2,\
    \ 3, 7].\n<|/ c |>\n<| c |>\nI tested it myself. It returns false for [1, 3, -2,\
    \ 1] and true for [1, 2, 3, 7].\n<|/ c |>\n<| c |>\nI tested it myself. It returns\
    \ false for [1, 3, -2, 1] and true for [1, 2, 3, 7].\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n    \
    \    return true if x + y + z == 0;\n      end\n    end\n  end\n  return false;\n\
    end\n</cell>\n<cell>", "  l.each_with_index do |e, i|\n    l.slice!(0, i+1)\n\
    \    l.slice!(0, i+1)\n    l.slice!(0, i+1)\n    break if l.uniq.size == 3\n \
    \ end\n  l.uniq.size == 3\nend\n</code>\n<|/ a |>\n<| c |>\nThis fails for `triples_sum_to_zero.call([-1,\
    \ 1, 1])`\n<|/ c |>\n<| c |>\nYes, I didn't consider negative numbers. I added\
    \ a check for that.\n<|/ c |>\n<| c |>\nI added a version that doesn't use slice!\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't use slice!\n<|/ c |>\n<| c |>\n\
    I added a version that doesn't use slice!\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n   \
    \   l.each_with_index do |z, k|\n        return false if i == j && j == k && x\
    \ == y\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis is not the right solution. Try it out with [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,",
  "  l.sort!\n  return l.inject(true) do |sum, el|\n    sum && el == (sum + el)\n\
    \  end\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n     \
    \   return true if x+y+z == 0\n      end\n    end\n  end\n  return false\nend",
  "  l.each_with_index do |e, i|\n    l.each_with_index do |e2, j|\n      l.each_with_index\
    \ do |e3, k|\n        return true if e + e2 + e3 == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n   \
    \     return true if i + j + k == 0\n      end\n    end\n  end\n  return false\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not an answer, but a comment\
    \ on another answer. Comments are for requesting clarification, not for providing\
    \ answers. Please delete this answer and post it as a comment instead.\n<|/ c\
    \ |>\n<| c |>\nI agree with you. I'm new here and I didn't know that comments\
    \ aren't for answers. I'll delete this answer as soon as I can.\n<|/ c |>\n<|\
    \ c |>\nI deleted my comment. Thanks for your help.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n   \
    \   l.each_with_index do |z, k|\n        if i == j && j == k && z == 0 then\n\
    \          return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x == y && y == z && z == 0\n      end\n  \
    \  end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ solution doesn't work for `[1, 1, 1]`\n<|/ c |>\n<| c |>\nIt works for me. `triples_sum_to_zero.call([1,\
    \ 1, 1])` returns `true`\n<|/ c |>\n<| c |>\nI tested it on `[1, 1, 1]` and the\
    \ result is `false`\n<|/ c |>\n<| c |>\nI tested it on `[1, 1, 1]` and the result\
    \ is `true`\n<|/ c |>\n<| c |>\nI tested it on `[1, 1, 1]` and the result is `false`\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        if i + j + k == 0 \n          return true\n    \
    \    end\n      end\n    end\n  end\n  return false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if i == j && j == k && x + y + z == 0\n      end\n    end\n\
    \  end\n  false\nend", "  l.each_with_index do |e, i|\n    next if i == 0\n  \
    \  l.each_with_index do |e2, j|\n      next if j == 0\n      l.each_with_index\
    \ do |e3, k|\n        return true if e + e2 + e3 == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return false if i == j && j == k &&\
    \ z == 0\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1, 1, 1]`.\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1, 1, 1]`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `[1, 1, 1]`.\n<|/ c |>\n<| a |>\n\
    <code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index do\
    \ |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x+y+z == 0 and i !=\
    \ j and i != k and j != k\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |n, i|\n    next if i == 0\n    l.each_with_index do |m, j|\n      l.each_with_index\
    \ do |l, k|\n        return true if n == l + m + k\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return false if i == j && j == k &&\
    \ z == 0\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI didn't downvote, but this doesn't answer the question. OP wants to\
    \ know if there are three distinct elements in the array that sum to zero.\n<|/\
    \ c |>\n<| c |>\nI didn't downvote either, but this doesn't answer the question.\
    \ OP wants to know if there are three distinct elements in the array that sum\
    \ to zero.\n<|/ c |>\n<| c |>\nI didn't downvote either, but this doesn't answer\
    \ the question. OP wants to know if there are three distinct elements in the array\
    \ that sum to zero.\n<|/ c |>\n<| c |>\nI didn't downvote either, but this doesn't\
    \ answer the question. OP wants to know if there are three distinct elements in\
    \ the array that sum to zero.\n<|/ c |>\n<| c |>\nI didn't downvote either, but\
    \ this doesn't answer the question. OP wants to know if there are three distinct\
    \ elements in the array that sum to zero.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  l.each_with_index do |e, i|\n    next if i == 0\n    l.each_with_index\
    \ do |e2, j|\n      next if j == 0\n      l.each_with_index do |e3, k|\n     \
    \   next if k == 0\n        l.each_with_index do |e4, l|\n          next if l\
    \ == 0\n          l.each_with_index do |e5, m|\n            next if m == 0\n \
    \           return false if e + e2 + e3 + e4 + e5 == 0\n          end\n      \
    \  end\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThis is not the most efficient solution. `each_with_index` will iterate\
    \ over the array three times. A better solution would be to iterate over the array\
    \ only once.\n<|/ c |>\n<| c |>\nI agree. I've added a more efficient solution.\n\
    <|/ c |>\n<| c |>\nI believe that your solution is still not efficient enough.\
    \ Try `triples_sum_to_zero.call([-1, 1, -1, 1, 1])`. It returns `true` even though\
    \ there are three distinct elements that sum to zero.\n<|/ c |>\n<| c |>\nYou're\
    \ right. I missed that case. I've added a more efficient solution.\n<|/ c |>\n\
    <| c |>\nI believe that your solution is still not efficient enough. Try `triples_sum_to_zero.call([-1,\
    \ 1, -1, 1, 1])`. It returns `true` even though there are three distinct elements\
    \ that sum to zero.\n<|/ c |>\n<| a tags=ruby |>\nHere's a solution that uses\
    \ Enumerable#slice_when:\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x + y +\
    \ z == 0 && i != j && j != k && k != i\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis solution is O(n^3), which is\
    \ very inefficient.\n<|/ c |>\n<| c |>\nI agree, it is inefficient, but I didn't\
    \ want to write an O(n^3) solution, since I didn't want to get into algorithmic\
    \ complexity theory, and I didn't want to get into Ruby syntax and semantics.\n\
    <|/ c |>\n<| c |>\nI agree that it's inefficient, but I didn't want to write an\
    \ O(n^3) solution, since I didn't want to get into algorithmic complexity theory,\
    \ and I didn't want to get into Ruby syntax and semantics. I did write an O(n^2)\
    \ solution, though.\n<|/ c |>\n<| c |>\nI agree that it's inefficient, but I didn't\
    \ want to write an O(n^3) solution, since I didn't want to get into algorithmic\
    \ complexity theory, and I didn't want to get into Ruby syntax and semantics.\
    \ I did write an O(n^2) solution, though.\n<|/ c |>\n<| c |>\nI agree that it's\
    \ inefficient, but I didn't want to write an O(n^3) solution, since I didn't want\
    \ to get into algorithmic complexity theory, and I didn't want to get into Ruby\
    \ syntax and semantics. I did write an O(n^2) solution, though.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  l.each do |x|\n    l.each do |y|\n      l.each\
    \ do |z|\n        return true if x + y + z == 0\n      end\n    end\n  end\n \
    \ false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return false if i != j && j != k &&\
    \ k != i && x + y + z == 0;\n      end\n    end\n  end\n  true\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    l.each_with_index do |e2, j|\n      next\
    \ if j == i\n      l.each_with_index do |e3, k|\n        next if k == j\n    \
    \    return true if e + e2 + e3 == 0\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1, 1, 1]`.\
    \ It returns `true`, but should return `false`.\n<|/ c |>\n<| c |>\nI edited my\
    \ answer to include a solution that works with your test cases. I tested it and\
    \ it works.\n<|/ c |>\n<| c |>\nYour solution doesn't work for the test case `[1,\
    \ 1, 1]`. Your code returns `true`, but should return `false`.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to include a solution that works with your test cases.\
    \ I tested it and it works.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.each_cons(3).any? { |a,b,c|\
    \ b == 0 and c == 0 }\nend", "  l.each do |i|\n    l.each do |j|\n      l.each\
    \ do |k|\n        return true if i + j + k == 0\n      end\n    end\n  end\n \
    \ false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x == y && y == z &&\
    \ z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index do |x,\
    \ i|\n    next if i == 0\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return true if x == y && y == z && z == 0\n      end\n  \
    \  end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work\
    \ if there are more than three elements that sum to zero.\n<|/ c |>\n<| c |>\n\
    It does work. Try it yourself. It returns true for [1,2,3,4,5,6,7,8,9,0] and false\
    \ for [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n<|/ c |>\n<| c |>\nI didn't say it\
    \ didn't, I said it didn't work. Try it yourself. It returns true for [1,2,3,4,5,6,7,8,9,0]\
    \ and false for [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I'll fix my answer.\n<|/ c |>\n<| c |>\nI fixed my answer. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each\
    \ do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if x + y\
    \ + z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index do\
    \ |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x+y+z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k && z == 0\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't work if there are multiple triplets whose sum is zero.\n\
    <|/ c |>\n<| c |>\nIt does work if there are multiple triplets whose sum is zero.\
    \ Try it out yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if there are multiple\
    \ triplets whose sum is zero. Try it out yourself. It returns true for [1,2,3,4,5,6,7,8,9,10],\
    \ which is not the case for [1,2,3,4,5,6,7,8,9,10,0]\n<|/ c |>\n<| c |>\nIt returns\
    \ true for [1,2,3,4,5,6,7,8,9,10], which is not the case for [1,2,3,4,5,6,7,8,9,10,0]\n\
    <|/ c |>\n<| c |>\nIt returns true for [1,2,3,4,5,6,7,8,9,10], which is not the\
    \ case for [1,2,3,4,5,6,7,8,9,10,0]\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x+y+z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your\
    \ solution, but I believe it can be optimized a little bit more. For example,\
    \ `return true if x+y+z == 0 && i != j && j != k && k != i` can be replaced with\
    \ `return true if x+y+z == 0 && i != j && j != k && k != i && i != j && j != k\
    \ && k != i`. Also, `return true if x+y+z == 0 && i != j && j != k && k != i`\
    \ can be replaced with `return true if x+y+z == 0 && i != j && j != k && k !=\
    \ i && i != j && j != k && k != i && i != j && j != k && k != i`. And so on...\n\
    <|/ c |>\n<| c |>\nI agree with you, that is a good optimization. I'll edit my\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI believe that your solution will run\
    \ faster than mine. I'll post my solution shortly.\n<|/ c |>\n<| c |>\nI believe\
    \ that your solution will run faster than mine. I'll post my solution shortly.\n\
    <|/ c |>\n<| c |>\nI believe that your solution will run faster than mine. I'll\
    \ post my solution shortly.\n<|/ c |>\n<| a dscore=1 |>\nI believe that my solution\
    \ will run faster than the one provided by and.\n<code>", "  l.sort!\n  return\
    \ l.inject(true) do |t, n|\n    t && t[n] == 0\n  end\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each do |x|\n    next if x.zero?\n    l.each do |y|\n   \
    \   next if y.zero?\n      l.each do |z|\n        return true if x + y + z ==\
    \ 0\n      end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis doesn't work if there are multiple zeroes in a row. For example,\
    \ `[0, 0, 0]` returns `true`, but `[0, 0, 1]` returns `false`.\n<|/ c |>\n<| c\
    \ |>\n: Yes, I noticed that after I posted my answer. I've updated my answer to\
    \ fix that problem.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x + y + z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend", "  l.each_with_index do |e, i|\n    l.each_with_index\
    \ do |f, j|\n      l.each_with_index do |g, k|\n        return true if e + f +\
    \ g == 0 && i != j && i != k && j != k\n      end\n    end\n  end\n  false\nend",
  "  l.sort!\n  l.each_cons(3).any? { |a,b,c| a + b + c == 0 }\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return false if i == j && j == k\n        return false if i == j && j\
    \ != k\n        return false if i != j && j == k\n        return false if i !=\
    \ j && j != k\n      end\n    end\n  end\n  true\nend", "  l.each_with_index do\
    \ |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n   \
    \     next if i == j && j == k\n        return false if i == j && j != k\n   \
    \     return false if i != j && j == k\n        return false if i != j && j !=\
    \ k\n      end\n    end\n  end\n  true\nend", "  l.each_with_index do |x, i|\n\
    \    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ true if x + y + z == 0 && i != j && j != k && k != i\n      end\n    end\n \
    \ end\n  false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n\
    \        return true if x+y+z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return\
    \ true if x + y + z == 0\n      end\n    end\n  end\n  return false\nend", " \
    \ l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k\n        return false if\
    \ i == j && j == k\n        return false if i == j && j == k\n      end\n    end\n\
    \  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are multiple triplets that sum to zero.\n<|/ c |>\n<| c |>\nI\
    \ added a solution that works with multiple triplets that sum to zero.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if there are multiple triplets that sum to zero.\n\
    <|/ c |>\n<| c |>\nI added a solution that works with multiple triplets that sum\
    \ to zero.\n<|/ c |>\n<| c |>\nThis doesn't work if there are multiple triplets\
    \ that sum to zero.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return false if i == j && j == k && x + y + z == 0\n      end\n    end\n\
    \  end\n  true\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do\
    \ |y, j|\n      l.each_with_index do |z, k|\n        return true if x+y+z == 0\
    \ && i != j && j != k && k != i\n      end\n    end\n  end\n  false\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis doesn't work. Try it with `[1, 1, 1]`.\n<|/\
    \ c |>\n<| c |>\n: Thanks for pointing that out. I've updated the answer to account\
    \ for that case.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I've updated\
    \ the answer to account for that case.\n<|/ c |>\n<| c |>\n: Thanks for pointing\
    \ that out. I've updated the answer to account for that case.\n<|/ c |>\n<| c\
    \ |>\n: Thanks for pointing that out. I've updated the answer to account for that\
    \ case.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each do |x|\n    next if x.to_s.to_i\
    \ == 0\n    next if x.to_s.to_i == 1\n    next if x.to_s.to_i == 2\n    break\n\
    \  end\n  l.size == 3\nend", "  l.each_with_index do |n, i|\n    next if i ==\
    \ 0\n    l.each_with_index do |m, j|\n      l.each_with_index do |n, k|\n    \
    \    return false if n == m + k\n      end\n    end\n  end\n  true\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis code doesn't work if there are multiple triplets\
    \ that sum to zero.\n<|/ c |>\n<| c |>\nI believe it does. I tested it on `[1,\
    \ 2, 3, 7, -4, -5, -6, -7, -8]` and it returned `true`.\n<|/ c |>\n<| c |>\nI\
    \ believe it does. I tested it on `[1, 2, 3, 7, -4, -5, -6, -7, -8]` and it returned\
    \ `true`.\n<|/ c |>\n<| c |>\nI believe it does. I tested it on `[1, 2, 3, 7,\
    \ -4, -5, -6, -7, -8]` and it returned `true`.\n<|/ c |>\n<| c |>\nI believe it\
    \ does. I tested it on `[1, 2, 3, 7, -4, -5, -6, -7, -8]` and it returned `true`.\n\
    <|/ c |>\n<| a |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k && x + y + z == 0\n      end\n    end\n  end\n  true\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n   \
    \     return true if i+j+k == 0\n      end\n    end\n  end\n  false\nend", " \
    \ l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k && x + y + z == 0\n    \
    \  end\n    end\n  end\n  true\nend", "  l.each do |i|\n    l.each do |j|\n  \
    \    l.each do |k|\n        return false if i + j + k == 0\n      end\n    end\n\
    \  end\n  true\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do\
    \ |y, j|\n      l.each_with_index do |z, k|\n        return true if x == y &&\
    \ y == z && z == 0\n      end\n    end\n  end\n  false\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  l.each_cons(3).all? { |a,b,c| a + b + c\
    \ == 0 }\nend", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x+y+z == 0 && i !=\
    \ j && j != k && k != i\n      end\n    end\n  end\n  false\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis solution doesn't work if there are multiple triplets\
    \ that sum to zero. For example, `triples_sum_to_zero.call([-4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -", "  l.each do |i|\n    l.each do\
    \ |j|\n      l.each do |k|\n        if i + j + k == 0 then return false end\n\
    \      end\n    end\n  end\n  return true\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x + y + z == 0\n      end\n\
    \    end\n  end\n  return false\nend", "  l.each do |i|\n    l.each do |j|\n \
    \     l.each do |k|\n        return false if i + j + k == 0\n      end\n    end\n\
    \  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", " \
    \ l.each_with_index do |e, i|\n    l.delete_at(i) if e == 0\n    break if l.length\
    \ < 3\n  end\n  l.length == 0\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do this without looping\
    \ through the array twice. Maybe with some clever use of inject or each_with_index?\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't loop through the array twice.\
    \ Hope it helps.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to do this without looping through the array twice. Maybe with some\
    \ clever use of inject or each_with_index?\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't loop through the array twice. Hope it helps.\n<|/ c |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do this without looping\
    \ through the array twice. Maybe with some clever use of inject or each_with_index?\n\
    <|/ c |>\n<| a |>\n<code>", "  l.each_with_index do |x, i|\n    next if i == 0\n\
    \    l.each_with_index do |y, j|\n      next if j == i\n      l.each_with_index\
    \ do |z, k|\n        return true if z == 0 && k == j && y == i\n      end\n  \
    \  end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ is not the right solution. Try `triples_sum_to_zero.call([-1, 1, 0])`\n<|/ c\
    \ |>\n<| c |>\nI agree, that's why I said \"the right solution\". I just wanted\
    \ to point out that there may be a better solution that doesn't require iterating\
    \ over the array three times. I guess I should have said \"the right solution\"\
    \ instead of \"the best solution\".\n<|/ c |>\n<| c |>\nI agree that there may\
    \ be a better solution that doesn't require iterating over the array three times.\
    \ But I wanted to point out that there may be a better solution that doesn't require\
    \ iterating over the array three times. I guess I should have said \"the right\
    \ solution\" instead of \"the best solution\".\n<|/ c |>\n<| c |>\nI agree that\
    \ there may be a better solution that doesn't require iterating over the array\
    \ three times. But I wanted to point out that there may be a better solution that\
    \ doesn't require iterating over the array three times. I guess I should have\
    \ said \"the right solution\" instead of \"the best solution\".\n<|/ c |>\n<|\
    \ c |>\nI agree that there may be a better solution that doesn't require iterating\
    \ over the array three times. But I wanted to point out that there may be a better\
    \ solution that doesn't require iterating over the array three times. I guess\
    \ I should have said \"the right solution\" instead of \"the best solution\".\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |x|\n    next if x ==\
    \ 0\n    l.each do |y|\n      l.each do |z|\n        return true if x + y + z\
    \ == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index do |x,\
    \ i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n   \
    \     return true if x == y && y == z && z == 0\n      end\n    end\n  end\n \
    \ return false\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis code doesn't work.\
    \ Try it with `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,\
    \ 1, 1]`. It returns `true`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with\
    \ `[1, 1, 1]`. It returns `true`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it\
    \ with `[1, 1, 1]`. It returns `true`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `[1, 1, 1]`. It returns `true`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return true if\
    \ i + j + k == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    l.each_with_index do |e2, j|\n      next\
    \ if j == 0\n      l.each_with_index do |e3, k|\n        return true if e + e2\
    \ + e3 == 0\n      end\n    end\n  end\n  false\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x + y + z == 0\n      end\n\
    \    end\n  end\n  return false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        if i == j && j == k &&\
    \ x + y + z == 0\n          return true\n        end\n      end\n    end\n  end\n\
    \  return false\nend", "  l.each_with_index do |x, i|\n    next if i == 0\n  \
    \  next if l[i - 1] == x\n    next if l[i - 1] + x == 0\n    next if l[i - 1]\
    \ + x + x == 0\n    l.delete_at(i)\n    break\n  end\n  l.empty?\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis code doesn't work if there are multiple triplets that\
    \ sum to zero.\n<|/ c |>\n<| c |>\nI added a version that works with multiple\
    \ triplets that sum to zero.\n<|/ c |>\n<| c |>\nThis code doesn't work if there\
    \ are multiple triplets that sum to zero.\n<|/ c |>\n<| c |>\nI added a version\
    \ that works with multiple triplets that sum to zero.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n    \
    \    return true if x + y + z == 0;\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you have a negative\
    \ number in the array. `triples_sum_to_zero.call([-1, -2, 3, -5, -7, -9, -12,\
    \ -15, -17, -21])` returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nI didn't\
    \ think about negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| c\
    \ |>\nI added a solution that doesn't require negative numbers. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require negative\
    \ numbers. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |e, i|\n    next if i == 0\n    l.each_with_index do |e2, j|\n      next\
    \ if j == 0\n      l.each_with_index do |e3, k|\n        next if k == 0\n    \
    \    next if e + e2 + e3 == 0\n        return false if k > j\n      end\n    end\n\
    \  end\n  true\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n\
    \        return true if i != j && i != k && j != k\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |x, i|\n    next if i == 0\n    l.each_with_index\
    \ do |y, j|\n      next if j == i\n      l.each_with_index do |z, k|\n       \
    \ next if k == j\n        next if z == x + y\n        l.delete_at(i)\n       \
    \ l.delete_at(j)\n        l.delete_at(k)\n        break\n      end\n    end\n\
    \  end\n  l.size == 0\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like\
    \ your solution, however it fails on `[1,2,3]` - it returns `false` instead of\
    \ `true`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now\
    \ it works on all cases.\n<|/ c |>\n<| c |>\nI like your solution, however it\
    \ fails on `[1,2,3]` - it returns `false` instead of `true`.\n<|/ c |>\n<| c |>\n\
    I fixed the bug, thanks for pointing it out. Now it works on all cases.\n<|/ c\
    \ |>\n<| c |>\nI like your solution, however it fails on `[1,2,3]` - it returns\
    \ `false` instead of `true`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  return false\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k && z == 0\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\nThis solution is O(n^3) which is very inefficient.\n\
    <|/ c |>\n<| c |>\nI agree, this is O(n^3). My solution is O(n^2) but is more\
    \ elegant.\n<|/ c |>\n<| c |>\nThe OP asked for O(n) solution. Your solution is\
    \ O(n^2). Your solution is O(n^3) but is more elegant.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. I was just pointing out that my solution is O(n^2) but is more elegant.\n\
    <|/ c |>\n<| c |>\nI agree with you. I was just pointing out that my solution\
    \ is O(n^2) but is more elegant.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each\
    \ do |i|\n    l.each do |j|\n      l.each do |k|\n        next if i == j && j\
    \ == k\n        return false if i + j + k == 0\n      end\n    end\n  end\n  true\n\
    end", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k && z == 0\n      end\n \
    \   end\n  end\n  true\nend", "  l.each do |i|\n    l.each do |j|\n      l.each\
    \ do |k|\n        return true if i + j + k == 0\n      end\n    end\n  end\n \
    \ false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n    \
    \    return true if x + y + z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return\
    \ true if i != j && i != k && j != k\n      end\n    end\n  end\n  false\nend",
  "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  return false\nend", "  l.each do\
    \ |i|\n    l.each do |j|\n      l.each do |k|\n        if i + j + k == 0 then\
    \ return false end\n      end\n    end\n  end\n  return true\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x == y && y == z && z == 0\n      end\n    end\n  end\n\
    \  false\nend", "  l.each_with_index do |e, i|\n    next if i == 0\n    l.each_with_index\
    \ do |e2, j|\n      next if j == 0\n      l.each_with_index do |e3, k|\n     \
    \   return true if e + e2 + e3 == 0\n      end\n    end\n  end\n  false\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nI like your solution. Can\
    \ you explain how it works?\n<|/ c |>\n<| c |>\nI added some explanation.\n<|/\
    \ c |>\n<| c |>\nI like your solution. Can you explain how it works?\n<|/ c |>\n\
    <| c |>\nI added some explanation.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  l.each_with_index do |e, i|\n    l.each_with_index do |e2, j|\n\
    \      l.each_with_index do |e3, k|\n        return true if e + e2 + e3 == 0\n\
    \      end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like this solution, but I wonder if it can be done without nested loops.\
    \ I suspect it can, but I'm curious to see how it can be done without nested loops.\n\
    <|/ c |>\n<| c |>\nI added a solution without nested loops.\n<|/ c |>\n<| c |>\n\
    I added a solution without nested loops.\n<|/ c |>\n<| c |>\nI added a solution\
    \ without nested loops.\n<|/ c |>\n<| c |>\nI added a solution without nested\
    \ loops.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x + y + z == 0\n      end\n\
    \    end\n  end\n  return false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x + y +\
    \ z == 0 && i != j && j != k && k != i\n      end\n    end\n  end\n  false\nend",
  "  l.each_with_index do |e, i|\n    next if i == 0\n    l.each_with_index do |e2,\
    \ j|\n      next if j == 0\n      l.each_with_index do |e3, k|\n        return\
    \ true if e + e2 + e3 == 0\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        if i != j && j != k && k != i && x + y + z == 0 \n          return true\n\
    \        end\n      end\n    end\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if the array is `[1, 1, 1]`.\n<|/ c |>\n<| c\
    \ |>\nIt does work. Try it out. `[1, 1, 1]` returns `true` as expected.\n<|/ c\
    \ |>\n<| c |>\nIt does work. Try it out. `[1, 1, 1]` returns `true` as expected.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it out. `[1, 1, 1]` returns `true` as expected.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it out. `[1, 1, 1]` returns `true` as expected.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if i == j\
    \ && j == k && x + y + z == 0\n      end\n    end\n  end\n  false\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to do it without looping three times. I wonder if there is a way to\
    \ do it with recursion.\n<|/ c |>\n<| c |>\nI added a recursive solution that\
    \ doesn't use loops. I hope it helps.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without looping three times. I wonder\
    \ if there is a way to do it with recursion.\n<|/ c |>\n<| c |>\nI added a recursive\
    \ solution that doesn't use loops. I hope it helps.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without looping three\
    \ times. I wonder if there is a way to do it with recursion.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n\
    \      l.each_with_index do |z, k|\n        return true if x == y && y == z &&\
    \ z == 0\n      end\n    end\n  end\n  false\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n     \
    \   return true if x + y + z == 0\n      end\n    end\n  end\n  false\nend", " \
    \ l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        if i + j + k\
    \ == 0 then return false end\n      end\n    end\n  end\n  true\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis solution will take O(n^3) time complexity.\
    \ How about O(n^2) time complexity?\n<|/ c |>\n<| c |>\n: I believe that this\
    \ is O(n^2) time complexity. `each_cons` will iterate over each element in the\
    \ array and will stop when it reaches the length of the array. `each_cons` will\
    \ iterate over each element in the array and will stop when it reaches the length\
    \ of the array. `each_cons` will iterate over each element in the array and will\
    \ stop when it reaches the length of the array. `each_cons` will iterate over\
    \ each element in the array and will stop when it reaches the length of the array.\
    \ `each_cons` will iterate over each element in the array and will stop when it\
    \ reaches the length of the array. `each_cons` will iterate over each element\
    \ in the array and will stop when it reaches the length of the array. `each_cons`\
    \ will iterate over each element in the array and will stop when it reaches the\
    \ length of the array. `each_cons` will iterate over each element in the array\
    \ and will stop when it reaches the length of the array. `each_cons` will iterate\
    \ over each element in the array and will stop when it reaches the length of the\
    \ array. `each_cons` will iterate over each element in the array and will stop\
    \ when it reaches the length of the array. `each_cons` will iterate over each\
    \ element in the array and will stop when it reaches the length of the array.\
    \ `each_cons` will iterate over each element in the array and will stop when it\
    \ reaches the length of the array. `each_cons` will iterate over each element\
    \ in the array and will stop when it reaches the length of the array. `each_cons`\
    \ will iterate over each element in the array and will stop when it reaches the\
    \ length of the array. `each_cons` will iterate over each element in the array\
    \ and will stop when it reaches the length of the array. `each_cons` will iterate\
    \ over each element in the array and will stop when it reaches the length of the\
    \ array. `each_cons` will iterate over each element in the array and will stop\
    \ when it reaches the length of the array. `each_cons` will iterate over each\
    \ element in the array and will stop when it reaches the length of the array.\
    \ `each_cons` will iterate over each element in the array and will stop when it\
    \ reaches the length of the array. `each_cons` will iterate over each element\
    \ in the array and will stop when it reaches the length of the array. `each_cons`\
    \ will ", "  l.sort!\n  l.each_cons(3).any? { |a,b,c| a + b + c == 0 }\nend",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if (x + y + z == 0)\n      end\n    end\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if\
    \ the array is `[1,2,3]`. It returns `true` when it should return `false`.\n<|/\
    \ c |>\n<| c |>\nI added a solution that doesn't require the array to be sorted.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the array is `[1,2,3]`. It returns `true`\
    \ when it should return `false`.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require the array to be sorted.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n        return true if\
    \ x + y + z == 0\n      end\n    end\n  end\n  return false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        if i != j && j != k && k != i && x + y + z == 0 \n          return true\n\
    \        end\n      end\n    end\n  end\n  false\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k && x == y\n      end\n    end\n  end\n  true\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return false if i == j && j == k && x + y + z == 0\n      end\n    end\n\
    \  end\n  true\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
