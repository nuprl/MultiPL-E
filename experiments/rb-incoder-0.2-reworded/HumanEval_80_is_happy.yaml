name: HumanEval_80_is_happy
language: rb
prompt: "# You are given a string s.\n# Your task is to check if the string is haprb\
  \ or not.\n# A string is haprb if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n# For example:\n# >>> is_happy.call(a)\n# false\n# >>> is_happy.call(aa)\n\
  # false\n# >>> is_happy.call(abcd)\n# true\n# >>> is_happy.call(aabb)\n# false\n\
  # >>> is_happy.call(adb)\n# true\n# >>> is_happy.call(xyy)\n# false\ndef is_happy(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n\
  \    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"\
  ))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"\
  abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true,\
  \ candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n \
  \   assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"\
  iopaxioi\"))\n  end\nend\n"
completions: ["  s.each_char.with_index.all? do |char, i|\n    char == char.next\n\
    \  end\nend", "  s.chars.each_cons(3).all? do |chars|\n    chars.uniq.size ==\
    \ chars.size\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution,\
    \ but I think it would be better to return false instead of throwing an exception.\
    \ Also, `each_cons(3)` will iterate over every 3 letters, not every 3 consecutive\
    \ letters.\n<|/ c |>\n<| c |>\nThanks for your comment. I think it's better to\
    \ return false instead of throwing an exception. Also, `each_cons(3)` will iterate\
    \ over every 3 letters, not every 3 consecutive letters.\n<|/ c |>\n<| c |>\n\
    Thanks for your comment. I think it's better to return false instead of throwing\
    \ an exception. Also, `each_cons(3)` will iterate over every 3 letters, not every\
    \ 3 consecutive letters.\n<|/ c |>\n<| c |>\nThanks for your comment. I think\
    \ it's better to return false instead of throwing an exception. Also, `each_cons(3)`\
    \ will iterate over every 3 letters, not every 3 consecutive letters.\n<|/ c |>\n\
    <| c |>\nThanks for your comment. I think it's better to return false instead\
    \ of throwing an exception. Also, `each_cons(3)` will iterate over every 3 letters,\
    \ not every 3 consecutive letters.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each_cons(3).all?\
    \ do |c|\n    !c.uniq.empty?\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work. Try it with `\"a\"`, `\"aa\"`, `\"abcd\"`, `\"aabb\"`, `\"\
    adb\"`, `\"xyy\"`.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've updated\
    \ the answer.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `\"a\"`, `\"\
    aa\"`, `\"abcd\"`, `\"aabb\"`, `\"adb\"`, `\"xyy\"`.\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing out. I've updated the answer.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. Try it with `\"a\"`, `\"aa\"`, `\"abcd\"`, `\"aabb\"`, `\"adb\"`, `\"\
    xyy\"`.\n<|/ c |>\n<| a |>\n<code>", "  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[aeiou]/,\
    \ '')\n  s.gsub!(/[aeiou]/, '')\n  s.gsub!(/[ae", "  s.each_char.with_index.all?\
    \ do |char, i|\n    char == char.next\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI believe this would fail for `is_happy.call(\"ab\")` since `char.next`\
    \ will return the next character in the string which is `b`\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I missed that. Thanks for pointing out. I've updated my answer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.each_cons(3).all? { |a,b,c| a\
    \ == b && b == c }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your\
    \ answer. I am not allowed to use any built-in methods. I did try your solution\
    \ and it works but I am not allowed to use any built-in methods. I did try your\
    \ solution and it works but I am not allowed to use any built-in methods. I did\
    \ try your solution and it works but I am not allowed to use any built-in methods.\
    \ I did try your solution and it works but I am not allowed to use any built-in\
    \ methods. I did try your solution and it works but I am not allowed to use any\
    \ built-in methods. I did try your solution and it works but I am not allowed\
    \ to use any built-in methods. I did try your solution and it works but I am not\
    \ allowed to use any built-in methods. I did try your solution and it works but\
    \ I am not allowed to use any built-in methods. I did try your solution and it\
    \ works but I am not allowed to use any built-in methods.\n<|/ c |>\n<| c |>\n\
    I did try your solution and it works but I am not allowed to use any built-in\
    \ methods. I did try your solution and it works but I am not allowed to use any\
    \ built-in methods. I did try your solution and it works but I am not allowed\
    \ to use any built-in methods. I did try your solution and it works but I am not\
    \ allowed to use any built-in methods. I did try your solution and it works but\
    \ I am not allowed to use any built-in methods. I did try your solution and it\
    \ works but I am not allowed to use any built-in methods. I did try your solution\
    \ and it works but I am not allowed to use any built-in methods.\n<|/ c |>\n<|\
    \ c |>\nI did try your solution and it works but I am not allowed to use any built-in\
    \ methods. I did try your solution and it works but I am not allowed to use any\
    \ built-in methods. I did try your solution and it works but I am not allowed\
    \ to use any built-in methods. I did try your solution and it works but I am not\
    \ allowed to use any built-in methods. I did try your solution and it works but\
    \ I am not allowed to use any built-in methods. I did try your solution and it\
    \ works but I am not allowed to use any built-in methods. I did try your solution\
    \ and it works but I am not allowed to use any built-in methods.\n<|/ c |>\n<|\
    \ c |>\nI did try your solution and it works but I am not allowed to use any built-in\
    \ methods. I did try your solution and it works but I am not allowed to use any\
    \ built-in methods. I did try ", "  s.chars.each_with_index do |char,i|\n    if\
    \ char != char.succ\n      return false\n    end\n    if i != 0 && i != s.length\
    \ - 1 && i != s.length - 2 && i != s.length - 3\n      return false\n    end\n\
    \  end\n  return true\nend", "  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(", "  s.chars.each_with_index.all? {|c,i| c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'}\nend", "  s.each_char.with_index.all?\
    \ do |char,i|\n    char == char.next\n  end\nend", "  s.each_char.with_index do\
    \ |char, i|\n    if i % 3 == 0 && i != 0\n      char == s[i - 1]\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `a =\
    \ \"aaa\"`\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. I\
    \ will update my answer with your suggestion.\n<|/ c |>\n<| c |>\nI updated my\
    \ answer. Thanks for pointing out my mistake.\n<|/ c |>\n<| c |>\nThe OP wants\
    \ to know if the string is happy.\n<|/ c |>\n<| c |>\nI updated my answer again.\
    \ Thanks for pointing out my mistake.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ s.chars.each_cons(3).all? { |a,b,c| a == b && b == c }\nend", "  s.chars.each_cons(3).all?\
    \ do |c|\n    seen = Set.new\n    c.each do |c|\n      seen << c\n    end\n  \
    \  seen.length >= 3\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I like your solution, but I think it can be simplified a bit. `s.chars.each_cons(3).all?\
    \ { |c| c.uniq.length >= 3 }` is enough.\n<|/ c |>\n<| c |>\nI agree, thanks.\
    \ I wanted to keep it close to the OP's original code as much as possible.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.each_cons(3).all? do |c|\n    not\
    \ c.uniq.empty?\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each_with_index.all? do |char, i|\n    char == s[i+2]\
    \ && char == s[i+3] && char != s[i+4] && char != s[i+5]\n  end\nend", "  s.chars.each_cons(3).all?\
    \ { |a,b,c| a.chars.uniq.length == 3 && b.chars.uniq.length == 3 && c.chars.uniq.length\
    \ == 3 }\nend", "  s.chars.each_cons(3).all? { |a,b,c| a.eql? b && a.eql? c }\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work. `is_happy.call(\"\
    ab\")` returns `true` but `is_happy.call(\"aa\")` returns `false`.\n<|/ c |>\n\
    <| c |>\nIt does work. `is_happy.call(\"ab\")` returns `false` because `\"ab\"\
    ` is `[\"a\", \"b\", \"c\"]` which contains three consecutive letters `\"a\"`,\
    \ `\"b\"` and `\"c\"`. `\"a\"` and `\"b\"` are distinct and `\"c\"` is distinct.\
    \ `\"aa\"` is `[\"a\", \"a\", \"a\"]` which contains three consecutive letters\
    \ `\"a\"` but `\"a\"` and `\"a\"` are distinct. `\"ab\"` is `[\"a\", \"b\", \"\
    c\"]` which contains three consecutive letters `\"a\"`, `\"b\"` and `\"c\"`. `\"\
    ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"\
    ` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is\
    \ distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct\
    \ and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and\
    \ `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"\
    ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"\
    ` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is\
    \ distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct\
    \ and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and\
    \ `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"\
    ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"\
    ` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is\
    \ distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct\
    \ and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and\
    \ `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"` is distinct and `\"\
    ab\"` is distinct and `\"ac\"` is distinct and `\"ab\"` is distinct and `\"ac\"\
    ` is ", "  s.each_char.with_index.all? do |char, i|\n    char == char.next\n \
    \ end\nend", "  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n \
    \ s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.gsub!(", "  s.chars.each_cons(3).all? do |s|\n    !s.uniq.empty?\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`s.chars.each_cons(3).all? { |s| s.uniq.empty?\
    \ }` would be more concise.\n<|/ c |>\n<| c |>\n`s.chars.each_cons(3).all? { |s|\
    \ s.uniq.empty? }` would be more concise, but `s.chars.each_cons(3).all? { |s|\
    \ s.uniq.size == 1 }` would be more efficient.\n<|/ c |>\n<| c |>\n`s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient, but `s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient.\n<|/ c |>\n<| c |>\n`s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient, but `s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient.\n<|/ c |>\n<| c |>\n`s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient, but `s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == 1 }` would be more efficient.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
