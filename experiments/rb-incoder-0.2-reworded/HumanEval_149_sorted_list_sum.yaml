name: HumanEval_149_sorted_list_sum
language: rb
prompt: "# Write a function that accepts an array of strings as a parameter,\n# deletes\
  \ the strings that have odd lengths from it,\n# and returns the resulted array with\
  \ a sorted order,\n# The array is always an array of strings and never an array\
  \ of numbers,\n# and it may contain duplicates.\n# The order of the array should\
  \ be ascending by length of each word, and you\n# should return the array sorted\
  \ by that rule.\n# If two words have the same length, sort the array alphabetically.\n\
  # The function should return an array of strings in sorted order.\n# You may assume\
  \ that all words will have the same length.\n# For example:\n# >>> list_sort.call([\"\
  aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\"\
  , \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n\
  \    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"\
  aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"\
  school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\"\
  , \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"\
  d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"\
  AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\"\
  , \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"],\
  \ candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"
completions: ["  lst.sort!\n  lst.delete_if{|x| x.length % 2 == 1}\n  lst.sort!\n\
    \  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. I am not allowed to use\
    \ any gems or libraries. I only have to write my own code.\n<|/ c |>\n<| c |>\n\
    I added my own code to the original post. I am not sure how to sort it by length\
    \ and then alphabetically. Thanks.\n<|/ c |>\n<| c |>\nI added my own code to\
    \ the original post. I am not sure how to sort it by length and then alphabetically.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI added my own code to the original post. I am not\
    \ sure how to sort it by length and then alphabetically. Thanks.\n<|/ c |>\n<|\
    \ c |>\nI added my own code to the original post. I am not sure how to sort it\
    \ by length and then alphabetically. Thanks.\n<|/ c |>\n<| a |>\n<code>", "  lst.sort!\n\
    \  lst.delete_if { |x| x.length % 2 != 0 }\n  lst\nend", "  lst.sort!\n  lst.delete_if\
    \ { |x| x.length % 2 != 0 }\n  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", " \
    \ lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\n\
    \  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  lst.sort!\n  lst.group_by{|x|\
    \ x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.delete_if {\
    \ |x| x.length % 2 != 0 }\n  lst\nend", "  lst.sort!\n  lst.map!{|x| x.split(//).sort}\n\
    \  lst.flatten!\n  lst.sort!\n  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort}.flatten\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n\
    \  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n\
    \  lst.map!{|x| x.split(//).sort}\n  lst.flatten!\n  lst\nend", "  lst.sort!\n\
    \  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n\
    \  lst.delete_if{|x| x.length % 2 != 0}\n  lst\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
