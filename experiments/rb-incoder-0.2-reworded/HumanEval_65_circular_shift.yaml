name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.modulo(10).to_s\n  end\nend", "  x = x.to_s\n  shift\
    \ = shift % x.size\n  digits = x.reverse.chars.take(shift)\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  ", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit.modulo(10).to_s\n  end\n\
    end", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit[(s.length + shift.to_i)\
    \ % digit.length]\n  end\nend", "  x = x.to_s\n  shift = shift.to_i\n  return\
    \ x.reverse.chars.drop(shift).join\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit[(s.length\
    \ - shift) % s.length]\n  end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits\
    \ = x.reverse.split(//)\n  digits.reverse!\n  digits[shift].concat(digits[shift\
    \ + 1])\n  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |result, digit|\n    result + ((digit << shift).to_s\
    \ % 10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
