name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.modulo(10).to_s\n  end\nend", "  x = x.to_s\n  shift\
    \ = shift % x.size\n  digits = x.reverse.chars.take(shift)\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  ", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit.modulo(10).to_s\n  end\n\
    end", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit[(s.length + shift.to_i)\
    \ % digit.length]\n  end\nend", "  x = x.to_s\n  shift = shift.to_i\n  return\
    \ x.reverse.chars.drop(shift).join\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit[(s.length\
    \ - shift) % s.length]\n  end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits\
    \ = x.reverse.split(//)\n  digits.reverse!\n  digits[shift].concat(digits[shift\
    \ + 1])\n  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |result, digit|\n    result + ((digit << shift).to_s\
    \ % 10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x = x.to_s\n  shift = shift\
    \ || 0\n  digits = x.reverse.chars.to_a\n  digits[0...shift].concat digits[shift+1..-1]\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit.modulo(10).to_s\n  end\n\
    end", "  x = x.to_s\n  shift = shift.to_i\n  x.reverse! if shift > x.length\n\
    \  x.slice!(0, shift)\n  x.reverse!\n  x.join\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to avoid the temporary string allocation. Maybe something like\
    \ `x.to_s.reverse.chars.take(shift).join` would work?\n<|/ c |>\n<| c |>\nYes,\
    \ that would work. I'll edit the answer to include that.\n<|/ c |>\n<| c |>\n\
    Thanks, I added your suggestion to the answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit[shift..-1]\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n\
    \    result << digit if digit > x % 10\n    result << digit % 10\n    result <<\
    \ digit % 10\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\n\
    I like your solution, but I believe that `circular_shift` should return `nil`\
    \ instead of `\"\"` when the shift is greater than the number of digits. I believe\
    \ that `circular_shift` should return `\"121\"` instead of `\"21\"`.\n<|/ c |>\n\
    <| c |>\nI believe that `circular_shift` should return `\"121\"` instead of `\"\
    21\"` because `circular_shift` should return `\"21\"` when `shift` is greater\
    \ than the number of digits. I believe that `circular_shift` should return `nil`\
    \ instead of `\"\"` when the shift is greater than the number of digits. I believe\
    \ that `circular_shift` should return `\"121\"` instead of `\"21\"` because `circular_shift`\
    \ should return `\"21\"` when `shift` is greater than the number of digits. I\
    \ believe that `circular_shift` should return `nil` instead of `\"\"` when the\
    \ shift is greater than the number of digits. I believe that `circular_shift`\
    \ should return `\"121\"` instead of `\"21\"` because `circular_shift` should\
    \ return `\"21\"` when `shift` is greater than the number of digits. I believe\
    \ that `circular_shift` should return `nil` instead of `\"\"` when the shift is\
    \ greater than the number of digits. I believe that `circular_shift` should return\
    \ `\"121\"` instead of `\"21\"` because `circular_shift` should return `\"21\"\
    ` when `shift` is greater than the number of digits. I believe that `circular_shift`\
    \ should return `nil` instead of `\"\"` when the shift is greater than the number\
    \ of digits. I believe that `circular_shift` should return `\"121\"` instead of\
    \ `\"21\"` because `circular_shift` should return `\"21\"` when `shift` is greater\
    \ than the number of digits. I believe that `circular_shift` should return `nil`\
    \ instead of `\"\"` when the shift is greater than the number of digits.\n<|/\
    \ c |>\n<| c |>\nI believe that `circular_shift` should return `\"121\"` instead\
    \ of `\"21\"` because `circular_shift` should return `\"21\"` when `shift` is\
    \ greater than the number of digits. I believe that `circular_shift` should return\
    \ `nil` instead of `\"\"` when the shift is greater than the number of ", "  x\
    \ = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits[shift + 1])\n  digits.reverse!\n  return digits.join(\"\
    \")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit[shift..-1]\n  end\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks so much for the help! I really appreciate it!\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x.to_s.reverse.slice(shift, x.to_s.length).reverse\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n\
    \    s << digit\n  end\nend", "  x = x.to_s\n  shift = shift % x.size\n  digits\
    \ = x.reverse.chars.take(shift)\n  digits.reverse!\n  digits.join\nend", "  x\
    \ = x.to_s\n  shift = shift % x.size\n  digits = x.reverse.chars.take(x.size -\
    \ shift)\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join(\"\
    \")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n   \
    \ result << digit if digit > x.to_s.split(\"\").reverse.shift\n    result << digit\n\
    \  end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n\
    \  digits.reverse!\n  digits[shift] = digits[shift].join\n  digits.reverse!\n\
    \  digits.join\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length)\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n\
    \    s << digit.chr\n  end\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length)\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result\
    \ << digit if digit > x.to_s.split(\"\").reverse.shift\n    result << digit\n\
    \  end\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i\
    \ - shift.to_s.to_i)).to_s\n    shift -= 1\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i -\
    \ shift.to_s.to_i)) % 10\n    shift -= 1\n  end\nend", "  x.to_s.split(\"\").reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.dup\n    digit.slice!(0, shift)\n    digit.slice!(-shift)\n\
    \    digit = digit.join if index == 0\n    digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result << digit\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do this without\
    \ having to use recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive solution\
    \ that doesn't use recursion.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i\
    \ - shift.to_s.to_i)).to_s\n    shift -= 1\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s << digit if digit >= (shift.to_i + 1)\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for your answer. I'm\
    \ still trying to understand how this works. I understand that `to_s` converts\
    \ the number to a string, but how does `inject(\"\")` work? I understand that\
    \ `inject` iterates over the array and returns the last value it iterates over,\
    \ but how does it know to iterate over the digits of the number? And how does\
    \ it know to stop iterating when it reaches the end of the string?\n<|/ c |>\n\
    <| c |>\n`inject` iterates over the array and returns the last value it iterates\
    \ over. `inject` returns the last value it iterates over. `inject` returns the\
    \ last value it iterates over. `inject` returns the last value it iterates over.\
    \ `inject` returns the last value it iterates over. `inject` returns the last\
    \ value it iterates over. `inject` returns the last value it iterates over. `inject`\
    \ returns the last value it iterates over. `inject` returns the last value it\
    \ iterates over. `inject` returns the last value it iterates over. `inject` returns\
    \ the last value it iterates over. `inject` returns the last value it iterates\
    \ over. `inject` returns the last value it iterates over. `inject` returns the\
    \ last value it iterates over. `inject` returns the last value it iterates over.\
    \ `inject` returns the last value it iterates over. `inject` returns the last\
    \ value it iterates over. `inject` returns the last value it iterates over. `inject`\
    \ returns the last value it iterates over. `inject` returns the last value it\
    \ iterates over. `inject` returns the last value it iterates over. `inject` returns\
    \ the last value it iterates over. `inject` returns the last value it iterates\
    \ over. `inject` returns the last value it iterates over. `inject` returns the\
    \ last value it iterates over. `inject` returns the last value it iterates over.\
    \ `inject` returns the last value it iterates over. `inject` returns the last\
    \ value it iterates over. `inject` returns the last value it ", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks so much\
    \ for this! I used this and modified it a little bit to fit my needs.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift\
    \ && digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n \
    \   s\n  end\nend", "  x = x.to_i\n  shift = shift.to_i\n  return x.to_s(10).reverse.chars.drop(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits.drop(shift))\n  digits.reverse!\n  digits.join(\"\
    \")\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift && digit > s.length\n\
    \    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n \
    \ end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift &&\
    \ digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n    s\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for your\
    \ answer. I'm going to try it out and let you know how it goes.\n<|/ c |>\n<|\
    \ c |>\nI got it to work. Thanks so much for your help. I really appreciate it.\n\
    <|/ c |>\n<| c |>\nI added a more efficient version of the `circular_shift` method\
    \ which I believe is more efficient than my original answer. Let me know if it\
    \ works for you.\n<|/ c |>\n<| c |>\nI added a more efficient version of the `circular_shift`\
    \ method which I believe is more efficient than my original answer. Let me know\
    \ if it works for you.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", " \
    \ return x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift && digit > s.length\n\
    \    s << digit.chr\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit % 10\n  end\nend", "  x = x.to_s\n  shift\
    \ = shift || 0\n  digits = x.chars.to_a\n  digits.reverse!\n  digits.each_with_index\
    \ do |digit, i|\n    digits[i] = digits[i - shift]\n  end\n  digits.join\nend",
  "  x.to_s.reverse.chars.take(shift).join\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x = x.to_s\n  shift = shift.to_i\n  digits = x.to_s.reverse\n\
    \  digits = digits.chars.drop(shift).concat(digits.chars.take(shift))\n  digits.reverse!\n\
    \  digits.reverse!\n  return digits.to_s\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 2)\n    s << digit\
    \ if digit > (shift.to_i + 3)\n    s << digit if digit > (shift.to_i + 4)\n  \
    \  s << digit if digit > (shift.to_i + 5)\n    s << digit if digit > (shift.to_i\
    \ + 6)\n    s << digit if digit > (shift.to_i + 7)\n    s << digit if digit >\
    \ (shift.to_i + 8)\n    s << digit if digit > (shift.to_i + 9)\n    s << digit\
    \ if digit > (shift.to_i + 10)\n    s << digit if digit > (shift.to_i + 11)\n\
    \    s << digit if digit > (shift.to_i + 12)\n    s << digit if digit > (shift.to_i\
    \ + 13)\n    s << digit if digit > (shift.to_i + 14)\n    s << digit if digit\
    \ > (shift.to_i + 15)\n    s << digit if digit > (shift.to_i + 16)\n    s << digit\
    \ if digit > (shift.to_i + 17)\n    s << digit if digit > (shift.to_i + 18)\n\
    \    s << digit if digit > (shift.to_i + 19)\n    s << digit if digit > (shift.to_i\
    \ + 20)\n    s << digit if digit > (shift.to_i + 21)\n    s << digit if digit\
    \ > (shift.to_i + 22)\n    s << digit if digit > (shift.to_i + 23)\n    s << digit\
    \ if digit > (shift.to_i + 24)\n    s << digit if digit > (shift.to_i + 25)\n\
    \    s << digit if digit > (shift.to_i + 26)\n    s << digit if digit > (shift.to_i\
    \ + 27)\n    s << digit if digit > (shift.to_i + 28)\n    s << digit if digit\
    \ > (shift.to_i + 29)\n    s << digit if digit > (shift.to_i + 30)\n    s << digit\
    \ if digit > (shift.to_i + 31)\n    s << digit if digit > (shift.to_i + 32)\n\
    \    s << digit if digit > (shift.to_i + 33)\n    s << digit if digit > (shift.to_i\
    \ + 34)\n    s << digit if digit > (shift.to_", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x = x.to_s\n  shift = shift.to_i\n  digits = x.split(//)\n  digits.reverse!\n\
    \  digits.reverse! if shift > digits.length\n  digits.reverse! if shift < 0\n\
    \  digits.join(//)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", " \
    \ return x.to_s.reverse.slice(shift, x.to_s.length).reverse\nend", "  x = x.to_i\n\
    \  shift = shift.to_i\n  return x.to_s(10).reverse.chars.drop(shift).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit.modulo(10).to_s\n  end\nend", " \
    \ x = x.to_s\n  shift = shift.to_i\n  x.slice!(0, shift)\n  x.reverse!\n  x.slice!(0,\
    \ shift)\n  x\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift && digit > s.length\n    s << digit\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>", "  x = x.to_s\n  shift = shift.to_i\n  digits\
    \ = x.split(\"\")\n  digits.reverse!\n  digits[shift..-1] + digits.first(shift)\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result\
    \ << digit if digit > 0 && digit < shift\n    result << digit\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x = x.to_s\n  shift = shift.to_i\n  return x.reverse.chars.drop(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit <= shift && digit > s.length\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n\
    \    result << digit if digit > x.to_s[shift..-1]\n    result << digit if digit\
    \ < x.to_s[0..shift]\n    result\n  end\nend", "  x = x.to_s\n  shift = shift.to_i\n\
    \  digits = x.to_s.reverse\n  digits = digits.chars.drop(shift).reverse\n  digits\
    \ = digits.reverse\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n\
    \    s << digit\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i -\
    \ shift.to_s.to_i))\n    shift -= 1\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend",
  "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits[shift + 1])\n  digits.reverse!\n  digits.join(\"\
    \")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit.modulo(10**(shift.to_i - shift.to_s.size + 1))\n    shift -= 1\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit\
    \ <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. Try `circular_shift.call(12, -1)`\n<|/ c |>\n<| c |>\nI added a fix\
    \ for negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added\
    \ a fix for negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit.chr\n  end\nend",
  "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\
    \ % 10\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x = x.to_s\n  shift = shift || 0\n  digits = x.chars.to_a\n  digits.reverse!\n\
    \  digits[0...shift].concat(digits[shift+1..-1]).reverse!\n  digits.join\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n", "  return x.to_s.reverse.slice(shift, x.to_s.length)\n\
    end", "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits[shift..-1]).reverse!\n  digits.join(\"\")\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n    s\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend", "  x = x.to_s\n  shift = shift || 0\n\
    \  digits = x.reverse.split(//)\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.each_with_index.map\
    \ do |digit, index|\n    digit = digit.succ\n    digit = digit if digit > 9\n\
    \    digit = digit if digit < 0\n    digit = digit * 10 + index\n    digit = digit\
    \ % 10\n    digit\n  end.reverse.join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like your solution, but I prefer to use `to_i` instead of `to_s`\
    \ because I believe it makes the code more readable. Also, `to_i` will raise an\
    \ error if the string cannot be converted to an integer.\n<|/ c |>\n<| c |>\n\
    I agree with you, `to_i` would be better. Thanks for pointing that out.\n<|/ c\
    \ |>\n<| a |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  return x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit % 10\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit <= shift.to_i\n    s << digit\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution. Very\
    \ concise. Thanks!\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n\
    \    s << digit.chr\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do it without using inject\
    \ (which I haven't learned yet).\n<|/ c |>\n<| c |>\nI added a solution without\
    \ inject. Hope it helps.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without using inject (which I haven't learned yet).\n\
    <|/ c |>\n<| c |>\nI added a solution without inject. Hope it helps.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit.modulo(10**(shift.to_i - 1)) rescue digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit if digit > shift\n    s\n  end\nend", "  x = x.to_s\n\
    \  shift = shift || 0\n  digits = x.split(//)\n  digits.reverse!\n  digits[0..(shift.to_i\
    \ - shift.to_s)] = digits[0..(shift.to_i - shift.to_s)].join\n  digits.reverse!\n\
    \  digits.join(//)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x = x.to_s\n\
    \  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n  digits[shift].concat(digits[shift..-1]).reverse!\n\
    \  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit[(shift.to_i % digit.length).to_i]\n    shift.decrement\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do this without having to use an extra variable.\
    \ Perhaps something like `x.to_s.split(\"\").reverse.inject(\"\") { |s, digit|\
    \ s << digit[(shift.to_i % digit.length).to_i] }`.\n<|/ c |>\n<| c |>\nYes, that\
    \ would work. I edited my answer to include your suggestion.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  x = x.to_i\n  shift = shift.to_i\n  digits = x.digits.reverse\n\
    \  digits[shift] = digits[shift].to_s\n  digits.reverse!\n  digits.join(\"\")\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit % 10\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i + 1)\n \
    \   s << digit if digit > (shift.to_i + 1)\n    s\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i + 1)\n \
    \   s << digit if digit > (shift.to_i + 1)\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result\
    \ << digit if digit > x.to_s.split(\"\").reverse.shift\n    result << digit if\
    \ digit > x.to_s.split(\"\").reverse.shift - 1\n    result\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit.chr << shift.chr\n    shift\
    \ -= 1\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to avoid the use of `.to_s` as I believe it would\
    \ be more efficient to just use `<<` on the string directly. Also, `circular_shift`\
    \ should return `nil` if the shift is greater than the number of digits.\n<|/\
    \ c |>\n<| c |>\nI agree that `to_s` is unnecessary. `<<` would work just as well.\
    \ I'll fix the return value.\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ use `to_s`.\n<|/ c |>\n<| c |>\nI added a version that doesn't use `to_s`.\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't use `to_s`.\n<|/ c |>\n<| a\
    \ tags=ruby,string |>\nHere's a solution using String#rindex and String#slice:\n\
    <code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift && digit < x.to_s.length\n    s << x.to_s[digit-shift]\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x = x.to_s\n  shift = shift || 0\n  len = x.length\n  digits = x.split(//)\n\
    \  digits.reverse!\n  digits[shift].concat!(digits[len-shift-1])\n  digits.reverse!\n\
    \  digits.join(//)\nend", "  x = x.to_i\n  shift = shift.to_i\n  return x.to_s(10).reverse.chars.drop(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x = x.to_s\n  shift = shift\
    \ || 0\n  digits = x.split(//)\n  digits.reverse!\n  digits.reverse!\n  digits[shift..-1]\
    \ + digits.join(//)\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length)\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\
    \").reverse.each_slice(shift).map(&:join).join(\"\")\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit.chars.reverse.join\n\
    \    s << digit.chars.reverse.slice!(0, shift)\n    s << digit.chars.reverse.slice!(0,\
    \ -shift)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nI like your\
    \ solution, however I believe that `to_s` will call `to_s` on every element in\
    \ the array. `to_s` will also call `to_s` on every element in the array. `to_s`\
    \ will call `to_s` on every element in the array. `to_s` will call `to_s` on every\
    \ element in the array. `to_s` will call `to_s` on every element in the array.\
    \ `to_s` will call `to_s` on every element in the array. `to_s` will call `to_s`\
    \ on every element in the array. `to_s` will call `to_s` on every element in the\
    \ array. `to_s` will call `to_s` on every element in the array. `to_s` will call\
    \ `to_s` on every element in the array. `to_s` will call `to_s` on every element\
    \ in the array. `to_s` will call `to_s` on every element in the array. `to_s`\
    \ will call `to_s` on every element in the array. `to_s` will call `to_s` on every\
    \ element in the array. `to_s` will call `to_s` on every element in the array.\
    \ `to_s` will call `to_s` on every element in the array. `to_s` will call `to_s`\
    \ on every element in the array. `to_s` will call `to_s` on every element in the\
    \ array. `to_s` will call `to_s` on every element in the array. `to_s` will call\
    \ `to_s` on every element in the array. `to_s` will call `to_s` on every element\
    \ in the array. `to_s` will call `to_s` on every element in the array. `to_s`\
    \ will call `to_s` on every element in the array. `to_s` will call `to_s` on every\
    \ element in the array. `to_s` will call `to_s` on every element in the array.\
    \ `to_s` will call `to_s` on every element in the array. `to_s` will call `to_s`\
    \ on every element in the array. `to_s` will call `to_s` on every element in the\
    \ array. `to_s` will call `to_s` on every element in the array. `to_s` will call\
    \ `to_s` on every element in the array. `to_s` will call `to_s` on every element\
    \ in the array. `", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i\
    \ - shift.to_s.to_i)).to_s\n    shift -= 1\n  end\nend", "  x = x.to_s\n  shift\
    \ = shift || 0\n  shift = shift > x.size ? x.size - shift : shift\n  x.reverse.chars.drop(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit % 10\n  end\nend", "  x = x.to_s\n\
    \  shift = shift.to_i\n  digits = x.chars.to_a\n  digits.reverse!\n  digits.rotate(shift)\n\
    \  digits.reverse!\n  digits.join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x = x.to_i\n  shift = shift.to_i\n  return x.to_s.reverse[shift]\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift && digit % 2 == 1\n    s << digit\n  end\nend",
  "  x = x.to_s\n  shift = shift.to_i\n  len = x.length\n  digits = x.split(//)\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n\
    \    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n\
    \    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n\
    \    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n\
    \    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n\
    \    s << digit.modulo(10**(shift.to_i - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i\
    \ - 1)) unless digit.zero?\n    s << digit.modulo(10**(shift.to_i - 1)) unless\
    \ digit.zero?\n    s << digit.modulo(10**(shif", "  x = x.to_s\n  shift = shift\
    \ % x.length\n  digits = x.to_s.reverse\n  digits[0...shift] = digits[shift]\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n",
  "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like your solution, but I wonder how it compares to other solutions\
    \ posted here. I think it would be interesting to compare the performance of different\
    \ solutions.\n<|/ c |>\n<| c |>\nI agree with you, this is very interesting. I\
    \ would like to see some benchmarks done on different solutions.\n<|/ c |>\n<|\
    \ c |>\nI added a benchmark test to my answer. Hope it helps.\n<|/ c |>\n<| c\
    \ |>\nI like your solution, but I wonder how it compares to other solutions posted\
    \ here. I think it would be interesting to compare the performance of different\
    \ solutions.\n<|/ c |>\n<| c |>\nI added a benchmark test to my answer. Hope it\
    \ helps.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift && digit % 2\
    \ == 1\n    s << digit\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like\
    \ your solution, but I wonder if it can be done without using recursion.\n<|/\
    \ c |>\n<| c |>\nI added a solution that doesn't use recursion.\n<|/ c |>\n<|\
    \ a tags=ruby,string,algorithm |>\n<code>", "  x = x.to_s\n  shift = shift % x.size\n\
    \  x.slice!(0, shift)\n  x.reverse!\n  x\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit.modulo(10).to_s\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result << digit\
    \ if digit > 0 && digit < shift\n    result << digit.divmod(shift).last\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit\
    \ <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n    s\n  end\n\
    end", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |result, digit|\n    result << digit if digit > 0 && digit < shift\n  \
    \  result << digit.modulo(10)\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result + ((digit > 0) ? ((digit\
    \ % 10) + shift * 10 + digit) : digit)\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x = x.to_s\n  shift = shift.to_i\n  len = x.length\n  result = \"\"\n\
    \  while shift > 0\n    digit = x.slice!(0, len)\n    result << digit\n    shift\
    \ -= 1\n  end\n  result << x.slice!(0, len)\n  result\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i + 1)\n \
    \   s << digit if digit > (shift.to_i + 1)\n    s << digit if digit > (shift.to_i\
    \ + 2)\n    s << digit if digit > (shift.to_i + 3)\n    s << digit if digit >\
    \ (shift.to_i + 4)\n    s << digit if digit > (shift.to_i + 5)\n    s << digit\
    \ if digit > (shift.to_i + 6)\n    s << digit if digit > (shift.to_i + 7)\n  \
    \  s << digit if digit > (shift.to_i + 8)\n    s << digit if digit > (shift.to_i\
    \ + 9)\n    s << digit if digit > (shift.to_i + 10)\n    s << digit if digit >\
    \ (shift.to_i + 11)\n    s << digit if digit > (shift.to_i + 12)\n    s << digit\
    \ if digit > (shift.to_i + 13)\n    s << digit if digit > (shift.to_i + 14)\n\
    \    s << digit if digit > (shift.to_i + 15)\n    s << digit if digit > (shift.to_i\
    \ + 16)\n    s << digit if digit > (shift.to_i + 17)\n    s << digit if digit\
    \ > (shift.to_i + 18)\n    s << digit if digit > (shift.to_i + 19)\n    s << digit\
    \ if digit > (shift.to_i + 20)\n    s << digit if digit > (shift.to_i + 21)\n\
    \    s << digit if digit > (shift.to_i + 22)\n    s << digit if digit > (shift.to_i\
    \ + 23)\n    s << digit if digit > (shift.to_i + 24)\n    s << digit if digit\
    \ > (shift.to_i + 25)\n    s << digit if digit > (shift.to_i + 26)\n    s << digit\
    \ if digit > (shift.to_i + 27)\n    s << digit if digit > (shift.to_i + 28)\n\
    \    s << digit if digit > (shift.to_i + 29)\n    s << digit if digit > (shift.to_i\
    \ + 30)\n    s << digit if digit > (shift.to_i + 31)\n    s << digit if digit\
    \ > (shift.to_i + 32)\n    s << digit if digit > (shift.to_i + 33)\n    s << digit\
    \ if digit > (shift.to_i + 34)\n    s << digit if digit > (shift.to_", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks so much for the detailed answer! I really appreciate it. I will try this\
    \ out and let you know how it goes.\n<|/ c |>\n<| c |>\nI ran your script and\
    \ got this error: `undefined method 'to_i' for \"12\":String`\n<|/ c |>\n<| c\
    \ |>\nSorry, I forgot to add `to_i` to the end of the `to_s` call. I've edited\
    \ my answer to include it.\n<|/ c |>\n<| c |>\nThanks so much! I really appreciate\
    \ it. I will try this out and let you know how it goes.\n<|/ c |>\n<| c |>\nI\
    \ ran your script and got this error: `undefined method 'to_i' for \"12\":String`\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
