name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n\
  # 2\ndef largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  factor = 1\n  while n > 1\n    factor += 1\n    n /= factor\n  factor\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n != 1\n\
    \    factors << i\n    n /= i\n    i += 1\n  factors.reverse\n  factors.last\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like your solution, but I believe that `largest_prime_factor`\
    \ should return `nil` instead of `0` when `n == 1`.\n<|/ c |>\n<| c |>\n: I agree,\
    \ that would be a better return value.\n<|/ c |>\n<| c |>\nI agree with you. `largest_prime_factor`\
    \ should return `nil` when `n` is `1`.\n<|/ c |>\n<| c |>\n: I agree, that would\
    \ be a better return value.\n<|/ c |>\n<| c |>\nI like your solution, but I believe\
    \ that `largest_prime_factor` should return `nil` instead of `0` when `n == 1`.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "  factors = []\n  factor = 1\n  while n\
    \ > 1\n    factors << factor\n    n /= factor\n    factor += 1\n  end\n  factors.reverse\n\
    \  factors.first\nend", "  prime_divisors = prime_divisors_of(n)\n  prime_divisors.each\
    \ do |prime_divisor|\n    if n % prime_divisor == 0\n      return prime_divisor\n\
    \    end\n  end\n  raise \"n must be greater than 1 and be a prime\"\nend", " \
    \ primes = prime_factors(n)\n  primes.reduce(:max)\nend", "  factors = []\n  i\
    \ = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 2\n  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n\
    \  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n /\
    \ 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while i *\
    \ i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n\
    \  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 2\n  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n\
    \  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n /\
    \ 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while i *\
    \ i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n\
    \  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 2\n  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n\
    \  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n /\
    \ 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n  i = 2\n  while i *\
    \ i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.",
  "  prime_divisor = 1\n  prime_factor = 1\n  while prime_divisor <= n\n    prime_divisor\
    \ = prime_divisor * 2\n    prime_factor = prime_factor + 1 if prime_divisor <=\
    \ n and n % prime_divisor == 0\n  end\n  prime_factor\nend", "  factors = []\n\
    \  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  factors.each do |factor|\n    if n % factor == 0\n      break\n\
    \    end\n  end\n  if factor == 1\n    n\n  else\n    factor\n  end\nend", " \
    \ prime_divisors = prime_divisors(n)\n  prime_divisors.each do |prime_divisor|\n\
    \    if n % prime_divisor == 0\n      return prime_divisor\n    end\n  end\nend",
  "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n % i == 0\n \
    \   n /= i\n    factors.push(i)\n  factors.reverse\n  factors.find { |f| f > n\
    \ }\nend", "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n\
    \ >= i\n    factors.push(i)\n    n /= i\n  factors.push(n)\n  factors.reverse\n\
    \  factors.inject(:*)\nend", "  prime_divisors = []\n  i = 2\n  while i <= n do\n\
    \    if n % i == 0 then\n      prime_divisors << i\n      n /= i\n    end\n  \
    \  i += 1\n  end\n  prime_divisors << n\n  prime_divisors.max\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,primes |>\n<code>", "  factors = []\n  factor\
    \ = 1\n  while n > 1\n    factors << factor\n    n /= factor\n    factor += 1\n\
    \  end\n  factors.reverse\n  factors.last\nend", "  prime_divisor = 1\n  while\
    \ n > prime_divisor\n    prime_divisor = prime_divisor * prime_divisor\n    n\
    \ /= prime_divisor\n  end\n  prime_divisor\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    if n % prime_divisor == 0\n   \
    \   return prime_divisor\n    end\n  end\n  raise \"n must be greater than 1 and\
    \ be a prime\"\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n\
    \  while n % i == 0\n    n /= i\n    factors << i\n    i += 1\n  factors << n\
    \ if n > 1\n  factors.max\nend", "  prime_divisors = []\n  prime_divisors_count\
    \ = 0\n  prime_divisors_limit = nil\n  prime_divisors_limit = n.to_i\n  while\
    \ prime_divisors_count < prime_divisors_limit\n    prime_divisors_count += 1\n\
    \    prime_divisor = prime_divisors.shift\n    prime_divisor = prime_divisor +\
    \ 1 if prime_divisor % 2 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor\
    \ % 3 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor % 5 == 0\n\
    \    prime_divisor = prime_divisor + 1 if prime_divisor % 7 == 0\n    prime_divisor\
    \ = prime_divisor + 1 if prime_divisor % 11 == 0\n    prime_divisor = prime_divisor\
    \ + 1 if prime_divisor % 13 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor\
    \ % 17 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor % 19 == 0\n\
    \    prime_divisor = prime_divisor + 1 if prime_divisor % 23 == 0\n    prime_divisor\
    \ = prime_divisor + 1 if prime_divisor % 29 == 0\n    prime_divisor = prime_divisor\
    \ + 1 if prime_divisor % 31 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor\
    \ % 37 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor % 41 == 0\n\
    \    prime_divisor = prime_divisor + 1 if prime_divisor % 43 == 0\n    prime_divisor\
    \ = prime_divisor + 1 if prime_divisor % 47 == 0\n    prime_divisor = prime_divisor\
    \ + 1 if prime_divisor % 53 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor\
    \ % 59 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor % 61 == 0\n\
    \    prime_divisor = prime_divisor + 1 if prime_divisor % 67 == 0\n    prime_divisor\
    \ = prime_divisor + 1 if prime_divisor % 71 == 0\n    prime_divisor = prime_divisor\
    \ + 1 if prime_divisor % 73 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor\
    \ % 79 == 0\n    prime_divisor = prime_divisor + 1 if prime_divisor % 83 == 0\n\
    \    prime_divisor = prime_divisor + 1 if ", "  prime_divisors(n)\n  prime_divisors.reduce(:max)\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i\
    \ += 1\n  factors.each do |factor|\n    if n % factor == 0\n      return factor\n\
    \    end\n  end\n  raise \"n must be greater than 1 and be a prime\"\nend", " \
    \ return n if n < 2 else largest_prime_factor(n / 2)\nend", "  factors = []\n\
    \  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  factors.each do |factor|\n    if n % factor == 0\n      break\n\
    \    end\n  end\n  return factor\nend", "  factors = []\n  factor = 1\n  while\
    \ n > 1\n    factors << factor\n    n /= factor\n    factor += 1\n  end\n  factors\
    \ << factor\n  factor\nend", "  factors = []\n  i = 2\n  while i * i <= n\n  \
    \  i += 1\n  while i <= n\n    factors.push(i)\n    i += 1\n  factors.each do\
    \ |factor|\n    if n % factor == 0\n      break\n    end\n  end\n  return factor\n\
    end", "  return n if n.is_a?(Integer) && n.odd? || n.prime? || n.even? || n.is_a?(Fixnum)\
    \ || n.is_a?(Bignum) || n.is_a?(Float) || n.is_a?(String) || n.is_a?(Symbol) ||\
    \ n.is_a?(TrueClass) || n.is_a?(FalseClass) || n.is_a?(::Numeric) || n.is_a?(::Complex)\n\
    \  factors = n.prime_division\n  factors.each do |factor|\n    return factor if\
    \ n % factor == 0\n  end\n  raise ArgumentError, \"#{n} is composite\"\nend",
  "  return n if n.is_a?(Integer) && n.odd? && n.prime? && n > 2 else largest_prime_factor(n./2)\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\
    \ / 2\n    factors << i\n    i += 1\n  factors.max\nend", "  factors = []\n  i\
    \ = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n \
    \   i += 1\n  factors.each do |factor|\n    break if n % factor == 0\n    n /=\
    \ factor\n  end\n  n\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ for me. `largest_prime_factor.call(13195)` returns `29` instead of `2`.\n<|/\
    \ c |>\n<| c |>\n: It works for me in Ruby 1.9.3p194 (2012-04-20 revision 35410)\
    \ [x86_64-darwin10.8.0]. Maybe you have a different Ruby version?\n<|/ c |>\n\
    <| c |>\n: I tested this in Ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\
    \ on Mac OS X 10.6.8. Maybe you have a different Ruby version?\n<|/ c |>\n<| c\
    \ |>\n: I tested this in Ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\
    \ on Mac OS X 10.6.8. Maybe you have a different Ruby version?\n<|/ c |>\n<| c\
    \ |>\n: I tested this in Ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\
    \ on Mac OS X 10.6.8. Maybe you have a different Ruby version?\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  factors = []\n  factor = 1\n  while n > 1\n    factors\
    \ << factor\n    n /= factor\n    factor += 1\n  end\n  factors << factor\n  factor\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, however it seems\
    \ to me that your algorithm is O(n^2) whereas my algorithm is O(n). In other words,\
    \ your algorithm is O(n^2) whereas mine is O(n).\n<|/ c |>\n<| c |>\nYes, I agree\
    \ with you. My algorithm is O(n^2), but it is also O(n). My algorithm is O(n^2)\
    \ because I use a while loop and I do not need to check every number in the range\
    \ from 2 to n. My algorithm is O(n) because I do not need to check every number\
    \ in the range from 2 to n. My algorithm is O(n) because I do not need to check\
    \ every number in the range from 2 to n. My algorithm is O(n) because I do not\
    \ need to check every number in the range from 2 to n. My algorithm is O(n) because\
    \ I do not need to check every number in the range from 2 to n. My algorithm is\
    \ O(n) because I do not need to check every number in the range from 2 to n. My\
    \ algorithm is O(n) because I do not need to check every number in the range from\
    \ 2 to n. My algorithm is O(n) because I do not need to check every number in\
    \ the range from 2 to n. My algorithm is O(n) because I do not need to check every\
    \ number in the range from 2 to n. My algorithm is O(n) because I do not need\
    \ to check every number in the range from 2 to n. My algorithm is O(n) because\
    \ I do not need to check every number in the range from 2 to n. My algorithm is\
    \ O(n) because I do not need to check every number in the range from 2 to n. My\
    \ algorithm is O(n) because I do not need to check every number in the range from\
    \ 2 to n. My algorithm is O(n) because I do not need to check every number in\
    \ the range from 2 to n. My algorithm is O(n) because I do not need to check every\
    \ number in the range from 2 to n. My algorithm is O(n) because I do not need\
    \ to check every number in the range from 2 to n. My algorithm is O(n) because\
    \ I do not need to check every number in the range from 2 to n. My algorithm is\
    \ O(n) because I do not need to check every number in the range from 2 to n. My\
    \ algorithm is O(n) because I do not need to check every number in the range ",
  "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n    while n % i == 0\n\
    \      n /= i\n      factors << i\n    end\n  end\n  factors << n if n > 1\n \
    \ factors.max\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nThis doesn't\
    \ work. Try it with `largest_prime_factor.call(5)`.\n<|/ c |>\n<| c |>\nIt works.\
    \ I tested it with `largest_prime_factor.call(5)` which returns `5`.\n<|/ c |>\n\
    <| c |>\nIt doesn't work for `largest_prime_factor.call(5)` because `5` isn't\
    \ a prime number.\n<|/ c |>\n<| c |>\nYes, I see that. My point is that it doesn't\
    \ work for `largest_prime_factor.call(5)` because `5` isn't a prime number.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated my answer to include a solution\
    \ that works with non-prime numbers.\n<|/ c |>\n<| a tags=ruby,primes |>\n<code>",
  "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n % i == 0\n \
    \   factors << i\n    n /= i\n  factors << n\n  factors.max\nend\n</code>\n<|/\
    \ a tags=ruby,primes |>\n<| c |>\nThe first `while` loop can be replaced by `n.prime?\
    \ && n.factors.max`.\n<|/ c |>\n<| c |>\n: Yes, that would be better. Thanks.\n\
    <|/ c |>\n<| c |>\nThe first `while` loop can be replaced by `n.prime? && n.factors.max`.\n\
    <|/ c |>\n<| c |>\n: Yes, that would be better. Thanks.\n<|/ c |>\n<| c |>\n:\
    \ Thanks for your answer. I am new to ruby and I wanted to know how you came up\
    \ with that solution. Can you please explain how you came up with that solution?\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "  prime_divisors(n)\n  prime_divisors(n).each\
    \ do |divisor|\n    return divisor if n % divisor == 0\n  end\n  2\nend", "  prime_divisors\
    \ = prime_divisors_of(n)\n  prime_divisors.each do |prime|\n    return prime if\
    \ prime.is_a?(Integer)\n  end\n  raise ArgumentError, \"#{n} is not a prime number\"\
    \nend", "  prime_divisors = prime_divisors_of(n)\n  prime_divisors.each do |prime|\n\
    \    return prime if n % prime == 0\n  end\n  return n\nend", "  i = 2\n  while\
    \ i <= n / 2\n    i += 1\n    if n % i == 0\n      break\n  i\nend", "  i = 2\n\
    \  while i * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n  while\
    \ i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n  \
    \  if n % factor == 0\n      return factor\n    end\n  end\n  return n\nend",
  "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n != 1\n    factors.push\
    \ n\n    n /= i\n  end\n  factors.push n\n  factors.reverse\n  factors.find {\
    \ |f| f > 1 }\nend", "  factors = []\n  factor = 1\n  while n > 1\n    factors\
    \ << factor\n    factor += 1\n    n /= factor\n  end\n  factors << factor\n  factors.max\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i\
    \ += 1\n  factors.each do |factor|\n    if n % factor == 0\n      return factor\n\
    \    end\n  end\n  raise \"No prime factor found\"\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby |>\n<code>", "  factors = []\n  i = 1\n  while i * i <= n\n\
    \    i += 1\n  while n % i == 0\n    factors.push(i)\n    n /= i\n  factors.push(n)\n\
    \  factors.reverse\n  factors.each do |factor|\n    return factor\n  end\n  raise\
    \ \"No prime factor found\"\nend", "  i = 2\n  while i * i <= n\n    i += 1\n\
    \  i\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    factors << i\n \
    \   i += 1\n  factors.max\nend", "  prime_divisor = 1\n  prime_factor = 1\n  while\
    \ prime_divisor <= n\n    prime_divisor = prime_divisor * 2\n    prime_factor\
    \ = prime_factor + 1\n  end\n  prime_factor\nend", "  return n if n < 2 else largest_prime_factor(n\
    \ / 2)\nend", "  prime_divisor = 1\n  while n > prime_divisor\n    prime_divisor\
    \ = prime_divisor * 2\n  end\n  prime_divisor\nend", "  prime_divisors = []\n\
    \  i = 2\n  while i * i <= n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\n\
    end", "  i = 2\n  while i <= n / 2\n    if n % i == 0\n      break\n    i += 1\n\
    \  i\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n\n    factors.push(i)\n    i += 2\n  factors.each do |factor|\n    if\
    \ n % factor == 0\n      break\n    end\n  end\n  return n if factors.size ==\
    \ 1\n  factors.last\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n\
    \    i += 1\n  factors.each do |factor|\n    if n % factor == 0\n      n = n /\
    \ factor\n      break\n    end\n  end\n  n\nend", "  i = 2\n  while i * i <= n\n\
    \    i += 1\n  i\nend", "  factors = []\n  i = 1\n  while i * i <= n\n    i +=\
    \ 1\n  while n % i == 0\n    factors << i\n    n /= i\n  factors << n if n > 1\n\
    \  factors.max\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\n`largest_prime_factor`\
    \ returns `nil` when given `0`.\n<|/ c |>\n<| c |>\nThanks, I fixed it.\n<|/ c\
    \ |>\n<| c |>\n`largest_prime_factor` returns `nil` when given `0`.\n<|/ c |>\n\
    <| c |>\nThanks, I fixed it.\n<|/ c |>\n<| a tags=ruby,primes |>\n<code>", " \
    \ i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n\
    \  while i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n\
    \    if n % factor == 0\n      return factor\n    end\n  end\n  return n\nend",
  "  factor = 1\n  while n > 1\n    if n % factor == 0\n      break\n    factor++\n\
    \    n/=factor\n  end\n  factor\nend", "  factors = []\n  i = 2\n  while i * i\
    \ <= n\n    factors.push(i)\n    i += 2\n  factors.each do |factor|\n    if n\
    \ % factor == 0\n      return factor\n    end\n  end\n  raise \"No prime factor\
    \ found\"\nend", "  prime_divisor = 1\n  prime_factor = 1\n  while prime_divisor\
    \ <= n / prime_divisor\n    prime_divisor = prime_divisor * prime_divisor\n  \
    \  prime_factor = prime_divisor\n  end\n  prime_factor\nend", "  prime_divisors\
    \ = prime_factors(n)\n  prime_divisors.each do |prime|\n    return prime if prime.is_a?(Integer)\n\
    \  end\n  raise ArgumentError, \"n must be greater than 1\"\nend", "  prime_divisors\
    \ = []\n  i = 2\n  while i * i <= n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\n\
    end", "  prime_divisor = 1\n  prime_factor = 1\n  while prime_divisor <= n\n \
    \   prime_divisor = prime_divisor * 2\n  end\n  while prime_factor <= n\n    prime_factor\
    \ = prime_factor * 2\n  end\n  prime_factor\nend", "  return n if n < 2 else largest_prime_factor(n\
    \ / 2)\nend", "  prime_divisors(n)\n  largest_prime_divisor = nil\n  n.times do\
    \ |i|\n    prime_divisor = prime_divisors.call(i)\n    if largest_prime_divisor\
    \ == nil || largest_prime_divisor > prime_divisor\n      largest_prime_divisor\
    \ = prime_divisor\n    end\n  end\n  largest_prime_divisor\nend", "  prime_divisors\
    \ = prime_divisors(n)\n  largest_prime_factor = nil\n  largest_prime_factor =\
    \ prime_divisors.first if prime_divisors.size > 0\n  largest_prime_factor\nend",
  "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 1\n\
    \  factors.each do |factor|\n    if n % factor == 0\n      break\n    end\n  end\n\
    \  factors.last\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", " \
    \ prime_divisors = prime_divisors_of(n)\n  prime_divisors.each do |prime_divisor|\n\
    \    if n % prime_divisor == 0\n      return prime_divisor\n    end\n  end\n \
    \ raise \"n must be greater than 1\"\nend", "  i = 2\n  while i * i <= n\n   \
    \ i += 1\n  i\nend", "  prime_divisors = prime_factors(n)\n  prime_divisors.each\
    \ do |prime|\n    return prime if prime.is_a? Integer\n  end\n  raise \"n must\
    \ be greater than 1\"\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend",
  "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n % i == 0\n \
    \   factors << i\n    n /= i\n  factors << n\n  factors.max\nend", "  i = 2\n\
    \  while i * i <= n\n    i += 1\n  i\nend", "  prime_divisors(n)\n  largest_prime\
    \ = nil\n  largest_divisor = nil\n  n.times do |i|\n    prime_divisors(i)\n  \
    \  largest_divisor = nil\n    prime_divisors.each do |divisor|\n      if divisor\
    \ > largest_divisor\n        largest_divisor = divisor\n        largest_prime\
    \ = i\n      end\n    end\n  end\n  return largest_prime\nend", "  prime_divisor\
    \ = 1\n  while prime_divisor < n\n    prime_divisor = prime_divisor * 2\n  end\n\
    \  prime_divisor\nend", "  prime_divisors(n)\n  largest_prime = nil\n  largest_prime_divisor\
    \ = nil\n  n.times do |i|\n    prime_divisors(i)\n    if largest_prime_divisor\
    \ == nil\n      largest_prime_divisor = i\n      largest_prime = i\n    elsif\
    \ largest_prime == nil\n      largest_prime = i\n    elsif largest_prime > i\n\
    \      largest_prime = i\n      largest_prime_divisor = i\n    end\n  end\n  largest_prime_divisor\n\
    end", "  factor = 1\n  while n > 1\n    factor += 1\n    n /= factor\n  end\n\
    \  factor\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n / 2\n    factors << i\n    i += 1\n  factors.max\nend", "  factors =\
    \ []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors <<\
    \ i\n    i += 1\n  factors.max\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like\
    \ your solution, but I wonder why you didn't just use [the built-in `prime?` method](http://ruby-doc.org/core-2.2.0/Prime.html#method-i-prime-3F)?\
    \ It seems like it would be a lot more efficient.\n<|/ c |>\n<| c |>\nI didn't\
    \ know about `prime?`, thanks for pointing it out. I've edited my answer to include\
    \ it.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder why you didn't just\
    \ use [the built-in `prime?` method](http://ruby-doc.org/core-2.2.0/Prime.html#method-i-prime-3F)?\
    \ It seems like it would be a lot more efficient.\n<|/ c |>\n<| c |>\nI didn't\
    \ know about `prime?`, thanks for pointing it out. I've edited my answer to include\
    \ it.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder why you didn't just\
    \ use [the built-in `prime?` method](http://ruby-doc.org/core-2.2.0/Prime.html#method-i-prime-3F)?\
    \ It seems like it would be a lot more efficient.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n %\
    \ i == 0\n    factors << i\n    n /= i\n  factors << n if n > 1\n  factors.max\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but I wonder how it compares\
    \ to other solutions posted here. I think it would be interesting to compare the\
    \ performance of different solutions.\n<|/ c |>\n<| c |>\nI compared this solution\
    \ to other solutions posted here and found that it is slower than the other solutions.\
    \ I wonder why.\n<|/ c |>\n<| c |>\nI compared this solution to other solutions\
    \ posted here and found that it is slower than the other solutions. I wonder why.\n\
    <|/ c |>\n<| c |>\nI compared this solution to other solutions posted here and\
    \ found that it is slower than the other solutions. I wonder why.\n<|/ c |>\n\
    <| c |>\nI compared this solution to other solutions posted here and found that\
    \ it is slower than the other solutions. I wonder why.\n<|/ c |>\n<| a tags=ruby,primes,algorithm\
    \ |>\n<code>", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ n >= i\n    factors.push(i)\n    n /= i\n  factors.push(n)\n  factors.reverse\n\
    \  factors.find { |f| f > n }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ doesn't work for large numbers. For example, `largest_prime_factor(1000000007)`\
    \ returns `nil`.\n<|/ c |>\n<| c |>\nThe algorithm is correct. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)`\
    \ returns `7`. `largest_prime_factor(1000000007)` returns `7`. `largest_prime_factor(1000000007)` ",
  "  primes = prime_factors(n)\n  primes.each do |prime|\n    return prime if prime\
    \ > n\n  end\n  n\nend", "  factors = []\n  i = 1\n  while i * i <= n\n    factors.push(i)\n\
    \    i += 1\n  factors.each do |factor|\n    if n % factor == 0\n      break\n\
    \    end\n  end\n  return n if factors.size == 1\n  factors.last\nend", "  prime_divisor\
    \ = 1\n  prime_factors = []\n  while n > 1\n    prime_factors << n\n    prime_divisor\
    \ = prime_divisor * n\n    n /= prime_divisor\n  end\n  prime_factors.reverse\n\
    \  prime_factors.last\nend", "  factors = []\n  i = 2\n  while i * i <= n\n  \
    \  factors.push(i)\n    i += 1\n  factors.each do |factor|\n    if n % factor\
    \ == 0\n      n = n / factor\n      break\n    end\n  end\n  n\nend\n</code>\n\
    <|/ a tags=ruby,primes |>\n<| c |>\nI like your solution, but I wonder why you\
    \ chose to implement it this way. Why not just use [the built-in `prime?` method](http://ruby-doc.org/core-2.4.0/Prime.html#method-i-prime-3F)?\n\
    <|/ c |>\n<| c |>\nI didn't know about `prime?`, thanks for pointing it out. I've\
    \ updated my answer to include it.\n<|/ c |>\n<| c |>\nI like your solution, but\
    \ I wonder why you chose to implement it this way. Why not just use [the built-in\
    \ `prime?` method](http://ruby-doc.org/core-2.4.0/Prime.html#method-i-prime-3F)?\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder why you chose to implement\
    \ it this way. Why not just use [the built-in `prime?` method](http://ruby-doc.org/core-2.4.0/Prime.html#method-i-prime-3F)?\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder why you chose to implement\
    \ it this way. Why not just use [the built-in `prime?` method](http://ruby-doc.org/core-2.4.0/Prime.html#method-i-prime-3F)?\n\
    <|/ c |>\n<| a tags=ruby,primes |>\n<code>", "  primes = prime_factors(n)\n  primes.each\
    \ do |prime|\n    if n % prime == 0\n      return prime\n    end\n  end\n  return\
    \ n\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| a dscore=0 |>\n<code>", "  factors\
    \ = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 1\n  factors.each do |factor|\n    if n % factor == 0\n      n = n /\
    \ factor\n      break\n    end\n  end\n  n\nend", "  prime_divisors = prime_factors(n)\n\
    \  prime_divisors.each do |prime|\n    return prime if prime.is_a? Integer\n \
    \ end\n  raise ArgumentError, \"n must be greater than 1\"\nend", "  prime_divisors\
    \ = prime_divisors(n)\n  largest_prime_factor = prime_divisors.max\n  prime_divisors.each\
    \ do |prime|\n    if n % prime == 0\n      largest_prime_factor = prime\n    end\n\
    \  end\n  largest_prime_factor\nend", "  factors = []\n  factor = 1\n  while n\
    \ > 1\n    factors << factor\n    factor += 1\n    n /= factor\n  factors << factor\n\
    \  factors.max\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nI like the idea\
    \ of using factors to store the factors. I didn't think of that. Thanks!\n<|/\
    \ c |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid\
    \ the array and just return the largest prime factor. I'm thinking something like\
    \ `largest_prime_factor(n)` where `largest_prime_factor` returns the largest prime\
    \ factor of `n`.\n<|/ c |>\n<| c |>\n: Yes, you can do that. I'll add that to\
    \ my answer.\n<|/ c |>\n<| c |>\n: I added a version that doesn't use an array.\n\
    <|/ c |>\n<| c |>\n: I added a version that doesn't use an array.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend",
  "  primes = prime_factors(n)\n  primes.reduce(:<=>)\nend", "  factors = []\n  i\
    \ = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n \
    \   i += 1\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.shift\n\
    \    i += 1\n  factors.each do |factor|\n    return factor if n % factor == 0\n\
    \  end\n  nil\nend", "  prime_divisor = 1\n  while n > prime_divisor\n    prime_divisor\
    \ = prime_divisor * prime_divisor\n    n /= prime_divisor\n  end\n  prime_divisor\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n\
    \    factors.push(i)\n    i += 2\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n\n    factors.shift\n    i += 2\n  factors.reverse\n  factors.last\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI like your solution, but I wonder if there is a way\
    \ to do this without using recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive\
    \ solution that is probably more efficient than a recursive solution.\n<|/ c |>\n\
    <| c |>\nI added a non-recursive solution that is probably more efficient than\
    \ a recursive solution.\n<|/ c |>\n<| c |>\nI added a non-recursive solution that\
    \ is probably more efficient than a recursive solution.\n<|/ c |>\n<| c |>\nI\
    \ added a non-recursive solution that is probably more efficient than a recursive\
    \ solution.\n<|/ c |>\n<| a tags=ruby,primes,algorithm |>\n<code>", "  factors\
    \ = []\n  factor = 1\n  while n > 1\n    factors << factor\n    n /= factor\n\
    \    factor += 1\n  end\n  factors << factor\n  factor\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>", "  factors = []\n  i = 2\n  while i * i <= n\n\
    \    i += 1\n  while i <= n\n    factors.push(i)\n    i += 2\n  factors.reverse\n\
    \  factors.each do |factor|\n    if n % factor == 0\n      return factor\n   \
    \ end\n  end\n  return n\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  i\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i\
    \ += 2\n  factors.each do |factor|\n    if n % factor == 0\n      return factor\n\
    \    end\n  end\n  nil\nend", "  factors = []\n  i = 2\n  while i * i <= n\n \
    \   i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n\
    \  factors.find { |f| n % f == 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This code doesn't work for large numbers. For example, `largest_prime_factor(1000000007)`\
    \ returns `nil`.\n<|/ c |>\n<| c |>\nThe code works fine for me on Ruby 2.1.1.\
    \ What version are you using?\n<|/ c |>\n<| c |>\nRuby 2.1.1 on Windows 7. Maybe\
    \ it's my computer. I'll try it on a different computer.\n<|/ c |>\n<| c |>\n\
    I tested it on Ruby 2.1.1 on Windows 7 and it works fine. Maybe your computer\
    \ has a different version of Ruby or maybe it's your computer that's not working\
    \ properly. Try it on a different computer or try it on another computer.\n<|/\
    \ c |>\n<| c |>\nI tested it on Ruby 2.1.1 on Windows 7 and it works fine. Maybe\
    \ your computer has a different version of Ruby or maybe it's your computer that's\
    \ not working properly. Try it on a different computer or try it on another computer.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  factors = []\n  i = 2\n  while i * i <=\
    \ n\n    factors << i\n    i += 1\n  factors.max\nend", "  factors = []\n  i =\
    \ 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n   \
    \ i += 2\n  factors.reverse\n  factors.each do |factor|\n    if n % factor ==\
    \ 0\n      return factor\n    end\n  end\n  return n\nend", "  prime_divisors\
    \ = prime_divisors_of(n)\n  prime_divisors.each do |prime|\n    return prime if\
    \ prime.is_a?(Integer)\n  end\n  2\nend", "  factors = []\n  i = 2\n  while i\
    \ * i <= n\n    i += 1\n    while n % i == 0\n      n /= i\n      factors << i\n\
    \    end\n  end\n  factors << n if n > 1\n  factors.max\nend", "  prime_divisors\
    \ = prime_divisors_of(n)\n  prime_divisors.each do |prime_divisor|\n    if n %\
    \ prime_divisor == 0\n      return prime_divisor\n    end\n  end\n  raise \"n\
    \ must be greater than 1\"\nend", "  factors = []\n  i = 2\n  while i * i <= n\n\
    \    i += 1\n    while n % i == 0\n      n /= i\n      factors << i\n    end\n\
    \  end\n  factors << n if n > 1\n  factors.max\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  largest_prime_divisor = nil\n  largest_prime_factor = nil\n  prime_divisors.each\
    \ do |prime_divisor|\n    if n % prime_divisor == 0\n      largest_prime_divisor\
    \ = prime_divisor\n      largest_prime_factor = n\n    end\n  end\n  return largest_prime_factor\n\
    end", "  prime_divisors = prime_divisors_of(n)\n  prime_divisors.each do |prime|\n\
    \    return prime if prime.is_a? Integer\n  end\n  2\nend", "  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  i\nend", "  factors = []\n  factor = 1\n  while n\
    \ > 1\n    factors << factor\n    factor += 1\n    n /= factor\n  end\n  factors\
    \ << factor\n  factor\nend", "  factors = []\n  i = 2\n  while i * i <= n\n  \
    \  i += 1\n  while i <= n\n    factors.push(i)\n    i += 2\n  factors.each do\
    \ |factor|\n    break if n % factor == 0\n    n /= factor\n  end\n  n\nend", " \
    \ i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    if n % prime_divisor == 0\n   \
    \   return prime_divisor\n    end\n  end\n  raise \"n must be greater than 1 and\
    \ be a prime\"\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n\
    \    i += 1\n  factors.each do |factor|\n    if n % factor == 0\n      return\
    \ factor\n    end\n  end\n  nil\nend", '  return n if n.is_a?(Integer) && n.odd?
    || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even?
    || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? ||
    n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime?
    || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? ||
    n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even?
    || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? ||
    n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? ||
    n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even?
    || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? ||
    n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime?
    || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? ||
    n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even?
    || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? ||
    n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even? ||
    n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? || n.even?
    || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even? || n.prime? ||
    n.even? || n.odd? || n.even? || n.prime? || n.even? || n.odd? || n.even', "  prime_divisors\
    \ = prime_factors(n)\n  prime_divisors.each do |prime|\n    if n % prime == 0\n\
    \      return prime\n    end\n  end\n  nil\nend", "  factors = []\n  factor =\
    \ 1\n  while n > 1\n    factors << factor\n    factor += 1\n    n /= factor\n\
    \  end\n  factors << factor\n  factor\nend", "  prime_divisors = prime_divisors(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    return prime_divisor if prime_divisor\
    \ > n\n  end\n  raise ArgumentError, \"No prime factor of #{n}\"\nend", "  factors\
    \ = []\n  factor = 1\n  while n > 1\n    if n % factor == 0\n      factors <<\
    \ factor\n      n /= factor\n    else\n      factor += 1\n    end\n  end\n  factors\
    \ << n if n > 1\n  factors.reverse\nend", "  i = 2\n  while i * i <= n\n    i\
    \ += 1\n  i\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n\
    \  while i <= n / 2\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n\
    \    if n % factor == 0\n      return factor\n    end\n  end\n  raise \"n must\
    \ be greater than 1 and a prime\"\nend", "  prime_divisor = 1\n  prime_factor\
    \ = 1\n  while prime_divisor <= n\n    prime_divisor = prime_divisor * 2\n  end\n\
    \  while prime_factor <= n\n    prime_factor = prime_divisor * 2\n    prime_divisor\
    \ = prime_divisor / 2\n  end\n  return prime_factor\nend", "  factors = []\n \
    \ i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 2\n  factors.reverse\n  factors.each do |factor|\n    if n % factor\
    \ == 0\n      return factor\n    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,primes\
    \ |>\n<| a tags=ruby,primes |>\n<code>", "  prime_divisors = prime_divisors_of(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    return prime_divisor if prime_divisor\
    \ > n\n  end\n  raise \"n must be greater than 1\"\nend", "  i = 2\n  while i\
    \ * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  while n >= i\n    factors.push(i)\n    n /= i\n  factors.push(n)\n\
    \  factors.reverse\n  factors.each do |factor|\n    return factor\n  end\n  raise\
    \ \"No prime factors found\"\nend", "  factors = []\n  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 1\n  i = 1\n\
    \  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n   \
    \ i += 1\n  factors.reverse\n  factors.each do |factor|\n    if n % factor ==\
    \ 0\n      return factor\n    end\n  end\n  nil\nend", "  factors = []\n  i =\
    \ 1\n  while i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n\
    \    while n % factor == 0\n      n /= factor\n    end\n  end\n  n\nend", "  factors\
    \ = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors\
    \ << i\n    i += 1\n  factors.max\nend", "  factors = []\n  i = 1\n  while i *\
    \ i <= n\n    i += 1\n  while n % i == 0\n    factors << i\n    n /= i\n  factors\
    \ << n\n  factors.max\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code doesn't\
    \ work. Try it with `largest_prime_factor.call(100)`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it with `largest_prime_factor.call(100)`. `factors.max` returns the\
    \ largest factor of `n`, which is the largest prime factor of `n`.\n<|/ c |>\n\
    <| c |>\nYes, it does. Try it with `largest_prime_factor.call(100)`. `factors.max`\
    \ returns the largest factor of `n`, which is the largest prime factor of `n`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `largest_prime_factor.call(100)`.\
    \ `factors.max` returns the largest factor of `n`, which is the largest prime\
    \ factor of `n`.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `largest_prime_factor.call(100)`.\
    \ `factors.max` returns the largest factor of `n`, which is the largest prime\
    \ factor of `n`.\n<|/ c |>\n<| a tags=ruby,primes |>\n<code>", "  primes = prime_factors(n)\n\
    \  primes.each do |prime|\n    return prime if prime > n\n  end\n  n\nend", " \
    \ factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n % i == 0\n\
    \    factors << i\n    n /= i\n  factors << n if n > 1\n  factors.max\nend", " \
    \ factor = 1\n  while n > 1\n    factor += 1\n    n /= factor\n  end\n  factor\n\
    end", "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n != 1\n\
    \    if n % i == 0\n      factors << i\n      n /= i\n    end\n    i += 1\n  end\n\
    \  factors << n\n  factors.max\nend", "  return n if n.is_a?(Integer) && n.odd?\
    \ && n > 2 else largest_prime_factor(n./2)\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    return prime_divisor if prime_divisor\
    \ > n\n  end\n  raise ArgumentError, \"n must be greater than 1\"\nend", "  prime_divisors\
    \ = []\n  i = 2\n  while i * i <= n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\n\
    end", "  prime_divisor = 1\n  prime_factor = 1\n  while prime_divisor < n\n  \
    \  prime_divisor = prime_divisor * prime_divisor\n    prime_factor = prime_divisor\n\
    \  end\n  while prime_factor < n\n    prime_factor = prime_factor / prime_divisor\n\
    \  end\n  prime_factor\nend", "  factors = []\n  i = 2\n  while i * i <= n\n \
    \   i += 1\n  while n >= i\n    factors.push(i)\n    n /= i\n  factors.push(n)\n\
    \  factors.reverse\n  factors.each do |factor|\n    return factor if n % factor\
    \ == 0\n  end\n  nil\nend", "  prime_divisors = []\n  i = 2\n  while i * i <=\
    \ n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\nend", "  factors\
    \ = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n != 1\n    factors.push\
    \ n\n    n /= i\n  factors.push n\n  factors.reverse\n  factors.find { |f| f >\
    \ 1 }\nend", "  factors = []\n  factor = 1\n  while n > 1\n    factors << factor\n\
    \    n /= factor\n    factor += 1\n  end\n  factors << factor\n  factor\nend",
  "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n\
    \    i += 1\n  factors.each do |factor|\n    if n % factor == 0\n      n /= factor\n\
    \      break\n    end\n  end\n  n\nend", "  factors = []\n  i = 2\n  while i *\
    \ i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n    i += 2\n  factors.reverse\n\
    \  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    i = factors.find\
    \ { |f| f * f > n }\n    break if i == nil\n    factors.delete i\n  end\n  i\n\
    end", "  prime_divisors = []\n  i = 2\n  while i * i <= n\n    prime_divisors\
    \ << i\n    i += 1\n  prime_divisors.max\nend", "  prime_divisors(n)\n  prime_divisors.reduce(:max)\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n != 1\n\
    \    factors << i\n    n /= i\n    i += 1\n  factors.last\nend\n</code>\n<|/ a\
    \ tags=ruby,primes |>\n<| c |>\nThe `factors.last` line is unnecessary. `factors`\
    \ will always have at least one element, and `factors.last` will return the last\
    \ element of `factors`.\n<|/ c |>\n<| c |>\n: I know, but I wanted to be sure\
    \ that `factors.last` was really necessary and didn't want to change it if that\
    \ wasn't necessary.\n<|/ c |>\n<| c |>\n: I added a version that doesn't use `factors.last`.\n\
    <|/ c |>\n<| c |>\n: I added a version that doesn't use `factors.last`.\n<|/ c\
    \ |>\n<| c |>\n: I added a version that doesn't use `factors.last`.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  factors = []\n  factor = 1\n  while n > 1\n    factors\
    \ << factor\n    n /= factor\n    factor += 1\n  end\n  factors.reverse\n  factors.first\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis was a great solution! I added a\
    \ couple lines to make it work for integers greater than `2**32-1`: `if n >= 2**32-1;\
    \ raise ArgumentError, \"n must be less than 2**32-1\"; end; factors = n.to_s.split(//).map\
    \ { |i| i.to_i }; factors.reduce(:*).to_i`\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n\
    \  while i * i <= n\n    i += 1\n  while n >= i\n    factors.push(i)\n    n /=\
    \ i\n  factors.push(n)\n  factors.reverse\n  factors.each do |factor|\n    return\
    \ factor if n % factor == 0\n  end\n  nil\nend", "  factors = []\n  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n    i += 2\n  factors.each\
    \ do |factor|\n    break if n % factor == 0\n    n /= factor\n  end\n  n\nend",
  "  prime_divisors = prime_divisors_of(n)\n  prime_divisors.each do |prime_divisor|\n\
    \    return prime_divisor if prime_divisor > n\n  end\n  2\nend", "  primes =\
    \ prime_factors(n)\n  primes.each do |prime|\n    return prime if prime > n\n\
    \  end\n  n\nend", "  prime_divisors = prime_divisors(n)\n  prime_divisors.each\
    \ do |prime|\n    if n % prime == 0\n      return prime\n    end\n  end\nend",
  "  i = 2\n  while i <= n / 2\n    if n % i == 0\n      break\n    i += 1\n  return\
    \ i\nend", "  primes = prime_factors(n)\n  primes.each do |prime|\n    return\
    \ prime if prime > n\n  end\n  n\nend", "  prime_divisors = prime_divisors(n)\n\
    \  largest_prime_factor = prime_divisors.max\n  prime_divisors.each do |divisor|\n\
    \    if n % divisor == 0\n      largest_prime_factor = divisor\n    end\n  end\n\
    \  largest_prime_factor\nend", "  prime_divisors = prime_factors(n)\n  largest_prime_factor\
    \ = prime_divisors.max\n  prime_divisors.each do |prime|\n    if n % prime ==\
    \ 0\n      largest_prime_factor = prime\n    end\n  end\n  largest_prime_factor\n\
    end", "  factor = 1\n  while n > 1\n    factor = (n % factor).to_i\n    n /= factor\n\
    \  end\n  factor\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i +=\
    \ 1\n  while i <= n / 2\n    if n % i == 0\n      factors << i\n      n /= i\n\
    \    end\n    i += 1\n  end\n  factors << n if n > 1\n  factors.max\nend\n</code>\n\
    <|/ a tags=ruby,primes |>\n<| c |>\n`largest_prime_factor` returns `nil` when\
    \ given `0`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out.\
    \ :)\n<|/ c |>\n<| c |>\nThanks for your answer. Could you please explain why\
    \ you used `factors.max` instead of `factors.last`?\n<|/ c |>\n<| c |>\n`factors.max`\
    \ returns the largest element in the array. `factors.last` returns the last element\
    \ in the array. Since `factors` is an array, `factors.max` returns the largest\
    \ element in the array. `factors.last` returns the last element in the array.\
    \ Since `factors` is an array, `factors.max` returns the largest element in the\
    \ array. `factors.last` returns the last element in the array. Since `factors`\
    \ is an array, `factors.max` returns the largest element in the array. `factors.last`\
    \ returns the last element in the array. Since `factors` is an array, `factors.max`\
    \ returns the largest element in the array. `factors.last` returns the last element\
    \ in the array. Since `factors` is an array, `factors.max` returns the largest\
    \ element in the array. `factors.last` returns the last element in the array.\
    \ Since `factors` is an array, `factors.max` returns the largest element in the\
    \ array. `factors.last` returns the last element in the array. Since `factors`\
    \ is an array, `factors.max` returns the largest element in the array. `factors.last`\
    \ returns the last element in the array. Since `factors` is an array, `factors.max`\
    \ returns the largest element in the array. `factors.last` returns the last element\
    \ in the array. Since `factors` is an array, `factors.max` returns the largest\
    \ element in the array. `factors.last` returns the last element in the array.\
    \ Since `factors` is an array, `factors.max` returns the largest element in the\
    \ array. `factors.last` returns the last element in the array. Since `factors`\
    \ is an array, `factors.max` returns the largest element in the array. `factors.last`\
    \ returns the last element in the array. Since `factors` is an ", "  prime_divisor\
    \ = 1\n  while n > prime_divisor\n    prime_divisor *= 2\n    n /= prime_divisor\n\
    \  end\n  n\nend", "  factors = []\n  factor = 1\n  while n > 1\n    factors <<\
    \ factor\n    n /= factor\n    factor += 1\n  end\n  factors.reverse\n  factors.first\n\
    end", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  prime_divisors =\
    \ prime_factors(n)\n  prime_divisors.each do |prime|\n    if n % prime == 0\n\
    \      return prime\n    end\n  end\n  return n\nend", "  i = 2\n  while i * i\
    \ <= n\n    i += 1\n  i\nend", "  prime_divisors = []\n  i = 2\n  while i * i\
    \ <= n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\nend", "  factors\
    \ = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n / 2\n    factors.push(i)\n\
    \    i += 2\n  factors.reverse\n  factors.find { |f| n % f == 0 }\nend", "  prime_divisors(n)\n\
    \  largest_prime = nil\n  largest_divisor = nil\n  n.times do |i|\n    prime_divisors(i)\n\
    \    largest_divisor = nil\n    prime_divisors.each do |divisor|\n      if divisor\
    \ > largest_divisor\n        largest_divisor = divisor\n        largest_prime\
    \ = i\n      end\n    end\n  end\n  return largest_prime\nend", "  return n if\
    \ n < 2 else largest_prime_factor(n / 2)\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  largest_prime_divisor = nil\n  largest_prime_factor = nil\n  prime_divisors.each\
    \ do |prime_divisor|\n    if n % prime_divisor == 0\n      largest_prime_factor\
    \ = prime_divisor\n      largest_prime_divisor = prime_divisor\n    end\n  end\n\
    \  return largest_prime_factor\nend", "  i = 2\n  while i * i <= n\n    i += 1\n\
    \  i\nend", "  factors = []\n  factor = 1\n  while n > 1\n    factors << factor\n\
    \    n /= factor\n    factor += 1\n  end\n  factors << factor\n  factor\nend",
  "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n\
    \  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n    i +=\
    \ 2\n  factors.reverse\n  factors.find { |f| n % f == 0 }\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks for your answer. I'm sorry I didn't specify that I was looking\
    \ for a solution that doesn't use any built-in functions. I edited my question\
    \ to reflect this.\n<|/ c |>\n<| c |>\n: I updated my answer with another solution\
    \ that doesn't use any built-in functions.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. I edited my question to reflect that I'm looking for a solution that\
    \ doesn't use any built-in functions. I appreciate your effort though.\n<|/ c\
    \ |>\n<| c |>\n: I updated my answer with another solution that doesn't use any\
    \ built-in functions.\n<|/ c |>\n<| c |>\nThanks for your answer. I edited my\
    \ question to reflect that I'm looking for a solution that doesn't use any built-in\
    \ functions. I appreciate your effort though.\n<|/ c |>\n<| a |>\n<code>", " \
    \ prime_divisors = []\n  i = 2\n  while i * i <= n\n    prime_divisors << i\n\
    \    i += 1\n  prime_divisors.max\nend", "  prime_divisors = prime_divisors_of(n)\n\
    \  prime_divisors.each do |prime_divisor|\n    if n % prime_divisor == 0\n   \
    \   return prime_divisor\n    end\n  end\n  raise \"n must be greater than 1 and\
    \ be a prime\"\nend", "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n\
    \  while n % i == 0\n    factors << i\n    n /= i\n  factors << n\n  factors.max\n\
    end\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nThis doesn't work. Try it with\
    \ `largest_prime_factor.call(13195)`\n<|/ c |>\n<| c |>\n: I see what you mean.\
    \ I've updated the answer to include a fix for that.\n<|/ c |>\n<| c |>\n: I added\
    \ a more efficient algorithm that doesn't require the use of `Integer#prime?`.\n\
    <|/ c |>\n<| c |>\n: I added a more efficient algorithm that doesn't require the\
    \ use of `Integer#prime?`.\n<|/ c |>\n<| c |>\n: I added a more efficient algorithm\
    \ that doesn't require the use of `Integer#prime?`.\n<|/ c |>\n<| a tags=ruby,primes\
    \ |>\n<code>", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i * i <= n\n    i\
    \ += 1\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while\
    \ i * i <= n\n    i += 1\n  i = 2\n  while i <= n\n    factors.push(i)\n    i\
    \ += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while\
    \ i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n\
    \  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n  \
    \  factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n\
    \  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n  \
    \  factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n\
    \  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n  \
    \  factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n\
    \  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n  \
    \  factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n\
    \  while i <= n\n    factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n  \
    \  factors.push(i)\n    i += 2\n  i = 2\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  i = 2\n  ", "  prime_divisors(n)\n  largest_prime = nil\n  largest_prime_factor\
    \ = nil\n  n.times do |i|\n    prime_divisors(i)\n    prime_divisors.each do |j|\n\
    \      if largest_prime == nil or largest_prime > j\n        largest_prime = j\n\
    \        largest_prime_factor = i\n      end\n    end\n  end\n  return largest_prime_factor\n\
    end", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", "  factors = []\n \
    \ factor = 1\n  while n > 1\n    if n % factor == 0\n      factors << factor\n\
    \      n /= factor\n    else\n      factor += 1\n    end\n  end\n  factors <<\
    \ n if n > 1\n  factors.reverse\nend", "  factors = []\n  i = 2\n  while i * i\
    \ <= n\n    i += 1\n  while n % i == 0\n    n /= i\n    factors.push(i)\n  factors.reverse\n\
    \  factors.find { |f| f > n }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like\
    \ your solution, but I believe it can be improved by using [prime decomposition](http://en.wikipedia.org/wiki/Prime_number_theorem#Prime_decomposition).\
    \ Also, you could use [the Sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\
    <|/ c |>\n<| c |>\nI agree that prime decomposition would be a better solution,\
    \ but I wanted to keep this as simple as possible for the OP.\n<|/ c |>\n<| c\
    \ |>\nI agree that prime decomposition would be a better solution, but I wanted\
    \ to keep this as simple as possible for the OP.\n<|/ c |>\n<| c |>\nI agree that\
    \ prime decomposition would be a better solution, but I wanted to keep this as\
    \ simple as possible for the OP.\n<|/ c |>\n<| c |>\nI agree that prime decomposition\
    \ would be a better solution, but I wanted to keep this as simple as possible\
    \ for the OP.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  prime_divisors = []\n \
    \ i = 2\n  while i * i <= n\n    prime_divisors << i\n    i += 1\n  prime_divisors.max\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i\
    \ += 1\n  factors.each do |factor|\n    if n % factor == 0\n      break\n    end\n\
    \  end\n  factor\nend", "  prime_numbers = prime_numbers_up_to_n(n)\n  prime_numbers.each\
    \ do |prime|\n    return prime if prime.is_prime?\n  end\n  2\nend", "  return\
    \ n if n.is_a?(Integer) && n.odd? || n.prime? && n.factor? && n.factor > 1 &&\
    \ (n % n.factor).zero? else n.prime? ? n : largest_prime_factor(n.factor)\nend",
  "  return n if n.is_a?(Integer) && n.odd? && n.prime? && n > 1 &&\n    n.factor?\
    \ && n.factor > 1 &&\n    n.factor > n.to_s.split(//).reduce(:+).to_i\n  else\n\
    \    n.to_s.split(//).reduce(:+).to_i\n  end\nend", "  factors = []\n  i = 2\n\
    \  while i * i <= n\n    i += 1\n  while n % i == 0\n    factors << i\n    n /=\
    \ i\n  factors << n\n  factors.max\nend", "  factors = []\n  i = 2\n  while i\
    \ * i <= n\n    factors << i\n    i += 1\n  factors.max\nend", "  factors = []\n\
    \  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each\
    \ do |factor|\n    if n % factor == 0\n      return factor\n    end\n  end\n \
    \ nil\nend", "  factors = []\n  i = 1\n  while i <= n do\n    factors.push i\n\
    \    i = i * 2\n  end\n  factors.push n\n  factors.sort { |a, b| b <=> a }\n \
    \ factors.last\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nI like your\
    \ solution, but I believe it can be optimized a bit. For example, `factors.push\
    \ i` can be replaced with `factors.push(i)`, because `i` is already an `Integer`.\
    \ And `factors.push n` can be replaced with `factors.push(n)`, because `n` is\
    \ already an `Integer`. And `factors.sort { |a, b| b <=> a }` can be replaced\
    \ with `factors.sort`, because `<=>` is already defined for `Integer`.\n<|/ c\
    \ |>\n<| c |>\nYes, I agree with your optimizations. I didn't want to change too\
    \ much from the original code, but I guess it would be better to do that anyway.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI agree with your optimizations. I didn't want to\
    \ change too much from the original code, but I guess it would be better to do\
    \ that anyway. Thanks.\n<|/ c |>\n<| c |>\nI agree with your optimizations. I\
    \ didn't want to change too much from the original code, but I guess it would\
    \ be better to do that anyway. Thanks.\n<|/ c |>\n<| c |>\nI agree with your optimizations.\
    \ I didn't want to change too much from the original code, but I guess it would\
    \ be better to do that anyway. Thanks.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 2\n\
    \  factors.each do |factor|\n    if n % factor == 0\n      return factor\n   \
    \ end\n  end\n  return n\nend", "  prime_divisors = prime_divisors_of(n)\n  prime_divisors.each\
    \ do |prime_divisor|\n    if n % prime_divisor == 0\n      return prime_divisor\n\
    \    end\n  end\n  raise \"n must be greater than 1\"\nend", "  return n if n\
    \ <= 1 || !prime?(n) \n  i = 2\n  while i * i <= n\n    i += 1\n  i\nend", " \
    \ factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\n    factors.push(i)\n\
    \    i += 2\n  factors.each do |factor|\n    if n % factor == 0\n      return\
    \ factor\n    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c\
    \ |>\nI like your solution, but I wonder if there is a way to avoid the while\
    \ loop and just use recursion.\n<|/ c |>\n<| c |>\n: I added a recursive solution\
    \ to my answer.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to avoid the while loop and just use recursion.\n<|/ c |>\n<| c |>\n\
    : I added a recursive solution to my answer.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to avoid the while loop and just use recursion.\n\
    <|/ c |>\n<| a |>\n<code>", "  factors = []\n  i = 2\n  while i * i <= n\n   \
    \ factors.push(i)\n    i += 1\n  factors.each do |factor|\n    if n % factor ==\
    \ 0\n      n /= factor\n      break\n    end\n  end\n  n\nend", "  prime_divisors(n)\n\
    \  largest_prime = nil\n  largest_divisor = nil\n  n.times do |i|\n    prime_divisors(i)\n\
    \    largest_divisor = nil\n    prime_divisors.each do |j|\n      if largest_divisor\
    \ == nil\n        largest_divisor = j\n      elsif largest_divisor > j\n     \
    \   largest_divisor = j\n      end\n    end\n    if largest_divisor != nil\n \
    \     largest_prime = largest_divisor\n    end\n  end\n  return largest_prime\n\
    end", "  return n if n.is_a?(Integer) && n.odd? && n > 2 else largest_prime_factor(n./2)\n\
    end", "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n  while n % i\
    \ == 0\n    n /= i\n    factors << i\n  factors << n\n  factors.max\nend", " \
    \ factor = 1\n  while n > 1\n    factor = (n % factor).to_i\n    n /= factor\n\
    \  end\n  factor\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your\
    \ code works, but I still don't understand why my code doesn't work. Could you\
    \ please explain why my code doesn't work?\n<|/ c |>\n<| c |>\nYour code doesn't\
    \ work because you didn't understand how `to_i` works. `to_i` converts a number\
    \ to a `Fixnum`. `Fixnum` doesn't have a `/` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_f`\
    \ method. `Fixnum` doesn't have a `to_s` method. `Fixnum` doesn't have a `to_i`\
    \ method. `Fixnum` doesn't have a `to_s` method. `", "  prime_numbers = []\n \
    \ i = 2\n  while i * i <= n\n    prime_numbers.push(i)\n    i += 2\n  prime_numbers.each\
    \ do |prime|\n    prime_factor = n / prime\n    if prime_factor > 1\n      return\
    \ prime_factor\n    end\n  end\n  return n\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,primes |>\n<code>", "  factors = []\n  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  while n % i == 0\n    factors << i\n    n /= i\n  factors <<\
    \ n if n > 1\n  factors.max\nend", "  i = 2\n  while i * i <= n\n    i += 1\n\
    \  i\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
