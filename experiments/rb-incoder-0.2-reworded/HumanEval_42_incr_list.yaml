name: HumanEval_42_incr_list
language: rb
prompt: "# Return array with elements incremented by 1.\n# >>> incr_list.call([1,\
  \ 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6,\
  \ 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n\
  \    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3,\
  \ 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\n\
  end\n"
completions: ["  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each_with_index\
    \ do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each_with_index do |e,\
    \ i|\n    l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each do |x|\n\
    \    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n    l[i] = l[i]\
    \ + 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n    l[i] = l[i] + 1\n\
    \  end\n  l\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work\
    \ if you have a negative number in the array. `incr_list([-1, -2, -3]) #=> [-2,\
    \ -3, -4]`\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't. :-) I said it wouldn't\
    \ work if you have a negative number in the array. `incr_list([-1, -2, -3]) #=>\
    \ [-2, -3, -4]`\n<|/ c |>\n<| c |>\nI didn't say it wouldn't work. I said it wouldn't\
    \ work if you have a negative number in the array. `incr_list([-1, -2, -3]) #=>\
    \ [-2, -3, -4]`\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it\
    \ wouldn't work if you have a negative number in the array. `incr_list([-1, -2,\
    \ -3]) #=> [-2, -3, -4]`\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work.\
    \ I said it wouldn't work if you have a negative number in the array. `incr_list([-1,\
    \ -2, -3]) #=> [-2, -3, -4]`\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  l.each_with_index\
    \ do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each_with_index do |e,\
    \ i|\n    l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This doesn't work if the array is empty. `incr_list([1,2])` returns `[2,3]` instead\
    \ of `[1,2]`.\n<|/ c |>\n<| c |>\n, good catch. Fixed it.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l.each_with_index do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\n\
    end", "  l.each_with_index { |e, i| l[i] = l[i] + 1 }\n  l\nend", "  l.each_with_index\
    \ do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each do |x|\n    next\
    \ if x == 0\n    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n  \
    \  l.insert(i, i + 1)\n  end\nend", "  l.each do |x|\n    x += 1\n  end\n  l\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if you have a list\
    \ of hashes, as hashes aren't mutable. `incr_hash([{a: 1}, {b: 2}])` returns `[{a:\
    \ 2}, {b: 2}]`\n<|/ c |>\n<| c |>\n: I agree, hashes aren't mutable. I've updated\
    \ my answer to include a version that works with hashes.\n<|/ c |>\n<| c |>\n\
    I believe this should be the accepted answer. `each_with_object` is designed for\
    \ this sort of thing.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list\
    \ of hashes, as hashes aren't mutable. `incr_hash([{a: 1}, {b: 2}])` returns `[{a:\
    \ 2}, {b: 2}]`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each_with_index do\
    \ |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n\
    \    l[i] = l[i] + 1\n  end\n  l\nend", "  l.each do |i|\n    i = i + 1\n  end\n\
    \  l\nend", "  l.each_with_index do |e, i|\n    l.delete_at(i)\n    l.insert(i,\
    \ e + 1)\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", " \
    \ l.each_with_index do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your use of each_with_index but I don't think\
    \ it works in my case. My list has duplicates and I only want to increment the\
    \ duplicates. So I should get [2, 3, 4] instead of [2, 3, 3, 2, 3, 3, 9, 0, 123].\
    \ Thanks for your help though.\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a version that does what you want.\n<|/ c |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
