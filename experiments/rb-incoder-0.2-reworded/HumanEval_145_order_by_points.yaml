name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given array of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ array.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split(\"\
    \").each do |i|\n      nums.delete_at(i.to_i)\n    end\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -99\n    break if num == -999\n    break if num == -9999\n    break if num\
    \ == -9999999\n    break if num == -99999999\n    break if num == -9999999999\n\
    \    break if num == -99999999999\n    break if num == -99999999999999\n    break\
    \ if num == -999999999999999\n    break if num == -999999999999999999\n    break\
    \ if num == -9999999999999999999\n    break if num == -9999999999999999999999\n\
    \    break if num == -99999999999999999999999\n    break if num == -99999999999999999999999999\n\
    \    break if num == -999999999999999999999999999\n    break if num == -999999999999999999999999999999\n\
    \    break if num == -9999999999999999999999999999999\n    break if num == -9999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999\n    break if num ==\
    \ -99999999999999999999999999999999999999\n    break if num == -999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999\n    break if\
    \ num == -9999999999999999999999999999999999999999999\n    break if num == -9999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999\n    break\
    \ if num == -99999999999999999999999999999999999999999999999999\n    break if\
    \ num == -999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -999999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -9999999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -9999999999999999999999999999999999999999999999999999999999\n    break if\
    \ num == -99999999999999999999999999999999999999999999999999999999999\n    break\
    \ if num == -99999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.to_i\n    nums[i] = nums[i] if nums[i] > 0\n    nums[i]\
    \ = nums[i] if nums[i] < 0\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are negative numbers in the array. `[2,-4,-6,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    while num\
    \ > 0\n      sum += num % 10\n      num /= 10\n    end\n    break if sum == num\n\
    \    num = sum\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i] + digits\n    end\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work for negative numbers. `order_by_points.call([-10, -9, -8, -7,\
    \ -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])` returns `[-10, -9, -8,\
    \ -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n<|/ c |>\n<| c\
    \ |>\nYes, it does. I tested it before posting. I just tested it again and it\
    \ works fine. `order_by_points.call([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])` returns `[-10, -9, -8, -7, -6, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n<|/ c |>\n<| c |>\nAh, I missed the part\
    \ where you said \"Note: if there are several items with similar sum of their\
    \ digits, order them based on their index in original array.\" I thought you meant\
    \ \"if there are several items with similar sum of their digits, order them based\
    \ on their sum.\" I guess I misunderstood your original comment. Sorry.\n<|/ c\
    \ |>\n<| c |>\nNo problem. Thanks for your help.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -num\n    break if num == num\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n,\
    \ i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i]\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work if there are negative numbers in the array. Try `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`\n<|/ c |>\n<| c |>\n: I added a note about negative numbers.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI added a note about negative numbers. Thanks.\n\
    <|/ c |>\n<| c |>\nI added a note about negative numbers. Thanks.\n<|/ c |>\n\
    <| c |>\nI added a note about negative numbers. Thanks.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if\
    \ n.to_s.size != n.to_s.chars.map(&:to_i).sum\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ Your solution is very similar to mine, but I wanted to avoid using loops. I\
    \ guess I should use loops anyway because I cannot use any built-in functions.\
    \ Thanks again.\n<|/ c |>\n<| c |>\nI guess you mean `nums.sort!` instead of `nums.sort!.reverse!`\n\
    <|/ c |>\n<| c |>\nYes, I meant `nums.sort!` instead of `nums.sort!.reverse!`\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map!\
    \ {|x| x.abs} if nums.any?\n  nums\nend", "  nums.sort!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n\
    \    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum == num.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if the array contains negative numbers. `order_by_points.call([-10,\
    \ -20, -30])` returns `[-10, -30, -20]`\n<|/ c |>\n<| c |>\nI added a note to\
    \ the answer\n<|/ c |>\n<| c |>\nThis doesn't work if the array contains negative\
    \ numbers. `order_by_points.call([-10, -20, -30])` returns `[-10, -30, -20]`\n\
    <|/ c |>\n<| c |>\nI added a note to the answer\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the array contains negative numbers. `order_by_points.call([-10, -20,\
    \ -30])` returns `[-10, -30, -20]`\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.\n    values.\n    map {\
    \ |v| v.inject(:+) }.\n    sort_by { |n| -n }\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like your solution, but I believe it can be made more concise by using\
    \ the `group_by` method on the `Array` class. See my answer below.\n<|/ c |>\n\
    <| c |>\n: Yes, it can be made more concise, but I find it more difficult to read.\
    \ Also, `group_by` does not guarantee any particular order, so it cannot be used\
    \ to sort by sum.\n<|/ c |>\n<| c |>\nI agree with you. My solution was more of\
    \ a \"proof of concept\" than a solution. Your solution is much more elegant and\
    \ concise. Thanks for sharing your solution!\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    sum = 0\n    while num > 0\n      sum += num % 10\n\
    \      num /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    break if num == 0 && nums.size == i\n\
    \    nums[i] = num if nums.sum.to_s == num.to_s.to_s\n  end\nend", "  nums.sort!\n\
    \  nums.group_by do |n|\n    n.to_s.chars.map { |c| c.to_i }.inject(:+).abs\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
