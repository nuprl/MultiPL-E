name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given array of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ array.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split(\"\
    \").each do |i|\n      nums.delete_at(i.to_i)\n    end\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -99\n    break if num == -999\n    break if num == -9999\n    break if num\
    \ == -9999999\n    break if num == -99999999\n    break if num == -9999999999\n\
    \    break if num == -99999999999\n    break if num == -99999999999999\n    break\
    \ if num == -999999999999999\n    break if num == -999999999999999999\n    break\
    \ if num == -9999999999999999999\n    break if num == -9999999999999999999999\n\
    \    break if num == -99999999999999999999999\n    break if num == -99999999999999999999999999\n\
    \    break if num == -999999999999999999999999999\n    break if num == -999999999999999999999999999999\n\
    \    break if num == -9999999999999999999999999999999\n    break if num == -9999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999\n    break if num ==\
    \ -99999999999999999999999999999999999999\n    break if num == -999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999\n    break if\
    \ num == -9999999999999999999999999999999999999999999\n    break if num == -9999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999\n    break\
    \ if num == -99999999999999999999999999999999999999999999999999\n    break if\
    \ num == -999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -999999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -9999999999999999999999999999999999999999999999999999999\n    break if num\
    \ == -9999999999999999999999999999999999999999999999999999999999\n    break if\
    \ num == -99999999999999999999999999999999999999999999999999999999999\n    break\
    \ if num == -99999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.to_i\n    nums[i] = nums[i] if nums[i] > 0\n    nums[i]\
    \ = nums[i] if nums[i] < 0\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are negative numbers in the array. `[2,-4,-6,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-5,-7,-9,-10,-3,-",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    while num\
    \ > 0\n      sum += num % 10\n      num /= 10\n    end\n    break if sum == num\n\
    \    num = sum\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i] + digits\n    end\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work for negative numbers. `order_by_points.call([-10, -9, -8, -7,\
    \ -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])` returns `[-10, -9, -8,\
    \ -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n<|/ c |>\n<| c\
    \ |>\nYes, it does. I tested it before posting. I just tested it again and it\
    \ works fine. `order_by_points.call([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])` returns `[-10, -9, -8, -7, -6, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n<|/ c |>\n<| c |>\nAh, I missed the part\
    \ where you said \"Note: if there are several items with similar sum of their\
    \ digits, order them based on their index in original array.\" I thought you meant\
    \ \"if there are several items with similar sum of their digits, order them based\
    \ on their sum.\" I guess I misunderstood your original comment. Sorry.\n<|/ c\
    \ |>\n<| c |>\nNo problem. Thanks for your help.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -num\n    break if num == num\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n,\
    \ i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i]\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work if there are negative numbers in the array. Try `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`\n<|/ c |>\n<| c |>\n: I added a note about negative numbers.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI added a note about negative numbers. Thanks.\n\
    <|/ c |>\n<| c |>\nI added a note about negative numbers. Thanks.\n<|/ c |>\n\
    <| c |>\nI added a note about negative numbers. Thanks.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if\
    \ n.to_s.size != n.to_s.chars.map(&:to_i).sum\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ Your solution is very similar to mine, but I wanted to avoid using loops. I\
    \ guess I should use loops anyway because I cannot use any built-in functions.\
    \ Thanks again.\n<|/ c |>\n<| c |>\nI guess you mean `nums.sort!` instead of `nums.sort!.reverse!`\n\
    <|/ c |>\n<| c |>\nYes, I meant `nums.sort!` instead of `nums.sort!.reverse!`\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map!\
    \ {|x| x.abs} if nums.any?\n  nums\nend", "  nums.sort!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n\
    \    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum == num.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if the array contains negative numbers. `order_by_points.call([-10,\
    \ -20, -30])` returns `[-10, -30, -20]`\n<|/ c |>\n<| c |>\nI added a note to\
    \ the answer\n<|/ c |>\n<| c |>\nThis doesn't work if the array contains negative\
    \ numbers. `order_by_points.call([-10, -20, -30])` returns `[-10, -30, -20]`\n\
    <|/ c |>\n<| c |>\nI added a note to the answer\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the array contains negative numbers. `order_by_points.call([-10, -20,\
    \ -30])` returns `[-10, -30, -20]`\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.\n    values.\n    map {\
    \ |v| v.inject(:+) }.\n    sort_by { |n| -n }\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like your solution, but I believe it can be made more concise by using\
    \ the `group_by` method on the `Array` class. See my answer below.\n<|/ c |>\n\
    <| c |>\n: Yes, it can be made more concise, but I find it more difficult to read.\
    \ Also, `group_by` does not guarantee any particular order, so it cannot be used\
    \ to sort by sum.\n<|/ c |>\n<| c |>\nI agree with you. My solution was more of\
    \ a \"proof of concept\" than a solution. Your solution is much more elegant and\
    \ concise. Thanks for sharing your solution!\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    sum = 0\n    while num > 0\n      sum += num % 10\n\
    \      num /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    break if num == 0 && nums.size == i\n\
    \    nums[i] = num if nums.sum.to_s == num.to_s.to_s\n  end\nend", "  nums.sort!\n\
    \  nums.group_by do |n|\n    n.to_s.chars.map { |c| c.to_i }.inject(:+).abs\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each_with_index do |n, i|\n    next if i == 0\n    n.to_s.chars.sort_by\
    \ { |s| s.to_i }.each { |s| nums[i] = n if s == s.to_i }\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do this without converting each number to string?\n<|/\
    \ c |>\n<| c |>\n: I added a solution without converting each number to string.\n\
    <|/ c |>\n<| c |>\n: I added a solution without converting each number to string.\n\
    <|/ c |>\n<| c |>\n: I added a solution without converting each number to string.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map do |num|\n    num = num.to_i\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits.inject(0) do |sum, digit|\n      sum + digit\n    end\n  end\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n    j =\
    \ num.to_s.chars.map(&:to_i).inject(:+)\n    next if i == j\n    nums[i], nums[j]\
    \ = nums[j], nums[i]\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like your solution, but I believe it can be made more efficient by\
    \ avoiding `to_s` and `to_i` calls on each element of the array. `nums.sort.reverse.each_with_index.map\
    \ { |n, i| [n, i] }.sort_by(&:first).map(&:last)` should do the trick.\n<|/ c\
    \ |>\n<| c |>\n: Yes, I agree with you. Thanks for your suggestion.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I believe it can be made more efficient by\
    \ avoiding `to_s` and `to_i` calls on each element of the array. `nums.sort.reverse.each_with_index.map\
    \ { |n, i| [n, i] }.sort_by(&:first).map(&:last)` should do the trick.\n<|/ c\
    \ |>\n<| c |>\n: Yes, I agree with you. Thanks for your suggestion.\n<|/ c |>\n\
    <| c |>\n: I added a more efficient solution to my answer.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if\
    \ n.to_s.size < 2\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).reduce(:+)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums.sum != i\n\
    \    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n\
    \    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n \
    \   if digits.zero?\n      nums[i] = n\n    else\n      nums[i] = [n, i] if nums[i].nil?\n\
    \    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    nums[i] = nums[i] if nums[i].to_s.size < nums[i].to_s.size\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if num == -1\n    break if num == -num\n    break\
    \ if num == num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map!\
    \ {|n| n.to_i}\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    sum = 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n\
    \    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    sum = 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n\
    \    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n  \
    \  sum = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n    end\n   \
    \ sum > 0 ? nums.unshift(n) : nums.unshift(-n)\n  end\n  nums\nend", "  nums.sort!\
    \ do |a, b|\n    digits = a.to_s.chars.map(&:to_i).reduce(:+)\n    digits = b.to_s.chars.map(&:to_i).reduce(:+)\
    \ - digits\n    if digits == 0\n      a.to_i <=> b.to_i\n    else\n      digits\
    \ <=> b.to_i <=> a.to_i\n    end\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work if you have negative numbers. Try `order_by_points.call([-10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n\
    <| c |>\nI added a version that works with negative numbers. I tested it on ruby\
    \ 2.4.\n<|/ c |>\n<| c |>\nI added a version that works with negative numbers.\
    \ I tested it on ruby 2.4.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ negative numbers. I tested it on ruby 2.4.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ # convert to positive integer\n    digits = digits.to_s # convert to string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse ", " \
    \ nums.sort! do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte { |i| sum1 += i }\n\
    \    b.each_byte { |i| sum2 += i }\n    sum1 < sum2\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] = nums[i].to_i\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if nums.sum == num\n    nums.delete_at(nums.index(num))\n  end\n  nums\n\
    end", "  nums.sort! do |a, b|\n    sum1 = sum2 = a + b\n    sum1.zero? ? sum2\
    \ : sum1\n  end\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits\
    \ = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_i\n    if nums[i] == n\n      nums[i] = n\n      nums[i + 1] = digits\n\
    \    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n  \
    \  break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n   \
    \ break if n.to_s.chars.map(&:to_i).sum > n.to_s.chars.map(&:to_i).sum\n  end\n\
    \  nums\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `order_by_points.call([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9])` returns `[-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9]`\n<|/ c |>\n<| c |>\nI added a fix for negative numbers. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  "  nums.sort! { |a, b| sum_of_digits(a) <=> sum_of_digits(b) }\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = a.to_s.chars.map(&:to_i).inject(:+)\n    sum2 = b.to_s.chars.map(&:to_i).inject(:+)\n\
    \    sum1 == sum2 ? a.to_i <=> b.to_i : sum1 < sum2\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis doesn't work if there are two or more numbers with\
    \ the same sum.\n<|/ c |>\n<| c |>\nYes, I know. That's why I wrote \"if there\
    \ are several items with similar sum of their digits, order them based on their\
    \ index in original array\".\n<|/ c |>\n<| c |>\nI see what you mean. Yes, I see\
    \ that now. Thanks for pointing that out.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_s }\nend", "  nums.sort! do |a, b|\n \
    \   sum1 = a.to_s.split(\"\").map(&:to_i).inject(:+)\n    sum2 = b.to_s.split(\"\
    \").map(&:to_i).inject(:+)\n    sum1 < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ 0 && !nums.include?(num)\n      nums.unshift(num)\n    end\n  end\n  nums\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your solution is very\
    \ elegant and works perfectly for me. Thanks again!\n<|/ c |>\n<| c |>\nI added\
    \ a more efficient solution that doesn't require sorting.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  nums.sort!\n  nums.each_with_index do |num, i|\n    nums[i]\
    \ = num if num.zero?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map!\
    \ {|n| n.to_i}\n  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n\
    \    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+) unless\
    \ digits.empty?\n    digits = digits.abs if digits.zero?\n    digits = digits.max\n\
    \    digits = digits.zero? ? 1 : digits\n    nums[i] = [digits, i]\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num ==\
    \ 0 || num.zero?\n    break if num.odd?\n    break if num.zero?\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(0) {|sum, digit| sum + digit}\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if nums.count(num)\
    \ > 1\n      nums.delete_at(nums.index(num))\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    sum_a = a.to_s.split(\"\
    \").map(&:to_i).inject(:+)\n    sum_b = b.to_s.split(\"\").map(&:to_i).inject(:+)\n\
    \    sum_a <=> sum_b\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.to_i\n    break if i == 0\n    nums.delete_at(i)\n   \
    \ nums.insert(i, num)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| c |>\nI like this solution, but I wonder\
    \ if it can be made more efficient. For example, `sort_by` needs to iterate over\
    \ the entire array even if the first element is the same. `sort_by!` needs to\
    \ iterate over the entire array even if the first element is the same. `sort_by!`\
    \ needs to iterate over the entire array even if the first element is the same.\
    \ `sort_by!` needs to iterate over the entire array even if the first element\
    \ is the same. `sort_by!` needs to iterate over the entire array even if the first\
    \ element is the same. `sort_by!` needs to iterate over the entire array even\
    \ if the first element is the same. `sort_by!` needs to iterate over the entire\
    \ array even if the first element is the same. `sort_by!` needs to iterate over\
    \ the entire array even if the first element is the same. `sort_by!` needs to\
    \ iterate over the entire array even if the first element is the same. `sort_by!`\
    \ needs to iterate over the entire array even if the first element is the same.\
    \ `sort_by!` needs to iterate over the entire array even if the first element\
    \ is the same. `sort_by!` needs to iterate over the entire array even if the first\
    \ element is the same. `sort_by!` needs to iterate over the entire array even\
    \ if the first element is the same. `sort_by!` needs to iterate over the entire\
    \ array even if the first element is the same. `sort_by!` needs to iterate over\
    \ the entire array even if the first element is the same. `sort_by!` needs to\
    \ iterate over the entire array even if the first element is the same. `sort_by!`\
    \ needs to iterate over the entire array even if the first element is the same.\
    \ `sort_by!` needs to iterate over the entire array even if the first element\
    \ is the same. `sort_by!` needs to iterate over the entire array even if the first\
    \ element is the same. `sort_by!` needs to iterate over the entire array even\
    \ if the first element is the same. `sort_by!` needs to iterate over the entire\
    \ array even if the first element is the same. `sort_by!` needs to iterate over\
    \ the entire array even if the first element is the same. `sort_by!` needs to\
    \ iterate over the entire array even if the first element is the same. `sort_by!`\
    \ needs to iterate over the entire array even if the first element is the same.\
    \ `sort_by!` needs to iterate over the entire array even if the first element\
    \ is the same. `sort_by!` needs to iterate over the entire array even if the first\
    \ element is the same. `sort_by!` ", "  nums.sort! do |a, b|\n    sum1 = a.to_s.chars.map(&:to_i).sum\n\
    \    sum2 = b.to_s.chars.map(&:to_i).sum\n    sum1 > sum2 ? 1 : sum1 < sum2 ?\
    \ -1 : 0\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. `order_by_points.call([-1, -10, -20, -30])` returns `[-10, -20, -30,\
    \ -1]` instead of `[-1, -10, -20, -30]`.\n<|/ c |>\n<| c |>\nI fixed the bug.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work if there are two numbers with the same sum.\n\
    <|/ c |>\n<| c |>\nIt does. `[1, 1, 1]` sorts to `[1, 1, 1]` because `1` sorts\
    \ to `1` before `1` sorts to `1`. `[1, 1]` sorts to `[1, 1]` because `1` sorts\
    \ to `1` before `1` sorts to `1`.\n<|/ c |>\n<| c |>\nI didn't know that. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\nIt does. `[1, 1, 1]` sorts to\
    \ `[1, 1, 1]` because `1` sorts to `1` before `1` sorts to `1`. `[1, 1]` sorts\
    \ to `[1, 1]` because `1` sorts to `1` before `1` sorts to `1`.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.unshift(num)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, index|\n\
    \    nums[index] = num if nums.sum.to_i == num\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] = [n] + nums[i].divmod(10)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n\
    \  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    if digits.zero?\n      nums[i] = n\n\
    \      next\n    end\n    digits = digits.to_s.reverse\n    digits = digits.reverse\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_s.reverse\n\
    \    digits = digits.reverse\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    if digits > nums[i]\n      nums[i] = n\n    end\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    break if nums.sum == n\n    nums.delete_at(0)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two or more items with the same\
    \ sum. For example, `order_by_points.call([1, 11, -1, -11, -12])` returns `[-1,\
    \ -11, 1, -12, 11]`.\n<|/ c |>\n<| c |>\nI agree with you. I've added a note to\
    \ the answer.\n<|/ c |>\n<| c |>\nI like the `each_with_index` solution. Nice!\n\
    <|/ c |>\n<| c |>\nI like the `each_with_index` solution. Nice!\n<|/ c |>\n<|\
    \ a dscore=4 |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n  \
    \  digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n   \
    \ if digits > nums[i]\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like your solution, however it fails for negative numbers. `order_by_points.call([-4,\
    \ -4, -4, -4, -4])` returns `[4, 4, 4, 4, 4]` instead of `[-4, -4, -4, -4, -4]`.\n\
    <|/ c |>\n<| c |>\nI added a fix for negative numbers. I hope it helps.\n<|/ c\
    \ |>\n<| c |>\nI like your solution, however it fails for negative numbers. `order_by_points.call([-4,\
    \ -4, -4, -4, -4])` returns `[4, 4, 4, 4, 4]` instead of `[-4, -4, -4, -4, -4]`.\n\
    <|/ c |>\n<| c |>\nI added a fix for negative numbers. I hope it helps.\n<|/ c\
    \ |>\n<| a tags=ruby,sorting |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if n.zero?\n    break\
    \ if n.odd?\n    break if n.even?\n  end\n  nums\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if num.digits.sum < num.digits.max\n  end\nend",
  "  nums.sort! do |a, b|\n    sum1 = a + b\n    sum2 = b + a\n    sum1 == sum2 ?\
    \ a : b\n  end\nend", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte\
    \ { |x| sum1 += x }\n    b.each_byte { |x| sum2 += x }\n    sum1 < sum2 ? -1 :\
    \ sum1 > sum2 ? 1 : 0\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without using recursion.\n\
    <|/ c |>\n<| c |>\n: I added a solution without recursion.\n<|/ c |>\n<| c |>\n\
    : I added a solution without recursion.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ without recursion.\n<|/ c |>\n<| c |>\n: I added a solution without recursion.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 2 if digits.even?\n    digits = 3 if digits.odd?\n    digits = 4 if digits.odd?\n\
    \    digits = 5 if digits.odd?\n    digits = 6 if digits.odd?\n    digits = 7\
    \ if digits.odd?\n    digits = 8 if digits.odd?\n    digits = 9 if digits.odd?\n\
    \    digits = 10 if digits.odd?\n    digits = 11 if digits.odd?\n    digits =\
    \ 12 if digits.odd?\n    digits = 13 if digits.odd?\n    digits = 14 if digits.odd?\n\
    \    digits = 15 if digits.odd?\n    digits = 16 if digits.odd?\n    digits =\
    \ 17 if digits.odd?\n    digits = 18 if digits.odd?\n    digits = 19 if digits.odd?\n\
    \    digits = 20 if digits.odd?\n    digits = 21 if digits.odd?\n    digits =\
    \ 22 if digits.odd?\n    digits = 23 if digits.odd?\n    digits = 24 if digits.odd?\n\
    \    digits = 25 if digits.odd?\n    digits = 26 if digits.odd?\n    digits =\
    \ 27 if digits.odd?\n    digits = 28 if digits.odd?\n    digits = 29 if digits.odd?\n\
    \    digits = 30 if digits.odd?\n    digits = 31 if digits.odd?\n    digits =\
    \ 32 if digits.odd?\n    digits = 33 if digits.odd?\n    digits = 34 if digits.odd?\n\
    \    digits = 35 if digits.odd?\n    digits = 36 if digits.odd?\n    digits =\
    \ 37 if digits.odd?\n    digits = 38 if digits.odd?\n    digits = 39 if digits.odd?\n\
    \    digits = 40 if digits.odd?\n    digits = 41 if digits.odd?\n    digits =\
    \ 42 if digits.odd?\n    digits = 43 if digits.odd?\n    digits = 44 if digits.odd?\n\
    \    digits = 45 if digits.odd?\n    digits = 46 if digits.odd?\n    digits =\
    \ 47 if digits.odd?\n    digits = 48 if digits.odd?\n    digits = 49 if digits.odd?\n\
    \    digits = 50 if digits.odd?\n    digits = 51 if digits.odd?\n    ", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete_at(nums.index(num))\n\
    \  end\n  nums\nend", "  nums.sort! { |a, b| a.to_s + b.to_s }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your answer. Your solution works fine for small\
    \ arrays, but for large arrays, it takes too much time to sort them.\n<|/ c |>\n\
    <| c |>\nI added a solution that sorts them in O(n) time.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. Your solution works fine for small arrays, but for large\
    \ arrays, it takes too much time to sort them.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that sorts them in O(n) time.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    nums[i] = [n, i]\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digit", " \
    \ nums.sort!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if i == 0\n      digits = -digits\n    end\n  \
    \  if digits > nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\n      nums.swap(i,\
    \ i-1)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    digits = digits.abs # remove negative sign\n  \
    \  digits = digits.to_i # convert to integer\n    digits = digits.to_s # convert\
    \ to string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # reverse string\n    digits = digits.reverse # reverse\
    \ string\n    digits = digits.reverse # reverse string\n    digits = digits.reverse\
    \ # reverse string\n    digits = digits.reverse # reverse string\n    digits =\
    \ digits.reverse # reverse string\n    digits = digits.reverse # reverse string\n\
    \    digits = digits.reverse # ", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n\
    \    a.each_byte { |x| sum1 += x }\n    b.each_byte { |x| sum2 += x }\n    sum1\
    \ < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i\
    \ == num.to_i\n  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n\
    \    break if num == -99\n    break if num == -999\n    break if num == -9999\n\
    \    break if num == -99999999\n    break if num == -9999999999\n    break if\
    \ num == -99999999999999\n    break if num == -999999999999999999\n    break if\
    \ num == -999999999999999999999\n    break if num == -9999999999999999999998\n\
    \    break if num == -99999999999999999999987\n    break if num == -999999999999999999999876\n\
    \    break if num == -9999999999999999999998765\n    break if num == -99999999999999999999987654\n\
    \    break if num == -999999999999999999999876543\n    break if num == -9999999999999999999998765432\n\
    \    break if num == -99999999999999999999987654321\n    break if num == -999999999999999999999876543210\n\
    \    break if num == -9999999999999999999998765432108\n    break if num == -99999999999999999999987654321087\n\
    \    break if num == -999999999999999999999876543210876\n    break if num == -9999999999999999999998765432108765\n\
    \    break if num == -99999999999999999999987654321087654\n    break if num ==\
    \ -999999999999999999999876543210876543\n    break if num == -9999999999999999999998765432108765432\n\
    \    break if num == -99999999999999999999987654321087654321\n    break if num\
    \ == -999999999999999999999876543210876543210\n    break if num == -9999999999999999999998765432108765432108\n\
    \    break if num == -99999999999999999999987654321087654321087\n    break if\
    \ num == -999999999999999999999876543210876543210876\n    break if num == -9999999999999999999998765432108765432108765\n\
    \    break if num == -99999999999999999999987654321087654321087654\n    break\
    \ if num == -999999999999999999999876543210876543210876543\n    break if num ==\
    \ -9999999999999999999998765432108765432108765432\n    break if num == -99999999999999999999987654321087",
  "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).", "  nums.sort!\n  nums.reverse!\n  nums.each do\
    \ |n|\n    break if n.to_s.size < 2\n    break if n.to_s.size != n.to_s.to_i\n\
    \    break if n.to_s.to_i != n.to_s.to_i\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using regular expressions.\n<|/ c |>\n<| c |>\nI added a solution without using\
    \ regular expressions.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without using regular expressions.\n<|/ c |>\n<|\
    \ c |>\nI added a solution without using regular expressions.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte\
    \ { |c| sum1 += c }\n    b.each_byte { |c| sum2 += c }\n    sum1 < sum2 ? -1 :\
    \ sum1 > sum2 ? 1 : 0\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your answer! I didn't know about `each_char`, that's a nice way to solve\
    \ the problem. However I still don't understand why my code doesn't work. Could\
    \ you please explain it to me?\n<|/ c |>\n<| c |>\nI added some explanation to\
    \ the answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your explanation!\
    \ I still don't understand why my code doesn't work. Could you please explain\
    \ it to me?\n<|/ c |>\n<| c |>\nI added some explanation to the answer. Hope it\
    \ helps.\n<|/ c |>\n<| a dscore=2 |>\nThe problem is that the sort method sorts\
    \ by the ASCII value of the characters, not the numerical value of the digits.\
    \ \n<code>\n\"1\".to_i #=> 1\n\"2\".to_i #=> 2\n\"3\".to_i #=> 3\n\"4\".to_i #=>\
    \ 4\n\"5\".to_i #=> 5\n\"6\".to_i #=> 6\n\"7\".to_i #=> 7\n\"8\".to_i #=> 8\n\"\
    9\".to_i #=> 9\n\"10\".to_i #=> 10\n\"11\".to_i #=> 11\n\"12\".to_i #=> 12\n\"\
    13\".to_i #=> 13\n\"14\".to_i #=> 14\n\"15\".to_i #=> 15\n\"16\".to_i #=> 16\n\
    \"17\".to_i #=> 17\n\"18\".to_i #=> 18\n\"19\".to_i #=> 19\n\"20\".to_i #=> 20\n\
    \"21\".to_i #=> 21\n\"22\".to_i #=> 22\n\"23\".to_i #=> 23\n\"24\".to_i #=> 24\n\
    \"25\".to_i #=> 25\n\"26\".to_i #=> 26\n\"27\".to_i #=> 27\n\"28\".to_i #=> 28\n\
    \"29\".to_i #=> 29\n\"30\".to_i #=> 30\n\"31\".to_i #=> 31", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n    j = num.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    next if i == j\n    nums[i] = nums[j]\n  end\n  nums\nend\n</code>\n<|/ a\
    \ tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work. Try it with `[12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,\
    \ -12, -12, ", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n\
    \    nums.unshift(num)\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n\
    \    a.each_byte { |i| sum1 += i }\n    b.each_byte { |i| sum2 += i }\n    sum1\
    \ == sum2 ? 0 : sum1 < sum2 ? -1 : +1\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    nums[i] = [n] + nums[i].divmod(10)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum < num\n    nums.delete(num)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are two or more items with the same sum.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing that out. I've updated my answer to include a solution that\
    \ does that.\n<|/ c |>\n<| c |>\nI like the `each_with_object` solution, but I\
    \ wonder if there's a way to avoid the double loop. Maybe `each_with_object` could\
    \ return an array of the sums of the digits and then `sort` could take that array\
    \ and sort by the sum of the digits?\n<|/ c |>\n<| c |>\n, that's a good idea.\
    \ I'll give it a try.\n<|/ c |>\n<| c |>\n, I've updated my answer to include\
    \ a solution that does that.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort! { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, index|\n    nums[index] = num if num.digits.sum\
    \ < nums[index].digits.sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if num < 0\n      nums.insert(nums.index(num),\
    \ -num)\n    else\n      nums.insert(nums.index(num), num)\n    end\n  end\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] =\
    \ nums[i] if nums[i].zero?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if i == 0 || digits\
    \ < nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if num == 0 \n    break if num > 0\n    break\
    \ if num < 0\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map\
    \ { |n| n.to_i }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if the array is empty or contains only negative numbers.\n<|/ c |>\n<| c |>\n\
    : It doesn't work because `sort!` modifies the array in place. `sort!` modifies\
    \ the array in-place by sorting it in-place and then reversing it. The `sort!`\
    \ method modifies the array in-place by sorting it in-place and then reversing\
    \ it. The `sort!` method modifies the array in-place by sorting it in-place and\
    \ then reversing it. The `sort!` method modifies the array in-place by sorting\
    \ it in-place and then reversing it. The `sort!` method modifies the array in-place\
    \ by sorting it in-place and then reversing it. The `sort!` method modifies the\
    \ array in-place by sorting it in-place and then reversing it. The `sort!` method\
    \ modifies the array in-place by sorting it in-place and then reversing it. The\
    \ `sort!` method modifies the array in-place by sorting it in-place and then reversing\
    \ it. The `sort!` method modifies the array in-place by sorting it in-place and\
    \ then reversing it. The `sort!` method modifies the array in-place by sorting\
    \ it in-place and then reversing it. The `sort!` method modifies the array in-place\
    \ by sorting it in-place and then reversing it. The `sort!` method modifies the\
    \ array in-place by sorting it in-place and then reversing it. The `sort!` method\
    \ modifies the array in-place by sorting it in-place and then reversing it. The\
    \ `sort!` method modifies the array in-place by sorting it in-place and then reversing\
    \ it. The `sort!` method modifies the array in-place by sorting it in-place and\
    \ then reversing it. The `sort!` method modifies the array in-place by sorting\
    \ it in-place and then reversing it. The `sort!` method modifies the array in-place\
    \ by sorting it in-place and then reversing it. The `sort!` method modifies the\
    \ array in-place by sorting it in-place and then reversing it. The `sort!` method\
    \ modifies the array in-place by sorting it in-place and then reversing it. The\
    \ `sort!` method modifies the array in-place by sorting it in-place and then reversing\
    \ it. The `sort!` method modifies the array in-place by sorting it in-place and\
    \ then reversing it. The `sort!` method modifies the array in-place by sorting\
    \ it ", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n  \
    \  while num > 0\n      sum += num % 10\n      num /= 10\n    end\n    sum\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work. Try\
    \ `order_by_points.call([-12, -11, -10, -9, -8])`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work because `sort!` modifies the array in-place. `nums.sort!.reverse!` would\
    \ work though.\n<|/ c |>\n<| c |>\n: I believe you mean `nums.sort!.reverse!`\
    \ instead of `nums.sort!.reverse!.reverse!`. `nums.sort!.reverse!` modifies the\
    \ array in-place and `nums.sort!.reverse!.reverse!` modifies the array twice in\
    \ one step.\n<|/ c |>\n<| c |>\n: I believe you mean `nums.sort!.reverse!` instead\
    \ of `nums.sort!.reverse!.reverse!`. `nums.sort!.reverse!` modifies the array\
    \ in-place and `nums.sort!.reverse!.reverse!` modifies the array twice in one\
    \ step.\n<|/ c |>\n<| c |>\n: I believe you mean `nums.sort!.reverse!` instead\
    \ of `nums.sort!.reverse!.reverse!`. `nums.sort!.reverse!` modifies the array\
    \ in-place and `nums.sort!.reverse!.reverse!` modifies the array twice in one\
    \ step.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.split(//)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit.to_i}\n    digits_sum.times { nums.unshift(nums.shift)\
    \ }\n  end\n  nums\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  nums.sort! do |a, b|\n    digits = a.to_s.chars.map(&:to_i)\n    digits_b = b.to_s.chars.map(&:to_i)\n\
    \    digits_a.zip(digits_b).map { |a_b| a_b.first <=> a_b.last }\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I believe it would\
    \ be more efficient to sort by `a.to_s.chars.map(&:to_i).zip(b.to_s.chars.map(&:to_i)).map\
    \ { |a_b| a_b.first <=> a_b.last }`.\n<|/ c |>\n<| c |>\nThanks for your suggestion!\
    \ I updated my answer accordingly.\n<|/ c |>\n<| a tags=sorting,ruby |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n    break if n.to_s.size\
    \ != n.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits_sum = digits.inject(:+)\n    if digits_sum > 0\n      nums[i] = n\n \
    \   end\n  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if num.zero?\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum != n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.map do |n|\n    n.to_s.split('').sort.join.to_i\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n   \
    \ nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits = num.to_s.split(//)\n\
    \    digits.each do |digit|\n      sum += digit.to_i\n    end\n    if sum > 0\n\
    \      nums.insert(nums.index(num), num)\n    end\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort! do |a, b|\n    digits = a.to_s.chars.map(&:to_i).reduce(:+)\n   \
    \ digits = b.to_s.chars.map(&:to_i).reduce(:+) - digits\n    digits <=> a.to_s.chars.map(&:to_i).reduce(:+)\
    \ - b.to_s.chars.map(&:to_i).reduce(:+)\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n    digits\
    \ = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits > num\n   \
    \   nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if nums.sum >= num\n    nums.delete(num)\n  end\n\
    \  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there\
    \ are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, I know.\
    \ I just wanted to show a possible solution. Of course the solution can be improved.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require the array to be sorted.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require the array to be sorted.\n\
    <|/ c |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n\
    \    sum = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n    end\n \
    \   sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] =\
    \ [n, i]\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n`nums.sort!` modifies the\
    \ original array. `nums.sort!.reverse!` modifies the original array and returns\
    \ the sorted array.\n<|/ c |>\n<| c |>\n`nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.sort!.reverse!` modifies the original\
    \ array and returns the sorted array. `nums.", "  nums.sort!\n  nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i) }.\n    map { |_, v| v.sort_by { |n| n.to_s.split(//).map(&:to_i)\
    \ } }\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nI like your solution,\
    \ but I wonder why you use `to_i` instead of `to_f`?\n<|/ c |>\n<| c |>\nBecause\
    \ `to_f` will convert `\"-1\"` to `-1.0`, which is not what we want. `to_i` will\
    \ convert `\"-1\"` to `-1`, which is what we want.\n<|/ c |>\n<| c |>\nI see.\
    \ Thanks for explaining.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.map do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits.inject(0) { |sum, digit| sum + digit }\n  end\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.digits.reverse\n    digits\
    \ = digits.map { |d| d * 10 }\n    digits = digits.sort_by{ |d| d }\n    digits\
    \ = digits.reverse\n    digits = digits.map { |d| d.to_s }\n    digits = digits.join(\"\
    \")\n    digits = digits.split(\"\").sort_by{ |d| d }\n    digits = digits.reverse\n\
    \    digits = digits.map { |d| d.to_i }\n    digits = digits.join(\"\")\n    digits\
    \ = digits.split(\"\").sort_by{ |d| d }\n    digits = digits.reverse\n    digits\
    \ = digits.map { |d| d.to_i }\n    digits = digits.join(\"\")\n    digits = digits.split(\"\
    \").sort_by{ |d| d }\n    digits = digits.reverse\n    digits = digits.map { |d|\
    \ d.to_i }\n    digits = digits.join(\"\")\n    digits = digits.split(\"\").sort_by{\
    \ |d| d }\n    digits = digits.reverse\n    digits = digits.map { |d| d.to_i }\n\
    \    digits = digits.join(\"\")\n    digits = digits.split(\"\").sort_by{ |d|\
    \ d }\n    digits = digits.reverse\n    digits = digits.map { |d| d.to_i }\n \
    \   digits = digits.join(\"\")\n    digits = digits.split(\"\").sort_by{ |d| d\
    \ }\n    digits = digits.reverse\n    digits = digits.map { |d| d.to_i }\n   \
    \ digits = digits.join(\"\")\n    digits = digits.split(\"\").sort_by{ |d| d }\n\
    \    digits = digits.reverse\n    digits = digits.map { |d| d.to_i }\n    digits\
    \ = digits.join(\"\")\n    digits = digits.split(\"\").sort_by{ |d| d }\n    digits\
    \ = digits.reverse\n    digits = digits.map { |d| d.to_i }\n    digits = digits.join(\"\
    \")\n    digits = digits.split(\"\").sort_by{ |d| d }\n    digits = digits.reverse\n\
    \    digits = digits.map { |d| d.to_i }\n    digits = digits.join(\"\")\n    digits\
    \ = digits.split(\"\").sort_by{ |d| d }\n    digits = digits.reverse\n", "  nums.sort!\n\
    \  nums.map { |n| n.to_s }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map {\
    \ |n| n.to_i }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits\
    \ = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    if digits\
    \ == nums[i]\n      nums[i], nums[nums[i]] = nums[nums[i]], nums[i]\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits\
    \ = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+) \n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n\
    \    digits = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n\
    \    digits = digits.abs\n    digits = digits.to_i\n", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i] + digits\n    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if i == 0 ||\
    \ nums[i-1].to_i > digits\n      nums.insert(i, n)\n    end\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits =\
    \ num.to_s.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_a\n    digits\
    \ = digits.sort.reverse\n    nums.insert(digits.index(digits) + 1, num)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if nums.sum == num\n    nums.delete_at(nums.index(num))\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] =\
    \ nums[i].to_i\n  end\n  nums\nend\n</cell>\n<cell>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 2 if digits.even?\n    digits = 3 if digits.odd?\n    digits = 4\
    \ if digits.odd?\n    digits = 5 if digits.odd?\n    digits = 6 if digits.odd?\n\
    \    digits = 7 if digits.odd?\n    digits = 8 if digits.odd?\n    digits = 9\
    \ if digits.odd?\n    digits = 10 if digits.odd?\n    digits = 11 if digits.odd?\n\
    \    digits = 12 if digits.odd?\n    digits = 13 if digits.odd?\n    digits =\
    \ 14 if digits.odd?\n    digits = 15 if digits.odd?\n    digits = 16 if digits.odd?\n\
    \    digits = 17 if digits.odd?\n    digits = 18 if digits.odd?\n    digits =\
    \ 19 if digits.odd?\n    digits = 20 if digits.odd?\n    digits = 21 if digits.odd?\n\
    \    digits = 22 if digits.odd?\n    digits = 23 if digits.odd?\n    digits =\
    \ 24 if digits.odd?\n    digits = 25 if digits.odd?\n    digits = 26 if digits.odd?\n\
    \    digits = 27 if digits.odd?\n    digits = 28 if digits.odd?\n    digits =\
    \ 29 if digits.odd?\n    digits = 30 if digits.odd?\n    digits = 31 if digits.odd?\n\
    \    digits = 32 if digits.odd?\n    digits = 33 if digits.odd?\n    digits =\
    \ 34 if digits.odd?\n    digits = 35 if digits.odd?\n    digits = 36 if digits.odd?\n\
    \    digits = 37 if digits.odd?\n    digits = 38 if digits.odd?\n    digits =\
    \ 39 if digits.odd?\n    digits = 40 if digits.odd?\n    digits = 41 if digits.odd?\n\
    \    digits = 42 if digits.odd?\n    digits = 43 if digits.odd?\n    digits =\
    \ 44 if digits.odd?\n    digits = 45 if digits.odd?\n    digits = 46 if digits.odd?\n\
    \    digits = 47 if digits.odd?\n    digits = 48 if digits.odd?\n    digits =\
    \ 49 if digits.odd?\n    digits = 50 if digits.odd?\n    ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    i = num.to_i\n    break if i == 0\n    j = nums.index(i)\n\
    \    nums.insert(j, i)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.chars.map(&:to_i).sum > n.to_s.chars.map(&:to_i).sum\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum - n == 0\n    nums[i] = n\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    if digits > 0 && !nums.include?(num)\n      nums.unshift(num)\n  \
    \  end\n  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `order_by_points.call([-12, -11, -11])`\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I added the test case to the answer. Can you please\
    \ explain why it doesn't work?\n<|/ c |>\n<| c |>\nThe test case you added doesn't\
    \ work because `order_by_points.call([-12, -11, -11])` returns `[-12, -11, -11]`\
    \ instead of `[-11, -11, -11]`.\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I added the test case to the answer. Can you please explain why it doesn't work?\n\
    <|/ c |>\n<| c |>\nThe test case you added doesn't work because `order_by_points.call([-12,\
    \ -11, -11])` returns `[-12, -11, -11]` instead of `[-11, -11, -11]`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    nums[i] = [n,\
    \ i]\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if there are two or more numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\nYes, you are right. My mistake. I will fix it.\n<|/\
    \ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if num == -1\n    break if num == 0\n    break\
    \ if num == +1\n    break if num == +1\n    break if num == -1\n    nums.unshift(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without using break.\n\
    <|/ c |>\n<| c |>\nI added a solution without break.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without using break.\n\
    <|/ c |>\n<| c |>\nI added a solution without break.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without using break.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if num == 0 && nums.size == 1\n    break if nums.include?(num)\n\
    \    nums[i] = num\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `order_by_points.call([-10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0])` returns `[-10, -9, -8, -7, -6, -5,\
    \ -4, -3, -2, -1, 0]`\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers,\
    \ because negative numbers are sorted before positive numbers. Try `order_by_points.call([-10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0])`\n<|/ c |>\n<| c |>\nI didn't say it\
    \ wouldn't work, I said it doesn't work for negative numbers. Try `order_by_points.call([-10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0])`\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've updated my answer to include a fix for negative numbers.\n<|/ c |>\n\
    <| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    sum = 0\n    while num > 0\n      sum += num % 10\n      num /=\
    \ 10\n    end\n    if sum > 0\n      nums.unshift(num)\n    end\n  end\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] =\
    \ [n, i]\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if i == 0\n      nums[i] = n\n    elsif nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\
    \ == digits\n      nums[i] = n\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,arrays |>\n<code>", "  nums.sort!\n  nums.map { |n| n.to_i }\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   i = num.to_i\n    nums[i] = nums[i] - nums[i].to_s.chars.map(&:to_i).inject(:+)\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ there are negative numbers in the array\n<|/ c |>\n<| c |>\nI added a note about\
    \ negative numbers. I tested it and it works fine.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are negative numbers in the array\n<|/ c |>\n<| c |>\nI added\
    \ a note about negative numbers. I tested it and it works fine.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if there are negative numbers in the array\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n \
    \   digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n  \
    \  digits = digits.to_i\n    if digits == 0\n      nums[i] = n\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums.sum\
    \ - n == 0\n    nums[i], nums[nums.sum - n] = nums[nums.sum - n], nums[i]\n  end\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n == 0\n    nums[i],\
    \ nums[nums.sum - n] = nums[nums.sum - n], nums[i]\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are multiple items\
    \ with the same sum.\n<|/ c |>\n<| c |>\n: I added a note to the answer.\n<|/\
    \ c |>\n<| c |>\n: I added a note to the answer.\n<|/ c |>\n<| c |>\n: I added\
    \ a note to the answer.\n<|/ c |>\n<| c |>\n: I added a note to the answer.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n    digits.each\
    \ do |digit|\n      nums.delete_at(nums.index(num) if nums.include?(num))\n  \
    \    break if nums.include?(digit)\n    end\n  end\n  nums\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis doesn't work. Try `order_by_points.call([-12,\
    \ -11, -10, -9, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8,\
    \ -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n == 0\n    nums[i]\
    \ = n\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for `[1,\
    \ 11, -1, -11, -12]`\n<|/ c |>\n<| c |>\nI tested it on `[1, 11, -1, -11, -12]`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on `[1, 11, -1, -11, -12]`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on `[1, 11, -1, -11, -12]`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on `[1, 11, -1, -11, -12]`\
    \ and it worked fine.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -99\n    break if num == -999\n    break if num == -9999\n    break if num\
    \ == -9999999\n    break if num == -999999999\n    break if num == -99999999999\n\
    \    break if num == -999999999999999\n    break if num == -9999999999999999999\n\
    \    break if num == -99999999999999999999999\n    break if num == -999999999999999999999999999\n\
    \    break if num == -9999999999999999999999999999999\n    break if num == -99999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999\n    break if num\
    \ == -9999999999999999999999999999999999999999999\n    break if num == -99999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999999999999\n  \
    \  break if num == -9999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -9999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -99999999999999999999999999999999999999999999999999999999999999999999999\n\
    \    break if num == -999999999999999999999999999999999999", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n  \
    \  nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n|\
    \ n.to_i}\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    break if nums.sum < num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n    break if n.to_s.size\
    \ != n.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are multiple items with the same sum.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated my answer to include\
    \ a note about that.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |num, i|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+)\
    \ if digits.empty?\n    digits = digits.sort { |a, b| b - a }\n    if digits[0]\
    \ != 0\n      nums[i] = nums[i - 1] + digits[0]\n    end\n  end\n  nums\nend",
  "  nums.sort!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try `order_by_points.call([-10,\
    \ -9, -7, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])`\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it before posting. Try it yourself.\n<|/ c |>\n\
    <| c |>\nIt doesn't work. Try `order_by_points.call([-10, -9, -7, -5, -4, -3,\
    \ -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])`\n<|/ c |>\n<| c |>\nIt works. I\
    \ tested it before posting. Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try `order_by_points.call([-10, -9, -7, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10])`\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if num.digits.sum < num.digits.max\n  end\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map!\
    \ {|x| x.to_i}\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n|\
    \ n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i\
    \ = num.to_i\n    j = num.to_s.chars.map(&:to_i).reduce(:+)\n    if i != j\n \
    \     nums.swap(i, j)\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two or more numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\n: Yes, I realized that after I posted it. I edited\
    \ my answer to include a solution that does work if there are multiple numbers\
    \ with the same sum.\n<|/ c |>\n<| c |>\n: I added a solution that works if there\
    \ are multiple numbers with the same sum.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ that works if there are multiple numbers with the same sum.\n<|/ c |>\n<| c\
    \ |>\n: I added a solution that works if there are multiple numbers with the same\
    \ sum.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  nums.sort! do |a, b|\n\
    \    sum1 = sum2 = 0\n    a.each_byte { |x| sum1 += x }\n    b.each_byte { |x|\
    \ sum2 += x }\n    sum1 < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend", "  nums.sort!\
    \ { |a, b| a.to_s + b.to_s }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| c |>\nI like the idea of using sort with a block. Nice and simple.\n<|/ c |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ converting to a string. For example, `[1,2,3].sort_by { |x| x.to_s }` returns\
    \ `[1,2,3]`, but `[1,2,3].sort_by { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n<|\
    \ c |>\nI guess you could do `[1,2,3].sort_by { |x| x.to_i }` but that would sort\
    \ by string length. `[1,2,3].sort_by { |x| x.to_i }.map(&:to_s)` would return\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\n`[1,2,3].sort_by { |x| x.to_i }.map(&:to_s)`\
    \ returns `[1,2,3]` because `[1,2,3].sort_by { |x| x.to_i }` returns `[1,2,3]`\n\
    <|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing that out. I've updated\
    \ my answer.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits.zero?\n      nums[i] = n\n    end\n \
    \ end\n  nums\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't\
    \ work if there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I fixed the code now. Thanks for pointing out.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are two or more numbers with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, you are right. I fixed the code now. Thanks for pointing\
    \ out.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n    j = num.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    next if i == j\n    nums.swap(i, j)\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nI like your solution, however I believe it can be made more efficient\
    \ by using a hash to store the sums of the digits of each number, then sorting\
    \ by the hash's values.\n<|/ c |>\n<| c |>\nI believe that would work, but I believe\
    \ that would require a lot of memory and be slower than the other solutions.\n\
    <|/ c |>\n<| c |>\nI agree with you, my solution would require a lot of memory,\
    \ but I think it would be faster than the other solutions.\n<|/ c |>\n<| c |>\n\
    I agree with you, my solution would require a lot of memory, but I think it would\
    \ be faster than the other solutions.\n<|/ c |>\n<| c |>\nI agree with you, my\
    \ solution would require a lot of memory, but I think it would be faster than\
    \ the other solutions.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n \
    \ nums.map { |n| n.to_i }\nend", "  nums.sort! { |a, b| sum_of_digits(a) <=> sum_of_digits(b)\
    \ }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
