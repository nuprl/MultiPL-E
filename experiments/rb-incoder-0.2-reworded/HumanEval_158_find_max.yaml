name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts an array of strings.\n# The array contains\
  \ different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> find_max.call([\"name\", \"\
  of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"\
  ])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\
  \ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  words.each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\n    .max_by { |word, counts| -counts[word] }\nend", "  words.inject([])\
    \ do |max, word|\n    chars = word.split(\"\").uniq.size\n    max.length < chars\
    \ ? max << word : max\n  end\nend", "  words.sort.reverse.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.uniq.sort!\n  words.uniq.max_by { |word| word.size }\nend", " \
    \ words.group_by { |word| word.chars.uniq.size }.max_by { |word, count| count\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>", "  words.uniq.sort!\n\
    \  words.uniq.count!\n  words.uniq.first\nend", "  words.sort_by { |word| word.chars.uniq.size\
    \ }\n  words.max_by { |word| word.chars.uniq.size }\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }.max_by { |word, counts| counts[word] }[1]\n\
    end", "  words.uniq.sort!\n  words.uniq.size\nend", "  words.group_by { |word|\
    \ word.chars.uniq.size }.max_by { |word, _| word.size }[0]\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,string |>\n<| c |>\nThanks for your answer. Can you please\
    \ explain how this works?\n<|/ c |>\n<| c |>\nI added some explanation.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n\
    <|/ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Can you please explain how this works?\n<|/ c |>\n<| a tags=ruby,arrays,string\
    \ |>\n<code>", "  words.sort.reverse.uniq.first\nend", "  words.uniq.sort!\n \
    \ words.uniq.size\n  words.uniq.first\nend", "  words.sort.reverse.uniq.length.first\n\
    end", "  words.group_by { |w| w.length }.max_by { |k, v| v.size }.first\nend",
  "  words.uniq.sort!\n  words.uniq.size\n  words.uniq.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.inject(0) do |max, word|\n    max = word.length if\
    \ max < word.length\n    max\n  end\nend", "  words.uniq.sort!\n  words.uniq.max_by\
    \ { |word| word.length }\nend", "  words.sort.reverse.uniq.length.first\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
