name: HumanEval_95_check_dict_case
language: rb
prompt: "# Given a hash, return true if all keys are strings in lower \n# case or\
  \ all keys are strings in upper case, else return false.\n# The function should\
  \ return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"\
  a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"\
  Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>>\
  \ check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef\
  \ check_dict_case(dict)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n\
  \    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"\
  p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"\
  p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false,\
  \ candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"\
  }))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"\
  36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\"\
  \ => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"\
  fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n\
  \  end\nend\n"
completions: ["  case dict\n  when Hash\n    dict.each do |key, value|\n      next\
    \ if value.nil?\n      next if value.is_a?(String)\n      next if value.is_a?(Symbol)\n\
    \      next if value.is_a?(Fixnum)\n      next if value.is_a?(Float)\n      next\
    \ if value.is_a?(BigDecimal)\n      next if value.is_a?(TrueClass)\n      next\
    \ if value.is_a?(FalseClass)\n      next if value.is_a?(Array)\n      next if\
    \ value.is_a?(Hash)\n      next if value.is_a?(Range)\n      next if value.is_a?(IO)\n\
    \      next if value.is_a?(StringIO)\n      next if value.is_a?(IO::MemoryStream)\n\
    \      next if value.is_a?(IO::File)\n      next if value.is_a?(IO::Stdout)\n\
    \      next if value.is_a?(IO::Stderr)\n      next if value.is_a?(IO::NullStream)\n\
    \      next if value.is_a?(IO::NullFile)\n      next if value.is_a?(IO::NullStdout)\n\
    \      next if value.is_a?(IO::NullStderr)\n      next if value.is_a?(IO::NullNullStream)\n\
    \      next if value.is_a?(IO::NullNullFile)\n      next if value.is_a?(IO::NullNullStdout)\n\
    \      next if value.is_a?(IO::NullNullStderr)\n      next if value.is_a?(IO::NullNullNullStream)\n\
    \      next if value.is_a?(IO::NullNullNullFile)\n      next if value.is_a?(IO::NullNullNullStdout)\n\
    \      next if value.is_a?(IO::NullNullNullStderr)\n      next if value.is_a?(IO::NullNullNullNullStream)\n\
    \      next if value.is_a?(IO::NullNullNullNullFile)\n      next if value.is_a?(IO::NullNullNullNullStdout)\n\
    \      next if value.is_a?(IO::NullNullNullNullStderr)\n      next if value.is_a?(IO::NullNullNullNullNullStream)\n\
    \      next if value.is_a?(IO::NullNullNullNullNullFile)\n      next if value.is_a?(IO::NullNullNullNullNull",
  "  case dict.length\n  when 0\n    false\n  when 1\n    dict.keys.all? { |k| k.is_a?(String)\
    \ }\n  else\n    dict.keys.all? { |k| k.is_a?(String) && k.upcase == k.downcase\
    \ }\n  end\nend", "  return false if dict.nil? || dict.empty?\n  dict.each do\
    \ |key, value|\n    next if value.nil? || value.empty?\n    next if value.is_a?(String)\n\
    \    next if value.is_a?(Symbol)\n    next if value.is_a?(Fixnum)\n    next if\
    \ value.is_a?(Float)\n    next if value.is_a?(BigDecimal)\n    next if value.is_a?(BigInteger)\n\
    \    next if value.is_a?(TrueClass)\n    next if value.is_a?(FalseClass)\n   \
    \ next if value.is_a?(Date)\n    next if value.is_a?(Time)\n    next if value.is_a?(DateTime)\n\
    \    next if value.is_a?(StringIO)\n    next if value.is_a?(IO)\n    next if value.is_a?(File)\n\
    \    next if value.is_a?(StringIO)\n    next if value.is_a?(IO)\n    next if value.is_a?(File)\n\
    \    next if value.is_a?(Array)\n    next if value.is_a?(Hash)\n    next if value.is_a?(Proc)\n\
    \    next if value.is_a?(IO)\n    next if value.is_a?(File)\n    next if value.is_a?(StringIO)\n\
    \    next if value.is_a?(IO)\n    next if value.is_a?(File)\n    next if value.is_a?(Array)\n\
    \    next if value.is_a?(Hash)\n    next if value.is_a?(Proc)\n    next if value.is_a?(IO)\n\
    \    next if value.is_a?(File)\n    next if value.is_a?(StringIO)\n    next if\
    \ value.is_a?(IO)\n    next if value.is_a?(File)\n    next if value.is_a?(Array)\n\
    \    next if value.is_a?(Hash)\n    next if value.is_a?(Proc)\n    next if value.is_a?(IO)\n\
    \    next if value.is_a?(File)\n    next if value.is_a?(StringIO)\n    next if\
    \ value.is_a?(IO)\n    next if value.is_a?(File)\n    next if value.is_a?(Array)\n\
    \    next if value.is_a?(Hash)\n    next if value.is_a?(Proc)\n    next if value.is_a?(",
  "  return false if dict.nil? or dict.empty?\n  dict.each do |key, value|\n    return\
    \ false if value.nil? or value.empty?\n    return false if key.to_s.upcase !=\
    \ key.to_s.downcase\n  end\n  return true\nend", "  case dict\n  when Hash\n \
    \   dict.all? { |key, value| key.downcase == value.downcase }\n  when Array\n\
    \    dict.all? { |value| value.downcase == value.downcase }\n  else\n    false\n\
    \  end\nend", "  if dict.empty?\n    false\n  else\n    dict.each do |key, value|\n\
    \      if value.is_a?(String)\n        value.downcase!\n      else\n        value.upcase!\n\
    \      end\n    end\n    true\n  end\nend", "  case dict.length\n  when 0\n  \
    \  false\n  when 1\n    true\n  else\n    dict.keys.all? do |key|\n      key.downcase\
    \ == key.upcase\n    end\n  end\nend", "  dict.each do |key, value|\n    if value.is_a?(String)\n\
    \      value.downcase!\n    else\n      value.upcase!\n    end\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", " \
    \ dict.each do |key, value|\n    if value.is_a?(String)\n      value.downcase!\n\
    \    else\n      value.upcase!\n    end\n  end\n  true\nend", "  case dict.length\n\
    \  when 0\n    false\n  when 1\n    true\n  else\n    dict.keys.all? do |key|\n\
    \      key.downcase == key.upcase\n    end\n  end\nend", "  if dict.empty?\n \
    \   false\n  else\n    dict.each do |key, value|\n      if value.is_a?(String)\n\
    \        value.downcase!\n      else\n        value.upcase!\n      end\n    end\n\
    \    true\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work\
    \ if the hash contains any non-string keys. For example, `check_dict_case({\"\
    a\" => \"apple\", \"b\" => \"banana\", \"c\" => \"carrot\"})` returns `true` instead\
    \ of `false`.\n<|/ c |>\n<| c |>\nI agree, my answer was meant to be a starting\
    \ point for OP to work from. I'll update my answer to include a more robust solution.\n\
    <|/ c |>\n<| a tags=ruby,hash |>\n<code>", "  case dict\n  when Hash\n    dict.all?\
    \ { |key, value| key.is_a?(String) && value.is_a?(String) }\n  else\n    false\n\
    \  end\nend", "  dict.each do |key, value|\n    next if value.nil?\n    next if\
    \ value.is_a?(String)\n    next if value.is_a?(Symbol)\n    next if value.is_a?(Fixnum)\n\
    \    next if value.is_a?(BigDecimal)\n    next if value.is_a?(Float)\n    next\
    \ if value.is_a?(BigInteger)\n    next if value.is_a?(Array)\n    next if value.is_a?(Hash)\n\
    \    next if value.is_a?(Time)\n    next if value.is_a?(DateTime)\n    next if\
    \ value.is_a?(IO)\n    next if value.is_a?(StringIO)\n    next if value.is_a?(IO::MemoryStream)\n\
    \    next if value.is_a?(IO::File)\n    next if value.is_a?(IO::Stdio)\n    next\
    \ if value.is_a?(IO::NullIO)\n    next if value.is_a?(IO::Pipe)\n    next if value.is_a?(IO::Pipe::Reader)\n\
    \    next if value.is_a?(IO::Pipe::Writer)\n    next if value.is_a?(IO::Pipe::Error)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)\n\
    \    next if value.is_a?(IO::Pipe::Stderr)\n    next if value.is_a?(IO::Pipe::Stdout)",
  "  if dict.empty?\n    false\n  else\n    true\n  end\nend", "  if dict.nil?\n \
    \   return false\n  end\n  \n  keys = dict.keys\n  keys.each do |key|\n    next\
    \ if key.kind_of?(String)\n    next if key.upcase == key\n    return false\n \
    \ end\n  \n  return true\nend", "  return false if dict.empty?\n  dict.each do\
    \ |k, v|\n    next if k.is_a?(String)\n    next if k.upcase != k\n    next if\
    \ k.downcase != k\n    false\n  end\n  true\nend", "  case dict.length\n  when\
    \ 0\n    false\n  when 1\n    true\n  else\n    dict.keys.all? { |key| key.downcase\
    \ == key.upcase }\n  end\nend", "  case dict.length\n  when 0\n    false\n  when\
    \ 1\n    true\n  else\n    dict.keys.all? { |k| k.downcase == k.upcase }\n  end\n\
    end", "  if dict.empty?\n    false\n  else\n    dict.each do |key, value|\n  \
    \    if value.is_a?(String)\n        value.downcase!\n      else\n        value.upcase!\n\
    \      end\n    end\n    true\n  end\nend", "  case dict.length\n  when 0\n  \
    \  false\n  when 1\n    true\n  else\n    dict.keys.all? { |key| key.downcase\
    \ == key.upcase }\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
