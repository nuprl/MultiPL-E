name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1,\
  \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
  \ smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>>\
  \ pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n# so we will choose the first zero, which has the smallest\
  \ index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\n\
  def pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["    arr.sort!\n    even = arr.select {|x| x % 2 == 0}\n    even.sort!\n\
    \    even.first\nend", "  arr.sort!\n  even = arr.select { |x| x % 2 == 0 }\n\
    \  even.empty? ? [] : even.min\nend", "  arr.each_with_index do |node, index|\n\
    \    if node.even?\n      arr[index] = node\n      break\n    end\n  end\n  arr\n\
    end", "  arr.each_with_index do |node, index|\n    next if node.even?\n    smallest_value\
    \ = index\n    smallest_index = 0\n    arr.each_with_index do |n, i|\n      next\
    \ if n.even?\n      if smallest_value < i && n.even?\n        smallest_value =\
    \ i\n        smallest_index = i\n      end\n    end\n    smallest_value\n  end\n\
    end", "  arr.sort!\n  even = arr.select {|x| x % 2 == 0}\n  even.empty? ? [] :\
    \ even.min\nend", "  arr.sort!\n  arr.each_with_index do |node, index|\n    if\
    \ node.even?\n      arr[index] = node\n    end\n  end\n  arr.uniq.sort\nend",
  "  arr.sort!\n  even = arr.select { |x| x % 2 == 0 }\n  if even.empty?\n    []\n\
    \  else\n    even.min\n  end\nend", "  arr.sort!\n  even = arr.select { |x| x\
    \ % 2 == 0 }\n  even.empty? ? [] : even.min\nend", "  arr.sort!\n  even = arr.select\
    \ { |x| x % 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : [even.min]\n  end\nend", "  arr.sort!\n  arr.each_with_index\
    \ do |node, index|\n    if node.even?\n      return [node, index]\n    end\n \
    \ end\n  []\nend", "  arr.each_with_index do |node, index|\n    if node.even?\n\
    \      arr[index] = node\n      break\n    end\n  end\n  arr.compact!\n  arr.sort!\n\
    \  arr\nend", "  arr.sort!\n  even = arr.select { |x| x % 2 == 0 }\n  if even.empty?\n\
    \    []\n  else\n    even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ", "  arr.sort!\n  even\
    \ = arr.select { |x| x % 2 == 0 }\n  if even.empty?\n    return []\n  else\n \
    \   even.min\n  end\nend", "  arr.sort!\n  even = arr.select { |x| x % 2 == 0\
    \ }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend", "  arr.sort!\n\
    \  even = arr.select { |x| x % 2 == 0 }\n  if even.empty?\n    []\n  else\n  \
    \  even.min.even? ? even.min : [even.min]\n  end\nend", "  arr.each_with_index\
    \ do |node, index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.uniq.sort\nend", "  arr.sort!\n  even = arr.select { |x| x % 2 == 0 }\n\
    \  even.empty? ? [] : even.min\nend", "  arr.sort!\n  even = arr.select { |x|\
    \ x % 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend", "  arr.sort!\n  even = arr.select {\
    \ |x| x % 2 == 0 }\n  even.empty? ? [] : even.min\nend", "    arr.sort!\n    even\
    \ = arr.select { |x| x.even? }\n    even.empty? ? [] : even.min.even? ? [even.min,\
    \ even.min.index] : even.min\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
