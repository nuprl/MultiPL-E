name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor.call(\"\
  010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\n\
    end", "  a = a.to_s\n  b = b.to_s\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b ", "  a\
    \ = a.to_s\n  b = b.to_s\n  result = []\n  a.each_byte do |x|\n    b.each_byte\
    \ do |y|\n      result << x ^ y\n    end\n  end\n  result.join\nend", "  a.to_i(2).xor(b.to_i(2)).to_s(2)\n\
    end", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte do |x|\n   \
    \ result << x ^ b.byte(x.to_i)\n  end\n  result\nend", "  a.unpack('C*').pack('C*').unpack('C*').pack('C*')\
    \ ^ b.unpack('C*').pack('C*').unpack('C*').pack('C*')\nend", "  result = \"\"\n\
    \  a.each_byte do |char|\n    result << char if char != b.byte(char)\n  end\n\
    \  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do\
    \ |c|\n    result << c ^ b[a.index(c)]\n  end\n  result\nend", "  result = \"\"\
    \n  a.each_byte do |x|\n    result << x ^ b.byte(0) if x == 1\n  end\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte do |x|\n   \
    \ result << x ^ b\n  end\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = []\n  for i in 0..(a.length - 1)\n    result << (a[i] ^ b[i])\n  end\n  result.to_s\n\
    end", "  result = \"\"\n  a.each_byte { |b| result << b.chr if b == 0 }\n  b.each_byte\
    \ { |b| result << b.chr if b == 0 }\n  result\nend", "  a.unpack('C*').inject(:^)\n\
    end", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end", "  a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n  a.to_s\n\
    end", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"0\" * (a.length + b.length - 2)\n\
    \  for i in 0...a.length\n    result += \"1\" if a[i] != b[i] else \"0\"\n  result\
    \ += \"1\" * (b.length - a.length)\n  return result\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  result = \"\"\n  a.each_byte do |char|\n    result << ((char ^ b).to_s(2))\n\
    \  end\n  result\nend", "  a.each_byte { |x| b << x }\n  b.each_byte { |x| a <<\
    \ x }\n  a.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
