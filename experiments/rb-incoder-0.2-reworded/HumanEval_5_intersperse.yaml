name: HumanEval_5_intersperse
language: rb
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ array `numbers'\n# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1,\
  \ 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n\
  \    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n\
  \    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2,\
  \ 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"
completions: ["  numbers = numbers.dup\n  numbers[0, 2] = delimeter\n  numbers.slice(1,\
    \ numbers.length).each do |i|\n    numbers[i + 1] = delimeter + numbers[i + 1]\n\
    \  end\n  numbers\nend", "  numbers.each_with_index do |number, index|\n    yield(number)\
    \ if index == 0\n    yield(delimeter) if index != 0\n    yield(number)\n  end\n\
    end", "  numbers.each_with_index do |number, index|\n    numbers.insert(index,\
    \ delimeter) if index > 0\n    numbers.insert(index, number)\n  end\nend", " \
    \ numbers.each_with_index do |number, index|\n    numbers[index] = number\n  \
    \  numbers[index + 1] = delimeter\n  end\n  numbers\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = number\n    numbers[index + 1] = delimeter\n\
    \  end\nend", "  numbers.each_with_index do |number, index|\n    if index > 0\n\
    \      yield delimeter\n    end\n    yield number\n  end\nend", "  numbers[0,\
    \ 2] = numbers[0, 2] + delimeter\n  numbers.slice(1, numbers.length).each do |number|\n\
    \    numbers[0, 2] = numbers[0, 2] + number\n  end\n  numbers\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = delimeter if index != 0\n    numbers[index]\
    \ = number if index != numbers.length - 1\n  end\nend", "  numbers.each_with_index\
    \ do |number, index|\n    yield(number) if index == 0\n    yield(delimeter) if\
    \ index != 0\n    yield(number)\n  end\nend", "  numbers.each_with_index do |number,\
    \ index|\n    numbers[index] = delimeter if index != 0\n    numbers[index] +=\
    \ number\n  end\n  numbers\nend", "  numbers = numbers.dup\n  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = delimeter if index > 0\n    numbers[index]\
    \ += number\n  end\n  numbers\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers.insert(index + 1, number)\n    numbers.insert(index + 2, delimeter)\n\
    \  end\nend", "  numbers.each_cons(2).with_index do |(first, second), i|\n   \
    \ numbers.insert(i, delimeter)\n  end\nend", "  numbers.each_with_index do |number,\
    \ index|\n    numbers[index] = number\n    numbers[index + 1] = delimeter\n  end\n\
    end", "  numbers.each_cons(2).with_index do |(first, second), index|\n    yield(first,\
    \ delimeter, second)\n  end\nend", "  numbers = numbers.dup\n  numbers.each_index\
    \ do |i|\n    numbers[i] += delimeter\n  end\n  numbers\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = delimeter if index > 0\n    numbers[index]\
    \ = number if index == 0\n  end\n  numbers\nend", "  numbers[0...-1].zip(numbers[1...-1]).map\
    \ { |x, y| x + delimeter + y }\nend", "  numbers.each_cons(2) do |numbers|\n \
    \   numbers.unshift(delimeter)\n  end\nend", "  numbers[0...-1].zip(numbers[1...-1]).map\
    \ { |x, y| x + delimeter + y }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
