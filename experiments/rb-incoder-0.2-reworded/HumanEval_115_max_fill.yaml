name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n\
  # Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
  \ 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length\
  \ <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <=\
  \ capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["    # write your code here\n    \n    count = 0\n    \n    buckets\
    \ = Array.new(capacity)\n    \n    grid.each do |row|\n        row.each do |val|\n\
    \            buckets[val] += 1\n        end\n    end\n    \n    buckets.each do\
    \ |val|\n        if val > 0\n            count += val\n        end\n    end\n\
    \    \n    return count\nend", "    count = 0\n    buckets = Array.new(capacity)\n\
    \    grid.each do |row|\n        row.each do |cell|\n            if cell == 1\n\
    \                buckets[cell] += 1\n            end\n        end\n    end\n \
    \   buckets.each do |bucket|\n        count += bucket if bucket > capacity\n \
    \   end\n    return count\nend", "    count = 0\n    \n    # Iterate through each\
    \ row\n    for row in grid\n        # Iterate through each column\n        for\
    \ col in row\n            # If the bucket is full, empty it\n            if grid[row][col]\
    \ == 1\n                grid[row][col] = 0\n                count += 1\n     \
    \       end\n        end\n    end\n    \n    return count\nend", "    # write\
    \ your code here\n    \n    count = 0\n    \n    buckets = Array.new(capacity)\n\
    \    \n    grid.each do |row|\n        row.each do |val|\n            buckets[val]\
    \ += 1\n        end\n    end\n    \n    buckets.each do |val|\n        count +=\
    \ val\n    end\n    \n    return count\nend", "  count = 0\n  for i in 1..grid.length\n\
    \    for j in 1..grid[i].length\n      if grid[i][j] == 1\n        count += 1\n\
    \        grid[i][j] = 0\n      else\n        grid[i][j] = grid[i][j-1]\n    end\n\
    \  end\n  grid\nend", "    # write your code here\n    \n    count = 0\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    count = 0\n    buckets = Array.new(capacity)\n    grid.each\
    \ do |row|\n        row.each do |col|\n            buckets[col] -= 1\n       \
    \     count += buckets[col] >= 0\n        end\n    end\n    return count\nend\n\
    </cell>\n<text>\nSolution\nLet's see how we solve this problem. First, we need\
    \ to define the grid and the buckets. We will use an Array for our grid. An Array\
    \ is a collection of objects that can store any type of objects. In this case,\
    \ our grid is an array of arrays. Each row in the grid is an array, and each column\
    \ is a separate array in the grid. Let's see how we can create our grid.", " \
    \   # write your code here\n    count = 0\n    buckets = Array.new(capacity)\n\
    \    grid.each do |row|\n        row.each do |item|\n            if item == 1\n\
    \                buckets[item] += 1\n            end\n        end\n    end\n \
    \   buckets.each do |item|\n        if item < capacity\n            count += 1\n\
    \        end\n    end\n    return count\nend\n</cell>\n<text>\nBacktracking\n\
    Backtracking is a technique for solving problems where the solution space is too\
    \ large for our computer's memory. Backtracking is a recursive algorithm that\
    \ searches for a solution to an optimization problem by trying smaller variations\
    \ of the problem until it finds a solution. Backtracking can be thought of as\
    \ a way to solve the problem by trying every possible variation of the problem\
    \ until it finds a solution.", "    # write your code here\n    \n    count =\
    \ 0\n    \n    buckets = Array.new(capacity)\n    \n    grid.each do |row|\n \
    \       row.each do |cell|\n            if cell == 1\n                buckets[cell]\
    \ += 1\n            end\n        end\n    end\n    \n    buckets.each do |bucket|\n\
    \        count += bucket if bucket > 0\n    end\n    \n    return count\nend",
  "    count = 0\n    \n    # Iterate through each row\n    for row in grid\n    \
    \    \n        # Iterate through each column\n        for col in row\n       \
    \     \n            # If the bucket is full, empty it\n            if grid[row][col]\
    \ == 1\n                grid[row][col] = 0\n                count += 1\n     \
    \       \n            # If the bucket is empty, lower the bucket\n           \
    \ if grid[row][col] == 0\n                grid[row][col] = capacity - grid[row][col]\n\
    \                count += 1\n            \n    return count\n</cell>\n<text>\n\
    Let's test your function", "    # write your code here\n    count = 0\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    count = 0\n    \n    buckets = Array.new(10).fill(0).each_with_index.map\
    \ { |_, i| Array.new(10).fill(i) }\n    \n    grid.each do |row|\n        row.each_with_index\
    \ do |value, i|\n            if value == 1\n                buckets[value].each_with_index\
    \ do |bucket, i|\n                    bucket[i] = i\n                end\n   \
    \         end\n        end\n    end\n    \n    buckets.each do |bucket|\n    \
    \    bucket.each_with_index do |value, i|\n            if value == 0\n       \
    \         count += 1\n            end\n        end\n    end\n    \n    count\n\
    end\n</cell>\n<text>\nBacktracking\nThe above algorithm is recursive, which is\
    \ very slow for large problems. A better approach is to use backtracking.", " \
    \   count = 0\n    \n    # Fill the buckets\n    grid.each do |row|\n        row.each\
    \ do |cell|\n            if cell == 1\n                count += 1\n          \
    \  end\n        end\n    end\n    \n    # Lower the buckets\n    count = 0\n \
    \   grid.each do |row|\n        row.each do |cell|\n            if cell == 0\n\
    \                count += 1\n            end\n        end\n    end\n    \n   \
    \ return count\nend\n</cell>\n<text>\nSolution 2", "    count = 0\n    buckets\
    \ = Array.new(capacity)\n    grid.each do |row|\n        row.each do |val|\n \
    \           buckets[val] += 1\n        end\n    end\n    buckets.each do |val|\n\
    \        if val > 0\n            count += val\n        end\n    end\n    return\
    \ count\nend", "    # write your code here\n    count = 0\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    # Write your code here\n    count = 0\n    buckets = Array.new(101)\n\
    \    buckets[0] = capacity\n    grid.each do |row|\n        row.each do |col|\n\
    \            buckets[col] -= 1\n            count += 1 if buckets[col] > 0\n \
    \       end\n    end\n    return count\nend", "    count = 0\n    buckets = Array.new(capacity)\n\
    \    grid.each do |row|\n        row.each do |item|\n            buckets[item]\
    \ ||= 0\n            buckets[item] += 1\n        end\n    end\n    buckets.each\
    \ do |item|\n        count += 1 if item < capacity\n    end\n    count\nend",
  "    count = 0\n    \n    buckets = Array.new(capacity)\n    \n    grid.each do\
    \ |row|\n        row.each do |cell|\n            if cell == 1\n              \
    \  buckets[cell] -= 1\n            end\n        end\n    end\n    \n    buckets.each\
    \ do |bucket|\n        count += bucket == 0\n    end\n    \n    return count\n\
    end\n</cell>\n<code language=julia-1.5>", "    # write your code here\n    count\
    \ = 0\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    count = 0\n    \n    # iterate through\
    \ each row\n    for row in grid\n        # iterate through each column\n     \
    \   for col in row\n            # check if bucket is full\n            if grid[row][col]\
    \ == 1\n                # if bucket is full, empty it\n                grid[row][col]\
    \ = 0\n                # increment count by 1\n                count += 1\n  \
    \          end\n        end\n    end\n    \n    return count\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
