name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ work if the string contains numbers, e.g. \"123abc\".\n<|/ c |>\n<| c |>\nYes,\
    \ I noticed that and fixed it.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.reverse_each.with_index\
    \ do |char, i|\n    char == char.upcase ? s.chars[0...i] + char.downcase : char\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I\
    \ believe it can be done more efficiently by using a regex to match each character\
    \ and replace it with the character in upper case or lower case. Something like\
    \ `s.gsub(/./) { |c| c.upcase == c ? c.downcase : c }`\n<|/ c |>\n<| c |>\nYes,\
    \ that would work as well. My solution was more to show how it could be done with\
    \ Ruby methods. I agree that regex is more efficient.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I believe it can be done more efficiently by using a regex\
    \ to match each character and replace it with the character in upper case or lower\
    \ case. Something like `s.gsub(/./) { |c| c.upcase == c ? c.downcase : c }`\n\
    <|/ c |>\n<| c |>\nYes, that would work as well. My solution was more to show\
    \ how it could be done with Ruby methods. I agree that regex is more efficient.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x|\
    \ x.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  s.chars.each do |c|\n    next if c.nil?\n    if c.upcase == c\n  \
    \    s = c.downcase\n    elsif c.downcase == c\n      s = c.upcase\n    end\n\
    \  end\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if the string\
    \ contains numbers, e.g. \"123abc\".\n<|/ c |>\n<| c |>\nIt doesn't work because\
    \ `gsub!` modifies the string in place. `gsub` returns a new string with the modifications.\n\
    <|/ c |>\n<| c |>\nI didn't know that. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for \"#a@C\"\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the string contains\
    \ only letters.\n<|/ c |>\n<| c |>\nYes, it does. `solve(\"ab\")` returns `\"\
    AB\"`\n<|/ c |>\n<| c |>\nYes, it does. `solve(\"ab\")` returns `\"AB\"`\n<|/\
    \ c |>\n<| c |>\nYes, it does. `solve(\"ab\")` returns `\"AB\"`\n<|/ c |>\n<|\
    \ c |>\nYes, it does. `solve(\"ab\")` returns `\"AB\"`\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.gsub!(/[^A-Za-z]/) do |x|\n    x.upcase if x.downcase == x\n\
    \    x.downcase if x.upcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n\
    \  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n    x.upcase\
    \ if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase\
    \ if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/)\
    \ do |x|\n    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n \
    \   x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n\
    \    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n\
    \  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n    x.upcase\
    \ if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase\
    \ if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/)\
    \ do |x|\n    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n \
    \   x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n\
    \    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n\
    \  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if ", "  s.downcase!\n  s.gsub!(/[a-z]/)\
    \ { |x| x.upcase }\n  s.gsub!(/[^a-z]/) { |x| x.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    next if c.nil?\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if the string contains only letters.\n<|/ c |>\n<| c |>\n\
    Yes, I know. That's why I wrote \"If the string contains no letters, reverse the\
    \ string.\" in the first line. :)\n<|/ c |>\n<| c |>\nI didn't downvote you, but\
    \ I suspect it's because you didn't explain what your code does. You don't explain\
    \ what it does and how it does it.\n<|/ c |>\n<| c |>\nI added some explanation\
    \ to the answer. Hope it helps.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI believe this answer does not work. Try it out with\
    \ '#a@C'\n<|/ c |>\n<| c |>\nIt does work. Try it out with '#a@C'\n<|/ c |>\n\
    <| c |>\nI believe it does work. Try it out with '#a@C'\n<|/ c |>\n<| c |>\nI\
    \ believe it does work. Try it out with '#a@C'\n<|/ c |>\n<| c |>\nI believe it\
    \ does work. Try it out with '#a@C'\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end", "  s.chars.reverse.join if s.chars.any? else s.chars.reverse\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end", "  s.chars.reverse_each.with_index.reduce(:+)\nend\n</cell>\n<text>\nThe\
    \ Ruby Programming Language\nRuby is a programming language that runs on the Ruby\
    \ Virtual Machine. Ruby programs are written in Ruby code. Ruby programs are executed\
    \ using the Ruby interpreter. Ruby programs are executed by Ruby VM. Ruby programs\
    \ are executed by Ruby interpreter.", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c|\
    \ c.upcase }\n  s.reverse!\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/, '')\n\
    \  s.upcase! if s.include?('A')\n  s.downcase! if s.include?('a')\n  s\nend",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.downcase == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    else\n      s = c\n    end\n\
    \  end\n  s.reverse!\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI like your solution but I think it would be better\
    \ to use a regex to match only letters instead of `s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }`. That way you avoid the extra `s` variable and also avoid the extra `downcase!`\
    \ call.\n<|/ c |>\n<| c |>\nThanks for the suggestion, I've updated my answer.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby,string,regex |>\n<| c |>\nI like your solution, but I wonder why\
    \ you used `gsub!` instead of `gsub`?\n<|/ c |>\n<| c |>\nI used `gsub!` because\
    \ I wanted to modify the string in place. `gsub` would return a new string and\
    \ leave the original string untouched.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |s| s.upcase\
    \ }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s = s.to_s\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n\
    \  s.gsub!(/[^A-Z]/i) { |c| c.upcase }\n  s.gsub!(/[A-Z]/i) { |c| c.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\n`s.gsub(/[^A-Z]/i) { |c|\
    \ c.upcase }` can be written as `s.gsub(/[^A-Z]/i) { |c| c.upcase }.reverse`\n\
    <|/ c |>\n<| c |>\nYes, but that doesn't change the fact that `gsub!` returns\
    \ the original string unchanged, so `s.gsub(/[^A-Z]/i) { |c| c.upcase }.reverse`\
    \ would return `s`.\n<|/ c |>\n<| c |>\nYes, but `gsub!` returns the original\
    \ string unchanged, so `s.gsub(/[^A-Z]/i) { |c| c.upcase }.reverse` would return\
    \ `s`.\n<|/ c |>\n<| c |>\nYes, but `gsub!` returns the original string unchanged,\
    \ so `s.gsub(/[^A-Z]/i) { |c| c.upcase }.reverse` would return `s`.\n<|/ c |>\n\
    <| c |>\nYes, but `gsub!` returns the original string unchanged, so `s.gsub(/[^A-Z]/i)\
    \ { |c| c.upcase }.reverse` would return `s`.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your\
    \ solution. Very elegant and concise. Thanks.\n<|/ c |>\n<| c |>\nI like your\
    \ solution. Very elegant and concise. Thanks.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n \
    \   next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  s =\
    \ s.to_s\n  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like this solution. One thing\
    \ I noticed is that it only works for strings with one character. For example,\
    \ \"a\" returns \"A\", but \"aa\" returns \"AA\". Any ideas on how to fix that?\n\
    <|/ c |>\n<| c |>\nI added a fix for that case. Hope it helps.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s\
    \ = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThanks for your answer. Your solution is very similar to mine.\
    \ I am just wondering why my code doesn't work. I am new to Ruby and I am not\
    \ familiar with all the methods and methods that Ruby has.\n<|/ c |>\n<| c |>\n\
    I added my code to the question. Could you please take a look at it? Thanks.\n\
    <|/ c |>\n<| c |>\nI added my code to the question. Could you please take a look\
    \ at it? Thanks.\n<|/ c |>\n<| c |>\nI added my code to the question. Could you\
    \ please take a look at it? Thanks.\n<|/ c |>\n<| c |>\nI added my code to the\
    \ question. Could you please take a look at it? Thanks.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do it without using gsub! and downcase!\n\
    <|/ c |>\n<| c |>\n`gsub!` and `downcase!` are not mutating methods. `gsub!` returns\
    \ a new string and `downcase!` modifies the string in place.\n<|/ c |>\n<| c |>\n\
    I see, thank you. I'm still learning Ruby, so I appreciate the help.\n<|/ c |>\n\
    <| c |>\nI added a solution without gsub! and downcase!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if you have\
    \ a string like \"#a@C\"\n<|/ c |>\n<| c |>\nIt does work if you add `s.downcase!`\
    \ to the beginning of the method.\n<|/ c |>\n<| c |>\n`s.downcase!` will change\
    \ \"#a@C\" to \"#a@c\"\n<|/ c |>\n<| c |>\nYes, I missed that one. Thanks for\
    \ pointing it out. Fixed now.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ a string like \"#a@C\"\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.empty? ? s.reverse : s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '') \n  s\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for the answer. I am not allowed\
    \ to use any built-in methods. I only need to use gsub! and reverse!\n<|/ c |>\n\
    <| c |>\nI added a solution without using any built-in methods.\n<|/ c |>\n<|\
    \ c |>\nThanks for the answer. I am not allowed to use any built-in methods. I\
    \ only need to use gsub! and reverse!\n<|/ c |>\n<| c |>\nI added a solution without\
    \ using any built-in methods.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s = s.to_s\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if the\
    \ string contains numbers. For example, `solve(\"123\")` returns `\"321\"`.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require the string to be converted\
    \ to a string\n<|/ c |>\n<| c |>\n`gsub!` modifies the string in place, so the\
    \ original string isn't modified. `s.gsub(/[^a-z]/i) { |s| s.upcase }` would work\
    \ as expected.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+)\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't\
    \ work for `solve.call(\"aBcD\")`\n<|/ c |>\n<| c |>\n: It does work for me. `solve.call(\"\
    aBcD\")` returns `\"DcBa\"`.\n<|/ c |>\n<| c |>\n: It does work for me too. `solve.call(\"\
    aBcD\")` returns `\"DcBa\"`.\n<|/ c |>\n<| c |>\n: It does work for me too. `solve.call(\"\
    aBcD\")` returns `\"DcBa\"`.\n<|/ c |>\n<| c |>\n: It does work for me too. `solve.call(\"\
    aBcD\")` returns `\"DcBa\"`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end", "  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase\
    \ }\n  s.reverse!\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s\
    \ = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThis doesn't work for `solve.call(\"ab\")` which should return `\"AB\"\
    `.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it. Thanks.\n<|/ c |>\n<|\
    \ c |>\nThe `gsub` method also accepts a block, so you can do `s.gsub(/[[:lower:]]/)\
    \ { |c| c.upcase }` instead of `s.gsub(/[[:lower:]]/) { |c| c.downcase }`.\n<|/\
    \ c |>\n<| c |>\nI didn't know that. Thanks.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase\
    \ }\n  s.empty? ? s.reverse : s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) {\
    \ |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the string contains numbers,\
    \ it only works if it contains letters.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ the string contains numbers, it only works if it contains letters.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if the string contains numbers, it only works if it contains\
    \ letters.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains numbers,\
    \ it only works if it contains letters.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ the string contains numbers, it only works if it contains letters.\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    next if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n\
    \    next if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse.join\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x|\
    \ x.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    `s.downcase!` will change the string in place, so you don't need to assign it\
    \ to a variable. `s.gsub!(/[^a-z]/i) { |x| x.upcase }` will also change the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will also\
    \ change the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will also change the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will also change the string in place, so you don't need to assign\
    \ it to a variable. `s.reverse!` will also change the string in place, so you\
    \ don't need to assign it to a variable. `s.reverse!` will also change the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will also\
    \ change the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will also change the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will also change the string in place, so you don't need to assign\
    \ it to a variable. `s.reverse!` will also change the string in place, so you\
    \ don't need to assign it to a variable. `s.reverse!` will also change the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will also\
    \ change the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will also change the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will also change the string in place, so you don't need to assign\
    \ it to a variable. `s.reverse!` will also change the string in place, so you\
    \ don't need to assign it to a variable. `s.reverse!` will also change the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will also\
    \ change the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will also change the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will also change the string in place, so you don't need to assign\
    \ it to a variable. `s.reverse!` will also change the string in place, so you\
    \ don't need to assign it to a variable. `s.reverse!` will also change the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will also\
    \ change the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will also change the string in place, so you don't need to ", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.chars.reverse!\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\n<code>", "  s = s.to_s\n  s.chars.each do |c|\n    next\
    \ if c.nil?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.length == 0\n    next if c.length == 1\n    next if c.length == 2\n   \
    \ next if c.length == 3\n    next if c.length == 4\n    next if c.length == 5\n\
    \    next if c.length == 6\n    next if c.length == 7\n    next if c.length ==\
    \ 8\n    next if c.length == 9\n    next if c.length == 10\n    next if c.length\
    \ == 11\n    next if c.length == 12\n    next if c.length == 13\n    next if c.length\
    \ == 14\n    next if c.length == 15\n    next if c.length == 16\n    next if c.length\
    \ == 17\n    next if c.length == 18\n    next if c.length == 19\n    next if c.length\
    \ == 20\n    next if c.length == 21\n    next if c.length == 22\n    next if c.length\
    \ == 23\n    next if c.length == 24\n    next if c.length == 25\n    next if c.length\
    \ == 26\n    next if c.length == 27\n    next if c.length == 28\n    next if c.length\
    \ == 29\n    next if c.length == 30\n    next if c.length == 31\n    next if c.length\
    \ == 32\n    next if c.length == 33\n    next if c.length == 34\n    next if c.length\
    \ == 35\n    next if c.length == 36\n    next if c.length == 37\n    next if c.length\
    \ == 38\n    next if c.length == 39\n    next if c.length == 40\n    next if c.length\
    \ == 41\n    next if c.length == 42\n    next if c.length == 43\n    next if c.length\
    \ == 44\n    next if c.length == 45\n    next if c.length == 46\n    next if c.length\
    \ == 47\n    next if c.length == 48\n    next if c.length == 49\n    next if c.length\
    \ == 50\n    next if c.length == 51\n    next if c.length == 52\n    next if c.length\
    \ == 53\n    next if c.length == 54\n    next if c.length == 55\n    next if c.length\
    \ == 56\n    next if c.length == 57\n    next if c.length == 58\n    next if c.length\
    \ == 59\n    next if c.length == 60\n    next if ", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThanks so much! This was a great learning experience\
    \ for me. I'm still learning Ruby, so I appreciate the help.\n<|/ c |>\n<| c |>\n\
    I added a more efficient solution that doesn't require the intermediate array.\
    \ Hope it helps.\n<|/ c |>\n<| c |>\nThanks so much! I really appreciate it!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x|\
    \ x.upcase }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\n\
    \  s.gsub(/[^A-Z]/i) { |x| x.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| c |>\nThis doesn't work if there are multiple consecutive uppercase letters.\n\
    <|/ c |>\n<| c |>\nI didn't know that Ruby had `gsub!`.  I thought it was `gsub`.\
    \  Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI believe that `gsub!` modifies\
    \ the string in place.  I believe `gsub` returns a new string with the modifications.\n\
    <|/ c |>\n<| c |>\n`gsub!` modifies the string in place. `gsub` returns a new\
    \ string with the modifications.\n<|/ c |>\n<| c |>\nI believe `gsub` modifies\
    \ the string in place.  I believe `gsub!` returns a new string with the modifications.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.upcase)\n  \
    \  end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work if the string contains only lowercase letters.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work if the string contains only lowercase letters. Try it\
    \ on `\"a\"`.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains only\
    \ lowercase letters. Try it on `\"a\"`.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ the string contains only lowercase letters. Try it on `\"a\"`.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work if the string contains only lowercase letters. Try it\
    \ on `\"a\"`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s = s.to_s\n  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if there are multiple consecutive letters.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. I tested it before posting. Try it yourself\
    \ with `\"ab\"`.\n<|/ c |>\n<| c |>\n: I tested it again and it works fine. Try\
    \ it yourself with `\"ab\"`.\n<|/ c |>\n<| c |>\n: I tested it again and it works\
    \ fine. Try it yourself with `\"ab\"`.\n<|/ c |>\n<| c |>\n: I tested it again\
    \ and it works fine. Try it yourself with `\"ab\"`.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThanks for the answer. Can you\
    \ please explain how this works?\n<|/ c |>\n<| c |>\nThe `gsub` method replaces\
    \ all instances of a pattern with a block. `/[^a-z]/i` matches all non-letters.\
    \ `x.upcase` converts any non-letter to uppercase letters. `x.upcase!` converts\
    \ the string to uppercase and `s.reverse!` reverses the string.\n<|/ c |>\n<|\
    \ c |>\nThanks for the explanation. Can you please explain how this works?\n<|/\
    \ c |>\n<| c |>\nI added some comments to the code.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation. Can you please explain how this works?\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n\
    \  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` can be written as `s.gsub(/[^a-z]/i) { |s| s.upcase }`\n<|/\
    \ c |>\n<| c |>\nThanks I didn't know that. I've updated my answer.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n    \
    \  s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend", "  s.chars.each do |c|\n    if c.upcase\
    \ == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.downcase)\n\
    \    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI\
    \ like your solution. One thing though, `s.chars.join` will return a string with\
    \ all the characters in `s` joined together. `s.chars.join.downcase` will return\
    \ a string with all the characters in `s` downcased.\n<|/ c |>\n<| c |>\nYes,\
    \ I know. Just wanted to show that you can do it in one line :)\n<|/ c |>\n<|\
    \ c |>\nI like your solution. One thing though, `s.chars.join` will return a string\
    \ with all the characters in `s` joined together. `s.chars.join.downcase` will\
    \ return a string with all the characters in `s` downcased.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like\
    \ your solution, however it fails on `\"#a@C\"` which should be `\"#A@c\"`\n<|/\
    \ c |>\n<| c |>\nThanks for pointing that out. I've fixed the answer.\n<|/ c |>\n\
    <| c |>\n`s.gsub(/[^a-z]/i, '')` can be written `s.delete('a')`\n<|/ c |>\n<|\
    \ c |>\n`s.gsub(/[^a-z]/i, '')` can be written `s.delete('a')`\n<|/ c |>\n<| c\
    \ |>\n`s.gsub(/[^a-z]/i, '')` can be written `s.delete('a')`\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.start_with?(\"#\")\n    next if c.start_with?(\"$\")\n    next\
    \ if c.start_with?(\"%\")\n    next if c.start_with?(\"&\")\n    next if c.start_with?(\"\
    *\")\n    next if c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n   \
    \ next if c.start_with?(\"+\")\n    next if c.start_with?(\"-\")\n    next if\
    \ c.start_with?(\"=\")\n    next if c.start_with?(\"|\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\",\")\n    next if c.start_with?(\":\")\n    next if c.start_with?(\"\
    '\")\n    next if c.start_with?(\"\\\"\")\n    next if c.start_with?(\"?\")\n\
    \    next if c.start_with?(\"!\")\n    next if c.start_with?(\".\")\n    next\
    \ if c.start_with?(\"*\")\n    next if c.start_with?(\"/\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"?\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"*\")\n    next if c.start_with?(\"/\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"?\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"*\")\n    next if c.start_with?(\"/\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"?\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"*\")\n    next if c.start_with?(\"/\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"=\")\n    ", "  s.downcase!\n  s.gsub(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.gsub(/[^A-Z]/i) { |c| c.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.downcase ==\
    \ c\n    next if c.upcase == c\n    next if c.swapcase == c\n  end\n  s.chars.join\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I like your solution, but I think it would be more efficient to just use `gsub(/[a-z]/i)\
    \ { |s| s.upcase }` instead of `gsub(/[^a-z]/i) { |s| s.upcase }`.\n<|/ c |>\n\
    <| c |>\nYeah, I thought about that too, but I wasn't sure if that was the intended\
    \ behavior. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I think it would be more efficient to just use `gsub(/[a-z]/i) { |s| s.upcase\
    \ }` instead of `gsub(/[^a-z]/i) { |s| s.upcase }`.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I think it would be more efficient to just use `gsub(/[a-z]/i)\
    \ { |s| s.upcase }` instead of `gsub(/[^a-z]/i) { |s| s.upcase }`.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I think it would be more efficient to just\
    \ use `gsub(/[a-z]/i) { |s| s.upcase }` instead of `gsub(/[^a-z]/i) { |s| s.upcase\
    \ }`.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n \
    \   if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work. Try `solve(\"A\")`.\n<|/ c |>\n<| c |>\nYes,\
    \ I noticed that and fixed it. I was just trying to give a general idea of how\
    \ to solve the problem and didn't want to give the full solution. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI added a more general solution that should work\
    \ for any string and any case.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if there are multiple letters in a row. For example,\
    \ \"aA\" returns \"aA\", not \"AA\".\n<|/ c |>\n<| c |>\nIt does work if there\
    \ are multiple letters in a row. Try it yourself.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are multiple letters in a row. Try it yourself. `aA` returns `aA`,\
    \ not `AA`.\n<|/ c |>\n<| c |>\nIt does work if there are multiple letters in\
    \ a row. Try it yourself. `aA` returns `aA`, not `AA`.\n<|/ c |>\n<| c |>\nIt\
    \ does work if there are multiple letters in a row. Try it yourself. `aA` returns\
    \ `aA`, not `AA`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n\
    <| c |>\nThis doesn't work if the string contains only letters. `solve(\"a\")`\
    \ returns `\"a\"`.\n<|/ c |>\n<| c |>\n: It does work. `solve(\"a\")` returns\
    \ `\"a\"`. `solve(\"ab\")` returns `\"Ab\"`. `solve(\"aB\")` returns `\"Ab\"`.\n\
    <|/ c |>\n<| c |>\n: I missed the part where you said \"If the string contains\
    \ no letters, reverse the string.\" I thought you meant \"If the string contains\
    \ no letters, reverse the string and return the reversed string.\" I updated my\
    \ answer to reflect this.\n<|/ c |>\n<| c |>\n: I updated my answer to reflect\
    \ your clarification.\n<|/ c |>\n<| c |>\n: I updated my answer to reflect your\
    \ clarification.\n<|/ c |>\n<| a tags=ruby,string,regex |>\n<code>", "  s.gsub!(/[a-z]/i)\
    \ do |x|\n    x.upcase if x.downcase == x\n  end\n  s.gsub!(/[A-Z]/i) do |x|\n\
    \    x.downcase if x.upcase == x\n  end\n  s.gsub!(/[^a-z]/i) do |x|\n    x.upcase\
    \ if x.downcase == x\n  end\n  s.gsub!(/[^A-Z]/i) do |x|\n    x.downcase if x.upcase\
    \ == x\n  end\n  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase.upcase\n    next if c.upcase ==\
    \ c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n    next\
    \ if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.tr('A-Z', 'a-z')\n    next if c.downcase == c.upcase.tr('A-Z',\
    \ 'a-z')\n    next if c.upcase == c.downcase.tr('a-z', 'A-Z')\n    next if c.downcase\
    \ == c.upcase.tr('a-z', 'A-Z')\n    next if c.upcase == c.downcase.tr('A-Z', 'a-z').tr('a-z',\
    \ 'A-Z')\n    next if c.downcase == c.upcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z')\n\
    \    next if c.upcase == c.downcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z')\n    next\
    \ if c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z')\n    next if c.upcase\
    \ == c.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z').tr('A-Z', 'a-z')\n    next if\
    \ c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z').tr('A-Z', 'a-z')\n\
    \    next if c.upcase == c.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z').tr('A-Z',\
    \ 'a-z')\n    next if c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z').tr('A-Z',\
    \ 'a-z')\n    next if c.upcase == c.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z').tr('A-Z',\
    \ 'a-z')\n    next if c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z').tr('A-Z',\
    \ 'a-z')\n    next if c.upcase == c.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z').tr('A-Z',\
    \ 'a-z')\n    next if c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z').tr('A-Z',\
    \ 'a-z')\n    next if c.upcase == c.downcase.tr('A-Z', 'a-z').tr('a-z', 'A-Z').tr('A-Z',\
    \ 'a-z')\n    next if c.downcase == c.upcase.tr('a-z', 'A-Z').tr('A-Z', 'a-z').tr('A-Z',\
    \ 'a-z')\n    next if c.upcase == c.downcase.", "  s.chars.each do |c|\n    if\
    \ c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if there are\
    \ multiple letters in a string that need to be reversed.\n<|/ c |>\n<| c |>\n\
    Yes, it does. I tested it before posting.\n<|/ c |>\n<| c |>\nI tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting. It works. I tested it before posting. It works. I tested it before\
    \ posting", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.chars.reverse.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=2 |>\n<code>", "  s = s.to_s\n\
    \  s.gsub!(/[^A-Za-z]/, \"\")\n  s.gsub!(/[A-Z]/, \"\")\n  s.gsub!(/[a-z]/, \"\
    \")\n  s.gsub!(/[0-9]/, \"\")\n  s.gsub!(/[@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\")\n  s.gsub!(/[!@#]/, \"\"\
    )\n  s.gsub!(/[!@#]/, \"\")\n  ", "  s.downcase!\n  s.gsub(/[[:alpha:]]/) { |c|\
    \ c.upcase }\n  s.gsub(/[[:alpha:]]/) { |c| c.downcase }\n  s.gsub(/[^[:alpha:]]/)\
    \ { |c| c.upcase }\n  s.gsub(/[^[:alpha:]]/) { |c| c.downcase }\n  s\nend", " \
    \ s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ s.gsub!(/[^a-zA-Z]/,'')\n  s.gsub!(/[a-z]/){|s| s.upcase }\n  s.gsub!(/[A-Z]/){|s|\
    \ s.downcase }\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  s =\
    \ s.to_s\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase\
    \ }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n\
    \  s.reverse!\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Can you\
    \ please explain me the code you wrote? I mean the part where you used `gsub!`\n\
    <|/ c |>\n<| c |>\n`gsub!` replaces every occurrence of the given regex with the\
    \ given block. `/[^a-z]/i` matches a string that doesn't contain any letters.\
    \ `s.upcase` converts the matched string to uppercase.\n<|/ c |>\n<| c |>\nThanks\
    \ for your explanation. Can you please explain me the code you wrote? I mean the\
    \ part where you used `gsub!`\n<|/ c |>\n<| c |>\nThanks for your explanation.\
    \ Can you please explain me the code you wrote? I mean the part where you used\
    \ `gsub!`\n<|/ c |>\n<| c |>\nThanks for your explanation. Can you please explain\
    \ me the code you wrote? I mean the part where you used `gsub!`\n<|/ c |>\n<|\
    \ a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[^a-z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[a-z]/)\
    \ { |x| x.upcase }\n  s.gsub!(/[^a-z]/) { |x| x.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[a-z]/i) { |c| c.downcase\
    \ }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |c| c.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `solve(\"ab\")` returns `\"Aa\"` instead of\
    \ `\"Ab\"`.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing it\
    \ out. Fixed now.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[[:alpha:]]/) { |c| c.upcase }\n  s.gsub(/[^[:alpha:]]/) { |c| c.downcase\
    \ }\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nThis doesn't work if the string contains multiple letters.\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it before posting it.\n<|/ c |>\n<| c |>\nI tested\
    \ it and it doesn't work. Try it on `\"#a@C\"`\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I posted my test cases. I tested it on `\"#a@C\"` and it returned\
    \ `\"#A@c\"`.\n<|/ c |>\n<| c |>\nI tested it on `\"#a@C\"` and it returned `\"\
    #A@c\"`.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\n`s.downcase!` will mutate the string in place, so you don't need to assign\
    \ it to a variable. `s.gsub!(/[^a-z]/i) { |x| x.upcase }` will also mutate the\
    \ string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will mutate the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will mutate the string in place, so you don't need to assign it\
    \ to a variable. `s.reverse!` will mutate the string in place, so you don't need\
    \ to assign it to a variable. `s.reverse!` will mutate the string in place, so\
    \ you don't need to assign it to a variable. `s.reverse!` will mutate the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will mutate\
    \ the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will mutate the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will mutate the string in place, so you don't need to assign it\
    \ to a variable. `s.reverse!` will mutate the string in place, so you don't need\
    \ to assign it to a variable. `s.reverse!` will mutate the string in place, so\
    \ you don't need to assign it to a variable. `s.reverse!` will mutate the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will mutate\
    \ the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will mutate the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will mutate the string in place, so you don't need to assign it\
    \ to a variable. `s.reverse!` will mutate the string in place, so you don't need\
    \ to assign it to a variable. `s.reverse!` will mutate the string in place, so\
    \ you don't need to assign it to a variable. `s.reverse!` will mutate the string\
    \ in place, so you don't need to assign it to a variable. `s.reverse!` will mutate\
    \ the string in place, so you don't need to assign it to a variable. `s.reverse!`\
    \ will mutate the string in place, so you don't need to assign it to a variable.\
    \ `s.reverse!` will mutate the string in place, so you don't need to assign it\
    \ to a variable. `s.reverse!` will mutate the string in place, so you don't need\
    \ to assign it to a variable. `s.reverse!` will mutate the string in place, so ",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. Try it with `solve.call(\"ab\")`.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out. I've updated the answer. Now it works.\n<|/ c |>\n<| c |>\n\
    This still doesn't work. Try it with `solve.call(\"ab\")`.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out. I've updated the answer. Now it works.\n<|/ c |>\n\
    <| c |>\nThis still doesn't work. Try it with `solve.call(\"ab\")`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  s.chars.reverse!\n  s.chars.join\nend\n</cell>\n\
    <cell>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.chars.join\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work for \"#a@C\" which should return\
    \ \"#A@c\"\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the\
    \ answer to handle that case.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[a-z]/){|c| c.upcase }\n  s.gsub!(/[^a-z]/){|c| c.downcase }\n  s\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution, but I\
    \ wonder why you used `downcase!` instead of `downcase`? I thought `downcase!`\
    \ was a method on `String` which would mutate the string in place. `downcase`\
    \ returns a new string and doesn't mutate the original string.\n<|/ c |>\n<| c\
    \ |>\nI used `downcase!` because I wanted to mutate the string in place. `downcase`\
    \ returns a new string and doesn't mutate the original string. `downcase!` mutates\
    \ the string in place and `downcase` returns a new string and doesn't mutate the\
    \ original string. `downcase!` mutates the string in place and `downcase` returns\
    \ a new string and doesn't mutate the original string.\n<|/ c |>\n<| c |>\n`downcase!`\
    \ mutates the string in place and `downcase` returns a new string and doesn't\
    \ mutate the original string. `downcase!` mutates the string in place and `downcase`\
    \ returns a new string and doesn't mutate the original string. `downcase!` mutates\
    \ the string in place and `downcase` returns a new string and doesn't mutate the\
    \ original string.\n<|/ c |>\n<| c |>\nI see. Thanks for the explanation. I'm\
    \ still learning Ruby so I appreciate the clarification.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work for `solve.call(\"\
    ab\")`\n<|/ c |>\n<| c |>\nI didn't realize that `gsub!` would modify the original\
    \ string. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't modify the original string.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[a-z]/i) { |c| c.downcase\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for \"#a@C\" which should\
    \ return \"#A@c\"\n<|/ c |>\n<| c |>\nI thought the question was about reversing\
    \ case. I'll update my answer to handle that case.\n<|/ c |>\n<| c |>\nI added\
    \ a second solution that handles both cases.\n<|/ c |>\n<| c |>\nI added a third\
    \ solution that handles both cases.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n\
    </code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nI like your solution, but I\
    \ wonder why you used `gsub!` instead of `gsub`?\n<|/ c |>\n<| c |>\n`gsub!` modifies\
    \ the string in place. `gsub` returns a new string with the substitution applied.\n\
    <|/ c |>\n<| c |>\nI see, thanks. I guess I should read more about `gsub!`\n<|/\
    \ c |>\n<| c |>\n`gsub!` modifies the string in place. `gsub` returns a new string\
    \ with the substitution applied.\n<|/ c |>\n<| a tags=ruby,string,regex |>\n<code>",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI like this solution, but I wonder how it compares to other solutions\
    \ posted so far.\n<|/ c |>\n<| c |>\nI like it too, but I wonder how it compares\
    \ to other solutions posted so far.\n<|/ c |>\n<| c |>\nI like it too, but I wonder\
    \ how it compares to other solutions posted so far.\n<|/ c |>\n<| c |>\nI like\
    \ it too, but I wonder how it compares to other solutions posted so far.\n<|/\
    \ c |>\n<| c |>\nI like it too, but I wonder how it compares to other solutions\
    \ posted so far.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.downcase ==\
    \ c\n    next if c.upcase == c\n    next if c.to_s.upcase == c\n    next if c.to_s.downcase\
    \ == c\n    next if c.to_s.upcase.to_s == c\n    next if c.to_s.downcase.to_s\
    \ == c\n    next if c.to_s.upcase.to_s.downcase == c\n    next if c.to_s.upcase.to_s.upcase\
    \ == c\n    next if c.to_s.downcase.to_s.upcase == c\n    next if c.to_s.downcase.to_s.downcase\
    \ == c\n    next if c.to_s.upcase.to_s.upcase.to_s == c\n    next if c.to_s.upcase.to_s.downcase.to_s\
    \ == c\n    next if c.to_s.downcase.to_s.upcase.to_s == c\n    next if c.to_s.downcase.to_s.downcase.to_s\
    \ == c\n    next if c.to_s.upcase.to_s.upcase.to_s.downcase == c\n    next if\
    \ c.to_s.upcase.to_s.downcase.to_s.downcase == c\n    next if c.to_s.downcase.to_s.upcase.to_s.downcase\
    \ == c\n    next if c.to_s.downcase.to_s.downcase.to_s.downcase == c\n    next\
    \ if c.to_s.upcase.to_s.upcase.to_s.upcase.to_s == c\n    next if c.to_s.upcase.to_s.upcase.to_s.downcase.to_s\
    \ == c\n    next if c.to_s.upcase.to_s.downcase.to_s.upcase.to_s == c\n    next\
    \ if c.to_s.upcase.to_s.downcase.to_s.downcase.to_s == c\n    next if c.to_s.downcase.to_s.upcase.to_s.upcase.to_s\
    \ == c\n    next if c.to_s.downcase.to_s.upcase.to_s.downcase.to_s == c\n    next\
    \ if c.to_s.downcase.to_s.downcase.to_s.downcase.to_s == c\n    next if c.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\
    \ == c\n    next if c.to_s.upcase.to_s.upcase.to_s.downcase.to_s.downcase == c\n\
    \    next if c.to_s.upcase.to_s.downcase.to_s.upcase.to_s.downcase == c\n    next\
    \ if c.to_s.upcase.to_s.downcase.to_s.downcase.", "  s.chars.each do |c|\n   \
    \ next if c.nil?\n    next if c.empty?\n    next if c.start_with?(\"#\")\n   \
    \ next if c.start_with?(\"$\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"*\")\n    next if c.start_with?(\"+\")\n    next if c.start_with?(\"\
    (\")\n    next if c.start_with?(\")\")\n    next if c.start_with?(\";\")\n   \
    \ next if c.start_with?(\":\")\n    next if c.start_with?(\"<\")\n    next if\
    \ c.start_with?(\">\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\":\")\n    next if c.start_with?(\"(\")\n    next if c.start_with?(\"\
    )\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"[\")\n   \
    \ next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if\
    \ c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if c.start_with?(\"\
    :\")\n    next if c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n   \
    \ next if c.start_with?(\"=\")\n    next if c.start_with?(\"[\")\n    next if\
    \ c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if c.start_with?(\"\
    }\")\n    next if c.start_with?(\";\")\n    next if c.start_with?(\":\")\n   \
    \ next if c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n    next if\
    \ c.start_with?(\"=\")\n    next if c.start_with?(\"[\")\n    next if c.start_with?(\"\
    ]\")\n    next if c.start_with?(\"{\")\n    next if c.start_with?(\"}\")\n   \
    \ next if c.start_with?(\";\")\n    next if c.start_with?(\":\")\n    next if\
    \ c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work. Try `solve(\"aBcD\")`\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it out yourself. It returns `aBcD` as expected.\n<|/ c |>\n<| c |>\n\
    Yes, it does. But it also returns `aBcD` for `\"aBcD\"`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. But it also returns `aBcD` for `\"aBcD\"`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. But it also returns `aBcD` for `\"aBcD\"`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ doesn't work if the string contains any non-letters.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if the string\
    \ contains any non-letters. Try it yourself.\n<|/ c |>\n<| c |>\nI did try it\
    \ myself. It works. I added the output to my answer.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if the string contains any non-letters. Try it yourself.\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.tr(\"A-Z\", \"\
    a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Z\", \"a-z\")\n    next if c.upcase\
    \ == c.downcase.tr(\"a-z\", \"A-Z\")\n    next if c.downcase == c.upcase.tr(\"\
    a-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"A-Za-z\", \"A-Z\")\n\
    \    next if c.downcase == c.upcase.tr(\"A-Za-z\", \"A-Z\")\n    next if c.upcase\
    \ == c.downcase.tr(\"A-Za-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"\
    A-Za-z\", \"a-z\")\n    next if c.upcase == c.downcase.tr(\"a-z\", \"A-Z\")\n\
    \    next if c.downcase == c.upcase.tr(\"a-z\", \"A-Z\")\n    next if c.upcase\
    \ == c.downcase.tr(\"a-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"\
    a-z\", \"a-z\")\n    next if c.upcase == c.downcase.tr(\"A-Z\", \"A-Z\")\n   \
    \ next if c.downcase == c.upcase.tr(\"A-Z\", \"A-Z\")\n    next if c.upcase ==\
    \ c.downcase.tr(\"A-Z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Z\"\
    , \"a-z\")\n    next if c.upcase == c.downcase.tr(\"a-z\", \"A-Z\")\n    next\
    \ if c.downcase == c.upcase.tr(\"a-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"\
    a-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"a-z\", \"a-z\")\n   \
    \ next if c.upcase == c.downcase.tr(\"A-Z\", \"A-Z\")\n    next if c.downcase\
    \ == c.upcase.tr(\"A-Z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"A-Z\"\
    , \"a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Z\", \"a-z\")\n    next\
    \ if c.upcase == c.downcase.tr(\"a-z\", \"A-Z\")\n    next if c.downcase == c.upcase.tr(\"\
    a-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"a-z\", \"", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if the string contains more than one letter.\
    \ For example, `solve(\"ab\")` returns `\"Aa\"`.\n<|/ c |>\n<| c |>\nI didn't\
    \ realize that requirement. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if the string contains more than one letter. For example, `solve(\"\
    ab\")` returns `\"Aa\"`.\n<|/ c |>\n<| c |>\nI didn't realize that requirement.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work if the string\
    \ contains more than one letter. For example, `solve(\"ab\")` returns `\"Aa\"\
    `.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\nend", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/,\
    \ '')\n  s.upcase! if s.include?('A')\n  s.downcase! if s.include?('a')\n  s.reverse!\n\
    \  s\nend", "  s.chars.reverse!\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`s.chars.join` doesn't reverse the string. It just joins them together\
    \ into a string. `s.chars.reverse!` reverses the string. `s.chars.join` joins\
    \ the string back together into a string.\n<|/ c |>\n<| c |>\nYes, I know. My\
    \ point was that `s.chars.join` doesn't reverse the string. It just joins them\
    \ together into a string. `s.chars.reverse!` reverses the string. `s.chars.join`\
    \ joins the string back together into a string.\n<|/ c |>\n<| c |>\nI know. My\
    \ point was that `s.chars.join` doesn't reverse the string. It just joins them\
    \ together into a string. `s.chars.reverse!` reverses the string. `s.chars.join`\
    \ joins the string back together into a string.\n<|/ c |>\n<| c |>\nI know. My\
    \ point was that `s.chars.join` doesn't reverse the string. It just joins them\
    \ together into a string. `s.chars.reverse!` reverses the string. `s.chars.join`\
    \ joins the string back together into a string.\n<|/ c |>\n<| c |>\nI know. My\
    \ point was that `s.chars.join` doesn't reverse the string. It just joins them\
    \ together into a string. `s.chars.reverse!` reverses the string. `s.chars.join`\
    \ joins the string back together into a string.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  s.downcase!\n  s.gsub(/[[:alpha:]]/) { |c| c.upcase }\n  s.gsub(/[[:alpha:]]/)\
    \ { |c| c.downcase }\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend", "  s.gsub!(/[a-z]/) { |x| x.upcase }\n  s.gsub!(/[A-Z]/) { |x| x.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse }\n  s.gsub!(/[^A-Za-z]/) { |x| x.reverse\
    \ }\n  s.gsub!(/[^A-Za-z]/", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |x| x.downcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if there are multiple consecutive capital letters.\n<|/ c |>\n<| c |>\n\
    : I see what you mean. I've updated my answer to account for that.\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.upcase)\n  \
    \  end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+)\nend", "  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend", "  s.downcase!\n \
    \ s.gsub(/[a-z]/) { |x| x.upcase }\n  s.gsub(/[^a-z]/) { |x| x.downcase }\n  s\n\
    end", "  s.gsub!(/[a-z]/){|c| c.upcase if c.is_a?(String)}\n  s.gsub!(/[A-Z]/){|c|\
    \ c.downcase if c.is_a?(String)}\n  s.gsub!(/[^a-zA-Z]/){|c| c}\n  s.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s = s.to_s\n\
    \  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not work for the string \"#a@C\"\
    . It returns \"#A@c\".\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s\nend", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\n  s\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your help but I am not allowed\
    \ to use any additional methods. I must use gsub!, downcase! and reverse!\n<|/\
    \ c |>\n<| c |>\nI added a solution without gsub!, downcase! and reverse!\n<|/\
    \ c |>\n<| c |>\nThank you so much! I appreciate your help!\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s| s.upcase }\n\
    \  s.gsub!(/[a-z]/){|s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ using gsub!. I'm thinking about using gsub! because I feel like it would be\
    \ more efficient than using gsub and then reversing the string.\n<|/ c |>\n<|\
    \ c |>\nI added a solution without gsub!\n<|/ c |>\n<| c |>\nI added a solution\
    \ without gsub!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work for \"#a@C\"\n<|/ c |>\n<| c |>\nIt works for\
    \ me on \"#a@C\"\n<|/ c |>\n<| c |>\nIt works for me on \"#a@C\" too. Ruby 2.5.1p57\
    \ (2018-03-29 revision 63029) [x86_64-darwin18]\n<|/ c |>\n<| c |>\nIt works for\
    \ me on \"#a@C\" too. Ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin18]\n\
    <|/ c |>\n<| c |>\nIt works for me on \"#a@C\" too. Ruby 2.5.1p57 (2018-03-29\
    \ revision 63029) [x86_64-darwin18]\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", "  s.gsub!(/[a-z]/i)\
    \ do |x|\n    x.upcase if x.downcase == x\n    x.downcase\n  end\n  s.gsub!(/[^a-z]/i)\
    \ do |x|\n    x.upcase if x.downcase == x\n    x.downcase\n  end\n  s\nend", " \
    \ s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[a-z]/i) { |c| c.downcase\
    \ }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work\
    \ if the string is `\"#a@C\"`\n<|/ c |>\n<| c |>\nI fixed it\n<|/ c |>\n<| c |>\n\
    This doesn't work if the string is `\"#a@C\"`\n<|/ c |>\n<| c |>\nI fixed it\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the string is `\"#a@C\"`\n<|/ c |>\n<|\
    \ a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work.\
    \ `'a'.upcase` returns `'A'`, not `'a'`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've updated the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.downcase == c\n    next if c.upcase == c\n    next if c.to_s.downcase\
    \ == c\n    next if c.to_s.upcase == c\n    next if c.to_s.downcase == c.to_s.upcase\n\
    \    next if c.to_s.upcase == c.to_s.downcase\n    next if c.to_s.downcase ==\
    \ c.to_s.upcase.to_s.downcase\n    next if c.to_s.upcase == c.to_s.downcase.to_s.upcase\n\
    \    next if c.to_s.downcase == c.to_s.upcase.to_s.downcase.to_s.downcase\n  \
    \  next if c.to_s.upcase == c.to_s.downcase.to_s.upcase.to_s.upcase\n    next\
    \ if c.to_s.downcase == c.to_s.upcase.to_s.downcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.upcase == c.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.downcase == c.to_s.upcase.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.upcase == c.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.downcase == c.to_s.upcase.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.upcase == c.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.downcase == c.to_s.upcase.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.upcase == c.to_s.downcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.upcase.to_s.downcase\n\
    \    next if c.to_s.down", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `downcase!` method modifies\
    \ the string in place. `gsub!` returns a new string. `reverse!` reverses the string\
    \ in place. `downcase!` modifies the string in place. `gsub!` returns a new string.\
    \ `reverse!` reverses the string in place. `downcase!` modifies the string in\
    \ place. `gsub!` returns a new string. `reverse!` reverses the string in place.\
    \ `downcase!` modifies the string in place. `gsub!` returns a new string. `reverse!`\
    \ reverses the string in place. `downcase!` modifies the string in place. `gsub!`\
    \ returns a new string. `reverse!` reverses the string in place. `downcase!` modifies\
    \ the string in place. `gsub!` returns a new string. `reverse!` reverses the string\
    \ in place.\n<|/ c |>\n<| c |>\nThe `downcase!` method modifies the string in\
    \ place. `gsub!` returns a new string. `reverse!` reverses the string in place.\
    \ `downcase!` modifies the string in place. `gsub!` returns a new string. `reverse!`\
    \ reverses the string in place. `downcase!` modifies the string in place. `gsub!`\
    \ returns a new string. `reverse!` reverses the string in place. `downcase!` modifies\
    \ the string in place. `gsub!` returns a new string. `reverse!` reverses the string\
    \ in place. `downcase!` modifies the string in place. `gsub!` returns a new string.\
    \ `reverse!` reverses the string in place. `downcase!` modifies the string in\
    \ place. `gsub!` returns a new string. `reverse!` reverses the string in place.\n\
    <|/ c |>\n<| c |>\nThe `downcase!` method modifies the string in place. `gsub!`\
    \ returns a new string. `reverse!` reverses the string in place. `downcase!` modifies\
    \ the string in place. `gsub!` returns a new string. `reverse!` reverses the string\
    \ in place. `downcase!` modifies the string in place. `gsub!` returns a new string.\
    \ `reverse!", "  s.downcase!\n  s.gsub(/[a-z]/i) do |x|\n    if x.upcase == x\n\
    \      x.upcase!\n    else\n      x.downcase!\n    end\n  end\n  s\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your solution, but I believe it would be more\
    \ efficient to just do `s.gsub(/[a-z]/i) { |x| x.upcase == x ? x.upcase : x.downcase\
    \ }`\n<|/ c |>\n<| c |>\nI agree, that would be more efficient. My solution was\
    \ more to show how to use `gsub` with blocks.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, your solution is more efficient. My solution was more to show how to use\
    \ `gsub` with blocks.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/) do |x|\n    x.upcase if x.match?(/[a-z]/)\n    x.downcase\
    \ if x.match?(/[A-Z]/)\n    x\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nI like your solution, but I wonder why you used `gsub` instead of `tr`?\n\
    <|/ c |>\n<| c |>\n`tr` would also work, but I find `gsub` more readable and easier\
    \ to understand.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder why you\
    \ used `gsub` instead of `tr`?\n<|/ c |>\n<| c |>\n`tr` would also work, but I\
    \ find `gsub` more readable and easier to understand.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder why you used `gsub` instead of `tr`?\n<|/ c |>\n\
    <| a |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.downcase!\n  s.gsub(/[a-z]/i) do |x|\n    x.upcase if x.match?(/[a-z]/i)\n\
    \    x.downcase if x.match?(/[A-Z]/i)\n    x\n  end\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work.\
    \ `solve(\"AaBbCcDd\")` returns `\"AbCdD\"`.\n<|/ c |>\n<| c |>\nI guess I misunderstood\
    \ the question. I've updated my answer.\n<|/ c |>\n<| a |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for me. I am just wondering why my code doesn't work? I thought the gsub! method\
    \ would replace all non-letters with their uppercase counterparts and then all\
    \ letters with their lowercase counterparts. Why doesn't this work?\n<|/ c |>\n\
    <| c |>\nThe `gsub!` method doesn't replace anything. It just modifies the string\
    \ in place. `gsub!` doesn't return anything.\n<|/ c |>\n<| c |>\nThanks for your\
    \ explanation. I understand now.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/, \"\")\n  s.downcase!\n  s.reverse!\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work\
    \ if you have a string like \"aA\" which should return \"aA\" but instead returns\
    \ \"aA\"\n<|/ c |>\n<| c |>\nI believe this would work if you changed the regex\
    \ to `/[^a-z]/i`\n<|/ c |>\n<| c |>\nI believe this would work if you changed\
    \ the regex to `/[^a-z]/i`\n<|/ c |>\n<| c |>\nI believe this would work if you\
    \ changed the regex to `/[^a-z]/i`\n<|/ c |>\n<| c |>\nI believe this would work\
    \ if you changed the regex to `/[^a-z]/i`\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like your solution.\
    \ Could you please explain how it works?\n<|/ c |>\n<| c |>\nI added some explanation.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s = s.to_s\n  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for `solve.call(\"\
    ab\")` which should return `\"AB\"`.\n<|/ c |>\n<| c |>\nI didn't notice that\
    \ requirement. I've updated my answer.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to use gsub. Something\
    \ like `s.chars.each { |c| s.gsub!(c,c.upcase == c ? c.downcase : c.upcase) }`\n\
    <|/ c |>\n<| c |>\nYes, you can do it without gsub, but it's less readable. I've\
    \ updated my answer.\n<|/ c |>\n<| a |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nThis doesn't work if the\
    \ string contains only letters.\n<|/ c |>\n<| c |>\n: It does work. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase\
    \ #=> \"a\"`. `'a'.upcase #=> \"A\"` and `'a'.downcase #=> \"a\"`. `'a'.upcase\
    \ #=> \"A\"` and `'a'.downcase #=> \"", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    next if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n\
    \    next if c.upcase == c.downcase\n    next if c.upcase == c.downcase.tr(\"\
    A-Z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Z\", \"a-z\")\n   \
    \ next if c.upcase == c.downcase.tr(\"a-z\", \"A-Z\")\n    next if c.downcase\
    \ == c.upcase.tr(\"a-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"A-Za-z\"\
    , \"A-Z\")\n    next if c.downcase == c.upcase.tr(\"A-Za-z\", \"A-Z\")\n    next\
    \ if c.upcase == c.downcase.tr(\"A-Za-z\", \"a-z\")\n    next if c.downcase ==\
    \ c.upcase.tr(\"A-Za-z\", \"a-z\")\n    next if c.upcase == c.downcase.tr(\"a-z\"\
    , \"A-Z\")\n    next if c.downcase == c.upcase.tr(\"a-z\", \"A-Z\")\n    next\
    \ if c.upcase == c.downcase.tr(\"a-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"\
    a-z\", \"a-z\")\n    next if c.upcase == c.downcase.tr(\"A-Z\", \"A-Z\")\n   \
    \ next if c.downcase == c.upcase.tr(\"A-Z\", \"A-Z\")\n    next if c.upcase ==\
    \ c.downcase.tr(\"A-Z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Z\"\
    , \"a-z\")\n    next if c.upcase == c.downcase.tr(\"a-z\", \"A-Z\")\n    next\
    \ if c.downcase == c.upcase.tr(\"a-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"\
    a-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"a-z\", \"a-z\")\n   \
    \ next if c.upcase == c.downcase.tr(\"A-Za-z\", \"A-Z\")\n    next if c.downcase\
    \ == c.upcase.tr(\"A-Za-z\", \"A-Z\")\n    next if c.upcase == c.downcase.tr(\"\
    A-Za-z\", \"a-z\")\n    next if c.downcase == c.upcase.tr(\"A-Za-z\", \"a-z\"\
    )\n    next if c.upcase == c.downcase.tr(\"A-Za-z\", \"A-Z\")\n    next if c.downcase\
    \ == c.upcase.tr(\"A-Za-z\", \"A-Z\")\n    next if c.upcase == c.", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.start_with?(\"\
    #\")\n    next if c.start_with?(\"$\")\n    next if c.start_with?(\"%\")\n   \
    \ next if c.start_with?(\"&\")\n    next if c.start_with?(\"*\")\n    next if\
    \ c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"-\")\n    next if c.start_with?(\".\")\n   \
    \ next if c.start_with?(\"/\")\n    next if c.start_with?(\":\")\n    next if\
    \ c.start_with?(\";\")\n    next if c.start_with?(\"<\")\n    next if c.start_with?(\"\
    >\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"?\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\",\")\n    next if\
    \ c.start_with?(\"'\")\n    next if c.start_with?(\"`\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\"(\")\n    next if\
    \ c.start_with?(\")\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    '\")\n    next if c.start_with?(\"`\")\n    next if c.start_with?(\"[\")\n   \
    \ next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if\
    \ c.start_with?(\"}\")\n    next if c.start_with?(\"(\")\n    next if c.start_with?(\"\
    )\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"'\")\n   \
    \ next if c.start_with?(\"`\")\n    next if c.start_with?(\"[\")\n    next if\
    \ c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if c.start_with?(\"\
    }\")\n    next if c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n   \
    \ next if c.start_with?(\",\")\n    next if c.start_with?(\"'\")\n    ", "  s\
    \ = s.to_s\n  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.upcase!\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like your solution,\
    \ but I wonder why you use `gsub!` instead of `gsub`? I thought `gsub!` was a\
    \ mutating method, and therefore should be used only when you need to change a\
    \ string, not when you need to replace a substring in a string. Or am I missing\
    \ something?\n<|/ c |>\n<| c |>\n`gsub!` mutates the string in place. `gsub` returns\
    \ a new string with the substitution made. `gsub!` is more efficient because it\
    \ doesn't have to create a new string every time.\n<|/ c |>\n<| c |>\n`gsub!`\
    \ mutates the string in place. `gsub` returns a new string with the substitution\
    \ made. `gsub!` is more efficient because it doesn't have to create a new string\
    \ every time.\n<|/ c |>\n<| c |>\n`gsub!` mutates the string in place. `gsub`\
    \ returns a new string with the substitution made. `gsub!` is more efficient because\
    \ it doesn't have to create a new string every time.\n<|/ c |>\n<| c |>\n`gsub!`\
    \ mutates the string in place. `gsub` returns a new string with the substitution\
    \ made. `gsub!` is more efficient because it doesn't have to create a new string\
    \ every time.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i)\
    \ { |c| c.upcase }\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.chars.reverse_each.with_index do |c,i|\n    next if c.nil?\n   \
    \ next if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n \
    \   next if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.",
  "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x|\
    \ x.downcase }\n  s.reverse!\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse.join\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the string contains\
    \ more than one letter. For example, `solve(\"ab\")` returns `\"ba\"` instead\
    \ of `\"ab\"`.\n<|/ c |>\n<| c |>\nI fixed the code so that it works with multiple\
    \ letters.\n<|/ c |>\n<| c |>\nThis doesn't work if the string contains more than\
    \ one letter. For example, `solve(\"ab\")` returns `\"ba\"` instead of `\"ab\"\
    `.\n<|/ c |>\n<| c |>\nI fixed the code so that it works with multiple letters.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.start_with?(\"#\")\n    next if c.start_with?(\"$\")\n    next\
    \ if c.start_with?(\".\")\n    next if c.start_with?(\"+\")\n    next if c.start_with?(\"\
    *\")\n    next if c.start_with?(\"?\")\n    next if c.start_with?(\"!\")\n   \
    \ next if c.start_with?(\":\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\"<\")\n    next if c.start_with?(\">\")\n    next if c.start_with?(\"\
    =\")\n    next if c.start_with?(\"%\")\n    next if c.start_with?(\"&\")\n   \
    \ next if c.start_with?(\"'\")\n    next if c.start_with?(\"(\")\n    next if\
    \ c.start_with?(\")\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\":\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\":\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\":\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\";\")\n    next if\
    \ c.start_with?(\":\")\n    next if c.start_with?(\",\")\n    next if c.start_with?",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if there are multiple letters\
    \ in the string. For example, if `s = \"#a@C\"`, then `s.downcase!` will change\
    \ it to `\"#a@c\"`, which then gets reversed to `\"#a@C\"`.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing that out. I've updated my answer to fix it.\n<|/ c |>\n\
    <| c |>\n, thanks for pointing that out. I've updated my answer to fix it.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s\nend", "  s =\
    \ s.to_s\n  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |c|\n  \
    \  if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    else\n      s = c\n    end\n  end\n  s.reverse!\n  s\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `'#a@C'.gsub(/#/, '').gsub(/@/,\
    \ '').gsub(/c/, '').gsub(/A/, '').gsub(/B/, '').gsub(/a/, '').gsub(/b/, '').gsub(/1/,\
    \ '').gsub(/2/, '').gsub(/3/, '').gsub(/4/, '').gsub(/5/, '').gsub(/6/, '').gsub(/7/,\
    \ '').gsub(/8/, '').gsub(/9/, '').gsub(/0/, '').gsub(/1/, '').gsub(/2/, '').gsub(/3/,\
    \ '').gsub(/4/, '').gsub(/5/, '').gsub(/6/, '').gsub(/7/, '').gsub(/8/, '').gsub(/9/,\
    \ '').gsub(/0/, '').gsub(/1/, '').gsub(/2/, '').gsub(/3/, '').gsub(/4/, '').gsub(/5/,\
    \ '').gsub(/6/, '').gsub(/7/, '').gsub(/8/, '').gsub(/9/, '').gsub(/0/, '').gsub(/1/,\
    \ '').gsub(/2/, '').gsub(/3/, '').gsub(/4/, '').gsub(/5/, '').gsub(/6/, '').gsub(/7/,\
    \ '').gsub(/8/, '').gsub(/9/, '').gsub(/0/, '').gsub(/1/, '').gsub(/2/, '').gsub(/3/,\
    \ '').gsub(/4/, '').gsub(/5/, '').gsub(/6/, '').gsub(/7/, '').gsub(/8/, '').gsub(/9/,\
    \ '').gsub(/0/, '').gsub(/1/, '').gsub(/2/, '').gsub(/3/, '').gsub(/4/, '').gsub(/5/,\
    \ '').gsub(/6/, '').gsub(/7/, '').gsub(/8/, '').gsub(/9/, '').g", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |c| c.upcase }\n  s.gsub!(/[A-Z]/i) { |c| c.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[^A-Z]/i) { |x| x.downcase }\n  s\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if the string contains any non-letters.\n<|/\
    \ c |>\n<| c |>\nYes, I know. That's why I said \"If the string contains no letters,\
    \ reverse the string.\" I didn't want to give a solution that doesn't work. :)\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood your comment then. :)\n<|/ c |>\n<|\
    \ c |>\nI guess I misunderstood your comment then. :)\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.join\nend", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThis doesn't work for `solve.call(\"ab\")` which should return `\"AB\"\
    `.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing it out. I've\
    \ updated the answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.join\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s\nend", "  s.chars.reverse_each.with_index.reduce(:+)\nend", "  s.chars.reverse_each.with_index\
    \ do |char, index|\n    if char.upcase == char\n      s.chars[index] = char.downcase\n\
    \    else\n      s.chars[index] = char\n    end\n  end\n  s.chars.join\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I wonder why you\
    \ used `chars.reverse_each` instead of `chars.reverse`?\n<|/ c |>\n<| c |>\nI\
    \ used `chars.reverse_each` because I wanted to modify the original string and\
    \ I wanted to keep the original index. `chars.reverse` would not do that. `chars.reverse`\
    \ would return a new string with the characters reversed.\n<|/ c |>\n<| c |>\n\
    I see. Thanks for explaining.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| c |>\nI like your solution. Very concise. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your solution. Very concise. Thanks!\n<|/ c |>\n<| a\
    \ tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`s.downcase!`\
    \ will mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will also mutate\
    \ the string. `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase\
    \ }` will mutate the string. `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }` will mutate the string. `s.reverse!` will mutate the string.\
    \ `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string. `s.reverse!` will\
    \ mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string.\
    \ `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will\
    \ mutate the string. `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }` will mutate the string. `s.reverse!` will mutate the string.\
    \ `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string. `s.reverse!` will\
    \ mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string.\
    \ `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will\
    \ mutate the string. `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }` will mutate the string. `s.reverse!` will mutate the string.\
    \ `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string. `s.reverse!` will\
    \ mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will mutate the string.\
    \ `s.reverse!` will mutate the string. `s.gsub!(/[^a-z]/i) { |c| c.upcase }` will\
    \ mutate the string. ", "  s.chars.each do |c|\n    if c.upcase == c\n      s\
    \ = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) {\
    \ |c| c.upcase }\n  s.gsub(/[^A-Z]/i) { |c| c.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
