name: HumanEval_47_median
language: py
prompt: "from typing import List\n\ndef median(l: List[int]) -> float:\n    \"\"\"\
  Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n\
  \    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert\
  \ candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n\
  \    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7])\
  \ == 7\n\ndef test_check():\n    check(median)\n\ntest_check()\n"
completions: ["    # In-place sorting as we don't need original list\n    l.sort()\n\
    \    if len(l) % 2 == 0:\n        # Even number of elements\n        return (l[len(l)\
    \ // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        # Odd number of elements\n\
    \        return l[len(l) // 2]\n", "    s = sorted(l)\n    n = len(s)\n    if\
    \ n % 2 == 1:\n        return s[n // 2]\n    else:\n        mid = n // 2\n   \
    \     return (s[mid] + s[mid - 1]) / 2\n", "    sorted_l = sorted(l)\n    n =\
    \ len(l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n   \
    \     return 0.5 * (sorted_l[n // 2 - 1] + sorted_l[n // 2])", "    # the following\
    \ code is a bit faster\n    # length = len(l)\n    # if length % 2 == 1:\n   \
    \ #     return sorted(l)[length // 2]\n    # else:\n    #     return (sorted(l)[length\
    \ // 2 - 1] + sorted(l)[length // 2]) / 2\n\n    sorted_l = sorted(l)\n    length\
    \ = len(sorted_l)\n    if length % 2 == 1:\n        return sorted_l[length //\
    \ 2]\n    else:\n        return (sorted_l[length // 2 - 1] + sorted_l[length //\
    \ 2]) / 2\n", "    i = sorted(l)\n    n = len(i)\n    if n == 0:\n        raise\
    \ ValueError(\"median of empty list\")\n    elif n % 2 == 1:\n        return i[n\
    \ // 2]\n    else:\n        return (i[n // 2 - 1] + i[n // 2]) / 2\n", "    n\
    \ = len(l)\n    sorted_l = sorted(l)\n    if n % 2 == 1:\n        # If odd, return\
    \ the middle element\n        return sorted_l[n // 2]\n    else:\n        # If\
    \ even, return the average of the middle elements\n        return (sorted_l[n\
    \ // 2 - 1] + sorted_l[n // 2]) / 2", "    # Sort the list\n    sorted_l = sorted(l)\n\
    \    # Check if list has odd number of elements\n    if len(sorted_l) % 2 == 1:\n\
    \        # Return middle element\n        return sorted_l[len(sorted_l) // 2]\n\
    \    else:\n        # Return average of middle elements\n        return (sorted_l[len(sorted_l)\
    \ // 2] + sorted_l[len(sorted_l) // 2 - 1]) / 2", "    s = sorted(l)\n    n =\
    \ len(s)\n    if n % 2 == 1:\n        return s[n // 2]\n    else:\n        return\
    \ (s[n // 2 - 1] + s[n // 2]) / 2\n", "    sorted_l = sorted(l)\n    n = len(l)\n\
    \    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return\
    \ (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2\n", "    # Sort the list from\
    \ low to high.\n    n = len(l)\n    copy = sorted(l)\n    if n % 2 == 1:  #  odd\
    \ length list\n        return copy[n // 2]\n    else:           #  even length\
    \ list\n        return (copy[n // 2 - 1] + copy[n // 2]) / 2\n", "    n = len(l)\n\
    \    if n % 2 == 1:\n        return sorted(l)[n // 2]\n    else:\n        return\
    \ sum(sorted(l)[n // 2 - 1:n // 2 + 1]) / 2\n", "    l.sort()\n    if len(l) %\
    \ 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l)\
    \ // 2] + l[len(l) // 2 - 1]) / 2\n", "    sorted_l = sorted(l)\n    n = len(l)\n\
    \    if n == 0:\n        raise ValueError(\"List l must not be empty\")\n    elif\
    \ n == 1:\n        return l[0]\n    else:\n        if n % 2 == 0:\n          \
    \  return sum(sorted_l[n//2-1:n//2+1]) / 2\n        else:\n            return\
    \ sorted_l[n//2]\n", "    l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l)\
    \ // 2]\n    else:\n        return sum(l[len(l) // 2 - 1: len(l) // 2 + 1]) /\
    \ 2", "    s = sorted(l)\n    if len(s) % 2 == 1:\n        return s[len(s) //\
    \ 2]\n    else:\n        return (s[len(s) // 2] + s[len(s) // 2 - 1]) / 2\n",
  "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n   \
    \ else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n", "    # sort\
    \ the list\n    l.sort()\n    mid = len(l) // 2\n    if len(l) % 2 == 0:\n   \
    \     return 0.5 * (l[mid - 1] + l[mid])\n    else:\n        return l[mid]\n",
  "    if len(l) == 0:\n        raise ValueError(\"Expected a non-empty list.\")\n\
    \    if len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2])\
    \ / 2\n    else:\n        return l[len(l) // 2]", "    l.sort()\n    N = len(l)\n\
    \    if N % 2 == 1:\n        return l[N // 2]\n    else:\n        return 0.5 *\
    \ (l[N // 2 - 1] + l[N // 2])\n", "    m = len(l) // 2\n    l.sort()\n    if len(l)\
    \ % 2 == 0:\n        return (l[m] + l[m-1]) / 2\n    else:\n        return l[m]\n",
  "    n = len(l)\n    # sort the list in ascending order\n    l.sort()\n    # if\
    \ the list has an odd number of elements, return the middle element\n    if n\
    \ % 2 != 0:\n        return l[n // 2]\n    # if the list has an even number of\
    \ elements, return the average of the two\n    # middle elements\n    else:\n\
    \        return (l[n // 2 - 1] + l[n // 2]) / 2\n", "    s = sorted(l)\n    n\
    \ = len(s)\n    if n % 2 == 1:\n        return s[n // 2]\n    else:\n        #\
    \ the line below means \"return the mean of the middle two elements\"\n      \
    \  return (s[n // 2 - 1] + s[n // 2]) / 2", "    n = len(l)\n    if n == 0:\n\
    \        raise ValueError\n    s = sorted(l)\n    # mid = n // 2\n    # return\
    \ (s[mid] + s[mid-1]) / 2\n    mid = n // 2\n    if n % 2 == 1:\n        return\
    \ s[mid]\n    else:\n        return (s[mid] + s[mid-1]) / 2", "    l.sort()\n\
    \    n = len(l)\n    middle = n // 2\n    if n % 2 == 0:\n        return (l[middle\
    \ - 1] + l[middle]) / 2\n    else:\n        return l[middle]\n", "    n = len(l)\n\
    \    if n == 0:\n        raise ValueError('median from empty list')\n    if n\
    \ % 2 == 1:\n        return sorted(l)[n // 2]\n    else:\n        return sum(sorted(l)[n\
    \ // 2 - 1:n // 2 + 1]) / 2", "    n = len(l)\n    sorted_l = sorted(l)\n    if\
    \ n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        middle_index\
    \ = n // 2\n        return (sorted_l[middle_index - 1] + sorted_l[middle_index])\
    \ / 2", "    ll = len(l)\n    if ll % 2 == 1:\n        return l[ll // 2]\n   \
    \ else:\n        return (l[ll // 2 - 1] + l[ll // 2]) / 2\n\n\n", "    sorted_l\
    \ = sorted(l)\n    length = len(sorted_l)\n    if length % 2 == 1:\n        return\
    \ sorted_l[length // 2]\n    else:\n        middle = length // 2\n        return\
    \ (sorted_l[middle - 1] + sorted_l[middle]) / 2", "    l = sorted(l)\n    n =\
    \ len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return\
    \ (l[n // 2 - 1] + l[n // 2]) / 2\n", "    if not l:\n        return 0\n    l.sort()\n\
    \    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return\
    \ (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n", "    n = len(l)\n    l = sorted(l)\n\
    \    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n\
    \ // 2 - 1] + l[n // 2]) / 2\n", "    l.sort()\n    # List is even sized\n   \
    \ if len(l) % 2 == 0:\n        return ((l[len(l) // 2] + l[len(l) // 2 - 1]) /\
    \ 2)\n    # List is odd sized\n    else:\n        return l[len(l) // 2]\n", " \
    \   s = sorted(l)\n    i = len(s) // 2\n    if len(s) % 2 == 0:\n        return\
    \ (s[i-1] + s[i]) / 2\n    else:\n        return s[i]\n", "    l.sort()\n    if\
    \ len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n\
    \    else:\n        return l[len(l) // 2]\n", "    l.sort()\n    if len(l)%2 !=\
    \ 0:\n        return l[len(l)//2]\n    else:\n        return (l[len(l)//2 - 1]\
    \ + l[len(l)//2])/2\n    ", "    # Ensure that l is not empty\n    if not l:\n\
    \        raise ValueError(\"Median of empty list is not defined\")\n    # Handle\
    \ single element cases\n    if len(l) == 1:\n        return l[0]\n    # Sort the\
    \ elements in l\n    l = sorted(l)\n    # Get length of list\n    n = len(l)\n\
    \    # Return the middle element\n    if n % 2 == 1:\n        return l[n // 2]\n\
    \    # Return the average of the two middle elements\n    else:\n        return\
    \ (l[n // 2 - 1] + l[n // 2]) / 2", "    sorted_l = sorted(l)\n    if len(sorted_l)\
    \ % 2 == 1:\n        return sorted_l[len(sorted_l) // 2]\n    return (sorted_l[len(sorted_l)\
    \ // 2] + sorted_l[len(sorted_l) // 2 - 1]) / 2\n\nprint(median([3, 1, 2, 4, 5]))\n\
    print(median([-10, 4, 6, 1000, 10, 20]))", "    sorted_l = sorted(l)\n    if len(sorted_l)\
    \ == 0:\n        raise RuntimeError('Cannot take median of empty list')\n    elif\
    \ len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l) // 2]\n    else:\n\
    \        return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l) // 2 -\
    \ 1]) / 2\n\nprint(median([3, 1, 2, 4, 5]))\nprint(median([-10, 4, 6, 1000, 10,\
    \ 20]))\n", "    s = sorted(l)\n    i = len(s) // 2\n    if len(s) % 2 == 0:\n\
    \        return (s[i] + s[i-1]) / 2\n    else:\n        return s[i]\n", "    ls\
    \ = sorted(l)\n    ls_len = len(ls)\n    if ls_len % 2 == 1:\n        return ls[ls_len\
    \ // 2]\n    else:\n        return (ls[ls_len // 2 - 1] + ls[ls_len // 2]) / 2\n\
    \n\n", "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) //\
    \ 2]\n    else:\n        middle_right = l[len(l) // 2]\n        middle_left =\
    \ l[len(l) // 2 - 1]\n        return (middle_right + middle_left) / 2\n", "  \
    \  s = sorted(l)\n    mid = len(s) // 2\n    if len(s) % 2 == 1:\n        return\
    \ s[mid]\n    else:\n        return (s[mid] + s[mid-1]) / 2\n", "    # Sorts the\
    \ list\n    l.sort()\n    # Checks if the length of the list is even or odd\n\
    \    if len(l) % 2 == 0:\n        # Returns the average of the middle elements\
    \ if the length is even\n        return (l[len(l) // 2] + l[len(l) // 2 - 1])\
    \ / 2\n    else:\n        # Returns the middle element if the length is odd\n\
    \        return l[len(l) // 2]\n", "    # Sort the copy of the list, then find\
    \ the median\n    s = sorted(l)\n    middle = len(s) // 2\n    if len(s) % 2 ==\
    \ 1: # Odd number of elements\n        return s[middle]\n    else: # Even number\
    \ of elements\n        return (s[middle] + s[middle - 1]) / 2\n", "    n = len(l)\n\
    \    if n == 0:\n        raise ValueError(\"Cannot compute median of empty list\"\
    )\n    l.sort()\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n   \
    \     return (l[n // 2 - 1] + l[n // 2]) / 2\n", "    s = sorted(l)\n    half\
    \ = len(s) // 2\n    if len(s) % 2 == 0:\n        return 0.5 * (s[half] + s[half\
    \ - 1])\n    else:\n        return s[half]\n", "    sorted_l = sorted(l)\n   \
    \ if len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l) // 2]\n  \
    \  else:\n        return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l)\
    \ // 2 - 1]) / 2\n\nprint(median([-10, 4, 6, 1000, 10, 20]))", "    n = len(l)\n\
    \    sorted_l = sorted(l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n\
    \    else:\n        mid_lo = n // 2 - 1\n        mid_hi = n // 2\n        return\
    \ (sorted_l[mid_lo] + sorted_l[mid_hi]) / 2", "    s = sorted(l)\n    n = len(s)\n\
    \    if n % 2 == 1:\n        return s[n // 2]\n    else:\n        return (s[n\
    \ // 2 - 1] + s[n // 2]) / 2\n", "    # Sort a copy of l\n    sorted_l = sorted(l)\n\
    \    # Length of l\n    n = len(l)\n    # Index of median\n    m = n // 2\n  \
    \  # If n is odd, return element at m\n    if n % 2 == 1:\n        return sorted_l[m]\n\
    \    # Else, return average of elements at m and m-1\n    else:\n        return\
    \ 0.5 * (sorted_l[m] + sorted_l[m-1])\n", "    n = len(l)\n    if n == 0:\n  \
    \      raise ValueError\n    s = sorted(l)\n    mid = n // 2\n    if n % 2 ==\
    \ 1:\n        return s[mid]\n    else:\n        return (s[mid] + s[mid - 1]) /\
    \ 2\n", "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) //\
    \ 2]\n    else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n",
  "    if len(l) == 0:\n        raise ValueError\n    sorted_l = sorted(l)\n    return\
    \ (sorted_l[len(l) // 2] + sorted_l[(len(l) - 1) // 2]) / 2\n", "    sorted_l\
    \ = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n //\
    \ 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2",
  "    l.sort()\n    if len(l)%2 == 0:\n        mid = len(l)//2\n        return (l[mid]\
    \ + l[mid-1])/2\n    return l[len(l)//2]", "    l.sort()\n    n = len(l)\n   \
    \ if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n //\
    \ 2 - 1] + l[n // 2]) / 2\n", "    l.sort()\n    mid = int(len(l) / 2)\n    if\
    \ len(l) % 2 == 0:\n        return sum(l[mid-1:mid+1]) / 2\n    else:\n      \
    \  return l[mid]", "    n = len(l)\n    l.sort()\n    if n % 2 == 1:\n       \
    \ return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n\
    \n", "    s = sorted(l)\n    if len(s) % 2 == 1:\n        return s[len(s) // 2]\n\
    \    else:\n        return sum(s[len(s) // 2 - 1:len(s) // 2 + 1]) / 2", "   \
    \ l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return\
    \ (l[mid] + l[mid-1]) / 2\n    else:\n        return l[mid]\n", "    # Sort the\
    \ list in ascending order.\n    l.sort()\n    # Find the middle of the list.\n\
    \    size = len(l)\n    mid = size // 2\n    # If the list has an odd number of\
    \ elements, return the middle one.\n    if size % 2 == 1:\n        return l[mid]\n\
    \    # Otherwise, return the average of the middle two.\n    else:\n        return\
    \ (l[mid] + l[mid-1]) / 2", "    n = len(l)\n    s = sorted(l)\n    return (sum(s[n//2-1:n//2+1])/2.0,\
    \ s[n//2])[n % 2] if n else None\n", "    l = sorted(l)\n    mid = len(l) // 2\n\
    \    if len(l) % 2 == 0:\n        return (l[mid] + l[mid - 1]) / 2\n    else:\n\
    \        return l[mid]", "    l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n\
    \        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2])\
    \ / 2\n\n", "    sorted_l = sorted(l)\n    mid = len(l) // 2\n    if len(l) %\
    \ 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n\
    \        return sorted_l[mid]\n", "    sorted_l = sorted(l)\n    if len(sorted_l)\
    \ % 2 == 1:\n        return sorted_l[len(sorted_l) // 2]\n    else:\n        mid_idx\
    \ = len(sorted_l) // 2\n        return (sorted_l[mid_idx] + sorted_l[mid_idx -\
    \ 1]) / 2\n", "    if len(l) == 0:\n        raise ValueError('empty list')\n \
    \   sorted_l = sorted(l)\n    middle = len(sorted_l) // 2\n    if len(sorted_l)\
    \ % 2 == 0:\n        return (sorted_l[middle] + sorted_l[middle - 1]) / 2\n  \
    \  else:\n        return sorted_l[middle]\n", "    return (sorted(l)[len(l) //\
    \ 2] + sorted(l)[~(len(l) // 2)]) / 2\n\n", "    l.sort()\n    half = len(l) //\
    \ 2\n    return (l[half] + l[~half]) / 2", "    return (l[len(l) // 2] + l[len(l)\
    \ // 2 - 1]) / 2\n\nl = [-10, 4, 6, 1000, 10, 20]\nprint(median(l))", "    return\
    \ sum(l) / len(l)\n", "    n = len(l)\n    if n % 2 == 1:\n        return sorted(l)[n\
    \ // 2]\n    else:\n        return (sorted(l)[n // 2 - 1] + sorted(l)[n // 2])\
    \ / 2", "    if len(l) == 0:\n        raise ValueError(\"Empty list\")\n    n\
    \ = len(l)\n    s = sorted(l)\n    print(s)\n    return (s[(n-1)//2] + s[n//2])\
    \ / 2\n\n", "    l.sort()\n    mid = len(l) // 2\n    if len(l) % 2 == 0:\n  \
    \      return (l[mid] + l[mid - 1]) / 2\n    else:\n        return l[mid]\n",
  "    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n  \
    \  else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n", "    l = sorted(l)\n\
    \    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        middle_index\
    \ = len(l) // 2\n        return (l[middle_index - 1] + l[middle_index]) / 2\n",
  "    mid = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[mid] + l[mid\
    \ - 1]) / 2\n    else:\n        return l[mid]\n", "    n = len(l)\n    if n ==\
    \ 0:\n        raise ValueError('median of zero length list')\n    if n % 2 ==\
    \ 1:\n        return sorted(l)[n // 2]\n    else:\n        return sum(sorted(l)[n\
    \ // 2 - 1:n // 2 + 1]) / 2.0\n\nprint(median([2, 3, 4, 5, 6]))\nprint(median([3,\
    \ 1, 2, 4, 5]))\nprint(median([-10, 4, 6, 1000, 10, 20]))\n", "    s = sorted(l)\n\
    \    n = len(s)\n    if n % 2 == 1:\n        return s[n // 2]\n    else:\n   \
    \     return (s[n // 2 - 1] + s[n // 2]) / 2\n", "    s = sorted(l)\n    if len(s)\
    \ == 0:\n        raise ValueError(\"There are no elements.\")\n    if len(s) %\
    \ 2 == 1:\n        return s[(len(s) - 1) // 2]\n    else:\n        i = len(s)\
    \ // 2\n        return (s[i] + s[i - 1]) / 2\n", "    s = sorted(l)\n    if len(s)\
    \ == 0:\n        raise ValueError(\"median of empty list is undefined\")\n   \
    \ elif len(s) % 2 == 1:\n        return s[len(s) // 2]\n    else:\n        v1\
    \ = s[len(s) // 2]\n        v2 = s[len(s) // 2 - 1]\n        return (v1 + v2)\
    \ / 2\n", "    l = sorted(l)\n    length = len(l)\n    i = (length - 1) // 2\n\
    \    if length % 2:\n        return l[i]\n    else:\n        return (l[i] + l[i\
    \ + 1]) / 2\n", "    sorted_l = sorted(l)\n    if len(sorted_l) == 0:\n      \
    \  raise ValueError(\"Empty list.\")\n    elif len(sorted_l) % 2 == 1:\n     \
    \   return sorted_l[len(sorted_l) // 2]\n    else:\n        median_hi = sorted_l[len(sorted_l)\
    \ // 2]\n        median_lo = sorted_l[len(sorted_l) // 2 - 1]\n        return\
    \ (median_hi + median_lo) / 2", "    n = len(l)\n    # sort the list\n    l.sort()\n\
    \    if n % 2 == 1: # odd\n        return l[n // 2]\n    else:\n        return\
    \ (l[n // 2 - 1] + l[n // 2]) / 2\n", "    n = len(l)\n    if n % 2 == 1:\n  \
    \      return sorted(l)[n // 2]\n    else:\n        return sum(sorted(l)[n //\
    \ 2 - 1:n // 2 + 1]) / 2\n\n", "    n = len(l)\n    if n == 0:\n        raise\
    \ ValueError('median(): list is empty')\n    if n % 2 == 1:\n        return sorted(l)[n\
    \ // 2]\n    else:\n        return (sorted(l)[n // 2 - 1] + sorted(l)[n // 2])\
    \ / 2\n", "    l.sort()\n    half = len(l) // 2\n    if len(l) % 2:\n        return\
    \ l[half]\n    else:\n        return (l[half-1] + l[half]) / 2\n", "    if len(l)\
    \ == 0:\n        raise IndexError(\"List is empty\")\n    else:\n        l.sort()\n\
    \        mid = len(l) // 2\n        if len(l) % 2 == 0:\n            return (l[mid\
    \ - 1] + l[mid]) / 2\n        else:\n            return l[mid]\n", "    l_sorted\
    \ = sorted(l)\n    length = len(l_sorted)\n    if length % 2 == 0:\n        return\
    \ (l_sorted[int(length/2)] + l_sorted[int(length/2)-1]) / 2\n    else:\n     \
    \   return l_sorted[int(length/2)]\n", "    l.sort()\n    if len(l) % 2 == 1:\n\
    \        return l[len(l) // 2]\n    else:\n        a = l[len(l) // 2]\n      \
    \  b = l[len(l) // 2 - 1]\n        return (a + b) / 2\n", "    l = sorted(l)\n\
    \    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        middle\
    \ = len(l) // 2\n        return (l[middle - 1] + l[middle]) / 2", "    sorted_l\
    \ = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n //\
    \ 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2\n\
    \        \n", "    s = sorted(l)\n    return (s[(len(s) - 1) // 2] + s[len(s)\
    \ // 2]) / 2", "    l.sort()\n    if len(l) % 2 == 1:\n        mid = int(len(l)\
    \ / 2)\n        return l[mid]\n    else:\n        mid1 = int(len(l) / 2)\n   \
    \     mid2 = mid1 - 1\n        return (l[mid1] + l[mid2]) / 2\n", "    sorted_l\
    \ = sorted(l)\n    if len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l)\
    \ // 2]\n    else:\n        mid = len(sorted_l) // 2\n        return (sorted_l[mid]\
    \ + sorted_l[mid - 1]) / 2", "    l.sort()\n    if len(l) % 2 == 1:\n        return\
    \ l[int(len(l) / 2)]\n    else:\n        return (l[int(len(l) / 2)] + l[int(len(l)\
    \ / 2) - 1]) / 2\n", "    n = len(l)\n    if n == 0:\n        raise ValueError('l\
    \ cannot be empty.')\n    l.sort()\n    if n % 2 == 1:\n        return l[n //\
    \ 2]\n    else:\n        i = n // 2\n        return (l[i - 1] + l[i]) / 2\n\n",
  "    sorted_l = sorted(l)\n    if len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l)\
    \ // 2]\n    return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l) //\
    \ 2 - 1]) / 2\n", "    l = sorted(l)\n    mid = len(l) // 2\n    if len(l) % 2\
    \ == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]\n",
  "    l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n\
    \        return sum(l[len(l) // 2 - 1: len(l) // 2 + 1]) / 2\n", "    l.sort()\n\
    \    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1])\
    \ / 2\n    else:\n        return l[len(l) // 2]", "    sort(l)\n    if len(l)\
    \ % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        i = len(l) // 2\n\
    \        return (l[i] + l[i - 1]) / 2\n", "    if len(l) % 2 == 0:\n        return\
    \ (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l)\
    \ // 2]\n", "    l.sort()\n    return sum(l[len(l)//2-1:len(l)//2+1])/2\n\n",
  "    n = len(l)\n    sorted_l = sorted(l)\n    if n % 2 == 1:\n        return sorted_l[n\
    \ // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) /\
    \ 2", "    l.sort()\n    n = len(l)\n    # Middle index if n is odd\n    middle\
    \ = n // 2\n    # Medain if n is odd\n    if n % 2:\n        return l[middle]\n\
    \    # Median if n is even\n    else:\n        return sum(l[middle - 1:middle\
    \ + 1]) / 2\n", "    if len(l) == 0:\n        raise ValueError\n    l = sorted(l)\n\
    \    mid = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[mid] + l[mid\
    \ - 1]) / 2\n    else:\n        return l[mid]\n", "    n = len(l)\n    return\
    \ (l[n // 2] + l[(n - 1) // 2]) / 2", "    n = len(l)\n    if n == 0:\n      \
    \  raise ValueError('cannot calculate median of empty list')\n    l_sorted = sorted(l)\n\
    \    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        mid_hi\
    \ = n // 2\n        mid_lo = mid_hi - 1\n        return (l_sorted[mid_lo] + l_sorted[mid_hi])\
    \ / 2\n", "    sorted_l = sorted(l)\n    if len(sorted_l) % 2 == 1:\n        return\
    \ sorted_l[len(sorted_l) // 2]\n    else:\n        return (sorted_l[len(sorted_l)\
    \ // 2] + sorted_l[len(sorted_l) // 2 - 1]) / 2\n", "    n = len(l)\n    s = sorted(l)\n\
    \    if n % 2 == 1:\n        return s[n//2]\n    else:\n        return (s[n//2\
    \ - 1] + s[n//2]) / 2\n\nassert median([3, 1, 2, 4, 5]) == 3\nassert median([-10,\
    \ 4, 6, 1000, 10, 20]) == 15\nassert median([0, 0, 0, 0, 0]) == 0\nassert median([])\
    \ == 0\n\nimport doctest\ndoctest.testmod()", "    n = len(l)\n    # sort the\
    \ list\n    l = sorted(l)\n    # if list has odd no. of elements, return middle\
    \ element\n    if n % 2 == 1:\n        mid = n // 2\n        return l[mid]\n \
    \   # else, return average of the two middle elements\n    else:\n        mid1\
    \ = n // 2\n        mid2 = mid1 - 1\n        return (l[mid1] + l[mid2]) / 2\n",
  "    # Sort the list to find the median\n    l.sort()\n    n = len(l)\n    mid =\
    \ n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n\
    \        return l[mid]\n", "    n = len(l)\n    l_sorted = sorted(l)\n    if n\
    \ % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return sum(l_sorted[n\
    \ // 2 - 1:n // 2 + 1]) / 2\n", "    if not l:\n        return 0\n    l = sorted(l)\n\
    \    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n   \
    \     return (l[n // 2 - 1] + l[n // 2]) / 2\n    \n", "    s = sorted(l)\n  \
    \  # len(s) // 2 is the (index of the) middle element when len(s) is odd.\n  \
    \  return (s[len(s) // 2] + s[-(len(s) // 2) - 1]) / 2\n\n", "    s = sorted(l)\n\
    \    m = len(s) // 2\n    if len(s) % 2 == 0:\n        return (s[m-1] + s[m])\
    \ / 2\n    else:\n        return s[m]\n\nassert median([3, 1, 2, 4, 5]) == 3\n\
    assert median([-10, 4, 6, 1000, 10, 20]) == 15.0", "    L = sorted(l)\n    n =\
    \ len(L)\n    if n % 2 == 1:\n        return L[n // 2]\n    else:\n        return\
    \ (L[n // 2 - 1] + L[n // 2]) / 2\n", "    # Sort the list.\n    copy = sorted(l)\n\
    \n    # Find the middle of the list.\n    mid = len(copy) // 2\n\n    # If the\
    \ length of the list is odd, return the middle element.\n    if len(copy) % 2\
    \ == 1:\n        return copy[mid]\n\n    # If the length of the list is even,\
    \ average the two middle elements.\n    else:\n        return (copy[mid] + copy[mid\
    \ - 1]) / 2\n\n", "    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        m\
    \ = (n - 1) // 2\n        return l[m]\n    else:\n        m1 = n // 2 - 1\n  \
    \      m2 = n // 2\n        return (l[m1] + l[m2]) / 2\n", "    l_sorted = sorted(l)\n\
    \    size = len(l_sorted)\n    if size % 2 == 0:\n        # Even number of elements\n\
    \        mid = int(size / 2)\n        return (l_sorted[mid] + l_sorted[mid-1])\
    \ / 2\n    else:\n        # Odd number of elements\n        mid = int(size / 2)\n\
    \        return l_sorted[mid]\n", "    n = len(l)\n    l.sort()\n    if n % 2\
    \ == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] +\
    \ l[n // 2]) / 2\n\n", "    half = len(l) // 2\n    l.sort()\n    if len(l) %\
    \ 2 == 0:\n        return (l[half - 1] + l[half]) / 2\n    else:\n        return\
    \ l[half]", "    l.sort()\n    mid = len(l) // 2\n    if len(l) % 2 == 0:\n  \
    \      return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]\n",
  "    l.sort()\n    if len(l) % 2 == 0:\n        m = (l[len(l) // 2] + l[len(l) //\
    \ 2 - 1]) / 2\n    else:\n        m = l[len(l) // 2]\n    return m", "    l_sort\
    \ = sorted(l)\n    if len(l_sort) % 2 == 0:\n        # Even number of elements\n\
    \        a = len(l_sort)//2\n        b = a - 1\n        return (l_sort[a] + l_sort[b])/2\n\
    \    else:\n        # Odd number of elements\n        return l_sort[len(l_sort)//2]\n",
  "    n = len(l)\n    s = sorted(l)\n    # Return the average of the middle two elements\n\
    \    return (s[n//2 - 1] + s[n//2]) / 2\n\nprint(median([3, 1, 2, 4, 5]))\nprint(median([-10,\
    \ 4, 6, 1000, 10, 20]))", "    n = len(l)\n    if n == 0:\n        raise ValueError(\"\
    Cannot find median of empty list.\")\n    if n % 2 == 1:\n        return l[n //\
    \ 2]\n    else:\n        middle = n // 2\n        return (l[middle - 1] + l[middle])\
    \ / 2", "    l.sort()\n    i = len(l) // 2\n    if len(l) % 2 == 0:\n        return\
    \ (l[i] + l[i-1]) / 2\n    else:\n        return l[i]", "    l.sort()\n    half\
    \ = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[half] + l[half-1])\
    \ / 2\n    else:\n        return l[half]", "    l_copy = l[:]\n    l_copy.sort()\n\
    \    n = len(l_copy)\n    if n % 2 == 1:\n        return l_copy[n // 2]\n    else:\n\
    \        return (l_copy[n // 2 - 1] + l_copy[n // 2]) / 2\n\n", "    return (l[(len(l)\
    \ - 1) // 2] + l[len(l) // 2]) / 2\n\n", "    l.sort()\n    return l[len(l) //\
    \ 2]\n    ", "    l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return\
    \ l[n // 2]\n    else:\n        return sum(l[n // 2 - 1:n // 2 + 1]) / 2\n", " \
    \   s = sorted(l)\n    n = len(s)\n    if n % 2 == 1:\n        return s[n // 2]\n\
    \    else:\n        i = n // 2\n        return (s[i - 1] + s[i]) / 2\n", "   \
    \ sorted_l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n\
    \ // 2]\n    else:\n        return 0.5 * (sorted_l[n // 2 - 1] + sorted_l[n //\
    \ 2])", "    if len(l) == 0:\n        raise ValueError('Empty list')\n    l.sort()\n\
    \    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n   \
    \     return (l[n // 2 - 1] + l[n // 2]) / 2", "    sorted_l = sorted(l)\n   \
    \ n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n\
    \        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2\n", "    sorted_l\
    \ = sorted(l)\n    if len(sorted_l) % 2:\n        return sorted_l[len(sorted_l)\
    \ // 2]\n    else:\n        mid_left = len(sorted_l) // 2 - 1\n        mid_right\
    \ = len(sorted_l) // 2\n        return (sorted_l[mid_left] + sorted_l[mid_right])\
    \ / 2\n", "    if len(l) == 0:\n        raise ValueError(\"median of an empty\
    \ list is undefined\")\n    sl = sorted(l)\n    # import pdb; pdb.set_trace()\n\
    \    if len(sl) % 2 == 1:\n        # odd length, return the middle element\n \
    \       return sl[len(sl) // 2]\n    else:\n        # even length, return the\
    \ average of the middle two elements\n        hi_midpoint = len(sl) // 2\n   \
    \     return (sl[hi_midpoint - 1] + sl[hi_midpoint]) / 2", "    n = len(l)\n \
    \   if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n //\
    \ 2 - 1] + l[n // 2]) / 2\n", "    l.sort()\n    if len(l) % 2 == 0:\n       \
    \ return (l[int(len(l)/2)] + l[int(len(l)/2) - 1]) / 2\n    else:\n        return\
    \ l[int(len(l)/2)]\n", "    sorted_l = sorted(l)\n    if len(sorted_l) % 2 ==\
    \ 1:\n        return sorted_l[len(sorted_l) // 2]\n    else:\n        mid_low\
    \ = sorted_l[len(sorted_l) // 2 - 1]\n        mid_high = sorted_l[len(sorted_l)\
    \ // 2]\n        return (mid_low + mid_high) / 2\n", "    s = sorted(l)\n    len_of_l\
    \ = len(l)\n    mid = len_of_l // 2\n    if len_of_l % 2 == 0:\n        return\
    \ (s[mid - 1] + s[mid]) / 2\n    else:\n        return s[mid]\n", "    l.sort()\n\
    \    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return\
    \ (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n\nprint(median([3, 1, 2, 4, 5]))\n\
    print(median([-10, 4, 6, 1000, 10, 20]))", "    n = len(l)\n    s = sorted(l)\n\
    \    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2] if n else None", "   \
    \ l = sorted(l)\n    mid = len(l) // 2\n    return (l[mid] + l[~mid]) / 2", " \
    \   # first find the length of the list\n    N = len(l)\n    # create sorted version\
    \ of the list\n    L = sorted(l)\n    # if length of the list is even, average\
    \ the middle two numbers\n    if N % 2 == 0:\n        return (L[N//2 - 1] + L[N//2])\
    \ / 2\n    # if length of the list is odd, return the middle number\n    else:\n\
    \        return L[N//2]\n", "    l.sort()\n    return (l[len(l) // 2] + l[-(len(l)\
    \ // 2 + 1)]) / 2", "    # l.sort()\n    # n = len(l)\n    # if n % 2 == 1:\n\
    \    #     return l[n // 2]\n    # else:\n    #     return (l[n // 2 - 1] + l[n\
    \ // 2]) / 2\n    l.sort()\n    return sum(l[len(l) // 2 - 1:len(l) // 2 + 1])\
    \ / 2\n\nimport random", "    lsorted = sorted(l)\n    n = len(lsorted)\n    if\
    \ n % 2 == 1:\n        # odd n, return the middle one\n        return lsorted[n\
    \ // 2]\n    else:\n        # even n, take avg of middle two\n        return (lsorted[n\
    \ // 2 - 1] + lsorted[n // 2]) / 2\n", "    l.sort() # sort the list to ascending\
    \ order\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n \
    \       return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n\n", "    sorted_l =\
    \ sorted(l)\n    size = len(sorted_l)\n    if size % 2 == 0:\n        return (sorted_l[size\
    \ // 2 - 1] + sorted_l[size // 2]) / 2\n    else:\n        return sorted_l[size\
    \ // 2]\n", "    l.sort()\n    return (l[len(l) // 2] + l[-(len(l) // 2) - 1])\
    \ / 2\n\n", "    l.sort() # mutates l\n    s = len(l)\n    mid = s // 2\n    if\
    \ s % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return\
    \ l[mid]\n", "    sorted_l = sorted(l)\n    mid = len(l) // 2\n    if len(l) %\
    \ 2 == 0:\n        return (sorted_l[mid] + sorted_l[mid-1]) / 2\n    else:\n \
    \       return sorted_l[mid]\n", "    # TODO: replace this line of code with a\
    \ correct implementation.\n    s = sorted(l)\n    return (s[(len(s)-1)//2] + s[len(s)//2])\
    \ / 2\n", "    l.sort()\n    i = len(l) // 2\n    if len(l) % 2 == 0:\n      \
    \  return (l[i] + l[i - 1]) / 2\n    else:\n        return l[i]\n", "    l.sort()\n\
    \    # Convert to float so we return a float instead of an int\n    return float(l[len(l)\
    \ // 2])\n", "    # Sort the list.\n    s = sorted(l)\n    middle = len(s) //\
    \ 2\n\n    # To be more specific, middle is the index of the middle element\n\
    \    # of s, with the middle being what is left over of len(s) // 2\n    # if\
    \ len(s) is odd.\n    if len(s) % 2 == 1:\n        return s[middle]\n    else:\n\
    \        return sum(s[middle - 1:middle + 1]) / 2\n", "    l.sort()\n    if len(l)\
    \ % 2 == 0:\n        mid = len(l) // 2\n        return (l[mid - 1] + l[mid]) /\
    \ 2\n    else:\n        return l[len(l) // 2]\n", "    s = sorted(l)\n    mid\
    \ = len(s) // 2\n    if len(s) % 2 == 1:\n        return s[mid]\n    else:\n \
    \       return (s[mid - 1] + s[mid]) / 2\n\nassert median([3, 1, 2, 4, 5]) ==\
    \ 3\nassert median([-10, 4, 6, 1000, 10, 20]) == 15.0", "    sorted_l = sorted(l)\n\
    \    mid_index = len(sorted_l) // 2\n    if len(sorted_l) % 2 == 0:\n        #\
    \ Even number of elements.\n        return 0.5 * (sorted_l[mid_index] + sorted_l[mid_index\
    \ - 1])\n    else:\n        # Odd number of elements.\n        return sorted_l[mid_index]",
  "    n = len(l)\n    # If the length of the list is odd.\n    if n % 2 == 1:\n \
    \       # Find the middle element\n        index = n // 2\n        # Return that\
    \ element\n        return l[index]\n    # If the length of the list is even\n\
    \    else:\n        # Find the two middle element\n        index1 = n // 2 - 1\n\
    \        index2 = n // 2\n        # Return the average of the two elements\n \
    \       return (l[index1] + l[index2]) / 2\n", "    sorted_l = sorted(l)\n   \
    \ n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n\
    \        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2\n\nfrom doctest\
    \ import testmod\ntestmod()", "    l.sort()\n    if len(l)%2 == 0:\n        return\
    \ (l[int(len(l)/2)] + l[int(len(l)/2 - 1)])/2\n    else:\n        return l[int(len(l)/2)]\n\
    \nprint(median([3, 1, 2, 4, 5]))\nprint(median([-10, 4, 6, 1000, 10, 20]))", " \
    \   sorted_l = sorted(l)\n    mid = len(sorted_l) // 2\n    if len(sorted_l) %\
    \ 2 == 0:\n        median = (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n\
    \        median = sorted_l[mid]\n    return median", "    sorted_l = sorted(l)\n\
    \    mid = len(sorted_l) // 2\n    if len(sorted_l) % 2 == 0:\n        return\
    \ (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]",
  "    sorted_l = sorted(l)\n    mid_index = len(sorted_l) // 2\n    if len(sorted_l)\
    \ % 2:\n        return sorted_l[mid_index]\n    else:\n        return (sorted_l[mid_index\
    \ - 1] + sorted_l[mid_index]) / 2\n\n", "    assert len(l) > 0, \"l should have\
    \ at least one element\"\n    if len(l) % 2 == 0:\n        return 0.5 * (l[len(l)\
    \ // 2] + l[len(l) // 2 - 1])\n    else:\n        return l[len(l) // 2]\n", " \
    \   s = sorted(l)\n    if len(s) % 2 == 1:\n        return s[len(s) // 2]\n  \
    \  else:\n        return (s[len(s) // 2] + s[len(s) // 2 - 1]) / 2\n", "    n\
    \ = len(l)\n    if n == 0:\n        raise ValueError(\"Empty list\")\n    if n\
    \ % 2 == 1:\n        return sorted(l)[n // 2]\n    else:\n        return sum(sorted(l)[n\
    \ // 2 - 1:n // 2 + 1]) / 2", "    if len(l) == 0:\n        raise IndexError('Empty\
    \ list does not have a median.')\n    else:\n        index = len(l) // 2\n   \
    \     if len(l) % 2 == 0:\n            return (l[index] + l[index - 1]) / 2\n\
    \        else:\n            return l[index]\n", "    l.sort()\n    n = len(l)\n\
    \    return l[n // 2] if n % 2 == 1 else (l[n // 2 - 1] + l[n // 2]) / 2\n", " \
    \   # Make a copy of the list\n    m = l[:]\n    # Sort the list\n    m.sort()\n\
    \    # Find the middle element\n    middle = len(m) // 2\n    # If list has odd\
    \ number of elements, return the element at the middle\n    if len(m) % 2 == 1:\n\
    \        return m[middle]\n    # If list has even number of elements, return the\
    \ average of two middle elements\n    else:\n        return (m[middle - 1] + m[middle])\
    \ / 2\n", "    assert len(l) > 0, \"The list must not be empty\"\n    l.sort()\n\
    \    k = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[k] + l[k - 1])\
    \ / 2\n    else:\n        return l[k]", "    l.sort()\n    return (l[len(l) //\
    \ 2] + l[~(len(l) // 2)]) / 2\n", "    # get the middle index\n    m = len(l)\
    \ // 2\n    # if len is even, take average of the two middle elements\n    if\
    \ len(l) % 2 == 0:\n        return (l[m] + l[m-1]) / 2\n    # else, return middle\
    \ element\n    else:\n        return l[m]", "    l.sort()\n    if len(l) % 2 ==\
    \ 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2]\
    \ + l[len(l) // 2 - 1]) / 2", "    sorted_l = sorted(l)\n    n = len(l)\n    if\
    \ n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n\
    \ // 2 - 1] + sorted_l[n // 2]) / 2\n\n", "    # sort the list, then if the length\
    \ is odd, return the middle, else return the mean of the two middle terms\n  \
    \  l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n\
    \        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2", "    l.sort()\n  \
    \  mid_pos = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[mid_pos]\
    \ + l[mid_pos-1]) / 2\n    else:\n        return l[mid_pos]\n", "    n = len(l)\n\
    \    return (l[n // 2] + l[(n - 1) // 2]) / 2\n", "    assert l, \"Empty list\
    \ has no median\"\n    n = len(l)\n    s = sorted(l)\n    return (s[n//2] + s[(n-1)//2])\
    \ / 2", "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) //\
    \ 2]\n    else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n",
  "    sorted_l = sorted(l)\n    if len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l)\
    \ // 2]\n    else:\n        return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l)\
    \ // 2 - 1]) / 2\n", "    # Case 1.0: empty list\n    if len(l) == 0:\n      \
    \  raise Exception(\"Cannot find the median of an empty list.\")\n    l.sort()\n\
    \    mid = len(l) // 2\n    if len(l) % 2 == 0:\n        return (l[mid - 1] +\
    \ l[mid]) / 2\n    else:\n        return l[mid]\n", "    assert len(l) > 0\n \
    \   n = len(l)\n    s = sorted(l)\n    if n % 2 == 1:\n        return s[(n - 1)\
    \ // 2]\n    else:\n        return (s[n // 2] + s[n // 2 - 1]) / 2\n", "    sorted_l\
    \ = sorted(l)\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return\
    \ sorted_l[mid]\n    else:\n        return (sorted_l[mid] + sorted_l[mid - 1])\
    \ / 2\n", "    sorted_l = sorted(l)\n    length = len(sorted_l)\n    if length\
    \ % 2 == 1:\n        return sorted_l[length // 2]\n    else:\n        # even case,\
    \ take the average of the middle two values\n        return (sorted_l[length //\
    \ 2] + sorted_l[length // 2 - 1]) / 2\n", "    n = len(l)\n    if n == 0:\n  \
    \      raise ValueError('median() arg is an empty sequence')\n    l = sorted(l)\n\
    \    return (l[n // 2] + l[-(n // 2) - 1]) / 2\n\n", "    sorted_l = sorted(l)\n\
    \    if len(sorted_l) % 2 == 1:\n        return sorted_l[len(sorted_l) // 2]\n\
    \    else:\n        return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l)\
    \ // 2 - 1]) / 2\n", "    length = len(l)\n    if length == 0:\n        raise\
    \ ValueError('median on empty list')\n    elif length % 2 == 1:\n        return\
    \ sorted(l)[length // 2]\n    else:\n        return (sorted(l)[length // 2 - 1]\
    \ + sorted(l)[length // 2]) / 2\n\n", "    l = sorted(l)\n    m = len(l) // 2\n\
    \    if len(l) % 2 == 0:\n        return (l[m] + l[m-1]) / 2\n    else:\n    \
    \    return l[m]\n", "    l = sorted(l)\n    if len(l) == 0:\n        raise RuntimeError(\"\
    The list is empty\")\n    elif len(l) % 2 == 1:\n        return l[len(l) // 2]\n\
    \    else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n", "   \
    \ sorted_l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return sorted_l[n\
    \ // 2]\n    else:\n        middle_index = n // 2\n        return (sorted_l[middle_index\
    \ - 1] + sorted_l[middle_index]) / 2\n", "    s = sorted(l)\n    length = len(s)\n\
    \    mid = length // 2\n    if len(s) % 2 == 0:\n        return (s[mid] + s[mid\
    \ - 1]) / 2\n    else:\n        return s[mid]\n", "    l.sort()\n    if len(l)\
    \ % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return 0.5 * (l[len(l)\
    \ // 2 - 1] + l[len(l) // 2])\n", "    sorted_l = sorted(l)\n    n = len(l)\n\
    \    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return\
    \ (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2\n\n", "    n = len(l)\n    s =\
    \ sorted(l)\n    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2] if n else\
    \ None"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
