name: HumanEval_147_get_max_triples
language: py
prompt: "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive\
  \ integer n. You have to create an integer array a of length n.\n        For each\
  \ i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the\
  \ number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j]\
  \ + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output:\
  \ 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid\
  \ triple is (1, 7, 13).\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(5) == 1\n    assert candidate(6)\
  \ == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n\ndef\
  \ test_check():\n    check(get_max_triples)\n\ntest_check()\n"
completions: ["    return None\n\n", "    a = list(map(lambda x: x * x - x + 1, range(1,\
    \ n + 1)))\n    valid_count = 0\n    for i in range(n - 2):\n        for j in\
    \ range(i + 1, n - 1):\n            for k in range(j + 1, n):\n              \
    \  if a[i] + a[j] + a[k] % 3 == 0:\n                    valid_count += 1\n   \
    \ return valid_count\n\n\n@testwrapper", "    # Time Complexity: O(N)\n    # Space\
    \ Complexity: O(1)\n    i = 1\n    j = 2\n    k = 3\n    m = 2\n    count = 0\n\
    \    while True:\n        while True:\n            while True:\n             \
    \   if i * i - i + 1 + j * j - j + 1 + k * k - k + 1 == 3 * m:\n             \
    \       count += 1\n                if k == n:\n                    break\n  \
    \              k += 1\n            if j == n - 1:\n                break\n   \
    \         j += 1\n            k = j + 1\n        if i == n - 2:\n            break\n\
    \        i += 1\n        j = i + 1\n        k = j + 1\n        m += 1\n    return\
    \ count", "    pass\n\n", "    a = list(map(lambda x: x * x - x + 1, range(1,\
    \ n + 1)))\n    res = 0\n    for i in range(n - 2):\n        for j in range(i\
    \ + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0:\n                    res += 1\n    return res\n\n",
  "    a = [(i*i - i + 1) for i in range(1, n+1)]\n    cnt = 0\n    for i in range(n):\n\
    \        for j in range(i+1, n):\n            for k in range(j+1, n):\n      \
    \          if (a[i] + a[j] + a[k]) % 3 == 0:\n                    cnt += 1\n \
    \   return cnt\n\n", "    # return sum(map(lambda x: (x + 2 * x + 4 * x) // 3,\
    \ range(1, n)))\n\n    if n == 1:\n        return 0\n    elif n == 2:\n      \
    \  return 0\n    else:\n        return n // 3 + n // 3\n\n", "    r_list = [i\
    \ * i - i + 1 for i in range(1, n + 1)]\n    print(r_list)\n    r_list_len = len(r_list)\n\
    \    cnt = 0\n    for i in range(r_list_len - 2):\n        for j in range(i +\
    \ 1, r_list_len - 1):\n            for k in range(j + 1, r_list_len):\n      \
    \          if (r_list[i] + r_list[j] + r_list[k]) % 3 == 0:\n                \
    \    cnt += 1\n    return cnt\n\n", "    return get_max_triples_naive(n)\n\n",
  "    if n < 3:\n        return 0\n    res = 0\n    for i in range(1, n-1):\n   \
    \     for j in range(i+1, n):\n            k = (i+j) * (i+j+1) // 2 - (i*(i+1)\
    \ // 2) + i + 1\n            if k <= n:\n                res += 1\n    return\
    \ res\n", "    return sum(1 for i in range(n - 2) for j in range(i + 1, n - 1)\
    \ for k in range(j + 1, n) if (i + j + k) % 3 == 0)\n\n\nprint(get_max_triples(7))",
  "    return int(n * (n - 1) * (n - 2) / 6)\n\n", "    a = [(i+1)*(i+1) - (i+1) +\
    \ 1 for i in range(n)]\n    return sum([1 for i in range(len(a)) for j in range(i+1,\
    \ len(a)) for k in range(j+1, len(a)) if (a[i] + a[j] + a[k]) % 3 == 0])\n\n",
  "    start = 1\n    end = (1 + n) // 2\n    out = 0\n    while end < n:\n      \
    \  out += n - end\n        start += 1\n        end = (1 + start + n) // 2\n  \
    \  return out\n\n", "    pass\n\n", "    pass\n\n", "    # Make a table for num\
    \ % 3 and its count\n    mod_3_count = {0: 0, 1: 0, 2: 0}\n    max_triples = 0\n\
    \    for i in range(1, n+1):\n        m = (i*i - i + 1) % 3\n        mod_3_count[m]\
    \ += 1\n        max_triples += mod_3_count[3-m]\n    return max_triples\n", " \
    \   a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in\
    \ range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in\
    \ range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n \
    \                   count += 1\n    return count\n\n", "    # array = [x * x -\
    \ x + 1 for x in range(1, n + 1)]\n    # length = len(array)\n    # count = 0\n\
    \    # for i in range(length - 2):\n    #     for j in range(i + 1, length - 1):\n\
    \    #         for k in range(j + 1, length):\n    #             if (array[i]\
    \ + array[j] + array[k]) % 3 == 0:\n    #                 count += 1\n    # return\
    \ count\n\n    # dynamic programming\n    return n * (n - 1) * (n - 2) // 6\n\n",
  "    a = [x * x - x + 1 for x in range(1, n + 1)]\n    return sum(1 for i in range(n\
    \ - 2) for j in range(i + 1, n - 1) for k in range(j + 1, n) if (a[i] + a[j] +\
    \ a[k]) % 3 == 0)\n\n", "    if n < 3:\n        return 0\n    # If a, b, c is\
    \ such triplet, then a + b + c = 3n - 2 where n is an integer.\n    # The number\
    \ of such triplets is (n - 2)C2\n    return math.comb(n - 2, 2)\n\n", "    return\
    \ -1\n", "    triples = 0\n    for i in range(1, n):\n        for j in range(i\
    \ + 1, n):\n            for k in range(j + 1, n):\n                a_i = i * i\
    \ - i + 1\n                a_j = j * j - j + 1\n                a_k = k * k -\
    \ k + 1\n                if (a_i + a_j + a_k) % 3 == 0:\n                    triples\
    \ += 1\n    return triples\n\n", "    a = []\n    for i in range(1, n+1):\n  \
    \      a.append(i*i - i + 1)\n    a.sort()\n    print(a)\n    return a\n", " \
    \   if n < 3:\n        return 0\n    res = 1\n    for i in range(n - 2):\n   \
    \     res += i + 1\n    return res\n\n", "    if n < 3:\n        return 0\n  \
    \  elif n < 6:\n        return 1\n    else:\n        return int(0.5 * (n - 1)\
    \ * (n - 2))", "    return (n - 1) * (n - 2) // 6\n\n", "    assert n > 0, 'n\
    \ must be a positive integer'\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n\
    \    return len([(i, j, k) for i in range(n) for j in range(i + 1, n) for k in\
    \ range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 == 0])\n\n", "    # initialize output\
    \ with the n value if n is a multiple of 3\n    triples = n // 3 if n % 3 == 0\
    \ else 0\n    # get the multiples of 3 until the n value\n    multiples = [i for\
    \ i in range(n+1) if i % 3 == 0]\n    # get the valid indices (j) for the desired\
    \ triples\n    valid_indices = [index for index in range(n) if index + 1 in multiples]\n\
    \    # check if the desired triple exists\n    for index_j in valid_indices:\n\
    \        for index_k in range(index_j+1, n):\n            if a[index_j] + a[index_k]\
    \ in multiples:\n                triples += 1\n    return triples\n\n\na = [i*i\
    \ - i + 1 for i in range(1, n+1)]\nprint(get_max_triples(n))", "    res = 0\n\
    \    for i in range(n):\n        for j in range(i+1, n):\n            for k in\
    \ range(j+1, n):\n                if (i * i - i + 1 + j * j - j + 1 + k * k -\
    \ k + 1) % 3 == 0:\n                    res += 1\n    return res\n\nprint(get_max_triples(5))",
  "    m = n - 1\n    t = m * (m + 1) // 2\n    if m % 3 == 0:\n        t -= m //\
    \ 3\n    if m % 3 == 1:\n        t -= (m + 2) // 3\n    return t\n\n", "    #\
    \ if n == 1:\n    #     return 0\n    # return n + int(n * (n - 1) / 3) - 2\n\
    \    # if n < 3:\n    #     return 0\n    # return n * (n - 1) * (n - 2) // 6\n\
    \    if n < 3:\n        return 0\n    return (n * (n - 1) * (n - 2) - 3 * n *\
    \ (n - 1) - 2 * n * (n - 2)) // 6\n\n\n", "    return n*(n-1)*(n-2)//6\n", " \
    \   res = [i * i - i + 1 for i in range(1, n + 1)]\n    triple = 0\n    for i\
    \ in range(len(res)):\n        for j in range(i + 1, len(res)):\n            for\
    \ k in range(j + 1, len(res)):\n                if (res[i] + res[j] + res[k])\
    \ % 3 == 0:\n                    triple += 1\n    return triple\n\n", '    return
    math.floor(n / 3) * (n - 2) * math.floor(n / 3)', "    a = [i * i - i + 1 for\
    \ i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for\
    \ j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n         \
    \       if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n  \
    \  return count\n\n", "    return n * (n - 1) * (n - 2) // 6\n\n", "    res =\
    \ 0\n    for i in range(1, n):\n        res += (n - i) // 3\n    return res\n\n",
  "    s = 0\n    for i in range(1, n - 1):\n        s += (n - i - 1) * i\n    return\
    \ s", "    pass\n\n", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n    return\
    \ sum(a[i] + a[j] + a[k] % 3 == 0 for i in range(n) for j in range(i + 1, n) for\
    \ k in range(j + 1, n))\n\n\nprint(get_max_triples(5))\nprint(get_max_triples(6))\n\
    print(get_max_triples(7))\nprint(\"The array a should be 1, 3, 7, 13, 21, 31,\
    \ 43.\")\nprint(\"The number of triples is 10.\")", "    pass\n\n", "    # a =\
    \ []\n    # for i in range(1, n+1):\n    #     a.append(i*i - i + 1)\n    # triples\
    \ = 0\n    # for i in range(len(a)):\n    #     for j in range(i+1, len(a)):\n\
    \    #         for k in range(j+1, len(a)):\n    #             if (a[i] + a[j]\
    \ + a[k]) % 3 == 0:\n    #                 triples += 1\n    # return triples\n\
    \    return sum(i * i for i in range(1, n + 1)) - n * (n + 1) // 2\n\n", "   \
    \ # The triplet should be such that:\n    #   a[i] + a[j] + a[k] % 3 == 0\n  \
    \  #   a[i] + a[j] + a[k] > a[i]\n    #   a[i] + a[j] + a[k] > a[j]\n    # For\
    \ a[i] + a[j] + a[k] % 3 == 0:\n    #   let a[i] % 3 == r1, a[j] % 3 == r2, a[k]\
    \ % 3 == r3\n    #   a[i] + a[j] + a[k] % 3 == (r1 + r2 + r3) % 3 = 0\n    # \
    \  So, we need at least 2 elements in a with reminder 0 and 1 element with reminder\
    \ 2\n    #   or at least 2 elements in a with reminder 1 and 1 element with reminder\
    \ 0\n    #   or at least 2 elements in a with reminder 2 and 1 element with reminder\
    \ 1\n    # For a[i] + a[j] + a[k] > a[i]:\n    #   let a[i] % 3 == r1, a[j] %\
    \ 3 == r2, a[k] % 3 == r3\n    #   a[i] % 3 + a[j] % 3 + a[k] % 3 > a[i] % 3\n\
    \    #   So, we need a[i] % 3 == 1\n\n    # We will create an array of size 3\
    \ which will hold the reminder of each a[i] when divided by 3\n    # For each\
    \ possible reminder, if it occur more than once we will reduce it by 1, so we\
    \ could use\n    # it in the calculation of the first condition\n    reminder_array\
    \ = [0, 0, 0]\n    for i in range(1, n+1):\n        reminder_array[i*i - i + 1\
    \ % 3] += 1\n\n    # Now we need to calculate the number of possible triplets\
    \ which fullfill the conditions\n    # We will do that by calculating the number\
    \ of possible fullfillments for each condition then sum them\n    possible_fullfillments\
    \ = 0\n    # First condition:\n    #   let a[i] % 3 ==", "    # max_triples =\
    \ 0\n    # for i in range(1, n):\n    #     for j in range(i+1, n):\n    #   \
    \      for k in range(j+1, n):\n    #             if (i*i - i + 1 + j*j - j +\
    \ 1 + k*k - k + 1) % 3 == 0:\n    #                 max_triples += 1\n    # return\
    \ max_triples\n\n    max_triples = 0\n    for i in range(1, n-1):\n        for\
    \ j in range(i+1, n):\n            if (i*i - i + 1 + j*j - j + 1) % 3 == 0:\n\
    \                max_triples += n - j\n    return max_triples\n\n", "    mod_remainder\
    \ = [0, 0, 0]\n    mod_remainder[0] = mod_remainder[1] = mod_remainder[2] = 0\n\
    \    count = 0\n    for i in range(1, n + 1):\n        mod_remainder[(i * i -\
    \ i + 1) % 3] += 1\n    count += mod_remainder[0] * (mod_remainder[0] - 1) * (mod_remainder[0]\
    \ - 2) // 6\n    count += mod_remainder[1] * (mod_remainder[1] - 1) * (mod_remainder[2])\
    \ // 6\n    count += mod_remainder[2] * (mod_remainder[2] - 1) * (mod_remainder[1])\
    \ // 6\n    return count\n", "    # sum must be divisible by 3,\n    # so sum(1,\
    \ 3, 7) = 11 must be odd\n    # sum(1, 7, 13) = 21 must be odd\n    # sum(3, 7,\
    \ 13) = 23 must be odd\n    # ....\n    # if even, then it must be divisible by\
    \ 3\n    # so, let, n = 3 * k + r, where r is the remainder\n    # if r = 0, then\
    \ the rest are divisible by 3\n    # if r = 1, then n - 1 = 3 * k + 1 - 1 = 3\
    \ * k, so rest of the array is divisible by 3\n    # if r = 2, then n - 2 = 3\
    \ * k + 2 - 2 = 3 * k, so rest of the array is divisible by 3\n    # so, if r\
    \ = 0 or r = 1 or r = 2, then it is ok\n    # for r = 3, then n - 3 = 3 * k +\
    \ 3 - 3 = 3 * k, so rest of the array is not divisible by 3\n    # for r = 4,\
    \ then n - 4 = 3 * k + 4 - 4 = 3 * k + 1, so we have to check the rest of the\
    \ array is divisible by 3\n    # ....\n    # so, if n = 3 * k + 3, then the rest\
    \ of the array is not divisible by 3\n    # if n = 3 * k + 4, then the rest of\
    \ the array is divisible by 3\n    # if n = 3 * k + 5, then the rest of the array\
    \ is divisible by 3\n    if n % 3 == 0:\n        return n * (n - 1) * (n - 2)\
    \ // 6\n    elif n % 3 == 1:\n        # so, not divisible by 3 are n - 1, n -\
    \ 4, n - 7, n - 10, n - 13, ....\n        # and we have k + 1 such numbers\n \
    \       k = (n - 1) // 3\n        not_divisible_by_3 = n - 1\n        total_triples\
    \ = (n - 1) * (n - 2) * (n - 3) // 6\n        return total_triples - (k + 1) *\
    \ not_divisible_by_", "    return n * (n - 1) * (n - 2) // 6\n\n\nn = 4\nprint(get_max_triples(n))",
  "    #TODO : refactor\n\n    count = 0\n    for i in range(1, n):\n        for j\
    \ in range(i + 1, n):\n            for k in range(j + 1, n):\n               \
    \ if ((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 == 0:\n       \
    \             count += 1\n    return count\n\n", "    return int(n / 3) * int((n\
    \ - 1) / 2) * int((n - 2) / 3)\n\n\nprint(get_max_triples(5))\nprint(get_max_triples(6))\n\
    print(get_max_triples(8))\nprint(get_max_triples(10))\nprint(get_max_triples(12))",
  "    return get_divisible_by_3_number_count(n - 1) * get_divisible_by_3_number_count(n\
    \ - 2)\n        ", "    a = []\n    for i in range(1, n+1):\n        a.append(i*i\
    \ - i + 1)\n    return sum(1 for i in range(0, n-2) for j in range(i+1, n-1) \n\
    \               for k in range(j+1, n) if a[i] + a[j] + a[k] % 3 == 0)\n", " \
    \   if n < 3:\n        return 0\n    ans = 0\n    nums = [i * i - i + 1 for i\
    \ in range(1, n + 1)]\n    for i in range(n - 2):\n        for j in range(i +\
    \ 1, n - 1):\n            for k in range(j + 1, n):\n                if (nums[i]\
    \ + nums[j] + nums[k]) % 3 == 0:\n                    ans += 1\n    return ans\n\
    \n", "    # Create the array\n    array = [i * i - i + 1 for i in range(1, n +\
    \ 1)]\n    # Get the number of triples\n    triples = 0\n    for i in range(len(array)):\n\
    \        for j in range(i + 1, len(array)):\n            for k in range(j + 1,\
    \ len(array)):\n                if (array[i] + array[j] + array[k]) % 3 == 0:\n\
    \                    triples += 1\n    return triples\n\n\n", "    return sum(1\
    \ for i in range(1, n - 1) for j in range(i + 1, n) for k in range(j + 1, n) if\
    \ (i + j + k) % 3 == 0)\n\n\nn = 5\nprint(get_max_triples(n))", "    triples =\
    \ 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for\
    \ k in range(j+1, n):\n                s = i*i - i + 1 + j*j - j + 1 + k*k - k\
    \ + 1\n                if s % 3 == 0:\n                    triples += 1\n    return\
    \ triples\n", "    return 1\n\n", "    # idea: use a hashmap to store the number\
    \ of multiples of 3 in \n    # a list [1, 3, 7, 13, 21]\n    if n < 3:\n     \
    \   return 0\n    hashmap = {\n        0: 0,\n        1: 0,\n        2: 0\n  \
    \  }\n    for i in range(1, n):\n        val = i * i - i + 1\n        hashmap[val\
    \ % 3] += 1\n    count = 0\n    for k, v in hashmap.items():\n        count +=\
    \ v * (v - 1) // 2\n    return count\n\n", "    return sum(1 for i in range(1,\
    \ n-1) for j in range(i+1, n) for k in range(j+1, n) if (i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1) % 3 == 0)\n", "    res = 0\n    for i in range(1, n):\n\
    \        for j in range(i + 1, n):\n            k = n - i - j\n            if\
    \ 1 <= k <= n and a[i] + a[j] + a[k] % 3 == 0:\n                res += 1\n   \
    \ return res\n\n", "    res = 0\n    rem = [0] * 3\n    for i in range(1, n +\
    \ 1):\n        a = i * i - i + 1\n        rem[a % 3] += 1\n    res += rem[0] *\
    \ (rem[0] - 1) * (rem[0] - 2) // 6\n    res += rem[1] * (rem[1] - 1) * (rem[2])\
    \ // 6\n    res += rem[2] * (rem[2] - 1) * (rem[1]) // 6\n    return res\n\n",
  "    # a = [i * i - i + 1 for i in range(1, n + 1)]\n    # ans = 0\n    # for i\
    \ in range(1, n - 1):\n    #     for j in range(i + 1, n):\n    #         for\
    \ k in range(j + 1, n + 1):\n    #             if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0:\n    #                 ans += 1\n    # return ans\n    mod = 3\n    ans =\
    \ 0\n    for i in range(1, n - 1):\n        ai = i * i - i + 1\n        if ai\
    \ % mod == 0:\n            ans += ((n - i) * (n - i - 1)) // 2\n    return ans\n\
    \n", "    return n*(n-1)*(n-2)//6\n\n", "    return sum(1 for _ in itertools.combinations(range(1,\
    \ n), 3) if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0)\n\n", "    return\
    \ ceil(n / 3)\n\n", "    # 0 to n-1, 1 to n, 2 to n+1 => 0 to n-1, 1 to n, 2 to\
    \ n+1 => 0 to n-1, 1 to n, 2 to n => 0 to n-1, 1 to n-1, 2 to n => 0 to n-2, 1\
    \ to n-1, 2 to n\n    # total of 0,1,2 = 0 to n-1, 1 to n-1, 2 to n-1 => 0 to\
    \ n-1, 1 to n-1, 2 to n-1 => 0 to n-1, 1 to n-1, 2 to n-1 => 0 to n-2, 1 to n-2,\
    \ 2 to n-1\n    # 0,1 => 0 to n-1, 1 to n => 0 to n-1, 1 to n => 0 to n-1, 1 to\
    \ n => 0 to n-1, 1 to n-1\n    # 0 => 0 to n-1 => 0 to n-1 => 0 to n-1 => 0 to\
    \ n-1\n    # n-1, n => n-1 to n => n-1 to n => n-1 to n => n-1 to n-1\n    # n\
    \ => n to n => n to n => n to n => n to n\n    # 0, 1, 2 => 0 to n-1, 1 to n,\
    \ 2 to n => 0 to n-1, 1 to n, 2 to n => 0 to n-1, 1 to n, 2 to n => 0 to n-1,\
    \ 1 to n, 2 to n\n    # n-1, n, n+1 => n-1 to n, n to n+1, n+1 to n+1 => n-1 to\
    \ n, n to n+1, n+1 to n+1 => n-1 to n, n to n+1, n+1 to n+1 => n-1 to n, n to\
    \ n, n+1 to n\n    # n, n+1, n+2 => n to n+1, n+1 to n+2, n+2 to n+2 => n to n+1,\
    \ n+1 to n+2, n+2 to n+2 => n to n+1, n+1 to n", "    if n == 0:\n        return\
    \ 0\n    triplets = 0\n    for i in range(1, n):\n        for j in range(i + 1,\
    \ n):\n            a_i = i * i - i + 1\n            a_j = j * j - j + 1\n    \
    \        a_k = (j + 1) * (j + 1) - (j + 1) + 1\n            if (a_i + a_j + a_k)\
    \ % 3 == 0:\n                triplets += 1\n    return triplets\n\n", "    # mod\
    \ = 10**9 + 7\n    # count = 0\n    # for i in range(1, n-1):\n    #     for j\
    \ in range(i+1, n):\n    #         for k in range(j+1, n+1):\n    #          \
    \   sum_ = (i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1)\n    #             if\
    \ sum_ % 3 == 0:\n    #                 count += 1\n    # return count % mod\n\
    \n    # (mod 3)\n    # 0 -> 1\n    # 1 -> 2\n    # 2 -> 1\n    # sum(1) = (1+2+1)*n/2\
    \ = n\n    # sum(2) = (1+2+1)*n/2 = n\n    # sum(3) = (1+2+1)*n/2 = n\n    mod\
    \ = 10**9 + 7\n    n = n-2\n\n    count_1 = (1 + n) * n // 2\n    count_2 = (1\
    \ + n) * n // 2\n    count_3 = (1 + n) * n // 2\n\n    return (count_1 * count_2\
    \ * count_3) % mod\n", "    a = []\n    max_triples = 0\n    for i in range(1,\
    \ n+1):\n        a.append(i*i - i + 1)\n    print(a)\n    for i in range(len(a)):\n\
    \        if i < len(a)-2:\n            for j in range(i+1, len(a)-1):\n      \
    \          for k in range(j+1, len(a)):\n                    if (a[i] + a[j] +\
    \ a[k]) % 3 == 0:\n                        max_triples += 1\n    return max_triples\n\
    \nprint(get_max_triples(5))\n", "    a = [x*x - x + 1 for x in range(1, n+1)]\n\
    \    count = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n\
    \            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0:\n                    count += 1\n    return count\n    \n    ", " \
    \   triples = 0\n    for i in range(1, n):\n        i_val = i * i - i + 1\n  \
    \      for j in range(i + 1, n):\n            j_val = j * j - j + 1\n        \
    \    for k in range(j + 1, n):\n                k_val = k * k - k + 1\n      \
    \          if (i_val + j_val + k_val) % 3 == 0:\n                    triples +=\
    \ 1\n    return triples\n\n", "    if n < 3:\n        return 0\n    # The length\
    \ of the array cannot be less than 3\n    max_possible_triples = (n-2) * (n-1)\
    \ * n // 6\n    # The number of multiples of 3 in the array is n // 3\n    triples_with_no_3\
    \ = n // 3\n    # We have to exclude the triples where a[i] + a[j] + a[k] is not\
    \ a multiple of 3\n    # For each (i, j) where i < j and a[i] + a[j] is not a\
    \ multiple of 3, we have (n-j) triples with (i, j)\n    # For each triple with\
    \ (i, j) where a[i] + a[j] is not a multiple of 3, \n    #   we have (n-j) * (n-j-1)\
    \ * (n-j-2) // 6 triples with (i, j, k) where a[i] + a[j] + a[k] is not a multiple\
    \ of 3\n    # The number of triples with (i, j) where a[i] + a[j] is not a multiple\
    \ of 3 is \n    #   (n-j) * (n-j-1) * (n-j-2) // 6 * (n-j)\n    #   for each j\n\
    \    #   = (n-j) * (n-j-1) * (n-j-2) // 2\n    #   for each j\n    #   = (n-j)\
    \ * (n-j-1) * (n-j-2) / 2\n    #   for each j\n    #   = ((n-j) * (n-j-1) / 2)\
    \ * (n-j-2)\n    #   for each j\n    # The number of triples where a[i] + a[j]\
    \ + a[k] is not a multiple of 3 is \n    #   = the sum of the number of triples\
    \ with (i, j) where a[i] + a[j] is not a multiple of 3\n    #     for each j\n\
    \    #   = sum of ((n-j) * (", "    return get_total_triples(n) - get_total_triples(n,\
    \ 2)\n    \n    ", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples\
    \ = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n   \
    \         for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) %\
    \ 3 == 0:\n                    triples += 1\n    return triples\n\n\nprint(get_max_triples(5))",
  "    pass\n\n", "    if n <= 2:\n        return 0\n    else:\n        # the index\
    \ of the last element that sum of a[i] + a[j] + a[k] is a multiple of 3\n    \
    \    # if k > k_max, then a[i] + a[j] + a[k] is not a multiple of 3\n        k_max\
    \ = (3 - 1) // 2\n\n        return n * (n - 1) * (n - 2) // 6 - (n - k_max - 1)\
    \ * (n - k_max - 2) // 2", "    # d = {i*i-i+1: i for i in range(1, n+1)}\n  \
    \  # print(d)\n    # s = set()\n    # for j in range(1, n+1):\n    #     for k\
    \ in range(j+1, n+1):\n    #         s.add((d[(j+k)//3], j, k))\n    # return\
    \ len(s)\n    return (n*(n-1)*(n-2)//6 + n*(n-1)//2)//3\n\n", "    max_triples\
    \ = (n * (n-1) * (n-2)) // 6\n    return max_triples\n\n", "    count = 0\n  \
    \  for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k\
    \ in range(j+1, n):\n                if (i+1)*(i+1) - (i+1) + 1 + (j+1)*(j+1)\
    \ - (j+1) + 1 + (k+1)*(k+1) - (k+1) + 1 == 3*k:\n                    count +=\
    \ 1\n    return count\n\n\nprint(get_max_triples(5))", "    if n == 1:\n     \
    \   return 0\n    max_triples = ((n-1)//3) * ((n-2)//3) * ((n-3)//3)\n    return\
    \ max_triples\n", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n    return\
    \ sum(1 for i in range(n - 2) for j in range(i + 1, n - 1) for k in range(j +\
    \ 1, n) if (a[i] + a[j] + a[k]) % 3 == 0)\n\n", "    return\n\n", '    return
    n // 3 + 1 if n % 3 == 0 else n // 3', "    all_triples = sum(int(i*(i-1)/2) for\
    \ i in range(1, n))\n    all_triples -= sum(i for i in range(1, n) if (i*i - i\
    \ + 1) % 3 == 0)\n    return all_triples\n\nprint(get_max_triples(5))\n", "  \
    \  if n < 3:\n        return 0\n    if n == 3:\n        return 1\n    if n < 5:\n\
    \        return 3\n    return get_max_triples(n - 1) + (n - 1)\n\n\n@pytest.mark.parametrize(\n\
    \    \"n, expected\",\n    [\n        (1, 0),\n        (2, 0),\n        (3, 1),\n\
    \        (4, 3),\n        (5, 6),\n        (6, 10),\n        (7, 15),\n      \
    \  (8, 21),\n        (9, 28),\n        (10, 36),\n        (11, 45),\n        (12,\
    \ 55),\n        (13, 66),\n        (14, 78),\n        (15, 91),\n        (16,\
    \ 105),\n        (17, 120),\n        (18, 136),\n        (19, 153),\n        (20,\
    \ 171),\n        (21, 190),\n        (22, 210),\n        (23, 231),\n        (24,\
    \ 253),\n        (25, 276),\n        (26, 300),\n        (27, 325),\n        (28,\
    \ 351),\n        (29, 378),\n        (30, 406),\n        (31, 435),\n        (32,\
    \ 465),\n        (33, 496),\n        (34, 528),\n        (35, 561),\n        (36,\
    \ 595),\n        (37, 630),\n        (38, 666),\n        (39, 703),\n        (40,\
    \ 741),\n        (41, 780),\n        (42, 820),\n        (43, 861),\n        (44,\
    \ 903),\n        (45, 946),\n        (46, 990),\n        (47, 1035),\n       \
    \ (48, 1081),\n        (49, 1128),\n        (50, 1176),\n        (51, 1225),\n\
    \        (52, 1275),\n        (53, 1326),\n        (54, 1378),\n        (55, 1431),\n\
    \        (56, 1485),\n        (57, 1540),\n        (58, 1596),\n        (59, 1653),",
  "    # 1 \u2264 n \u2264 105\n    # a[i] \u2264 109, for all 0 \u2264 i < n\n  \
    \  A = [i * i - i + 1 for i in range(1, n + 1)]\n    A.sort()\n    cnt = 0\n \
    \   for i in range(n - 2):\n        l, r = i + 1, n - 1\n        while l < r:\n\
    \            if A[i] + A[l] + A[r] == 0:\n                cnt += 1\n         \
    \       l += 1\n                r -= 1\n            elif A[i] + A[l] + A[r] <\
    \ 0:\n                l += 1\n            else:\n                r -= 1\n    return\
    \ cnt\n\n", "    max_triples = 0\n    mod_0 = 0\n    mod_1 = 0\n    mod_2 = 0\n\
    \    for i in range(1, n+1):\n        val = i * i - i + 1\n        if val % 3\
    \ == 0:\n            mod_0 += 1\n        elif val % 3 == 1:\n            mod_1\
    \ += 1\n        else:\n            mod_2 += 1\n    max_triples = mod_0 * (mod_0\
    \ - 1) * (mod_0 - 2) // 6\n    max_triples += mod_1 * mod_2 * (mod_0 - 1) // 2\n\
    \    max_triples += mod_0 * mod_1 * mod_2\n    return max_triples\n\n", "    arr\
    \ = []\n    for i in range(1, n+1):\n        num = i * i - i + 1\n        if num\
    \ % 3 == 0:\n            arr.append(num)\n    l = len(arr)\n    if l < 3:\n  \
    \      return 0\n    else:\n        return comb(l, 3)\n\n", "    n = n + 1\n \
    \   dp = [0] * n\n    dp[3] = 1\n    for i in range(4, n):\n        dp[i] = dp[i\
    \ - 1] + (i - 3)\n    return dp[n - 1]\n\n", "    a = [i * i - i + 1 for i in\
    \ range(1, n + 1)]\n    return sum(1 for i in range(n - 2) for j in range(i +\
    \ 1, n - 1) for k in range(j + 1, n) if a[i] + a[j] + a[k] % 3 == 0)\n    #count\
    \ = 0\n    # for i in range(n - 2):\n    #     for j in range(i + 1, n - 1):\n\
    \    #         for k in range(j + 1, n):\n    #             if a[i] + a[j] + a[k]\
    \ % 3 == 0:\n    #                 count += 1\n    # return count\n\n", "    mod_0\
    \ = n // 3\n    mod_1 = n // 3 + (1 if n % 3 != 0 else 0)\n    mod_2 = n // 3\
    \ + (1 if n % 3 == 2 else 0)\n    return mod_0 * mod_1 * mod_2\n\n", '    pass',
  "    return get_max_triples_builtin(n)\n\n", "    return len([(i, j, k) for i in\
    \ range(1, n) for j in range(i + 1, n) for k in range(j + 1, n)\n            \
    \    if (i * i - i + 1 + j * j - j + 1 + k * j - k + 1) % 3 == 0])\n\n", "   \
    \ a = [i * i - i + 1 for i in range(1, n + 1)]\n    divisible_by_3 = []\n    for\
    \ i in range(0, n - 2):\n        for j in range(i + 1, n - 1):\n            for\
    \ k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n \
    \                   divisible_by_3.append((a[i], a[j], a[k]))\n    return len(divisible_by_3)\n\
    \n", "    # find all the triples of a where i < j < k, \n    # and a[i] + a[j]\
    \ + a[k] is a multiple of 3.\n    # We need to find the number of triples where\
    \ a[i] + a[j] + a[k] % 3 == 0\n    # First approach is to generate all the triples\
    \ and check the condition.\n    # But the time complexity is high O(n^3)\n   \
    \ # So, we can improve the solution by finding the index where we want to start\
    \ looking for a[j]\n    # We can do that in O(n^2)\n    # Consider (i, j, k) as\
    \ a triple\n    # a[i] = i * i - i + 1 = (i - 1) * (i - 1) + i = (i - 1) ^ 2 +\
    \ i\n    # a[j] = j * j - j + 1 = (j - 1) * (j - 1) + j = (j - 1) ^ 2 + j\n  \
    \  # a[k] = k * k - k + 1 = (k - 1) * (k - 1) + k = (k - 1) ^ 2 + k\n    # So,\
    \ a[i] + a[j] + a[k] % 3 == 0\n    # if, (i - 1) ^ 2 + i + (j - 1) ^ 2 + j + (k\
    \ - 1) ^ 2 + k % 3 == 0\n    # (i - 1) ^ 2 + i % 3 == 0\n    # (j - 1) ^ 2 + j\
    \ % 3 == 0\n    # (k - 1) ^ 2 + k % 3 == 0\n    # If we assume that 0 <= i < j\
    \ < k <= n, then we can find the number of possible j and k\n    # when we are\
    \ iterating i\n    # so, (i - 1) ^ 2 + i % 3 == 0\n    #   => i % 3 == 2 or 0\n\
    \    # Similarly, we can find the values of j and k where j mod 3 == 2 or 0 and\
    \ k mod 3 == 2 or 0\n    # So, we will iterate over i from 1 to n and find the\
    \ number of possible j and k\n    count = 0\n   ", "    # a[i] = i * i - i + 1\n\
    \    # a[i] + a[j] + a[k] = 3 * i^2 - 3 * i + 3 - 3 * j^2 + 3 * j - 3 + 3 * k^2\
    \ - 3 * k + 3\n    # a[i] + a[j] + a[k] = 3(i^2 - i - j^2 + j + k^2 - k) + 9\n\
    \    # a[i] + a[j] + a[k] = 3 * (i^2 - i) + 3 * (j^2 - j) + 3 * (k^2 - k) + 9\n\
    \    # a[i] + a[j] + a[k] = 3 * (i * (i - 1)) + 3 * (j * (j - 1)) + 3 * (k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1) + j * (j - 1) + k * (k\
    \ - 1)) + 9\n    # a[i] + a[j] + a[k] = 3 * (i * (i - 1", "    # Let sum of a[i],\
    \ a[j], a[k] = 3m.\n    # a[i] + a[j] + a[k] = 3m.\n    # a[i] + a[j] = 3m - a[k].\n\
    \    # k = (a[i] + a[j] - 3m) / 3.\n    # If k is an integer, there is an integer\
    \ triple.\n    # m = (a[i] + a[j] + a[k]) / 3.\n    # If a[i] + a[j] + a[k] is\
    \ a multiple of 3.\n    # Then, a[i] + a[j] is a multiple of 3.\n    # Then, a[i]\
    \ + a[j] + a[k] is a multiple of 3.\n    # If a[i] + a[j] is a multiple of 3.\n\
    \    # Then, a[i] + a[j] + a[k] is a multiple of 3.\n    # a[i] + a[j] + a[k]\
    \ = (a[i] + a[j]) + (a[j] + a[k]) + (a[k] + a[i])\n    #                     =\
    \ (a[i] + a[j]) + a[k] * 2 + a[j] - a[i]\n    #                     = (a[i] +\
    \ a[j]) + (a[k] - a[i]) * 2 + a[j]\n    #                     = (a[i] + a[j])\
    \ + (3m - (a[i] + a[j])) * 2 + a[j]\n    #                     = (a[i] + a[j])\
    \ + 3m * 2 - 2(a[i] + a[j]) + a[j]\n    #                     = 3m + a[j]\n  \
    \  #                     = 3m + 2k + 1\n\n    # a[i] + a[j] = 3m - a[k] = 3m -\
    \ 2k - 1\n    # a[i] + a[j] = 3m - 2(3m - a[i] - a[j]) - 1\n   ", "    res = 0\n\
    \    for i in range(n):\n        for j in range(i+1, n):\n            for k in\
    \ range(j+1, n):\n                ijk = i * i - i + 1 + j * j - j + 1 + k * k\
    \ - k + 1\n                if ijk % 3 == 0:\n                    res += 1\n  \
    \  return res\n", '    pass', '    pass', "    a = [i * i - i + 1 for i in range(1,\
    \ n + 1)]\n    triples = 0\n    for i in range(len(a)):\n        for j in range(i\
    \ + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if\
    \ (a[i] + a[j] + a[k]) % 3 == 0:\n                    triples += 1\n    return\
    \ triples\n\n", "    x = []\n    for i in range(1, n+1):\n        x.append(i*i\
    \ - i + 1)\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1,\
    \ n-1):\n            for k in range(j+1, n):\n                if (x[i] + x[j]\
    \ + x[k]) % 3 == 0:\n                    count += 1\n    return count\n\n", " \
    \   return sum(\n        1\n        for i in range(1, n)\n        for j in range(i\
    \ + 1, n)\n        for k in range(j + 1, n)\n        if sum([i, j, k]) % 3 ==\
    \ 0\n    )\n\n\nassert get_max_triples(5) == 1\nassert get_max_triples(20) ==\
    \ 43", "    return sum([1 for i in range(1, n-1) for j in range(i+1, n) for k\
    \ in range(j+1, n) if (i*i-i+1+j*j-j+1+k*j-k+1)%3==0])\n", "    return sum(map(triples,\
    \ get_triplets(n)))\n", "    a = [(i * i - i + 1) % 3 for i in range(1, n + 1)]\n\
    \    s = sum(a)\n    return s * (n - 2)\n", "    # Create array a of len n, where\
    \ each element is calculated from the formula.\n    a = [i * i - i + 1 for i in\
    \ range(1, n + 1)]\n    # Check for each element if it's divisible by 3.\n   \
    \ return sum(1 for i in a if i % 3 == 0)\n\n", "    a = [i * i - i + 1 for i in\
    \ range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in\
    \ range(i + 1, n - 1):\n            for k in range(j + 1, n):\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return\
    \ count\n\n", "    if n < 3:\n        return 0\n    else:\n        mod_dict =\
    \ {0: 0, 1: 0, 2: 0}\n        answer = 0\n        mod_dict[(n * n - n + 1) % 3]\
    \ += 1\n        for i in range(n - 1, 2, -1):\n            new_mod = (i * i -\
    \ i + 1) % 3\n            answer += mod_dict[(3 - new_mod) % 3]\n            mod_dict[new_mod]\
    \ += 1\n        return answer\n\n", "    # ijk are consecutive numbers\n    return\
    \ n // 3\n\n", "    return (n * (n - 1) * (n - 2)) // 6\n\n\nprint(get_max_triples(5))",
  "    # Get the max possible value of 3 * (1, 2, 3, 4, 5, ...)\n    max_num = 3 *\
    \ sum(range(1, n + 1))\n    # Get the mod of the max number\n    max_mod = max_num\
    \ % 3\n    # Get the combinations of 3\n    triples = (n * (n - 1) * (n - 2))\
    \ // 6\n    # If the mod is different than 0\n    if max_mod != 0:\n        #\
    \ Remove the combinations for the numbers that are not divisible by 3\n      \
    \  n_bad_nums = math.ceil(max_num / 3)\n        triples -= (n_bad_nums * (n_bad_nums\
    \ - 1) * (n_bad_nums - 2)) // 6\n    return triples\n\n", "    # assert n > 0\n\
    \    # dp[i] = i * i - i + 1\n    # dp[n] = n * n - n + 1\n\n    def get_sum(n:\
    \ int) -> int:\n        return n * (n + 1) // 2\n\n    # sum of dp[i] = 1/3 *\
    \ i * (i + 1) * (i + 2)\n    # sum of dp[1] + dp[2] + ... + dp[k] = 1/3 * (1 +\
    \ 2 + ... + k) * (2 + 3 + ... + k + 1) * (3 + 4 + ... + k + 2)\n    # sum of dp[1]\
    \ + dp[2] + ... + dp[k] = 1/3 * k * (k + 1) * (k + 2)\n    # sum of dp[1] + dp[2]\
    \ + ... + dp[k] = k * k * (k + 1) // 3\n    # sum of dp[1] + dp[2] + ... + dp[k]\
    \ = 1/3 * (k * k * (k + 1))\n    # sum of dp[1] + dp[2] + ... + dp[k] = 1/3 *\
    \ (k * k * (k + 1))\n    # dp[n] = n * n - n + 1\n    # sum of dp[1] + dp[2] +\
    \ ... + dp[k] = 1/3 * (k * k * (k + 1)) = n * n - n + 1\n    # k * k * (k + 1)\
    \ = 3 * (n * n - n + 1)\n    # k * k * (k + 1) = 3 * n * n - 3 * n + 3\n    #\
    \ k * k * (k + 1) - 3 * n * n + 3 * n - 3 = 0\n    # (k - n) * (k * k + n * k\
    \ + n - 3) = 0\n    # (k - n) * (k * (k + n) + n - 3) = 0\n    # (k - n) * (k\
    \ * (k + n", "    def get_sum(n: int) -> int:\n        return int(n * (n + 1)\
    \ / 2)\n\n    def count_factor(n: int, factor: int) -> int:\n        count = 0\n\
    \        for i in range(factor, n+1, factor):\n            count += i // factor\n\
    \        return count\n\n    N = n - 2\n    return N - get_sum(N // 3) - get_sum(N\
    \ // 2) + get_sum(N // 6)\n\n", "    triples = 0\n    arr = []\n    max_number\
    \ = 0\n    for i in range(1, n+1):\n        val = i * i - i + 1\n        if val\
    \ % 3 == 0:\n            triples += 1\n        arr.append(val)\n        max_number\
    \ = max(max_number, val)\n    total_triples = n * (n-1) * (n-2) // 6\n    cache\
    \ = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            if\
    \ arr[i] + arr[j] in cache:\n                cache[arr[i] + arr[j]] += 1\n   \
    \         else:\n                cache[arr[i] + arr[j]] = 1\n    for k in range(n):\n\
    \        if arr[k] in cache:\n            triples += cache[arr[k]]\n        if\
    \ arr[k] % 3 == 0:\n            triples -= 1\n    return triples // 2\n", "  \
    \  def mod3(x: int) -> int:\n        return x % 3\n\n    def count_subarrays(nums:\
    \ List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n\
    \            for j in range(i + 1, len(nums)):\n                if nums[i] ==\
    \ nums[j]:\n                    count += 1\n        return count\n\n    nums =\
    \ [mod3(i * i - i + 1) for i in range(1, n + 1)]\n    return count_subarrays(nums)\n",
  '    return (1 + n) * n // 2 // 3', "    return (n-1) * (n-2) / 2\n\n", "    MOD\
    \ = 3\n    s, e = 1, n\n    _sum = sum(range(s, e + 1))\n    _len = e - s + 1\n\
    \    _num = _sum // MOD\n    _start = _num * MOD - _sum\n    return _len * (_len\
    \ - 1) // 2 * (_len - 2) // 3 - _start\n\n", "    lst = []\n    for i in range(1,\
    \ n+1):\n        lst.append(i*i - i + 1)\n    triples = 0\n    for i in range(n):\n\
    \        for j in range(i+1, n):\n            for k in range(j+1, n):\n      \
    \          if lst[i] + lst[j] + lst[k] % 3 == 0:\n                    triples\
    \ += 1\n    return triples\n\n", "    max_triples = 0\n    if n < 3:\n       \
    \ return max_triples\n    for i in range(n):\n        for j in range(i+1, n):\n\
    \            for k in range(j+1, n):\n                if (i+1)*(i+1) - (i+1) +\
    \ 1 + (j+1)*(j+1) - (j+1) + 1 + (k+1)*(k+1) - (k+1) + 1 == 0:\n              \
    \      max_triples += 1\n    return max_triples\n", "    triple_map = {}\n   \
    \ for i in range(1, n+1):\n        triple_map[i*i-i+1] = True\n    count = 0\n\
    \    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for\
    \ k in range(j+1, n+1):\n                if (i*i-i+1) + (j*j-j+1) + (k*k-k+1)\
    \ % 3 == 0:\n                    count += 1\n    return count\n\n\n", "    # calculate\
    \ all the values of a\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    #\
    \ iterate over all possible triples and check if a[i] + a[j] + a[k] % 3 == 0\n\
    \    triples = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n\
    \ - 1):\n            for k in range(j + 1, n):\n                if a[i] + a[j]\
    \ + a[k] % 3 == 0:\n                    triples += 1\n    return triples\n\n\n",
  "    return sum([1 for i in range(n) for j in range(i+1, n) for k in range(j+1,\
    \ n) if (i*i-i+1+j*j-j+1+k*k-k+1)%3==0])\n", "    a = [i * i - i + 1 for i in\
    \ range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j\
    \ in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n     \
    \           if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\
    \    return count\n\n", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n  \
    \  return count_triples(a)\n\n", "    a = [i * i - i + 1 for i in range(1, n +\
    \ 1)]\n    return sum(1 for i in range(n - 2) for j in range(i + 1, n - 1) for\
    \ k in range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 == 0)\n\n", "    res = 0\n\
    \    sum_a = 0\n    for i in range(1, n):\n        for j in range(i+1, n):\n \
    \           for k in range(j+1, n):\n                sum_a = a(i) + a(j) + a(k)\n\
    \                if sum_a % 3 == 0:\n                    res += 1\n    return\
    \ res\n", "    from itertools import combinations\n\n    a = [i * i - i + 1 for\
    \ i in range(1, n + 1)]\n    combos = combinations(a, 3)\n    return sum(1 for\
    \ triple in combos if sum(triple) % 3 == 0)", "    if n == 1:\n        return\
    \ 0\n    return ((n - 1) * (n - 2) * (n - 3)) // 6\n\n", "    count = 0\n    for\
    \ i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1,\
    \ n):\n                a = (i+1) * (i+1) - (i+1) + 1\n                b = (j+1)\
    \ * (j+1) - (j+1) + 1\n                c = (k+1) * (k+1) - (k+1) + 1\n       \
    \         if (a + b + c) % 3 == 0:\n                    count += 1\n    return\
    \ count\n", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n    res = 0\n \
    \   for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n        \
    \    for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) %\
    \ 3 == 0:\n                    res += 1\n    return res\n\n", "    mod3_freq =\
    \ [0] * 3\n    for i in range(1, n + 1):\n        val = i * i - i + 1\n      \
    \  mod3_freq[val % 3] += 1\n    n_zeros = mod3_freq[0]\n    n_ones = mod3_freq[1]\n\
    \    n_twos = mod3_freq[2]\n    return int(comb(n_zeros, 3) + comb(n_ones, 3)\
    \ + comb(n_twos, 3) + n_zeros * n_ones * n_twos)\n\n", "    l = []\n    for i\
    \ in range(1, n+1):\n        l.append(i*i - i + 1)\n    # print(l)\n    count\
    \ = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n         \
    \   for k in range(j+1, n):\n                if (l[i] + l[j] + l[k]) % 3 == 0:\n\
    \                    count += 1\n    return count\n", "    # Get a[i] values\n\
    \    a = list(map(lambda i: i * i - i + 1, range(1, n + 1)))\n    # Get all possible\
    \ combinations of triples\n    triples = list(combinations(a, 3))\n    return\
    \ sum(1 for t in triples if sum(t) % 3 == 0)", "    return sum(1 for i in range(n)\
    \ for j in range(i + 1, n) for k in range(j + 1, n) if (i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1) % 3 == 0)\n\n", "    return (n * (n-1) * (n-2)) //\
    \ 6\n\n", "    total = 0\n    # a = [i*i - i + 1 for i in range(1, n+1)]\n   \
    \ for i in range(1, n-1):\n        for j in range(i+1, n):\n            for k\
    \ in range(j+1, n+1):\n                if (i*i - i + 1 + j*j - j + 1 + k*k - k\
    \ + 1) % 3 == 0:\n                    total += 1\n                    print(i,\
    \ j, k)\n    return total\n\n", "    _, res = get_max_triples_helper(n)\n    return\
    \ res\n\n", "    pass\n\n", "    cnt = 0\n    for i in range(n):\n        for\
    \ j in range(i+1, n):\n            for k in range(j+1, n):\n                if\
    \ a[i] + a[j] + a[k] % 3 == 0:\n                    cnt += 1\n    return cnt\n\
    \n", "    # a[i] % 3 == 2 <==> (i * i - i + 1) % 3 == 2\n    # <==> i * i % 3\
    \ == 2 * i % 3 + 1\n    # <==> (i * i + 2 * i + 1) % 3 == 0\n    # <==> (3 * i\
    \ * i + 6 * i + 3) % 3 == 0\n    # <==> 3 * i * i + 6 * i + 3 == 0\n    # <==>\
    \ i * (3 * i + 6) + 3 == 0\n    # <==> i * (3 * i + 6) == -3\n    # <==> i * (3\
    \ * i + 6) == 3 mod 3\n    # <==> i * (3 * i + 6) == 0 mod 3\n    # <==> i * (3\
    \ * i + 6) % 3 == 0\n    # => for any i: if i * (3 * i + 6) % 3 == 0 then a[i]\
    \ % 3 == 2\n    # => All we need to do is counting number of i's that i * (3 *\
    \ i + 6) % 3 == 0\n    # => There are floor(n / 3) + 1 (1 + 2 + ... + floor(n\
    \ / 3)) such i's.\n    # => => ceil(n / 3) is number of i's that i * (3 * i +\
    \ 6) % 3 == 0\n    res = math.ceil(n / 3)\n    # => => There are floor(n / 3)\
    \ + 1 (1 + 2 + ... + floor(n / 3)) such i's.\n    # => => There are floor(n /\
    \ 3) (0 + 1 + ... + floor(n / 3) - 1) such i's.\n    res -= math.floor(n / 3)\n\
    \    return res\n\n", "    if n < 3:\n        return 0\n    assert n >= 3\n  \
    \  return n * (n - 1) * (n - 2) // 6\n\n", "    pass\n\n", "    # Time complexity:\
    \ O(N)\n    # Space complexity: O(1)\n    max_triples = 0\n    rem_1 = rem_2 =\
    \ 0\n    for num in range(1, n + 1):\n        curr_num = num * num - num + 1\n\
    \        if curr_num % 3 == 0:\n            max_triples += 1\n        elif curr_num\
    \ % 3 == 1:\n            rem_1 += 1\n        else:\n            rem_2 += 1\n \
    \   return max_triples + min(rem_1, rem_2)", "    # n = 5\n    # a = [1, 3, 7,\
    \ 13, 21]\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    # for i, x in\
    \ enumerate(a):\n    #     print(i, x)\n    # [(i, x) for i, x in enumerate(a)]\n\
    \    # [(0, 1), (1, 3), (2, 7), (3, 13), (4, 21)]\n    a = [(i, x) for i, x in\
    \ enumerate(a)]\n    b = [(i, x, y) for i, x in a for j, y in a if i < j]\n  \
    \  c = [(i, x, y, z) for i, x, y in b for j, _, z in b if i < j]\n    # print(b)\n\
    \    # print(c)\n    c = [(i, x, y, z) for i, x, y, z in c if x + y + z % 3 ==\
    \ 0]\n    return len(c)\n\n", "    return (n * (n - 1) * (n - 2)) // 6\n\n", " \
    \   a = [(i * i - i + 1) % 3 for i in range(1, n + 1)]\n    return sum(\n    \
    \    1\n        for i in range(n - 2)\n        for j in range(i + 1, n - 1)\n\
    \        for k in range(j + 1, n)\n        if a[i] + a[j] + a[k] == 0\n    )\n\
    \n", "    total_triples = 0\n    for i in range(n-2):\n        for j in range(i+1,\
    \ n-1):\n            for k in range(j+1, n):\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0:\n                    total_triples += 1\n    return total_triples\n",
  "    # Brute force\n    # Time: O(n^3)\n    # Space: O(n)\n    count = 0\n    for\
    \ i in range(1, n - 1):\n        for j in range(i + 1, n):\n            for k\
    \ in range(j + 1, n + 1):\n                if (i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % 3 == 0:\n                    count += 1\n    return count\n\
    \n", "    if n < 3:\n        return 0\n    def get_num_of_multiples_of_3(a: int,\
    \ b: int) -> int:\n        if a % 3 == 0 and b % 3 == 0:\n            return min(a\
    \ // 3, b // 3)\n        elif a % 3 == 0 and b % 3 == 1:\n            return min(a\
    \ // 3, (b - 1) // 3)\n        elif a % 3 == 0 and b % 3 == 2:\n            return\
    \ min(a // 3, (b - 2) // 3)\n        elif a % 3 == 1 and b % 3 == 0:\n       \
    \     return min((a - 1) // 3, b // 3)\n        elif a % 3 == 1 and b % 3 == 1:\n\
    \            return min((a - 1) // 3, (b - 1) // 3)\n        elif a % 3 == 1 and\
    \ b % 3 == 2:\n            return min((a - 1) // 3, (b - 2) // 3)\n        elif\
    \ a % 3 == 2 and b % 3 == 0:\n            return min((a - 2) // 3, b // 3)\n \
    \       elif a % 3 == 2 and b % 3 == 1:\n            return min((a - 2) // 3,\
    \ (b - 1) // 3)\n        elif a % 3 == 2 and b % 3 == 2:\n            return min((a\
    \ - 2) // 3, (b - 2) // 3)\n    return get_num_of_multiples_of_3(n, 2 * n - 1)\
    \ + get_num_of_multiples_of_3(n - 1, 2 * n - 2)", "    ans = 0\n    for i in range(n):\n\
    \        for j in range(i+1, n):\n            for k in range(j+1, n):\n      \
    \          if ((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 == 0:\n\
    \                    ans += 1\n    return ans\n", "    if n < 3:\n        return\
    \ 0\n    else:\n        return n//3 * (n-1)//2 * (n-2)//1\n\n", "    if n < 1:\n\
    \        return 0\n    triples = set()\n    for i in range(1, n + 1):\n      \
    \  for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n\
    \                s = i * i - i + 1 + j * j - j + 1 + k * k - k + 1\n         \
    \       if s % 3 == 0:\n                    triples.add((i, j, k))\n    return\
    \ len(triples)\n\n", '    return (1 + n - 1) * (n - 1) // 2', "    a = [i * i\
    \ - i + 1 for i in range(1, n + 1)]\n    print(a)\n    count = 0\n    for i in\
    \ range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j\
    \ + 1, n):\n                if a[i] + a[j] + a[k] % 3 == 0:\n                \
    \    count += 1\n    return count\n\n", "    pass\n\n", "    triples_cnt = 0\n\
    \    for i in range(n):\n        for j in range(i + 1, n):\n            for k\
    \ in range(j + 1, n):\n                ai = i * i - i + 1\n                aj\
    \ = j * j - j + 1\n                ak = k * k - k + 1\n                if (ai\
    \ + aj + ak) % 3 == 0:\n                    triples_cnt += 1\n    return triples_cnt\n\
    \n", "    return int(n * (n - 1) * (n - 2) / 6)\n\n", "    a = [0] * n\n    for\
    \ i in range(n):\n        a[i] = i * i - i + 1\n    max_triples = 0\n    for i\
    \ in range(n):\n        for j in range(i + 1, n):\n            for k in range(j\
    \ + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n              \
    \      max_triples += 1\n    return max_triples\n\n", "    return (n * (n - 1)\
    \ * (n - 2)) // 6\n\n", "    if n <= 2:\n        return 0\n    return get_max_triples_helper(n)\n\
    \n", "    if n == 0:\n        return 0\n    a = [x*x - x + 1 for x in range(1,\
    \ n+1)]\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1,\
    \ n-1):\n            for k in range(j+1, n):\n                if a[i] + a[j] +\
    \ a[k] % 3 == 0:\n                    count += 1\n    return count\n\n", "   \
    \ if n < 3:\n        return 0\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n\
    \    res = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n\
    \            if (a[i] + a[j]) % 3 == 0:\n                for k in range(j + 1,\
    \ n):\n                    if (a[i] + a[j] + a[k]) % 3 == 0:\n               \
    \         res += 1\n    return res\n\n", "    a = [i * i - i + 1 for i in range(1,\
    \ n + 1)]\n    return len([(i, j, k) for i in range(n) for j in range(i + 1, n)\
    \ for k in range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 == 0])\n\n", "    a = [i\
    \ * i - i + 1 for i in range(1, n + 1)]\n    return len([(a[i], a[j], a[k]) for\
    \ i in range(len(a)) for j in range(i + 1, len(a)) for k in range(j + 1, len(a))\
    \ if (a[i] + a[j] + a[k]) % 3 == 0])\n\n", "    return n // 3 * (n // 3 - 1) //\
    \ 2\n", "    a = list(map(lambda x: x * x - x + 1, range(1, n + 1)))\n    count\
    \ = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n   \
    \         for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) %\
    \ 3 == 0:\n                    count += 1\n    return count\n\n", "    a = [i\
    \ * i - i + 1 for i in range(1, n + 1)]\n    res = 0\n    for i in range(n - 2):\n\
    \        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    res +=\
    \ 1\n    return res\n\n", "    a = list(range(1, n + 1))\n    a = [i*i - i + 1\
    \ for i in a]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i+1,\
    \ len(a)):\n            for k in range(j+1, len(a)):\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n\
    \n", "    assert n > 0\n    return get_max_triples_1(n)\n\n", "    triples = 0\n\
    \    for i in range(1, n):\n        for j in range(i + 1, n):\n            for\
    \ k in range(j + 1, n):\n                if (i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0:\n                    triples += 1\n    return triples",
  "    res = 0\n    mod = 3\n    S = [i * i - i + 1 for i in range(1, n + 1)]\n  \
    \  F = [0] * mod\n    for i in range(n):\n        res += F[S[i] % mod]\n     \
    \   F[S[i] % mod] += 1\n    return res\n\n", "    a = [i * i - i + 1 for i in\
    \ range(1, n + 1)]\n    triples = []\n    for i in range(len(a)):\n        for\
    \ j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n   \
    \             if (a[i] + a[j] + a[k]) % 3 == 0:\n                    triples.append((a[i],\
    \ a[j], a[k]))\n    return len(triples)\n", "    i = 1\n    total = 0\n    while\
    \ i < n:\n        j = i + 1\n        while j < n:\n            k = j + 1\n   \
    \         while k < n:\n                if (i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0:\n                    total += 1\n                k +=\
    \ 1\n            j += 1\n        i += 1\n    return total\n", "    a = [i * i\
    \ - i + 1 for i in range(1, n + 1)]\n    return sum(1 for i in range(n - 2) for\
    \ j in range(i + 1, n - 1) for k in range(j + 1, n) if a[i] + a[j] + a[k] % 3\
    \ == 0)\n\n", "    nums = list(range(1, n+1))\n    return len([(i, j, k) for i\
    \ in nums for j in nums for k in nums if j > i if k > j if (i + j + k) % 3 ==\
    \ 0])\n\n", "    triples_count = 0\n    for i in range(n):\n        for j in range(i\
    \ + 1, n):\n            for k in range(j + 1, n):\n                if (i + 1)\
    \ * (i + 1) - (i + 1) + 1 + (j + 1) * (j + 1) - (j + 1) + 1 + (k + 1) * (k + 1)\
    \ - (k + 1) + 1 \\\n                        % 3 == 0:\n                    triples_count\
    \ += 1\n    return triples_count\n\n", "    return sum(1 for i in range(n) for\
    \ j in range(i + 1, n) for k in range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0)\n\n", "    if n < 3:\n        return 0\n    # 1. For each a[i], search for\
    \ a[j] and a[k] such that a[i] + a[j] + a[k] = 3n\n    # 2. The number of triplets\
    \ satisfy the condition is equal to the number of subarray sum equal to n\n  \
    \  res = get_subarray_sum(n)\n    return res\n\n", "    return n * (n - 1) * (n\
    \ - 2) // 6\n\nassert get_max_triples(5) == 1\nassert get_max_triples(4) == 0\n\
    assert get_max_triples(6) == 3", "    return n * (n - 1) * (n - 2) // 6\n\n",
  "    return n * (n - 1) * (n - 2) // 6\n\n", '    return (n * (n - 1) * (n - 2))
    // 6', "    def get_triples(a: int, b: int, c: int) -> int:\n        if a+b+c\
    \ == 0:\n            return 1\n        return 0\n\n    if n < 3:\n        return\
    \ 0\n    size = n - 2\n    # a[i] = i * i - i + 1\n    a = [0] * size\n    for\
    \ i in range(size):\n        a[i] = i * i - i + 1\n    triples = 0\n    for i\
    \ in range(size):\n        for j in range(i+1, size):\n            for k in range(j+1,\
    \ size):\n                triples += get_triples(a[i], a[j], a[k])\n    return\
    \ triples\n\n", "    return n * (n - 1) * (n - 2) // 6\n\n\n", "    if n == 1:\n\
    \        return 0\n    res = 0\n    for i in range(1, n):\n        for j in range(i+1,\
    \ n):\n            if (i * i - i + 1 + j * j - j + 1) % 3 == 0:\n            \
    \    res += 1\n    return res\n\n", "    # Solution 1 (O(n^3)):\n    # triples\
    \ = 0\n    # for i in range(1, n):\n    #     for j in range(i+1, n):\n    # \
    \        for k in range(j+1, n):\n    #             if (i*i - i + 1 + j*j - j\
    \ + 1 + k*k - k + 1) % 3 == 0:\n    #                 triples += 1\n    # return\
    \ triples\n\n    # Solution 2 (O(n^2)):\n    # c = [0] * 3\n    # for i in range(1,\
    \ n):\n    #     num = i * i - i + 1\n    #     c[num % 3] += 1\n    # triples\
    \ = 0\n    # for i in range(1, n):\n    #     for j in range(i+1, n):\n    # \
    \        num = i * i - i + 1 + j * j - j + 1\n    #         if num % 3 == 0:\n\
    \    #             triples += c[(3 - num % 3) % 3]\n    # return triples\n\n \
    \   # Solution 3 (O(n)):\n    c = [0] * 3\n    for i in range(1, n):\n       \
    \ num = i * i - i + 1\n        c[num % 3] += 1\n    triples = c[0] * (c[0] - 1)\
    \ * (c[0] - 2) // 6\n    triples += c[1] * (c[1] - 1) * (c[2] - 2) // 6\n    triples\
    \ += c[2] * (c[2] - 1) * (c[1] - 2) // 6\n    triples += c[0] * c[1] * c[2]\n\
    \    return triples\n\n", "    if n < 3:\n        return 0\n    # find the number\
    \ of triples.\n    # count(0), count(1), count(2)\n    # (0, 1, 2) (0, 2, 1) (1,\
    \ 0, 2) (1, 2, 0) (2, 0, 1) (2, 1, 0)\n    # we can use the function combination(n,\
    \ k) to represent the number of k numbers from n numbers\n    # it is equivalent\
    \ to C(n, k)\n    # for (i, j, k)\n    # count(0) = combination(n, 3) - combination(n,\
    \ 3) + combination(n, 2)\n    # count(1) = combination(n, 3) - combination(n,\
    \ 3)\n    # count(2) = combination(n, 3)\n    # then sum up count(0), count(1),\
    \ count(2)\n    return combination(n, 3) + combination(n, 3) - combination(n,\
    \ 2)\n", "    # Time: O(n)\n    # Space: O(n)\n    if n < 3:\n        return 0\n\
    \    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in\
    \ range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j\
    \ + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n              \
    \      count += 1\n    return count\n\n", "    assert n >= 1\n\n    a = [i * i\
    \ - i + 1 for i in range(1, n + 1)]\n    return len([(i, j, k) for i in range(n)\
    \ for j in range(i + 1, n) for k in range(j + 1, n) if (a[i] + a[j] + a[k]) %\
    \ 3 == 0])\n\n", "    a = [i * i - i + 1 for i in range(1, n + 1)]\n    ans =\
    \ 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n   \
    \         for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0:\n                    ans += 1\n    return ans", "    # return sum(int(a[i]\
    \ + a[j] + a[k]) % 3 == 0 for i in range(n) for j in range(i + 1, n) for k in\
    \ range(j + 1, n))\n    return sum(i + j + k for i in range(n) for j in range(i\
    \ + 1, n) for k in range(j + 1, n) if (i + j + k) % 3 == 0)\n", "    count = 0\n\
    \    for i in range(1, n):\n        i_mod = i * i - i + 1\n        for j in range(i\
    \ + 1, n):\n            j_mod = j * j - j + 1\n            for k in range(j +\
    \ 1, n):\n                k_mod = k * k - k + 1\n                if (i_mod + j_mod\
    \ + k_mod) % 3 == 0:\n                    count += 1\n    return count\n\n\nassert\
    \ get_max_triples(5) == 1\nassert get_max_triples(8) == 2\nassert get_max_triples(20)\
    \ == 18", "    # counter = 0\n    # for i in range(1, n - 1):\n    #     for j\
    \ in range(i + 1, n):\n    #         for k in range(j + 1, n + 1):\n    #    \
    \         if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0:\n    #\
    \                 counter += 1\n    # return counter\n\n    # n = n - 2\n    #\
    \ return n * (n + 1) * (n + 2) // 6\n    return n * (n - 1) * (n - 2) // 6", " \
    \   a = []\n    for i in range(1, n+1):\n        a.append(i*i - i + 1)\n    count\
    \ = 0\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n   \
    \         for k in range(j+1, len(a)):\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0:\n                    count += 1\n    return count\n\n", "    if n\
    \ < 3:\n        return 0\n    elif n == 3:\n        return 1\n    else:\n    \
    \    arr = []\n        for i in range(1, n + 1):\n            arr.append(i * i\
    \ - i + 1)\n        count = 0\n        for i in range(0, n - 2):\n           \
    \ for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n \
    \                   if (arr[i] + arr[j] + arr[k]) % 3 == 0:\n                \
    \        count += 1\n        return count\n\n", "    triples = 0\n    for i in\
    \ range(1, n - 1):\n        for j in range(i + 1, n):\n            for k in range(j\
    \ + 1, n + 1):\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0:\n                    triples += 1\n    return triples\n\n", " \
    \   n = n // 3 * 3\n    return n * (n - 1) * (n - 2) // 24\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
