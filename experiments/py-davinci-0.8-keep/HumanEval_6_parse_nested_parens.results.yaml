name: HumanEval_6_parse_nested_parens
language: py
results:
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret: List[int] = []\n\
    \    for nested_parens in paren_string.split():\n        depth = 0\n        max_depth\
    \ = 0\n        for c in nested_parens:\n            if c == '(':\n           \
    \     depth += 1\n                max_depth = max(max_depth, depth)\n        \
    \    elif c == ')':\n                depth -= 1\n        ret.append(max_depth)\n\
    \    return ret\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_splits = paren_string.split('\
    \ ')\n    if not paren_splits:\n        return None\n    counts = []\n    for\
    \ group in paren_splits:\n        if not group:\n            continue\n      \
    \  count = 0\n        tmp_count = 0\n        for char in group:\n            if\
    \ char == '(':\n                tmp_count += 1\n            elif char == ')':\n\
    \                tmp_count -= 1\n            count = max(count, tmp_count)\n \
    \       counts.append(count)\n    return counts\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels = []\n\
    \    for paren_group in paren_string.split():\n        paren_level = 0\n     \
    \   max_paren_level = 0\n        for paren in paren_group:\n            if paren\
    \ == '(':\n                paren_level += 1\n                max_paren_level =\
    \ max(max_paren_level, paren_level)\n            elif paren == ')':\n        \
    \        paren_level -= 1\n        paren_levels.append(max_paren_level)\n    return\
    \ paren_levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    levels = []\n    for group in groups:\n        max_level = 0\n        curr_level\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            else:\n                curr_level -= 1\n        levels.append(max_level)\n\
    \    return levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split(' '):\n        current_max_level = 0\n        current_level\
    \ = 0\n        for c in s:\n            if c == '(':\n                current_level\
    \ += 1\n                current_max_level = max(current_max_level, current_level)\n\
    \            elif c == ')':\n                current_level -= 1\n        result.append(current_max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    list_of_parens = paren_string.split('\
    \ ')\n    list_of_parens = [x for x in list_of_parens if x]\n    count_list =\
    \ []\n    for val in list_of_parens:\n        count = 0\n        max_count = 0\n\
    \        for i in val:\n            if i == '(':\n                count += 1\n\
    \                if count > max_count:\n                    max_count = count\n\
    \            elif i == ')':\n                count -= 1\n        count_list.append(max_count)\n\
    \    return count_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_parens = [paren_string]\n\
    \    for letter in paren_string:\n        if letter == ' ':\n            parsed_parens.append('')\n\
    \        else:\n            parsed_parens[-1] += letter\n    return [len(paren)\
    \ - 2 * paren.count(')') for paren in parsed_parens]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpccpr1g2c.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpccpr1g2c.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpccpr1g2c.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split(' '):\n        prev_char = None\n        max_level\
    \ = 0\n        current_level = 0\n        for char in group:\n            if char\
    \ == '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                current_level\
    \ -= 1\n            prev_char = char\n        result.append(max_level)\n    return\
    \ result\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    depth\
    \ = 0\n    current_max = 0\n    for char in paren_string:\n        if char ==\
    \ '(':\n            depth += 1\n            current_max = max(current_max, depth)\n\
    \        elif char == ')':\n            depth -= 1\n        elif char == ' ':\n\
    \            result.append(current_max)\n            current_max = 0\n       \
    \     depth = 0\n    result.append(current_max)\n    return result\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_count = 0\n  \
    \  counts = []\n    for paren in paren_string.split(' '):\n        count = 0\n\
    \        for char in paren:\n            if char == '(':\n                count\
    \ += 1\n            elif char == ')':\n                if count > 0:\n       \
    \             count -= 1\n                else:\n                    raise ValueError('Invalid\
    \ input: closing parens before opening parens')\n            else:\n         \
    \       raise ValueError('Invalid input: invalid character')\n        if count\
    \ != 0:\n            raise ValueError('Invalid input: number of opening and closing\
    \ parens did not match')\n        counts.append(count)\n    return counts\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps9k06530.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmps9k06530.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps9k06530.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n\
    \    for group in paren_string.split(' '):\n        depth = 0\n        max_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth = max(max_depth, depth)\n          \
    \  elif char == ')':\n                depth -= 1\n        nested_levels.append(max_depth)\n\
    \    return nested_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    curr_paren_level = 0\n    max_paren_level = 0\n    result\
    \ = []\n\n    for char in paren_string:\n        if char == '(':\n           \
    \ curr_paren_level += 1\n            max_paren_level = max(max_paren_level, curr_paren_level)\n\
    \        elif char == ')':\n            curr_paren_level -= 1\n        elif char\
    \ == ' ':\n            result.append(max_paren_level)\n            max_paren_level\
    \ = 0\n            curr_paren_level = 0\n\n    result.append(max_paren_level)\n\
    \    return result\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ group in paren_string.split():\n        max_depth = 0\n        curr_depth =\
    \ 0\n        for char in group:\n            if char == '(':\n               \
    \ curr_depth += 1\n                max_depth = max(max_depth, curr_depth)\n  \
    \          elif char == ')':\n                curr_depth -= 1\n        res.append(max_depth)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  curr_depth = 0\n    result = []\n    for paren in paren_string:\n        if\
    \ paren == '(':\n            curr_depth += 1\n            max_depth = max(max_depth,\
    \ curr_depth)\n        elif paren == ')':\n            curr_depth -= 1\n     \
    \   elif paren == ' ':\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            curr_depth = 0\n    result.append(max_depth)\n    return result\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_depth = []\n    for group in groups:\n        depth = 0\n        max_depth_per_group\
    \ = 0\n        for c in group:\n            if c == '(':\n                depth\
    \ += 1\n                max_depth_per_group = max(max_depth_per_group, depth)\n\
    \            elif c == ')':\n                depth -= 1\n        max_depth.append(max_depth_per_group)\n\
    \    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [get_deepest_nesting(paren_group)\
    \ for paren_group in paren_string.split()]\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmln58cnc.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpmln58cnc.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmln58cnc.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpmln58cnc.py\", line 11, in parse_nested_parens\n\
    \    return [get_deepest_nesting(paren_group) for paren_group in paren_string.split()]\n\
    \  File \"/tmp/tmpmln58cnc.py\", line 11, in <listcomp>\n    return [get_deepest_nesting(paren_group)\
    \ for paren_group in paren_string.split()]\nNameError: name 'get_deepest_nesting'\
    \ is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [max_nested_parens(group) for group in paren_groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpan8yyxdr.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpan8yyxdr.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpan8yyxdr.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpan8yyxdr.py\", line 12, in parse_nested_parens\n\
    \    return [max_nested_parens(group) for group in paren_groups]\n  File \"/tmp/tmpan8yyxdr.py\"\
    , line 12, in <listcomp>\n    return [max_nested_parens(group) for group in paren_groups]\n\
    NameError: name 'max_nested_parens' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n\n    # Ensure that the paren_string is only made up of '(' and ')'\n\
    \    valid_parens = set('()')\n    if not all(paren in valid_parens for paren\
    \ in paren_string):\n        raise Exception('paren_string should only be made\
    \ up of \"(\" and \")\"')\n\n    max_depth = 0\n    current_depth = 0\n    for\
    \ paren in paren_string:\n        if paren == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif paren\
    \ == ')':\n            current_depth -= 1\n            if current_depth < 0:\n\
    \                # This means more ')' are present than '('\n                raise\
    \ Exception(\"Too many closing parentheses\")\n\n    if current_depth != 0:\n\
    \        # This means more '(' are present than ')'\n        raise Exception(\"\
    Too many opening parentheses\")\n\n    return max_depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwli3hoo5.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpwli3hoo5.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwli3hoo5.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  level = 0\n    result = []\n    for c in paren_string:\n        if c == '(':\n\
    \            level += 1\n            max_level = max(max_level, level)\n     \
    \   elif c == ')':\n            level -= 1\n        elif c == ' ':\n         \
    \   result.append(max_level)\n            max_level = 0\n            level = 0\n\
    \    result.append(max_level)\n    return result\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_chunk in paren_string.split():\n        if paren_chunk[0] != '(' or paren_chunk[-1]\
    \ != ')':\n            raise Exception(f'Input string must begin and end with\
    \ parentheses')\n        max_depth = 0\n        current_depth = 0\n        for\
    \ paren in paren_chunk:\n            if paren == '(':\n                current_depth\
    \ += 1\n                max_depth = max(max_depth, current_depth)\n          \
    \  elif paren == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    def get_max_depth(paren_substring: str) -> int:\n  \
    \      \"\"\" For a given nested paren substring (without any external space),\n\
    \        return the maximum depth of the nested parens.\n\n        >>> get_max_depth('(()())')\n\
    \        2\n        >>> get_max_depth('((()))')\n        3\n        >>> get_max_depth('()')\n\
    \        1\n        >>> get_max_depth('((())()())')\n        3\n        \"\"\"\
    \n        if not paren_substring:\n            return 0\n\n        max_depth =\
    \ 0\n        current_depth = 0\n        for c in paren_substring:\n          \
    \  if c == '(':\n                current_depth += 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            elif c == ')':\n              \
    \  current_depth -= 1\n            else:\n                raise ValueError(f'Invalid\
    \ input: {paren_substring}')\n\n        return max_depth\n\n    if ' ' not in\
    \ paren_string:\n        return [get_max_depth(paren_string)]\n\n    max_depth_list\
    \ = []\n    prev_idx = 0\n    for idx, c in enumerate(paren_string):\n       \
    \ if c == ' ':\n            max_depth_list.append(get_max_depth(paren_string[prev_idx:idx]))\n\
    \            prev_idx = idx + 1\n\n    max_depth_list.append(get_max_depth(paren_string[prev_idx:]))\n\
    \    return max_depth_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    max_nest\
    \ = 0\n    nest_level = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            nest_level += 1\n            max_nest = max(max_nest, nest_level)\n\
    \        elif char == ')':\n            nest_level -= 1\n        elif char ==\
    \ ' ':\n            output.append(max_nest)\n            max_nest = 0\n      \
    \      nest_level = 0\n    return output\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp628luxrv.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp628luxrv.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp628luxrv.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Create a splitter\
    \ which can parse the paren_string to a list of strings.\n    # The splitter uses\
    \ the space ` ` as delimiter.\n    splitter = re.compile(' ')\n    # Create a\
    \ scanner which can scan thru each character of a string.\n    scanner = Scanner(paren_string)\n\
    \    # scanner.find_token returns a tuple of (matching string, starting position,\
    \ ending position)\n    # If there is no match it returns None\n    # Here we\
    \ are looking for spaces as well as patterns.\n    # If we find a space, the scanner\
    \ will not advance by itself.\n    # If we find a pattern, the scanner will advance.\n\
    \    # If the scanner does not advance, it needs an explicit advance.\n    # We\
    \ know that we are at the end of the string if scanner.find_token(splitter) is\
    \ None\n    res = []\n    while scanner.find_token(splitter) is not None:\n  \
    \      # If we find a space, advance the scanner.\n        if scanner.match ==\
    \ ' ':\n            scanner.advance()\n        # If we find a pattern, store the\
    \ pattern in a variable.\n        if scanner.match != ' ':\n            paren_string\
    \ = scanner.match\n        # Initialize a variable to store the level of nesting.\n\
    \        level = 0\n        # Initialize a variable to store the max level of\
    \ nesting.\n        max_level = 0\n        # For each character in the pattern\n\
    \        for char in paren_string:\n            # If it is an opening parenthesis\n\
    \            if char == '(':\n                # Increase the level of nesting\
    \ by 1\n                level += 1\n                # If the level of nesting\
    \ exceeds the max level of nesting\n                if level > max_level:\n  \
    \                  # Increase the max level of nesting by 1\n                \
    \    max_level += 1\n            # If it is a closing parenthesis\n          \
    \  if char == ')':\n                # Decrease the level of nesting by 1\n   \
    \             level -= 1\n        # After the for loop, append the max level of\
    \ nesting to the result list.\n        res.append(max_level)\n    return res\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7vjkkgn9.py\", line\
    \ 60, in <module>\n    test_check()\n  File \"/tmp/tmp7vjkkgn9.py\", line 58,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7vjkkgn9.py\"\
    , line 53, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp7vjkkgn9.py\", line 13, in parse_nested_parens\n\
    \    splitter = re.compile(' ')\nNameError: name 're' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    results = []\n    for group in groups:\n        group_depth = 0\n       \
    \ group_max_depth = 0\n        for symbol in group:\n            if symbol ==\
    \ '(':\n                group_depth += 1\n                group_max_depth = max(group_max_depth,\
    \ group_depth)\n            elif symbol == ')':\n                group_depth -=\
    \ 1\n        results.append(group_max_depth)\n    return results\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp68064fuq.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp68064fuq.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp68064fuq.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_string = paren_string.split('\
    \ ')\n    output = []\n    for group in parsed_string:\n        curr_max = 0\n\
    \        curr_level = 0\n        for char in group:\n            if char == '(':\n\
    \                curr_level += 1\n                curr_max = max(curr_max, curr_level)\n\
    \            elif char == ')':\n                curr_level -= 1\n        output.append(curr_max)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO\n    pass\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnt3i9sp7.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpnt3i9sp7.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnt3i9sp7.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # paren_string = input()\n\
    \    paren_string = paren_string.split()\n    max_paren_level = []\n    for sub_string\
    \ in paren_string:\n        # print(sub_string)\n        nesting_depth = 0\n \
    \       max_depth = 0\n        for char in sub_string:\n            if char ==\
    \ '(':\n                nesting_depth += 1\n                max_depth = max(max_depth,\
    \ nesting_depth)\n            elif char == ')':\n                nesting_depth\
    \ -= 1\n        max_paren_level.append(max_depth)\n    return max_paren_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    max_levels = []\n    for group in paren_groups:\n        count = 0\n\
    \        max_count = 0\n        for char in group:\n            if char == '(':\n\
    \                count += 1\n                max_count = max(max_count, count)\n\
    \            elif char == ')':\n                count -= 1\n        max_levels.append(max_count)\n\
    \    return max_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    output\
    \ = []\n    max_depth = 0\n    for i in paren_string:\n        if i == '(':\n\
    \            stack.append(i)\n            max_depth = max(max_depth, len(stack))\n\
    \        elif i == ')':\n            stack.pop()\n        elif i == ' ':\n   \
    \         output.append(max_depth)\n            max_depth = 0\n    output.append(max_depth)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\
    \    for group in paren_string.split():\n        current_paren_group = []\n  \
    \      current_level = 0\n        max_level = 0\n        for char in group:\n\
    \            if char == '(':\n                current_level += 1\n           \
    \     max_level = max(max_level, current_level)\n            elif char == ')':\n\
    \                current_level -= 1\n        nested_parens.append(max_level)\n\
    \    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_level\
    \ = []\n\n    for group in paren_string.split(' '):\n        if group == '':\n\
    \            max_nesting_level.append(0)\n            continue\n\n        curr_nesting_level\
    \ = 0\n        max_nesting_level_for_group = 0\n\n        for ch in group:\n \
    \           if ch == '(':\n                curr_nesting_level += 1\n         \
    \       max_nesting_level_for_group = max(max_nesting_level_for_group, curr_nesting_level)\n\
    \            elif ch == ')':\n                curr_nesting_level -= 1\n\n    \
    \    max_nesting_level.append(max_nesting_level_for_group)\n\n    return max_nesting_level\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split():\n        max_nesting = 0\n        current_nesting\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   current_nesting += 1\n                max_nesting = max(max_nesting, current_nesting)\n\
    \            elif char == ')':\n                current_nesting -= 1\n       \
    \ result.append(max_nesting)\n    return result\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_lst =\
    \ []\n    for group in paren_string.split(' '):\n        max_nesting = 0\n   \
    \     current_nesting = 0\n        for char in group:\n            if char ==\
    \ '(':\n                current_nesting += 1\n                max_nesting = max(max_nesting,\
    \ current_nesting)\n            elif char == ')':\n                current_nesting\
    \ -= 1\n        max_nesting_lst.append(max_nesting)\n    return max_nesting_lst\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    max_depth = []\n    for idx, paren in enumerate(paren_list):\n        paren_depth\
    \ = []\n        curr_depth = 0\n        for idx, paren_idx in enumerate(paren):\n\
    \            if paren_idx == '(':\n                curr_depth += 1\n         \
    \   else:\n                curr_depth -= 1\n            paren_depth.append(curr_depth)\n\
    \        max_depth.append(max(paren_depth))\n    return max_depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    return [paren_level(g) for g in groups]\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptdfd_u6e.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmptdfd_u6e.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptdfd_u6e.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmptdfd_u6e.py\", line 12, in parse_nested_parens\n\
    \    return [paren_level(g) for g in groups]\n  File \"/tmp/tmptdfd_u6e.py\",\
    \ line 12, in <listcomp>\n    return [paren_level(g) for g in groups]\nNameError:\
    \ name 'paren_level' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\
    \    for group in paren_string.split(' '):\n        max_level = 0\n        level\
    \ = 0\n        for i in range(len(group)):\n            if group[i] == '(':\n\
    \                level += 1\n                max_level = max(max_level, level)\n\
    \            else:\n                level -= 1\n        nested_parens.append(max_level)\n\
    \    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    depths = []\n    in_space = False\n    for paren in\
    \ paren_string:\n        if paren == ' ':\n            in_space = True\n     \
    \       continue\n        elif paren == '(':\n            current_depth += 1\n\
    \            max_depth = max(max_depth, current_depth)\n        elif paren ==\
    \ ')':\n            if current_depth == 0:\n                raise Exception('Invalid\
    \ input, too many closing parentheses')\n            current_depth -= 1\n    \
    \    else:\n            raise Exception('Invalid character in input')\n      \
    \  if in_space:\n            depths.append(max_depth)\n            max_depth =\
    \ 0\n            current_depth = 0\n            in_space = False\n    if not in_space:\n\
    \        depths.append(max_depth)\n    return depths\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpydlra090.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmpydlra090.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpydlra090.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpydlra090.py\", line 24, in parse_nested_parens\n\
    \    raise Exception('Invalid input, too many closing parentheses')\nException:\
    \ Invalid input, too many closing parentheses\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize an integer\
    \ to keep track of the maximum depth of nesting.\n    max_depth = 0\n    # Initialize\
    \ an integer to keep track of the current depth of nesting.\n    current_depth\
    \ = 0\n    # Initialize a list to keep track of the maximum depth of nesting for\
    \ each group of parentheses.\n    max_depths = []\n    # For each character in\
    \ the string,\n    for char in paren_string:\n        # If it is an opening parenthesis,\
    \ add one to the current depth.\n        if char == '(':\n            current_depth\
    \ += 1\n        # If it is a closing parenthesis, subtract one from the current\
    \ depth.\n        elif char == ')':\n            current_depth -= 1\n        #\
    \ If it is a space, add the current depth to the list of maximum depths and reset\
    \ current depth.\n        if char == ' ':\n            max_depths.append(current_depth)\n\
    \            current_depth = 0\n    # Add the current depth to the list of maximum\
    \ depths and reset current depth.\n    max_depths.append(current_depth)\n    current_depth\
    \ = 0\n    # Return the list of maximum depths.\n    return max_depths\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_gioben7.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmp_gioben7.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_gioben7.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split(' '):\n        max_nesting = 0\n        nesting = 0\n\
    \        for c in s:\n            if c == '(':\n                nesting += 1\n\
    \                max_nesting = max(max_nesting, nesting)\n            elif c ==\
    \ ')':\n                nesting -= 1\n        result.append(max_nesting)\n   \
    \ return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ paren_group in paren_string.split():\n        current_max = 0\n        max_so_far\
    \ = 0\n        for char in paren_group:\n            if char == '(':\n       \
    \         current_max += 1\n                max_so_far = max(max_so_far, current_max)\n\
    \            elif char == ')':\n                current_max -= 1\n        output.append(max_so_far)\n\
    \    return output\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: "[2, 3, 1, 3]\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  depth = 0\n    result = []\n    for char in paren_string:\n        if char\
    \ == '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        elif char == ')':\n            depth -= 1\n        elif char == ' ':\n\
    \            result.append(max_depth)\n            max_depth = 0\n           \
    \ depth = 0\n    result.append(max_depth)\n    return result\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_counts = []\n\n\
    \    for group in paren_string.split(' '):\n        max_counts.append(helper(group))\n\
    \n    return max_counts\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpba6gsmct.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpba6gsmct.py\", line 24,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpba6gsmct.py\"\
    , line 19, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpba6gsmct.py\", line 14, in parse_nested_parens\n\
    \    max_counts.append(helper(group))\nNameError: name 'helper' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: consider removing\
    \ the need to trim the parenthesis\n    return [get_max_nested_parens(x) for x\
    \ in paren_string.split(' ')]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptb9gpplt.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmptb9gpplt.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptb9gpplt.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmptb9gpplt.py\", line 12, in parse_nested_parens\n\
    \    return [get_max_nested_parens(x) for x in paren_string.split(' ')]\n  File\
    \ \"/tmp/tmptb9gpplt.py\", line 12, in <listcomp>\n    return [get_max_nested_parens(x)\
    \ for x in paren_string.split(' ')]\nNameError: name 'get_max_nested_parens' is\
    \ not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_levels = []\n\
    \    for paren_group in paren_string.split(' '):\n        # Using stack we will\
    \ iterate through each parenthesis group to figure out the maximum\n        #\
    \ number of nested levels within it.\n        stack = []\n        max_level =\
    \ 0\n        for paren in paren_group:\n            if paren == '(':\n       \
    \         stack.append(paren)\n                max_level = max(max_level, len(stack))\n\
    \            elif paren == ')':\n                stack.pop()\n        max_levels.append(max_level)\n\
    \    return max_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ string in paren_string.split():\n        level = 0\n        max_level = 0\n\
    \        for c in string:\n            if c == '(':\n                level +=\
    \ 1\n                max_level = max(max_level, level)\n            elif c ==\
    \ ')':\n                level -= 1\n        result.append(max_level)\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n\
    \        for c in s:\n            if c == '(':\n                current_depth\
    \ += 1\n                max_depth = max(max_depth, current_depth)\n          \
    \  elif c == ')':\n                current_depth -= 1\n        result.append(max_depth)\n\
    \    return result\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split():\n        stack = []\n        max_depth = 0\n\
    \        for symbol in parens:\n            if symbol == '(':\n              \
    \  stack.append(symbol)\n                max_depth = max(max_depth, len(stack))\n\
    \            elif symbol == ')':\n                if stack and stack[-1] == '(':\n\
    \                    stack.pop()\n                else:\n                    break\n\
    \        else:\n            result.append(max_depth)\n    return result\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ group in paren_string.split(' '):\n        max_depth = 0\n        depth = 0\n\
    \        for char in group:\n            if char == '(':\n                depth\
    \ += 1\n                max_depth = max(max_depth, depth)\n            else:\n\
    \                depth -= 1\n        output.append(max_depth)\n    return output\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    return [parse_nested_parens_single(group) for group in paren_groups]\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdysae__v.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpdysae__v.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdysae__v.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpdysae__v.py\", line 12, in parse_nested_parens\n\
    \    return [parse_nested_parens_single(group) for group in paren_groups]\n  File\
    \ \"/tmp/tmpdysae__v.py\", line 12, in <listcomp>\n    return [parse_nested_parens_single(group)\
    \ for group in paren_groups]\nNameError: name 'parse_nested_parens_single' is\
    \ not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        depth = 0\n        max_depth = 0\n\
    \        for ch in parens:\n            if ch == '(':\n                depth +=\
    \ 1\n                max_depth = max(max_depth, depth)\n            else:\n  \
    \              depth -= 1\n        result.append(max_depth)\n    return result\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split('\
    \ ')\n    res = [0] * len(nested_parens)\n    for i, parens in enumerate(nested_parens):\n\
    \        level = 0\n        for char in parens:\n            if char == '(':\n\
    \                level += 1\n            else:\n                res[i] = max(res[i],\
    \ level)\n                level -= 1\n    return res\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nested_parens\
    \ = []\n    for paren_group in paren_string.split(' '):\n        current_level\
    \ = 0\n        max_level = 0\n        for paren in paren_group:\n            if\
    \ paren == '(':\n                current_level += 1\n                max_level\
    \ = max(max_level, current_level)\n            elif paren == ')':\n          \
    \      current_level -= 1\n            else:\n                raise ValueError(f'{paren}\
    \ is not a valid parenthesis character.')\n        max_nested_parens.append(max_level)\n\
    \    return max_nested_parens\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split(' '):\n        level = 0\n        max_level = 0\n\
    \        for paren in group:\n            if paren == '(':\n                level\
    \ += 1\n                max_level = max(max_level, level)\n            elif paren\
    \ == ')':\n                level -= 1\n        result.append(max_level)\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = [group.strip()\
    \ for group in paren_string.split(' ')]\n    return [max_nesting(group) for group\
    \ in groups]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqqlz18ee.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpqqlz18ee.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqqlz18ee.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqqlz18ee.py\", line 12, in parse_nested_parens\n\
    \    return [max_nesting(group) for group in groups]\n  File \"/tmp/tmpqqlz18ee.py\"\
    , line 12, in <listcomp>\n    return [max_nesting(group) for group in groups]\n\
    NameError: name 'max_nesting' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Splitting the string\
    \ into groups of parentheses\n    groups = paren_string.split(' ')\n    # The\
    \ output list\n    output = []\n    # For each of the group, call helper function\
    \ with state variable max_depth\n    for g in groups:\n        max_depth = 0\n\
    \        helper(g, 0, 0, max_depth, output)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfsunf9x5.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpfsunf9x5.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfsunf9x5.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfsunf9x5.py\", line 18, in parse_nested_parens\n\
    \    helper(g, 0, 0, max_depth, output)\nNameError: name 'helper' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # First, split the\
    \ string into groups of parens\n    paren_groups = paren_string.split(' ')\n \
    \   # Maintain a stack of parenthesis\n    stack = []\n    # Then, for each group,\
    \ iterate through the parens, and output the max height of parenthesis\n    #\
    \ If we encounter an open paren, increment the stack height\n    # If we encounter\
    \ a closed paren, decrement the stack height and output the max height of the\
    \ stack\n    # TODO:\n    return [1]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcvgivpmw.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpcvgivpmw.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcvgivpmw.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ paren_group in paren_string.split(' '):\n        level = 0\n        max_level\
    \ = 0\n        for ch in paren_group:\n            if ch == '(':\n           \
    \     level += 1\n                max_level = max(max_level, level)\n        \
    \    elif ch == ')':\n                level -= 1\n        output.append(max_level)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split()\n\
    \    max_level_of_nesting = []\n    for group in group_list:\n        max_level\
    \ = 0\n        current_level = 0\n        for c in group:\n            if c ==\
    \ '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif c == ')':\n                current_level -=\
    \ 1\n        max_level_of_nesting.append(max_level)\n    return max_level_of_nesting\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        level = 0\n        maximum_level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           level += 1\n                maximum_level = max(maximum_level, level)\n\
    \            elif paren == ')':\n                level -= 1\n            else:\n\
    \                raise ValueError(f'{paren} is not a parenthesis')\n        result.append(maximum_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n\n  \
    \  for paren_group in paren_string.split():\n        curr_level = 0\n        max_level\
    \ = 0\n\n        for paren in paren_group:\n            if paren == '(':\n   \
    \             curr_level += 1\n                max_level = max(max_level, curr_level)\n\
    \            elif paren == ')':\n                curr_level -= 1\n\n        levels.append(max_level)\n\
    \n    return levels\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ item in paren_string.split():\n        stack = []\n        curr_max = 0\n  \
    \      for c in item:\n            if c == '(':\n                stack.append(c)\n\
    \                curr_max = max(curr_max, len(stack))\n            elif c == ')':\n\
    \                stack.pop()\n        result.append(curr_max)\n    return result\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_level\
    \ = []\n    curr_nesting_level = 0\n    for paren in paren_string:\n        if\
    \ paren == '(':\n            curr_nesting_level += 1\n        elif paren == ')':\n\
    \            max_nesting_level.append(curr_nesting_level)\n            curr_nesting_level\
    \ -= 1\n        elif paren == ' ':\n            continue\n    return max_nesting_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6id3zr7c.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp6id3zr7c.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6id3zr7c.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ paren_group in paren_string.split(' '):\n        output.append(parse_paren_group(paren_group))\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpj4dej2f5.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpj4dej2f5.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpj4dej2f5.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpj4dej2f5.py\", line 13, in parse_nested_parens\n\
    \    output.append(parse_paren_group(paren_group))\nNameError: name 'parse_paren_group'\
    \ is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def find_nesting_level(curr_level,\
    \ curr_string, curr_index):\n        if curr_index == len(curr_string):\n    \
    \        return curr_level\n\n        if curr_string[curr_index] == '(':\n   \
    \         return find_nesting_level(curr_level + 1, curr_string, curr_index +\
    \ 1)\n        elif curr_string[curr_index] == ')':\n            return find_nesting_level(curr_level\
    \ - 1, curr_string, curr_index + 1)\n        else:\n            raise ValueError('String\
    \ can only contain \\'(\\' and \\')\\'')\n\n    res = []\n    for curr_paren_string\
    \ in paren_string.split(' '):\n        res.append(find_nesting_level(0, curr_paren_string,\
    \ 0))\n\n    return res\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcm9qrq9d.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpcm9qrq9d.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcm9qrq9d.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    num_groups = len(groups)\n    res = [0] * num_groups\n    for i in range(num_groups):\n\
    \        max_count = 0\n        count = 0\n        for c in groups[i]:\n     \
    \       if c == '(':\n                count += 1\n                max_count =\
    \ max(max_count, count)\n            else:\n                count -= 1\n     \
    \   res[i] = max_count\n    return res\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    ans = []\n    for group in paren_groups:\n        level = 0\n        max_level\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     level += 1\n                max_level = max(max_level, level)\n        \
    \    elif paren == ')':\n                level -= 1\n        ans.append(max_level)\n\
    \    return ans\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    output = []\n    for group in paren_groups:\n        count = 0\n        max_count\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     count += 1\n                max_count = max(max_count, count)\n        \
    \    elif paren == ')':\n                count -= 1\n        output.append(max_count)\n\
    \    return output\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: "[2, 3, 1, 3]\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    space_splitted = paren_string.split('\
    \ ')\n    ans = [0] * len(space_splitted)\n    for i, paren_str in enumerate(space_splitted):\n\
    \        stack = []\n        curr_max = 0\n        for paren in paren_str:\n \
    \           if paren == '(':\n                stack.append(paren)\n          \
    \      curr_max += 1\n            elif paren == ')':\n                stack.pop()\n\
    \                curr_max -= 1\n            ans[i] = max(ans[i], curr_max)\n \
    \   return ans\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  curr_level = 0\n    result = []\n    for char in paren_string:\n        if\
    \ char == '(':\n            curr_level += 1\n            max_level = max(max_level,\
    \ curr_level)\n        elif char == ')':\n            curr_level -= 1\n      \
    \  elif char == ' ':\n            result.append(max_level)\n            max_level\
    \ = 0\n            curr_level = 0\n    result.append(max_level)\n    return result\n\
    \nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: "[2, 3, 1, 3]\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    depth_levels\
    \ = []\n    for paren in paren_string:\n        if paren == '(':\n           \
    \ depth += 1\n        elif paren == ')':\n            depth_levels.append(depth)\n\
    \            depth -= 1\n    return depth_levels\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbuq84lb1.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpbuq84lb1.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbuq84lb1.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_levels\
    \ = []\n    for sub_string in paren_string.split():\n        max_nesting_levels.append(find_max_nesting_level(sub_string))\n\
    \    return max_nesting_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpknuv3b8t.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpknuv3b8t.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpknuv3b8t.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpknuv3b8t.py\", line 13, in parse_nested_parens\n\
    \    max_nesting_levels.append(find_max_nesting_level(sub_string))\nNameError:\
    \ name 'find_max_nesting_level' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    split_paren_string\
    \ = paren_string.split(' ')\n    max_depth = []\n    for paren in split_paren_string:\n\
    \        if paren[0] != '(' or paren[-1] != ')':\n            raise ValueError('Invalid\
    \ parentheses')\n        max_depth.append(find_depth(paren))\n    return max_depth\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9j9ckq4v.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmp9j9ckq4v.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9j9ckq4v.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp9j9ckq4v.py\", line 16, in parse_nested_parens\n\
    \    max_depth.append(find_depth(paren))\nNameError: name 'find_depth' is not\
    \ defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    max_depth_list = []\n    max_depth = 0\n    open_parens\
    \ = 0\n    for symbol in paren_string:\n        if symbol == '(':\n          \
    \  open_parens += 1\n            max_depth = max(max_depth, open_parens)\n   \
    \     elif symbol == ')':\n            open_parens -= 1\n        elif symbol ==\
    \ ' ':\n            max_depth_list.append(max_depth)\n            max_depth =\
    \ 0\n            open_parens = 0\n    max_depth_list.append(max_depth)\n    return\
    \ max_depth_list\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  curr_depth = 0\n    output = []\n    for char in paren_string:\n        if\
    \ char == '(':\n            curr_depth += 1\n            max_depth = max(max_depth,\
    \ curr_depth)\n        elif char == ')':\n            curr_depth -= 1\n      \
    \  elif char == ' ':\n            output.append(max_depth)\n            max_depth\
    \ = 0\n            curr_depth = 0\n    return output\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptv44adve.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmptv44adve.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptv44adve.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split()\n\
    \    max_level_list = []\n    for group in group_list:\n        max_level = 0\n\
    \        current_level = 0\n        for paren in group:\n            if paren\
    \ == '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif paren == ')':\n                current_level\
    \ -= 1\n        max_level_list.append(max_level)\n    return max_level_list\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    return [group_nesting_level(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplzm6qag2.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmplzm6qag2.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplzm6qag2.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmplzm6qag2.py\", line 12, in parse_nested_parens\n\
    \    return [group_nesting_level(group) for group in groups]\n  File \"/tmp/tmplzm6qag2.py\"\
    , line 12, in <listcomp>\n    return [group_nesting_level(group) for group in\
    \ groups]\nNameError: name 'group_nesting_level' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    if\
    \ not paren_string:\n        return output\n    parenthesis_stack = []\n    for\
    \ char in paren_string:\n        if char == \"(\":\n            parenthesis_stack.append(char)\n\
    \        elif char == \")\":\n            if parenthesis_stack and parenthesis_stack[-1]\
    \ == \"(\":\n                parenthesis_stack.pop()\n            else:\n    \
    \            # return False\n                raise ValueError(\"Invalid parenthesis\
    \ format\")\n        else:\n            if not parenthesis_stack:\n          \
    \      output.append(len(parenthesis_stack))\n                parenthesis_stack\
    \ = []\n    return output\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpivl36b2q.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpivl36b2q.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpivl36b2q.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_levels = []\n\
    \    for group in paren_string.split(' '):\n        nested_level = 0\n       \
    \ max_nested_level = 0\n        for char in group:\n            if char == '(':\n\
    \                nested_level += 1\n                max_nested_level = max(max_nested_level,\
    \ nested_level)\n            elif char == ')':\n                nested_level -=\
    \ 1\n        max_levels.append(max_nested_level)\n    return max_levels\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    current_depth = 0\n\
    \    max_depth = 0\n    outputs = []\n    for char in paren_string:\n        if\
    \ char == '(':\n            current_depth += 1\n            max_depth = max(max_depth,\
    \ current_depth)\n        elif char == ')':\n            current_depth -= 1\n\
    \        elif char == ' ':\n            outputs.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n    outputs.append(max_depth)\n\
    \    return outputs\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth_list = []\n\
    \    group_depth = 0\n    max_depth = 0\n    for char in paren_string:\n     \
    \   if char == '(':\n            group_depth += 1\n            max_depth = max(max_depth,\
    \ group_depth)\n        elif char == ')':\n            group_depth -= 1\n    \
    \    elif char == ' ':\n            max_depth_list.append(max_depth)\n       \
    \     max_depth = 0\n            group_depth = 0\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9upbnw80.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp9upbnw80.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9upbnw80.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_group = paren_string.split()\n\
    \    result = []\n    for paren in paren_group:\n        if paren[0] != '(' or\
    \ paren[-1] != ')':\n            raise ValueError('Invalid input')\n        else:\n\
    \            max_nesting = 0\n            current_nesting = 0\n            for\
    \ c in paren:\n                if c == '(':\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                elif c == ')':\n                    current_nesting -= 1\n  \
    \          result.append(max_nesting)\n    return result\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [parse_single_paren_group(group) for group in paren_groups]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo2xj766c.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpo2xj766c.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo2xj766c.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpo2xj766c.py\", line 12, in parse_nested_parens\n\
    \    return [parse_single_paren_group(group) for group in paren_groups]\n  File\
    \ \"/tmp/tmpo2xj766c.py\", line 12, in <listcomp>\n    return [parse_single_paren_group(group)\
    \ for group in paren_groups]\nNameError: name 'parse_single_paren_group' is not\
    \ defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    depths = []\n    for letter in paren_string:\n     \
    \   if letter == '(':\n            current_depth += 1\n            max_depth =\
    \ max(max_depth, current_depth)\n        elif letter == ')':\n            current_depth\
    \ -= 1\n        elif letter == ' ':\n            depths.append(max_depth)\n  \
    \          max_depth = 0\n            current_depth = 0\n    depths.append(max_depth)\n\
    \    return depths\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    depth = []\n    for group in groups:\n        if group == '':\n    \
    \        depth.append(0)\n        else:\n            left = 0\n            right\
    \ = 0\n            for ch in group:\n                if ch == '(':\n         \
    \           left += 1\n                elif ch == ')':\n                    right\
    \ += 1\n                if right > left:\n                    break\n        \
    \    if left == right:\n                depth.append(left)\n            else:\n\
    \                depth.append(0)\n    return depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptghhq4oe.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmptghhq4oe.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptghhq4oe.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    parsed_groups = []\n    for group in groups:\n        parsed_groups.append(parse_group(group))\n\
    \    return parsed_groups\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxof2ajfv.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpxof2ajfv.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxof2ajfv.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpxof2ajfv.py\", line 14, in parse_nested_parens\n\
    \    parsed_groups.append(parse_group(group))\nNameError: name 'parse_group' is\
    \ not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Write your code\
    \ here!\n    max_depth = 0\n    curr_depth = 0\n    max_depths = []\n    for c\
    \ in paren_string:\n        if c == '(':\n            curr_depth += 1\n      \
    \      max_depth = max(max_depth, curr_depth)\n        elif c == ')':\n      \
    \      curr_depth -= 1\n        elif c == ' ':\n            max_depths.append(max_depth)\n\
    \            max_depth = 0\n            curr_depth = 0\n    max_depths.append(max_depth)\n\
    \    return max_depths\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def helper(paren_string:\
    \ str) -> int:\n        \"\"\" Input to this function is a string of parentheses.\n\
    \        Output is the deepest level of nesting of parentheses.\n        \"\"\"\
    \n        max_depth = 0\n        depth = 0\n        for i in paren_string:\n \
    \           if i == '(':\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            elif i == ')':\n                depth -=\
    \ 1\n        return max_depth\n\n    return [helper(paren) for paren in paren_string.split()]\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_levels = []\n\
    \    for group in paren_string.split(' '):\n        level = 0\n        max_level\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   level += 1\n                max_level = max(max_level, level)\n          \
    \  elif char == ')':\n                level -= 1\n        max_levels.append(max_level)\n\
    \    return max_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    count = []\n    temp_count\
    \ = 0\n    for paren in paren_string:\n        if paren == '(':\n            temp_count\
    \ += 1\n        elif paren == ')':\n            count.append(temp_count)\n   \
    \         temp_count -= 1\n    return count\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmgmlizbw.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpmgmlizbw.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmgmlizbw.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # remove the spaces\
    \ from the input string\n    paren_string = paren_string.replace(' ', '')\n  \
    \  # initialize the result list and a counter to keep track of nested levels\n\
    \    res = []\n    count = 0\n    # Iterate over the input string\n    for char\
    \ in paren_string:\n        # If the char is '(', increment the counter\n    \
    \    if char == '(':\n            count += 1\n        # If the char is ')', decrement\
    \ the counter\n        elif char == ')':\n            count -= 1\n        # If\
    \ we reach zero and the current char is ')', append the nested level count\n \
    \       if count == 0 and char == ')':\n            res.append(count)\n      \
    \  # If we reach zero and the current char is '(', start a new nested level count\n\
    \        elif count == 0 and char == '(':\n            count = 1\n    return res\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe9nnp0e0.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpe9nnp0e0.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpe9nnp0e0.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # YOUR CODE HERE\n\
    \    list1 = []\n    max_value = 0\n    for i in paren_string.split(' '):\n  \
    \      max_value = 0\n        for j in i:\n            if j == '(':\n        \
    \        max_value += 1\n            elif j == ')':\n                max_value\
    \ -= 1\n        list1.append(max_value)\n    return list1\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp66ku58jn.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp66ku58jn.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp66ku58jn.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    split_groups = paren_string.split('\
    \ ')\n    ret = []\n    for group in split_groups:\n        num_left_paren = 0\n\
    \        num_right_paren = 0\n        for char in group:\n            if char\
    \ == '(':\n                num_left_paren += 1\n            elif char == ')':\n\
    \                num_right_paren += 1\n            if num_right_paren > num_left_paren:\n\
    \                raise ValueError(\"Invalid input string.\")\n        ret.append(num_left_paren)\n\
    \    return ret\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgxefcac_.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpgxefcac_.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgxefcac_.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    current_level\
    \ = 0\n    for item in paren_string:\n        if item == '(':\n            current_level\
    \ += 1\n        elif item == ')':\n            levels.append(current_level)\n\
    \            current_level -= 1\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzbz9lt4b.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpzbz9lt4b.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzbz9lt4b.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Remove all characters\
    \ in paren_string except parentheses.\n    paren_string = re.sub('[^()]', '',\
    \ paren_string)\n    parsed_parens = []\n    while paren_string:\n        max_idx\
    \ = 0\n        # Find the index of the closing parenthesis that has the longest\n\
    \        # valid prefix of opening parentheses.\n        for i in range(len(paren_string)):\n\
    \            if paren_string[i] == ')':\n                if max_idx == 0:\n  \
    \                  max_idx = i\n                elif paren_string[:i].count('(')\
    \ > paren_string[:max_idx].count('('):\n                    max_idx = i\n    \
    \    # Calculate the depth of nesting for the longest valid prefix.\n        parsed_parens.append(paren_string[:max_idx].count('('))\n\
    \        # Remove the prefix.\n        paren_string = paren_string[max_idx + 1:]\n\
    \    return parsed_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe02fuoy8.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpe02fuoy8.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpe02fuoy8.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpe02fuoy8.py\", line 12, in parse_nested_parens\n\
    \    paren_string = re.sub('[^()]', '', paren_string)\nNameError: name 're' is\
    \ not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_string = []\n\
    \    for paren in paren_string.split():\n        stack = []\n        max_stack\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   stack.append(char)\n                max_stack = max(max_stack, len(stack))\n\
    \            elif char == ')':\n                stack.pop()\n        parsed_string.append(max_stack)\n\
    \    return parsed_string\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    return [get_max_level(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn6dwaci_.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpn6dwaci_.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn6dwaci_.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpn6dwaci_.py\", line 12, in parse_nested_parens\n\
    \    return [get_max_level(group) for group in groups]\n  File \"/tmp/tmpn6dwaci_.py\"\
    , line 12, in <listcomp>\n    return [get_max_level(group) for group in groups]\n\
    NameError: name 'get_max_level' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_levels\
    \ = []\n    split_groups = paren_string.split()\n    for group in split_groups:\n\
    \        max_nesting_levels.append(calculate_nesting_levels(group))\n    return\
    \ max_nesting_levels\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppwjxizfg.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmppwjxizfg.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppwjxizfg.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmppwjxizfg.py\", line 14, in parse_nested_parens\n\
    \    max_nesting_levels.append(calculate_nesting_levels(group))\nNameError: name\
    \ 'calculate_nesting_levels' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ group in paren_string.split():\n        max_level = 0\n        current_level\
    \ = 0\n        for c in group:\n            if c == '(':\n                current_level\
    \ += 1\n                max_level = max(max_level, current_level)\n          \
    \  elif c == ')':\n                current_level -= 1\n        result.append(max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [get_depth(group) for group in paren_groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp136frtim.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp136frtim.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp136frtim.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp136frtim.py\", line 12, in parse_nested_parens\n\
    \    return [get_depth(group) for group in paren_groups]\n  File \"/tmp/tmp136frtim.py\"\
    , line 12, in <listcomp>\n    return [get_depth(group) for group in paren_groups]\n\
    NameError: name 'get_depth' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split('\
    \ ')\n    result = []\n    for group in group_list:\n        counter = 0\n   \
    \     max_counter = 0\n        for c in group:\n            if c == '(':\n   \
    \             counter += 1\n                max_counter = max(max_counter, counter)\n\
    \            elif c == ')':\n                counter -= 1\n        result.append(max_counter)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split('\
    \ ')\n    result = []\n    for group in group_list:\n        current_max = 0\n\
    \        current_max_depth = 0\n        for char in group:\n            if char\
    \ == '(':\n                current_max_depth += 1\n                current_max\
    \ = max(current_max, current_max_depth)\n            elif char == ')':\n     \
    \           current_max_depth -= 1\n        result.append(current_max)\n    return\
    \ result\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    split_strings = paren_string.split()\n\
    \    return [parse_single_nested_parens(x) for x in split_strings]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr0hdqs_9.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpr0hdqs_9.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr0hdqs_9.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpr0hdqs_9.py\", line 12, in parse_nested_parens\n\
    \    return [parse_single_nested_parens(x) for x in split_strings]\n  File \"\
    /tmp/tmpr0hdqs_9.py\", line 12, in <listcomp>\n    return [parse_single_nested_parens(x)\
    \ for x in split_strings]\nNameError: name 'parse_single_nested_parens' is not\
    \ defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    depth_list = []\n    for group in paren_groups:\n        max_depth = 0\n\
    \        depth = 0\n        for char in group:\n            if char == '(':\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        depth_list.append(max_depth)\n\
    \    return depth_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def helper(paren_string:\
    \ str) -> int:\n        \"\"\" Helper function to parse one group of nested parentheses\n\
    \        >>> helper('(()())')\n        2\n        >>> helper('()')\n        1\n\
    \        >>> helper('((())()())')\n        3\n        \"\"\"\n        # calculate\
    \ the number of levels of nesting for the current group.\n        # for every\
    \ opening paren, increment level.\n        # for every closing paren, decrement\
    \ level.\n        level = 0\n        max_level = 0\n        for c in paren_string:\n\
    \            if c == '(':\n                level += 1\n            elif c == ')':\n\
    \                level -= 1\n            if level > max_level:\n             \
    \   max_level = level\n        return max_level\n\n    # split the input string\
    \ into multiple groups\n    group_list = paren_string.split(' ')\n    return [helper(group)\
    \ for group in group_list]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split paren_string\
    \ into individual groups separated by spaces.\n    # Use list comprehension.\n\
    \    paren_groups = [groups for groups in paren_string.split(' ')]\n\n    # Iterate\
    \ over each paren group to count its nested parens.\n    # Create a new list to\
    \ store the output.\n    nested_parens = []\n    for paren_group in paren_groups:\n\
    \        # Initialize a counter to count the number of nested parens.\n      \
    \  # Initialize a variable to store the maximum level of nested parens.\n    \
    \    paren_counter = 0\n        max_nested_parens = 0\n\n        # Use a for loop\
    \ to iterate over each character in the paren group.\n        for char in paren_group:\n\
    \            # Increment paren_counter by 1 when there is an opening paren.\n\
    \            if char == '(':\n                paren_counter += 1\n           \
    \     max_nested_parens = max(max_nested_parens, paren_counter)\n            #\
    \ Decrement paren_counter by 1 when there is a closing paren.\n            elif\
    \ char == ')':\n                paren_counter -= 1\n\n        # After looping\
    \ through each char, append the max_nested_parens to nested_parens.\n        nested_parens.append(max_nested_parens)\n\
    \n    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # start with an empty\
    \ stack for tracking nested parens\n    stack = []\n    # split input string into\
    \ individual groups\n    groups = paren_string.split()\n    # output list of max\
    \ levels of nested parens\n    output = []\n    # for each group, check if the\
    \ character is '(' or ')'\n    for group in groups:\n        # assume that the\
    \ max nested level is 1\n        max_depth = 1\n        for ch in group:\n   \
    \         if ch == '(':\n                # we have met another open paren, so\
    \ push it to the stack\n                stack.append(ch)\n                # update\
    \ the maximum depth if needed\n                max_depth = max(max_depth, len(stack))\n\
    \            elif ch == ')':\n                # we have met a close paren, so\
    \ pop the top open paren from the stack\n                stack.pop()\n       \
    \ # add the max depth of this group to the output list\n        output.append(max_depth)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Note: String with\
    \ parentheses is not a valid Python input, so we are pretending that the string\
    \ is\n    # input by user.\n    paren_list = paren_string.split(' ')\n\n    result\
    \ = []\n    for paren in paren_list:\n        # We only need to keep track of\
    \ the deepest level at any point.\n        deepest_nesting = 0\n        current_nesting\
    \ = 0\n        for c in paren:\n            if c == '(':\n                current_nesting\
    \ += 1\n                if current_nesting > deepest_nesting:\n              \
    \      deepest_nesting = current_nesting\n            elif c == ')':\n       \
    \         current_nesting -= 1\n            else:\n                # We are just\
    \ considering parentheses, so any other character is treated as an error.\n  \
    \              raise ValueError('Invalid character found in input. Input should\
    \ only contain parentheses.')\n        # If there are any dangling parentheses,\
    \ the input is invalid and we need to throw an error.\n        if current_nesting\
    \ != 0:\n            raise ValueError('Number of opening and closing parentheses\
    \ do not match')\n        result.append(deepest_nesting)\n    return result\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    for\
    \ paren_group in paren_string.split():\n        level = 0\n        max_level =\
    \ 0\n        for paren in paren_group:\n            if paren == '(':\n       \
    \         level += 1\n                max_level = max(max_level, level)\n    \
    \        elif paren == ')':\n                level -= 1\n        levels.append(max_level)\n\
    \    return levels\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ s in paren_string.split():\n        res.append(len(s) - len(s.replace('(', '')))\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmfuhnu1i.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpmfuhnu1i.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmfuhnu1i.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren in paren_string.split(' '):\n        paren_stack = []\n        max_nesting\
    \ = 0\n        for ch in paren:\n            if ch == '(':\n                paren_stack.append(ch)\n\
    \                max_nesting = max(max_nesting, len(paren_stack))\n          \
    \  elif ch == ')':\n                paren_stack.pop()\n        res.append(max_nesting)\n\
    \    return res\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def recurse(paren_string:\
    \ str, acc: int) -> int:\n        if not paren_string:\n            return acc\n\
    \        if paren_string[0] == '(':\n            return recurse(paren_string[1:],\
    \ acc + 1)\n        else:\n            return recurse(paren_string[1:], acc -\
    \ 1)\n\n    output = []\n    for group in paren_string.split(' '):\n        output.append(recurse(group,\
    \ 0))\n    return output\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdalvkott.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpdalvkott.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdalvkott.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    output = [max_depth(group) for group in groups]\n    return output\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpose61lha.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpose61lha.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpose61lha.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpose61lha.py\", line 12, in parse_nested_parens\n\
    \    output = [max_depth(group) for group in groups]\n  File \"/tmp/tmpose61lha.py\"\
    , line 12, in <listcomp>\n    output = [max_depth(group) for group in groups]\n\
    NameError: name 'max_depth' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    group_counts = []\n\n    while paren_string:\n        if not paren_string.startswith('('):\n\
    \            raise ValueError(\"Must start with open parenthesis!\")\n\n     \
    \   num_open = 1\n        deepest_level = 1\n        paren_string = paren_string[1:]\n\
    \        for paren in paren_string:\n            if paren == '(':\n          \
    \      num_open += 1\n                deepest_level = max(deepest_level, num_open)\n\
    \            elif paren == ')':\n                num_open -= 1\n            else:\n\
    \                raise ValueError(\"Invalid character\")\n\n            if num_open\
    \ == 0:\n                break\n\n        if paren_string.startswith(')') and\
    \ num_open == 0:\n            group_counts.append(deepest_level)\n           \
    \ paren_string = paren_string[1:]\n        else:\n            raise ValueError(\"\
    Invalid group of parentheses\")\n\n        if paren_string:\n            if not\
    \ paren_string.startswith(' '):\n                raise ValueError(\"Must be separated\
    \ by spaces\")\n            paren_string = paren_string[1:]\n\n    return group_counts\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpa5lcpw92.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpa5lcpw92.py\", line 52,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpa5lcpw92.py\"\
    , line 47, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpa5lcpw92.py\", line 37, in parse_nested_parens\n\
    \    raise ValueError(\"Invalid group of parentheses\")\nValueError: Invalid group\
    \ of parentheses\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    output = []\n    for group in paren_groups:\n        max_level = 0\n\
    \        if group:\n            level = 0\n            for paren in group:\n \
    \               if paren == '(':\n                    level += 1\n           \
    \         max_level = max(max_level, level)\n                elif paren == ')':\n\
    \                    level -= 1\n            output.append(max_level)\n      \
    \  else:\n            output.append(0)\n    return output\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    input_list = paren_string.split('\
    \ ')\n    output_list = []\n    for paren in input_list:\n        count = 0\n\
    \        for char in paren:\n            if char == '(':\n                count\
    \ += 1\n            else:\n                count -= 1\n            if count <\
    \ 0:\n                break\n        output_list.append(count)\n    return output_list\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpz5bi49lj.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpz5bi49lj.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz5bi49lj.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        max_depth = 0\n        level\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           level += 1\n                max_depth = max(max_depth, level)\n  \
    \          else:\n                level -= 1\n        result.append(max_depth)\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    paren_nesting_level = [len(re.findall(r'(\\(+)', paren)) - len(re.findall(r'(\\\
    ))+', paren)) for paren in paren_list]\n    return paren_nesting_level\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpd7_lcwza.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpd7_lcwza.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpd7_lcwza.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpd7_lcwza.py\", line 12, in parse_nested_parens\n\
    \    paren_nesting_level = [len(re.findall(r'(\\(+)', paren)) - len(re.findall(r'(\\\
    ))+', paren)) for paren in paren_list]\n  File \"/tmp/tmpd7_lcwza.py\", line 12,\
    \ in <listcomp>\n    paren_nesting_level = [len(re.findall(r'(\\(+)', paren))\
    \ - len(re.findall(r'(\\))+', paren)) for paren in paren_list]\nNameError: name\
    \ 're' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    deepest_levels\
    \ = []\n    for token in paren_string.split():\n        if token == '(':\n   \
    \         level += 1\n        elif token == ')':\n            deepest_levels.append(level)\n\
    \            level -= 1\n    return deepest_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbogmtm0d.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpbogmtm0d.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbogmtm0d.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    deepest_nesting = list()\n    for paren in paren_list:\n        current_level\
    \ = 0\n        max_level = 0\n        for char in paren:\n            if char\
    \ == '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                current_level\
    \ -= 1\n        deepest_nesting.append(max_level)\n    return deepest_nesting\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n    if paren_string == '':\n        return []\n    result = []\n   \
    \ depth = 0\n    max_depth = 0\n    for paren in paren_string:\n        if paren\
    \ == '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        elif paren == ')':\n            depth -= 1\n        elif paren == ' ':\n\
    \            if depth > 0:\n                result.append(max_depth)\n       \
    \         max_depth = 0\n    result.append(max_depth)\n    return result\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpd_m8niss.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpd_m8niss.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpd_m8niss.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    split_list = paren_string.split()\n\
    \    result = []\n    for i in split_list:\n        level = 0\n        max_level\
    \ = 0\n        for j in i:\n            if j == '(':\n                level +=\
    \ 1\n                max_level = max(max_level, level)\n            elif j ==\
    \ ')':\n                level -= 1\n        result.append(max_level)\n    return\
    \ result\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = paren_string.split('\
    \ ')\n    depth_list = []\n    for group in group_list:\n        depth = 0\n \
    \       max_depth = 0\n        for ch in group:\n            if ch == '(':\n \
    \               depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            elif ch == ')':\n                depth -= 1\n        depth_list.append(max_depth)\n\
    \    return depth_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Create lists of\
    \ paren strings\n    paren_groups = paren_string.split(' ')\n    max_nested_level\
    \ = []\n\n    # Calculate and append maximum nested level of each group to max_nested_level\n\
    \    for paren in paren_groups:\n        max_level = 0\n        count = 0\n  \
    \      for c in paren:\n            if c == '(':\n                count += 1\n\
    \                if count > max_level:\n                    max_level = count\n\
    \            elif c == ')':\n                count -= 1\n        max_nested_level.append(max_level)\n\
    \n    return max_nested_level\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    max_depth\
    \ = 0\n    depth_list = []\n    for i in paren_string:\n        if i == '(':\n\
    \            depth += 1\n            max_depth = max(max_depth, depth)\n     \
    \   elif i == ')':\n            depth -= 1\n        elif i == ' ':\n         \
    \   depth_list.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n    depth_list.append(max_depth)\n    return depth_list\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def parse_parens(paren_string:\
    \ str) -> int:\n        # This is a helper function which computes the depth of\
    \ nesting in a single group.\n        levels = 0\n        max_levels = 0\n   \
    \     for paren in paren_string:\n            if paren == '(':\n             \
    \   levels += 1\n                max_levels = max(max_levels, levels)\n      \
    \      elif paren == ')':\n                levels -= 1\n            else:\n  \
    \              raise ValueError('Unsupported character: ' + paren)\n        return\
    \ max_levels\n\n    return [parse_parens(paren_string) for paren_string in paren_string.split()]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Tokenize the string\n\
    \    tokens = paren_string.split(' ')\n    # For each group, count the number\
    \ of left parens before the first unmatched right paren\n    output = [token.count('(')\
    \ - token.count(')') for token in tokens]\n    # Always check for correctness\
    \ of input\n    assert all(p == 0 for p in output)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpi4z9r31c.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpi4z9r31c.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpi4z9r31c.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    split_string = paren_string.split('\
    \ ')\n    max_nesting = [0]\n    for s in split_string:\n        current_max =\
    \ 0\n        stack = []\n        for i in range(len(s)):\n            if s[i]\
    \ == '(':\n                stack.append(s[i])\n                current_max +=\
    \ 1\n            elif s[i] == ')':\n                if len(stack) == 0:\n    \
    \                return False\n                stack.pop()\n                current_max\
    \ -= 1\n        max_nesting.append(current_max)\n    return max_nesting\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaqf2uxty.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpaqf2uxty.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaqf2uxty.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def calculate_nested_parens(paren_string:\
    \ str) -> int:\n        \"\"\"\n        Input to this function is a string represented\
    \ one group of nested parentheses.\n        Output is the maximum number of nesting\
    \ of parentheses.\n        E.g. ((())) has three levels of nesting while (()())\
    \ has two.\n        \"\"\"\n        if paren_string is None or paren_string ==\
    \ '':\n            return 0\n        stack = []\n        for bracket in paren_string:\n\
    \            if bracket == '(':\n                stack.append(bracket)\n     \
    \       else:\n                if len(stack) > 0:\n                    stack.pop()\n\
    \                else:\n                    return 0\n        return len(stack)\n\
    \n    if paren_string is None or paren_string == '':\n        return []\n    groups\
    \ = paren_string.split(' ')\n    return [calculate_nested_parens(group) for group\
    \ in groups]\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0jd1dlr6.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmp0jd1dlr6.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0jd1dlr6.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    return [process_paren_group(group) for group in groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqv8sq39f.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpqv8sq39f.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqv8sq39f.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqv8sq39f.py\", line 12, in parse_nested_parens\n\
    \    return [process_paren_group(group) for group in groups]\n  File \"/tmp/tmpqv8sq39f.py\"\
    , line 12, in <listcomp>\n    return [process_paren_group(group) for group in\
    \ groups]\nNameError: name 'process_paren_group' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  current_depth = 0\n    max_depth_in_parens = []\n    open_parens = ('(', '[',\
    \ '{')\n    close_parens = (')', ']', '}')\n    for char in paren_string:\n  \
    \      if char in open_parens:\n            current_depth += 1\n            max_depth\
    \ = max(max_depth, current_depth)\n        elif char in close_parens:\n      \
    \      current_depth -= 1\n        elif char == ' ':\n            max_depth_in_parens.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n    max_depth_in_parens.append(max_depth)\n\
    \    return max_depth_in_parens\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ paren_group in paren_string.split():\n        level = 0\n        max_level =\
    \ 0\n        for paren in paren_group:\n            if paren == '(':\n       \
    \         level += 1\n                max_level = max(max_level, level)\n    \
    \        elif paren == ')':\n                level -= 1\n            else:\n \
    \               raise ValueError(f'Unknown char {paren}')\n        output.append(max_level)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3sgcwa50.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp3sgcwa50.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3sgcwa50.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_nested_parens\
    \ = []\n    for paren_group in paren_string.split(' '):\n        max_nesting =\
    \ 0\n        current_nesting = 0\n        for paren in paren_group:\n        \
    \    if paren == '(':\n                current_nesting += 1\n                max_nesting\
    \ = max(max_nesting, current_nesting)\n            elif paren == ')':\n      \
    \          current_nesting -= 1\n            else:\n                print('Invalid\
    \ parentheses!')\n                return\n        parsed_nested_parens.append(max_nesting)\n\
    \    return parsed_nested_parens\n\nimport doctest\ndoctest.testmod()\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # parse string\n \
    \   groups = paren_string.split(' ')\n    # calculate maximum nested parens\n\
    \    max_nested_parens = [max_nested_parens_helper(group) for group in groups]\n\
    \    return max_nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfsymc3ec.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpfsymc3ec.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfsymc3ec.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfsymc3ec.py\", line 14, in parse_nested_parens\n\
    \    max_nested_parens = [max_nested_parens_helper(group) for group in groups]\n\
    \  File \"/tmp/tmpfsymc3ec.py\", line 14, in <listcomp>\n    max_nested_parens\
    \ = [max_nested_parens_helper(group) for group in groups]\nNameError: name 'max_nested_parens_helper'\
    \ is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n  \
    \  depths = []\n    for paren in paren_string.split(' '):\n        curr_depth\
    \ = 0\n        for ch in paren:\n            if ch == '(':\n                curr_depth\
    \ += 1\n                max_depth = max(max_depth, curr_depth)\n            else:\n\
    \                curr_depth -= 1\n        depths.append(max_depth)\n    return\
    \ depths\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp28vao9g0.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp28vao9g0.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp28vao9g0.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_depth = []\n\
    \    for paren_group in paren_string.split():\n        depth = 0\n        max_depth\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           depth += 1\n                max_depth = max(max_depth, depth)\n  \
    \          elif paren == ')':\n                depth -= 1\n        paren_depth.append(max_depth)\n\
    \    return paren_depth\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deepest_level_per_group\
    \ = []\n    for paren_group in paren_string.split():\n        depth = 0\n    \
    \    deepest_level = 0\n        for paren in paren_group:\n            if paren\
    \ == '(':\n                depth += 1\n                if depth > deepest_level:\n\
    \                    deepest_level = depth\n            elif paren == ')':\n \
    \               depth -= 1\n            else:\n                raise ValueError(f'Invalid\
    \ character in input string {paren_string}')\n        deepest_level_per_group.append(deepest_level)\n\
    \    return deepest_level_per_group\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  count = 0\n    ret = []\n    for x in paren_string:\n        if x == '(':\n\
    \            count += 1\n            max_level = max(max_level, count)\n     \
    \   elif x == ')':\n            count -= 1\n        elif x == ' ':\n         \
    \   ret.append(max_level)\n            max_level = 0\n            count = 0\n\
    \    ret.append(max_level)\n    return ret\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # split by spaces\
    \ and then iterate over the groups\n    nested_parens = paren_string.split()\n\
    \    levels = []\n    for nested_paren in nested_parens:\n        level = 0\n\
    \        maximum = 0\n        for paren in nested_paren:\n            if paren\
    \ == '(':\n                level += 1\n                maximum = max(maximum,\
    \ level)\n            elif paren == ')':\n                level -= 1\n       \
    \ levels.append(maximum)\n    return levels\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('\
    \ ')\n    res = []\n    for g in groups:\n        if len(g) == 0:\n          \
    \  res.append(0)\n            continue\n        stack = []\n        level = 0\n\
    \        max_level = 0\n        for c in g:\n            if c == '(':\n      \
    \          stack.append(c)\n                level += 1\n                max_level\
    \ = max(max_level, level)\n            elif c == ')':\n                stack.pop()\n\
    \                level -= 1\n        res.append(max_level)\n    return res\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        levels = 0\n        max_levels =\
    \ 0\n        for paren in parens:\n            if paren == '(':\n            \
    \    levels += 1\n                max_levels = max(max_levels, levels)\n     \
    \       elif paren == ')':\n                levels -= 1\n        result.append(max_levels)\n\
    \    return result\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ parens in paren_string.split(' '):\n        curr_max = 0\n        stack = []\n\
    \        for idx, char in enumerate(parens):\n            if char == '(':\n  \
    \              stack.append(idx)\n            else:\n                stack.pop()\n\
    \                if len(stack) > curr_max:\n                    curr_max = len(stack)\n\
    \        output.append(curr_max)\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkqe8r34f.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpkqe8r34f.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkqe8r34f.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ans = []\n    for\
    \ group in paren_string.split(' '):\n        ans.append(max(map(paren_string.count,\
    \ '()' * (len(group) // 2 + 1))))\n    return ans\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgy65knwe.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpgy65knwe.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgy65knwe.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    out = []\n    for paren_group in paren_groups:\n        counter = 0\n   \
    \     max_counter = 0\n        for paren in paren_group:\n            if paren\
    \ == '(':\n                counter += 1\n                max_counter = max(max_counter,\
    \ counter)\n            else:\n                counter -= 1\n        out.append(max_counter)\n\
    \    return out\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_grp in paren_string.split(' '):\n        curr_max = 0\n        max_so_far\
    \ = 0\n        for char in paren_grp:\n            if char == '(':\n         \
    \       curr_max += 1\n                max_so_far = max(max_so_far, curr_max)\n\
    \            elif char == ')':\n                curr_max -= 1\n        res.append(max_so_far)\n\
    \    return res\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_count = 0\n  \
    \  result = []\n    for string in paren_string.split():\n        count = 0\n \
    \       for char in string:\n            if char == '(':\n                count\
    \ += 1\n            else:\n                count -= 1\n            max_count =\
    \ max(max_count, count)\n        result.append(max_count)\n    return result\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxrwk8hrl.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpxrwk8hrl.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxrwk8hrl.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    paren_list = paren_string.split(' ')\n    results =\
    \ []\n    for paren in paren_list:\n        results.append(nested_parens(paren))\n\
    \    return results\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqkejxrhp.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpqkejxrhp.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqkejxrhp.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqkejxrhp.py\", line 17, in parse_nested_parens\n\
    \    results.append(nested_parens(paren))\nNameError: name 'nested_parens' is\
    \ not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ elem in paren_string.split(' '):\n        count = 0\n        max_count = 0\n\
    \        for i in elem:\n            if i == '(':\n                count += 1\n\
    \                max_count = max(max_count, count)\n            elif i == ')':\n\
    \                count -= 1\n        result.append(max_count)\n    return result\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphrpv90oj.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmphrpv90oj.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphrpv90oj.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output_list = []\n\
    \    for single_paren_string in paren_string.split():\n        last_open_idx =\
    \ 0\n        max_so_far = 0\n        current_max = 0\n        for index, char\
    \ in enumerate(single_paren_string):\n            if char == '(':\n          \
    \      current_max += 1\n                max_so_far = max(max_so_far, current_max)\n\
    \            elif char == ')':\n                current_max -= 1\n        output_list.append(max_so_far)\n\
    \    return output_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        res_val = 0\n        max_val\
    \ = 0\n        for c in paren_group:\n            if c == '(':\n             \
    \   res_val += 1\n            else:\n                res_val -= 1\n          \
    \  max_val = max(max_val, res_val)\n        result.append(max_val)\n    return\
    \ result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_nesting_level\
    \ = 0\n    nesting_level = 0\n    nesting_levels = []\n    for c in paren_string:\n\
    \        if c == '(':\n            nesting_level += 1\n            max_nesting_level\
    \ = max(max_nesting_level, nesting_level)\n        elif c == ')':\n          \
    \  nesting_level -= 1\n        elif c == ' ':\n            nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            nesting_level = 0\n    return\
    \ nesting_levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyie6q_6j.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpyie6q_6j.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyie6q_6j.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    depth = 0\n    max_depth = 0\n    result = []\n    for\
    \ c in paren_string:\n        if c == '(':\n            depth += 1\n         \
    \   max_depth = max(max_depth, depth)\n        elif c == ')':\n            depth\
    \ -= 1\n        elif c == ' ':\n            result.append(max_depth)\n       \
    \     max_depth = 0\n            depth = 0\n        else:\n            raise ValueError(f'Invalid\
    \ character: {c}')\n\n    result.append(max_depth)\n    return result\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    output = []\n    for paren in paren_list:\n        index = 0\n     \
    \   count = 0\n        max_count = 0\n        while index < len(paren):\n    \
    \        if paren[index] == '(':\n                count += 1\n               \
    \ if count > max_count:\n                    max_count = count\n            elif\
    \ paren[index] == ')':\n                count -= 1\n            index += 1\n \
    \       output.append(max_count)\n    return output\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_group in paren_string.split():\n        count = 0\n        max_count =\
    \ 0\n        for c in paren_group:\n            if c == '(':\n               \
    \ count += 1\n                max_count = max(max_count, count)\n            elif\
    \ c == ')':\n                count -= 1\n        res.append(max_count)\n    return\
    \ res\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    values = paren_string.split()\n\
    \    return [max_depth(value) for value in values]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp207609dr.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp207609dr.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp207609dr.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp207609dr.py\", line 12, in parse_nested_parens\n\
    \    return [max_depth(value) for value in values]\n  File \"/tmp/tmp207609dr.py\"\
    , line 12, in <listcomp>\n    return [max_depth(value) for value in values]\n\
    NameError: name 'max_depth' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_counts = []\n\
    \    for paren_group in paren_string.split(' '):\n        max_count = 0\n    \
    \    curr_count = 0\n        for char in paren_group:\n            if char ==\
    \ '(':\n                curr_count += 1\n                max_count = max(max_count,\
    \ curr_count)\n            elif char == ')':\n                curr_count -= 1\n\
    \            else:\n                raise RuntimeError(f'Unexpected character\
    \ {char}')\n        if curr_count != 0:\n            raise RuntimeError(f'No match\
    \ found for {paren_group}')\n        paren_counts.append(max_count)\n    return\
    \ paren_counts\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsqrp2mft.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpsqrp2mft.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsqrp2mft.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ s in paren_string.split(' '):\n        output.append(len(s.replace('(', ' ').replace(')',\
    \ ' ').split()))\n    return output\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu8tsx7gm.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpu8tsx7gm.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu8tsx7gm.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    paren_string = paren_string.strip()\n    paren_string\
    \ = paren_string.replace(' ', '')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.split()\n\n    res = []\n    open_p = 0\n    max_open_p = 0\n\
    \    for c in paren_string:\n        if c == '(':\n            open_p += 1\n \
    \           max_open_p = max(max_open_p, open_p)\n        elif c == ')':\n   \
    \         open_p -= 1\n        else:\n            res.append(max_open_p)\n   \
    \         max_open_p = 0\n            open_p = 0\n\n    return res\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeo125yx1.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpeo125yx1.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpeo125yx1.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # First, split the\
    \ input string on spaces to get a list of substrings.\n    all_substrings = paren_string.split()\n\
    \    # Create a list to hold the maximum levels of nesting for each of the substring\
    \ groups.\n    max_nesting_levels = []\n    # Next, for each substring, process\
    \ it to determine the deepest level of nesting of parentheses.\n    for substring\
    \ in all_substrings:\n        # Set initial nesting level to 0.\n        max_level\
    \ = 0\n        # Set initial current nesting level to 0.\n        curr_level =\
    \ 0\n        # Process each character in substring to find the deepest level of\
    \ nesting.\n        for char in substring:\n            # If char is an opening\
    \ parenthesis, then increment current nesting level.\n            if char == '(':\n\
    \                curr_level += 1\n            # Else if char is a closing parenthesis,\
    \ then decrement current nesting level.\n            elif char == ')':\n     \
    \           curr_level -= 1\n            # If current nesting level is greater\
    \ than max nesting level, then set max level to current level.\n            if\
    \ curr_level > max_level:\n                max_level = curr_level\n        # Add\
    \ deepest level of nesting to the max_nesting_levels list.\n        max_nesting_levels.append(max_level)\n\
    \    # Return the list containing maximum nesting levels.\n    return max_nesting_levels\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        depth = 0\n        highest_depth\
    \ = 0\n        for c in parens:\n            if c == '(':\n                depth\
    \ += 1\n                highest_depth = max(highest_depth, depth)\n          \
    \  elif c == ')':\n                depth -= 1\n        result.append(highest_depth)\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n    curr_count = 0\n    max_level = 0\n    result = []\n    for i in\
    \ range(len(paren_string)):\n        if paren_string[i] == '(':\n            curr_count\
    \ += 1\n            max_level = max(max_level, curr_count)\n        elif paren_string[i]\
    \ == ')':\n            curr_count -= 1\n        else:\n            result.append(max_level)\n\
    \            max_level = 0\n            curr_count = 0\n    return result\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpz18j3apf.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpz18j3apf.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz18j3apf.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split(' '):\n        level = 0\n        max_level = 0\n\
    \        for paren in parens:\n            if paren == '(':\n                level\
    \ += 1\n                max_level = max(max_level, level)\n            elif paren\
    \ == ')':\n                level -= 1\n        result.append(max_level)\n    return\
    \ result\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for\
    \ parens in paren_string.split():\n        max_level = 0\n        level = 0\n\
    \        for char in parens:\n            if char == '(':\n                level\
    \ += 1\n                max_level = max(max_level, level)\n            elif char\
    \ == ')':\n                level -= 1\n            else:\n                raise\
    \ ValueError(f'Invalid character: {char}')\n        output.append(max_level)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth_list = []\n\
    \    for parenthesis_group in paren_string.split(' '):\n        current_depth\
    \ = 0\n        max_depth = 0\n        for char in parenthesis_group:\n       \
    \     if char == '(':\n                current_depth += 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            elif char == ')':\n           \
    \     current_depth -= 1\n        max_depth_list.append(max_depth)\n    return\
    \ max_depth_list\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split('\
    \ ')\n    return [deepest_nesting(group) for group in paren_groups]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy3p0l_7a.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpy3p0l_7a.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpy3p0l_7a.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpy3p0l_7a.py\", line 12, in parse_nested_parens\n\
    \    return [deepest_nesting(group) for group in paren_groups]\n  File \"/tmp/tmpy3p0l_7a.py\"\
    , line 12, in <listcomp>\n    return [deepest_nesting(group) for group in paren_groups]\n\
    NameError: name 'deepest_nesting' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split():\n        result.append(len(s.replace(')', '')))\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_tuf2z2r.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmp_tuf2z2r.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_tuf2z2r.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    max_levels = []\n    for paren_group in paren_groups:\n        max_level\
    \ = 0\n        curr_level = 0\n        for char in paren_group:\n            if\
    \ char == '(':\n                curr_level += 1\n                max_level = max(max_level,\
    \ curr_level)\n            elif char == ')':\n                curr_level -= 1\n\
    \        max_levels.append(max_level)\n    return max_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ paren_group in paren_string.split(' '):\n        if not paren_group:\n     \
    \       result.append(0)\n            continue\n        max_nested_parenthesis\
    \ = 0\n        current_level = 0\n        for paren in paren_group:\n        \
    \    if paren == '(':\n                current_level += 1\n            elif paren\
    \ == ')':\n                current_level -= 1\n            if current_level >\
    \ max_nested_parenthesis:\n                max_nested_parenthesis = current_level\n\
    \        result.append(max_nested_parenthesis)\n    return result\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    num_parens = paren_string.count('(')\n\
    \    if num_parens == 0:\n        return []\n    paren_levels = [0] * num_parens\n\
    \    curr_paren_idx = 0\n    curr_level = 0\n    for char in paren_string:\n \
    \       if char == '(':\n            curr_level += 1\n            paren_levels[curr_paren_idx]\
    \ = curr_level\n        elif char == ')':\n            curr_level -= 1\n     \
    \       curr_paren_idx += 1\n    return paren_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbk0bs36r.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpbk0bs36r.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbk0bs36r.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Splitting the string\
    \ into individual groups\n    paren_groups = paren_string.split()\n    paren_counts\
    \ = []\n\n    for group in paren_groups:\n        group_count = 0\n        max_count\
    \ = 0\n        for paren in group:\n            if paren == '(':\n           \
    \     group_count += 1\n            elif paren == ')':\n                group_count\
    \ -= 1\n            max_count = max(max_count, group_count)\n        paren_counts.append(max_count)\n\
    \n    return paren_counts\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_nesting = []\n    for group in groups:\n        max_depth = 0\n     \
    \   depth = 0\n        for c in group:\n            if c == '(':\n           \
    \     depth += 1\n                max_depth = max(max_depth, depth)\n        \
    \    elif c == ')':\n                depth -= 1\n        max_nesting.append(max_depth)\n\
    \    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp18kfy5w7.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp18kfy5w7.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp18kfy5w7.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_str_list = paren_string.split()\n\
    \    out_list = []\n    for paren_str in paren_str_list:\n        c = 0\n    \
    \    d = 0\n        for char in paren_str:\n            if char == '(':\n    \
    \            c += 1\n                d = max(c, d)\n            elif char == ')':\n\
    \                c -= 1\n        out_list.append(d)\n    return out_list\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\nimport doctest\n\
    doctest.testmod()\n \n```\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "  File \"/tmp/tmpgcm8djxo.py\", line 16\n    ```\n    ^\nSyntaxError: invalid\
    \ syntax\n"
  exit_code: 1
  status: SyntaxError
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ group in paren_string.split(' '):\n        max_level = 0\n        level = 0\n\
    \        for c in group:\n            if c == '(':\n                level += 1\n\
    \                max_level = max(max_level, level)\n            elif c == ')':\n\
    \                level -= 1\n        res.append(max_level)\n    return res\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deep_nest = []\n \
    \   max_level = 0\n    curr_level = 0\n    for char in paren_string:\n       \
    \ if char == '(':\n            curr_level += 1\n            max_level = max(max_level,\
    \ curr_level)\n        elif char == ')':\n            curr_level -= 1\n      \
    \  elif char == ' ':\n            deep_nest.append(max_level)\n            max_level\
    \ = 0\n            curr_level = 0\n    deep_nest.append(max_level)\n    return\
    \ deep_nest\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ string in paren_string.split(' '):\n        max_level = 0\n        current_level\
    \ = 0\n        for char in string:\n            if char == '(':\n            \
    \    current_level += 1\n                max_level = max(max_level, current_level)\n\
    \            elif char == ')':\n                current_level -= 1\n        result.append(max_level)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ s in paren_string.split():\n        current_max = 0\n        current_level =\
    \ 0\n        for c in s:\n            if c == '(':\n                current_level\
    \ += 1\n                current_max = max(current_max, current_level)\n      \
    \      else:\n                current_level -= 1\n        result.append(current_max)\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ group in paren_string.split():\n        max_depth = 0\n        current_depth\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            elif char == ')':\n                current_depth -= 1\n        res.append(max_depth)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_list = []\n\
    \    for paren_group in paren_string.split():\n        current_max = 0\n     \
    \   current_nesting = 0\n        for paren in paren_group:\n            if paren\
    \ == '(':\n                current_nesting += 1\n                current_max =\
    \ max(current_max, current_nesting)\n            elif paren == ')':\n        \
    \        current_nesting -= 1\n        parsed_list.append(current_max)\n    return\
    \ parsed_list\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    #\
    \ split by space\n    for paren_group in paren_string.split(' '):\n        # keep\
    \ track of the maximum level of nested parentheses\n        max_level = 0\n  \
    \      # current level of nested parentheses\n        level = 0\n        for c\
    \ in paren_group:\n            if c == '(':\n                level += 1\n    \
    \            max_level = max(max_level, level)\n            elif c == ')':\n \
    \               level -= 1\n        result.append(max_level)\n    return result\n\
    \nprint(parse_nested_parens('(()()) ((())) () ((())()())'))\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: "[2, 3, 1, 3]\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depths = []\n    current_depth\
    \ = 0\n    max_depth = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            current_depth -= 1\n        elif char\
    \ == ' ':\n            depths.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    depths.append(max_depth)\n    return depths\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Complete this\
    \ function\n    paren_list = []\n    temp_paren = \"\"\n    for char in paren_string:\n\
    \        if char != \" \":\n            temp_paren += char\n        elif char\
    \ == \" \":\n            paren_list.append(temp_paren)\n            temp_paren\
    \ = \"\"\n    paren_list.append(temp_paren)\n    max_paren_list = []\n    for\
    \ paren_string in paren_list:\n        left_paren = 0\n        right_paren = 0\n\
    \        for char in paren_string:\n            if char == \"(\":\n          \
    \      left_paren += 1\n            elif char == \")\":\n                right_paren\
    \ += 1\n        max_paren_list.append(min(left_paren, right_paren))\n    return\
    \ max_paren_list\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp40_9i5h1.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmp40_9i5h1.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp40_9i5h1.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    groups\
    \ = paren_string.split()\n    for group in groups:\n        depth = 0\n      \
    \  max_depth = 0\n        for ch in group:\n            if ch == '(':\n      \
    \          depth += 1\n                max_depth = max(max_depth, depth)\n   \
    \         elif ch == ')':\n                depth -= 1\n        res.append(max_depth)\n\
    \    return res\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    paren_list = paren_string.split(' ')\n    res = []\n\
    \    for paren in paren_list:\n        depth = 0\n        max_depth = 0\n    \
    \    for c in paren:\n            if c == '(':\n                depth += 1\n \
    \               max_depth = max(max_depth, depth)\n            elif c == ')':\n\
    \                depth -= 1\n        res.append(max_depth)\n    return res\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n    stack = []\n    level = 0\n    max_level = 0\n    max_levels = []\n\
    \    for paren in paren_string:\n        if paren == '(':\n            stack.append(paren)\n\
    \            level += 1\n            if level > max_level:\n                max_level\
    \ = level\n        elif paren == ')':\n            stack.pop()\n            level\
    \ -= 1\n            if not stack:\n                max_levels.append(max_level)\n\
    \                max_level = 0\n    return max_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\
    \    for paren_group in paren_string.split():\n        nested_parens.append(max_nested_parens(paren_group))\n\
    \    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpq_f6z5p7.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpq_f6z5p7.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpq_f6z5p7.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpq_f6z5p7.py\", line 13, in parse_nested_parens\n\
    \    nested_parens.append(max_nested_parens(paren_group))\nNameError: name 'max_nested_parens'\
    \ is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def _max_nested_parens(paren_string:\
    \ str) -> int:\n        \"\"\" Returns the deepest level of nesting of parentheses\
    \ within the input string.\n        \"\"\"\n        max_depth = 0\n        curr_depth\
    \ = 0\n        for c in paren_string:\n            if c == '(':\n            \
    \    curr_depth += 1\n                max_depth = max(max_depth, curr_depth)\n\
    \            elif c == ')':\n                curr_depth -= 1\n        return max_depth\n\
    \n    paren_strings = paren_string.split(' ')\n    return [_max_nested_parens(paren_string)\
    \ for paren_string in paren_strings]\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n\
    \    max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(determine_max_nesting(group))\n\
    \    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjnwyou0q.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpjnwyou0q.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjnwyou0q.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpjnwyou0q.py\", line 14, in parse_nested_parens\n\
    \    max_nesting.append(determine_max_nesting(group))\nNameError: name 'determine_max_nesting'\
    \ is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for\
    \ parens in paren_string.split():\n        stack = []\n        max_depth = 0\n\
    \        for c in parens:\n            if c == '(':\n                stack.append(c)\n\
    \                max_depth = max(max_depth, len(stack))\n            elif c ==\
    \ ')':\n                stack.pop()\n        result.append(max_depth)\n    return\
    \ result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res = []\n    for\
    \ paren_group in paren_string.split():\n        paren_stack = []\n        max_depth\
    \ = 0\n        for char in paren_group:\n            if char == '(':\n       \
    \         paren_stack.append(char)\n                max_depth = max(max_depth,\
    \ len(paren_stack))\n            else:\n                paren_stack.pop()\n  \
    \      res.append(max_depth)\n    return res\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_strings = paren_string.split()\n\
    \    output = []\n    for string in parsed_strings:\n        current_level = 0\n\
    \        max_level = 0\n        for char in string:\n            if char == '(':\n\
    \                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif char == ')':\n                current_level\
    \ -= 1\n        output.append(max_level)\n    return output\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split('\
    \ ')\n    max_depth = []\n    for paren in paren_list:\n        curr_depth = 0\n\
    \        max_depth_curr = 0\n        for char in paren:\n            if char ==\
    \ '(':\n                curr_depth += 1\n                max_depth_curr = max(max_depth_curr,\
    \ curr_depth)\n            elif char == ')':\n                curr_depth -= 1\n\
    \            else:\n                raise ValueError('String contains non-parens\
    \ character')\n        max_depth.append(max_depth_curr)\n    return max_depth\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    parenthesis_stack\
    \ = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n\
    \            parenthesis_stack.append(i)\n        elif char == ')':\n        \
    \    start_pos = parenthesis_stack.pop()\n            if not parenthesis_stack:\n\
    \                levels.append(i - start_pos + 1)\n    return levels\n\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf3v86hiw.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpf3v86hiw.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf3v86hiw.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # example: s = '(()())\
    \ ((())) () ((())()())'\n    s = paren_string.replace(' ', '') # remove space\n\
    \n    # 1. get all substrings separated by non-parens\n    substring_list = re.split('[^()]',\
    \ s) # ['(()())', '(()))', '()', '(()()())']\n\n    # 2. calculate nesting depth\
    \ for each substring\n    depth_list = [get_paren_depth(substring) for substring\
    \ in substring_list] # [2, 3, 1, 3]\n\n    return depth_list\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1l1h5l29.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmp1l1h5l29.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1l1h5l29.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp1l1h5l29.py\", line 15, in parse_nested_parens\n\
    \    substring_list = re.split('[^()]', s) # ['(()())', '(()))', '()', '(()()())']\n\
    NameError: name 're' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    if paren_string[0] != '(' or paren_string[-1] != ')':\n        raise ValueError(f'Input\
    \ paren_string should start and end with a parenthesis. Got: {paren_string}')\n\
    \n    groups = paren_string.split(' ')\n    output = []\n    for group in groups:\n\
    \        curr_nesting = 0\n        max_nesting = 0\n        for paren in group:\n\
    \            if paren == '(':\n                curr_nesting += 1\n           \
    \     max_nesting = max(max_nesting, curr_nesting)\n            elif paren ==\
    \ ')':\n                curr_nesting -= 1\n        output.append(max_nesting)\n\
    \    return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
