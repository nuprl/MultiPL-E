{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "swift",
  "prompt": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n + n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAverage = 0.0\n    var sum = 0\n    var count = 0\n    var i = 0\n    var j = 0\n    var visited = Array(repeating: Array(repeating: false, count: cost.count), count: cost.count)\n    maxAverage = Double(cost[0][0])\n    maxAveragePath(cost: cost, i: &i, j: &j, sum: &sum, count: &count, visited: &visited, maxAverage: &maxAverage)\n    return maxAverage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "/tmp/tmph_xncms6.swift:11:5: error: cannot find 'maxAveragePath' in scope\n    maxAveragePath(cost: cost, i: &i, j: &j, sum: &sum, count: &count, visited: &visited, maxAverage: &maxAverage)\n    ^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var cache = Array(repeating: Array(repeating: -1, count: cost[0].count), count: cost.count)\n    return maxAverageOfPath(cost: cost, row: 0, col: 0, cache: &cache)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "/tmp/tmpx567jeab.swift:5:28: error: extra arguments at positions #2, #3, #4 in call\n    return maxAverageOfPath(cost: cost, row: 0, col: 0, cache: &cache)\n                           ^\n/tmp/tmpx567jeab.swift:3:6: note: 'maxAverageOfPath(cost:)' declared here\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost[0].count - 1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    \n    var dp = Array(repeating: Array(repeating: 0.0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    \n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    \n    for j in 1..<m {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    \n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[n-1][m-1] / Double(n+m-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    \n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmb9okshr/tmpmb9okshr.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afa2b0c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afa2adbcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afa2adbc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afa2adbb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmb9okshr                        0x00005636d4536888 <unavailable> + 6280\n5    libc.so.6                          0x00002afa2b2b1460 __libc_start_main + 245\n6    tmpmb9okshr                        0x00005636d4536429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<n {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmmi_vmjj/tmpmmi_vmjj.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b78c0eecc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b78c0be3b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b78c0be3988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b78c0be27b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmmi_vmjj                        0x000055e795d4c888 <unavailable> + 6280\n5    libc.so.6                          0x00002b78c10d8460 __libc_start_main + 245\n6    tmpmmi_vmjj                        0x000055e795d4c429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0.0 }\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAvg = 0.0\n    var dp = cost\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += min(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    maxAvg = Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n    return maxAvg\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpt5ylrdk5/tmpt5ylrdk5.swift:28: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b931cc36c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b931c92db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b931c92d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b931c92c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt5ylrdk5                        0x0000556bf4523788 <unavailable> + 6024\n5    libc.so.6                          0x00002b931ce22460 __libc_start_main + 245\n6    tmpt5ylrdk5                        0x0000556bf4523329 <unavailable> + 4905\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost.count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost.count-1]) / Double(cost.count * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAverage = 0.0\n    var sum = 0\n    var count = 0\n    var row = 0\n    var col = 0\n    var path = [Int]()\n    \n    maxAverageOfPathHelper(cost: cost, row: row, col: col, sum: &sum, count: &count, path: &path, maxAverage: &maxAverage)\n    \n    return maxAverage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "/tmp/tmpi4suk2vg.swift:11:5: error: cannot find 'maxAverageOfPathHelper' in scope\n    maxAverageOfPathHelper(cost: cost, row: row, col: col, sum: &sum, count: &count, path: &path, maxAverage: &maxAverage)\n    ^~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0, count: cost.count), count: cost.count)\n    dp[0][0] = cost[0][0]\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[cost.count - 1][cost.count - 1]) / Double(cost.count * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var sum = 0\n    var count = 0\n    var i = 0\n    var j = 0\n    while i < cost.count && j < cost[0].count {\n        sum += cost[i][j]\n        count += 1\n        if i == cost.count - 1 {\n            j += 1\n        } else if j == cost[0].count - 1 {\n            i += 1\n        } else {\n            if cost[i+1][j] > cost[i][j+1] {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return Double(sum) / Double(count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpah19737m/tmpah19737m.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9921f87c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9921c7eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9921c7e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9921c7d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpah19737m                        0x000056185d4ee888 <unavailable> + 6280\n5    libc.so.6                          0x00002b9922173460 __libc_start_main + 245\n6    tmpah19737m                        0x000056185d4ee429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<n {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmp1sptg8j9/tmp1sptg8j9.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad167dccc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad167ac3b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad167ac3988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad167ac27b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1sptg8j9                        0x000055f4c3f68888 <unavailable> + 6280\n5    libc.so.6                          0x00002ad167fb8460 __libc_start_main + 245\n6    tmp1sptg8j9                        0x000055f4c3f68429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: cost.count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost.count - 1] / Double(cost.count * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmplpwrvpcu/tmplpwrvpcu.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad7e3a93c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad7e378ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad7e378a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad7e37897b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmplpwrvpcu                        0x000055ccbf41e888 <unavailable> + 6280\n5    libc.so.6                          0x00002ad7e3c7f460 __libc_start_main + 245\n6    tmplpwrvpcu                        0x000055ccbf41e429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAverage = 0.0\n    var maxPath = [Int]()\n    var maxPaths = [[Int]]()\n    var path = [Int]()\n    var paths = [[Int]]()\n    var total = 0\n    var count = 0\n    var average = 0.0\n    var max = 0\n    var maxCount = 0\n    var maxTotal = 0\n    var maxAveragePath = [Int]()\n    var maxAveragePaths = [[Int]]()\n    var maxAverageTotal = 0\n    var maxAverageCount = 0\n    var maxAverageAverage = 0.0\n    var maxAverageMax = 0\n    var maxAverageMaxCount = 0\n    var maxAverageMaxTotal = 0\n    var maxAverageMaxAverage = 0.0\n    var maxAverageMaxAveragePath = [Int]()\n    var maxAverageMaxAveragePaths = [[Int]]()\n    var maxAverageMaxAverageTotal = 0\n    var maxAverageMaxAverageCount = 0\n    var maxAverageMaxAverageAverage = 0.0\n    var maxAverageMaxAverageMax = 0\n    var maxAverageMaxAverageMaxCount = 0\n    var maxAverageMaxAverageMaxTotal = 0\n    var maxAverageMaxAverageMaxAverage = 0.0\n    var maxAverageMaxAverageMaxAveragePath = [Int]()\n    var maxAverageMaxAverageMaxAveragePaths = [[Int]]()\n    var maxAverageMaxAverageMaxAverageTotal = 0\n    var maxAverageMaxAverageMaxAverageCount = 0\n    var maxAverageMaxAverageMaxAverageAverage = 0.0\n    var maxAverageMaxAverageMaxAverageMax = 0\n    var maxAverageMaxAverageMaxAverageMaxCount = 0\n    var maxAverageMaxAverageMaxAverageMaxTotal = 0\n    var maxAverageMaxAverageMaxAverageMaxAverage = 0.0\n    var maxAverageMaxAverageMaxAverageMaxAveragePath = [Int]()\n    var maxAverageMaxAverageMaxAverageMaxAveragePaths = [[Int]]()\n    var maxAverageMaxAverageMaxAverageMaxAverageTotal = 0\n    var maxAverageMaxAverageMaxAverageMaxAverageCount = 0\n    var maxAverageMaxAverageMaxAverageMaxAverageAverage = 0.0\n    var maxAverageMaxAverageMaxAverageMaxAverageMax = 0\n    var maxAverageMaxAverageMaxAverageMaxAverageMaxCount = 0\n    var max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "/tmp/tmpbrpj43vd.swift:49:9: error: type annotation missing in pattern\n    var max\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmb9okshr/tmpmb9okshr.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afa2b0c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afa2adbcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afa2adbc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afa2adbb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmb9okshr                        0x00005636d4536888 <unavailable> + 6280\n5    libc.so.6                          0x00002afa2b2b1460 __libc_start_main + 245\n6    tmpmb9okshr                        0x00005636d4536429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    guard cost.count == cost[0].count else { return 0 }\n    \n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    \n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    \n    return Double(dp[n-1][n-1]) / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<dp.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<dp[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<dp.count {\n        for j in 1..<dp[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[dp.count-1][dp[0].count-1]) / Double((dp.count + dp[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost[0].count-1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    \n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpm9t4l989/tmpm9t4l989.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfd2d84c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfd2a7bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfd2a7b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfd2a7a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm9t4l989                        0x00005603cf020888 <unavailable> + 6280\n5    libc.so.6                          0x00002acfd2f70460 __libc_start_main + 245\n6    tmpm9t4l989                        0x00005603cf020429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n + n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAvg = 0.0\n    var sum = 0\n    var count = 0\n    var i = 0\n    var j = 0\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: cost[0].count), count: cost.count)\n    var path = [Int]()\n    var stack = Stack<Int>()\n    stack.push(i)\n    stack.push(j)\n    while !stack.isEmpty {\n        j = stack.pop()!\n        i = stack.pop()!\n        if i == cost.count - 1 && j == cost[0].count - 1 {\n            count += 1\n            sum += cost[i][j]\n            if maxAvg < Double(sum) / Double(count) {\n                maxAvg = Double(sum) / Double(count)\n            }\n            count -= 1\n            sum -= cost[i][j]\n            continue\n        }\n        if i < cost.count - 1 && !visited[i + 1][j] {\n            stack.push(i + 1)\n            stack.push(j)\n        }\n        if j < cost[0].count - 1 && !visited[i][j + 1] {\n            stack.push(i)\n            stack.push(j + 1)\n        }\n        count += 1\n        sum += cost[i][j]\n        visited[i][j] = true\n    }\n    return maxAvg\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "/tmp/tmpuro13n_4.swift:11:17: error: cannot find 'Stack' in scope\n    var stack = Stack<Int>()\n                ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost.count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost.count - 1]) / Double(2 * cost.count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    guard n > 0 else { return 0 }\n    guard n > 1 else { return Double(cost[0][0]) }\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmplpwrvpcu/tmplpwrvpcu.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad7e3a93c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad7e378ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad7e378a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad7e37897b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmplpwrvpcu                        0x000055ccbf41e888 <unavailable> + 6280\n5    libc.so.6                          0x00002ad7e3c7f460 __libc_start_main + 245\n6    tmplpwrvpcu                        0x000055ccbf41e429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let rows = cost.count\n    let cols = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: cols), count: rows)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<rows {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cols {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<rows {\n        for j in 1..<cols {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[rows - 1][cols - 1] / Double(rows + cols - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<dp.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<dp[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<dp.count {\n        for j in 1..<dp[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[dp.count-1][dp[0].count-1]) / Double(dp.count + dp[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost.count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost.count-1]) / Double(cost.count * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    guard cost.count == cost[0].count else { return 0 }\n    \n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    \n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    \n    return Double(dp[n - 1][n - 1]) / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmp9u2nlt31/tmp9u2nlt31.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b98854adc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b98851a4b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b98851a4988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b98851a37b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9u2nlt31                        0x000056059734b858 <unavailable> + 6232\n5    libc.so.6                          0x00002b9885699460 __libc_start_main + 245\n6    tmp9u2nlt31                        0x000056059734b3f9 <unavailable> + 5113\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / Double(n+m-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][m - 1]) / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "tmpm_3h0dd9/tmpm_3h0dd9.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b82b1397c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b82b108eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b82b108e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b82b108d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm_3h0dd9                        0x000055e5817f7888 <unavailable> + 6280\n5    libc.so.6                          0x00002b82b1583460 __libc_start_main + 245\n6    tmpm_3h0dd9                        0x000055e5817f7429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmb9okshr/tmpmb9okshr.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afa2b0c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afa2adbcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afa2adbc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afa2adbb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmb9okshr                        0x00005636d4536888 <unavailable> + 6280\n5    libc.so.6                          0x00002afa2b2b1460 __libc_start_main + 245\n6    tmpmb9okshr                        0x00005636d4536429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "tmp4h84vszt/tmp4h84vszt.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1ad7ed7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1ad7bceb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1ad7bce988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1ad7bcd7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4h84vszt                        0x00005640a75b0788 <unavailable> + 6024\n5    libc.so.6                          0x00002b1ad80c3460 __libc_start_main + 245\n6    tmp4h84vszt                        0x00005640a75b0329 <unavailable> + 4905\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmb9okshr/tmpmb9okshr.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afa2b0c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afa2adbcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afa2adbc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afa2adbb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmb9okshr                        0x00005636d4536888 <unavailable> + 6280\n5    libc.so.6                          0x00002afa2b2b1460 __libc_start_main + 245\n6    tmpmb9okshr                        0x00005636d4536429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / Double(n+m-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "tmpmb9okshr/tmpmb9okshr.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afa2b0c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afa2adbcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afa2adbc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afa2adbb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmb9okshr                        0x00005636d4536888 <unavailable> + 6280\n5    libc.so.6                          0x00002afa2b2b1460 __libc_start_main + 245\n6    tmpmb9okshr                        0x00005636d4536429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    \n    return Double(dp[n-1][n-1]) / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<n {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let rows = cost.count\n    let cols = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n    dp[0][0] = cost[0][0]\n    for i in 1..<rows {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for j in 1..<cols {\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    }\n    for i in 1..<rows {\n        for j in 1..<cols {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[rows - 1][cols - 1]) / Double(rows + cols - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost.count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost.count-1] / Double(cost.count*2-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    guard n > 0 else { return 0 }\n    guard n > 1 else { return Double(cost[0][0]) }\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509921,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as an array of arrays, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}