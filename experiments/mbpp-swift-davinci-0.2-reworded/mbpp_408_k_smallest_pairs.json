{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [[Int]]()\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while !pq.isEmpty && k > 0 {\n        result.append(pq.dequeue()!)\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while k > 0 && !queue.isEmpty {\n        result.append(queue.dequeue()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result.removeLast()\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(array: [], sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 || k == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result"
  ]
}