{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [[Int]]()\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while !pq.isEmpty && k > 0 {\n        result.append(pq.dequeue()!)\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while k > 0 && !queue.isEmpty {\n        result.append(queue.dequeue()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result.removeLast()\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(array: [], sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 || k == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (a, b) = heap.extract() {\n            result.append([a, b])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let minSum = result[0][0] + result[0][1]\n                if sum < minSum {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<Int> = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<min(k, result.count)])",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i, j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i, j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)> { $0.0 + $0.1 < $1.0 + $1.1 }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    var count = 0\n    while count < k && count < nums1.count * nums2.count {\n        var min_val = Int.max\n        var t = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                t = i\n                min_val = nums1[i] + nums2[index[i]]\n            }\n        }\n        result.append([nums1[t], nums2[index[t]]])\n        index[t] += 1\n        count += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    while !queue.isEmpty && k > 0 {\n        result.append(queue.dequeue()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if heap.peek()! > sum {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while heap.count > 0 {\n        result.append([heap.remove()!, heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    \n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append([value])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i], nums2[j]))\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()!.0 + heap.peek()!.1 {\n                    heap.remove()\n                    heap.insert((nums1[i], nums2[j]))\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.remove() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            if queue.count < k {\n                queue.enqueue(pair)\n            } else {\n                if pair.sum < queue.peek()!.sum {\n                    queue.dequeue()\n                    queue.enqueue(pair)\n                }\n            }\n        }\n    }\n    \n    while !queue.isEmpty() {\n        result.append(queue.dequeue()!.toArray())\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.enqueue(pair)\n        }\n    }\n    var i = 0\n    while !queue.isEmpty && i < k {\n        result.append(queue.dequeue()!.toArray())\n        i += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([sum, index])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.remove() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (e1, e2) -> Bool in\n        return e1.0 + e1.1 < e2.0 + e2.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let e = heap.pop() {\n            result.append([e.0, e.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i, j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i, j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    for _ in 0..<k {\n        guard let pair = heap.pop() else {\n            break\n        }\n        result.append(pair)\n        if pair[2] < nums2.count - 1 {\n            heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((i, j, nums1[i] + nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (i, j, _) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = 0\n    var i = 0\n    var j = 0\n    while index < k && i < nums1.count && j < nums2.count {\n        let sum = nums1[i] + nums2[j]\n        if i + 1 < nums1.count && j + 1 < nums2.count {\n            let sum1 = nums1[i] + nums2[j + 1]\n            let sum2 = nums1[i + 1] + nums2[j]\n            if sum1 < sum2 {\n                if sum1 < sum {\n                    result.append([nums1[i], nums2[j + 1]])\n                    j += 1\n                } else {\n                    result.append([nums1[i], nums2[j]])\n                }\n            } else {\n                if sum2 < sum {\n                    result.append([nums1[i + 1], nums2[j]])\n                    i += 1\n                } else {\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        } else if i + 1 < nums1.count {\n            let sum2 = nums1[i + 1] + nums2[j]\n            if sum2 < sum {\n                result.append([nums1[i + 1], nums2[j]])\n                i += 1\n            } else {\n                result.append([nums1[i], nums2[j]])\n            }\n        } else if j + 1 < nums2.count {\n            let sum1 = nums1[i] + nums2[j + 1]\n            if sum1 < sum {\n                result.append([nums1[i], nums2[j + 1]])\n                j += 1\n            } else {\n                result.append([nums1[i], nums2[j]])\n            }\n        } else {\n            result.append([nums1[i], nums2[j]])\n        }\n        index += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_sum = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_sum {\n                min_sum = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        var i = 0\n        var j = 0\n        while i < nums1.count && j < nums2.count {\n            if nums1[i] + nums2[j] == sum {\n                result.append([nums1[i], nums2[j]])\n                i += 1\n                j += 1\n            } else if nums1[i] + nums2[j] < sum {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    \n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        heap.insert((nums1[i] + nums2[0], i))\n    }\n    \n    while result.count < k && !heap.isEmpty {\n        let (sum, i) = heap.remove()!\n        result.append([nums1[i], nums2[0]])\n        \n        if nums2.count > 1 {\n            heap.insert((nums1[i] + nums2[1], i))\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            res.append([pair.0, pair.1])\n        }\n    }\n    return res",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var pq = PriorityQueue<[Int]>(sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            result.append(pair)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    \n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var index = [0, 0]\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: nums2.count), count: nums1.count)\n    for _ in 0..<k {\n        var min = Int.max\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if !visited[i][j] && nums1[i] + nums2[j] < min {\n                    min = nums1[i] + nums2[j]\n                    index = [i, j]\n                }\n            }\n        }\n        if min == Int.max { break }\n        result.append([nums1[index[0]], nums2[index[1]]])\n        visited[index[0]][index[1]] = true\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    while k > 0 {\n        result.append(heap.pop()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append(sum)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (num1, num2) = heap.remove()!\n        result.append([num1, num2])\n        if num2 != nums2.last! {\n            heap.insert((num1, nums2[nums2.firstIndex(of: num2)! + 1]))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var queue: PriorityQueue<[Int]> = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(ascending: true) { $0.0 + $0.1 < $1.0 + $1.1 }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n            if pair[2] < nums2.count - 1 {\n                heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n            }\n        } else {\n            break\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.1, heap.remove()!.1])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    \n    let m = nums1.count\n    let n = nums2.count\n    var index = [Int](repeating: 0, count: m)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var t = 0\n        for i in 0..<m {\n            if index[i] < n && nums1[i] + nums2[index[i]] < min_val {\n                t = i\n                min_val = nums1[i] + nums2[index[i]]\n            }\n        }\n        \n        if index[t] < n {\n            result.append([nums1[t], nums2[index[t]]])\n            index[t] += 1\n        } else {\n            break\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert(sum)\n            if heap.count > k {\n                heap.pop()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[0], nums2[heap.pop()!]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let min = heap.extractMin() {\n            result.append([min])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let item = queue.dequeue() {\n            result.append([item.0, item.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<Pair> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let pair = heap.remove()!\n        result.append([pair.0, pair.1])\n        if pair.1 < nums2.last! {\n            heap.insert((pair.0, pair.1 + 1))\n        }\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<Pair> = Heap<Pair>(sort: { $0.sum < $1.sum })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.num1, pair.num2])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (x, y) = heap.remove()!\n        result.append([x, y])\n        if y != nums2.last! {\n            let next = nums2.firstIndex(of: y)! + 1\n            heap.insert((x, nums2[next]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            res.append(pair)\n        }\n    }\n    return res",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.pop()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty() {\n        result.append([nums1[0], nums2[heap.pop()! - nums1[0]]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replaceTop((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var index = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if index < k {\n                result.append([nums1[i], nums2[j]])\n                index += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while k > 0 {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                var max = result[0][0] + result[0][1]\n                var maxIndex = 0\n                for index in 0..<result.count {\n                    let sum = result[index][0] + result[index][1]\n                    if sum > max {\n                        max = sum\n                        maxIndex = index\n                    }\n                }\n                let sum = nums1[i] + nums2[j]\n                if sum < max {\n                    result[maxIndex] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        res.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            heap.insert((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return res",
    "    var result = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: nums2.count), count: nums1.count)\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    heap.insert((0, 0))\n    visited[0][0] = true\n    \n    while !heap.isEmpty && result.count < k {\n        let (i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n        \n        if i + 1 < nums1.count && !visited[i + 1][j] {\n            heap.insert((i + 1, j))\n            visited[i + 1][j] = true\n        }\n        \n        if j + 1 < nums2.count && !visited[i][j + 1] {\n            heap.insert((i, j + 1))\n            visited[i][j + 1] = true\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.remove() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i] + nums2[j], i + j))\n            } else {\n                if heap.peek()! > (nums1[i] + nums2[j], i + j) {\n                    heap.remove()\n                    heap.insert((nums1[i] + nums2[j], i + j))\n                }\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        result.append([heap.remove()!.0 - heap.remove()!.1, heap.remove()!.1])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.extract() {\n            result.append([val])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.0, heap.remove()!.0])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let item = heap.pop() {\n            result.append([item.0, item.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = MinHeap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            heap.insert(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < k && index1 < nums1.count && index2 < nums2.count {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if sum < max![0] + max![1] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[0][0] + result[0][1] {\n                    result.removeFirst()\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n            result.sort { (a, b) -> Bool in\n                return a[0] + a[1] < b[0] + b[1]\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return nums1[a.0] + nums2[a.1] < nums1[b.0] + nums2[b.1]\n    })\n    for i in 0..<nums1.count {\n        heap.push((i, 0))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((i, j + 1))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([sum, index])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.enqueue(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.insert(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.pop() {\n            result.append([pair.a, pair.b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var pq = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !pq.isEmpty && k > 0 {\n        result.append(pq.dequeue()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[heap.peek()!.1], nums2[heap.peek()!.1]])\n        heap.remove()\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<Int> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.replace(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.peek()!, heap.peek()! - heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in nums1 {\n        for j in nums2 {\n            heap.insert((i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (i, j) = heap.pop() {\n            result.append([i, j])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min == Int.max {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count { continue }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.pop() {\n            result.append(val)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result"
  ]
}