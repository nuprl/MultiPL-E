{
  "name": "mbpp_563_extract_values",
  "language": "swift",
  "prompt": "\n/// Write a function to extract values between quotation marks from a string.\nfunc extract_values(text: String) -> [String] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_values(text: \"\\\"Python\\\", \\\"PHP\\\", \\\"Java\\\"\") == [\"Python\", \"PHP\", \"Java\"])\nassert(extract_values(text: \"\\\"python\\\",\\\"program\\\",\\\"language\\\"\") == [\"python\", \"program\", \"language\"])\nassert(extract_values(text: \"\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"yellow\\\"\") == [\"red\", \"blue\", \"green\", \"yellow\"])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var values = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if inQuotes {\n                values.append(text[start..<end])\n            }\n            inQuotes = !inQuotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return values",
    "    var values = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    \n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                values.append(text[start..<end])\n            }\n            in_quotes = !in_quotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    \n    return values",
    "    var result = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuote = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if inQuote {\n                result.append(text[start..<end])\n                inQuote = false\n            } else {\n                start = end\n                inQuote = true\n            }\n        }\n        end = end.successor()\n    }\n    return result",
    "    var values = [String]()\n    var start = 0\n    var end = 0\n    var is_quoted = false\n    for (index, character) in text.characters.enumerated() {\n        if character == \"\\\"\" {\n            if is_quoted {\n                end = index\n                values.append(text[start...end])\n                is_quoted = false\n            } else {\n                start = index\n                is_quoted = true\n            }\n        }\n    }\n    return values",
    "    var result: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuotes = false\n    for c in text {\n        if c == \"\\\"\" {\n            if inQuotes {\n                result.append(String(text[start..<end]))\n                inQuotes = false\n            } else {\n                start = text.index(after: end)\n                inQuotes = true\n            }\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map {\n        String(text[Range($0.range(at: 1), in: text)!])\n    }",
    "    var values = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                values.append(text[start..<end])\n                in_quotes = false\n            } else {\n                in_quotes = true\n                start = text.index(after: end)\n            }\n        }\n        end = text.index(after: end)\n    }\n    return values",
    "    var result = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuotes = false\n    for c in text {\n        if c == \"\\\"\" {\n            if inQuotes {\n                result.append(text[start..<end])\n            }\n            inQuotes = !inQuotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map {\n        let range = Range($0.range(at: 1), in: text)!\n        return String(text[range])\n    }",
    "    var values = [String]()\n    var start = 0\n    var end = 0\n    for (i, c) in text.characters.enumerated() {\n        if c == \"\\\"\" {\n            if start == 0 {\n                start = i\n            } else {\n                end = i\n                values.append(text.substring(with: (start+1)..<end))\n                start = 0\n            }\n        }\n    }\n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map { String(text[Range($0.range, in: text)!]) }",
    "    var result = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if inQuotes {\n                result.append(text[start..<end])\n            }\n            inQuotes = !inQuotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    var values: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text {\n        if c == \"\\\"\" {\n            if in_quotes {\n                values.append(text[start..<end])\n                in_quotes = false\n            } else {\n                start = end\n                in_quotes = true\n            }\n        }\n        end = text.index(after: end)\n    }\n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))\n    return matches.map {\n        let range = Range($0.range(at: 1), in: text)!\n        return String(text[range])\n    }",
    "    var result = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                result.append(text[start..<end])\n                in_quotes = false\n            } else {\n                in_quotes = true\n                start = text.index(after: end)\n            }\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    var values: [String] = []\n    var start = 0\n    var end = 0\n    var is_quoted = false\n    for (i, c) in text.characters.enumerated() {\n        if c == \"\\\"\" {\n            if is_quoted {\n                end = i\n                values.append(text[start..<end])\n                is_quoted = false\n            } else {\n                start = i + 1\n                is_quoted = true\n            }\n        }\n    }\n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map {\n        String(text[Range($0.range(at: 1), in: text)!])\n    }",
    "    var values = [String]()\n    let pattern = \"\\\"(.*?)\\\"\"\n    do {\n        let regex = try NSRegularExpression(pattern: pattern, options: [])\n        let results = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))\n        for result in results {\n            let range = result.range(at: 1)\n            let value = (text as NSString).substring(with: range)\n            values.append(value)\n        }\n    } catch {\n        print(error)\n    }\n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))\n    return matches.map {\n        let rangeBounds = $0.range(at: 1)\n        let start = text.index(text.startIndex, offsetBy: rangeBounds.location)\n        let end = text.index(start, offsetBy: rangeBounds.length)\n        return String(text[start..<end])\n    }",
    "    var values: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuotes = false\n    for char in text {\n        if char == \"\\\"\" {\n            if inQuotes {\n                let value = text[start..<end]\n                values.append(String(value))\n                inQuotes = false\n            } else {\n                start = end\n                inQuotes = true\n            }\n        }\n        end = text.index(after: end)\n    }\n    return values"
  ]
}