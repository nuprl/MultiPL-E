{
  "name": "mbpp_92_is_undulating",
  "language": "swift",
  "prompt": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n        n /= 10\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "tmpqh1fhqkc/tmpqh1fhqkc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b752144fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7521146b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7521146988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b75211457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqh1fhqkc                        0x000055db146ab23e <unavailable> + 4670\n5    libc.so.6                          0x00002b752163b460 __libc_start_main + 245\n6    tmpqh1fhqkc                        0x000055db146aaef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var str = String(n)\n    var i = 0\n    while i < str.count - 1 {\n        if str[i] == str[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmp7kkf3dz4.swift:7:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7kkf3dz4.swift:7:22: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n                     ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7kkf3dz4.swift:4:9: warning: variable 'str' was never mutated; consider changing to 'let' constant\n    var str = String(n)\n    ~~~ ^\n    let\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && last_digit < current_digit {\n            return false\n        }\n        if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_increasing = true\n    while n > 0 {\n        n /= 10\n        current_digit = n % 10\n        if current_digit == last_digit {\n            return false\n        }\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n        last_digit = current_digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "tmp7fw3fiu4/tmp7fw3fiu4.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b53d7567c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b53d725eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b53d725e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b53d725d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7fw3fiu4                        0x000055e3c300123e <unavailable> + 4670\n5    libc.so.6                          0x00002b53d7753460 __libc_start_main + 245\n6    tmp7fw3fiu4                        0x000055e3c3000ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let a = s.map { Int(String($0))! }\n    let b = zip(a, a.dropFirst())\n    return b.allSatisfy { $0.0 != $1.0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmpyirbgvec.swift:7:30: error: value of type 'Int' has no member '0'\n    return b.allSatisfy { $0.0 != $1.0 }\n                          ~~ ^\n/tmp/tmpyirbgvec.swift:7:38: error: value of type 'Int' has no member '0'\n    return b.allSatisfy { $0.0 != $1.0 }\n                                  ~~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if last_digit == current_digit {\n            return false\n        }\n        if is_increasing && last_digit < current_digit {\n            return false\n        }\n        if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits()\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmpdgann5hv.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits()\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > last_digit {\n            return false\n        } else if !is_increasing && digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "tmptl984jhf/tmptl984jhf.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9e3ff6bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9e3fc62b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9e3fc62988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9e3fc617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmptl984jhf                        0x000056279cd4123e <unavailable> + 4670\n5    libc.so.6                          0x00002b9e40157460 __libc_start_main + 245\n6    tmptl984jhf                        0x000056279cd40ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    var current = n % 10\n    n /= 10\n    while n > 0 {\n        if last == current {\n            return false\n        }\n        last = current\n        current = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    var last_digit = digits[0]\n    var is_increasing = true\n    for digit in digits[1..<digits.count] {\n        if digit == last_digit {\n            return false\n        }\n        if is_increasing {\n            if digit < last_digit {\n                is_increasing = false\n            }\n        } else {\n            if digit > last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmpmo58y_82.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_undulating = true\n    while n > 0 {\n        n /= 10\n        let digit = n % 10\n        if last_digit == digit {\n            is_undulating = false\n            break\n        }\n        last_digit = digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits()\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmpdgann5hv.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits()\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmp1613n6s7/tmp1613n6s7.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1ab90fec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1ab8df5b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1ab8df5988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1ab8df47b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1613n6s7                        0x0000560c8429323e <unavailable> + 4670\n5    libc.so.6                          0x00002b1ab92ea460 __libc_start_main + 245\n6    tmp1613n6s7                        0x0000560c84292ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if increasing && current_digit > last_digit {\n            return false\n        }\n        if !increasing && current_digit < last_digit {\n            return false\n        }\n        increasing = !increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpkrry9x0m/tmpkrry9x0m.swift:20: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aea7f280c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aea7ef77b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aea7ef77988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aea7ef767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpkrry9x0m                        0x0000556a3aaa51ae <unavailable> + 4526\n5    libc.so.6                          0x00002aea7f46c460 __libc_start_main + 245\n6    tmpkrry9x0m                        0x0000556a3aaa4e69 <unavailable> + 3689\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev != curr {\n            n /= 10\n            prev = curr\n            continue\n        }\n        let next = n / 10 % 10\n        if prev != next {\n            n /= 10\n            prev = next\n            continue\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpv16zxh11/tmpv16zxh11.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac34a370c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac34a067b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac34a067988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac34a0667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpv16zxh11                        0x00005606a7b602b4 <unavailable> + 4788\n5    libc.so.6                          0x00002ac34a55c460 __libc_start_main + 245\n6    tmpv16zxh11                        0x00005606a7b5fef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = true\n    for i in 0..<digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = prev_digit > curr_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if prev_digit < curr_digit {\n                return false\n            }\n        } else {\n            if prev_digit > curr_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmp270ch0bl/tmp270ch0bl.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b613e3bdc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b613e0b4b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b613e0b4988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b613e0b37b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp270ch0bl                        0x00005599fc57c23e <unavailable> + 4670\n5    libc.so.6                          0x00002b613e5a9460 __libc_start_main + 245\n6    tmp270ch0bl                        0x00005599fc57bef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    var current = n % 10\n    n /= 10\n    while n > 0 {\n        if last == current {\n            return false\n        }\n        last = current\n        current = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_odd = true\n    for i in 0..<digits.count-1 {\n        if is_odd && digits[i] > digits[i+1] {\n            return false\n        }\n        if !is_odd && digits[i] < digits[i+1] {\n            return false\n        }\n        is_odd = !is_odd\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmp5k_bi1ct.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpkrry9x0m/tmpkrry9x0m.swift:20: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aea7f280c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aea7ef77b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aea7ef77988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aea7ef767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpkrry9x0m                        0x0000556a3aaa51ae <unavailable> + 4526\n5    libc.so.6                          0x00002aea7f46c460 __libc_start_main + 245\n6    tmpkrry9x0m                        0x0000556a3aaa4e69 <unavailable> + 3689\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    while n > 0 {\n        n /= 10\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpn0dh0l73/tmpn0dh0l73.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2f69cf3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2f699eab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2f699ea988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2f699e97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpn0dh0l73                        0x000055d5450f023e <unavailable> + 4670\n5    libc.so.6                          0x00002b2f69edf460 __libc_start_main + 245\n6    tmpn0dh0l73                        0x000055d5450efef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    var current = n % 10\n    n /= 10\n    while n > 0 {\n        if last == current {\n            return false\n        }\n        last = current\n        current = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_undulating = true\n    for i in 1..<digits.count - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmpug14f1j4.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        } else if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit > second_last_digit\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > second_last_digit {\n                return false\n            }\n        } else {\n            if digit < second_last_digit {\n                return false\n            }\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpzdmta_dj/tmpzdmta_dj.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3036546c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b303623db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b303623d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b303623c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpzdmta_dj                        0x000055a33c86523e <unavailable> + 4670\n5    libc.so.6                          0x00002b3036732460 __libc_start_main + 245\n6    tmpzdmta_dj                        0x000055a33c864ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let c = s.characters\n    var i = 0\n    while i < c.count - 2 {\n        if c[i] == c[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmpwjue876g.swift:5:15: error: 'characters' is unavailable: Please use String directly\n    let c = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwjue876g.swift:8:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if c[i] == c[i + 2] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwjue876g.swift:8:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if c[i] == c[i + 2] {\n                   ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmp61_drdkd/tmp61_drdkd.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b77250a9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7724da0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7724da0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7724d9f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp61_drdkd                        0x00005628d398823e <unavailable> + 4670\n5    libc.so.6                          0x00002b7725295460 __libc_start_main + 245\n6    tmp61_drdkd                        0x00005628d3987ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).compactMap { Int(String($0)) }\n    var is_increasing = true\n    var is_decreasing = true\n    for i in 0..<digits.count - 1 {\n        if digits[i] < digits[i + 1] {\n            is_decreasing = false\n        }\n        if digits[i] > digits[i + 1] {\n            is_increasing = false\n        }\n    }\n    return is_increasing || is_decreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmp6souotwi/tmp6souotwi.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab2012b9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab200fb0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab200fb0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab200faf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp6souotwi                        0x00005606de2a968e <unavailable> + 5774\n5    libc.so.6                          0x00002ab2014a5460 __libc_start_main + 245\n6    tmp6souotwi                        0x00005606de2a9349 <unavailable> + 4937\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let c = s.characters\n    for i in 0..<c.count-2 {\n        if c[i] == c[i+2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmpb0i73xzs.swift:5:15: error: 'characters' is unavailable: Please use String directly\n    let c = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpb0i73xzs.swift:7:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if c[i] == c[i+2] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb0i73xzs.swift:7:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if c[i] == c[i+2] {\n                   ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = (last_digit < current_digit)\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if last_digit < current_digit {\n                return false\n            }\n        } else {\n            if last_digit > current_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        n /= 10\n        last_digit = second_last_digit\n        second_last_digit = digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpy5orvzxo/tmpy5orvzxo.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afb4b9fbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afb4b6f2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afb4b6f2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afb4b6f17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpy5orvzxo                        0x00005596fee4f23e <unavailable> + 4670\n5    libc.so.6                          0x00002afb4bbe7460 __libc_start_main + 245\n6    tmpy5orvzxo                        0x00005596fee4eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = curr_digit > prev_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if curr_digit > prev_digit {\n                return false\n            }\n        } else {\n            if curr_digit < prev_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let d = n % 10\n        if is_increasing {\n            if d > last {\n                return false\n            }\n        } else {\n            if d < last {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last = d\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpthlh_zaw/tmpthlh_zaw.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b67f0fd0c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b67f0cc7b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b67f0cc7988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b67f0cc67b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpthlh_zaw                        0x000055e10a3ff23e <unavailable> + 4670\n5    libc.so.6                          0x00002b67f11bc460 __libc_start_main + 245\n6    tmpthlh_zaw                        0x000055e10a3feef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let a = s[s.index(s.startIndex, offsetBy: i)]\n        let b = s[s.index(s.startIndex, offsetBy: i + 1)]\n        let c = s[s.index(s.startIndex, offsetBy: i + 2)]\n        if a == c {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] != digits[i+2] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var last_digit = -1\n    var last_digit_was_odd = false\n    for c in s {\n        let digit = Int(String(c))!\n        if last_digit != -1 {\n            if last_digit_was_odd && digit % 2 == 0 {\n                return false\n            }\n            if !last_digit_was_odd && digit % 2 == 1 {\n                return false\n            }\n        }\n        last_digit = digit\n        last_digit_was_odd = digit % 2 == 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpwgxweld_/tmpwgxweld_.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b805a7e7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b805a4deb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b805a4de988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b805a4dd7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpwgxweld_                        0x000055612e7824be <unavailable> + 5310\n5    libc.so.6                          0x00002b805a9d3460 __libc_start_main + 245\n6    tmpwgxweld_                        0x000055612e782179 <unavailable> + 4473\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmp3nh3sz_n.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit && digit != second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpxaynnujq/tmpxaynnujq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2e2c413c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2e2c10ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2e2c10a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2e2c1097b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxaynnujq                        0x000055881c2fe23e <unavailable> + 4670\n5    libc.so.6                          0x00002b2e2c5ff460 __libc_start_main + 245\n6    tmpxaynnujq                        0x000055881c2fdef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    while n > 0 {\n        if last_digit == second_last_digit {\n            return false\n        }\n        n /= 10\n        second_last_digit = last_digit\n        last_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 2\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpf_06gjsu/tmpf_06gjsu.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae3882d0c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae387fc7b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae387fc7988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae387fc67b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpf_06gjsu                        0x000055a37b463464 <unavailable> + 5220\n5    libc.so.6                          0x00002ae3884bc460 __libc_start_main + 245\n6    tmpf_06gjsu                        0x000055a37b4630a9 <unavailable> + 4265\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var previous = digits[0]\n    var is_increasing = true\n    for digit in digits[1..<digits.count] {\n        if digit == previous {\n            return false\n        }\n        if digit < previous && is_increasing {\n            is_increasing = false\n        } else if digit > previous && !is_increasing {\n            return false\n        }\n        previous = digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmpl1ilawuc.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit != next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpdn4ecw81/tmpdn4ecw81.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab64cb31c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab64c828b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab64c828988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab64c8277b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpdn4ecw81                        0x0000556c8527d23e <unavailable> + 4670\n5    libc.so.6                          0x00002ab64cd1d460 __libc_start_main + 245\n6    tmpdn4ecw81                        0x0000556c8527cef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 2\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpf_06gjsu/tmpf_06gjsu.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae3882d0c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae387fc7b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae387fc7988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae387fc67b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpf_06gjsu                        0x000055a37b463464 <unavailable> + 5220\n5    libc.so.6                          0x00002ae3884bc460 __libc_start_main + 245\n6    tmpf_06gjsu                        0x000055a37b4630a9 <unavailable> + 4265\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = true\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var previous_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == previous_digit {\n            return false\n        }\n        previous_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_ascending = true\n    while n > 0 {\n        let digit = n % 10\n        if is_ascending {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_ascending = !is_ascending\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp0q_oinqr/tmp0q_oinqr.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac369980c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac369677b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac369677988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac3696767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0q_oinqr                        0x000055b3d822f23e <unavailable> + 4670\n5    libc.so.6                          0x00002ac369b6c460 __libc_start_main + 245\n6    tmp0q_oinqr                        0x000055b3d822eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] < digits[i - 1] {\n                is_increasing = false\n            }\n        } else {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpfpsr8dhz.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var lastDigit = n % 10\n    n /= 10\n    var secondLastDigit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != lastDigit && digit != secondLastDigit {\n            return false\n        }\n        secondLastDigit = lastDigit\n        lastDigit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmptsiksjlf/tmptsiksjlf.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b4adea4fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b4ade746b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b4ade746988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b4ade7457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmptsiksjlf                        0x0000563303c5d23e <unavailable> + 4670\n5    libc.so.6                          0x00002b4adec3b460 __libc_start_main + 245\n6    tmptsiksjlf                        0x0000563303c5cef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        n /= 10\n        next_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var str = String(n)\n    var is_undulating = true\n    var i = 0\n    while i < str.count - 1 {\n        if str[i] == str[i + 1] {\n            is_undulating = false\n            break\n        }\n        i += 1\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmprcac755g.swift:8:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprcac755g.swift:8:22: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n                     ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprcac755g.swift:4:9: warning: variable 'str' was never mutated; consider changing to 'let' constant\n    var str = String(n)\n    ~~~ ^\n    let\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit == digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_increasing = true\n    for i in 0..<digits.count - 1 {\n        if is_increasing {\n            if digits[i] > digits[i + 1] {\n                is_increasing = false\n            } else {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i + 1] {\n                is_increasing = true\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpwltoi275/tmpwltoi275.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ade77d16c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ade77a0db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ade77a0d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ade77a0c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpwltoi275                        0x000055c4e52bf67e <unavailable> + 5758\n5    libc.so.6                          0x00002ade77f02460 __libc_start_main + 245\n6    tmpwltoi275                        0x000055c4e52bf339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > last_digit {\n            return false\n        }\n        if !is_increasing && digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpoka683k5/tmpoka683k5.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b18b4dd8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b18b4acfb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b18b4acf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b18b4ace7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpoka683k5                        0x0000558202c1e23e <unavailable> + 4670\n5    libc.so.6                          0x00002b18b4fc4460 __libc_start_main + 245\n6    tmpoka683k5                        0x0000558202c1def9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var prev = 0\n    var curr = 0\n    var next = 0\n    var is_undulating = false\n    for i in 0..<digits.count {\n        prev = curr\n        curr = next\n        next = digits[i]\n        if prev == next {\n            is_undulating = true\n        } else if prev != 0 && next != 0 && prev != next {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmp61_drdkd/tmp61_drdkd.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b77250a9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7724da0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7724da0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7724d9f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp61_drdkd                        0x00005628d398823e <unavailable> + 4670\n5    libc.so.6                          0x00002b7725295460 __libc_start_main + 245\n6    tmp61_drdkd                        0x00005628d3987ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_increasing = true\n    var is_decreasing = true\n    for i in 1..<digits.count {\n        if digits[i] > digits[i-1] {\n            is_decreasing = false\n        } else if digits[i] < digits[i-1] {\n            is_increasing = false\n        }\n    }\n    return is_increasing || is_decreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp4m0pqgs3/tmp4m0pqgs3.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3bca833c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3bca52ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3bca52a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3bca5297b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4m0pqgs3                        0x000055e09ccdc67e <unavailable> + 5758\n5    libc.so.6                          0x00002b3bcaa1f460 __libc_start_main + 245\n6    tmp4m0pqgs3                        0x000055e09ccdc339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmplr86swcg.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && last_digit < current_digit {\n            return false\n        } else if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_undulating = false\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        is_undulating = !is_undulating\n        last_digit = digit\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpozmeluo4/tmpozmeluo4.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0aece3ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0aecb35b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0aecb35988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0aecb347b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpozmeluo4                        0x000055e54cf6f23e <unavailable> + 4670\n5    libc.so.6                          0x00002b0aed02a460 __libc_start_main + 245\n6    tmpozmeluo4                        0x000055e54cf6eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > second_last_digit {\n            return false\n        } else if !is_increasing && digit < second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    n /= 100\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp3fim96tq/tmp3fim96tq.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b02ccb47c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b02cc83eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b02cc83e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b02cc83d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3fim96tq                        0x00005641eefa123e <unavailable> + 4670\n5    libc.so.6                          0x00002b02ccd33460 __libc_start_main + 245\n6    tmp3fim96tq                        0x00005641eefa0ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var i = 1\n    var is_increasing = true\n    while i < digits.count {\n        if digits[i] == digits[i - 1] {\n            return false\n        }\n        if is_increasing {\n            if digits[i] < digits[i - 1] {\n                is_increasing = false\n            }\n        } else {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmp14hu96z8.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_diff = 0\n    var curr_diff = 0\n    while n > 0 {\n        let curr_digit = n % 10\n        let next_digit = (n / 10) % 10\n        curr_diff = curr_digit - next_digit\n        if prev_diff != 0 && prev_diff != curr_diff {\n            return false\n        }\n        prev_diff = curr_diff\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpx3sc0ekj/tmpx3sc0ekj.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8c8e509c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8c8e200b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8c8e200988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8c8e1ff7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpx3sc0ekj                        0x000055aaa112723e <unavailable> + 4670\n5    libc.so.6                          0x00002b8c8e6f5460 __libc_start_main + 245\n6    tmpx3sc0ekj                        0x000055aaa1126ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        current_digit = n % 10\n        if is_increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp5wpug48q/tmp5wpug48q.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8879697c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b887938eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b887938e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b887938d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp5wpug48q                        0x0000564713f5023e <unavailable> + 4670\n5    libc.so.6                          0x00002b8879883460 __libc_start_main + 245\n6    tmp5wpug48q                        0x0000564713f4fef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map{Int(String($0))!}\n    for i in 0..<digits.count-2 {\n        if digits[i] == digits[i+2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpewj6r90w.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map{Int(String($0))!}\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var next_digit = (n / 10) % 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        n /= 10\n        last_digit = next_digit\n        next_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp254tjsyl/tmp254tjsyl.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c43b47c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c4383eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5c4383e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5c4383d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp254tjsyl                        0x000055615f5a523e <unavailable> + 4670\n5    libc.so.6                          0x00002b5c43d33460 __libc_start_main + 245\n6    tmp254tjsyl                        0x000055615f5a4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    while n > 0 {\n        let next = n % 10\n        if last != next {\n            return false\n        }\n        last = next\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpq3s3s03g/tmpq3s3s03g.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7293a31c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7293728b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7293728988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b72937277b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpq3s3s03g                        0x000055931810223e <unavailable> + 4670\n5    libc.so.6                          0x00002b7293c1d460 __libc_start_main + 245\n6    tmpq3s3s03g                        0x0000559318101ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let next_digit = n % 10\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = next_digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1\n        } else if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2\n        } else if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpetdruamy.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing && digits[i] < digits[i - 1] {\n            is_increasing = false\n        } else if !is_increasing && digits[i] > digits[i - 1] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp00v7__pg/tmp00v7__pg.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6b727dfc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6b724d6b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6b724d6988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6b724d57b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp00v7__pg                        0x0000557b241a37c0 <unavailable> + 6080\n5    libc.so.6                          0x00002b6b729cb460 __libc_start_main + 245\n6    tmp00v7__pg                        0x0000557b241a3389 <unavailable> + 5001\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i - 1] {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpe45ra308/tmpe45ra308.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac2f4509c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac2f4200b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac2f4200988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac2f41ff7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpe45ra308                        0x00005623fcfdc67e <unavailable> + 5758\n5    libc.so.6                          0x00002ac2f46f5460 __libc_start_main + 245\n6    tmpe45ra308                        0x00005623fcfdc339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_undulating = true\n    var is_increasing = true\n    while n > 0 {\n        n /= 10\n        let digit = n % 10\n        if digit == last_digit {\n            is_undulating = false\n            break\n        }\n        if is_increasing {\n            if digit > last_digit {\n                is_increasing = false\n            }\n        } else {\n            if digit < last_digit {\n                is_undulating = false\n                break\n            }\n        }\n        last_digit = digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpwgsvzqo8/tmpwgsvzqo8.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b50a82cec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b50a7fc5b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b50a7fc5988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b50a7fc47b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpwgsvzqo8                        0x0000556f49acd23e <unavailable> + 4670\n5    libc.so.6                          0x00002b50a84ba460 __libc_start_main + 245\n6    tmpwgsvzqo8                        0x0000556f49accef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let c1 = s[s.index(s.startIndex, offsetBy: i)]\n        let c2 = s[s.index(s.startIndex, offsetBy: i + 1)]\n        let c3 = s[s.index(s.startIndex, offsetBy: i + 2)]\n        if c1 != c2 && c2 != c3 && c1 != c3 {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpfl0qiknq/tmpfl0qiknq.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1b0d04ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1b0cd41b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1b0cd41988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1b0cd407b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpfl0qiknq                        0x000055642478842e <unavailable> + 5166\n5    libc.so.6                          0x00002b1b0d236460 __libc_start_main + 245\n6    tmpfl0qiknq                        0x00005564247880e9 <unavailable> + 4329\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    while n > 0 {\n        if last_digit != next_digit {\n            return false\n        }\n        last_digit = n % 10\n        n /= 10\n        next_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp_g_c4k1o/tmp_g_c4k1o.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0150331c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0150028b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0150028988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b01500277b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp_g_c4k1o                        0x0000563bfdcf623e <unavailable> + 4670\n5    libc.so.6                          0x00002b015051d460 __libc_start_main + 245\n6    tmp_g_c4k1o                        0x0000563bfdcf5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    n /= 100\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > last_digit {\n            return false\n        }\n        if !is_increasing && digit < last_digit {\n            return false\n        }\n        if digit != last_digit {\n            is_increasing = !is_increasing\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp7iy44qne/tmp7iy44qne.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b34ddf54c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b34ddc4bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b34ddc4b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b34ddc4a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7iy44qne                        0x000055ee6e7912b4 <unavailable> + 4788\n5    libc.so.6                          0x00002b34de140460 __libc_start_main + 245\n6    tmp7iy44qne                        0x000055ee6e790ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i - 1] {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpsg9p0th8.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).compactMap { Int(String($0)) }\n    var is_increasing = true\n    var is_decreasing = true\n    for i in 0..<digits.count - 1 {\n        if digits[i] > digits[i + 1] {\n            is_increasing = false\n        }\n        if digits[i] < digits[i + 1] {\n            is_decreasing = false\n        }\n    }\n    return is_increasing || is_decreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp0z96h9uw/tmp0z96h9uw.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6a10c4ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6a10941b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6a10941988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6a109407b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0z96h9uw                        0x000055581e8ce68e <unavailable> + 5774\n5    libc.so.6                          0x00002b6a10e36460 __libc_start_main + 245\n6    tmp0z96h9uw                        0x000055581e8ce349 <unavailable> + 4937\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var num = n\n    var last_digit = num % 10\n    var current_digit = 0\n    var is_undulating = false\n    while num > 0 {\n        num /= 10\n        current_digit = num % 10\n        if current_digit != last_digit {\n            is_undulating = true\n        }\n        last_digit = current_digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp3d6ciwoh/tmp3d6ciwoh.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae369259c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae368f50b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae368f50988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae368f4f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3d6ciwoh                        0x0000557c6e90f2b4 <unavailable> + 4788\n5    libc.so.6                          0x00002ae369445460 __libc_start_main + 245\n6    tmp3d6ciwoh                        0x0000557c6e90eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpi2kjtpnc/tmpi2kjtpnc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b143431bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1434012b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1434012988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14340117b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2kjtpnc                        0x0000563c37bd623e <unavailable> + 4670\n5    libc.so.6                          0x00002b1434507460 __libc_start_main + 245\n6    tmpi2kjtpnc                        0x0000563c37bd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] != digits[i+2] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmppz8snkce.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    var is_undulating = true\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmp840vlkjj.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit || digit == second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpeqf4ctms/tmpeqf4ctms.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5f2eb19c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5f2e810b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5f2e810988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5f2e80f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeqf4ctms                        0x0000555651beb23e <unavailable> + 4670\n5    libc.so.6                          0x00002b5f2ed05460 __libc_start_main + 245\n6    tmpeqf4ctms                        0x0000555651beaef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits()\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmpdgann5hv.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits()\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    while n > 0 {\n        let d = n % 10\n        if d == last {\n            return false\n        }\n        last = d\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] < digits[i - 1] {\n                is_increasing = false\n            }\n        } else {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpfpsr8dhz.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let a = Int(String(s[s.index(s.startIndex, offsetBy: i)]))!\n        let b = Int(String(s[s.index(s.startIndex, offsetBy: i + 1)]))!\n        let c = Int(String(s[s.index(s.startIndex, offsetBy: i + 2)]))!\n        if (a - b) * (b - c) < 0 {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        } else if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing && digits[i] > digits[i - 1] {\n            return false\n        }\n        if !is_increasing && digits[i] < digits[i - 1] {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpetjxz2ib.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing && digits[i] > digits[i - 1] {\n            continue\n        } else if !is_increasing && digits[i] < digits[i - 1] {\n            continue\n        } else {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp98xjokjk/tmp98xjokjk.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6ff27d1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6ff24c8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6ff24c8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6ff24c77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp98xjokjk                        0x000055fc415806ce <unavailable> + 5838\n5    libc.so.6                          0x00002b6ff29bd460 __libc_start_main + 245\n6    tmp98xjokjk                        0x000055fc41580389 <unavailable> + 5001\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let l = s.count\n    if l < 3 {\n        return false\n    }\n    for i in 1..<l-1 {\n        let a = Int(String(s[s.index(s.startIndex, offsetBy: i-1)]))!\n        let b = Int(String(s[s.index(s.startIndex, offsetBy: i)]))!\n        let c = Int(String(s[s.index(s.startIndex, offsetBy: i+1)]))!\n        if (a < b && b > c) || (a > b && b < c) {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing && digits[i] > digits[i-1] {\n            return false\n        } else if !is_increasing && digits[i] < digits[i-1] {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpm73fql1o.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_increasing = true\n    while n > 0 {\n        n /= 10\n        current_digit = n % 10\n        if current_digit > last_digit {\n            if is_increasing {\n                return false\n            }\n            is_increasing = true\n        } else if current_digit < last_digit {\n            if !is_increasing {\n                return false\n            }\n            is_increasing = false\n        }\n        last_digit = current_digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp3odwoqbk/tmp3odwoqbk.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9488cc2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b94889b9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b94889b9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b94889b87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3odwoqbk                        0x00005592cf03f23e <unavailable> + 4670\n5    libc.so.6                          0x00002b9488eae460 __libc_start_main + 245\n6    tmp3odwoqbk                        0x00005592cf03eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let str = String(n)\n    var i = 0\n    while i < str.count - 2 {\n        let first = Int(String(str[str.index(str.startIndex, offsetBy: i)]))!\n        let second = Int(String(str[str.index(str.startIndex, offsetBy: i + 1)]))!\n        let third = Int(String(str[str.index(str.startIndex, offsetBy: i + 2)]))!\n        if (first < second && second > third) || (first > second && second < third) {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let str = String(n)\n    var result = true\n    for i in 0..<str.count - 2 {\n        let index = str.index(str.startIndex, offsetBy: i)\n        let index2 = str.index(str.startIndex, offsetBy: i + 1)\n        let index3 = str.index(str.startIndex, offsetBy: i + 2)\n        let char1 = str[index]\n        let char2 = str[index2]\n        let char3 = str[index3]\n        if char1 == char2 || char2 == char3 || char1 == char3 {\n            result = false\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpiczzgyrw/tmpiczzgyrw.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b58a6bd4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b58a68cbb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b58a68cb988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b58a68ca7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpiczzgyrw                        0x00005589c59de5be <unavailable> + 5566\n5    libc.so.6                          0x00002b58a6dc0460 __libc_start_main + 245\n6    tmpiczzgyrw                        0x00005589c59de279 <unavailable> + 4729\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let digits = s.characters.map { Int(String($0))! }\n    var prev = digits[0]\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if digits[i] == prev {\n            return false\n        }\n        if is_increasing {\n            if digits[i] < prev {\n                is_increasing = false\n            }\n        } else {\n            if digits[i] > prev {\n                return false\n            }\n        }\n        prev = digits[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpdvz2esf3.swift:5:20: error: 'characters' is unavailable: Please use String directly\n    let digits = s.characters.map { Int(String($0))! }\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] > digits[i-1] {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i-1] {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpodxo0mxu.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var number = n\n    var last_digit = number % 10\n    number /= 10\n    while number > 0 {\n        let digit = number % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        number /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmps_gmei90.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev != curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpzfou62bv/tmpzfou62bv.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae49748ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae497185b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae497185988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae4971847b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpzfou62bv                        0x00005565b9d1a23e <unavailable> + 4670\n5    libc.so.6                          0x00002ae49767a460 __libc_start_main + 245\n6    tmpzfou62bv                        0x00005565b9d19ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = get_digits(n)\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpz_4cms68.swift:4:18: error: cannot find 'get_digits' in scope\n    let digits = get_digits(n)\n                 ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = true\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && last_digit < current_digit {\n            return false\n        } else if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i - 1] {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmpnyh4pt7o/tmpnyh4pt7o.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2a5a18ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2a59e85b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2a59e85988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2a59e847b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpnyh4pt7o                        0x00005561dc56f5ae <unavailable> + 5550\n5    libc.so.6                          0x00002b2a5a37a460 __libc_start_main + 245\n6    tmpnyh4pt7o                        0x00005561dc56f269 <unavailable> + 4713\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    var is_decreasing = true\n    for i in 1..<digits.count {\n        if digits[i] > digits[i-1] {\n            is_decreasing = false\n        }\n        if digits[i] < digits[i-1] {\n            is_increasing = false\n        }\n    }\n    return is_increasing || is_decreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmp5vrb6d5q.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpi2kjtpnc/tmpi2kjtpnc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b143431bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1434012b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1434012988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14340117b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2kjtpnc                        0x0000563c37bd623e <unavailable> + 4670\n5    libc.so.6                          0x00002b1434507460 __libc_start_main + 245\n6    tmpi2kjtpnc                        0x0000563c37bd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}