{
  "name": "mbpp_12_sort_matrix",
  "language": "swift",
  "prompt": "\n/// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nfunc sort_matrix(M: [[Int]]) -> [[Int]] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_matrix(M: [[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]])\nassert(sort_matrix(M: [[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]])\nassert(sort_matrix(M: [[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let tmp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = tmp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count {\n            if j < M.count - 1 && sum_of_row(M, i) > sum_of_row(M, j + 1) {\n                let temp = M[i]\n                M[i] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                swap(&M[j], &M[j+1])\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if sum(M[j]) > sum(M[j + 1]) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    var sums = [Int]()\n    for i in 0..<M.count {\n        sums.append(M[i].reduce(0, +))\n    }\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sums[j] > sums[j+1] {\n                sums.swapAt(j, j+1)\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M"
  ]
}