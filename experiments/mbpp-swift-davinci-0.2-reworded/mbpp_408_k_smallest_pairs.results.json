{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while !pq.isEmpty && k > 0 {\n        result.append(pq.dequeue()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517424,
      "stdout": "",
      "stderr": "/tmp/tmp3x6vxxl0.swift:5:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n             ^~~~~~~~~~~~~\n/tmp/tmp3x6vxxl0.swift:5:14: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3x6vxxl0.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmph5s004p7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "tmpe4polr6j/tmpe4polr6j.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b085efd3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b085eccab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b085ecca988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b085ecc97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpe4polr6j                        0x0000556bc28e3cd0 <unavailable> + 7376\n5    libc.so.6                          0x00002b085f1bf460 __libc_start_main + 245\n6    tmpe4polr6j                        0x0000556bc28e3339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append(value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmp7_qhbem9.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[0][0] + result[0][1] {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "tmpce90ypv6/tmpce90ypv6.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6299f66c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6299c5db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6299c5d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6299c5c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpce90ypv6                        0x0000557ed144acd0 <unavailable> + 7376\n5    libc.so.6                          0x00002b629a152460 __libc_start_main + 245\n6    tmpce90ypv6                        0x0000557ed144a339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    while k > 0 && !queue.isEmpty {\n        result.append(queue.dequeue()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517424,
      "stdout": "",
      "stderr": "/tmp/tmpxz2kzp2g.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~\n/tmp/tmpxz2kzp2g.swift:5:17: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxz2kzp2g.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpudwat9qu.swift:26:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpe8l4my0c.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result.removeLast()\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "tmp7o4yez3h/tmp7o4yez3h.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1fd276ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1fd2465b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1fd2465988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1fd24647b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7o4yez3h                        0x000055593aca0d60 <unavailable> + 7520\n5    libc.so.6                          0x00002b1fd295a460 __libc_start_main + 245\n6    tmp7o4yez3h                        0x000055593aca03c9 <unavailable> + 5065\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(array: [], sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmptdok1f4u.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(array: [], sort: { (a, b) -> Bool in\n               ^~~~\n/tmp/tmptdok1f4u.swift:9:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(array: [], sort: { (a, b) -> Bool in\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmp1wf_p90i.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp1wf_p90i.swift:19:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 || k == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmptmlcdoph.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpf4wrq85s.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (a, b) = heap.extract() {\n            result.append([a, b])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpmaa5lykg.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let minSum = result[0][0] + result[0][1]\n                if sum < minSum {\n                    result.remove(at: 0)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "tmpii6440_d/tmpii6440_d.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7ce2f0ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7ce2c05b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7ce2c05988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7ce2c047b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpii6440_d                        0x000055a42d7c6cd0 <unavailable> + 7376\n5    libc.so.6                          0x00002b7ce30fa460 __libc_start_main + 245\n6    tmpii6440_d                        0x000055a42d7c6339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<Int> = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp20ou1y83.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<Int> = Heap<Int>(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<min(k, result.count)])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i, j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i, j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpv8pa6rft.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmprqu5nfti.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)> { $0.0 + $0.1 < $1.0 + $1.1 }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp91okxnnt.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)> { $0.0 + $0.1 < $1.0 + $1.1 }\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmptbtpa2ap.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    var count = 0\n    while count < k && count < nums1.count * nums2.count {\n        var min_val = Int.max\n        var t = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                t = i\n                min_val = nums1[i] + nums2[index[i]]\n            }\n        }\n        result.append([nums1[t], nums2[index[t]]])\n        index[t] += 1\n        count += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpxqkiq9f5.swift:6:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpxqkiq9f5.swift:16:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp3h27cde5.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    while !queue.isEmpty && k > 0 {\n        result.append(queue.dequeue()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp4but7wkb.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n                ^~~~~~~~~~~~~\n/tmp/tmp4but7wkb.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp7o8iknwh.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpxk31mkxs.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if heap.peek()! > sum {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while heap.count > 0 {\n        result.append([heap.remove()!, heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmphb9n9ovm.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    \n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "/tmp/tmp2ucoak_j.swift:7:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmp2ucoak_j.swift:7:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ucoak_j.swift:16:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append([value])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpdweqbi6o.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "/tmp/tmpovsmxh2o.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpovsmxh2o.swift:8:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i], nums2[j]))\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()!.0 + heap.peek()!.1 {\n                    heap.remove()\n                    heap.insert((nums1[i], nums2[j]))\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "/tmp/tmp2_f3mujo.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "/tmp/tmpt3m_pbp0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpt3m_pbp0.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp7o8iknwh.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.remove() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp4z8rawbd.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n/tmp/tmp4z8rawbd.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.remove() {\n                          ~~~~~^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpmgk4xk93.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpbjugbwvj.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpi_yu8n_i.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpi_yu8n_i.swift:14:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            if queue.count < k {\n                queue.enqueue(pair)\n            } else {\n                if pair.sum < queue.peek()!.sum {\n                    queue.dequeue()\n                    queue.enqueue(pair)\n                }\n            }\n        }\n    }\n    \n    while !queue.isEmpty() {\n        result.append(queue.dequeue()!.toArray())\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpxgba8qen.swift:9:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<Pair>()\n                ^~~~~~~~~~~~~\n/tmp/tmpxgba8qen.swift:12:24: error: cannot find 'Pair' in scope\n            let pair = Pair(nums1[i], nums2[j])\n                       ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.enqueue(pair)\n        }\n    }\n    var i = 0\n    while !queue.isEmpty && i < k {\n        result.append(queue.dequeue()!.toArray())\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp6647oeom.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<Pair>()\n                ^~~~~~~~~~~~~\n/tmp/tmp6647oeom.swift:8:24: error: cannot find 'Pair' in scope\n            let pair = Pair(nums1[i], nums2[j])\n                       ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp527wb9qx.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp_fln08h4.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([sum, index])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpcnntbqor.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.remove() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp4z8rawbd.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n/tmp/tmp4z8rawbd.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.remove() {\n                          ~~~~~^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpqy3yiv9f.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpqy3yiv9f.swift:14:34: error: type of expression is ambiguous without more context\n        if let (value, _) = heap.pop() {\n                            ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpzsn_vknf.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp48vny91r.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpl0ou8jyl.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Pair>()\n               ^~~~\n/tmp/tmpl0ou8jyl.swift:8:25: error: cannot find 'Pair' in scope\n            heap.insert(Pair(nums1[i], nums2[j]))\n                        ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (e1, e2) -> Bool in\n        return e1.0 + e1.1 < e2.0 + e2.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let e = heap.pop() {\n            result.append([e.0, e.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpksb9y_dp.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (e1, e2) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i, j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i, j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpn15ytvzk.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    for _ in 0..<k {\n        guard let pair = heap.pop() else {\n            break\n        }\n        result.append(pair)\n        if pair[2] < nums2.count - 1 {\n            heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122958,
      "stdout": "",
      "stderr": "/tmp/tmp8ssy02id.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmp8ssy02id.swift:8:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp4isdoeto.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((i, j, nums1[i] + nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (i, j, _) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpbj7174ww.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n               ^~~~\n/tmp/tmpbj7174ww.swift:12:33: error: type of expression is ambiguous without more context\n        if let (i, j, _) = heap.pop() {\n                           ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp3mjww1gz.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpxmya735g.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpxmya735g.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpqmw70va_.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = 0\n    var i = 0\n    var j = 0\n    while index < k && i < nums1.count && j < nums2.count {\n        let sum = nums1[i] + nums2[j]\n        if i + 1 < nums1.count && j + 1 < nums2.count {\n            let sum1 = nums1[i] + nums2[j + 1]\n            let sum2 = nums1[i + 1] + nums2[j]\n            if sum1 < sum2 {\n                if sum1 < sum {\n                    result.append([nums1[i], nums2[j + 1]])\n                    j += 1\n                } else {\n                    result.append([nums1[i], nums2[j]])\n                }\n            } else {\n                if sum2 < sum {\n                    result.append([nums1[i + 1], nums2[j]])\n                    i += 1\n                } else {\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        } else if i + 1 < nums1.count {\n            let sum2 = nums1[i + 1] + nums2[j]\n            if sum2 < sum {\n                result.append([nums1[i + 1], nums2[j]])\n                i += 1\n            } else {\n                result.append([nums1[i], nums2[j]])\n            }\n        } else if j + 1 < nums2.count {\n            let sum1 = nums1[i] + nums2[j + 1]\n            if sum1 < sum {\n                result.append([nums1[i], nums2[j + 1]])\n                j += 1\n            } else {\n                result.append([nums1[i], nums2[j]])\n            }\n        } else {\n            result.append([nums1[i], nums2[j]])\n        }\n        index += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpo16ljmk0/tmpo16ljmk0.swift:65: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1a74a36c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1a7472db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1a7472d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1a7472c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo16ljmk0                        0x00005649cf80f60c <unavailable> + 5644\n5    libc.so.6                          0x00002b1a74c22460 __libc_start_main + 245\n6    tmpo16ljmk0                        0x00005649cf80f159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmplrr5gn1d.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmpi_yu8n_i.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpi_yu8n_i.swift:14:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp3sk6v_ll.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_sum = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_sum {\n                min_sum = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmptvylfcwa.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmptvylfcwa.swift:12:34: error: type of expression is ambiguous without more context\n        if let (value, _) = heap.pop() {\n                            ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        var i = 0\n        var j = 0\n        while i < nums1.count && j < nums2.count {\n            if nums1[i] + nums2[j] == sum {\n                result.append([nums1[i], nums2[j]])\n                i += 1\n                j += 1\n            } else if nums1[i] + nums2[j] < sum {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp1s8g5gni.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    \n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        heap.insert((nums1[i] + nums2[0], i))\n    }\n    \n    while result.count < k && !heap.isEmpty {\n        let (sum, i) = heap.remove()!\n        result.append([nums1[i], nums2[0]])\n        \n        if nums2.count > 1 {\n            heap.insert((nums1[i] + nums2[1], i))\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmptmt6fdlq.swift:10:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpppr7y8fu.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp8afkqeuh.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            res.append([pair.0, pair.1])\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpnmh22pti.swift:8:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n             ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmprj405fph.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var pq = PriorityQueue<[Int]>(sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            result.append(pair)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "/tmp/tmph7ov90gl.swift:9:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<[Int]>(sort: { (a, b) -> Bool in\n             ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    \n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpf80dt37r.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpf80dt37r.swift:18:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var index = [0, 0]\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: nums2.count), count: nums1.count)\n    for _ in 0..<k {\n        var min = Int.max\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if !visited[i][j] && nums1[i] + nums2[j] < min {\n                    min = nums1[i] + nums2[j]\n                    index = [i, j]\n                }\n            }\n        }\n        if min == Int.max { break }\n        result.append([nums1[index[0]], nums2[index[1]]])\n        visited[index[0]][index[1]] = true\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    while k > 0 {\n        result.append(heap.pop()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpjqtypmlf.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n              ^~~~\n/tmp/tmpjqtypmlf.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpldp72vov.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpyr7pin5t.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpjf0wit7_.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append(sum)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp1z16tolk.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (num1, num2) = heap.remove()!\n        result.append([num1, num2])\n        if num2 != nums2.last! {\n            heap.insert((num1, nums2[nums2.firstIndex(of: num2)! + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp58tnu2x9.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var queue: PriorityQueue<[Int]> = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpnat2skfw.swift:8:16: error: cannot find type 'PriorityQueue' in scope\n    var queue: PriorityQueue<[Int]> = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n               ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(ascending: true) { $0.0 + $0.1 < $1.0 + $1.1 }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpjkyy06_9.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(ascending: true) { $0.0 + $0.1 < $1.0 + $1.1 }\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n            if pair[2] < nums2.count - 1 {\n                heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n            }\n        } else {\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122959,
      "stdout": "",
      "stderr": "/tmp/tmpjg08exhd.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpjg08exhd.swift:8:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.1, heap.remove()!.1])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp84kmp52r.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "tmp853ax31z/tmp853ax31z.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9337725c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b933741cb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b933741c988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b933741b7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp853ax31z                        0x0000561fa451960c <unavailable> + 5644\n5    libc.so.6                          0x00002b9337911460 __libc_start_main + 245\n6    tmp853ax31z                        0x0000561fa4519159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpf8th93f_.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp8cmvdbaf.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    \n    let m = nums1.count\n    let n = nums2.count\n    var index = [Int](repeating: 0, count: m)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var t = 0\n        for i in 0..<m {\n            if index[i] < n && nums1[i] + nums2[index[i]] < min_val {\n                t = i\n                min_val = nums1[i] + nums2[index[i]]\n            }\n        }\n        \n        if index[t] < n {\n            result.append([nums1[t], nums2[index[t]]])\n            index[t] += 1\n        } else {\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert(sum)\n            if heap.count > k {\n                heap.pop()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[0], nums2[heap.pop()!]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "/tmp/tmpn83vygnf.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "/tmp/tmp5wxd2qoq.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let min = heap.extractMin() {\n            result.append([min])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "/tmp/tmp569w98x4.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "/tmp/tmpr5k9iuj7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let item = queue.dequeue() {\n            result.append([item.0, item.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp9vzregbn.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmptvyr_jvi.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "/tmp/tmp9kt6f_q3.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp9kt6f_q3.swift:21:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "/tmp/tmpis344ggz.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp_fln08h4.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<Pair> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "/tmp/tmprqtf3gpb.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<Pair> = Heap(sort: <, elements: [])\n              ^~~~\n/tmp/tmprqtf3gpb.swift:8:25: error: cannot find 'Pair' in scope\n            heap.insert(Pair(nums1[i], nums2[j]))\n                        ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let pair = heap.remove()!\n        result.append([pair.0, pair.1])\n        if pair.1 < nums2.last! {\n            heap.insert((pair.0, pair.1 + 1))\n        }\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122953,
      "stdout": "",
      "stderr": "/tmp/tmpg5tq7f6o.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpg5tq7f6o.swift:18:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<Pair> = Heap<Pair>(sort: { $0.sum < $1.sum })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.num1, pair.num2])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "/tmp/tmpduynptrp.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<Pair> = Heap<Pair>(sort: { $0.sum < $1.sum })\n              ^~~~\n/tmp/tmpduynptrp.swift:8:25: error: cannot find 'Pair' in scope\n            heap.insert(Pair(nums1[i], nums2[j]))\n                        ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "/tmp/tmpxj7t9m27.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122953,
      "stdout": "",
      "stderr": "/tmp/tmpwxrlg4tb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpwxrlg4tb.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (x, y) = heap.remove()!\n        result.append([x, y])\n        if y != nums2.last! {\n            let next = nums2.firstIndex(of: y)! + 1\n            heap.insert((x, nums2[next]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "/tmp/tmpudujoyvf.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp_m5b8c8x.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp_m5b8c8x.swift:20:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = pq.dequeue() {\n            res.append(pair)\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "/tmp/tmp45leagon.swift:8:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n             ^~~~~~~~~~~~~\n/tmp/tmp45leagon.swift:8:14: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var pq = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.pop()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty() {\n        result.append([nums1[0], nums2[heap.pop()! - nums1[0]]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpeyva_6cn.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replaceTop((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw1ucen3e.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if index < k {\n                result.append([nums1[i], nums2[j]])\n                index += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpja5sc8dg/tmpja5sc8dg.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b31ab552c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b31ab249b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b31ab249988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b31ab2487b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpja5sc8dg                        0x0000559b6078fc80 <unavailable> + 7296\n5    libc.so.6                          0x00002b31ab73e460 __libc_start_main + 245\n6    tmpja5sc8dg                        0x0000559b6078f2e9 <unavailable> + 4841\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpe8l4my0c.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp3mjww1gz.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while k > 0 {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpmxc12d_4.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n/tmp/tmpmxc12d_4.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append(value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpplyae9a4.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                var max = result[0][0] + result[0][1]\n                var maxIndex = 0\n                for index in 0..<result.count {\n                    let sum = result[index][0] + result[index][1]\n                    if sum > max {\n                        max = sum\n                        maxIndex = index\n                    }\n                }\n                let sum = nums1[i] + nums2[j]\n                if sum < max {\n                    result[maxIndex] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpjxly38mu/tmpjxly38mu.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0b473fcc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0b470f3b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0b470f3988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0b470f27b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjxly38mu                        0x00005608d791ecd0 <unavailable> + 7376\n5    libc.so.6                          0x00002b0b475e8460 __libc_start_main + 245\n6    tmpjxly38mu                        0x00005608d791e339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpyr7pin5t.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "/tmp/tmpwq50olzr.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~\n/tmp/tmpwq50olzr.swift:5:17: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        res.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            heap.insert((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122957,
      "stdout": "",
      "stderr": "/tmp/tmpgpzi2co_.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpgpzi2co_.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: nums2.count), count: nums1.count)\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    heap.insert((0, 0))\n    visited[0][0] = true\n    \n    while !heap.isEmpty && result.count < k {\n        let (i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n        \n        if i + 1 < nums1.count && !visited[i + 1][j] {\n            heap.insert((i + 1, j))\n            visited[i + 1][j] = true\n        }\n        \n        if j + 1 < nums2.count && !visited[i][j + 1] {\n            heap.insert((i, j + 1))\n            visited[i][j + 1] = true\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpjpoxbhtg.swift:6:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.remove() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmplucbtanr.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i] + nums2[j], i + j))\n            } else {\n                if heap.peek()! > (nums1[i] + nums2[j], i + j) {\n                    heap.remove()\n                    heap.insert((nums1[i] + nums2[j], i + j))\n                }\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        result.append([heap.remove()!.0 - heap.remove()!.1, heap.remove()!.1])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp81qelh82.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.extract() {\n            result.append([val])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpsly1ozhf.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpgk607g64.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpgk607g64.swift:21:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp2qbdwdeo.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            if nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append([heap.remove()!.0, heap.remove()!.0])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpx8uy66sa.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp66sowkna.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let item = heap.pop() {\n            result.append([item.0, item.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122957,
      "stdout": "",
      "stderr": "/tmp/tmpgyf974eq.swift:6:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpokaq21_n/tmpokaq21_n.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6b9cc37c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6b9c92eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6b9c92e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6b9c92d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpokaq21_n                        0x0000562c0b7a260c <unavailable> + 5644\n5    libc.so.6                          0x00002b6b9ce23460 __libc_start_main + 245\n6    tmpokaq21_n                        0x0000562c0b7a2159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = MinHeap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            heap.insert(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpnkwjli5f.swift:8:16: error: cannot find 'MinHeap' in scope\n    var heap = MinHeap<Pair>()\n               ^~~~~~~\n/tmp/tmpnkwjli5f.swift:11:24: error: cannot find 'Pair' in scope\n            let pair = Pair(nums1[i], nums2[j])\n                       ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp6budx_qb/tmp6budx_qb.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b14fedafc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b14feaa6b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b14feaa6988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14feaa57b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp6budx_qb                        0x000055c5cea865cc <unavailable> + 5580\n5    libc.so.6                          0x00002b14fef9b460 __libc_start_main + 245\n6    tmp6budx_qb                        0x000055c5cea86119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < k && index1 < nums1.count && index2 < nums2.count {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n        count += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpdmi91z5v/tmpdmi91z5v.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad90b683c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad90b37ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad90b37a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad90b3797b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpdmi91z5v                        0x000056312e1ca5cc <unavailable> + 5580\n5    libc.so.6                          0x00002ad90b86f460 __libc_start_main + 245\n6    tmpdmi91z5v                        0x000056312e1ca119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if sum < max![0] + max![1] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "tmpw2p26elk/tmpw2p26elk.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad5856c7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad5853beb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad5853be988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad5853bd7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpw2p26elk                        0x0000558f6d6abda0 <unavailable> + 7584\n5    libc.so.6                          0x00002ad5858b3460 __libc_start_main + 245\n6    tmpw2p26elk                        0x0000558f6d6ab409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122965,
      "stdout": "",
      "stderr": "/tmp/tmpr5_1px1k.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpr5_1px1k.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[0][0] + result[0][1] {\n                    result.removeFirst()\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n            result.sort { (a, b) -> Bool in\n                return a[0] + a[1] < b[0] + b[1]\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpe8l4my0c.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return nums1[a.0] + nums2[a.1] < nums1[b.0] + nums2[b.1]\n    })\n    for i in 0..<nums1.count {\n        heap.push((i, 0))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((i, j + 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpeinf8efd.swift:8:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpb2e148si.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp2snhkf8y.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122966,
      "stdout": "",
      "stderr": "/tmp/tmp36yo0y1w.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmp36yo0y1w.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([sum, index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpjz0r_qy4.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.enqueue(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpzaxmj5jy.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<Pair>()\n                ^~~~~~~~~~~~~\n/tmp/tmpzaxmj5jy.swift:8:24: error: cannot find 'Pair' in scope\n            let pair = Pair(nums1[i], nums2[j])\n                       ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let pair = Pair(nums1[i], nums2[j])\n            queue.insert(pair)\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.pop() {\n            result.append([pair.a, pair.b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp3jwfii7i.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<Pair>()\n                ^~~~~~~~~~~~~\n/tmp/tmp3jwfii7i.swift:8:24: error: cannot find 'Pair' in scope\n            let pair = Pair(nums1[i], nums2[j])\n                       ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpcdmpr9nl.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var pq = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    \n    while !pq.isEmpty && k > 0 {\n        result.append(pq.dequeue()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpqju94742.swift:5:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<[Int]>(ascending: true) { (a, b) -> Bool in\n             ^~~~~~~~~~~~~\n/tmp/tmpqju94742.swift:17:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[heap.peek()!.1], nums2[heap.peek()!.1]])\n        heap.remove()\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpjf013214.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp0vacb9eg.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<Int> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.replace(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.peek()!, heap.peek()! - heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpov_677dh.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<Int> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in nums1 {\n        for j in nums2 {\n            heap.insert((i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (i, j) = heap.pop() {\n            result.append([i, j])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpvi9sm1d6.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min {\n                min = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min == Int.max {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count { continue }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.pop() {\n            result.append(val)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp_qr7ga2r.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp9zpxad5b.swift:25:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}