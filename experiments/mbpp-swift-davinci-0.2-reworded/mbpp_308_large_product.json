{
  "name": "mbpp_308_large_product",
  "language": "swift",
  "prompt": "\n/// Write a function to find the specified number of largest products from two given arrays, selecting one factor from each array.\nfunc large_product(nums1: [Int], nums2: [Int], N: Int) -> [Int] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 3) == [60, 54, 50])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 4) == [60, 54, 50, 48])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 5) == [60, 54, 50, 48, 45])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 * num2)\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            pq.enqueue(n1 * n2)\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.insert(product)\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if product > max {\n                result.append(product)\n                max = product\n            }\n        }\n    }\n    return result.sorted(by: >).prefix(N).sorted()",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if heap.peek()! < product {\n                heap.replace(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n        }\n    }\n    for _ in 0..<N {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    return Array(maxHeap)",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if maxHeap.count < N {\n                maxHeap.insert(nums1[i] * nums2[j])\n            } else if nums1[i] * nums2[j] < maxHeap.peek()! {\n                maxHeap.insert(nums1[i] * nums2[j])\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result"
  ]
}