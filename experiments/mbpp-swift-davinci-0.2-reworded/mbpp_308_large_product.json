{
  "name": "mbpp_308_large_product",
  "language": "swift",
  "prompt": "\n/// Write a function to find the specified number of largest products from two given arrays, selecting one factor from each array.\nfunc large_product(nums1: [Int], nums2: [Int], N: Int) -> [Int] {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 3) == [60, 54, 50])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 4) == [60, 54, 50, 48])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 5) == [60, 54, 50, 48, 45])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 * num2)\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            pq.enqueue(n1 * n2)\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.insert(product)\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if product > max {\n                result.append(product)\n                max = product\n            }\n        }\n    }\n    return result.sorted(by: >).prefix(N).sorted()",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if heap.peek()! < product {\n                heap.replace(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n        }\n    }\n    for _ in 0..<N {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    return Array(maxHeap)",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if maxHeap.count < N {\n                maxHeap.insert(nums1[i] * nums2[j])\n            } else if nums1[i] * nums2[j] < maxHeap.peek()! {\n                maxHeap.insert(nums1[i] * nums2[j])\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 * num2)\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if max_heap.count < N {\n                max_heap.insert(nums1[i] * nums2[j])\n            } else if nums1[i] * nums2[j] < max_heap.peek()! {\n                max_heap.replace(nums1[i] * nums2[j])\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1\n    var nums2 = nums2\n    nums1.sort()\n    nums2.sort()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i - 1] * nums2[j - 1] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i - 1] * nums2[j - 1])\n            i -= 1\n            j -= 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n            count += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n            count += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max = 0\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > max {\n            result.append(nums1[i] * nums2[j])\n            max = nums1[i] * nums2[j]\n        }\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        let product = nums1[i] * nums2[j]\n        if nums1[i] > nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n        if result.count == 0 {\n            result.append(product)\n        } else {\n            if product < result.last! {\n                result.append(product)\n            } else {\n                var k = result.count - 1\n                while k >= 0 && result[k] > product {\n                    k -= 1\n                }\n                result.insert(product, at: k + 1)\n            }\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    \n    for _ in 0..<N {\n        max1.append(nums1.max()!)\n        max2.append(nums2.max()!)\n        nums1.remove(at: nums1.index(of: max1.last!)!)\n        nums2.remove(at: nums2.index(of: max2.last!)!)\n    }\n    \n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    \n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n        }\n    }\n    for _ in 0..<N {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            maxHeap.insert(product)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for i in 0..<nums1.count {\n        if max1.count < N {\n            max1.append(nums1[i])\n        } else {\n            max1.sort()\n            if nums1[i] > max1[0] {\n                max1[0] = nums1[i]\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        if max2.count < N {\n            max2.append(nums2[i])\n        } else {\n            max2.sort()\n            if nums2[i] > max2[0] {\n                max2[0] = nums2[i]\n            }\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    return result",
    "    var result = [Int]()\n    var minHeap = MinHeap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if minHeap.count < N {\n                minHeap.insert(product)\n            } else if product > minHeap.peek()! {\n                minHeap.remove()\n                minHeap.insert(product)\n            }\n        }\n    }\n    while !minHeap.isEmpty() {\n        result.append(minHeap.remove()!)\n    }\n    return result.reversed()",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var max_heap = Heap<Int>(sort: >)\n    var result = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.replace(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product < pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int](repeating: 0, count: N)\n    var max2 = [Int](repeating: 0, count: N)\n    for i in 0..<nums1.count {\n        for j in 0..<N {\n            if nums1[i] > max1[j] {\n                for k in (j..<N).reversed() {\n                    max1[k] = max1[k-1]\n                }\n                max1[j] = nums1[i]\n                break\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        for j in 0..<N {\n            if nums2[i] > max2[j] {\n                for k in (j..<N).reversed() {\n                    max2[k] = max2[k-1]\n                }\n                max2[j] = nums2[i]\n                break\n            }\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while let max = maxHeap.pop() {\n        result.append(max)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var n = N\n    while n > 0 {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i + 1] * nums2[j])\n            i += 1\n        }\n        n -= 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push(product)\n            } else if product > pq.peek()! {\n                pq.pop()\n                pq.push(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        res.append(pq.pop()!)\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0\n    var index2 = 0\n    var max1 = Int.min\n    var max2 = Int.min\n    var maxIndex1 = 0\n    var maxIndex2 = 0\n    var count = 0\n    while count < N {\n        max1 = Int.min\n        max2 = Int.min\n        for i in index1..<nums1.count {\n            if nums1[i] > max1 {\n                max1 = nums1[i]\n                maxIndex1 = i\n            }\n        }\n        for i in index2..<nums2.count {\n            if nums2[i] > max2 {\n                max2 = nums2[i]\n                maxIndex2 = i\n            }\n        }\n        result.append(max1 * max2)\n        index1 = maxIndex1\n        index2 = maxIndex2\n        count += 1\n    }\n    return result",
    "    var results = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        results.append(maxHeap.remove()!)\n    }\n    return results",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var pq = PriorityQueue<Int>(ascending: false)\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            pq.enqueue(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            pq.enqueue(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    while i < nums1.count {\n        pq.enqueue(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        pq.enqueue(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    for _ in 0..<N {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result: [Int] = []\n    var max_heap: Heap<Int> = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.replace(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty() {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        var max = Int.min\n        var max_i = 0\n        var max_j = 0\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if nums1[i] * nums2[j] > max {\n                    max = nums1[i] * nums2[j]\n                    max_i = i\n                    max_j = j\n                }\n            }\n        }\n        result.append(max)\n        nums1[max_i] = Int.min\n        nums2[max_j] = Int.min\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for i in 0..<nums1.count {\n        if max1.count < N {\n            max1.append(nums1[i])\n        } else {\n            if nums1[i] > max1[0] {\n                max1.remove(at: 0)\n                max1.append(nums1[i])\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        if max2.count < N {\n            max2.append(nums2[i])\n        } else {\n            if nums2[i] > max2[0] {\n                max2.remove(at: 0)\n                max2.append(nums2[i])\n            }\n        }\n    }\n    max1.sort()\n    max2.sort()\n    for i in 0..<N {\n        result.append(max1[i] * max2[N - i - 1])\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    \n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.insert(product)\n                max_heap.remove()\n            }\n        }\n    }\n    \n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int](repeating: 0, count: N)\n    var max2 = [Int](repeating: 0, count: N)\n    for i in 0..<nums1.count {\n        for j in 0..<N {\n            if nums1[i] > max1[j] {\n                for k in (j..<N).reversed() {\n                    max1[k] = max1[k - 1]\n                }\n                max1[j] = nums1[i]\n                break\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        for j in 0..<N {\n            if nums2[i] > max2[j] {\n                for k in (j..<N).reversed() {\n                    max2[k] = max2[k - 1]\n                }\n                max2[j] = nums2[i]\n                break\n            }\n        }\n    }\n    for i in 0..<N {\n        for j in 0..<N {\n            result.append(max1[i] * max2[j])\n        }\n    }\n    return result.sorted(by: >)",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1\n    var nums2 = nums2\n    nums1.sort()\n    nums2.sort()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.push(nums1[i] * nums2[j])\n            if pq.count > N {\n                pq.pop()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        res.append(pq.pop()!)\n    }\n    return res",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n        if !result.contains(product) {\n            result.append(product)\n            count += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                _ = maxHeap.pop()\n                maxHeap.insert(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] > nums2[j] {\n            max1.append(nums1[i])\n            i += 1\n        } else {\n            max2.append(nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        max1.append(nums1[i])\n        i += 1\n    }\n    while j < nums2.count {\n        max2.append(nums2[j])\n        j += 1\n    }\n    i = 0\n    j = 0\n    while i < max1.count && j < max2.count && result.count < N {\n        if max1[i] * max2[j] > max1[i] * max2[j + 1] {\n            result.append(max1[i] * max2[j])\n            j += 1\n        } else {\n            result.append(max1[i] * max2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.enqueue(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.dequeue()\n                maxHeap.enqueue(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.enqueue(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.dequeue()\n                maxHeap.enqueue(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < N {\n        let product = nums1[index1] * nums2[index2]\n        if product > nums1[index1] * nums2[index2 + 1] {\n            result.append(product)\n            index2 += 1\n        } else {\n            result.append(nums1[index1 + 1] * nums2[index2])\n            index1 += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for i in 0..<nums1.count {\n        if max1.count < N {\n            max1.append(nums1[i])\n        } else {\n            max1.sort()\n            if nums1[i] > max1[0] {\n                max1[0] = nums1[i]\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        if max2.count < N {\n            max2.append(nums2[i])\n        } else {\n            max2.sort()\n            if nums2[i] > max2[0] {\n                max2[0] = nums2[i]\n            }\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                _ = maxHeap.pop()\n                maxHeap.insert(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i - 1] * nums2[j - 1] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i - 1] * nums2[j - 1])\n            i -= 1\n            j -= 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for _ in 0..<N {\n        max1.append(0)\n        max2.append(0)\n    }\n    for i in 0..<nums1.count {\n        for j in 0..<N {\n            if nums1[i] > max1[j] {\n                for k in (j..<N).reversed() {\n                    max1[k] = max1[k-1]\n                }\n                max1[j] = nums1[i]\n                break\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        for j in 0..<N {\n            if nums2[i] > max2[j] {\n                for k in (j..<N).reversed() {\n                    max2[k] = max2[k-1]\n                }\n                max2[j] = nums2[i]\n                break\n            }\n        }\n    }\n    for i in 0..<N {\n        for j in 0..<N {\n            result.append(max1[i] * max2[j])\n        }\n    }\n    return result.sorted(by: >)",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            max_heap.insert(nums1[i] * nums2[j])\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.insert(product)\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var res = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            res.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            res.append(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        res.append(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        res.append(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    return res.sorted().reversed()[0..<N]",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                _ = maxHeap.pop()\n                maxHeap.insert(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i - 1] * nums2[j - 1] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i - 1] * nums2[j - 1])\n            i -= 1\n            j -= 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < N {\n        let product = nums1[index1] * nums2[index2]\n        if product > nums1[index1] * nums2[index2 + 1] && product > nums1[index1 + 1] * nums2[index2] {\n            result.append(product)\n            index1 += 1\n            index2 += 1\n        } else if nums1[index1] * nums2[index2 + 1] > nums1[index1 + 1] * nums2[index2] {\n            result.append(nums1[index1] * nums2[index2 + 1])\n            index2 += 1\n        } else {\n            result.append(nums1[index1 + 1] * nums2[index2])\n            index1 += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        let product = nums1[i] * nums2[j]\n        if nums1[i] > nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n        if result.count == 0 || product != result.last! {\n            result.append(product)\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n        result.append(product)\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue(nums1[i] * nums2[j])\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        res.append(pq.dequeue()!)\n    }\n    return res",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for i in 0..<N {\n        max1.append(nums1[i])\n        max2.append(nums2[i])\n    }\n    for i in N..<nums1.count {\n        if nums1[i] > max1[0] {\n            max1[0] = nums1[i]\n            max1.sort()\n        }\n    }\n    for i in N..<nums2.count {\n        if nums2[i] > max2[0] {\n            max2[0] = nums2[i]\n            max2.sort()\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[N-1-i])\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n        if result.count == N {\n            break\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.replace(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue(nums1[i] * nums2[j])\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<String>()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n            let key = \"\\(num1),\\(num2)\"\n            if !visited.contains(key) {\n                visited.insert(key)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            max_heap.insert(nums1[i] * nums2[j])\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    let sorted1 = nums1.sorted(by: >)\n    let sorted2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < sorted1.count && j < sorted2.count && result.count < N {\n        if sorted1[i] * sorted2[j] > sorted1[i] * sorted2[j + 1] {\n            result.append(sorted1[i] * sorted2[j])\n            j += 1\n        } else {\n            result.append(sorted1[i] * sorted2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.enqueue(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.dequeue()\n                maxHeap.enqueue(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push(product)\n            } else if pq.peek()! < product {\n                pq.pop()\n                pq.push(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        res.append(pq.pop()!)\n    }\n    return res",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.replace(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            res.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            res.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return res",
    "    var result = [Int]()\n    var max1 = [Int](repeating: 0, count: N)\n    var max2 = [Int](repeating: 0, count: N)\n    for num in nums1 {\n        for i in 0..<N {\n            if num > max1[i] {\n                for j in (i+1..<N).reversed() {\n                    max1[j] = max1[j-1]\n                }\n                max1[i] = num\n                break\n            }\n        }\n    }\n    for num in nums2 {\n        for i in 0..<N {\n            if num > max2[i] {\n                for j in (i+1..<N).reversed() {\n                    max2[j] = max2[j-1]\n                }\n                max2[i] = num\n                break\n            }\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    return result",
    "    let sorted1 = nums1.sorted(by: >)\n    let sorted2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if sorted1[i] * sorted2[j] > sorted1[i] * sorted2[j+1] {\n            result.append(sorted1[i] * sorted2[j])\n            j += 1\n        } else {\n            result.append(sorted1[i] * sorted2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.replace(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result: [Int] = []\n    var max1: Int = 0\n    var max2: Int = 0\n    for i in 0..<nums1.count {\n        if nums1[i] > max1 {\n            max1 = nums1[i]\n        }\n    }\n    for i in 0..<nums2.count {\n        if nums2[i] > max2 {\n            max2 = nums2[i]\n        }\n    }\n    var max: Int = max1 * max2\n    var index1: Int = 0\n    var index2: Int = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if nums1[i] * nums2[j] > max {\n                max = nums1[i] * nums2[j]\n                index1 = i\n                index2 = j\n            }\n        }\n    }\n    result.append(max)\n    for _ in 1..<N {\n        max = 0\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if nums1[i] * nums2[j] > max && (i != index1 || j != index2) {\n                    max = nums1[i] * nums2[j]\n                    index1 = i\n                    index2 = j\n                }\n            }\n        }\n        result.append(max)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        result.append(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        result.append(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    return result.sorted(by: >).prefix(N).sorted()",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if maxHeap.count < N {\n                maxHeap.insert(nums1[i] * nums2[j])\n            } else if nums1[i] * nums2[j] < maxHeap.peek()! {\n                maxHeap.replace(nums1[i] * nums2[j])\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            max_heap.insert(nums1[i] * nums2[j])\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            max_heap.insert(num1 * num2)\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var heap = Heap<Int>(sort: >)\n    while i < nums1.count && j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        if nums1[i] > nums2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    while i < nums1.count {\n        let product = nums1[i] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        i += 1\n    }\n    while j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        j += 1\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] * nums2[j] > nums1[i - 1] * nums2[j - 1] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n            j -= 1\n        } else {\n            result.append(nums1[i - 1] * nums2[j - 1])\n            i -= 1\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max = 0\n    var maxIndex = 0\n    var max2 = 0\n    var maxIndex2 = 0\n    var max3 = 0\n    var maxIndex3 = 0\n    var max4 = 0\n    var maxIndex4 = 0\n    for i in 0..<nums1.count {\n        if nums1[i] > max {\n            max = nums1[i]\n            maxIndex = i\n        }\n    }\n    for i in 0..<nums2.count {\n        if nums2[i] > max2 {\n            max2 = nums2[i]\n            maxIndex2 = i\n        }\n    }\n    for i in 0..<nums1.count {\n        if nums1[i] > max3 && i != maxIndex {\n            max3 = nums1[i]\n            maxIndex3 = i\n        }\n    }\n    for i in 0..<nums2.count {\n        if nums2[i] > max4 && i != maxIndex2 {\n            max4 = nums2[i]\n            maxIndex4 = i\n        }\n    }\n    result.append(max * max2)\n    result.append(max * max4)\n    result.append(max3 * max2)\n    result.append(max3 * max4)\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int](repeating: 0, count: N)\n    var max2 = [Int](repeating: 0, count: N)\n    for i in 0..<nums1.count {\n        for j in 0..<N {\n            if nums1[i] > max1[j] {\n                for k in (j..<N).reversed() {\n                    max1[k] = max1[k-1]\n                }\n                max1[j] = nums1[i]\n                break\n            }\n        }\n    }\n    for i in 0..<nums2.count {\n        for j in 0..<N {\n            if nums2[i] > max2[j] {\n                for k in (j..<N).reversed() {\n                    max2[k] = max2[k-1]\n                }\n                max2[j] = nums2[i]\n                break\n            }\n        }\n    }\n    for i in 0..<N {\n        for j in 0..<N {\n            result.append(max1[i] * max2[j])\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0\n    var index2 = 0\n    var max1 = 0\n    var max2 = 0\n    var max = 0\n    for _ in 0..<N {\n        max1 = 0\n        max2 = 0\n        max = 0\n        for i in 0..<nums1.count {\n            if nums1[i] > max1 {\n                max1 = nums1[i]\n                index1 = i\n            }\n        }\n        for i in 0..<nums2.count {\n            if nums2[i] > max2 {\n                max2 = nums2[i]\n                index2 = i\n            }\n        }\n        max = max1 * max2\n        result.append(max)\n        nums1[index1] = 0\n        nums2[index2] = 0\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<String>()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            let key = \"\\(num1),\\(num2)\"\n            if !visited.contains(key) {\n                visited.insert(key)\n                if maxHeap.count < N {\n                    maxHeap.insert(product)\n                } else if let max = maxHeap.peek(), product > max {\n                    _ = maxHeap.pop()\n                    maxHeap.insert(product)\n                }\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(product)\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0\n    var index2 = 0\n    for _ in 0..<N {\n        var max = Int.min\n        var maxIndex1 = 0\n        var maxIndex2 = 0\n        for i in index1..<nums1.count {\n            for j in index2..<nums2.count {\n                if nums1[i] * nums2[j] > max {\n                    max = nums1[i] * nums2[j]\n                    maxIndex1 = i\n                    maxIndex2 = j\n                }\n            }\n        }\n        result.append(max)\n        index1 = maxIndex1\n        index2 = maxIndex2\n    }\n    return result"
  ]
}