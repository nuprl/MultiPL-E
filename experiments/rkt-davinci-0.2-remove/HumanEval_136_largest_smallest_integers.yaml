name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a tuple (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as None.\n;; Examples:\n(define (largest_smallest_integers lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (define (helper lst neg-max pos-min)\n    (cond\n      [(empty? lst)\
    \ (values neg-max pos-min)]\n      [(and (negative? (first lst))\n           \
    \ (or (not neg-max)\n                (< (first lst) neg-max)))\n       (helper\
    \ (rest lst) (first lst) pos-min)]\n      [(and (positive? (first lst))\n    \
    \        (or (not pos-min)\n                (> (first lst) pos-min)))\n      \
    \ (helper (rest lst) neg-max (first lst))]\n      [else (helper (rest lst) neg-max\
    \ pos-min)]))\n  (helper lst #f #f))\n", "  (let ([negs (filter negative? lst)]\n\
    \        [pos (filter positive? lst)])\n    (if (or (empty? negs) (empty? pos))\n\
    \        (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (define (largest-negative lst)\n    (cond [(empty? lst) #f]\n          [(negative?\
    \ (first lst))\n           (max (first lst) (largest-negative (rest lst)))]\n\
    \          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(positive? (first lst))\n    \
    \       (min (first lst) (smallest-positive (rest lst)))]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (cond [(and (largest-negative lst) (smallest-positive lst))\n\
    \         (list (largest-negative lst) (smallest-positive lst))]\n        [(largest-negative\
    \ lst) (list (largest-negative lst) #f)]\n        [(smallest-positive lst) (list\
    \ #f (smallest-positive lst))]\n        [else (list #f #f)]))\n", "  (let ([negs\
    \ (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (if (or\
    \ (null? negs) (null? pos))\n        'none\n        (list (apply max negs) (apply\
    \ min pos)))))\n", "  (if (empty? lst)\n      (values #f #f)\n      (let* ([negatives\
    \ (filter (lambda (x) (negative? x)) lst)]\n             [positives (filter (lambda\
    \ (x) (positive? x)) lst)]\n             [largest-negative (apply max negatives)]\n\
    \             [smallest-positive (apply min positives)])\n        (values largest-negative\
    \ smallest-positive))))\n", "  (let ([negs (filter (lambda (x) (negative? x))\
    \ lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n    (if (or (empty?\
    \ negs) (empty? pos))\n        (values #f #f)\n        (values (apply max negs)\
    \ (apply min pos)))))\n", "  (let ([negatives (filter negative? lst)]\n      \
    \  [positives (filter positive? lst)])\n    (if (or (empty? negatives) (empty?\
    \ positives))\n        (values #f #f)\n        (values (apply max negatives) (apply\
    \ min positives)))))\n", "  (let* ([negs (filter (lambda (x) (and (integer? x)\
    \ (< x 0))) lst)]\n         [pos (filter (lambda (x) (and (integer? x) (> x 0)))\
    \ lst)])\n    (cond\n      [(empty? negs) (cons #f (min pos))]\n      [(empty?\
    \ pos) (cons (max negs) #f)]\n      [else (cons (max negs) (min pos))])))\n",
  "  (let ([negs (filter (\u03BB (x) (< x 0)) lst)]\n        [pos  (filter (\u03BB\
    \ (x) (> x 0)) lst)])\n    (if (or (empty? negs) (empty? pos))\n        'none\n\
    \        (list (apply max negs) (apply min pos)))))\n", "  (define (helper lst\
    \ largest smallest)\n    (cond\n      [(empty? lst) (cons largest smallest)]\n\
    \      [(and (negative? (first lst))\n            (or (not (negative? largest))\n\
    \                (< (first lst) largest)))\n       (helper (rest lst) (first lst)\
    \ smallest)]\n      [(and (positive? (first lst))\n            (or (not (positive?\
    \ smallest))\n                (> (first lst) smallest)))\n       (helper (rest\
    \ lst) largest (first lst))]\n      [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst 'None 'None))\n", "  (define (helper lst neg-max pos-min)\n   \
    \ (cond [(empty? lst) (values neg-max pos-min)]\n          [(and (negative? (first\
    \ lst))\n                (&gt; (first lst) neg-max))\n           (helper (rest\
    \ lst) (first lst) pos-min)]\n          [(and (positive? (first lst))\n      \
    \          (&lt; (first lst) pos-min))\n           (helper (rest lst) neg-max\
    \ (first lst))]\n          [else (helper (rest lst) neg-max pos-min)]))\n  (helper\
    \ lst -1/0 1/0))\n", "  (let* ([negs (filter negative? lst)]\n         [pos (filter\
    \ positive? lst)])\n    (if (or (empty? negs) (empty? pos))\n        (values #f\
    \ #f)\n        (values (apply max negs) (apply min pos)))))\n", "  (let ([negatives\
    \ (filter (lambda (x) (negative? x)) lst)]\n        [positives (filter (lambda\
    \ (x) (positive? x)) lst)])\n    (if (or (empty? negatives) (empty? positives))\n\
    \        (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let* ([negs (filter negative? lst)]\n         [pos (filter positive? lst)])\n\
    \    (if (or (null? negs) (null? pos))\n        (values #f #f)\n        (values\
    \ (apply max negs) (apply min pos)))))\n", "  (define (helper lst)\n    (cond\n\
    \      [(empty? lst) (values #f #f)]\n      [(and (not (empty? lst)) (not (negative?\
    \ (car lst)))) (helper (cdr lst))]\n      [(and (not (empty? lst)) (not (positive?\
    \ (car lst)))) (helper (cdr lst))]\n      [(and (not (empty? lst)) (negative?\
    \ (car lst))) (values (car lst) (car lst))]\n      [(and (not (empty? lst)) (positive?\
    \ (car lst))) (values (car lst) (car lst))]))\n  (define (helper2 lst)\n    (cond\n\
    \      [(empty? lst) (values #f #f)]\n      [(and (not (empty? lst)) (not (negative?\
    \ (car lst)))) (helper2 (cdr lst))]\n      [(and (not (empty? lst)) (not (positive?\
    \ (car lst)))) (helper2 (cdr lst))]\n      [(and (not (empty? lst)) (negative?\
    \ (car lst))) (values (car lst) (car lst))]\n      [(and (not (empty? lst)) (positive?\
    \ (car lst))) (values (car lst) (car lst))]))\n  (define (helper3 lst)\n    (cond\n\
    \      [(empty? lst) (values #f #f)]\n      [(and (not (empty? lst)) (not (negative?\
    \ (car lst)))) (helper3 (cdr lst))]\n      [(and (not (empty? lst)) (not (positive?\
    \ (car lst)))) (helper3 (cdr lst))]\n      [(and (not (empty? lst)) (negative?\
    \ (car lst))) (values (car lst) (car lst))]\n      [(and (not (empty? lst)) (positive?\
    \ (car lst))) (values (car lst) (car lst))]))\n  (define (helper4 lst)\n    (cond\n\
    \      [(empty? lst) (values #", "  (define (largest-negative lst)\n    (cond\
    \ [(empty? lst) '()]\n          [(and (negative? (first lst))\n              \
    \  (not (negative? (second lst))))\n           (first lst)]\n          [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) '()]\n\
    \          [(and (positive? (first lst))\n                (not (positive? (second\
    \ lst))))\n           (first lst)]\n          [else (smallest-positive (rest lst))]))\n\
    \  (cond [(empty? lst) '(none none)]\n        [(negative? (first lst))\n     \
    \    (cons (largest-negative lst)\n               (cons (smallest-positive lst)\
    \ '()))]\n        [else (cons (largest-negative lst)\n                    (cons\
    \ (smallest-positive lst) '()))]))\n", "  (let ([negs (filter (lambda (x) (and\
    \ (integer? x) (< x 0))) lst)]\n        [pos (filter (lambda (x) (and (integer?\
    \ x) (> x 0))) lst)])\n    (if (or (empty? negs) (empty? pos))\n        'none\n\
    \        (cons (apply max negs) (apply min pos)))))\n", "  (define (helper lst)\n\
    \    (cond\n      [(empty? lst) (values #f #f)]\n      [(and (negative? (first\
    \ lst)) (not (positive? (first lst))))\n       (let* ([a (first lst)]\n      \
    \        [b (second lst)]\n              [c (third lst)])\n         (cond\n  \
    \         [(and (negative? b) (not (positive? b)))\n            (if (> a b)\n\
    \                (values a c)\n                (values b c))]\n           [(negative?\
    \ b)\n            (if (> a b)\n                (values a c)\n                (values\
    \ b c))]\n           [else\n            (if (> a c)\n                (values a\
    \ b)\n                (values c b))]))]\n      [(negative? (first lst))\n    \
    \   (let* ([a (first lst)]\n              [b (second lst)])\n         (cond\n\
    \           [(negative? b)\n            (if (> a b)\n                (values a\
    \ (third lst))\n                (values b (third lst)))]\n           [else\n \
    \           (values a b)]))]\n      [(positive? (first lst))\n       (let* ([a\
    \ (first lst)]\n              [b (second lst)])\n         (cond\n           [(positive?\
    \ b)\n            (if (< a b)\n                (values a (third lst))\n      \
    \          (values b (third lst)))]\n           [else\n            (values a b)]))]\n\
    \      [else\n       (let* ([a (first lst)]\n              [b (second lst)])\n\
    \         (cond\n           [(positive? b)\n            (if (< a b)\n        \
    \        (values a (third lst))\n                (values b (third lst)))]\n  \
    \         [else\n            (values a b)]))]))\n  (let* ([a (helper lst)]\n \
    \        [b (helper (rest lst))])\n    (cond\n      [(and (not (first a)) (not\
    \ (first b))) (values #f #f)]\n      [(not (first a)) b]\n      [(not (first b))\
    \ a]\n      [(> (", "  (let ([negs (filter negative? lst)]\n        [pos (filter\
    \ positive? lst)])\n    (if (empty? negs)\n        (if (empty? pos)\n        \
    \    (values 'none 'none)\n            (values 'none (min pos)))\n        (if\
    \ (empty? pos)\n            (values (max negs) 'none)\n            (values (max\
    \ negs) (min pos))))))\n", "  (cond\n    [(empty? lst) (values none none)]\n \
    \   [(and (negative? (first lst)) (positive? (first lst))) (values (first lst)\
    \ (first lst))]\n    [(negative? (first lst)) (values (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n    [(positive? (first lst)) (values (largest_smallest_integers\
    \ (rest lst)) (first lst))]\n    [else (largest_smallest_integers (rest lst))]))\n",
  "  (let ((negatives (filter (lambda (x) (and (integer? x) (< x 0))) lst))\n    \
    \    (positives (filter (lambda (x) (and (integer? x) (> x 0))) lst)))\n    (if\
    \ (or (empty? negatives) (empty? positives))\n        (values #f #f)\n       \
    \ (values (apply max negatives) (apply min positives)))))\n", "  (let* ([negatives\
    \ (filter negative? lst)]\n         [positives (filter positive? lst)])\n    (if\
    \ (or (empty? negatives) (empty? positives))\n        #f\n        (list (apply\
    \ max negatives) (apply min positives)))))\n", "  (define (largest-neg lst)\n\
    \    (cond\n      [(empty? lst) 'none]\n      [(negative? (first lst)) (max (first\
    \ lst) (largest-neg (rest lst)))]\n      [else (largest-neg (rest lst))]))\n \
    \ (define (smallest-pos lst)\n    (cond\n      [(empty? lst) 'none]\n      [(positive?\
    \ (first lst)) (min (first lst) (smallest-pos (rest lst)))]\n      [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (define\
    \ (positive? n) (&gt; n 0))\n  (define (negative? n) (&lt; n 0))\n  (define (filter-positive\
    \ lst)\n    (cond [(empty? lst) empty]\n          [(positive? (first lst)) (cons\
    \ (first lst) (filter-positive (rest lst)))]\n          [else (filter-positive\
    \ (rest lst))]))\n  (define (filter-negative lst)\n    (cond [(empty? lst) empty]\n\
    \          [(negative? (first lst)) (cons (first lst) (filter-negative (rest lst)))]\n\
    \          [else (filter-negative (rest lst))]))\n  (define (max lst)\n    (cond\
    \ [(empty? lst) 0]\n          [(&gt; (first lst) (max (rest lst))) (first lst)]\n\
    \          [else (max (rest lst))]))\n  (define (min lst)\n    (cond [(empty?\
    \ lst) 0]\n          [(&lt; (first lst) (min (rest lst))) (first lst)]\n     \
    \     [else (min (rest lst))]))\n  (cond [(empty? lst) (values 0 0)]\n       \
    \ [(empty? (filter-positive lst)) (values (max (filter-negative lst)) 0)]\n  \
    \      [(empty? (filter-negative lst)) (values 0 (min (filter-positive lst)))]\n\
    \        [else (values (max (filter-negative lst)) (min (filter-positive lst)))]))\n\
    </code>\nI'm not sure if this is the best way to do it, but it works.\n", "  (let\
    \ ([negatives (filter (\u03BB (x) (negative? x)) lst)]\n        [positives (filter\
    \ (\u03BB (x) (positive? x)) lst)])\n    (if (or (empty? negatives) (empty? positives))\n\
    \        '(None None)\n        (list (apply max negatives) (apply min positives)))))\n",
  "  (define (largest-negative lst)\n    (cond [(empty? lst) 'none]\n          [(and\
    \ (negative? (first lst))\n                (or (not (negative? (second lst)))\n\
    \                    (empty? (rest lst))))\n           (first lst)]\n        \
    \  [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond [(empty? lst) 'none]\n          [(and (positive? (first lst))\n   \
    \             (or (not (positive? (second lst)))\n                    (empty?\
    \ (rest lst))))\n           (first lst)]\n          [else (smallest-positive (rest\
    \ lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n", "  (let*\
    \ ([negatives (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n        \
    \ [positives (filter (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (cond\n\
    \      [(empty? negatives) (values #f #f)]\n      [(empty? positives) (values\
    \ #f #f)]\n      [else (values (apply max negatives) (apply min positives))])))\n",
  "  (let* ([negatives (filter (lambda (x) (< x 0)) lst)]\n         [positives (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (or (empty? negatives) (empty? positives))\n\
    \        (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let ([negs (filter (lambda (x) (&lt; x 0)) lst)]\n        [pos (filter (lambda\
    \ (x) (&gt; x 0)) lst)])\n    (if (or (empty? negs) (empty? pos))\n        (values\
    \ #f #f)\n        (values (apply max negs) (apply min pos)))))\n", "  (cond [(empty?\
    \ lst) (values '() '())]\n        [(and (positive? (car lst)) (negative? (car\
    \ lst))) (values (car lst) (car lst))]\n        [(positive? (car lst)) (let-values\
    \ ([(a b) (largest_smallest_integers (cdr lst))])\n                          \
    \       (values a (min (car lst) b)))]\n        [(negative? (car lst)) (let-values\
    \ ([(a b) (largest_smallest_integers (cdr lst))])\n                          \
    \       (values (max (car lst) a) b))]\n        [else (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (define (largest-neg lst)\n    (cond [(empty? lst) 'none]\n\
    \          [(and (negative? (first lst)) (not (empty? (rest lst))))\n        \
    \   (if (&gt; (first lst) (largest-neg (rest lst)))\n               (first lst)\n\
    \               (largest-neg (rest lst)))]\n          [(negative? (first lst))\
    \ (first lst)]\n          [else (largest-neg (rest lst))]))\n  (define (smallest-pos\
    \ lst)\n    (cond [(empty? lst) 'none]\n          [(and (positive? (first lst))\
    \ (not (empty? (rest lst))))\n           (if (&lt; (first lst) (smallest-pos (rest\
    \ lst)))\n               (first lst)\n               (smallest-pos (rest lst)))]\n\
    \          [(positive? (first lst)) (first lst)]\n          [else (smallest-pos\
    \ (rest lst))]))\n  (cons (largest-neg lst) (smallest-pos lst)))\n", "  (cond\n\
    \    [(empty? lst) (values '() '())]\n    [(and (negative? (first lst)) (positive?\
    \ (first lst)))\n     (values (first lst) (first lst))]\n    [(negative? (first\
    \ lst))\n     (define (helper lst largest smallest)\n       (cond\n         [(empty?\
    \ lst) (values largest smallest)]\n         [(negative? (first lst))\n       \
    \   (if (&gt; (first lst) largest)\n              (helper (rest lst) (first lst)\
    \ smallest)\n              (helper (rest lst) largest smallest))]\n         [(positive?\
    \ (first lst))\n          (if (&lt; (first lst) smallest)\n              (helper\
    \ (rest lst) largest (first lst))\n              (helper (rest lst) largest smallest))]\n\
    \         [else (helper (rest lst) largest smallest)]))\n     (helper (rest lst)\
    \ (first lst) (first lst))]\n    [(positive? (first lst))\n     (define (helper\
    \ lst largest smallest)\n       (cond\n         [(empty? lst) (values largest\
    \ smallest)]\n         [(negative? (first lst))\n          (if (&gt; (first lst)\
    \ largest)\n              (helper (rest lst) (first lst) smallest)\n         \
    \     (helper (rest lst) largest smallest))]\n         [(positive? (first lst))\n\
    \          (if (&lt; (first lst) smallest)\n              (helper (rest lst) largest\
    \ (first lst))\n              (helper (rest lst) largest smallest))]\n       \
    \  [else (helper (rest lst) largest smallest)]))\n     (helper (rest lst) (first\
    \ lst) (first lst))]\n    [else (largest_smallest_integers (rest lst))]))\n</code>\n",
  "  (define (positive? x) (&gt; x 0))\n  (define (negative? x) (&lt; x 0))\n  (define\
    \ (max-negative lst)\n    (cond\n      [(empty? lst) 0]\n      [(negative? (first\
    \ lst)) (max (first lst) (max-negative (rest lst)))]\n      [else (max-negative\
    \ (rest lst))]))\n  (define (min-positive lst)\n    (cond\n      [(empty? lst)\
    \ 0]\n      [(positive? (first lst)) (min (first lst) (min-positive (rest lst)))]\n\
    \      [else (min-positive (rest lst))]))\n  (cond\n    [(empty? lst) (values\
    \ 0 0)]\n    [else (values (max-negative lst) (min-positive lst))]))\n", "  (let\
    \ ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (if\
    \ (or (empty? negs) (empty? pos))\n        (values #f #f)\n        (values (apply\
    \ max negs) (apply min pos)))))\n", "  (let ([negatives (filter (lambda (x) (&lt;\
    \ x 0)) lst)]\n        [positives (filter (lambda (x) (&gt; x 0)) lst)])\n   \
    \ (if (or (null? negatives) (null? positives))\n        (values #f #f)\n     \
    \   (values (apply max negatives) (apply min positives)))))\n", "  (if (empty?\
    \ lst)\n      (values #f #f)\n      (let loop ([lst lst] [neg #f] [pos #f])\n\
    \        (cond [(empty? lst) (values neg pos)]\n              [(and (integer?\
    \ (car lst)) (negative? (car lst)))\n               (loop (cdr lst) (max (car\
    \ lst) neg) pos)]\n              [(and (integer? (car lst)) (positive? (car lst)))\n\
    \               (loop (cdr lst) neg (min (car lst) pos))]\n              [else\
    \ (loop (cdr lst) neg pos)]))))\n", "  (cond\n    [(empty? lst) (cons 'None 'None)]\n\
    \    [(andmap number? lst)\n     (let ([negs (filter negative? lst)]\n       \
    \    [pos (filter positive? lst)])\n       (cond\n         [(empty? negs) (cons\
    \ 'None (min pos))]\n         [(empty? pos) (cons (max negs) 'None)]\n       \
    \  [else (cons (max negs) (min pos))]))]\n    [else (cons 'None 'None)]))\n",
  "  (define (positive? n)\n    (> n 0))\n  (define (negative? n)\n    (< n 0))\n\
    \  (define (largest-negative lst)\n    (cond\n      [(empty? lst) 0]\n      [(negative?\
    \ (first lst)) (max (first lst) (largest-negative (rest lst)))]\n      [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond\n      [(empty?\
    \ lst) 0]\n      [(positive? (first lst)) (min (first lst) (smallest-positive\
    \ (rest lst)))]\n      [else (smallest-positive (rest lst))]))\n  (cond\n    [(empty?\
    \ lst) (values 0 0)]\n    [else (values (largest-negative lst) (smallest-positive\
    \ lst))]))\n", "  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(and (negative?\
    \ (first lst)) (positive? (first lst))) (values (first lst) (first lst))]\n  \
    \  [(negative? (first lst)) (values (first lst) (apply min (filter positive? (rest\
    \ lst))))]\n    [(positive? (first lst)) (values (apply max (filter negative?\
    \ (rest lst))) (first lst))]\n    [else (values (apply max (filter negative? (rest\
    \ lst))) (apply min (filter positive? (rest lst))))]))\n", "  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) 'None]\n          [(and (negative? (first lst))\n\
    \                (or (not (negative? (second lst)))\n                    (and\
    \ (negative? (second lst))\n                         (< (first lst) (second lst)))))\n\
    \           (first lst)]\n          [else (largest-negative (rest lst))]))\n \
    \ (define (smallest-positive lst)\n    (cond [(empty? lst) 'None]\n          [(and\
    \ (positive? (first lst))\n                (or (not (positive? (second lst)))\n\
    \                    (and (positive? (second lst))\n                         (>\
    \ (first lst) (second lst)))))\n           (first lst)]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (list (largest-negative lst) (smallest-positive lst)))\n",
  "  (cond [(empty? lst) (values #f #f)]\n        [(andmap number? lst)\n        \
    \ (let* ([negatives (filter (\u03BB (x) (and (number? x) (< x 0))) lst)]\n   \
    \             [positives (filter (\u03BB (x) (and (number? x) (> x 0))) lst)])\n\
    \           (values (if (empty? negatives) #f (apply max negatives))\n       \
    \            (if (empty? positives) #f (apply min positives))))]\n        [else\
    \ (values #f #f)]))\n", "  (let* ([negatives (filter (\u03BB (x) (and (integer?\
    \ x) (< x 0))) lst)]\n         [positives (filter (\u03BB (x) (and (integer? x)\
    \ (> x 0))) lst)])\n    (if (or (empty? negatives) (empty? positives))\n     \
    \   (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let ([negatives (filter (\u03BB (x) (and (number? x) (negative? x))) lst)]\n\
    \        [positives (filter (\u03BB (x) (and (number? x) (positive? x))) lst)])\n\
    \    (if (or (empty? negatives) (empty? positives))\n        (values #f #f)\n\
    \        (values (apply max negatives) (apply min positives)))))\n", "  (cond\
    \ [(empty? lst) (values #f #f)]\n        [(andmap number? lst)\n         (values\
    \ (apply max (filter negative? lst))\n                 (apply min (filter positive?\
    \ lst)))]\n        [else (values #f #f)]))\n", "  (let ([negs (filter negative?\
    \ lst)]\n        [pos (filter positive? lst)])\n    (cond [(empty? negs) (values\
    \ (void) (min pos))]\n          [(empty? pos) (values (max negs) (void))]\n  \
    \        [else (values (max negs) (min pos))])))\n", "  (let ([negs (filter negative?\
    \ lst)]\n        [pos (filter positive? lst)])\n    (if (and (not (empty? negs))\
    \ (not (empty? pos)))\n        (values (apply max negs) (apply min pos))\n   \
    \     (values #f #f))))\n", "  (define (largest-negative lst)\n    (cond\n   \
    \   [(empty? lst) 'none]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (first lst)]\n      [else (largest-negative (rest lst))]))\n\
    \  (define (smallest-positive lst)\n    (cond\n      [(empty? lst) 'none]\n  \
    \    [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n\
    \      [else (smallest-positive (rest lst))]))\n  (list (largest-negative lst)\
    \ (smallest-positive lst)))\n", "  (define (helper lst neg-max pos-min)\n    (cond\
    \ [(empty? lst) (values neg-max pos-min)]\n          [(and (negative? (first lst))\n\
    \                (or (not neg-max)\n                    (&gt; (first lst) neg-max)))\n\
    \           (helper (rest lst) (first lst) pos-min)]\n          [(and (positive?\
    \ (first lst))\n                (or (not pos-min)\n                    (&lt; (first\
    \ lst) pos-min)))\n           (helper (rest lst) neg-max (first lst))]\n     \
    \     [else (helper (rest lst) neg-max pos-min)]))\n  (helper lst #f #f))\n",
  "  (cond\n    [(empty? lst) (cons 'none 'none)]\n    [(andmap number? lst)\n   \
    \  (let ([negatives (filter negative? lst)]\n           [positives (filter positive?\
    \ lst)])\n       (cons (apply max negatives) (apply min positives)))]\n    [else\
    \ (cons 'none 'none)]))\n", "  (cond\n    [(empty? lst) (values #f #f)]\n    [(and\
    \ (negative? (first lst)) (positive? (first lst))) (values #f #f)]\n    [(negative?\
    \ (first lst)) (let ([a (first lst)])\n                               (for/fold\
    \ ([a (first lst)]) ([b (in-list (rest lst))])\n                             \
    \    (if (and (negative? b) (> b a))\n                                     b\n\
    \                                     a)))]\n    [(positive? (first lst)) (let\
    \ ([b (first lst)])\n                               (for/fold ([b (first lst)])\
    \ ([a (in-list (rest lst))])\n                                 (if (and (positive?\
    \ a) (< a b))\n                                     a\n                      \
    \               b)))]\n    [else (largest_smallest_integers (rest lst))]))\n",
  "  (define (largest-negative lst)\n    (cond\n      [(empty? lst) 'none]\n     \
    \ [(and (negative? (first lst)) (not (empty? (rest lst))))\n       (max (first\
    \ lst) (largest-negative (rest lst)))]\n      [(negative? (first lst)) (first\
    \ lst)]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) 'none]\n      [(and (positive? (first lst))\
    \ (not (empty? (rest lst))))\n       (min (first lst) (smallest-positive (rest\
    \ lst)))]\n      [(positive? (first lst)) (first lst)]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (largest-neg lst)\n    (cond\n      [(empty? lst) 'none]\n      [(and\
    \ (negative? (first lst))\n            (or (empty? (rest lst))\n             \
    \   (negative? (first (rest lst)))))\n       (first lst)]\n      [else (largest-neg\
    \ (rest lst))]))\n  (define (smallest-pos lst)\n    (cond\n      [(empty? lst)\
    \ 'none]\n      [(and (positive? (first lst))\n            (or (empty? (rest lst))\n\
    \                (positive? (first (rest lst)))))\n       (first lst)]\n     \
    \ [else (smallest-pos (rest lst))]))\n  (tuple (largest-neg lst) (smallest-pos\
    \ lst)))\n", "  (define (helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (values largest smallest)]\n      [(and (positive? (first lst)) (not (positive?\
    \ smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and (negative?\
    \ (first lst)) (not (negative? largest)))\n       (helper (rest lst) (first lst)\
    \ smallest)]\n      [else (helper (rest lst) largest smallest)]))\n  (helper lst\
    \ #f #f))\n", "  (let ([negs (filter negative? lst)]\n        [pos (filter positive?\
    \ lst)])\n    (if (or (empty? negs) (empty? pos))\n        (values #f #f)\n  \
    \      (values (apply max negs) (apply min pos)))))\n", "  (define (helper lst\
    \ neg pos)\n    (cond\n      [(empty? lst) (values neg pos)]\n      [(negative?\
    \ (first lst)) (helper (rest lst) (first lst) pos)]\n      [(positive? (first\
    \ lst)) (helper (rest lst) neg (first lst))]\n      [else (helper (rest lst) neg\
    \ pos)]))\n  (let ([neg (first (helper lst 0 0))]\n        [pos (second (helper\
    \ lst 0 0))])\n    (if (and (zero? neg) (zero? pos))\n        (values 'None 'None)\n\
    \        (values neg pos))))\n", "  (define (helper lst neg pos)\n    (cond [(empty?\
    \ lst) (values neg pos)]\n          [(negative? (first lst)) (helper (rest lst)\
    \ (max (first lst) neg) pos)]\n          [(positive? (first lst)) (helper (rest\
    \ lst) neg (min (first lst) pos))]\n          [else (helper (rest lst) neg pos)]))\n\
    \  (helper lst 0 (first lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) 'none]\n      [(and (negative? (first lst))\n           \
    \ (or (empty? (rest lst))\n                (negative? (first (rest lst)))))\n\
    \       (largest_negative (rest lst))]\n      [(and (negative? (first lst))\n\
    \            (positive? (first (rest lst))))\n       (largest_negative (rest lst))]\n\
    \      [(and (positive? (first lst))\n            (negative? (first (rest lst))))\n\
    \       (largest_negative (rest lst))]\n      [(and (positive? (first lst))\n\
    \            (or (empty? (rest lst))\n                (positive? (first (rest\
    \ lst)))))\n       (first lst)]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) 'none]\n      [(and (negative? (first lst))\n           \
    \ (or (empty? (rest lst))\n                (negative? (first (rest lst)))))\n\
    \       (smallest_positive (rest lst))]\n      [(and (negative? (first lst))\n\
    \            (positive? (first (rest lst))))\n       (first (rest lst))]\n   \
    \   [(and (positive? (first lst))\n            (negative? (first (rest lst))))\n\
    \       (smallest_positive (rest lst))]\n      [(and (positive? (first lst))\n\
    \            (or (empty? (rest lst))\n                (positive? (first (rest\
    \ lst)))))\n       (smallest_positive (rest lst))]))\n  (cons (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (let ([negs (filter negative? lst)]\n\
    \        [pos (filter positive? lst)])\n    (if (and (empty? negs) (empty? pos))\n\
    \        (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (let* ([negs (filter (lambda (x) (negative? x)) lst)]\n         [pos (filter\
    \ (lambda (x) (positive? x)) lst)])\n    (if (or (null? negs) (null? pos))\n \
    \       (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (let ([negatives (filter negative? lst)]\n        [positives (filter positive?\
    \ lst)])\n    (if (and (empty? negatives) (empty? positives))\n        (values\
    \ 'none 'none)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let* ([negs (filter negative? lst)]\n         [pos (filter positive? lst)])\n\
    \    (if (and (empty? negs) (empty? pos))\n        (values #f #f)\n        (values\
    \ (apply max negs) (apply min pos)))))\n", "  (let ([neg-lst (filter negative?\
    \ lst)]\n        [pos-lst (filter positive? lst)])\n    (cond [(empty? neg-lst)\
    \ (cons #f (min pos-lst))]\n          [(empty? pos-lst) (cons (max neg-lst) #f)]\n\
    \          [else (cons (max neg-lst) (min pos-lst))])))\n", "  (define (largest-negative\
    \ lst)\n    (cond\n      [(empty? lst) 'none]\n      [(and (negative? (first lst))\n\
    \            (not (empty? (rest lst))))\n       (if (> (first lst) (largest-negative\
    \ (rest lst)))\n           (first lst)\n           (largest-negative (rest lst)))]\n\
    \      [(negative? (first lst)) (first lst)]\n      [else (largest-negative (rest\
    \ lst))]))\n  (define (smallest-positive lst)\n    (cond\n      [(empty? lst)\
    \ 'none]\n      [(and (positive? (first lst))\n            (not (empty? (rest\
    \ lst))))\n       (if (< (first lst) (smallest-positive (rest lst)))\n       \
    \    (first lst)\n           (smallest-positive (rest lst)))]\n      [(positive?\
    \ (first lst)) (first lst)]\n      [else (smallest-positive (rest lst))]))\n \
    \ (cons (largest-negative lst) (smallest-positive lst)))\n", "  (define (helper\
    \ lst neg-max pos-min)\n    (cond [(empty? lst) (values neg-max pos-min)]\n  \
    \        [(negative? (first lst)) (helper (rest lst) (max (first lst) neg-max)\
    \ pos-min)]\n          [(positive? (first lst)) (helper (rest lst) neg-max (min\
    \ (first lst) pos-min))]\n          [else (helper (rest lst) neg-max pos-min)]))\n\
    \  (helper lst -100000 100000))\n", "  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) 'none]\n      [(negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) 'none]\n      [(positive? (first lst))\
    \ (min (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (tuple (largest-negative lst) (smallest-positive lst)))\n",
  "  (cond\n    [(empty? lst) (values #f #f)]\n    [(and (positive? (first lst)) (negative?\
    \ (first lst)))\n     (let ([l (largest_smallest_integers (rest lst))])\n    \
    \   (values (first l) (second l)))]\n    [(positive? (first lst))\n     (let ([l\
    \ (largest_smallest_integers (rest lst))])\n       (values (first l) (min (second\
    \ l) (first lst))))]\n    [(negative? (first lst))\n     (let ([l (largest_smallest_integers\
    \ (rest lst))])\n       (values (max (first l) (first lst)) (second l)))]\n  \
    \  [else (values #f #f)]))\n", "  (let* ([negatives (filter (\u03BB (x) (negative?\
    \ x)) lst)]\n         [positives (filter (\u03BB (x) (positive? x)) lst)])\n \
    \   (if (empty? negatives)\n        (if (empty? positives)\n            (values\
    \ 'None 'None)\n            (values 'None (apply min positives)))\n        (if\
    \ (empty? positives)\n            (values (apply max negatives) 'None)\n     \
    \       (values (apply max negatives) (apply min positives))))))\n", "  (define\
    \ (helper lst neg pos)\n    (cond [(empty? lst) (values neg pos)]\n          [(<\
    \ (first lst) 0) (helper (rest lst) (max (first lst) neg) pos)]\n          [(>\
    \ (first lst) 0) (helper (rest lst) neg (min (first lst) pos))]\n          [else\
    \ (helper (rest lst) neg pos)]))\n  (let ([neg (helper lst -10000000000 10000000000)])\n\
    \    (if (and (zero? (first neg)) (zero? (second neg)))\n        (values #f #f)\n\
    \        neg)))\n", "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n \
    \       [positives (filter (lambda (x) (> x 0)) lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (let ([negs (filter negative? lst)]\n     \
    \   [pos (filter positive? lst)])\n    (if (or (empty? negs) (empty? pos))\n \
    \       (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (let ((negatives (filter (lambda (x) (negative? x)) lst))\n        (positives\
    \ (filter (lambda (x) (positive? x)) lst)))\n    (if (empty? negatives)\n    \
    \    (values 'None (min positives))\n        (values (max negatives)\n       \
    \         (if (empty? positives)\n                    'None\n                \
    \    (min positives))))))\n", "  (define (is-positive? n)\n    (and (integer?\
    \ n)\n         (positive? n)))\n  (define (is-negative? n)\n    (and (integer?\
    \ n)\n         (negative? n)))\n  (define (largest-negative lst)\n    (cond [(null?\
    \ lst) #f]\n          [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n          [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(null? lst) #f]\n          [(is-positive? (car lst)) (min (car\
    \ lst) (smallest-positive (cdr lst)))]\n          [else (smallest-positive (cdr\
    \ lst))]))\n  (cond [(and (not (largest-negative lst)) (not (smallest-positive\
    \ lst))) #f]\n        [(not (largest-negative lst)) (cons #f (smallest-positive\
    \ lst))]\n        [(not (smallest-positive lst)) (cons (largest-negative lst)\
    \ #f)]\n        [else (cons (largest-negative lst) (smallest-positive lst))]))\n",
  "  (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (or (empty? negs) (empty? pos))\n        (values #f #f)\n        (values\
    \ (apply max negs) (apply min pos)))))\n", "  (define (largest-negative lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n   \
    \         (or (not (negative? (second lst)))\n                (not (negative?\
    \ (second lst)))))\n       (first lst)]\n      [else (largest-negative (rest lst))]))\n\
    \  (define (smallest-positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst))\n            (or (not (positive? (second lst)))\n\
    \                (not (positive? (second lst)))))\n       (first lst)]\n     \
    \ [else (smallest-positive (rest lst))]))\n  (cond\n    [(empty? lst) (values\
    \ #f #f)]\n    [(and (largest-negative lst) (smallest-positive lst))\n     (values\
    \ (largest-negative lst) (smallest-positive lst))]\n    [(largest-negative lst)\
    \ (values (largest-negative lst) #f)]\n    [(smallest-positive lst) (values #f\
    \ (smallest-positive lst))]\n    [else (values #f #f)]))\n", "  (let ([negs (filter\
    \ (lambda (x) (and (number? x) (negative? x))) lst)]\n        [pos (filter (lambda\
    \ (x) (and (number? x) (positive? x))) lst)])\n    (if (and (not (empty? negs))\
    \ (not (empty? pos)))\n        (list (apply max negs) (apply min pos))\n     \
    \   (list 'None 'None))))\n", "  (cond [(empty? lst) (values 'none 'none)]\n \
    \       [(andmap number? lst)\n         (values (apply max (filter negative? lst))\n\
    \                 (apply min (filter positive? lst)))]\n        [else (values\
    \ 'none 'none)]))\n", "  (define (helper lst neg pos)\n    (cond [(empty? lst)\
    \ (cons neg pos)]\n          [(and (negative? (first lst))\n                (or\
    \ (not neg) (&lt; (first lst) neg)))\n           (helper (rest lst) (first lst)\
    \ pos)]\n          [(and (positive? (first lst))\n                (or (not pos)\
    \ (&gt; (first lst) pos)))\n           (helper (rest lst) neg (first lst))]\n\
    \          [else (helper (rest lst) neg pos)]))\n  (helper lst #f #f))\n", " \
    \ (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (and (empty? negs) (empty? pos))\n        (values #f #f)\n        (values\
    \ (apply max negs) (apply min pos)))))\n", "  (cond\n    [(empty? lst) (cons #f\
    \ #f)]\n    [(and (negative? (first lst)) (positive? (first lst))) (cons (first\
    \ lst) (first lst))]\n    [(negative? (first lst)) (cons (first lst) (second lst))]\n\
    \    [(positive? (first lst)) (cons (first lst) (second lst))]\n    [else (cons\
    \ (first lst) (second lst))]))\n", "  (let* ([negs (filter (lambda (x) (and (integer?\
    \ x) (< x 0))) lst)]\n         [pos (filter (lambda (x) (and (integer? x) (> x\
    \ 0))) lst)])\n    (if (or (null? negs) (null? pos))\n        (values #f #f)\n\
    \        (values (apply max negs) (apply min pos)))))\n", "  (let ([negatives\
    \ (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n        [positives (filter\
    \ (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (cond\n      [(empty? negatives)\
    \ (values 'None 'None)]\n      [(empty? positives) (values 'None 'None)]\n   \
    \   [else (values (apply max negatives) (apply min positives))])))\n", "  (let\
    \ ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (if\
    \ (empty? negs)\n        (cons #f (min pos))\n        (cons (max negs) (if (empty?\
    \ pos) #f (min pos))))))\n", "  (define (helper lst neg pos)\n    (cond\n    \
    \  [(null? lst) (values neg pos)]\n      [(and (negative? (car lst)) (or (null?\
    \ neg) (< (car lst) neg)))\n       (helper (cdr lst) (car lst) pos)]\n      [(and\
    \ (positive? (car lst)) (or (null? pos) (> (car lst) pos)))\n       (helper (cdr\
    \ lst) neg (car lst))]\n      [else (helper (cdr lst) neg pos)]))\n  (helper lst\
    \ #f #f))\n", "  (define (helper lst neg-max pos-min)\n    (cond [(empty? lst)\
    \ (values neg-max pos-min)]\n          [(and (positive? (first lst))\n       \
    \         (or (not pos-min)\n                    (< (first lst) pos-min)))\n \
    \          (helper (rest lst) neg-max (first lst))]\n          [(and (negative?\
    \ (first lst))\n                (or (not neg-max)\n                    (> (first\
    \ lst) neg-max)))\n           (helper (rest lst) (first lst) pos-min)]\n     \
    \     [else (helper (rest lst) neg-max pos-min)]))\n  (helper lst #f #f))\n",
  "  (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (or (empty? negs) (empty? pos))\n        '()\n        (list (apply max\
    \ negs) (apply min pos)))))\n", "  (define (helper lst neg-max pos-min)\n    (cond\
    \ [(empty? lst) (values neg-max pos-min)]\n          [(and (negative? (first lst))\n\
    \                (or (not (number? neg-max))\n                    (&gt; (first\
    \ lst) neg-max)))\n           (helper (rest lst) (first lst) pos-min)]\n     \
    \     [(and (positive? (first lst))\n                (or (not (number? pos-min))\n\
    \                    (&lt; (first lst) pos-min)))\n           (helper (rest lst)\
    \ neg-max (first lst))]\n          [else (helper (rest lst) neg-max pos-min)]))\n\
    \  (helper lst #f #f))\n", "  (let ([negatives (filter (lambda (x) (negative?\
    \ x)) lst)]\n        [positives (filter (lambda (x) (positive? x)) lst)])\n  \
    \  (if (and (empty? negatives) (empty? positives))\n        (values 'None 'None)\n\
    \        (values (apply max negatives) (apply min positives)))))\n", "  (cond\n\
    \    [(empty? lst) (cons 'None 'None)]\n    [(and (not (empty? lst)) (not (number?\
    \ (car lst)))) (largest_smallest_integers (cdr lst))]\n    [(and (not (empty?\
    \ lst)) (number? (car lst)) (positive? (car lst))) (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n    [(and (not (empty? lst)) (number? (car lst)) (negative? (car\
    \ lst))) (cons (car lst) (largest_smallest_integers (cdr lst)))]))\n", "  (cond\n\
    \    [(empty? lst) (values 'none 'none)]\n    [(andmap number? lst)\n     (let\
    \ ([negatives (filter negative? lst)]\n           [positives (filter positive?\
    \ lst)])\n       (values (apply max negatives) (apply min positives)))]\n    [else\
    \ (values 'none 'none)]))\n", "  (let* ([negatives (filter (\u03BB (x) (and (number?\
    \ x) (< x 0))) lst)]\n         [positives (filter (\u03BB (x) (and (number? x)\
    \ (> x 0))) lst)])\n    (if (or (empty? negatives) (empty? positives))\n     \
    \   (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (or (empty? negs) (empty? pos))\n        (values #f #f)\n        (values\
    \ (apply max negs) (apply min pos)))))\n", "  (let ([negs (filter negative? lst)]\n\
    \        [pos (filter positive? lst)])\n    (if (or (null? negs) (null? pos))\n\
    \        (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (cond\n    [(empty? lst) (values 'none 'none)]\n    [(andmap number? lst)\n \
    \    (values (apply max (filter negative? lst))\n             (apply min (filter\
    \ positive? lst)))]\n    [else (values 'none 'none)]))\n", "  (let ([negatives\
    \ (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n        [positives (filter\
    \ (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (define (helper lst neg-max pos-min)\n    (cond\
    \ [(empty? lst) (values neg-max pos-min)]\n          [(and (negative? (first lst))\n\
    \                (or (not neg-max)\n                    (&gt; (first lst) neg-max)))\n\
    \           (helper (rest lst) (first lst) pos-min)]\n          [(and (positive?\
    \ (first lst))\n                (or (not pos-min)\n                    (&lt; (first\
    \ lst) pos-min)))\n           (helper (rest lst) neg-max (first lst))]\n     \
    \     [else (helper (rest lst) neg-max pos-min)]))\n  (helper lst #f #f))\n",
  "  (let* ([negs (filter (\u03BB (x) (negative? x)) lst)]\n         [pos (filter\
    \ (\u03BB (x) (positive? x)) lst)])\n    (if (or (empty? negs) (empty? pos))\n\
    \        (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (define (is-positive? x)\n    (and (number? x) (> x 0)))\n  (define (is-negative?\
    \ x)\n    (and (number? x) (< x 0)))\n  (define (largest-negative lst)\n    (apply\
    \ max (filter is-negative? lst)))\n  (define (smallest-positive lst)\n    (apply\
    \ min (filter is-positive? lst)))\n  (cond [(empty? lst) (values #f #f)]\n   \
    \     [(and (is-positive? (first lst)) (is-negative? (first lst)))\n         (values\
    \ (largest-negative lst) (smallest-positive lst))]\n        [(is-positive? (first\
    \ lst))\n         (values (largest-negative (rest lst)) (smallest-positive lst))]\n\
    \        [(is-negative? (first lst))\n         (values (largest-negative lst)\
    \ (smallest-positive (rest lst)))]\n        [else (values #f #f)]))\n", "  (let\
    \ ([negs (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda\
    \ (x) (positive? x)) lst)])\n    (cond [(empty? negs) (values #f #f)]\n      \
    \    [(empty? pos) (values #f #f)]\n          [else (values (apply max negs) (apply\
    \ min pos))])))\n", "  (let ([negs (filter negative? lst)]\n        [pos (filter\
    \ positive? lst)])\n    (if (empty? negs)\n        (if (empty? pos)\n        \
    \    (values #f #f)\n            (values #f (apply min pos)))\n        (if (empty?\
    \ pos)\n            (values (apply max negs) #f)\n            (values (apply max\
    \ negs) (apply min pos))))))\n", "  (cond\n    [(empty? lst) (values 'none 'none)]\n\
    \    [(andmap number? lst)\n     (values (apply max (filter negative? lst))\n\
    \             (apply min (filter positive? lst)))]\n    [else (values 'none 'none)]))\n",
  "  (cond\n    [(empty? lst) (values 'None 'None)]\n    [(and (negative? (first lst))\
    \ (positive? (first lst))) (values (first lst) (first lst))]\n    [(negative?\
    \ (first lst)) (define (a b) (values (max a (first lst)) b))]\n    [(positive?\
    \ (first lst)) (define (a b) (values a (min b (first lst))))]\n    [else (define\
    \ (a b) (values a b))]\n    )\n  (apply (largest_smallest_integers (rest lst))\
    \ (a b))\n  )\n</code>\nI am getting the following error:\n<code>apply: expects\
    \ a procedure that can be applied to arguments\n  given: #&lt;procedure:largest_smallest_integers&gt;\n\
    \  arguments...:\n   '(1 2 3 4 5 6 7 8 9 10)\n   'None\n   'None\n</code>\nI am\
    \ not sure what I am doing wrong. I am trying to create a function that returns\
    \ a tuple, where the first element is the largest negative integer, and the second\
    \ element is the smallest positive integer. If there are no negative or positive\
    \ integers, then return <code>'None</code>.\nI am trying to use recursion to do\
    \ this. I am not sure if I am doing it correctly. I am not sure how to return\
    \ a tuple.\nI am trying to use <code>apply</code> to apply the function to the\
    \ arguments.\nI am not sure how to return a tuple.\nI am not sure if I am using\
    \ <code>apply</code> correctly.\nI am not sure if I am using <code>define</code>\
    \ correctly.\nI am not sure if I am using <code>cond</code> correctly.\nI am not\
    \ sure if I am using <code>values</code> correctly.\nI am not sure if I am using\
    \ <code>and</code> correctly.\nI am not sure if I am using <code>max</code> correctly.\n\
    I am not sure if I am using <code>min</code> correctly.\nI am not sure if I am\
    \ using <code>negative?</code> correctly.\nI am not sure if I am", "  (let ([negs\
    \ (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (if (empty?\
    \ negs)\n        (values (cons 'None (max pos))\n                (cons 'None (min\
    \ pos)))\n        (values (cons (max negs) (max pos))\n                (cons (min\
    \ negs) (min pos))))))\n", "  (cond\n    [(empty? lst) (values 'none 'none)]\n\
    \    [(andmap number? lst)\n     (values (apply max (filter negative? lst))\n\
    \             (apply min (filter positive? lst)))]\n    [else (values 'none 'none)]))\n",
  "  (define (largest_negative lst)\n    (cond [(empty? lst) #f]\n          [(and\
    \ (negative? (first lst))\n                (or (not (negative? (second lst)))\n\
    \                    (negative? (first lst))))\n           (first lst)]\n    \
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond [(empty? lst) #f]\n          [(and (positive? (first lst))\n      \
    \          (or (not (positive? (second lst)))\n                    (positive?\
    \ (first lst))))\n           (first lst)]\n          [else (smallest_positive\
    \ (rest lst))]))\n  (cond [(empty? lst) (values #f #f)]\n        [(and (not (largest_negative\
    \ lst))\n              (not (smallest_positive lst)))\n         (values #f #f)]\n\
    \        [(and (largest_negative lst)\n              (not (smallest_positive lst)))\n\
    \         (values (largest_negative lst) #f)]\n        [(and (not (largest_negative\
    \ lst))\n              (smallest_positive lst))\n         (values #f (smallest_positive\
    \ lst))]\n        [else (values (largest_negative lst)\n                     \
    \ (smallest_positive lst))]))\n", "  (define (helper lst)\n    (cond\n      [(empty?\
    \ lst) (values #f #f)]\n      [(and (integer? (first lst)) (positive? (first lst)))\n\
    \       (let ([a (first lst)])\n         (let ([b (second lst)])\n           (if\
    \ (and (integer? b) (positive? b))\n               (if (&lt; a b)\n          \
    \         (values a b)\n                   (values b a))\n               (values\
    \ a #f))))]\n      [(and (integer? (first lst)) (negative? (first lst)))\n   \
    \    (let ([a (first lst)])\n         (let ([b (second lst)])\n           (if\
    \ (and (integer? b) (negative? b))\n               (if (&gt; a b)\n          \
    \         (values a b)\n                   (values b a))\n               (values\
    \ a #f))))]\n      [else (helper (rest lst))]))\n  (let ([a (first (helper lst))])\n\
    \    (let ([b (second (helper lst))])\n      (if (and a b)\n          (values\
    \ a b)\n          (values #f #f)))))\n", "  (define (helper lst)\n    (cond\n\
    \      [(empty? lst) (values #f #f)]\n      [(and (integer? (first lst)) (negative?\
    \ (first lst)))\n       (let ([a (first lst)])\n         (let ([b (second lst)])\n\
    \           (if (and (integer? b) (positive? b))\n               (values a b)\n\
    \               (helper (rest lst))\n               )\n           )\n        \
    \ )\n       ]\n      [else (helper (rest lst))]\n      )\n    )\n  (let ([a (first\
    \ (helper lst))])\n    (let ([b (second (helper lst))])\n      (if (and a b)\n\
    \          (values a b)\n          (values #f #f)\n          )\n      )\n    )\n\
    \  )\n", "  (let ([neg (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (or (empty? neg) (empty? pos))\n      \
    \  (values #f #f)\n        (values (apply max neg) (apply min pos)))))\n", " \
    \ (let ([negs (filter (\u03BB (x) (and (integer? x) (< x 0))) lst)]\n        [pos\
    \ (filter (\u03BB (x) (and (integer? x) (> x 0))) lst)])\n    (if (and (not (empty?\
    \ negs)) (not (empty? pos)))\n        (values (apply max negs) (apply min pos))\n\
    \        (values #f #f))))\n", "  (let* ([negatives (filter negative? lst)]\n\
    \         [positives (filter positive? lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (let ([negs (filter (lambda (x) (negative?\
    \ x)) lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n    (cond\n\
    \      [(empty? negs) (cons #f #f)]\n      [(empty? pos) (cons #f #f)]\n     \
    \ [else (cons (apply max negs) (apply min pos))])))\n", "  (if (null? lst)\n \
    \     (values #f #f)\n      (let loop ((lst lst)\n                 (max #f)\n\
    \                 (min #f))\n        (cond ((null? lst) (values max min))\n  \
    \            ((and (positive? (car lst)) (not min))\n               (loop (cdr\
    \ lst) max (car lst)))\n              ((and (negative? (car lst)) (not max))\n\
    \               (loop (cdr lst) (car lst) min))\n              ((and (positive?\
    \ (car lst)) (< (car lst) min))\n               (loop (cdr lst) max (car lst)))\n\
    \              ((and (negative? (car lst)) (> (car lst) max))\n              \
    \ (loop (cdr lst) (car lst) min))\n              (else (loop (cdr lst) max min))))))\n",
  "  (cond\n    [(empty? lst) (values '() '())]\n    [(and (negative? (first lst))\
    \ (positive? (first lst))) (values (first lst) (first lst))]\n    [(negative?\
    \ (first lst)) (values (first lst) (second lst))]\n    [(positive? (first lst))\
    \ (values (second lst) (first lst))]\n    [else (values (first lst) (first lst))]))\n",
  "  (match lst\n    [(list) (values 'none 'none)]\n    [(list x) (values x x)]\n\
    \    [(list x xs ...)\n     (let ([(values a b) (largest_smallest_integers xs)])\n\
    \       (if (&lt; x a)\n           (values x b)\n           (if (&gt; x b)\n \
    \              (values a x)\n               (values a b))))]))\n</code>\n", " \
    \ (define (helper lst neg-max pos-min)\n    (cond\n      [(empty? lst) (values\
    \ neg-max pos-min)]\n      [(positive? (first lst))\n       (helper (rest lst)\
    \ neg-max (min (first lst) pos-min))]\n      [(negative? (first lst))\n      \
    \ (helper (rest lst) (max (first lst) neg-max) pos-min)]\n      [else (helper\
    \ (rest lst) neg-max pos-min)]))\n  (helper lst -1/0 1/0))\n", "  (let ([negatives\
    \ (filter (\u03BB (x) (and (integer? x) (< x 0))) lst)]\n        [positives (filter\
    \ (\u03BB (x) (and (integer? x) (> x 0))) lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (define (largest-negative lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(and (negative? (first lst))\n                (or (not\
    \ (negative? (second lst)))\n                    (negative? (first lst))))\n \
    \          (first lst)]\n          [else (largest-negative (rest lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond [(empty? lst) #f]\n          [(and (positive?\
    \ (first lst))\n                (or (not (positive? (second lst)))\n         \
    \           (positive? (first lst))))\n           (first lst)]\n          [else\
    \ (smallest-positive (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive\
    \ lst)))\n", "  (define (is-positive? n)\n    (and (integer? n)\n         (&gt;\
    \ n 0)))\n  (define (is-negative? n)\n    (and (integer? n)\n         (&lt; n\
    \ 0)))\n  (define (largest-negative lst)\n    (apply max (filter is-negative?\
    \ lst)))\n  (define (smallest-positive lst)\n    (apply min (filter is-positive?\
    \ lst)))\n  (cond [(empty? lst) '()]\n        [(and (is-positive? (first lst))\n\
    \              (is-negative? (first lst)))\n         (list (largest-negative lst)\n\
    \               (smallest-positive lst))]\n        [(is-positive? (first lst))\n\
    \         (list (largest-negative lst)\n               (smallest-positive lst))]\n\
    \        [(is-negative? (first lst))\n         (list (largest-negative lst)\n\
    \               (smallest-positive lst))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n</code>\nI'm not sure if I'm on the right track, but I'm getting\
    \ the following error:\n<code>largest_smallest_integers: contract violation\n\
    \  expected: (listof number?)\n  given: '()\n  in: the 2nd argument of\n     \
    \ (-&gt; (listof number?) (listof number?))\n  contract from: &lt;pkgs&gt;/racket/private/misc.rkt\n\
    \  blaming: &lt;pkgs&gt;/racket/private/misc.rkt\n   (assuming the contract is\
    \ correct)\n  at: &lt;pkgs&gt;/racket/private/misc.rkt:88.2\n</code>\nI'm not\
    \ sure what I'm doing wrong.\n\n\nA:\n\nYour <code>largest_smallest_integers</code>\
    \ function is returning <code>'()</code> when the list is empty.  That's not a\
    \ list of numbers, so it violates the contract.  You probably want to return <code>'(none\
    \ none)</code> instead.\n", "  (if (empty? lst)\n      (values #f #f)\n      (let\
    \ loop ((lst lst)\n                 (largest #f)\n                 (smallest #f))\n\
    \        (cond\n          [(empty? lst) (values largest smallest)]\n         \
    \ [(and (integer? (car lst))\n                (positive? (car lst))\n        \
    \        (not (integer? smallest)))\n           (loop (cdr lst) largest (car lst))]\n\
    \          [(and (integer? (car lst))\n                (positive? (car lst))\n\
    \                (< (car lst) smallest))\n           (loop (cdr lst) largest (car\
    \ lst))]\n          [(and (integer? (car lst))\n                (negative? (car\
    \ lst))\n                (not (integer? largest)))\n           (loop (cdr lst)\
    \ (car lst) smallest)]\n          [(and (integer? (car lst))\n               \
    \ (negative? (car lst))\n                (> (car lst) largest))\n           (loop\
    \ (cdr lst) (car lst) smallest)]\n          [else (loop (cdr lst) largest smallest)]))))\n",
  "  (let* ([negatives (filter (lambda (x) (negative? x)) lst)]\n         [positives\
    \ (filter (lambda (x) (positive? x)) lst)])\n    (if (or (empty? negatives) (empty?\
    \ positives))\n        (values #f #f)\n        (values (apply max negatives) (apply\
    \ min positives)))))\n", "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n\
    \        [positives (filter (lambda (x) (> x 0)) lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (define (helper lst neg-max pos-min)\n    (cond\n\
    \      [(empty? lst) (values neg-max pos-min)]\n      [(and (negative? (first\
    \ lst))\n            (or (not neg-max)\n                (&gt; (first lst) neg-max)))\n\
    \       (helper (rest lst) (first lst) pos-min)]\n      [(and (positive? (first\
    \ lst))\n            (or (not pos-min)\n                (&lt; (first lst) pos-min)))\n\
    \       (helper (rest lst) neg-max (first lst))]\n      [else (helper (rest lst)\
    \ neg-max pos-min)]))\n  (helper lst #f #f))\n", "  (let* ([negs (filter (lambda\
    \ (x) (and (integer? x) (< x 0))) lst)]\n         [pos (filter (lambda (x) (and\
    \ (integer? x) (> x 0))) lst)])\n    (cond [(empty? negs) (cons 'none (min pos))]\n\
    \          [(empty? pos) (cons (max negs) 'none)]\n          [else (cons (max\
    \ negs) (min pos))])))\n", "  (define (helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (values largest smallest)]\n      [(negative? (first lst))\n\
    \       (helper (rest lst) (max (first lst) largest) smallest)]\n      [(positive?\
    \ (first lst))\n       (helper (rest lst) largest (min (first lst) smallest))]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst -1/0 1/0))\n",
  "  (let* ([negatives (filter (\u03BB (x) (and (integer? x) (negative? x))) lst)]\n\
    \         [positives (filter (\u03BB (x) (and (integer? x) (positive? x))) lst)])\n\
    \    (cond\n      [(empty? negatives) (cons #f (min positives))]\n      [(empty?\
    \ positives) (cons (max negatives) #f)]\n      [else (cons (max negatives) (min\
    \ positives))])))\n", "  (define (largest-negative lst)\n    (cond\n      [(empty?\
    \ lst) 'none]\n      [(negative? (first lst)) (max (first lst) (largest-negative\
    \ (rest lst)))]\n      [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(empty? lst) 'none]\n      [(positive? (first lst))\
    \ (min (first lst) (smallest-positive (rest lst)))]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (list (largest-negative lst) (smallest-positive lst)))\n",
  "  (let ([negs (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n        [pos\
    \ (filter (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (if (and (not (empty?\
    \ negs)) (not (empty? pos)))\n        (values (apply max negs) (apply min pos))\n\
    \        (values #f #f))))\n", "  (define (largest-negative lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(and (negative? (first lst))\n                (or (not\
    \ (negative? (second lst)))\n                    (negative? (first lst))))\n \
    \          (first lst)]\n          [else (largest-negative (rest lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond [(empty? lst) #f]\n          [(and (positive?\
    \ (first lst))\n                (or (not (positive? (second lst)))\n         \
    \           (positive? (first lst))))\n           (first lst)]\n          [else\
    \ (smallest-positive (rest lst))]))\n  (define (largest-negative-smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(and (negative? (first lst))\n\
    \                (positive? (second lst)))\n           (list (first lst) (second\
    \ lst))]\n          [else (largest-negative-smallest-positive (rest lst))]))\n\
    \  (cond [(empty? lst) #f]\n        [(and (negative? (first lst))\n          \
    \    (positive? (second lst)))\n         (list (first lst) (second lst))]\n  \
    \      [(and (positive? (first lst))\n              (negative? (second lst)))\n\
    \         (list (second lst) (first lst))]\n        [(and (negative? (first lst))\n\
    \              (not (negative? (second lst))))\n         (list (first lst) (smallest-positive\
    \ (rest lst)))]\n        [(and (positive? (first lst))\n              (not (positive?\
    \ (second lst))))\n         (list (largest-negative (rest lst)) (first lst))]\n\
    \        [else (largest-negative-smallest-positive (rest lst))]))\n", "  (define\
    \ (largest-neg lst)\n    (cond [(empty? lst) 'none]\n          [(negative? (first\
    \ lst)) (max (first lst) (largest-neg (rest lst)))]\n          [else (largest-neg\
    \ (rest lst))]))\n  (define (smallest-pos lst)\n    (cond [(empty? lst) 'none]\n\
    \          [(positive? (first lst)) (min (first lst) (smallest-pos (rest lst)))]\n\
    \          [else (smallest-pos (rest lst))]))\n  (cond [(empty? lst) (values 'none\
    \ 'none)]\n        [else (values (largest-neg lst) (smallest-pos lst))]))\n",
  "  (cond\n    [(null? lst) (cons #f #f)]\n    [(and (negative? (car lst)) (not (negative?\
    \ (cdr lst))))\n     (cons (car lst) (cadr lst))]\n    [(and (negative? (car lst))\
    \ (negative? (cdr lst)))\n     (cons (car lst) (largest_smallest_integers (cdr\
    \ lst)))]\n    [(and (not (negative? (car lst))) (not (negative? (cdr lst))))\n\
    \     (cons (cadr lst) (car lst))]\n    [(and (not (negative? (car lst))) (negative?\
    \ (cdr lst)))\n     (cons (cadr lst) (car lst))]\n    [else (cons #f #f)]))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(empty? lst) 'None]\n     \
    \ [(and (negative? (first lst)) (not (negative? (second lst)))) (first lst)]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) 'None]\n      [(and (positive? (first lst)) (not\
    \ (positive? (second lst)))) (first lst)]\n      [else (smallest_positive (rest\
    \ lst))]))\n  (values (largest_negative lst) (smallest_positive lst)))\n", " \
    \ (match lst\n    [(list) (values 'None 'None)]\n    [(list x) (values x x)]\n\
    \    [(list x xs ...)\n     (let ([(values a b) (largest_smallest_integers xs)])\n\
    \       (if (and (not (negative? x)) (not (positive? x)))\n           (values\
    \ a b)\n           (if (negative? x)\n               (if (or (not a) (&gt; x a))\n\
    \                   (values x b)\n                   (values a b))\n         \
    \      (if (or (not b) (&lt; x b))\n                   (values a x)\n        \
    \           (values a b)))))]))\n", "  (let* ([negs (filter negative? lst)]\n\
    \         [pos (filter positive? lst)])\n    (if (or (empty? negs) (empty? pos))\n\
    \        (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n",
  "  (let ([negatives (filter negative? lst)]\n        [positives (filter positive?\
    \ lst)])\n    (if (or (empty? negatives) (empty? positives))\n        (values\
    \ #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (define (helper lst neg-max pos-min)\n    (cond\n      [(empty? lst) (values\
    \ neg-max pos-min)]\n      [(and (positive? (first lst)) (negative? neg-max))\n\
    \       (helper (rest lst) (first lst) pos-min)]\n      [(and (negative? (first\
    \ lst)) (positive? pos-min))\n       (helper (rest lst) neg-max (first lst))]\n\
    \      [(and (positive? (first lst)) (< (first lst) pos-min))\n       (helper\
    \ (rest lst) neg-max (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) neg-max))\n       (helper (rest lst) (first lst) pos-min)]\n      [else\
    \ (helper (rest lst) neg-max pos-min)]))\n  (helper lst -1/0 1/0))\n", "  (let\
    \ ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (if\
    \ (and (null? negs) (null? pos))\n        (values #f #f)\n        (values (apply\
    \ max negs) (apply min pos)))))\n", "  (let* ([negatives (filter (lambda (x) (and\
    \ (integer? x) (< x 0))) lst)]\n         [positives (filter (lambda (x) (and (integer?\
    \ x) (> x 0))) lst)])\n    (if (or (null? negatives) (null? positives))\n    \
    \    (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (define (helper lst neg-max pos-min)\n    (cond [(empty? lst) (values neg-max\
    \ pos-min)]\n          [(and (positive? (first lst)) (or (not pos-min) (< (first\
    \ lst) pos-min)))\n           (helper (rest lst) neg-max (first lst))]\n     \
    \     [(and (negative? (first lst)) (or (not neg-max) (> (first lst) neg-max)))\n\
    \           (helper (rest lst) (first lst) pos-min)]\n          [else (helper\
    \ (rest lst) neg-max pos-min)]))\n  (helper lst #f #f))\n", "  (let ([negatives\
    \ (filter (lambda (x) (and (integer? x) (negative? x))) lst)]\n        [positives\
    \ (filter (lambda (x) (and (integer? x) (positive? x))) lst)])\n    (if (or (empty?\
    \ negatives) (empty? positives))\n        (values #f #f)\n        (values (apply\
    \ max negatives) (apply min positives)))))\n", "  (define (helper lst acc)\n \
    \   (cond\n      [(empty? lst) acc]\n      [(and (positive? (first lst)) (positive?\
    \ (second lst)))\n       (helper (rest lst) (cons (first lst) acc))]\n      [(and\
    \ (negative? (first lst)) (negative? (second lst)))\n       (helper (rest lst)\
    \ (cons (first lst) acc))]\n      [else (helper (rest lst) acc)]))\n  (define\
    \ (helper2 lst acc)\n    (cond\n      [(empty? lst) acc]\n      [(and (positive?\
    \ (first lst)) (positive? (second lst)))\n       (helper2 (rest lst) (cons (first\
    \ lst) acc))]\n      [(and (negative? (first lst)) (negative? (second lst)))\n\
    \       (helper2 (rest lst) (cons (first lst) acc))]\n      [else (helper2 (rest\
    \ lst) acc)]))\n  (if (empty? lst)\n      (cons 'none 'none)\n      (cons (apply\
    \ max (helper lst '()))\n            (apply min (helper2 lst '())))))\n", "  (cond\
    \ [(empty? lst) (values '() '())]\n        [(and (negative? (first lst)) (positive?\
    \ (first lst))) (values (first lst) (first lst))]\n        [(negative? (first\
    \ lst)) (values (first lst) (second lst))]\n        [(positive? (first lst)) (values\
    \ (second lst) (first lst))]\n        [else (values (first lst) (first lst))]))\n",
  "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst) (values neg pos)]\n\
    \      [(negative? (first lst)) (helper (rest lst) (first lst) pos)]\n      [(positive?\
    \ (first lst)) (helper (rest lst) neg (first lst))]\n      [else (helper (rest\
    \ lst) neg pos)]))\n  (helper lst 0 0))\n", "  (define (is-negative? n)\n    (and\
    \ (number? n) (< n 0)))\n  (define (is-positive? n)\n    (and (number? n) (> n\
    \ 0)))\n  (define (find-largest-negative lst)\n    (cond [(null? lst) #f]\n  \
    \        [(is-negative? (car lst))\n           (max (car lst) (find-largest-negative\
    \ (cdr lst)))]\n          [else (find-largest-negative (cdr lst))]))\n  (define\
    \ (find-smallest-positive lst)\n    (cond [(null? lst) #f]\n          [(is-positive?\
    \ (car lst))\n           (min (car lst) (find-smallest-positive (cdr lst)))]\n\
    \          [else (find-smallest-positive (cdr lst))]))\n  (cond [(and (not (find-largest-negative\
    \ lst))\n              (not (find-smallest-positive lst)))\n         (values #f\
    \ #f)]\n        [(not (find-largest-negative lst))\n         (values #f (find-smallest-positive\
    \ lst))]\n        [(not (find-smallest-positive lst))\n         (values (find-largest-negative\
    \ lst) #f)]\n        [else (values (find-largest-negative lst)\n             \
    \         (find-smallest-positive lst))]))\n", "  (define (helper lst)\n    (cond\
    \ [(empty? lst) (values #f #f)]\n          [(and (negative? (first lst)) (not\
    \ (positive? (first lst))))\n           (let ([a (first lst)])\n             (let\
    \ ([b (first (rest lst))])\n               (if (and (negative? b) (not (positive?\
    \ b)))\n                   (values a b)\n                   (values a #f))))]\n\
    \          [(and (positive? (first lst)) (not (negative? (first lst))))\n    \
    \       (let ([a (first lst)])\n             (let ([b (first (rest lst))])\n \
    \              (if (and (positive? b) (not (negative? b)))\n                 \
    \  (values a b)\n                   (values a #f))))]\n          [else (helper\
    \ (rest lst))]))\n  (let ([a (first (helper lst))])\n    (let ([b (second (helper\
    \ lst))])\n      (if (and a b)\n          (values a b)\n          (values #f #f)))))\n",
  "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n        [positives (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (and (empty? negatives) (empty? positives))\n\
    \        (values #f #f)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (and (empty? negs) (empty? pos))\n        (values 'none 'none)\n    \
    \    (values (apply max negs) (apply min pos)))))\n", "  (define (helper lst)\n\
    \    (cond [(empty? lst) (values #f #f)]\n          [(and (negative? (first lst))\
    \ (not (negative? (second lst))))\n           (values (first lst) (second lst))]\n\
    \          [(and (positive? (first lst)) (not (positive? (second lst))))\n   \
    \        (values (second lst) (first lst))]\n          [else (helper (rest lst))]))\n\
    \  (let ([a (helper lst)])\n    (cond [(and (first a) (second a)) (values (first\
    \ a) (second a))]\n          [(first a) (values (first a) #f)]\n          [(second\
    \ a) (values #f (second a))]\n          [else (values #f #f)])))\n", "  (let ((negs\
    \ (filter negative? lst))\n        (pos (filter positive? lst)))\n    (if (and\
    \ (empty? negs) (empty? pos))\n        (values #f #f)\n        (values (apply\
    \ max negs) (apply min pos)))))\n", "  (define (helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (values largest smallest)]\n      [(and (negative?\
    \ (first lst))\n            (or (not (number? largest))\n                (&gt;\
    \ (first lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n \
    \     [(and (positive? (first lst))\n            (or (not (number? smallest))\n\
    \                (&lt; (first lst) smallest)))\n       (helper (rest lst) largest\
    \ (first lst))]\n      [else (helper (rest lst) largest smallest)]))\n  (helper\
    \ lst #f #f))\n", "  (define (helper lst)\n    (cond\n      [(empty? lst) (values\
    \ #f #f)]\n      [(and (negative? (first lst)) (not (positive? (first lst))))\n\
    \       (let ([a (first lst)])\n         (let ([b (second lst)])\n           (if\
    \ (and (negative? b) (not (positive? b)))\n               (helper (rest lst))\n\
    \               (values a b))))]\n      [(and (positive? (first lst)) (not (negative?\
    \ (first lst))))\n       (let ([a (first lst)])\n         (let ([b (second lst)])\n\
    \           (if (and (positive? b) (not (negative? b)))\n               (helper\
    \ (rest lst))\n               (values a b))))]\n      [else (helper (rest lst))]))\n\
    \  (let ([a (first (helper lst))])\n    (let ([b (second (helper lst))])\n   \
    \   (if (and (not a) (not b))\n          (values #f #f)\n          (values a b)))))\n",
  "  (let ([negs (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda\
    \ (x) (positive? x)) lst)])\n    (cond [(empty? negs) (cons #f #f)]\n        \
    \  [(empty? pos) (cons (apply max negs) #f)]\n          [else (cons (apply max\
    \ negs) (apply min pos))])))\n", "  (if (empty? lst)\n      (values #f #f)\n \
    \     (let loop ([lst lst] [largest #f] [smallest #f])\n        (cond\n      \
    \    [(empty? lst) (values largest smallest)]\n          [(and (number? (car lst))\
    \ (< (car lst) 0))\n           (loop (cdr lst) (max (car lst) largest) smallest)]\n\
    \          [(and (number? (car lst)) (> (car lst) 0))\n           (loop (cdr lst)\
    \ largest (min (car lst) smallest))]\n          [else (loop (cdr lst) largest\
    \ smallest)]))))\n", "  (cond\n    [(empty? lst) (values '() '())]\n    [(and\
    \ (positive? (car lst)) (negative? (car lst))) (values '() '())]\n    [(positive?\
    \ (car lst)) (values (largest_smallest_integers (cdr lst)) (car lst))]\n    [(negative?\
    \ (car lst)) (values (car lst) (largest_smallest_integers (cdr lst)))]\n    [else\
    \ (values (largest_smallest_integers (cdr lst)) (largest_smallest_integers (cdr\
    \ lst)))]))\n", "  (cond\n    [(empty? lst) (cons 'none 'none)]\n    [(andmap\
    \ number? lst)\n     (cons (apply max (filter negative? lst))\n           (apply\
    \ min (filter positive? lst)))]\n    [else (cons 'none 'none)]))\n", "  (let ([negs\
    \ (filter negative? lst)]\n        [pos (filter positive? lst)])\n    (cond [(empty?\
    \ negs) (values #f #f)]\n          [(empty? pos) (values #f #f)]\n          [else\
    \ (values (apply max negs) (apply min pos))])))\n", "  (let ([neg-nums (filter\
    \ negative? lst)]\n        [pos-nums (filter positive? lst)])\n    (if (or (empty?\
    \ neg-nums) (empty? pos-nums))\n        (values #f #f)\n        (values (apply\
    \ max neg-nums) (apply min pos-nums)))))\n", "  (let* ([negatives (filter (lambda\
    \ (x) (negative? x)) lst)]\n         [positives (filter (lambda (x) (positive?\
    \ x)) lst)])\n    (if (and (not (empty? negatives)) (not (empty? positives)))\n\
    \        (values (apply max negatives) (apply min positives))\n        (values\
    \ #f #f))))\n", "  (define (helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (values largest smallest)]\n      [(and (positive? (first lst)) (or (not\
    \ smallest) (&lt; (first lst) smallest)))\n       (helper (rest lst) largest (first\
    \ lst))]\n      [(and (negative? (first lst)) (or (not largest) (&gt; (first lst)\
    \ largest)))\n       (helper (rest lst) (first lst) smallest)]\n      [else (helper\
    \ (rest lst) largest smallest)]))\n  (helper lst #f #f))\n</code>\n", "  (define\
    \ (is-positive? n)\n    (and (number? n) (> n 0)))\n  (define (is-negative? n)\n\
    \    (and (number? n) (< n 0)))\n  (define (is-integer? n)\n    (and (number?\
    \ n) (integer? n)))\n  (define (max-negative lst)\n    (apply max (filter is-negative?\
    \ lst)))\n  (define (min-positive lst)\n    (apply min (filter is-positive? lst)))\n\
    \  (define (max-negative-or-none lst)\n    (if (empty? (filter is-negative? lst))\n\
    \        'none\n        (max-negative lst)))\n  (define (min-positive-or-none\
    \ lst)\n    (if (empty? (filter is-positive? lst))\n        'none\n        (min-positive\
    \ lst)))\n  (define (integers-or-none lst)\n    (if (empty? (filter is-integer?\
    \ lst))\n        'none\n        (cons (max-negative-or-none lst) (min-positive-or-none\
    \ lst))))\n  (integers-or-none lst))\n", "  (define (helper lst neg pos)\n   \
    \ (cond\n      [(empty? lst) (values neg pos)]\n      [(< (first lst) 0) (helper\
    \ (rest lst) (max (first lst) neg) pos)]\n      [(> (first lst) 0) (helper (rest\
    \ lst) neg (min (first lst) pos))]\n      [else (helper (rest lst) neg pos)]))\n\
    \  (helper lst 0 (first lst)))\n", "  (let ([negs (filter (lambda (x) (negative?\
    \ x)) lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n    (if (or\
    \ (null? negs) (null? pos))\n        (values #f #f)\n        (values (apply max\
    \ negs) (apply min pos)))))\n", "  (define (helper lst neg-max pos-min)\n    (cond\n\
    \      [(null? lst) (values neg-max pos-min)]\n      [(and (positive? (car lst))\n\
    \            (or (not pos-min)\n                (< (car lst) pos-min)))\n    \
    \   (helper (cdr lst) neg-max (car lst))]\n      [(and (negative? (car lst))\n\
    \            (or (not neg-max)\n                (> (car lst) neg-max)))\n    \
    \   (helper (cdr lst) (car lst) pos-min)]\n      [else (helper (cdr lst) neg-max\
    \ pos-min)]))\n  (helper lst #f #f))\n", "  (let* ([negatives (filter negative?\
    \ lst)]\n         [positives (filter positive? lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (cond\n    [(empty? lst) (values 'none 'none)]\n\
    \    [(andmap number? lst) (values (apply max (filter negative? lst))\n      \
    \                            (apply min (filter positive? lst)))]\n    [else (values\
    \ 'none 'none)]))\n", "  (let* ([negative-integers (filter (lambda (x) (and (integer?\
    \ x) (< x 0))) lst)]\n         [positive-integers (filter (lambda (x) (and (integer?\
    \ x) (> x 0))) lst)])\n    (cond [(empty? negative-integers) (cons #f (min positive-integers))]\n\
    \          [(empty? positive-integers) (cons (max negative-integers) #f)]\n  \
    \        [else (cons (max negative-integers) (min positive-integers))])))\n",
  "  (cond\n    [(empty? lst) (values #f #f)]\n    [(and (negative? (first lst)) (positive?\
    \ (first lst))) (values (first lst) (first lst))]\n    [(negative? (first lst))\
    \ (let ([a (first lst)])\n                               (define (loop lst a)\n\
    \                                 (cond\n                                   [(empty?\
    \ lst) (values a #f)]\n                                   [(and (negative? (first\
    \ lst)) (positive? (first lst))) (values a (first lst))]\n                   \
    \                [(negative? (first lst)) (loop (rest lst) (max a (first lst)))]\n\
    \                                   [(positive? (first lst)) (values a (first\
    \ lst))]))\n                               (loop (rest lst) a))]\n    [(positive?\
    \ (first lst)) (let ([b (first lst)])\n                               (define\
    \ (loop lst b)\n                                 (cond\n                     \
    \              [(empty? lst) (values #f b)]\n                                \
    \   [(and (negative? (first lst)) (positive? (first lst))) (values (first lst)\
    \ b)]\n                                   [(negative? (first lst)) (values (first\
    \ lst) b)]\n                                   [(positive? (first lst)) (loop\
    \ (rest lst) (min b (first lst)))]))\n                               (loop (rest\
    \ lst) b))]))\n", "  (let ([negs (filter negative? lst)]\n        [pos (filter\
    \ positive? lst)])\n    (if (empty? negs)\n        (if (empty? pos)\n        \
    \    (values #f #f)\n            (values #f (min pos)))\n        (if (empty? pos)\n\
    \            (values (max negs) #f)\n            (values (max negs) (min pos))))))\n",
  "  (cond [(empty? lst) (values #f #f)]\n        [(andmap number? lst)\n        \
    \ (let ([neg (filter (lambda (x) (negative? x)) lst)]\n               [pos (filter\
    \ (lambda (x) (positive? x)) lst)])\n           (values (apply max neg) (apply\
    \ min pos)))]\n        [else (values #f #f)]))\n", "  (cond\n    [(empty? lst)\
    \ (values 'None 'None)]\n    [(andmap number? lst) (values (apply max (filter\
    \ negative? lst))\n                                  (apply min (filter positive?\
    \ lst)))]\n    [else (values 'None 'None)]))\n", "  (let ([negatives (filter (lambda\
    \ (x) (and (integer? x) (< x 0))) lst)]\n        [positives (filter (lambda (x)\
    \ (and (integer? x) (> x 0))) lst)])\n    (if (or (empty? negatives) (empty? positives))\n\
    \        (values 'none 'none)\n        (values (apply max negatives) (apply min\
    \ positives)))))\n", "  (define (largest-negative lst)\n    (cond [(empty? lst)\
    \ #f]\n          [(and (negative? (first lst))\n                (or (not (negative?\
    \ (second lst)))\n                    (negative? (first lst))))\n           (first\
    \ lst)]\n          [else (largest-negative (rest lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond [(empty? lst) #f]\n          [(and (positive? (first lst))\n\
    \                (or (not (positive? (second lst)))\n                    (positive?\
    \ (first lst))))\n           (first lst)]\n          [else (smallest-positive\
    \ (rest lst))]))\n  (cons (largest-negative lst) (smallest-positive lst)))\n",
  "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst) (values neg pos)]\n\
    \      [(< (first lst) 0) (helper (rest lst) (max (first lst) neg) pos)]\n   \
    \   [(> (first lst) 0) (helper (rest lst) neg (min (first lst) pos))]\n      [else\
    \ (helper (rest lst) neg pos)]))\n  (helper lst 0 0))\n", "  (let* ([negs (filter\
    \ negative? lst)]\n         [pos (filter positive? lst)])\n    (cond [(empty?\
    \ negs) (cons #f #f)]\n          [(empty? pos) (cons (max negs) #f)]\n       \
    \   [else (cons (max negs) (min pos))])))\n", "  (cond\n    [(empty? lst) (cons\
    \ 'None 'None)]\n    [(andmap number? lst)\n     (let ([negatives (filter (lambda\
    \ (x) (< x 0)) lst)]\n           [positives (filter (lambda (x) (> x 0)) lst)])\n\
    \       (cond\n         [(empty? negatives) (cons 'None (min positives))]\n  \
    \       [(empty? positives) (cons (max negatives) 'None)]\n         [else (cons\
    \ (max negatives) (min positives))]))]\n    [else (cons 'None 'None)]))\n", " \
    \ (define (largest-neg lst)\n    (cond [(empty? lst) 'none]\n          [(and (negative?\
    \ (first lst)) (not (negative? (second lst))))\n           (first lst)]\n    \
    \      [else (largest-neg (rest lst))]))\n  (define (smallest-pos lst)\n    (cond\
    \ [(empty? lst) 'none]\n          [(and (positive? (first lst)) (not (positive?\
    \ (second lst))))\n           (first lst)]\n          [else (smallest-pos (rest\
    \ lst))]))\n  (list (largest-neg lst) (smallest-pos lst)))\n", "  (let ([negatives\
    \ (filter (lambda (x) (< x 0)) lst)]\n        [positives (filter (lambda (x) (>\
    \ x 0)) lst)])\n    (if (or (empty? negatives) (empty? positives))\n        (values\
    \ 'None 'None)\n        (values (apply max negatives) (apply min positives)))))\n",
  "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n        [positives (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (or (null? negatives) (null? positives))\n\
    \        (values 'None 'None)\n        (values (apply max negatives) (apply min\
    \ positives)))))\n", "  (define (helper lst neg-max pos-min)\n    (cond [(empty?\
    \ lst) (values neg-max pos-min)]\n          [(and (negative? (first lst))\n  \
    \              (or (not neg-max) (&gt; (first lst) neg-max)))\n           (helper\
    \ (rest lst) (first lst) pos-min)]\n          [(and (positive? (first lst))\n\
    \                (or (not pos-min) (&lt; (first lst) pos-min)))\n           (helper\
    \ (rest lst) neg-max (first lst))]\n          [else (helper (rest lst) neg-max\
    \ pos-min)]))\n  (helper lst #f #f))\n", "  (cond\n    [(empty? lst) (values 'none\
    \ 'none)]\n    [(andmap number? lst)\n     (let ([negs (filter negative? lst)]\n\
    \           [pos (filter positive? lst)])\n       (values (apply max negs) (apply\
    \ min pos)))]\n    [else (values 'none 'none)]))\n", "  (define (helper lst neg-max\
    \ pos-min)\n    (cond [(empty? lst) (values neg-max pos-min)]\n          [(< (first\
    \ lst) 0)\n           (helper (rest lst) (max (first lst) neg-max) pos-min)]\n\
    \          [(> (first lst) 0)\n           (helper (rest lst) neg-max (min (first\
    \ lst) pos-min))]\n          [else (helper (rest lst) neg-max pos-min)]))\n  (helper\
    \ lst -10000000000 10000000000))\n", "  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) 'None]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (first lst)]\n      [else (largest-negative (rest lst))]))\n\
    \  (define (smallest-positive lst)\n    (cond\n      [(empty? lst) 'None]\n  \
    \    [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n\
    \      [else (smallest-positive (rest lst))]))\n  (list (largest-negative lst)\
    \ (smallest-positive lst)))\n", "  (if (empty? lst)\n      (values #f #f)\n  \
    \    (let ((negatives (filter (lambda (x) (negative? x)) lst))\n            (positives\
    \ (filter (lambda (x) (positive? x)) lst)))\n        (values (if (empty? negatives)\n\
    \                    #f\n                    (apply max negatives))\n        \
    \        (if (empty? positives)\n                    #f\n                    (apply\
    \ min positives))))))\n", "  (let ([negs (filter (\u03BB (x) (negative? x)) lst)]\n\
    \        [pos (filter (\u03BB (x) (positive? x)) lst)])\n    (if (empty? negs)\n\
    \        (if (empty? pos)\n            (values #f #f)\n            (values #f\
    \ (apply min pos)))\n        (if (empty? pos)\n            (values (apply max\
    \ negs) #f)\n            (values (apply max negs) (apply min pos))))))\n", " \
    \ (let ([negs (filter (lambda (x) (negative? x)) lst)]\n        [pos (filter (lambda\
    \ (x) (positive? x)) lst)])\n    (if (or (empty? negs) (empty? pos))\n       \
    \ (values #f #f)\n        (values (apply max negs) (apply min pos)))))\n", " \
    \ (define (largest_negative lst)\n    (cond\n      [(empty? lst) 'none]\n    \
    \  [(and (negative? (first lst))\n            (or (empty? (rest lst))\n      \
    \          (negative? (first (rest lst)))))\n       (first lst)]\n      [else\
    \ (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) 'none]\n      [(and (positive? (first lst))\n           \
    \ (or (empty? (rest lst))\n                (positive? (first (rest lst)))))\n\
    \       (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (cons (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (let ([neg (filter (lambda (x) (and (integer?\
    \ x) (< x 0))) lst)]\n        [pos (filter (lambda (x) (and (integer? x) (> x\
    \ 0))) lst)])\n    (cond [(empty? neg) (values 'none 'none)]\n          [(empty?\
    \ pos) (values 'none 'none)]\n          [else (values (apply max neg) (apply min\
    \ pos))])))\n", "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst)\
    \ (values neg pos)]\n      [(negative? (first lst)) (helper (rest lst) (max (first\
    \ lst) neg) pos)]\n      [(positive? (first lst)) (helper (rest lst) neg (min\
    \ (first lst) pos))]\n      [else (helper (rest lst) neg pos)]))\n  (helper lst\
    \ 0 0))\n", "  (define (helper lst neg-max pos-min)\n    (cond [(empty? lst) (values\
    \ neg-max pos-min)]\n          [(and (negative? (first lst))\n               \
    \ (&gt; (first lst) neg-max))\n           (helper (rest lst) (first lst) pos-min)]\n\
    \          [(and (positive? (first lst))\n                (&lt; (first lst) pos-min))\n\
    \           (helper (rest lst) neg-max (first lst))]\n          [else (helper\
    \ (rest lst) neg-max pos-min)]))\n  (helper lst -1/0 1/0))\n", "  (let* ([negs\
    \ (filter negative? lst)]\n         [pos (filter positive? lst)])\n    (if (or\
    \ (empty? negs) (empty? pos))\n        (values #f #f)\n        (values (apply\
    \ max negs) (apply min pos)))))\n", "  (cond\n    [(empty? lst) (cons #f #f)]\n\
    \    [(and (positive? (car lst)) (negative? (car lst)))\n     (cons (car lst)\
    \ (car lst))]\n    [(positive? (car lst))\n     (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n    [(negative? (car lst))\n     (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n    [else (largest_smallest_integers (cdr lst))]))\n", "  (cond\n\
    \    [(empty? lst) (cons 'None 'None)]\n    [(andmap number? lst)\n     (cons\
    \ (apply max (filter negative? lst))\n           (apply min (filter positive?\
    \ lst)))]\n    [else (cons 'None 'None)]))\n", "  (let ([negatives (filter negative?\
    \ lst)]\n        [positives (filter positive? lst)])\n    (if (or (empty? negatives)\
    \ (empty? positives))\n        (values #f #f)\n        (values (apply max negatives)\
    \ (apply min positives)))))\n", "  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) 'none]\n      [(and (negative? (first lst))\n           \
    \ (or (empty? (rest lst))\n                (negative? (first (rest lst)))))\n\
    \       (first lst)]\n      [else (largest-negative (rest lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond\n      [(empty? lst) 'none]\n      [(and\
    \ (positive? (first lst))\n            (or (empty? (rest lst))\n             \
    \   (positive? (first (rest lst)))))\n       (first lst)]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (list (largest-negative lst) (smallest-positive lst)))\n",
  "  (let* ([negatives (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n   \
    \      [positives (filter (lambda (x) (and (integer? x) (> x 0))) lst)])\n   \
    \ (if (or (empty? negatives) (empty? positives))\n        (values #f #f)\n   \
    \     (values (apply max negatives) (apply min positives)))))\n", "  (cond\n \
    \   [(empty? lst) (cons 'none 'none)]\n    [(andmap number? lst)\n     (cons (apply\
    \ max (filter negative? lst))\n           (apply min (filter positive? lst)))]\n\
    \    [else (cons 'none 'none)]))\n", "  (match lst\n    [(list) '(None None)]\n\
    \    [(list x) (if (integer? x)\n                  (if (positive? x)\n       \
    \               (list None x)\n                      (list x None))\n        \
    \          '(None None))]\n    [(list x xs ...)\n     (let ([(list a b) (largest_smallest_integers\
    \ xs)])\n       (if (integer? x)\n           (if (positive? x)\n             \
    \  (if (and (not (eq? a None))\n                        (&lt; a x))\n        \
    \           (list a x)\n                   (list a b))\n               (if (and\
    \ (not (eq? b None))\n                        (&gt; b x))\n                  \
    \ (list x b)\n                   (list a b)))\n           (list a b)))]))\n</code>\n",
  "  (let ([negs (filter (\u03BB (x) (and (number? x) (< x 0))) lst)]\n        [pos\
    \ (filter (\u03BB (x) (and (number? x) (> x 0))) lst)])\n    (if (or (empty? negs)\
    \ (empty? pos))\n        (values #f #f)\n        (values (apply max negs) (apply\
    \ min pos)))))\n", "  (define (positive-integers lst)\n    (filter positive? lst))\n\
    \  (define (negative-integers lst)\n    (filter negative? lst))\n  (define (max-negative\
    \ lst)\n    (apply max (negative-integers lst)))\n  (define (min-positive lst)\n\
    \    (apply min (positive-integers lst)))\n  (if (and (positive-integers lst)\
    \ (negative-integers lst))\n      (list (max-negative lst) (min-positive lst))\n\
    \      (list)))\n", "  (let ([neg-nums (filter negative? lst)]\n        [pos-nums\
    \ (filter positive? lst)])\n    (if (and (empty? neg-nums) (empty? pos-nums))\n\
    \        (values #f #f)\n        (values (apply max neg-nums) (apply min pos-nums)))))\n",
  "  (let ([negatives (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n    \
    \    [positives (filter (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (if\
    \ (or (null? negatives) (null? positives))\n        (values #f #f)\n        (values\
    \ (apply max negatives) (apply min positives)))))\n", "  (define (largest-negative\
    \ lst)\n    (cond [(empty? lst) 'none]\n          [(and (negative? (first lst))\n\
    \                (or (not (negative? (second lst)))\n                    (empty?\
    \ (rest lst))))\n           (first lst)]\n          [else (largest-negative (rest\
    \ lst))]))\n  (define (smallest-positive lst)\n    (cond [(empty? lst) 'none]\n\
    \          [(and (positive? (first lst))\n                (or (not (positive?\
    \ (second lst)))\n                    (empty? (rest lst))))\n           (first\
    \ lst)]\n          [else (smallest-positive (rest lst))]))\n  (list (largest-negative\
    \ lst) (smallest-positive lst)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
