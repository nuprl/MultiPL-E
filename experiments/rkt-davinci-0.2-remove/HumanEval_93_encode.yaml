name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n(define (encode\
  \ message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if\
    \ (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel? c)\n     \
    \   (let ((vowels (string->list \"aeiou\")))\n          (list-ref vowels (modulo\
    \ (+ (list-index (list-ref vowels c) vowels) 2) 5)))\n        c))\n  (list->string\
    \ (map encode-char (map swap-case (string->list message)))))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n \
    \        (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (swap-case c)\n         (if (char-upper-case? c)\n             (char-downcase\
    \ c)\n             (char-upcase c)))\n       (define (next-char c)\n         (integer->char\
    \ (+ (char->integer c) 1)))\n       (define (next-next-char c)\n         (integer->char\
    \ (+ (char->integer c) 2)))\n       (cond\n         [(is-vowel? c)\n         \
    \ (next-next-char c)]\n         [else\n          (swap-case c)])]\n      [else\n\
    \       c]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n\
    \    (if (char-alphabetic? c)\n        (if (char-upper-case? c)\n            (char-downcase\
    \ c)\n            (char-upcase c))\n        c))\n  (define (encode-char c)\n \
    \   (if (char-vowel? c)\n        (if (char=? c #\\z)\n            #\\b\n     \
    \       (if (char=? c #\\y)\n                #\\a\n                (char+ c 2)))\n\
    \        c))\n  (define (encode-string s)\n    (if (string-empty? s)\n       \
    \ \"\"\n        (string-append (string (encode-char (string-ref s 0)))\n     \
    \                  (encode-string (substring s 1)))))\n  (encode-string (string-map\
    \ swap-case message)))\n", "  (define (swap-case c)\n    (cond\n      [(char-lower-case?\
    \ c) (char-upcase c)]\n      [(char-upper-case? c) (char-downcase c)]\n      [else\
    \ c]))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)])\n\
    \    (for/list ([c (in-string message)])\n      (cond\n        [(char-alphabetic?\
    \ c)\n         (if (member (char-downcase c) vowels)\n             (char-upcase\
    \ (char-next (char-next (char-downcase c))))\n             (char-upcase c))]\n\
    \        [else c]))))\n", "  (string-map (lambda (c)\n                (cond\n\
    \                  [(char-alphabetic? c)\n                   (char-upcase c)]\n\
    \                  [else\n                   c]))\n              message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-vowel c)\n         (cond\n           [(char=? c #\\a) #\\c]\n        \
    \   [(char=? c #\\e) #\\g]\n           [(char=? c #\\i) #\\k]\n           [(char=?\
    \ c #\\o) #\\q]\n           [(char=? c #\\u) #\\w]\n           [(char=? c #\\\
    y) #\\a]\n           [else #\\a]))\n       (define (next-consonant c)\n      \
    \   (cond\n           [(char=? c #\\b) #\\d]\n           [(char=? c #\\d) #\\\
    f]\n           [(char=? c #\\f) #\\h]\n           [(char=? c #\\h) #\\j]\n   \
    \        [(char=? c #\\j) #\\l]\n           [(char=? c #\\l) #\\n]\n         \
    \  [(char=? c #\\n) #\\p]\n           [(char=? c #\\p) #\\r]\n           [(char=?\
    \ c #\\r) #\\t]\n           [(char=? c #\\t) #\\v]\n           [(char=? c #\\\
    v) #\\x]\n           [(char=? c #\\x) #\\z]\n           [(char=? c #\\z) #\\b]\n\
    \           [else #\\b]))\n       (cond\n         [(char-vowel? c)\n         \
    \ (next-vowel c)]\n         [else\n          (next-consonant c)])]\n      [else\n\
    \       c]))\n  (string-map encode-char message))\n", "  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (swap-case c)\n\
    \    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (shift-vowel c)\n    (cond ((char=? c #\\a) #\\c)\n        \
    \  ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=?\
    \ c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n          (else c)))\n  (string-map\n\
    \   (lambda (c)\n     (if (is-vowel? c)\n         (shift-vowel c)\n         (swap-case\
    \ c)))\n   message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n\
    \        (if (char-upper-case? c)\n            (char-downcase c)\n           \
    \ (char-upcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (list-ref\
    \ '(#\\c #\\f #\\j #\\o #\\t)\n                      (position c '(#\\a #\\e #\\\
    i #\\o #\\u)))\n            (swap-case c))\n        c))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic? c)\n\
    \        (let* ([vowels (string-&gt;list \"aeiou\")]\n               [vowel-index\
    \ (list-index (lambda (v) (char=? v c)) vowels)]\n               [next-vowel (list-ref\
    \ vowels (modulo (+ 2 vowel-index) (length vowels)))]\n               [next-vowel-index\
    \ (list-index (lambda (v) (char=? v next-vowel)) vowels)])\n          (list-ref\
    \ vowels next-vowel-index))\n        c))\n  (list-&gt;string (map encode-char\
    \ (map swap-case (string-&gt;list message)))))\n</code>\n", "  (string-upcase\
    \ (string-replace message \"a\" \"c\")\n                 (string-replace message\
    \ \"e\" \"g\")\n                 (string-replace message \"i\" \"k\")\n      \
    \           (string-replace message \"o\" \"q\")\n                 (string-replace\
    \ message \"u\" \"w\")\n                 (string-replace message \"A\" \"C\")\n\
    \                 (string-replace message \"E\" \"G\")\n                 (string-replace\
    \ message \"I\" \"K\")\n                 (string-replace message \"O\" \"Q\")\n\
    \                 (string-replace message \"U\" \"W\")))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let* ([vowels (string-&gt;list\
    \ \"aeiou\")]\n               [vowel-index (list-index (lambda (v) (char=? v c))\
    \ vowels)]\n               [next-vowel (list-ref vowels (modulo (+ 2 vowel-index)\
    \ (length vowels)))]\n               [next-vowel-index (list-index (lambda (v)\
    \ (char=? v next-vowel)) vowels)])\n          (list-ref vowels (modulo (+ 2 next-vowel-index)\
    \ (length vowels))))\n        c))\n  (string-join (map (lambda (c) (encode-char\
    \ (swap-case c))) (string-&gt;list message))))\n", "  (string-map\n   (lambda\
    \ (c)\n     (cond\n       [(char-alphabetic? c)\n        (let ([c (char-upcase\
    \ c)])\n          (cond\n            [(char=? c #\\A) #\\C]\n            [(char=?\
    \ c #\\E) #\\G]\n            [(char=? c #\\I) #\\K]\n            [(char=? c #\\\
    O) #\\Q]\n            [(char=? c #\\U) #\\W]\n            [(char=? c #\\Y) #\\\
    A]\n            [else (char-downcase (char-next c))]))]\n       [else c]))\n \
    \  message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (map (lambda (c)\n         (cond\n           [(char-alphabetic? c)\n       \
    \     (if (char-lower-case? c)\n                (char-upcase c)\n            \
    \    (char-downcase c))]\n           [(char=? c #\\a) #\\c]\n           [(char=?\
    \ c #\\e) #\\g]\n           [(char=? c #\\i) #\\k]\n           [(char=? c #\\\
    o) #\\q]\n           [(char=? c #\\u) #\\w]\n           [else c]))\n       (string->list\
    \ message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (let ([c (char-upcase c)])\n         (cond\n           [(member c\
    \ '(#\\A #\\E #\\I #\\O #\\U))\n            (char-upcase (list-ref '(#\\C #\\\
    F #\\J #\\O #\\T)\n                                   (char-&gt;integer c #\\\
    A)))]\n           [else\n            (if (char-&gt;integer c)\n              \
    \  (char-upcase (integer-&gt;char (+ (char-&gt;integer c) 2)))\n             \
    \   c)]))]\n      [else c]))\n  (string-&gt;list (string-map encode-char message)))\n",
  "  (string-map (lambda (c)\n                (cond\n                  [(char-alphabetic?\
    \ c)\n                   (let ([c (char-upcase c)])\n                     (cond\n\
    \                       [(char=? c #\\A) #\\C]\n                       [(char=?\
    \ c #\\E) #\\G]\n                       [(char=? c #\\I) #\\K]\n             \
    \          [(char=? c #\\O) #\\Q]\n                       [(char=? c #\\U) #\\\
    W]\n                       [else (char-downcase (char+ c 2))]))]\n           \
    \       [else c]))\n              message))\n", "  (define (is-vowel? c)\n   \
    \ (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n    \
    \    (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (swap-case c)\n   \
    \ (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(is-vowel? c)\n       (swap-case\
    \ (list-ref (string->list \"defghijklmnopqrstuvwxyz\")\n                     \
    \       (+ (string-index \"abcdefghijklmnopqrstuvwxyz\" c) 2)))]\n      [else\
    \ (swap-case c)]))\n  (list->string (map encode-char (string->list message))))\n",
  "  (string-upcase message))\n", "  (string-append (map (lambda (c)\n           \
    \             (if (char-alphabetic? c)\n                            (if (char-lower-case?\
    \ c)\n                                (char-upcase c)\n                      \
    \          (char-downcase c))\n                            c))\n             \
    \         message)\n                 (map (lambda (c)\n                      \
    \  (if (char-alphabetic? c)\n                            (let ((vowels (string-&gt;list\
    \ \"aeiou\")))\n                              (if (member c vowels)\n        \
    \                          (list-ref vowels (+ (list-index c vowels) 2))\n   \
    \                               c))\n                            c))\n       \
    \               message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-char c)\n         (integer->char (+ (char->integer c) 1)))\n       (define\
    \ (next-next-char c)\n         (integer->char (+ (char->integer c) 2)))\n    \
    \   (if (is-vowel? c)\n           (next-next-char c)\n           (swap-case c))]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n\
    \         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (swap-case c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n\
    \      [(char-upper-case? c) (char-downcase c)]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (define (encode-string str)\n    (string-map encode-char\
    \ str))\n  (define (swap-case-string str)\n    (string-map swap-case str))\n \
    \ (swap-case-string (encode-string message)))\n", "  (define (swap-case c)\n \
    \   (if (char-alphabetic? c)\n        (if (char-upper-case? c)\n            (char-downcase\
    \ c)\n            (char-upcase c))\n        c))\n  (define (encode-char c)\n \
    \   (if (char-alphabetic? c)\n        (let ((vowels (string-&gt;list \"aeiou\"\
    ))\n              (alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\")))\n\
    \          (let ((vowel-index (list-index (char-downcase c) vowels)))\n      \
    \      (if vowel-index\n                (list-ref alphabet (+ vowel-index 2))\n\
    \                c)))\n        c))\n  (string-join\n   (map (lambda (c) (encode-char\
    \ (swap-case c)))\n        (string-&gt;list message))\n   \"\"))\n", "  (define\
    \ (encode-helper message)\n    (if (empty? message)\n        empty\n        (cons\
    \ (encode-char (first message))\n              (encode-helper (rest message)))))\n\
    \  (encode-helper message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case? c)\n\
    \             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n           \
    \  (char+ c 1)))\n       (define (next-next-char c)\n         (if (char=? c #\\\
    y)\n             #\\b\n             (char+ c 2)))\n       (cond\n         [(is-vowel?\
    \ c)\n          (next-next-char c)]\n         [else\n          (swap-case c)])]\n\
    \      [else\n       c]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n\
    \        (char-next (char-next c))\n        c))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (swap-case\
    \ (first message)))\n              (encode-message (rest message)))))\n  (encode-message\
    \ message))\n", "  (let ((vowels '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n    (string-join\n\
    \     (map\n      (lambda (c)\n        (cond\n          [(string-contains? vowels\
    \ (string-downcase c))\n           (string-ref\n            (string-append vowels\
    \ (string-append vowels vowels))\n            (+ (string-index (string-downcase\
    \ c) vowels) 2))]\n          [else (string-upcase c)]))\n      (string-split message\
    \ \"\"))\n     \"\")))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (let ([vowels (string-&gt;list \"aeiou\")])\n          (if (member\
    \ c vowels)\n              (let ([pos (position c vowels)])\n                (list-ref\
    \ vowels (+ pos 2)))\n              c))\n        c))\n  (string-&gt;list (map\
    \ swap-case message)))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (define (vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n\
    \    (define (next-vowel c)\n      (cond\n        [(vowel? c) (next-vowel (char+\
    \ c 1))]\n        [else c]))\n    (define (next-next-vowel c)\n      (cond\n \
    \       [(vowel? c) (next-next-vowel (char+ c 2))]\n        [else c]))\n    (cond\n\
    \      [(vowel? c) (next-next-vowel c)]\n      [else (swap-case c)]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char ch)\n    (cond\n      [(char-alphabetic?\
    \ ch)\n       (define (is-vowel? ch)\n         (member ch '(#\\a #\\e #\\i #\\\
    o #\\u)))\n       (define (next-vowel ch)\n         (cond\n           [(char=?\
    \ ch #\\u) #\\a]\n           [else (char+ ch 1)]))\n       (define (next-next-vowel\
    \ ch)\n         (cond\n           [(char=? ch #\\u) #\\a]\n           [(char=?\
    \ ch #\\a) #\\e]\n           [else (char+ ch 2)]))\n       (cond\n         [(is-vowel?\
    \ ch) (next-next-vowel ch)]\n         [else (next-vowel ch)])]\n      [else ch]))\n\
    \  (define (encode-string str)\n    (if (string-empty? str)\n        \"\"\n  \
    \      (string-append (string (encode-char (string-ref str 0)))\n            \
    \           (encode-string (substring str 1)))))\n  (encode-string message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-char c)\n         (cond\n           [(char=? c #\\z) #\\a]\n         \
    \  [(char=? c #\\Z) #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char\
    \ c)\n         (cond\n           [(char=? c #\\y) #\\a]\n           [(char=? c\
    \ #\\Y) #\\A]\n           [else (next-char (next-char c))]))\n       (define (is-vowel?\
    \ c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n\
    \       (cond\n         [(is-vowel? c) (next-next-char c)]\n         [(char-lower-case?\
    \ c) (char-upcase c)]\n         [(char-upper-case? c) (char-lower-case c)]\n \
    \        [else c])]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (map (lambda (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case?\
    \ c)\n                 (char-upcase c)\n                 (char-downcase c))\n\
    \             c))\n       message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (let ([vowels (string-&gt;list \"aeiou\")])\n          (if (member\
    \ c vowels)\n              (list-ref vowels (+ (list-index c vowels) 2))\n   \
    \           c))\n        c))\n  (string-&gt;list (string-map swap-case message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let*\
    \ ([a (char-upcase c)]\n              [b (char-downcase c)]\n              [i\
    \ (char-&gt;integer a)]\n              [j (char-&gt;integer b)])\n         (cond\n\
    \           [(or (= i 65) (= i 69) (= i 73) (= i 79) (= i 85))\n            (integer-&gt;char\
    \ (+ i 2))]\n           [(or (= j 97) (= j 101) (= j 105) (= j 111) (= j 117))\n\
    \            (integer-&gt;char (+ j 2))]\n           [else\n            c]))]\n\
    \      [else\n       c]))\n  (string-&gt;list (string-map encode-char message)))\n",
  "  (map (lambda (c)\n         (cond\n           [(char-alphabetic? c)\n        \
    \    (if (char-lower-case? c)\n                (char-upcase c)\n             \
    \   (char-downcase c))]\n           [(char=? c #\\a) #\\c]\n           [(char=?\
    \ c #\\e) #\\g]\n           [(char=? c #\\i) #\\k]\n           [(char=? c #\\\
    o) #\\q]\n           [(char=? c #\\u) #\\w]\n           [else c]))\n       (string->list\
    \ message)))\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic?\
    \ c)\n        (let* ([case (char-upcase? c)]\n               [c (char-downcase\
    \ c)]\n               [c (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        \
    \              (char-upcase (next-vowel c))\n                      c)])\n    \
    \      (if case c (char-downcase c)))]\n       [else c]))\n   message))\n", " \
    \ (string-upcase message))\n", "  (define (encode-char c)\n    (cond\n      ((char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c)))\n      ((char=? c #\\a) #\\c)\n      ((char=? c #\\e) #\\\
    g)\n      ((char=? c #\\i) #\\k)\n      ((char=? c #\\o) #\\q)\n      ((char=?\
    \ c #\\u) #\\w)\n      (else c)))\n  (string-map encode-char message))\n", " \
    \ (map (lambda (c)\n         (cond\n           [(char-alphabetic? c)\n       \
    \     (let* ([c (char-upcase c)]\n                   [c (if (char-vowel? c)\n\
    \                          (char-next (char-next c))\n                       \
    \   c)])\n              (if (char-lower-case? c)\n                  (char-downcase\
    \ c)\n                  c))]\n           [else c]))\n       message))\n", "  (map\
    \ (lambda (c)\n         (cond\n           [(char-alphabetic? c)\n            (let\
    \ ([c (char-upcase c)])\n              (cond\n                [(member c '(#\\\
    A #\\E #\\I #\\O #\\U))\n                 (char-upcase (list-ref (list #\\C #\\\
    D #\\F #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\\
    X #\\Y #\\Z)\n                                        (sub1 (char-&gt;integer\
    \ c))))]\n                [else (char-downcase c)]))]\n           [else c]))\n\
    \       (string-&gt;list message)))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n   \
    \       ((char=? c #\\i) #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=?\
    \ c #\\u) #\\w)\n          ((char=? c #\\A) #\\C)\n          ((char=? c #\\E)\
    \ #\\G)\n          ((char=? c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n\
    \          ((char=? c #\\U) #\\W)\n          (else c)))\n  (define (encode-string\
    \ s)\n    (if (string-empty? s)\n        \"\"\n        (string-append (encode-char\
    \ (string-ref s 0))\n                       (encode-string (substring s 1)))))\n\
    \  (encode-string (string-map swap-case message)))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (vowel? c)\n    \
    \     (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (next-char c)\n         (char-upcase (if (vowel? c)\n            \
    \              (char-downcase (char+ c 2))\n                          (char+ c\
    \ 1))))\n       (if (char-upper-case? c)\n           (char-downcase (next-char\
    \ c))\n           (next-char c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n       (define (next-char c)\n         (integer->char (+ (char->integer\
    \ c) 1)))\n       (define (next-next-char c)\n         (integer->char (+ (char->integer\
    \ c) 2)))\n       (define (next-next-char-vowel c)\n         (next-next-char (next-char\
    \ c)))\n       (define (next-next-char-consonant c)\n         (next-next-char\
    \ c))\n       (cond\n         [(is-vowel? c)\n          (cond\n            [(is-vowel?\
    \ (next-char c))\n             (next-next-char-vowel c)]\n            [else\n\
    \             (next-next-char-consonant c)])]\n         [else\n          (next-next-char\
    \ c)])]\n      [else\n       c]))\n  (string-map encode-char message))\n", " \
    \ (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n    \
    \    (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))]\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n       [(char=?\
    \ c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n       [(char=? c #\\u) #\\w]\n\
    \       [else c]))\n   message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (char-next (char-next c))\n        c))\n  (string-map swap-case\
    \ (string-map encode-char message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (let ((vowels '(#\\a #\\e #\\i #\\o #\\u)))\n          (if (member\
    \ c vowels)\n              (list-ref vowels (+ 2 (list-index c vowels)))\n   \
    \           c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n    \
    \    (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (swap-vowel c)\n    (if (member c '(#\\a #\\e #\\\
    i #\\o #\\u))\n        (list-ref '(#\\c #\\d #\\f #\\g #\\h) (- (char-downcase\
    \ c) #\\a))\n        c))\n  (define (encode-char c)\n    (swap-vowel (swap-case\
    \ c)))\n  (string-join (map encode-char (string->list message))))\n", "  (string-upcase\
    \ message))\n</code>\nI am trying to write a function that takes a message and\
    \ encodes it in such a way that it swaps the case of all letters, replaces all\
    \ vowels in the message with the letter that appears 2 places ahead of that vowel\
    \ in the english alphabet. I am assuming that the message only contains letters.\n\
    I have written the function that swaps the case of all letters, but I am not sure\
    \ how to write the function that replaces all vowels in the message with the letter\
    \ that appears 2 places ahead of that vowel in the english alphabet.\nI have tried\
    \ using the string-replace function, but I am not sure how to use it in this case.\n\
    Any help would be appreciated.\n\n\nA:\n\nYou can use <code>string-replace</code>\
    \ to replace each vowel with the next vowel. \n<code>(define (encode message)\n\
    \  (string-upcase\n   (string-replace message\n                   \"a\" \"c\"\
    )\n   (string-replace message\n                   \"e\" \"g\")\n   (string-replace\
    \ message\n                   \"i\" \"k\")\n   (string-replace message\n     \
    \              \"o\" \"q\")\n   (string-replace message\n                   \"\
    u\" \"w\")))\n</code>\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (let* ([alphabet (string-&gt;list\
    \ \"abcdefghijklmnopqrstuvwxyz\")]\n              [index (string-index (string-downcase\
    \ c) alphabet)]\n              [new-index (+ index 2)])\n         (if (&gt;= new-index\
    \ (length alphabet))\n             (list-ref alphabet (- new-index (length alphabet)))\n\
    \             (list-ref alphabet new-index)))]\n      [else c]))\n  (string-join\
    \ (map encode-char (string-&gt;list message))))\n</code>\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (define (next-vowel c)\n      (cond\n \
    \       [(char=? c #\\a) #\\c]\n        [(char=? c #\\e) #\\g]\n        [(char=?\
    \ c #\\i) #\\k]\n        [(char=? c #\\o) #\\q]\n        [(char=? c #\\u) #\\\
    w]\n        [else c]))\n    (if (char-vowel? c)\n        (next-vowel c)\n    \
    \    (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\\
    u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t)\n                  (position\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (string-map (lambda (c)\n                (if (char-alphabetic?\
    \ c)\n                    (let ((vowels (string-&gt;list \"aeiou\")))\n      \
    \                (if (member c vowels)\n                          (let ((index\
    \ (list-index vowels c)))\n                            (list-ref vowels (modulo\
    \ (+ index 2) (length vowels))))\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-lower-case c))))\n                    c))\n              message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(= c #\\u) #\\a]\n           [else\
    \ (char-upcase (char+ c 1))]))\n       (define (next-consonant c)\n         (cond\n\
    \           [(= c #\\z) #\\a]\n           [else (char-upcase (char+ c 1))]))\n\
    \       (define (next-char c)\n         (if (is-vowel? c)\n             (next-vowel\
    \ c)\n             (next-consonant c)))\n       (define (next-next-char c)\n \
    \        (next-char (next-char c)))\n       (define (swap-case c)\n         (if\
    \ (char-lower-case? c)\n             (char-upcase c)\n             (char-downcase\
    \ c)))\n       (cond\n         [(is-vowel? c) (next-next-char c)]\n         [else\
    \ (swap-case c)]\n         )]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case? c)\n\
    \             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n           \
    \  (char+ c 1)))\n       (define (next-next-char c)\n         (if (char=? c #\\\
    y)\n             #\\b\n             (next-char (next-char c))))\n       (if (is-vowel?\
    \ c)\n           (next-next-char c)\n           (swap-case c))]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (define (is-vowel? c)\n         (or (char=?\
    \ c #\\a)\n             (char=? c #\\e)\n             (char=? c #\\i)\n      \
    \       (char=? c #\\o)\n             (char=? c #\\u)))\n       (define (swap-case\
    \ c)\n         (if (char-upper-case? c)\n             (char-downcase c)\n    \
    \         (char-upcase c)))\n       (define (next-vowel c)\n         (cond\n \
    \          [(char=? c #\\a) #\\e]\n           [(char=? c #\\e) #\\i]\n       \
    \    [(char=? c #\\i) #\\o]\n           [(char=? c #\\o) #\\u]\n           [(char=?\
    \ c #\\u) #\\a]))\n       (if (is-vowel? c)\n           (next-vowel c)\n     \
    \      (swap-case c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (let ((vowels\
    \ (string->list \"aeiou\"))\n              (alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n          (if (member c vowels)\n              (list-ref alphabet (+ 2 (list-index\
    \ c vowels)))\n              c))\n        c))\n  (string-join (map encode-char\
    \ (map swap-case (string->list message))) \"\"))\n", "  (define (swap-case c)\n\
    \    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))\n        c))\n  (define (encode-char c)\n\
    \    (if (char-alphabetic? c)\n        (let ([c (char-downcase c)])\n        \
    \  (cond\n            [(char=? c #\\a) #\\c]\n            [(char=? c #\\e) #\\\
    g]\n            [(char=? c #\\i) #\\k]\n            [(char=? c #\\o) #\\q]\n \
    \           [(char=? c #\\u) #\\w]\n            [else c]))\n        c))\n  (string-map\
    \ encode-char (string-map swap-case message)))\n", "  (define (encode-char c)\n\
    \    (define (is-vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  \
    \  (define (next-vowel c)\n      (cond ((equal? c #\\u) #\\a)\n            (else\
    \ (char-upcase (char+ c 1)))))\n    (cond ((is-vowel? c) (next-vowel c))\n   \
    \       ((char-lower-case? c) (char-upcase c))\n          ((char-upper-case? c)\
    \ (char-lower-case c))\n          (else c)))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond [(char-alphabetic? c)\n           (define\
    \ (is-vowel? c)\n             (or (char=? c #\\a)\n                 (char=? c\
    \ #\\e)\n                 (char=? c #\\i)\n                 (char=? c #\\o)\n\
    \                 (char=? c #\\u)))\n           (define (swap-case c)\n      \
    \       (if (char-upper-case? c)\n                 (char-downcase c)\n       \
    \          (char-upcase c)))\n           (define (encode-vowel c)\n          \
    \   (define (next-vowel c)\n               (cond [(char=? c #\\a) #\\e]\n    \
    \                 [(char=? c #\\e) #\\i]\n                     [(char=? c #\\\
    i) #\\o]\n                     [(char=? c #\\o) #\\u]\n                     [(char=?\
    \ c #\\u) #\\a]))\n             (next-vowel (next-vowel c)))\n           (if (is-vowel?\
    \ c)\n               (encode-vowel c)\n               (swap-case c))]\n      \
    \    [else c]))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (let ((vowels '#(#\\a #\\e #\\i #\\o #\\\
    u)))\n      (if (member c vowels)\n          (list-ref vowels (+ (position c vowels)\
    \ 2))\n          c)))\n  (string-map (lambda (c) (encode-char (swap-case c)))\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (cond\n         [(char-lower-case? c) (char-upcase c)]\n        \
    \ [(char-upper-case? c) (char-downcase c)])]\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (let ([vowels\
    \ (string-&gt;list \"aeiou\")])\n          (if (member c vowels)\n           \
    \   (let ([index (list-index vowels c)])\n                (list-ref vowels (modulo\
    \ (+ index 2) (length vowels))))\n              c))\n        c))\n  (string-&gt;list\
    \ (map swap-case (map encode-char (string-&gt;list message)))))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel?\
    \ c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n           \
    \  (char=? c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n\
    \       (define (swap-case c)\n         (if (char-upper-case? c)\n           \
    \  (char-downcase c)\n             (char-upcase c)))\n       (define (next-char\
    \ c)\n         (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\b\n             (next-char (next-char c))))\n       (if (is-vowel? c)\n\
    \           (next-next-char c)\n           (swap-case c))]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (char-upcase (char-next (char-next c)))\n        c))\n  (string-map\
    \ encode-char (string-map swap-case message)))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (swap-vowel c)\n    (if (char-vowel?\
    \ c)\n        (char-next (char-next c))\n        c))\n  (define (encode-char c)\n\
    \    (swap-vowel (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (swap-vowel c)\n    (if (char-alphabetic? c)\n        (if (char-vowel? c)\n\
    \            (char-upcase (char-next (char-next c)))\n            c)\n       \
    \ c))\n  (string-map swap-vowel (string-map swap-case message)))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-upper-case? c)\n           (char-downcase\
    \ c)\n           (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (string-map (lambda (c)\n                (cond\n                  [(char-alphabetic?\
    \ c)\n                   (let* ([c (char-upcase c)]\n                        \
    \  [c (if (char-numeric? (string-ref \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (modulo (+\
    \ (char-&gt;integer c) 2) 26)))\n                                 (string-ref\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (modulo (+ (char-&gt;integer c) 2) 26))\n   \
    \                              (string-ref \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (modulo\
    \ (+ (char-&gt;integer c) 2) 26)))]\n                          [c (char-downcase\
    \ c)])\n                     c)]\n                  [else c]))\n             \
    \ message))\n", "  (string-upcase message))\n", "  (string-upcase (string-map\
    \ (lambda (c)\n                               (if (vowel? c)\n               \
    \                    (next-next-letter c)\n                                  \
    \ c))\n                             message)))\n", "  (map (lambda (c)\n     \
    \    (cond\n           [(char-alphabetic? c)\n            (let ([c (char-upcase\
    \ c)])\n              (cond\n                [(char=? c #\\A) #\\C]\n        \
    \        [(char=? c #\\E) #\\G]\n                [(char=? c #\\I) #\\K]\n    \
    \            [(char=? c #\\O) #\\Q]\n                [(char=? c #\\U) #\\W]\n\
    \                [(char=? c #\\Y) #\\A]\n                [else (char-downcase\
    \ c)]))]\n           [else c]))\n       message))\n", "  (define (swap-case c)\n\
    \    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))\n        c))\n  (define (encode-char c)\n\
    \    (if (char-alphabetic? c)\n        (let ([vowels (string-&gt;list \"aeiou\"\
    )])\n          (if (member c vowels)\n              (list-ref vowels (+ (list-index\
    \ c vowels) 2))\n              c))\n        c))\n  (string-&gt;list\n   (map (lambda\
    \ (c) (encode-char (swap-case c)))\n        (string-&gt;list message))))\n</code>\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (swap-vowel c)\n    (if (char-alphabetic? c)\n        (if (member c\
    \ '(#\\a #\\e #\\i #\\o #\\u))\n            (char-upcase (char-upcase c))\n  \
    \          c)\n        c))\n  (define (swap-vowel-2 c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (char-upcase\
    \ (char-upcase (char-upcase c)))\n            c)\n        c))\n  (define (swap-vowel-3\
    \ c)\n    (if (char-alphabetic? c)\n        (if (member c '(#\\a #\\e #\\i #\\\
    o #\\u))\n            (char-upcase (char-upcase (char-upcase (char-upcase c))))\n\
    \            c)\n        c))\n  (define (swap-vowel-4 c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (char-upcase\
    \ (char-upcase (char-upcase (char-upcase (char-upcase c)))))\n            c)\n\
    \        c))\n  (define (swap-vowel-5 c)\n    (if (char-alphabetic? c)\n     \
    \   (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (char-upcase (char-upcase\
    \ (char-upcase (char-upcase (char-upcase (char-upcase c))))))\n            c)\n\
    \        c))\n  (define (swap-vowel-6 c)\n    (if (char-alphabetic? c)\n     \
    \   (if (member c '(#\\a #", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (char-upcase (char-next (char-next c)))\n        c))\n  (string-map\
    \ encode-char (string-map swap-case message)))\n", "  (define (swap-case c)\n\
    \    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))\n        c))\n  (define (encode-char c)\n\
    \    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n  \
    \      c))\n  (string-map swap-case (string-map encode-char message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-upper-case? c)\n           (char-downcase c)\n           (char-upcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n    \
    \    (if (char-upper-case? c)\n            (char-downcase c)\n            (char-upcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic? c)\n\
    \        (let ((vowels (string->list \"aeiouAEIOU\")))\n          (if (member\
    \ c vowels)\n              (let ((index (list-index c vowels)))\n            \
    \    (list-ref vowels (+ index 2)))\n              c))\n        c))\n  (list->string\
    \ (map encode-char (map swap-case (string->list message)))))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (swap-vowel c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref\
    \ '(#\\c #\\d #\\f #\\g #\\h) (- (char-ci&gt;integer c) 97))\n        c))\n  (string-map\
    \ swap-vowel (string-map swap-case message)))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n      \
    \   (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=? c\
    \ #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n      \
    \ (define (swap-case c)\n         (if (char-upper-case? c)\n             (char-downcase\
    \ c)\n             (char-upcase c)))\n       (define (encode-vowel c)\n      \
    \   (define (next-vowel c)\n           (cond\n             [(char=? c #\\a) #\\\
    e]\n             [(char=? c #\\e) #\\i]\n             [(char=? c #\\i) #\\o]\n\
    \             [(char=? c #\\o) #\\u]\n             [(char=? c #\\u) #\\a]))\n\
    \         (next-vowel (next-vowel c)))\n       (if (is-vowel? c)\n           (encode-vowel\
    \ c)\n           (swap-case c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\b\n             (next-char (next-char\
    \ c))))\n       (define (swap-case c)\n         (if (char-upper-case? c)\n   \
    \          (char-downcase c)\n             (char-upcase c)))\n       (cond\n \
    \        [(or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o)\
    \ (char=? c #\\u))\n          (next-next-char c)]\n         [else\n          (swap-case\
    \ c)])]\n      [else\n       c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (define (is-vowel? c)\n      (or (char=? c #\\\
    a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u)))\n    (define\
    \ (next-vowel c)\n      (cond ((char=? c #\\a) #\\c)\n            ((char=? c #\\\
    e) #\\g)\n            ((char=? c #\\i) #\\k)\n            ((char=? c #\\o) #\\\
    q)\n            ((char=? c #\\u) #\\w)))\n    (cond ((is-vowel? c) (next-vowel\
    \ c))\n          ((char-alphabetic? c) (char-upcase c))\n          (else c)))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (or (char=? c #\\a)\n          (char=? c #\\e)\n          (char=?\
    \ c #\\i)\n          (char=? c #\\o)\n          (char=? c #\\u)))\n    (define\
    \ (next-vowel c)\n      (cond ((char=? c #\\a) #\\e)\n            ((char=? c #\\\
    e) #\\i)\n            ((char=? c #\\i) #\\o)\n            ((char=? c #\\o) #\\\
    u)\n            ((char=? c #\\u) #\\a)))\n    (if (is-vowel? c)\n        (next-vowel\
    \ c)\n        c))\n  (string-map swap-case (string-map encode-char message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (if (is-vowel? c)\n           (define (next-vowel c)\n   \
    \          (cond\n               [(char=? c #\\a) #\\c]\n               [(char=?\
    \ c #\\e) #\\g]\n               [(char=? c #\\i) #\\k]\n               [(char=?\
    \ c #\\o) #\\q]\n               [(char=? c #\\u) #\\w]))\n           (next-vowel\
    \ c))]\n      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\b\n             (next-char (next-char c))))\n       (define (vowel? c)\n\
    \         (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (if (vowel? c)\n           (next-next-char c)\n           (next-char c))]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (define\
    \ (is-vowel? c)\n      (or (char=? c #\\a)\n          (char=? c #\\e)\n      \
    \    (char=? c #\\i)\n          (char=? c #\\o)\n          (char=? c #\\u)))\n\
    \    (define (swap-case c)\n      (if (char-upper-case? c)\n          (char-downcase\
    \ c)\n          (char-upcase c)))\n    (define (encode-vowel c)\n      (define\
    \ (next-vowel c)\n        (cond ((char=? c #\\a) #\\e)\n              ((char=?\
    \ c #\\e) #\\i)\n              ((char=? c #\\i) #\\o)\n              ((char=?\
    \ c #\\o) #\\u)\n              ((char=? c #\\u) #\\a)))\n      (next-vowel c))\n\
    \    (if (is-vowel? c)\n        (encode-vowel c)\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (string-upcase message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\b\n             (next-char (next-char c))))\n       (cond\n         [(char-lower-case?\
    \ c)\n          (char-upcase (next-next-char c))]\n         [(char-upper-case?\
    \ c)\n          (char-downcase (next-next-char c))])]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (string-map (lambda\
    \ (c)\n                (cond\n                  [(char-alphabetic? c)\n      \
    \             (if (char-lower-case? c)\n                       (char-upcase c)\n\
    \                       (char-downcase c))]\n                  [(char=? c #\\\
    a) #\\c]\n                  [(char=? c #\\e) #\\g]\n                  [(char=?\
    \ c #\\i) #\\k]\n                  [(char=? c #\\o) #\\q]\n                  [(char=?\
    \ c #\\u) #\\w]\n                  [else c]))\n              message))\n", " \
    \ (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)]\n        [alphabet (list->string\
    \ (range #\\a #\\z))])\n    (string-map\n     (lambda (c)\n       (if (member\
    \ c vowels)\n           (string-ref alphabet (+ (string-index alphabet c) 2))\n\
    \           (if (char-alphabetic? c)\n               (if (char-lower-case? c)\n\
    \                   (char-upcase c)\n                   (char-lower-case c))\n\
    \               c)))\n     message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (define (next-vowel c)\n          (if (char-vowel? c)\n        \
    \      (next-vowel (char-next c))\n              c))\n        (next-vowel (char-next\
    \ c))))\n  (string-map swap-case (string-map encode-char message)))\n", "  (string-upcase\
    \ (string-append (string-map (lambda (c) (if (char-alphabetic? c) (if (char-vowel?\
    \ c) (char-upcase (char-next (char-next (char-downcase c)))) (char-upcase c))\
    \ c)) message))))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (next-vowel c)\n         (cond\n\
    \           [(char=? c #\\a) #\\e]\n           [(char=? c #\\e) #\\i]\n      \
    \     [(char=? c #\\i) #\\o]\n           [(char=? c #\\o) #\\u]\n           [(char=?\
    \ c #\\u) #\\a]))\n       (if (is-vowel? c)\n           (next-vowel c)\n     \
    \      (char-upcase c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-upper-case?\
    \ c)\n           (char-downcase c)\n           (char-upcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (map (lambda (c)\n         (if (char-alphabetic?\
    \ c)\n             (if (char-lower-case? c)\n                 (char-upcase c)\n\
    \                 (char-downcase c))\n             c))\n       message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (let ((vowels\
    \ (string-&gt;list \"aeiou\"))\n              (alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n          (if (member c vowels)\n              (list-ref alphabet (+ (list-index\
    \ c vowels 2) 2))\n              c))\n        c))\n  (string-join (map encode-char\
    \ (map swap-case (string-&gt;list message))) \"\"))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (string-join\n\
    \   (map\n    (lambda (c)\n      (cond\n        [(char-alphabetic? c)\n      \
    \   (if (char-lower-case? c)\n             (char-upcase c)\n             (char-downcase\
    \ c))]\n        [(char-vowel? c)\n         (char-next (char-next c))]\n      \
    \  [else c]))\n    (string->list message))\n   \"\"))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-vowel? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase (char-next (char-next c)))\n            (char-downcase\
    \ (char-next (char-next c))))\n        c))\n  (define (char-vowel? c)\n    (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (next-vowel c)\n         (define (next-char c)\n           (integer->char (+\
    \ (char->integer c) 1)))\n         (cond\n           [(is-vowel? c)\n        \
    \    (next-char c)]\n           [else\n            (next-vowel (next-char c))]))\n\
    \       (define (next-char c)\n         (integer->char (+ (char->integer c) 1)))\n\
    \       (define (next-char-2 c)\n         (next-char (next-char c)))\n       (define\
    \ (swap-case c)\n         (cond\n           [(char-lower-case? c)\n          \
    \  (char-upcase c)]\n           [else\n            (char-downcase c)]))\n    \
    \   (cond\n         [(is-vowel? c)\n          (next-char-2 c)]\n         [else\n\
    \          (swap-case c)])]\n      [else\n       c]))\n  (string-map encode-char\
    \ message))\n", "  (string-upcase message))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (if (member c '#(#\\a #\\e #\\i #\\o #\\u))\n\
    \        (list-ref '#(#\\c #\\g #\\k #\\o #\\s)\n                  (position c\
    \ '#(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (map (lambda (c)\n         (if (char-alphabetic?\
    \ c)\n             (if (char-lower-case? c)\n                 (char-upcase c)\n\
    \                 (char-downcase c))\n             c))\n       message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (define (next-vowel c)\n         (cond\n           [(char=?\
    \ c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n           [(char=? c #\\\
    i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=? c #\\u) #\\w]))\n\
    \       (if (is-vowel? c)\n           (next-vowel c)\n           (char-upcase\
    \ c))]\n      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n \
    \        (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (swap-case c)\n         (if (char-upper-case? c)\n             (char-downcase\
    \ c)\n             (char-upcase c)))\n       (define (next-vowel c)\n        \
    \ (cond\n           [(char=? c #\\a) #\\e]\n           [(char=? c #\\e) #\\i]\n\
    \           [(char=? c #\\i) #\\o]\n           [(char=? c #\\o) #\\u]\n      \
    \     [(char=? c #\\u) #\\a]))\n       (if (is-vowel? c)\n           (next-vowel\
    \ c)\n           (swap-case c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\a\n             (next-char (next-char\
    \ c))))\n       (if (is-vowel? c)\n           (next-next-char c)\n           (next-char\
    \ c))]\n      [else c]))\n  (define (encode-string s)\n    (string-map encode-char\
    \ s))\n  (define (encode-word w)\n    (if (string-ci=? w \"the\")\n        \"\
    tHe\"\n        (encode-string w)))\n  (define (encode-words words)\n    (map encode-word\
    \ words))\n  (define (encode-message message)\n    (string-join (encode-words\
    \ (string-split message)) \" \"))\n  (encode-message message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let* ([vowels (string-&gt;list\
    \ \"aeiou\")]\n               [vowel-index (list-index (lambda (x) (char=? x c))\
    \ vowels)]\n               [new-vowel-index (+ 2 vowel-index)])\n          (if\
    \ (and vowel-index (&lt; new-vowel-index (length vowels)))\n              (list-ref\
    \ vowels new-vowel-index)\n              c))\n        c))\n  (define (encode-string\
    \ s)\n    (string-&gt;list (string-map encode-char s)))\n  (string-&gt;list (string-map\
    \ swap-case message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n           \
    \  (char+ c 1)))\n       (define (next-next-char c)\n         (if (char=? c #\\\
    y)\n             #\\b\n             (next-char (next-char c))))\n       (cond\n\
    \         [(is-vowel? c)\n          (next-next-char c)]\n         [else\n    \
    \      (swap-case c)])]\n      [else\n       c]))\n  (string-map encode-char message))\n",
  "  (string-upcase message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (map (lambda (c)\n         (cond\n           [(char-alphabetic? c)\n       \
    \     (if (char-lower-case? c)\n                (char-upcase c)\n            \
    \    (char-downcase c))]\n           [(char=? c #\\a) #\\c]\n           [(char=?\
    \ c #\\e) #\\g]\n           [(char=? c #\\i) #\\k]\n           [(char=? c #\\\
    o) #\\q]\n           [(char=? c #\\u) #\\w]\n           [else c]))\n       (string->list\
    \ message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n       (define (next-letter c)\n         (if (char=? c #\\z)\n         \
    \    #\\a\n             (char+ c 1)))\n       (define (next-vowel c)\n       \
    \  (let loop ([c (next-letter c)])\n           (if (is-vowel? c)\n           \
    \    c\n               (loop (next-letter c)))))\n       (if (is-vowel? c)\n \
    \          (next-vowel (next-letter c))\n           (next-letter c))]\n      [else\
    \ c]))\n  (define (encode-string s)\n    (string-map encode-char s))\n  (define\
    \ (encode-list l)\n    (map encode-string l))\n  (cond\n    [(string? message)\
    \ (encode-string message)]\n    [(list? message) (encode-list message)]\n    [else\
    \ message]))\n", "  (define (encode-char c)\n    (define (vowel? c)\n      (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n    (define (encode-vowel c)\n      (define\
    \ (next-vowel c)\n        (cond\n          [(equal? c #\\u) #\\a]\n          [else\
    \ (char-upcase (char+ c 1))]))\n      (next-vowel (next-vowel c)))\n    (cond\n\
    \      [(vowel? c) (encode-vowel c)]\n      [else (char-upcase c)]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-letter c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (list-ref\
    \ '(#\\c #\\f #\\j #\\o #\\r)\n                      (position c '(#\\a #\\e #\\\
    i #\\o #\\u)))\n            (swap-case c))\n        c))\n  (string-&gt;list (string-map\
    \ encode-letter (string-map swap-case message))))\n", "  (map (lambda (c)\n  \
    \       (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (string-map (lambda (c)\n                (if (char-alphabetic? c)\n        \
    \            (let* ([c (char-upcase c)]\n                           [c (if (char-in-range?\
    \ c #\\A #\\Z)\n                                  (char-upcase c)\n          \
    \                        c)])\n                      (if (char-in-range? c #\\\
    A #\\Z)\n                          (if (char-in-range? c #\\A #\\M)\n        \
    \                      (char-upcase (+ c 2))\n                              (char-upcase\
    \ (- c 24)))\n                          c))\n                    c))\n       \
    \       message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n\
    \        (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel? c)\n     \
    \   (char-upcase (char-next (char-next c)))\n        c))\n  (string-map encode-char\
    \ (string-map swap-case message)))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\\
    o) (char=? c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n\
    \  (define (encode-message message)\n    (if (empty? message)\n        empty\n\
    \        (cons (encode-char (first message)) (encode-message (rest message)))))\n\
    \  (list->string (encode-message (string->list message))))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let ([vowels (string-&gt;list\
    \ \"aeiou\")])\n          (if (member c vowels)\n              (list-ref vowels\
    \ (+ (position c vowels) 2))\n              c))\n        c))\n  (string-&gt;list\
    \ (map swap-case message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (encode-vowel c)\n         (define (next-vowel c)\n           (cond\n      \
    \       [(char=? c #\\a) #\\e]\n             [(char=? c #\\e) #\\i]\n        \
    \     [(char=? c #\\i) #\\o]\n             [(char=? c #\\o) #\\u]\n          \
    \   [(char=? c #\\u) #\\a]))\n         (next-vowel (next-vowel c)))\n       (if\
    \ (is-vowel? c)\n           (encode-vowel c)\n           (swap-case c))]\n   \
    \   [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (swap-case c)\n \
    \        (if (char-lower-case? c)\n             (char-upcase c)\n            \
    \ (char-downcase c)))\n       (define (next-vowel c)\n         (cond\n       \
    \    [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n           [(char=?\
    \ c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=? c #\\\
    u) #\\w]\n           [else c]))\n       (next-vowel (swap-case c))]\n      [else\
    \ c]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n        \
    \ (cond\n           [(char-alphabetic? c)\n            (let ([c (char-upcase c)])\n\
    \              (cond\n                [(char=? c #\\A) #\\C]\n               \
    \ [(char=? c #\\E) #\\G]\n                [(char=? c #\\I) #\\K]\n           \
    \     [(char=? c #\\O) #\\Q]\n                [(char=? c #\\U) #\\W]\n       \
    \         [(char=? c #\\Y) #\\A]\n                [else (char-downcase (char+\
    \ c 2))]))]\n           [else c]))\n       message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (let ([offset (if (char-lower-case? c)\n                       \
    \   #\\a\n                          #\\A)])\n          (char (+ offset (modulo\
    \ (+ (char->integer c) 2) 26))))\n        c))\n  (string-map encode-char (string-map\
    \ swap-case message)))\n", "  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (or (equal? c #\\a)\n          (equal? c #\\e)\n          (equal?\
    \ c #\\i)\n          (equal? c #\\o)\n          (equal? c #\\u)))\n    (define\
    \ (encode-vowel c)\n      (define (next-vowel c)\n        (cond ((equal? c #\\\
    a) #\\e)\n              ((equal? c #\\e) #\\i)\n              ((equal? c #\\i)\
    \ #\\o)\n              ((equal? c #\\o) #\\u)\n              ((equal? c #\\u)\
    \ #\\a)))\n      (next-vowel (next-vowel c)))\n    (cond ((is-vowel? c) (encode-vowel\
    \ c))\n          ((char-lower-case? c) (char-upcase c))\n          ((char-upper-case?\
    \ c) (char-lower-case c))\n          (else c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-vowel c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n\
    \        (list-ref '(#\\c #\\d #\\f #\\g #\\h) (- (char-downcase c) #\\a))\n \
    \       c))\n  (string-map encode-vowel (string-map swap-case message)))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (let ((vowels\
    \ (string-&gt;list \"aeiou\"))\n              (alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n          (if (member c vowels)\n              (list-ref alphabet (+ (list-index\
    \ c vowels 2) 2))\n              c))\n        c))\n  (string-join (map encode-char\
    \ (map swap-case (string-&gt;list message))) \"\"))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c #\\Z)\
    \ #\\A]\n           [else (char-upcase (char+ c 1))]))\n       (define (next-next-char\
    \ c)\n         (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c\
    \ #\\Z) #\\A]\n           [else (char-upcase (char+ c 2))]))\n       (define (vowel?\
    \ c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n           \
    \  (char=? c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n\
    \       (cond\n         [(vowel? c) (next-next-char c)]\n         [(char-lower-case?\
    \ c) (next-char c)]\n         [(char-upper-case? c) (char-downcase (next-char\
    \ c))]\n         [else c])]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (swap-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map (lambda (c)\n                (swap-vowel (swap-case c)))\n    \
    \          message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-map (lambda (c)\n                (cond\n                  [(char-alphabetic?\
    \ c)\n                   (let ([c (char-upcase c)])\n                     (cond\n\
    \                       [(member c '#(#\\A #\\E #\\I #\\O #\\U))\n           \
    \             (char-upcase (vector-ref '#(#\\C #\\F #\\K #\\P #\\T)\n        \
    \                                         (position c '#(#\\A #\\E #\\I #\\O #\\\
    U))))]\n                       [else\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase (char-next (char-next c)))\n  \
    \                          (char-downcase (char-next (char-next c))))]))]\n  \
    \                [else c]))\n              message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c #\\Z)\
    \ #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char c)\n\
    \         (cond\n           [(char=? c #\\y) #\\a]\n           [(char=? c #\\\
    Y) #\\A]\n           [else (next-char (next-char c))]))\n       (define (vowel?\
    \ c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n           \
    \  (char=? c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)\n\
    \             (char=? c #\\A)\n             (char=? c #\\E)\n             (char=?\
    \ c #\\I)\n             (char=? c #\\O)\n             (char=? c #\\U)))\n    \
    \   (cond\n         [(vowel? c) (next-next-char c)]\n         [else (next-char\
    \ c)])]\n      [else c]))\n  (define (encode-string s)\n    (cond\n      [(empty?\
    \ s) empty]\n      [else (cons (encode-char (first s))\n                  (encode-string\
    \ (rest s)))]))\n  (encode-string message))\n", "  (string-map\n   (lambda (c)\n\
    \     (cond\n       [(char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))]\n       [(char=?\
    \ c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n       [(char=? c #\\i) #\\k]\n\
    \       [(char=? c #\\o) #\\q]\n       [(char=? c #\\u) #\\w]\n       [else c]))\n\
    \   message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(char=? c #\\a) #\\e]\n        \
    \   [(char=? c #\\e) #\\i]\n           [(char=? c #\\i) #\\o]\n           [(char=?\
    \ c #\\o) #\\u]\n           [(char=? c #\\u) #\\a]))\n       (if (is-vowel? c)\n\
    \           (next-vowel c)\n           (swap-case c))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next\
    \ c))\n        c))\n  (define (encode-message message)\n    (if (null? message)\n\
    \        '()\n        (cons (encode-char (swap-case (car message)))\n        \
    \      (encode-message (cdr message)))))\n  (list->string (encode-message (string->list\
    \ message))))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (let* ([c (char-upcase c)]\n              [c (if (char-lower-case?\
    \ c)\n                     (char-upcase c)\n                     (char-downcase\
    \ c))]\n              [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n        \
    \             (if (char-lower-case? c)\n                         (char-upcase\
    \ (next-vowel c))\n                         (char-downcase (next-vowel c)))\n\
    \                     c)])\n         c)]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(char=? c #\\a) #\\e]\n        \
    \   [(char=? c #\\e) #\\i]\n           [(char=? c #\\i) #\\o]\n           [(char=?\
    \ c #\\o) #\\u]\n           [(char=? c #\\u) #\\a]))\n       (if (is-vowel? c)\n\
    \           (next-vowel c)\n           (swap-case c))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond [(char-alphabetic?\
    \ c)\n           (if (char-lower-case? c)\n               (char-upcase c)\n  \
    \             (char-downcase c))]\n          [(char-vowel? c)\n           (char-upcase\
    \ (char-next (char-next c)))]\n          [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n  \
    \      (swap-case c)))\n  (string-map encode-char message))\n", "  (map (lambda\
    \ (c)\n         (cond\n           [(char-alphabetic? c)\n            (let ([c\
    \ (char-upcase c)])\n              (cond\n                [(member c '(#\\A #\\\
    E #\\I #\\O #\\U))\n                 (let ([vowels '(#\\A #\\E #\\I #\\O #\\U)])\n\
    \                   (list-ref vowels (modulo (+ (list-index c vowels) 2) 5)))]\n\
    \                [else c]))]\n           [else c]))\n       message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\\
    a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case\
    \ (char-upcase c))\n        (swap-case c)))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (first message))\n\
    \              (encode-message (rest message)))))\n  (encode-message message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let*\
    \ ([c-up (char-upcase c)]\n              [c-up-code (char-&gt;integer c-up)]\n\
    \              [c-up-code-plus-2 (+ c-up-code 2)]\n              [c-up-code-plus-2-mod\
    \ (+ c-up-code-plus-2 (modulo c-up-code-plus-2 26))]\n              [c-up-code-plus-2-mod-char\
    \ (integer-&gt;char c-up-code-plus-2-mod)])\n         (cond\n           [(char-vowel?\
    \ c-up-code-plus-2-mod-char)\n            (char-downcase c-up-code-plus-2-mod-char)]\n\
    \           [else\n            (char-downcase c-up-code-plus-2-mod-char)]))]\n\
    \      [else\n       c]))\n  (string-&gt;list message))\n</code>\n", "  (string-map\
    \ (lambda (c)\n                (cond\n                  [(char-alphabetic? c)\n\
    \                   (if (char-lower-case? c)\n                       (char-upcase\
    \ c)\n                       (char-downcase c))]\n                  [(char=? c\
    \ #\\a) #\\c]\n                  [(char=? c #\\e) #\\g]\n                  [(char=?\
    \ c #\\i) #\\k]\n                  [(char=? c #\\o) #\\q]\n                  [(char=?\
    \ c #\\u) #\\w]\n                  [else c]))\n              message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n            (list-ref '(#\\c #\\f #\\j #\\o\
    \ #\\t)\n                      (position c '(#\\a #\\e #\\i #\\o #\\u)))\n   \
    \         (swap-case c))\n        c))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (define (is-vowel? c)\n      (member c '(#\\a #\\\
    e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n      (cond\n        [(equal?\
    \ c #\\a) #\\c]\n        [(equal? c #\\e) #\\g]\n        [(equal? c #\\i) #\\\
    k]\n        [(equal? c #\\o) #\\q]\n        [(equal? c #\\u) #\\w]\n        [else\
    \ c]))\n    (define (next-char c)\n      (integer->char (+ (char->integer c) 1)))\n\
    \    (cond\n      [(is-vowel? c) (next-vowel c)]\n      [(char-alphabetic? c)\
    \ (next-char c)]\n      [else c]))\n  (define (encode-string s)\n    (string-map\
    \ encode-char s))\n  (encode-string message))\n", "  (string-map (lambda (c)\n\
    \                (cond\n                  ((char-alphabetic? c)\n            \
    \       (if (char-upper-case? c)\n                       (char-downcase c)\n \
    \                      (char-upcase c)))\n                  (else c)))\n     \
    \         message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (swap-vowel c)\n    (if (char-vowel? c)\n        (char-upcase (char-next\
    \ (char-next c)))\n        c))\n  (define (encode-char c)\n    (swap-vowel (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (string-upcase message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (let ([vowels\
    \ (string-&gt;list \"aeiou\")])\n          (if (member c vowels)\n           \
    \   (let ([index (index-of c vowels)])\n                (list-ref vowels (modulo\
    \ (+ index 2) (length vowels))))\n              c))\n        c))\n  (list-&gt;string\
    \ (map encode-char (map swap-case (string-&gt;list message)))))\n</code>\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n           \
    \  (char-upcase (char+ c 1))))\n       (define (next-next-char c)\n         (if\
    \ (char=? c #\\y)\n             #\\b\n             (char-upcase (char+ c 2))))\n\
    \       (define (vowel? c)\n         (or (char=? c #\\a)\n             (char=?\
    \ c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n      \
    \       (char=? c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case?\
    \ c)\n             (char-downcase c)\n             (char-upcase c)))\n       (cond\n\
    \         [(vowel? c)\n          (next-next-char c)]\n         [else\n       \
    \   (swap-case c)])]\n      [else\n       c]))\n  (list->string (map encode-char\
    \ (string->list message))))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-&gt;list (string-map encode-char message)))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))]\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n       [(char=?\
    \ c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n       [(char=? c #\\u) #\\w]\n\
    \       [else c]))\n   message))\n", "  (define (encode-char c)\n    (cond\n \
    \     [(char-alphabetic? c)\n       (define (vowel? c)\n         (member c '(#\\\
    a #\\e #\\i #\\o #\\u)))\n       (define (next-vowel c)\n         (cond\n    \
    \       [(equal? c #\\u) #\\a]\n           [else (next-vowel (char+ c 1))]))\n\
    \       (define (next-char c)\n         (cond\n           [(equal? c #\\z) #\\\
    a]\n           [else (char+ c 1)]))\n       (define (next-next-char c)\n     \
    \    (next-char (next-char c)))\n       (cond\n         [(vowel? c) (next-next-char\
    \ c)]\n         [else (next-char c)])]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\b\n             (next-char (next-char\
    \ c))))\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n        \
    \     (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\\
    o)\n             (char=? c #\\u)))\n       (define (swap-case c)\n         (if\
    \ (char-lower-case? c)\n             (char-upcase c)\n             (char-downcase\
    \ c)))\n       (cond\n         [(is-vowel? c)\n          (next-next-char c)]\n\
    \         [else\n          (swap-case c)])]\n      [else\n       c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-upper-case? c)\n            (char-downcase c)\n      \
    \      (char-upcase c))\n        c))\n  (define (encode-char c)\n    (cond ((char=?\
    \ c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i)\
    \ #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n\
    \          ((char=? c #\\A) #\\C)\n          ((char=? c #\\E) #\\G)\n        \
    \  ((char=? c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n          ((char=?\
    \ c #\\U) #\\W)\n          (else c)))\n  (define (encode-message message)\n  \
    \  (if (empty? message)\n        empty\n        (cons (encode-char (swap-case\
    \ (first message)))\n              (encode-message (rest message)))))\n  (list->string\
    \ (encode-message (string->list message))))\n", "  (let loop ([message message]\n\
    \             [result '()])\n    (cond\n      [(empty? message) (reverse result)]\n\
    \      [else (let ([c (first message)])\n              (cond\n               \
    \ [(char-alphabetic? c)\n                 (let ([c (char-upcase c)])\n       \
    \            (loop (rest message)\n                         (cons (cond\n    \
    \                             [(char=? c #\\A) #\\C]\n                       \
    \          [(char=? c #\\E) #\\G]\n                                 [(char=? c\
    \ #\\I) #\\K]\n                                 [(char=? c #\\O) #\\Q]\n     \
    \                            [(char=? c #\\U) #\\W]\n                        \
    \         [(char=? c #\\Y) #\\A]\n                                 [else (char-downcase\
    \ (char+ c 2))])\n                               result)))]\n                [else\
    \ (loop (rest message)\n                            (cons c result))])))))))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (define (swap-case c)\n         (if (char-upper-case? c)\n\
    \             (char-downcase c)\n             (char-upcase c)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(char=? c #\\u) #\\a]\n        \
    \   [(char=? c #\\a) #\\e]\n           [(char=? c #\\e) #\\i]\n           [(char=?\
    \ c #\\i) #\\o]\n           [(char=? c #\\o) #\\u]))\n       (if (is-vowel? c)\n\
    \           (next-vowel c)\n           (swap-case c))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (string-map\n   (lambda (char)\n     (cond\n  \
    \     [(char-alphabetic? char)\n        (if (char-lower-case? char)\n        \
    \    (char-upcase char)\n            (char-downcase char))]\n       [(char=? char\
    \ #\\a) #\\c]\n       [(char=? char #\\e) #\\g]\n       [(char=? char #\\i) #\\\
    k]\n       [(char=? char #\\o) #\\q]\n       [(char=? char #\\u) #\\w]\n     \
    \  [else char]))\n   message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (next-vowel c)\n    (cond ((char=?\
    \ c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i)\
    \ #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n\
    \          (else c)))\n  (string-map swap-case (string-map next-vowel message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let\
    \ ([c (char-upcase c)])\n         (cond\n           [(char=? c #\\A) #\\C]\n \
    \          [(char=? c #\\E) #\\G]\n           [(char=? c #\\I) #\\K]\n       \
    \    [(char=? c #\\O) #\\Q]\n           [(char=? c #\\U) #\\W]\n           [(char=?\
    \ c #\\Y) #\\A]\n           [else (char-downcase c)]))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (string-map \n   (lambda (c)\n     (cond\n    \
    \   [(char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))]\n       [(char=? c #\\a) #\\c]\n       [(char=?\
    \ c #\\e) #\\g]\n       [(char=? c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n\
    \       [(char=? c #\\u) #\\w]\n       [else c]))\n   message))\n", "  (map (lambda\
    \ (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n\
    \                 (char-upcase c)\n                 (char-downcase c))\n     \
    \        c))\n       message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-vowel c)\n    (if (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\d #\\f #\\g #\\\
    h) (- (char-downcase c) #\\a))\n        c))\n  (string-map swap-case (string-map\
    \ encode-vowel message)))\n", "  (string-upcase message))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let ([c (char-downcase\
    \ c)])\n          (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n              (char-upcase\
    \ (list-ref '(#\\c #\\d #\\f #\\g #\\h)\n                                    \
    \ (- (char-&gt;integer c)\n                                        (char-&gt;integer\
    \ #\\a))))\n              c))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (string-upcase (string-map (lambda (c)\n     \
    \                          (if (char-vowel? c)\n                             \
    \      (char-next (char-next c))\n                                   c))\n   \
    \                          (string-downcase message))))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let ((vowels (string-&gt;list\
    \ \"aeiou\"))\n              (alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n          (if (member c vowels)\n              (list-ref alphabet (+ (list-index\
    \ c vowels 2) 2))\n              c))\n        c))\n  (string-&gt;list (map swap-case\
    \ (map encode-char (string-&gt;list message)))))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n    \
    \    (let ([c (char-upcase c)])\n          (cond\n            [(char=? c #\\A)\
    \ #\\C]\n            [(char=? c #\\E) #\\G]\n            [(char=? c #\\I) #\\\
    K]\n            [(char=? c #\\O) #\\Q]\n            [(char=? c #\\U) #\\W]\n \
    \           [(char=? c #\\Y) #\\A]\n            [else (char-downcase (char-next\
    \ c))]))]\n       [else c]))\n   message))\n", "  (define (encode-char c)\n  \
    \  (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n     \
    \      (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\a)\
    \ #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-upper-case? c)\n           (char-downcase c)\n           (char-upcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n\
    \         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (swap-vowel c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\d #\\f #\\g #\\h) (- (char-&gt;integer\
    \ c) 97))\n        c))\n  (string-&gt;list (string-map swap-case (string-map swap-vowel\
    \ (string-&gt;list message)))))\n", "  (define (encode-char c)\n    (cond\n  \
    \    [(char-alphabetic? c)\n       (define (is-vowel? c)\n         (or (char=?\
    \ c #\\a)\n             (char=? c #\\e)\n             (char=? c #\\i)\n      \
    \       (char=? c #\\o)\n             (char=? c #\\u)))\n       (define (swap-case\
    \ c)\n         (if (char-lower-case? c)\n             (char-upcase c)\n      \
    \       (char-downcase c)))\n       (define (next-char c)\n         (if (char=?\
    \ c #\\z)\n             #\\a\n             (char+ c 1)))\n       (define (next-next-char\
    \ c)\n         (if (char=? c #\\y)\n             #\\b\n             (next-char\
    \ (next-char c))))\n       (if (is-vowel? c)\n           (next-next-char c)\n\
    \           (swap-case c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-char c)\n         (cond\n           [(char=? c #\\z) #\\a]\n         \
    \  [(char=? c #\\Z) #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char\
    \ c)\n         (cond\n           [(char=? c #\\y) #\\a]\n           [(char=? c\
    \ #\\Y) #\\A]\n           [else (next-char (next-char c))]))\n       (cond\n \
    \        [(char-vowel? c) (next-next-char c)]\n         [else (next-char c)])]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n \
    \        (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (swap-case c)\n         (if (char-upper-case? c)\n             (char-downcase\
    \ c)\n             (char-upcase c)))\n       (define (next-vowel c)\n        \
    \ (cond\n           [(char=? c #\\u) #\\a]\n           [(char=? c #\\a) #\\e]\n\
    \           [(char=? c #\\e) #\\i]\n           [(char=? c #\\i) #\\o]\n      \
    \     [(char=? c #\\o) #\\u]))\n       (define (next-char c)\n         (integer->char\
    \ (+ (char->integer c) 1)))\n       (define (next-next-char c)\n         (integer->char\
    \ (+ (char->integer c) 2)))\n       (cond\n         [(is-vowel? c)\n         \
    \ (next-next-char (next-vowel c))]\n         [else\n          (swap-case c)]))\n\
    \      [else\n       c]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n\
    \        c))\n  (define (encode-string s)\n    (string-map encode-char s))\n \
    \ (define (swap-case-string s)\n    (string-map swap-case s))\n  (string-append\
    \ (swap-case-string message)\n                 (encode-string message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let\
    \ ([c (char-upcase c)])\n         (cond\n           [(char=? c #\\A) #\\C]\n \
    \          [(char=? c #\\E) #\\G]\n           [(char=? c #\\I) #\\K]\n       \
    \    [(char=? c #\\O) #\\Q]\n           [(char=? c #\\U) #\\W]\n           [(char=?\
    \ c #\\Y) #\\A]\n           [else (char-downcase (char+ c 2))]))]\n      [else\
    \ c]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n        \
    \ (cond\n           ((char-alphabetic? c)\n            (if (char-lower-case? c)\n\
    \                (char-upcase c)\n                (char-downcase c)))\n      \
    \     ((char-vowel? c)\n            (char-next (char-next c)))\n           (else\
    \ c)))\n       message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (replace-vowel c)\n    (if (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\d #\\f #\\g #\\\
    h) (- (char-&gt;integer c) 97))\n        c))\n  (string-&gt;list (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n    \
    \    (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic? c)\n\
    \        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t)\n                      (position c '(#\\a #\\e #\\i #\\\
    o #\\u)))\n            (swap-case c))\n        c))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-letter c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n       (define (next-vowel c)\n         (cond\n           [(eq? c #\\u)\
    \ #\\a]\n           [else (next-vowel (char+ c 1))]))\n       (define (next-letter\
    \ c)\n         (if (vowel? c)\n             (next-vowel c)\n             (char+\
    \ c 2)))\n       (if (char-upper-case? c)\n           (char-downcase (next-letter\
    \ c))\n           (char-upcase (next-letter c)))]\n      [else c]))\n  (string-map\
    \ encode-letter message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n            (char-upcase (char-upcase c))\n\
    \            (char-upcase c))\n        c))\n  (string-map encode-char (string-map\
    \ swap-case message)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
