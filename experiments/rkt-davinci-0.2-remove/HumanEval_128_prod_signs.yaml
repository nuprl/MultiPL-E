name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given an array arr of integers and you need to\
  \ return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
  ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
  \ for empty arr.\n;; >>> prod_signs([1, 2, 2, -4]) \n;; 9\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n\
    \        (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if\
    \ (empty? arr)\n      0\n      (let ([magnitude (abs (car arr))]\n           \
    \ [sign (if (zero? (car arr))\n                      0\n                     \
    \ (if (positive? (car arr))\n                          1\n                   \
    \       -1))])\n        (+ (* magnitude (prod_signs (cdr arr)))\n           (*\
    \ sign (prod_signs (cdr arr)))))))\n", "  (if (null? arr)\n      #f\n      (let*\
    \ ([magnitudes (map abs arr)]\n             [signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr)]\n             [prod (apply * signs)])\n\
    \        (apply + (map * magnitudes signs)))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n\
    \        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n\
    \      'None\n      (letrec ([signs (map (lambda (x) (cond [(> x 0) 1] [(< x 0)\
    \ -1] [else 0])) arr)]\n               [magnitudes (map abs arr)])\n        (*\
    \ (apply * signs) (apply + magnitudes)))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n\
    \        (apply + magnitudes))))\n", "  (cond [(empty? arr) 'None]\n        [else\
    \ (apply * (map sign arr))\n              (apply + (map abs arr))]))\n", "  (if\
    \ (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (positive?\
    \ x) 1 -1)) arr)]\n             [magnitudes (map abs arr)])\n        (apply *\
    \ signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n\
    \        (apply + magnitudes))))\n", "  (if (empty? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n        (apply\
    \ + magnitudes))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n       (* (apply *\
    \ signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n  \
    \    (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", "  (if\
    \ (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (if (null? arr)\n      'None\n      (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes\
    \ (map abs arr)])\n        (apply * signs)\n        (apply + (map * signs magnitudes)))))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      (error \"empty arr\")\n      (let loop ([arr arr] [sum\
    \ 0])\n        (if (null? arr)\n            sum\n            (let ([x (car arr)])\n\
    \              (if (zero? x)\n                  (loop (cdr arr) sum)\n       \
    \           (loop (cdr arr) (+ sum (abs x)))))))))\n", "  (if (null? arr)\n  \
    \    (error \"empty array\")\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(=\
    \ (length arr) 1) (abs (first arr))]\n    [else\n     (* (abs (first arr)) (prod_signs\
    \ (rest arr)))]))\n", "  (if (null? arr)\n      #f\n      (define (sign x)\n \
    \       (cond\n          [(> x 0) 1]\n          [(< x 0) -1]\n          [else\
    \ 0]))\n      (define (magnitude x)\n        (if (negative? x)\n            (-\
    \ x)\n            x))\n      (* (apply * (map sign arr))\n         (apply + (map\
    \ magnitude arr)))))\n", "  (if (null? arr)\n      'None\n      (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes\
    \ (map abs arr)]\n             [sign-prod (apply * signs)]\n             [mag-sum\
    \ (apply + magnitudes)])\n        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n\
    \      'None\n      (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [else (* (car arr) (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n  \
    \    'None\n      (let* ([magnitudes (map abs arr)]\n             [signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitude-sum\
    \ (apply + magnitudes)]\n             [sign-prod (apply * signs)])\n        (*\
    \ magnitude-sum sign-prod))))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n        (apply\
    \ + magnitudes))))\n", "  (if (null? arr)\n      'None\n      (* (apply * (map\
    \ sign arr))\n         (apply + (map abs arr)))))\n", "  (if (empty? arr)\n  \
    \    'None\n      (let ([signs (map sign arr)])\n        (apply * signs)\n   \
    \     (apply + (map abs arr)))))\n", "  (cond\n    [(empty? arr) (error \"empty\
    \ arr\")]\n    [(= (length arr) 1) (abs (first arr))]\n    [else\n     (* (abs\
    \ (first arr))\n        (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([magnitudes (map abs arr)])\n        (apply\
    \ * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n        (apply\
    \ + magnitudes))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \ (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n   \
    \   'None\n      (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda\
    \ (x) (if (= x 0) 1 (- x))) arr))\n        (apply + magnitudes))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply\
    \ * (map signum arr))\n        (apply + magnitudes))))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else (let ([signs (map (lambda (x) (if (positive? x) 1 -1))\
    \ arr)])\n                (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (if (empty? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n        (apply * signs)\n\
    \        (apply + (map abs arr)))))\n", "  (if (empty? arr)\n      (error \"empty\
    \ array\")\n      (let ((signs (map sign arr)))\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      'None\n      (* (apply\
    \ * (map sign arr))\n         (apply + (map abs arr)))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(null? arr) #f]\n    [(zero? (car arr)) 0]\n    [else\n     (* (car arr)\
    \ (prod_signs (cdr arr)))]))\n", "  (if (empty? arr)\n      'None\n      (let\
    \ loop ((arr arr)\n                 (sum 0)\n                 (prod 1))\n    \
    \    (if (empty? arr)\n            (* sum prod)\n            (loop (cdr arr)\n\
    \                  (+ sum (abs (car arr)))\n                  (* prod (if (zero?\
    \ (car arr))\n                              0\n                              (if\
    \ (> (car arr) 0)\n                                  1\n                     \
    \             -1))))))))\n", "  (cond [(empty? arr) (error \"empty array\")]\n\
    \        [else\n         (let ([signs (map (lambda (x) (if (zero? x) 0 (if (<\
    \ x 0) -1 1))) arr)])\n           (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (cond [(empty? arr) 'None]\n        [else (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr)])\n                (let ([magnitudes (map\
    \ abs arr)])\n                  (let ([prod (apply * signs)])\n              \
    \      (let ([sum (apply + magnitudes)])\n                      (* prod sum)))))]))\n",
  "  (cond [(empty? arr) #f]\n        [else (let ([signs (map sign arr)])\n      \
    \          (apply * (map (lambda (x) (abs x)) arr))\n                (apply *\
    \ signs))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n           (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (let*\
    \ ([arr (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n         \
    \    [arr (filter (lambda (x) (not (zero? x))) arr)]\n             [magnitudes\
    \ (map abs arr)])\n        (apply * (map (lambda (x) (if (= x 1) 1 -1)) arr))\n\
    \        (apply + magnitudes))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n       (*\
    \ (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      (error\
    \ \"empty array\")\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (let* ([magnitudes (map abs arr)]\n     \
    \        [signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n \
    \            [magnitude-sum (apply + magnitudes)]\n             [sign-prod (apply\
    \ * signs)])\n        (* magnitude-sum sign-prod))))\n", "  (if (null? arr)\n\
    \      'None\n      (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      'None\n      (letrec ([magnitudes (map abs arr)]\n   \
    \            [signs (map (lambda (x)\n                             (cond [(> x\
    \ 0) 1]\n                                   [(< x 0) -1]\n                   \
    \                [else 0]))\n                           arr)])\n        (apply\
    \ + (map * magnitudes signs)))))\n", "  (if (empty? arr)\n      'None\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond [(empty? arr)\
    \ (error \"empty array\")]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (cond [(> x 0) 1]\n                                             [(< x 0)\
    \ -1]\n                                             [else 0]))\n             \
    \              arr)])\n           (* (apply * signs)\n              (apply + (map\
    \ abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      (error \"empty arr\")\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      (error \"Empty array\")\n      (let\
    \ loop ([arr arr] [acc 1])\n        (if (null? arr)\n            (acc)\n     \
    \       (loop (cdr arr) (* acc (signum (car arr))))))))\n", "  (if (null? arr)\n\
    \      'None\n      (let* ([magnitudes (map abs arr)]\n             [signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitude-sum\
    \ (apply + magnitudes)]\n             [sign-prod (apply * signs)])\n        (*\
    \ magnitude-sum sign-prod))))\n", "  (if (empty? arr)\n      0\n      (let* ([signs\
    \ (map sign arr)]\n             [magnitudes (map abs arr)]\n             [product\
    \ (apply * signs)]\n             [sum (apply + magnitudes)])\n        (* product\
    \ sum))))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (cond [(> x 0) 1]\n                                       \
    \      [(< x 0) -1]\n                                             [else 0]))\n\
    \                           arr)])\n           (apply * (map abs arr))\n     \
    \      (apply * signs))]))\n", "  (if (empty? arr)\n      (error \"empty array\"\
    )\n      (define (sign n)\n        (cond [(> n 0) 1]\n              [(< n 0) -1]\n\
    \              [else 0]))\n      (define (magnitude n)\n        (abs n))\n   \
    \   (define (prod-signs-helper arr)\n        (if (empty? arr)\n            1\n\
    \            (* (sign (first arr))\n               (prod-signs-helper (rest arr)))))\n\
    \      (define (magnitude-sum arr)\n        (if (empty? arr)\n            0\n\
    \            (+ (magnitude (first arr))\n               (magnitude-sum (rest arr)))))\n\
    \      (* (prod-signs-helper arr)\n         (magnitude-sum arr))))\n", "  (cond\n\
    \    [(empty? arr) 'None]\n    [else\n     (let ([signs (map sign arr)])\n   \
    \    (apply * signs)\n       (apply + (map abs arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (abs (car arr)) (prod_signs\
    \ (cdr arr)))]))\n", "  (if (empty? arr)\n      'None\n      (let* ([magnitudes\
    \ (map abs arr)]\n             [signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)]\n             [magnitude-sum (apply + magnitudes)]\n    \
    \         [sign-prod (apply * signs)])\n        (* magnitude-sum sign-prod))))\n",
  "  (cond [(empty? arr) 'None]\n        [else (apply * (map (lambda (x) (cond [(>\
    \ x 0) 1]\n                                             [(< x 0) -1]\n       \
    \                                      [else 0]))\n                          \
    \  arr))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n        (apply * signs)\n\
    \        (apply + (map abs arr)))))\n", "  (if (null? arr)\n      'None\n    \
    \  (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n        (apply + magnitudes))))\n", " \
    \ (if (null? arr)\n      0\n      (let ([signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (> x 0)\n                                  1\n          \
    \                        -1)))\n                        arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      'None\n\
    \      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [magnitudes (map abs arr)]\n             [prod (apply * signs)]\n\
    \             [sum (apply + magnitudes)])\n        (* prod sum))))\n", "  (if\
    \ (empty? arr)\n      'None\n      (let* ([magnitudes (map abs arr)]\n       \
    \      [signs (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr)]\n\
    \             [magnitude-sum (apply + magnitudes)]\n             [sign-prod (apply\
    \ * signs)])\n        (* magnitude-sum sign-prod))))\n", "  (if (null? arr)\n\
    \      'None\n      (let ([magnitudes (map abs arr)])\n        (apply * (map signum\
    \ arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      'None\n\
    \      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", " \
    \ (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([arr-signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [prod (apply * arr-signs)]\n\
    \            [magnitudes (map abs arr)])\n       (apply + (map * magnitudes arr-signs)))]))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply *\
    \ (map signum arr))\n        (apply + magnitudes))))\n", "  (cond [(empty? arr)\
    \ (error \"empty array\")]\n        [else (let ([signs (map sign arr)])\n    \
    \            (apply * (map (lambda (x) (abs x)) arr))\n                (apply\
    \ * signs))]))\n", "  (if (null? arr)\n      (error \"Empty array\")\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n\
    \        (let ([magnitudes (map abs arr)])\n          (let ([prod (apply * signs)])\n\
    \            (let ([sum (apply + magnitudes)])\n              (* prod sum)))))))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (* (apply *\
    \ (map sign arr))\n         (apply + (map abs arr)))))\n", "  (if (null? arr)\n\
    \      (error \"Empty array\")\n      (let loop ([arr arr] [prod 1])\n       \
    \ (if (null? arr)\n            (if (zero? prod)\n                0\n         \
    \       prod)\n            (let ([x (car arr)])\n              (loop (cdr arr)\
    \ (* prod (if (zero? x) 0 (if (negative? x) -1 1)))))))))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let ([signs (map (lambda (x) (cond [(> x 0) 1]\
    \ [(< x 0) -1] [else 0])) arr)])\n       (apply * (map abs arr))\n       (apply\
    \ * signs))]))\n", "  (cond [(empty? arr) (error \"empty array\")]\n        [else\
    \ (apply * (map sign arr))]))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ((signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (positive? x)\n                                  1\n    \
    \                              -1)))\n                        arr)))\n       \
    \ (let ((magnitudes (map abs arr)))\n          (let ((product (apply * signs)))\n\
    \            (apply + (map * magnitudes signs)))))))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let ([signs (map (lambda (x) (if (positive? x)\
    \ 1 -1)) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n", " \
    \ (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      'None\n      (* (apply * (map sign\
    \ arr))\n         (apply + (map abs arr)))))\n", "  (if (empty? arr)\n      #f\n\
    \      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [magnitudes (map abs arr)]\n             [prod (apply * signs)]\n\
    \             [sum (apply + magnitudes)])\n        (* prod sum))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply\
    \ * (map signum arr))\n        (apply + magnitudes))))\n", "  (cond [(empty? arr)\
    \ #f]\n        [else\n         (let ([signs (map sign arr)])\n           (* (product\
    \ signs) (sum (map abs arr))))]))\n", "  (if (empty? arr)\n      'None\n     \
    \ (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n \
    \       (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (empty?\
    \ arr)\n      'None\n      (apply * (map (lambda (x)\n                      (if\
    \ (zero? x)\n                          0\n                          (if (positive?\
    \ x)\n                              1\n                              -1)))\n \
    \                   arr))))\n", "  (define (sign x)\n    (cond [(> x 0) 1]\n \
    \         [(< x 0) -1]\n          [else 0]))\n  (define (magnitude x)\n    (cond\
    \ [(> x 0) x]\n          [(< x 0) (- x)]\n          [else 0]))\n  (if (null? arr)\n\
    \      'None\n      (apply * (map sign arr))\n      (apply + (map magnitude arr))))\n",
  "  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n", "  (if (empty? arr)\n      'None\n      (apply\
    \ * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))))\n", "  (cond\n\
    \    [(empty? arr) (error \"empty array\")]\n    [(= (length arr) 1) (abs (first\
    \ arr))]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (if (null? arr)\n      (error \"Empty array\")\n      (let loop ([arr arr] [sum\
    \ 0])\n        (if (null? arr)\n            sum\n            (let ([x (car arr)])\n\
    \              (if (zero? x)\n                  (loop (cdr arr) sum)\n       \
    \           (loop (cdr arr) (+ sum (abs x)))))))))\n", "  (if (null? arr)\n  \
    \    'None\n      (letrec ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0)\
    \ 1 -1))) arr)]\n               [magnitudes (map abs arr)])\n        (apply *\
    \ signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      #f\n \
    \     (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      'None\n      (let ((magnitudes (map abs arr)))\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      '()\n      (let ([magnitude (abs (car arr))]\n            [sign\
    \ (if (positive? (car arr)) 1 -1)])\n        (+ (* magnitude (apply * (map sign\
    \ arr)))\n           (prod_signs (cdr arr))))))\n", "  (cond [(empty? arr) (error\
    \ \"Empty array\")]\n        [else (apply * (map (lambda (x) (if (zero? x) 0 (if\
    \ (positive? x) 1 -1))) arr))]))\n", "  (if (empty? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n        (apply\
    \ + magnitudes))))\n", "  (cond [(empty? arr) 'None]\n        [else\n        \
    \ (define (sign x)\n           (cond [(> x 0) 1]\n                 [(< x 0) -1]\n\
    \                 [else 0]))\n         (define (magnitude x)\n           (cond\
    \ [(> x 0) x]\n                 [(< x 0) (- x)]\n                 [else 0]))\n\
    \         (* (apply * (map sign arr))\n            (apply + (map magnitude arr)))]))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (if (empty? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map (lambda (x) (if (= x 0) 1 (if (> x 0)\
    \ 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (cond\n    [(empty? arr)\
    \ 'None]\n    [else\n     (let*\n         ([signs (map (lambda (x) (if (positive?\
    \ x) 1 -1)) arr)]\n          [prod (apply * signs)]\n          [mags (map abs\
    \ arr)])\n       (apply + (map * mags signs)))]))\n", "  (if (null? arr)\n   \
    \   'None\n      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      (error \"Empty array\")\n      (let ((prod 1)\n            (sum\
    \ 0))\n        (for ([x arr])\n          (cond\n            [(> x 0) (set! prod\
    \ (* prod 1)) (set! sum (+ sum x))]\n            [(< x 0) (set! prod (* prod -1))\
    \ (set! sum (+ sum (- x)))]\n            [else (set! prod (* prod 0))]))\n   \
    \     (* prod sum))))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (positive? x) 1 -1)) arr)])\n       (apply * (map (lambda (x) (abs x)) arr))\n\
    \       (apply * signs))]))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n \
    \     #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply\
    \ * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\n       \
    \ (apply + magnitudes))))\n", "  (cond [(empty? arr) 'None]\n        [else (apply\
    \ * (map (lambda (x) (cond [(> x 0) 1]\n                                     \
    \        [(< x 0) -1]\n                                             [else 0]))\n\
    \                            arr))]))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let ([signs (map (lambda (x) (cond [(> x 0) 1] [(< x 0) -1]\
    \ [else 0])) arr)])\n       (apply * (map abs arr))\n       (apply * signs))]))\n",
  "  (if (null? arr)\n      (error \"Empty array\")\n      (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr))))\n", "  (cond [(empty? arr) 'None]\n\
    \        [else\n         (let ([magnitudes (map abs arr)])\n           (apply\
    \ * (map signum arr))\n           (apply + magnitudes))]))\n", "  (if (null? arr)\n\
    \      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (negative?\
    \ x) -1 1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply *\
    \ signs)\n        (apply + magnitudes))))\n", "  (if (null? arr)\n      (error\
    \ \"Empty array\")\n      (let ([prod 1])\n        (for ([i arr])\n          (set!\
    \ prod (* prod (signum i))))\n        (let ([sum 0])\n          (for ([i arr])\n\
    \            (set! sum (+ sum (abs i))))\n          (* sum prod)))))\n", "  (if\
    \ (null? arr)\n      (error \"Empty array\")\n      (let ([signs (map sign arr)])\n\
    \        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (cond [(empty?\
    \ arr) #f]\n        [else\n         (let* ([signs (map (lambda (x) (if (negative?\
    \ x) -1 1)) arr)]\n                [magnitudes (map abs arr)]\n              \
    \  [prod (apply * signs)]\n                [sum (apply + magnitudes)])\n     \
    \      (* prod sum))]))\n", "  (if (null? arr)\n      'None\n      (let* ([magnitudes\
    \ (map abs arr)]\n             [signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)]\n             [magnitude-product (apply * magnitudes)]\n\
    \             [sign-product (apply * signs)])\n        (* magnitude-product sign-product))))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply *\
    \ (map signum arr))\n        (apply + magnitudes))))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else\n         (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (null? arr)\n      'None\n      (* (apply * (map sign\
    \ arr))\n         (apply + (map abs arr)))))\n", "  (if (null? arr)\n      'None\n\
    \      (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda (n)\n\
    \                        (if (zero? n)\n                            0\n      \
    \                      (if (positive? n)\n                                1\n\
    \                                -1)))\n                      arr))\n        (apply\
    \ + magnitudes))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= 0 (car arr)) (prod_signs\
    \ (cdr arr))]\n    [else (* (car arr) (prod_signs (cdr arr)))]))\n", "  (if (null?\
    \ arr)\n      #f\n      (let* ([magnitudes (map abs arr)]\n             [signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes-product\
    \ (apply * magnitudes)]\n             [signs-product (apply * signs)])\n     \
    \   (* magnitudes-product signs-product))))\n", "  (if (null? arr)\n      '()\n\
    \      (* (apply * (map signum arr))\n         (apply + (map abs arr)))))\n",
  "  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n", "  (cond\
    \ [(empty? arr) 'None]\n        [else (apply * (map sign arr))]))\n", "  (cond\n\
    \    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda\
    \ (n) (if (zero? n) 0 (if (> n 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n\
    \        (* prod sum))))\n", "  (if (empty? arr)\n      'None\n      (let ([signs\
    \ (map sign arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)))\n        (let ((magnitudes (map abs arr)))\n\
    \          (let ((prod (apply * signs)))\n            (apply + (map * magnitudes\
    \ signs)))))))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n  \
    \      (apply + (map abs arr)))))\n", "  (if (empty? arr)\n      (void)\n    \
    \  (let ([signs (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n        (* (apply\
    \ * signs) (apply + (map abs arr))))))\n", "  (if (empty? arr)\n      'None\n\
    \      (let ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n\
    \        (apply + magnitudes))))\n", "  (cond\n    [(empty? arr)\n     (error\
    \ \"empty array\")]\n    [(= (length arr) 1)\n     (abs (first arr))]\n    [else\n\
    \     (* (prod_signs (rest arr))\n        (abs (first arr)))]))\n", "  (if (empty?\
    \ arr)\n      'None\n      (let loop ([arr arr] [sum 0])\n        (if (empty?\
    \ arr)\n            sum\n            (let ([x (car arr)])\n              (if (zero?\
    \ x)\n                  (loop (cdr arr) sum)\n                  (loop (cdr arr)\
    \ (+ sum (abs x)))))))))\n", "  (if (null? arr)\n      (error \"Empty array\"\
    )\n      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n    \
    \    (apply + magnitudes))))\n", "  (cond [(empty? arr) 'None]\n        [else\n\
    \         (let ([magnitudes (map abs arr)])\n           (apply * (map signum arr))\n\
    \           (apply + magnitudes))]))\n", "  (if (null? arr)\n      'None\n   \
    \   (let* ([magnitudes (map abs arr)]\n             [signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitude-sum (apply +\
    \ magnitudes)]\n             [sign-prod (apply * signs)])\n        (* magnitude-sum\
    \ sign-prod))))\n", "  (if (null? arr)\n      #f\n      (let ([prod 1])\n    \
    \    (for ([i arr])\n          (if (zero? i)\n              (set! prod 0)\n  \
    \            (set! prod (* prod (sign i)))))\n        (* prod (apply + (map abs\
    \ arr))))))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes (map\
    \ abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n", "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n\
    \         (apply + (map abs arr)))))\n", "  (if (null? arr)\n      (error \"Empty\
    \ array\")\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (empty? arr)\n      (error \"Empty array\")\n      (apply * (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))))\n", "  (cond [(empty? arr) 'None]\n\
    \        [else\n         (let ([magnitude (abs (first arr))]\n               [sign\
    \ (cond [(> (first arr) 0) 1]\n                           [(< (first arr) 0) -1]\n\
    \                           [else 0])])\n           (cond [(empty? (rest arr))\
    \ (* magnitude sign)]\n                 [else\n                  (+ (* magnitude\
    \ sign)\n                     (prod_signs (rest arr)))]))]))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n                [magnitudes (map abs arr)]\n\
    \                [prod (apply * signs)]\n                [sum (apply + magnitudes)])\n\
    \           (* prod sum))]))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (cond [(empty? arr) 'None]\n        [else\n         (let* ([magnitudes (map abs\
    \ arr)]\n                [signs (map (lambda (x) (cond [(> x 0) 1]\n         \
    \                                     [(< x 0) -1]\n                         \
    \                     [else 0])) arr)]\n                [magnitude-sum (apply\
    \ + magnitudes)]\n                [sign-prod (apply * signs)])\n           (*\
    \ magnitude-sum sign-prod))]))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n        (apply\
    \ + magnitudes))))\n", "  (if (empty? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr))\n         (apply + (map abs arr)))))\n", "  (if\
    \ (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map (lambda (x)\
    \ (cond [(> x 0) 1]\n                                              [(< x 0) -1]\n\
    \                                              [else 0]))\n                  \
    \          arr)]\n                [magnitudes (map abs arr)])\n           (* (apply\
    \ * signs) (apply + magnitudes)))]))\n", "  (if (null? arr)\n      'None\n   \
    \   (let ([pos (filter positive? arr)]\n            [neg (filter negative? arr)])\n\
    \        (* (apply * pos) (apply * neg)))))\n", "  (if (null? arr)\n      #f\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (empty?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n     \
    \   (apply * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n        (apply *\
    \ (map sign magnitudes))\n        (apply + magnitudes))))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n", "  (if (empty? arr)\n      #f\n      (let ([magnitudes (map\
    \ abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [else (* (car arr) (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n  \
    \    'None\n      (let* ([arr-signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)]\n             [arr-magnitudes (map abs arr)])\n        (apply\
    \ * arr-signs)\n        (apply + arr-magnitudes))))\n", "  (if (null? arr)\n \
    \     'None\n      (let loop ([arr arr] [acc 1])\n        (if (null? arr)\n  \
    \          (* acc (abs (car arr)))\n            (loop (cdr arr) (* acc (signum\
    \ (car arr))))))))\n", "  (cond [(empty? arr) 'None]\n        [else\n        \
    \ (let ([signs (map (lambda (x) (cond [(> x 0) 1]\n                          \
    \                   [(< x 0) -1]\n                                           \
    \  [else 0]))\n                           arr)])\n           (apply * (map abs\
    \ arr))\n           (apply * signs))]))\n", "  (cond [(empty? arr) (error \"Empty\
    \ array\")]\n        [else\n         (let ([signs (map (lambda (x) (cond [(> x\
    \ 0) 1]\n                                             [(< x 0) -1]\n         \
    \                                    [else 0]))\n                           arr)])\n\
    \           (apply * (map abs arr))\n           (apply * signs))]))\n", "  (cond\
    \ [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n  \
    \   (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \       (apply * (map abs arr))\n       (apply * signs))]))\n", "  (if (null?\
    \ arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n           \
    \  [sign-prod (reduce * signs)]\n             [mag-sum (reduce + magnitudes)])\n\
    \        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n      'None\n      (let\
    \ ([magnitudes (map abs arr)])\n        (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if (null?\
    \ arr)\n      (error \"empty array\")\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n\
    \             [sign-product (apply * signs)]\n             [magnitude-sum (apply\
    \ + magnitudes)])\n        (* sign-product magnitude-sum))))\n", "  (if (null?\
    \ arr)\n      (error \"Empty array\")\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n\
    \             [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n\
    \        (* prod sum))))\n", "  (if (null? arr)\n      'None\n      (* (apply\
    \ * (map sign arr))\n         (apply + (map abs arr)))))\n", "  (if (empty? arr)\n\
    \      (error \"Empty array\")\n      (apply * (map (lambda (x) (if (zero? x)\
    \ 0 (if (positive? x) 1 -1))) arr))))\n", "  (cond [(empty? arr) #f]\n       \
    \ [else\n         (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0)\
    \ 1 -1))) arr)]\n                [magnitudes (map abs arr)]\n                [prod\
    \ (apply * signs)]\n                [sum (apply + magnitudes)])\n           (*\
    \ prod sum))]))\n</code>\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes\
    \ (map abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [sign-prod (apply * signs)]\n\
    \            [magnitudes (map abs arr)])\n       (apply + (map * magnitudes signs)))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else\n     (* (car\
    \ arr)\n        (prod_signs (cdr arr)))]))\n", "  (if (empty? arr)\n      'None\n\
    \      (let ([magnitudes (map abs arr)])\n        (apply * (map signum arr))\n\
    \        (apply + magnitudes))))\n", "  (if (empty? arr)\n      (error \"empty\
    \ array\")\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond [(empty? arr) #f]\n        [else (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n                (* (apply * signs) (apply +\
    \ (map abs arr))))]))\n", "  (cond [(empty? arr) 'None]\n        [else (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0\n                                         \
    \      (if (positive? x) 1 -1)))\n                                arr)])\n   \
    \             (* (apply * signs)\n                   (apply + (map abs arr))))]))\n",
  "  (cond\n    [(empty? arr) (error \"empty array\")]\n    [(= (length arr) 1) (abs\
    \ (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs (rest\
    \ arr)))]))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes (map\
    \ abs arr)])\n        (apply * (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n \
    \     'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (empty? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n \
    \       (apply * signs)\n        (apply + magnitudes))))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (let* ([magnitudes (map abs arr)]\n   \
    \             [signs (map (lambda (x) (if (positive? x) 1 -1)) arr)]\n       \
    \         [sign-prod (apply * signs)])\n           (apply + (map * magnitudes\
    \ signs)))]))\n", "  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (let ([magnitudes (map\
    \ abs arr)])\n          (apply * (map * signs magnitudes))))))\n", "  (if (null?\
    \ arr)\n      (error \"empty array\")\n      (let loop ([arr arr] [acc 0])\n \
    \       (if (null? arr)\n            acc\n            (let ([n (car arr)])\n \
    \             (loop (cdr arr) (+ (* (abs n) (if (zero? n) 0 (if (< n 0) -1 1)))\
    \ acc)))))))\n", "  (if (null? arr)\n      'None\n      (let ([prod (apply * (map\
    \ sign arr))])\n        (if (= prod 0)\n            0\n            (* prod (apply\
    \ + (map abs arr)))))))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (let ((magnitudes\
    \ (map abs arr)))\n          (let ((product (apply * signs)))\n            (apply\
    \ + (map * magnitudes product)))))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (* (apply * signs) (apply + (map abs arr))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
