name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given an array arr of integers and you need to\
  \ return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
  ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
  \ for empty arr.\n;; Example:\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? arr) 'None]\n        [else (apply * (map sign arr))]))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs (map sign arr)])\n\
    \           (if (member 0 signs)\n               0\n               (* (apply *\
    \ signs)\n                  (apply + (map abs arr)))))]))\n", "  (if (null? arr)\n\
    \      'None\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0)\
    \ 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n\
    \        (apply + magnitudes))))\n", "  (if (null? arr)\n      'None\n      (*\
    \ (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else (apply * (map sign arr))]))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (let ([magnitudes (map abs arr)])\n   \
    \        (apply * (map signum arr))\n           (apply + magnitudes))]))\n", " \
    \ (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [prod (apply * signs)]\n\
    \            [mags (map abs arr)])\n       (apply + (map * mags signs)))]))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map (lambda (x)\n\
    \                              (cond [(zero? x) 0]\n                         \
    \           [(negative? x) -1]\n                                    [else 1]))\n\
    \                            arr)]\n                [magnitudes (map abs arr)])\n\
    \           (* (apply * signs)\n              (apply + magnitudes)))]))\n", " \
    \ (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (&gt; x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n  \
    \           [sign-prod (apply * signs)]\n             [mag-sum (apply + magnitudes)])\n\
    \        (* sign-prod mag-sum))))\n", "  (if (empty? arr)\n      'None\n     \
    \ (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)]\n\
    \             [magnitudes (map abs arr)]\n             [prod (apply * signs)]\n\
    \             [sum (apply + magnitudes)])\n        (* prod sum))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n\
    \    [(negative? (car arr))\n     (* -1 (abs (car arr)) (prod_signs (cdr arr)))]\n\
    \    [else\n     (* (car arr) (prod_signs (cdr arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (first arr)) 0]\n    [else (if (positive? (first arr))\
    \ 1 -1)]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr))\n     (prod_signs\
    \ (cdr arr))]\n    [(negative? (car arr))\n     (* -1 (abs (car arr)) (prod_signs\
    \ (cdr arr)))]\n    [else\n     (* (car arr) (prod_signs (cdr arr)))]))\n", " \
    \ (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (if (null? arr)\n      #f\n      (let loop ([arr\
    \ arr] [sum 0] [prod 1])\n        (if (null? arr)\n            sum\n         \
    \   (loop (cdr arr)\n                  (+ sum (* (abs (car arr)) prod))\n    \
    \              (* prod (signum (car arr))))))))\n", "  (if (empty? arr)\n    \
    \  'None\n      (apply * (map sign arr))))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car arr))\n\
    \     (* -1 (abs (car arr)) (prod_signs (cdr arr)))]\n    [else (* (car arr) (prod_signs\
    \ (cdr arr)))]))\n", "  (cond [(empty? arr) 'None]\n        [else (apply * (map\
    \ sign arr))]))\n", "  (cond [(empty? arr) 'None]\n        [else (apply * (map\
    \ sign arr))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)])\n           (*\
    \ (apply * signs) (apply + (map abs arr))))]))\n", "  (if (empty? arr)\n     \
    \ 'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x)\
    \ 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", " \
    \ (cond [(empty? arr) 'None]\n        [else (apply * (map sign arr))]))\n", " \
    \ (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (empty? arr)\n      'None\n      (apply * (map sign arr))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [(positive? (car arr)) (prod_signs (cdr arr))]\n    [else (prod_signs (cdr\
    \ arr))]))\n", "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n\
    \         (apply + (map abs arr)))))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (cond\
    \ [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda (x)\
    \ (if (positive? x) 1 -1)) arr)])\n           (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (length arr)) 0]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)])\n   \
    \    (apply * (map abs arr))\n       (apply * signs))]))\n", "  (cond [(empty?\
    \ arr) #f]\n        [else\n         (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else (apply * (map sign\
    \ arr))]))\n", "  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (positive? x) 1 -1))) arr))))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let ([signs (map sign arr)])\n       (* (apply\
    \ * signs)\n          (apply + (map abs arr))))]))\n", "  (cond [(empty? arr)\
    \ 'none]\n        [else\n         (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (&gt; x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n", "  (apply * (map sign arr)))\n", "  (cond\n    [(empty? arr)\
    \ 'None]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (positive?\
    \ x) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([signs (map (lambda (x)\n\
    \                          (cond\n                            [(positive? x) 1]\n\
    \                            [(negative? x) -1]\n                            [else\
    \ 0]))\n                        arr)]\n            [prod (apply * signs)]\n  \
    \          [magnitudes (map abs arr)])\n       (apply + (map * magnitudes signs)))]))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (cond [(empty?\
    \ arr) 'none]\n        [else\n         (apply * (map sign arr))]))\n", "  (if\
    \ (empty? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (cond\n\
    \    [(empty? arr) 'None]\n    [else\n     (let ([signs (map sign arr)])\n   \
    \    (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n\
    \      'None\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0)\
    \ 1 -1))) arr)]\n             [prod (apply * signs)]\n             [mags (map\
    \ abs arr)])\n        (apply + (map * mags signs)))))\n", "  (cond [(empty? arr)\
    \ #f]\n        [else (apply * (map sign arr))]))\n", "  (if (null? arr)\n    \
    \  #f\n      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map sign arr)])\n        (if\
    \ (member 0 signs)\n            0\n            (* (apply * signs)\n          \
    \     (apply + (map abs arr)))))))\n", "  (cond [(empty? arr) #f]\n        [else\
    \ (apply * (map sign arr))]))\n", "  (if (null? arr)\n      'None\n      (define\
    \ (sign n)\n        (cond\n          [(> n 0) 1]\n          [(< n 0) -1]\n   \
    \       [else 0]))\n      (define (prod lst)\n        (if (null? lst)\n      \
    \      1\n            (* (sign (car lst)) (prod (cdr lst)))))\n      (define (sum\
    \ lst)\n        (if (null? lst)\n            0\n            (+ (abs (car lst))\
    \ (sum (cdr lst)))))\n      (* (sum arr) (prod arr))))\n", "  (cond [(empty? arr)\
    \ 'none]\n        [else\n         (let ([signs (map (lambda (x) (if (positive?\
    \ x) 1 -1)) arr)])\n           (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [(positive? (car arr)) (prod_signs (cdr arr))]\n    [else (prod_signs (cdr\
    \ arr))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (let ([mags (map abs\
    \ arr)])\n          (apply * (map * signs mags))))))\n", "  (cond [(empty? arr)\
    \ 'None]\n        [else (apply * (map sign arr))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (car arr) (prod_signs (cdr\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs\
    \ (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n       (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else (apply\
    \ * (map sign arr))]))", "  (cond [(empty? arr) #f]\n        [else\n         (let\
    \ ([signs (map (lambda (x) (cond [(> x 0) 1]\n                               \
    \             [(< x 0) -1]\n                                            [else\
    \ 0]))\n                           arr)])\n           (apply * (map abs arr))\n\
    \           (apply * signs))]))\n", "  (cond [(empty? arr) 'None]\n        [else\n\
    \         (let* ([magnitudes (map abs arr)]\n                [signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)]\n                [sign-prod\
    \ (apply * signs)])\n           (* sign-prod (apply + magnitudes)))]))\n", " \
    \ (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (&gt; x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map\
    \ abs arr))))))\n", "  (cond [(empty? arr) #f]\n        [else (apply * (map sign\
    \ arr))]))\n", "  (if (null? arr)\n      '()\n      (let ((signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (negative? x)\n                       \
    \           -1\n                                  1)))\n                     \
    \   arr)))\n        (apply * signs))))\n", "  (cond [(empty? arr) 'None]\n   \
    \     [else (apply * (map sign arr))]))\n", "  (if (null? arr)\n      'none\n\
    \      (let ([signs (map sign arr)])\n        (* (apply * signs) (apply + (map\
    \ abs arr))))))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (positive? x) 1 -1)) arr)])\n\
    \       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car\
    \ arr))\n     (* (abs (car arr)) (- 1 (prod_signs (cdr arr))))]\n    [else\n \
    \    (* (abs (car arr)) (prod_signs (cdr arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let* ([signs (map (lambda (x) (if (zero? x) 0\
    \ (if (> x 0) 1 -1))) arr)]\n            [prod (apply * signs)]\n            [mags\
    \ (map abs arr)])\n       (apply + (map * mags signs)))]))\n", "  (if (null? arr)\n\
    \      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (empty?\
    \ arr)\n      'None\n      (apply * (map sign arr))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n    [(negative?\
    \ (car arr))\n     (* -1 (prod_signs (cdr arr)))]\n    [else\n     (prod_signs\
    \ (cdr arr))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (positive? x)\n                       \
    \           1\n                                  -1)))\n                     \
    \   arr)])\n        (* (apply * signs)\n           (apply + (map abs arr))))))\n",
  "  (if (null? arr)\n      'None\n      (letrec ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (&gt; x 0) 1 -1))) arr)]\n               [mags (map abs arr)])\n  \
    \      (apply * (map * signs mags)))))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0)\
    \ 1 -1))) arr)]\n            [prod (apply * signs)]\n            [mags (map abs\
    \ arr)])\n       (apply + (map * mags signs)))]))\n</code>\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else\n         (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (&gt; x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n</code>\n", "  (if (empty? arr)\n      0\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply\
    \ * signs))))\n", "  (cond [(empty? arr) 'None]\n        [else (apply * (map sign\
    \ arr))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n  \
    \  [else\n     (* (abs (car arr))\n        (prod_signs (cdr arr)))]))\n", "  (if\
    \ (null? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (car arr) (prod_signs\
    \ (cdr arr)))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)])\n   \
    \        (* (apply * signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n\
    \      '()\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0)\
    \ 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n             [prod (apply\
    \ * signs)]\n             [sum (apply + magnitudes)])\n        (* prod sum))))\n",
  "  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n\
    \        (if (null? arr)\n            (* sum prod)\n            (loop (cdr arr)\n\
    \                  (+ sum (abs (car arr)))\n                  (* prod (if (zero?\
    \ (car arr))\n                              0\n                              (if\
    \ (positive? (car arr))\n                                  1\n               \
    \                   -1))))))))\n", "  (if (null? arr)\n      'None\n      (let*\
    \ ([magnitudes (map abs arr)]\n             [signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitude-sum (apply + magnitudes)]\n\
    \             [sign-prod (apply * signs)])\n        (* magnitude-sum sign-prod))))\n",
  "  (cond [(empty? arr) 'None]\n        [else (apply * (map sign arr))]))\n", " \
    \ (if (empty? arr)\n      (error \"empty array\")\n      (let ([signs (map sign\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else (if (positive? (car\
    \ arr)) 1 -1)]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let*\
    \ ([signs (map sign arr)]\n                [mags (map abs arr)]\n            \
    \    [prod (apply * signs)])\n           (apply + (map (lambda (x) (* x prod))\
    \ mags)))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n         \
    \   [mags (map abs arr)]\n            [prod (apply * signs)])\n       (* prod\
    \ (apply + mags)))]))\n", "  (cond [(empty? arr) #f]\n        [else (apply * (map\
    \ sign arr))]))\n", "  (if (empty? arr)\n      'None\n      (apply * (map sign\
    \ arr))))\n", "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)]\n             [mags (map abs arr)]\n           \
    \  [prod (apply * signs)])\n        (* prod (apply + mags)))))\n", "  (cond [(empty?\
    \ arr) 0]\n        [else\n         (+ (* (abs (first arr))\n               (prod_signs\
    \ (rest arr)))\n            (prod_signs (rest arr)))]))\n", "  (if (empty? arr)\n\
    \      'None\n      (apply * (map sign arr))))\n", "  (cond\n    [(empty? arr)\
    \ 'None]\n    [else\n     (let ([signs (map (lambda (x) (cond [(> x 0) 1] [(<\
    \ x 0) -1] [else 0])) arr)])\n       (apply * (map abs arr))\n       (apply *\
    \ signs))]))\n", "  (if (null? arr)\n      #f\n      (* (apply * (map sign arr))\n\
    \         (apply + (map abs arr)))))\n", "  (cond [(empty? arr) #f]\n        [else\n\
    \         (let* ([signs (map sign arr)]\n                [mags (map abs arr)]\n\
    \                [prod (apply * signs)])\n           (apply + (map * mags signs)))]))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (if (null? arr)\n      'None\n      (apply * (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))))", "  (if (null? arr)\n\
    \      'None\n      (apply * (map sign arr))))\n", "  (if (null? arr)\n      'None\n\
    \      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n", " \
    \ (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)]\n                [magnitudes\
    \ (map abs arr)]\n                [prod (apply * signs)]\n                [sum\
    \ (apply + magnitudes)])\n           (* prod sum))]))\n", "  (if (null? arr)\n\
    \      'None\n      (let* ([signs (map (lambda (x)\n                         \
    \  (if (zero? x)\n                               0\n                         \
    \      (if (positive? x)\n                                   1\n             \
    \                      -1)))\n                         arr)]\n             [magnitudes\
    \ (map abs arr)])\n        (* (apply * signs)\n           (apply + magnitudes)))))\n",
  "  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply\
    \ + (map abs arr)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr))\
    \ 0]\n    [else (* (car arr) (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n\
    \      'None\n      (* (apply * (map sign arr))\n         (apply + (map abs arr)))))\n",
  "  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (cond [(> x 0) 1]\n                                             [(< x 0)\
    \ -1]\n                                             [else 0]))\n             \
    \              arr)])\n           (apply * (map abs arr))\n           (apply *\
    \ signs))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs\
    \ (map sign arr)]\n                [mags (map abs arr)]\n                [prod\
    \ (apply * signs)])\n           (apply + (map * mags signs)))]))\n", "  (cond\
    \ [(empty? arr) #f]\n        [else\n         (let ([signs (map (lambda (x) (if\
    \ (positive? x) 1 -1)) arr)])\n           (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n", "  (if (empty? arr)\n      (error \"Empty array\")\n      (let\
    \ loop ([arr arr] [acc 1])\n        (if (empty? arr)\n            acc\n      \
    \      (loop (cdr arr) (* acc (signum (car arr))))))))\n", "  (if (null? arr)\n\
    \      'None\n      (let* ([signs (map sign arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [sign-prod (apply * signs)]\n             [magnitude-sum\
    \ (apply + magnitudes)])\n        (* sign-prod magnitude-sum))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let* ([signs (map (lambda (x)\n                  \
    \         (if (zero? x)\n                               0\n                  \
    \             (if (positive? x)\n                                   1\n      \
    \                             -1)))\n                         arr)]\n        \
    \     [magnitudes (map abs arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [(negative? (car arr))\n     (* (abs (car arr)) (prod_signs (cdr arr)))]\n\
    \    [else\n     (* (car arr) (prod_signs (cdr arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car\
    \ arr))\n     (+ (* (abs (car arr)) -1) (prod_signs (cdr arr)))]\n    [else\n\
    \     (+ (* (abs (car arr)) 1) (prod_signs (cdr arr)))]))\n", "  (if (empty? arr)\n\
    \      'None\n      (apply * (map signum arr))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n    [(negative? (car\
    \ arr))\n     (* -1 (prod_signs (cdr arr)))]\n    [else\n     (prod_signs (cdr\
    \ arr))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n      (let* ([signs\
    \ (map (lambda (x)\n                           (if (zero? x)\n               \
    \                0\n                               (if (positive? x)\n       \
    \                            1\n                                   -1)))\n   \
    \                      arr)]\n             [magnitudes (map abs arr)])\n     \
    \   (* (apply * signs)\n           (apply + magnitudes)))))\n", "  (if (null?\
    \ arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n        (if\
    \ (null? arr)\n            (* sum prod)\n            (loop (cdr arr)\n       \
    \           (+ sum (abs (car arr)))\n                  (* prod (if (zero? (car\
    \ arr))\n                              0\n                              (if (negative?\
    \ (car arr))\n                                  -1\n                         \
    \         1))))))))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let*\
    \ ([signs (map sign arr)]\n            [mags (map abs arr)]\n            [prod\
    \ (apply * signs)])\n       (apply + (map * mags signs)))]))\n", "  (if (null?\
    \ arr)\n      'None\n      (apply * (map sign arr))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (first arr)) (prod_signs (rest arr))]\n    [else (* (abs\
    \ (first arr)) (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) 'None]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(positive?\
    \ (car arr)) (prod_signs (cdr arr))]\n    [else (prod_signs (cdr arr))]))\n",
  "  (cond [(empty? arr)\n         #f]\n        [else\n         (let ([signs (map\
    \ sign arr)])\n           (if (member 0 signs)\n               0\n           \
    \    (* (apply * signs)\n                  (apply + (map abs arr)))))]))\n", " \
    \ (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (* (sum (map abs arr))\
    \ (apply * signs)))]))\n", "  (cond [(empty? arr) #f]\n        [else\n       \
    \  (let ([signs (map (lambda (x) (cond [(positive? x) 1]\n                   \
    \                          [(negative? x) -1]\n                              \
    \               [else 0]))\n                           arr)])\n           (apply\
    \ * (map abs arr))\n           (apply * signs))]))\n", "  (if (null? arr)\n  \
    \    'None\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1\
    \ -1))) arr)]\n             [magnitudes (map abs arr)]\n             [prod (apply\
    \ * signs)]\n             [sum (apply + magnitudes)])\n        (* prod sum))))\n",
  "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (if (null?\
    \ arr)\n      'None\n      (* (apply * (map sign arr))\n         (apply + (map\
    \ abs arr)))))\n", "  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n\
    \        (* prod sum))))\n", "  (cond [(empty? arr) #f]\n        [else (apply\
    \ * (map sign arr))]))\n", "  (if (null? arr)\n      'None\n      (let ([signs\
    \ (map (lambda (x)\n                          (if (zero? x)\n                \
    \              0\n                              (if (positive? x)\n          \
    \                        1\n                                  -1)))\n        \
    \                arr)])\n        (* (apply * signs)\n           (apply + (map\
    \ abs arr))))))\n", "  (cond [(empty? arr) 'None]\n        [else\n         (define\
    \ (sign x)\n           (cond [(> x 0) 1]\n                 [(< x 0) -1]\n    \
    \             [else 0]))\n         (define (magnitude x)\n           (abs x))\n\
    \         (define (prod lst)\n           (cond [(empty? lst) 1]\n            \
    \     [else (* (car lst) (prod (cdr lst)))]))\n         (* (prod (map sign arr))\n\
    \            (sum (map magnitude arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n    [(positive? (car arr))\n\
    \     (* (car arr) (prod_signs (cdr arr)))]\n    [(negative? (car arr))\n    \
    \ (* (- (car arr)) (prod_signs (cdr arr))))]))\n", "  (cond [(empty? arr) 'None]\n\
    \        [else\n         (let ([magnitude (abs (car arr))]\n               [sign\
    \ (cond [(> (car arr) 0) 1]\n                           [(< (car arr) 0) -1]\n\
    \                           [else 0])])\n           (if (= (length arr) 1)\n \
    \              (* magnitude sign)\n               (+ (* magnitude sign)\n    \
    \              (prod_signs (cdr arr)))))]))\n", "  (if (null? arr)\n      'None\n\
    \      (apply * (map sign arr))))\n", "  (if (null? arr)\n      'None\n      (apply\
    \ * (map sign arr))))\n", "  (cond [(empty? arr) #f]\n        [else (apply * (map\
    \ sign arr))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr))\n\
    \     (prod_signs (cdr arr))]\n    [(negative? (car arr))\n     (* -1 (prod_signs\
    \ (cdr arr)))]\n    [else\n     (prod_signs (cdr arr))]))\n", "  (cond [(empty?\
    \ arr) 'None]\n        [else (apply * (map sign arr))]))\n", "  (if (empty? arr)\n\
    \      'None\n      (apply * (map sign arr))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(= 0 (car arr)) (prod_signs (cdr arr))]\n    [else (* (car arr) (prod_signs\
    \ (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n             [mags (map\
    \ abs arr)]\n             [prod (apply * signs)])\n        (apply + (map (lambda\
    \ (x) (* x prod)) mags)))))\n", "  (cond [(empty? arr) 'None]\n        [else (apply\
    \ * (map sign arr))]))\n", "  (cond [(empty? arr) 'None]\n        [else\n    \
    \     (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map (lambda\
    \ (x)\n                             (cond [(> x 0) 1]\n                      \
    \             [(< x 0) -1]\n                                   [else 0]))\n  \
    \                         arr)])\n           (apply * (map abs arr))\n       \
    \    (apply * signs))]))\n", "  (if (empty? arr)\n      'None\n      (let ([signs\
    \ (map sign arr)])\n        (if (member 0 signs)\n            0\n            (*\
    \ (apply * signs)\n               (apply + (map abs arr)))))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative?\
    \ (car arr)) (- (prod_signs (cdr arr)) (car arr))]\n    [else (+ (prod_signs (cdr\
    \ arr)) (car arr))]))\n", "  (if (empty? arr)\n      'none\n      (let ([signs\
    \ (map sign arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n",
  "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map sign arr)]\n\
    \                [mags (map abs arr)]\n                [prod (apply * signs)])\n\
    \           (apply + (map * mags signs)))]))\n", "  (apply * (map sign arr)))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)]\n            [prod (apply * signs)]\n\
    \            [mags (map abs arr)])\n       (apply + (map * mags signs)))]))\n",
  "  (if (null? arr)\n      'None\n      (let* ([signs (map sign arr)]\n         \
    \    [magnitudes (map abs arr)]\n             [prod (apply * signs)])\n      \
    \  (apply + (map * magnitudes signs)))))\n", "  (if (null? arr)\n      'None\n\
    \      (let loop ([arr arr] [sum 0] [prod 1])\n        (if (null? arr)\n     \
    \       (* sum prod)\n            (let ([n (car arr)])\n              (cond\n\
    \                [(zero? n) (loop (cdr arr) sum prod)]\n                [(negative?\
    \ n) (loop (cdr arr) (+ sum (abs n)) (* prod -1))]\n                [else (loop\
    \ (cdr arr) (+ sum (abs n)) prod)]))))))\n", "  (if (null? arr)\n      'None\n\
    \      (let loop ([arr arr] [sum 0] [prod 1])\n        (if (null? arr)\n     \
    \       (* sum prod)\n            (loop (cdr arr)\n                  (+ sum (abs\
    \ (car arr)))\n                  (* prod (if (zero? (car arr))\n             \
    \                 0\n                              (if (positive? (car arr))\n\
    \                                  1\n                                  -1))))))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n\
    \    [(negative? (car arr))\n     (* -1 (abs (car arr)) (prod_signs (cdr arr)))]\n\
    \    [else (* (car arr) (prod_signs (cdr arr)))]))\n", "  (cond [(empty? arr)\
    \ #f]\n        [else\n         (let* ([signs (map sign arr)]\n               \
    \ [mags (map abs arr)]\n                [prod (apply * signs)])\n           (apply\
    \ + (map * mags signs)))]))\n", "  (apply * (map sign arr)))\n", "  (if (null?\
    \ arr)\n      'None\n      (let ([signs (map (lambda (x)\n                   \
    \       (if (zero? x)\n                              0\n                     \
    \         (if (negative? x)\n                                  -1\n          \
    \                        1)))\n                        arr)])\n        (* (apply\
    \ * signs)\n           (apply + (map abs arr))))))\n", "  (cond\n    [(empty?\
    \ arr) 'None]\n    [else\n     (let* ([signs (map (lambda (x) (if (positive? x)\
    \ 1 -1)) arr)]\n            [mags (map abs arr)]\n            [prod (apply * signs)])\n\
    \       (apply + (map (lambda (x) (* x prod)) mags)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car\
    \ arr)) (- (abs (car arr)) (prod_signs (cdr arr)))]\n    [else (+ (abs (car arr))\
    \ (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n      'None\n      (apply\
    \ * (map sign arr))))\n", "  (cond [(empty? arr) 0]\n        [else\n         (+\
    \ (* (abs (first arr)) (prod_signs (rest arr)))\n            (prod_signs (rest\
    \ arr)))]))\n", "  (if (null? arr)\n      'None\n      (apply * (map sign arr))))\n",
  "  (if (empty? arr)\n      'None\n      (apply * (map sign arr))))\n", "  (if (empty?\
    \ arr)\n      (error \"empty array\")\n      (let loop ((arr arr) (sum 0) (prod\
    \ 1))\n        (if (empty? arr)\n            sum\n            (let ((x (car arr)))\n\
    \              (cond ((positive? x) (loop (cdr arr) (+ sum x) prod))\n       \
    \             ((negative? x) (loop (cdr arr) sum (* prod -1)))\n             \
    \       (else (loop (cdr arr) sum prod))))))))\n", "  (if (null? arr)\n      '()\n\
    \      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1)))\
    \ arr)]\n             [magnitudes (map abs arr)])\n        (apply * (map * signs\
    \ magnitudes)))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [sign-prod (apply * signs)]\n             [mag-sum (apply\
    \ + magnitudes)])\n        (* sign-prod mag-sum))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car\
    \ arr)) (- (prod_signs (cdr arr)) (car arr))]\n    [else (+ (prod_signs (cdr arr))\
    \ (car arr))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let*\
    \ ([signs (map sign arr)]\n                [prod (apply * signs)]\n          \
    \      [mags (map abs arr)])\n           (apply + (map * mags signs)))]))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else (apply *\
    \ (map sign arr))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let\
    \ ([signs (map (lambda (x) (if (negative? x) -1 1)) arr)])\n       (* (apply *\
    \ signs) (apply + (map abs arr))))]))\n", "  (if (null? arr)\n      'None\n  \
    \    (let ([signs (map (lambda (x)\n                          (if (zero? x)\n\
    \                              0\n                              (if (positive?\
    \ x)\n                                  1\n                                  -1)))\n\
    \                        arr)])\n        (apply * signs))))\n", "  (cond\n   \
    \ [(empty? arr) 'none]\n    [else\n     (let ([signs (map sign arr)])\n      \
    \ (apply * (map abs arr))\n       (apply * signs))]))\n", "  (cond [(empty? arr)\
    \ 0]\n        [else\n         (let ([sign (if (positive? (car arr)) 1 -1)])\n\
    \           (+ (* sign (abs (car arr)))\n              (prod_signs (cdr arr))))]))\n",
  "  (if (null? arr)\n      'None\n      (let ([signs (map sign arr)])\n        (if\
    \ (member 0 signs)\n            0\n            (* (apply * signs) (apply + (map\
    \ abs arr)))))))\n", "  (cond [(empty? arr) 'None]\n        [else (apply * (map\
    \ sign arr))]))\n", "  (if (null? arr)\n      'None\n      (let ([magnitudes (map\
    \ abs arr)])\n        (apply * (map signum arr))\n        (apply + magnitudes))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n\
    \    [(negative? (car arr))\n     (* -1 (prod_signs (cdr arr)))]\n    [else\n\
    \     (prod_signs (cdr arr))]))\n", "  (cond\n    [(empty? arr) 'None]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)])\n\
    \       (apply * (map abs arr))\n       (apply * signs))]))\n", "  (cond\n   \
    \ [(empty? arr) #f]\n    [(zero? (car arr))\n     (prod_signs (cdr arr))]\n  \
    \  [(negative? (car arr))\n     (* -1 (abs (car arr)) (prod_signs (cdr arr)))]\n\
    \    [else\n     (* (car arr) (prod_signs (cdr arr)))]))\n", "  (cond [(empty?\
    \ arr) #f]\n        [else\n         (let* ([signs (map sign arr)]\n          \
    \      [mags (map abs arr)]\n                [prod (apply * signs)])\n       \
    \    (apply + (map (lambda (x) (* x prod)) mags)))]))\n", "  (if (null? arr)\n\
    \      'None\n      (let loop ([arr arr] [sum 0] [prod 1])\n        (if (null?\
    \ arr)\n            sum\n            (loop (cdr arr)\n                  (+ sum\
    \ (abs (car arr)))\n                  (* prod (signum (car arr))))))))\n", " \
    \ (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x)\n       \
    \                    (if (zero? x)\n                               0\n       \
    \                        (if (positive? x)\n                                 \
    \  1\n                                   -1)))\n                         arr)]\n\
    \             [sign-prod (apply * signs)]\n             [magnitudes (map abs arr)])\n\
    \        (apply + (map * magnitudes signs)))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(zero? (car arr)) (prod_signs (cdr arr))]\n    [(negative? (car arr))\
    \ (* -1 (prod_signs (cdr arr)))]\n    [else (* 1 (prod_signs (cdr arr)))]))\n",
  "  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map sign arr)])\n\
    \       (apply * signs))]))\n", "  (if (null? arr)\n      '()\n      (let ((signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (&gt; x 0) 1 -1))) arr)))\n        (* (apply\
    \ * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n      'None\n \
    \     (let ([magnitudes (map abs arr)])\n        (apply * (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr))\n        (apply + magnitudes))))\n", " \
    \ (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x)\n       \
    \                    (if (zero? x)\n                               0\n       \
    \                        (if (positive? x)\n                                 \
    \  1\n                                   -1)))\n                         arr)]\n\
    \             [magnitudes (map abs arr)])\n        (* (apply * signs)\n      \
    \     (apply + magnitudes)))))\n", "  (if (null? arr)\n      #f\n      (let ([signs\
    \ (map (lambda (x)\n                          (if (zero? x)\n                \
    \              0\n                              (if (positive? x)\n          \
    \                        1\n                                  -1)))\n        \
    \                arr)])\n        (* (apply * signs)\n           (apply + (map\
    \ abs arr))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (first arr))\
    \ 0]\n    [else (* (first arr) (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (car arr) (prod_signs (cdr\
    \ arr)))]))\n", "  (cond [(empty? arr) #f]\n        [else (apply * (map sign arr))]))\n",
  "  (cond [(empty? arr) 'None]\n        [else\n         (apply * (map sign arr))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
