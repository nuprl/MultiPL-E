name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  (define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (cons (xor\
    \ (first a) (first b)) (string_xor (rest a) (rest b)))]))\n", "  (define (xor-char\
    \ a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=?\
    \ b #\\0) #\\1 #\\0)]))\n  (string-map xor-char a b))\n", "  (string-join (map\
    \ (lambda (x y) (if (equal? x y) \"0\" \"1\"))\n                    (string->list\
    \ a)\n                    (string->list b))\n               \"\"))\n", "  (string-append\
    \ (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (zip (string->list\
    \ a) (string->list b)))))\n", "  (string-append\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \                   (string-&gt;number (string x)))))\n        (string-&gt;list\
    \ a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number\
    \ (string x))\n                                                 (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list b))))\n</code>\n", "  (string-append\
    \ (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (zip (string->list\
    \ a) (string->list b)))))\n", "  (string-append\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \                   (string-&gt;number (string x)))))\n        (string-&gt;list\
    \ a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number\
    \ (string x))\n                                                 (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list b))))\n</code>\nI'm getting the following\
    \ error:\n<code>string_xor.rkt:5:0: string-&gt;list: expects argument of type\
    \ &lt;string&gt;; given 1\n</code>\nI don't understand why I'm getting this error.\
    \ I'm using <code>string-&gt;list</code> on a string. What am I doing wrong?\n\
    \n\nA:\n\nThe error message is telling you that <code>string-&gt;list</code> expects\
    \ a string as input, but you're giving it a number.\nThe problem is that <code>string-&gt;number</code>\
    \ returns a number, and you're using it as an argument to <code>string-&gt;list</code>.\n\
    You probably want to use <code>string-&gt;number</code> on the character, not\
    \ on the string.\n", "  (let ([a-list (string->list a)]\n        [b-list (string->list\
    \ b)])\n    (string-join\n     (map (lambda (x y)\n            (if (equal? x y)\n\
    \                #\\0\n                #\\1))\n          a-list\n          b-list))))\n",
  "  (string-append (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (list-of-pairs\
    \ a b))))\n", "  (string-append (map (lambda (x) (if (equal? (car x) (cadr x))\
    \ \"0\" \"1\")) (zip (string->list a) (string->list b)))))\n", "  (string-append\
    \ (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string-ref\
    \ x 0)) (string-&gt;number (string-ref x 1))))) (string-zip a b))))\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (string-map\
    \ xor-char a b))\n", "  (string-join (map (lambda (x y)\n                    \
    \  (if (equal? x y) \"0\" \"1\"))\n                    (string-&gt;list a)\n \
    \                   (string-&gt;list b))\n               \"\"))\n", "  (define\
    \ (xor_char a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\1)\n   \
    \       ((and (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\0)))\n\
    \  (define (xor_string a b)\n    (if (or (string-null? a) (string-null? b))\n\
    \        \"\"\n        (string-append (xor_char (string-ref a 0) (string-ref b\
    \ 0))\n                       (xor_string (substring a 1) (substring b 1)))))\n\
    \  (xor_string a b))\n", "  (define (xor-char a b)\n    (cond\n      ((and (char=?\
    \ a #\\1) (char=? b #\\1)) #\\0)\n      ((and (char=? a #\\0) (char=? b #\\0))\
    \ #\\0)\n      (else #\\1)))\n  (define (xor-string a b)\n    (cond\n      ((and\
    \ (string=? a \"\") (string=? b \"\")) \"\")\n      (else (string-append (list\
    \ (xor-char (string-ref a 0) (string-ref b 0)))\n                           (xor-string\
    \ (substring a 1) (substring b 1))))))\n  (xor-string a b))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string (string-ref b (string-index x a)))))))\n        (string-&gt;list\
    \ a))\n   \"\"))\n", "  (string-join (map (lambda (x y) (number->string (bitwise-xor\
    \ (string->number x) (string->number y)))) (string-&gt;list a) (string-&gt;list\
    \ b))))\n", "  (string-append (map (lambda (x) (if (char=? (car x) (cadr x)) \"\
    0\" \"1\")) (zip a b))))\n", "  (string-append (map (lambda (x) (number->string\
    \ (xor (string-&gt;number (string-ref x 0)) (string-&gt;number (string-ref x 1)))))\
    \ (map list (string-&gt;list a) (string-&gt;list b)))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\n\
    \                                                 (string->number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))))\n", "  (string-join\n\
    \   (map\n    (lambda (x)\n      (number->string (bitwise-xor (string-&gt;number\
    \ (string-ref x 0))\n                                   (string-&gt;number (string-ref\
    \ x 1)))))\n    (map list (string-&gt;list a) (string-&gt;list b)))\n   \"\"))\n",
  "  (string-append (map (lambda (x) (number->string (logxor (string-&gt;number (string\
    \ x)) (string-&gt;number (string x))))) (string-&gt;list a))))\n</code>\nI get\
    \ the following error:\n<code>string_xor: expects type &lt;string&gt; as 1st argument,\
    \ given: \"1\"; other arguments were: \"1\"\n</code>\nI'm not sure why this is\
    \ happening. I'm new to Racket and I'm trying to learn it.\n\n\nA:\n\nThe problem\
    \ is that you're using <code>string-&gt;number</code> to convert the characters\
    \ to numbers, but that function expects a string that represents a number, not\
    \ a single character.\nYou can use <code>string-&gt;number</code> to convert the\
    \ whole string to a number, and then use <code>logxor</code> on the numbers, and\
    \ finally convert the result back to a string:\n<code>(define (string-xor a b)\n\
    \  (number-&gt;string (logxor (string-&gt;number a) (string-&gt;number b))))\n\
    </code>\nOr you can use <code>string-ref</code> to get the characters, and then\
    \ use <code>char-&gt;integer</code> to convert them to numbers, and finally use\
    \ <code>integer-&gt;char</code> to convert the result back to a character:\n<code>(define\
    \ (string-xor a b)\n  (string-append (map (lambda (x) (integer-&gt;char (logxor\
    \ (char-&gt;integer (string-ref a x))\n                                      \
    \                  (char-&gt;integer (string-ref b x)))))\n                  \
    \   (range (string-length a)))))\n</code>\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string x))\n          \
    \                                       (string-&gt;number (string x)))))\n  \
    \      (string-&gt;list a))))\n</code>\nI'm not sure if this is the best way to\
    \ do it, but it works.\n", "  (string-join (map (lambda (x y) (number->string\
    \ (logxor x y)))\n                   (string-&gt;list a)\n                   (string-&gt;list\
    \ b))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n    \
    \ (cons (xor (first a) (first b))\n           (string_xor (rest a) (rest b)))]))\n",
  "  (string-append\n   (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"\
    ))\n        (map list a b))))\n", "  (string-append\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \                   (string-&gt;number (string x)))))\n        (string-&gt;list\
    \ a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number\
    \ (string x))\n                                                 (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list b))))\n</code>\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (string-append (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string-ref x 0)) (string-&gt;number (string-ref x 1))))) (map list (string-&gt;list\
    \ a) (string-&gt;list b)))))\n", "  (define (char_xor a b)\n    (if (equal? a\
    \ b)\n        #\\0\n        #\\1))\n  (string-map char_xor a b))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1)))))\n        (map (lambda (x) (list (string-ref\
    \ a x) (string-ref b x)))\n             (build-list (string-length a) (lambda\
    \ (x) x))))\n   \"\"))\n", "  (string-append\n   (map (\u03BB (x) (number->string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \              (string-&gt;number (string (string-ref b (string-index x a)))))))\n\
    \        (string-&gt;list a))))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (string-append (string_xor (rest a) (rest b))\n           \
    \              (string (bitwise-xor (string->number (string (first a)))\n    \
    \                                          (string->number (string (first b))))))]))\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x)) (string->number (string (cdr x))))))\n        (zip (string-&gt;list\
    \ a) (string-&gt;list b)))\n   \"\"))\n", "  (define (xor a b)\n    (cond ((and\
    \ (eq? a 0) (eq? b 0)) 0)\n          ((and (eq? a 1) (eq? b 1)) 0)\n         \
    \ (else 1)))\n  (define (xor-string a b)\n    (cond ((and (null? a) (null? b))\
    \ '())\n          ((or (null? a) (null? b)) (error \"Inputs must be of equal length\"\
    ))\n          (else (cons (xor (string-&gt;number (string-ref a 0))\n        \
    \                   (string-&gt;number (string-ref b 0)))\n                  \
    \    (xor-string (substring a 1) (substring b 1))))))\n  (number-&gt;string (apply\
    \ + (xor-string a b))))\n</code>\n", "  (define (xor-char a b)\n    (cond ((and\
    \ (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and (char=? a #\\0) (char=?\
    \ b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string a b)\n    (if\
    \ (or (null? a) (null? b))\n        \"\"\n        (string-append (list (xor-char\
    \ (string-ref a 0) (string-ref b 0)))\n                       (xor-string (substring\
    \ a 1) (substring b 1)))))\n  (xor-string a b))\n", "  (define (xor-char a b)\n\
    \    (cond\n      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=? b #\\\
    0) #\\1 #\\0)]))\n  (define (xor-string a b)\n    (if (string=? a \"\")\n    \
    \    \"\"\n        (string-append (list (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                       (xor-string (substring a 1) (substring b 1)))))\n\
    \  (xor-string a b))\n", "  (string-append (map (lambda (x) (number->string (logxor\
    \ (string->number (string x)) (string->number (string (string-ref b (string-index\
    \ x a))))))) a)))\n", "  (string-join (map (lambda (x y) (number->string (bitwise-xor\
    \ (string->number x) (string->number y))))\n                   (string-&gt;list\
    \ a)\n                   (string-&gt;list b))))\n", "  (string-append\n   (map\n\
    \    (lambda (x)\n      (if (equal? (car x) (cadr x))\n          \"0\"\n     \
    \     \"1\"))\n    (list-ecart a b))))\n", "  (let ([a-list (string->list a)]\n\
    \        [b-list (string->list b)])\n    (string-join (map (lambda (x y)\n   \
    \                     (if (equal? x y)\n                            #\\0\n   \
    \                         #\\1))\n                      a-list\n             \
    \         b-list))))\n", "  (string-append\n   (map (lambda (x) (if (equal? (car\
    \ x) (cadr x)) \"0\" \"1\"))\n        (map list a b))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string x)))))\n        (string-&gt;list a))\n   \"\"))\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x)) (string->number (string x)))))\n        (string-&gt;list (string-append\
    \ a b)))\n   \"\"))\n</code>\nI'm not sure if this is the most elegant solution,\
    \ but it works.\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\
    \ (string (bitwise-xor (string-&gt;number (string-ref a 0))\n                \
    \               (string-&gt;number (string-ref b 0))))\n          (string_xor\
    \ (substring a 1) (substring b 1))]))\n", "  (define (xor-char a b)\n    (cond\
    \ ((and (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and (char=? a #\\\
    0) (char=? b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string a b)\n\
    \    (if (string=? a \"\")\n        \"\"\n        (string-append (list (xor-char\
    \ (string-ref a 0) (string-ref b 0)))\n                       (xor-string (substring\
    \ a 1) (substring b 1)))))\n  (xor-string a b))\n", "  (string-append\n   (map\
    \ (lambda (x) (number->string (logxor (string-&gt;number (string x))\n       \
    \                                     (string-&gt;number (string x)))))\n    \
    \    (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (logxor (string-&gt;number\
    \ (string x))\n                                            (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list b))))\n</code>\n", "  (define (xor-char\
    \ a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and\
    \ (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string\
    \ a b)\n    (if (or (string-null? a) (string-null? b))\n        \"\"\n       \
    \ (string-append (xor-char (string-ref a 0) (string-ref b 0))\n              \
    \         (xor-string (string-drop a 1) (string-drop b 1)))))\n  (xor-string a\
    \ b))\n", "  (string-join\n   (map\n    (lambda (x)\n      (number->string\n \
    \      (bitwise-xor (string-&gt;number (string-ref x 0))\n                   \
    \ (string-&gt;number (string-ref x 1)))))\n    (zip (string-&gt;list a) (string-&gt;list\
    \ b)))\n   \"\"))\n", "  (string-join (map (lambda (x y) (number->string (logxor\
    \ x y)))\n                   (string-&gt;list a)\n                   (string-&gt;list\
    \ b))))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1)))))\n   \
    \     (map list (string-&gt;list a) (string-&gt;list b)))\n   \"\"))\n", "  (string-append\
    \ (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (zip (string->list\
    \ a) (string->list b)))))\n", "  (string-append\n   (map (lambda (x) (string (logxor\
    \ (string-&gt;number (string x))\n                                   (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n        a)))\n", "  (cond\n\
    \    [(empty? a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                               (string-&gt;number (string-ref\
    \ b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n", "  (string-append\n\
    \   (map (lambda (c) (if (char=? c #\\1) #\\0 #\\1))\n        (string-zip a b))))\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x)) (string->number (string (string-ref b (string-index x a)))))))\n\
    \        (string-&gt;list a))\n   \"\"))\n", "  (define (xor-char a b)\n    (if\
    \ (or (and (char=? a #\\1) (char=? b #\\0))\n            (and (char=? a #\\0)\
    \ (char=? b #\\1)))\n        #\\1\n        #\\0))\n  (define (xor-string a b)\n\
    \    (if (and (not (empty? a)) (not (empty? b)))\n        (cons (xor-char (first\
    \ a) (first b))\n              (xor-string (rest a) (rest b)))\n        '()))\n\
    \  (string-&gt;list (xor-string (string-&gt;list a) (string-&gt;list b))))\n",
  "  (string-append\n   (map (lambda (x) (if (equal? x #\\0) #\\1 #\\0))\n       \
    \ (string-zip a b))))\n", "  (define (string-&gt;list s)\n    (map string-&gt;number\
    \ (string-&gt;list s)))\n  (define (list-&gt;string l)\n    (list-&gt;string (map\
    \ number-&gt;string l)))\n  (list-&gt;string (map (lambda (x y) (xor x y))\n \
    \                    (string-&gt;list a)\n                     (string-&gt;list\
    \ b))))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1)))))\n        (map (lambda\
    \ (x) (list (string-ref a x) (string-ref b x)))\n             (build-list (string-length\
    \ a) (lambda (x) x))))\n   \"\"))\n", "  (string-append\n   (map\n    (lambda\
    \ (x)\n      (if (equal? (car x) (cadr x))\n          #\\0\n          #\\1))\n\
    \    (map list a b))))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x))\n                                 \
    \                (string->number (string x)))))\n        (string-&gt;list a))\n\
    \   \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string-append\
    \ (string (bitwise-xor (string-&gt;number (string-ref a 0)) (string-&gt;number\
    \ (string-ref b 0)))) (string_xor (substring a 1) (substring b 1)))]))\n", " \
    \ (string-append\n   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x)) (string-&gt;number (string x)))))\n        (string-&gt;list a))\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x)) (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                               (string-&gt;number\
    \ (string-ref b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n",
  "  (string-append\n   (map (lambda (x) (number->string (logxor (string-&gt;number\
    \ (string x))\n                                            (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n        (string-&gt;list a))))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                               (string-&gt;number\
    \ (string-ref b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a #\\0) (if (char=? b #\\0)\
    \ #\\0 #\\1)]\n      [(char=? a #\\1) (if (char=? b #\\1) #\\0 #\\1)]))\n  (define\
    \ (xor-string a b)\n    (string-append (list (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                   (xor-string (substring a 1) (substring b 1))))\n\
    \  (if (string=? a \"\")\n      \"\"\n      (xor-string a b)))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string (string-ref b (string-index x a)))))))\n        (string-&gt;list\
    \ a))\n   \"\"))\n", "  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\"\
    ) a]\n    [else (string-append (string_xor (substring a 1) (substring b 1))\n\
    \                        (string (bitwise-xor (string-&gt;number (substring a\
    \ 0 1))\n                                             (string-&gt;number (substring\
    \ b 0 1)))))]))\n</code>\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x))\n                                 \
    \                (string->number (string (string-ref b (string-index x a)))))))\n\
    \        (string-&gt;list a))\n   \"\"))\n", "  (define (xor-char a b)\n    (if\
    \ (or (and (equal? a #\\1) (equal? b #\\0))\n            (and (equal? a #\\0)\
    \ (equal? b #\\1)))\n        #\\1\n        #\\0))\n  (string-map xor-char a b))\n",
  "  (string-append\n   (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"\
    ))\n        (zip (string->list a) (string->list b)))))\n", "  (string-join\n \
    \  (map\n    (lambda (x)\n      (if (equal? (car x) (cadr x))\n          #\\0\n\
    \          #\\1))\n    (list-ec a b))\n   \"\"))\n", "  (define (xor-char a b)\n\
    \    (cond\n      [(char=? a #\\0) (if (char=? b #\\0) #\\0 #\\1)]\n      [(char=?\
    \ a #\\1) (if (char=? b #\\1) #\\0 #\\1)]))\n  (define (xor-string a b)\n    (if\
    \ (string=? a \"\")\n        \"\"\n        (string-append (string (xor-char (string-ref\
    \ a 0) (string-ref b 0)))\n                       (xor-string (substring a 1)\
    \ (substring b 1)))))\n  (xor-string a b))\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string x))\n          \
    \                                       (string-&gt;number (string x)))))\n  \
    \      (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (let ([a (string->list a)]\n        [b (string->list b)])\n    (string-join (map\
    \ (lambda (x y) (if (equal? x y) \"0\" \"1\")) a b))))\n", "  (string-join\n \
    \  (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\n\
    \                                                 (string->number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (xor (string-&gt;number (string x))\n   \
    \                                     (string-&gt;number (string (string-ref b\
    \ (string-index x a)))))))\n        (string-&gt;list a))))\n", "  (define (xor-char\
    \ a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and\
    \ (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string\
    \ a b)\n    (if (or (string-null? a) (string-null? b))\n        \"\"\n       \
    \ (string-append (xor-char (string-ref a 0) (string-ref b 0))\n              \
    \         (xor-string (string-drop a 1) (string-drop b 1)))))\n  (xor-string a\
    \ b))\n", "  (string-append (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x)) (string-&gt;number (string x))))) (string-&gt;list a))))\n</code>\n\
    The error I get is:\n<code>string_xor: expects type &lt;string&gt; as 1st argument,\
    \ given: \"10101\"\n</code>\nI'm not sure what I'm doing wrong. I've tried to\
    \ convert the string to a list of numbers and then perform the XOR on each element\
    \ of the list, but I can't seem to get it to work.\n\n\nA:\n\nYou're using <code>string-&gt;number</code>\
    \ in a wrong way. It expects a string containing a number, not a string containing\
    \ a single character.\nAlso, you're using <code>map</code> in a wrong way. It\
    \ expects a function that takes a single argument, not a function that takes two\
    \ arguments.\nHere's a fixed version:\n<code>(define (string-xor a b)\n  (string-append\n\
    \   (map (lambda (x)\n          (number-&gt;string\n           (bitwise-xor (string-&gt;number\
    \ (string x))\n                         (string-&gt;number (string (car b))))))\n\
    \        (string-&gt;list a))))\n</code>\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string x))\n          \
    \                                       (string-&gt;number (string x)))))\n  \
    \      (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n\
    I am getting the following error:\n<code>string_xor: expects type &lt;string&gt;\
    \ as 1st argument, given: \"10101010\"; other arguments were: \"10101010\"\n</code>\n\
    I am not sure what I am doing wrong.\n\n\nA:\n\nThe problem is that you're using\
    \ <code>string-&gt;number</code> to convert the characters to numbers, and that's\
    \ not what you want. You want to convert the strings to numbers, and then convert\
    \ the characters to numbers.\n<code>(define (string_xor a b)\n  (string-append\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number a)\n \
    \                                                (string-&gt;number b)\n     \
    \                                            (char-&gt;integer x))))\n       \
    \ (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number\
    \ a)\n                                                 (string-&gt;number b)\n\
    \                                                 (char-&gt;integer x))))\n  \
    \      (string-&gt;list b))))\n</code>\n", "  (define (xor-char a b)\n    (if\
    \ (eq? a b)\n        #\\0\n        #\\1))\n  (string-map xor-char a b))\n", " \
    \ (string-append (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string-ref x 0)) (string-&gt;number (string-ref x 1))))) (map list (string-&gt;list\
    \ a) (string-&gt;list b)))))\n", "  (string-append\n   (map (lambda (x) (if (equal?\
    \ (car x) (cadr x)) \"0\" \"1\"))\n        (zip (string->list a) (string->list\
    \ b)))))\n", "  (define (xor-char a b)\n    (if (equal? a b) #\\0 #\\1))\n  (string-map\
    \ xor-char a b))\n", "  (string-append\n   (map (lambda (x) (if (equal? (car x)\
    \ (cadr x)) \"0\" \"1\"))\n        (map list a b))))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                               (string-&gt;number\
    \ (string-ref b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=?\
    \ a #\\1) (if (char=? b #\\0) #\\1 #\\0)]))\n  (string-map xor-char a b))\n",
  "  (string-append\n   (map (lambda (x) (number->string (logxor (string-&gt;number\
    \ (string x))\n                                            (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n        (string-&gt;list a))))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                               (string-&gt;number\
    \ (string-ref b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x)) (string->number (string x)))))\n        (string-&gt;list a))\n \
    \  \"\"))\n", "  (string-append (map (lambda (x) (number->string (xor (string-&gt;number\
    \ (string x))\n                                                      (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n                      (string-&gt;list\
    \ a))))\n</code>\nI am not sure if this is the most elegant way to do this, but\
    \ it works.\n", "  (string-join (map (lambda (x y) (number->string (bitwise-xor\
    \ (string->number x) (string->number y)))) (string-&gt;list a) (string-&gt;list\
    \ b))))\n", "  (string-append\n   (map (lambda (x) (if (eq? x #\\0) #\\1 #\\0))\n\
    \        (string-zip a b))))\n", "  (string-append\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \                   (string-&gt;number (string x)))))\n        (string-&gt;list\
    \ a))))\n</code>\nThis works fine for inputs of length 1, but for longer inputs\
    \ I get the error:\n<code>string_xor: expects type &lt;string&gt; as 1st argument,\
    \ given: #&lt;procedure:string-&gt;number&gt;\n</code>\nI'm not sure why this\
    \ is happening. I'm also not sure if this is the best way to do this.\n\n\nA:\n\
    \nThe problem is that <code>map</code> is returning a list of strings, and you're\
    \ trying to append them to a string.\nYou can use <code>apply string-append</code>\
    \ to concatenate the list of strings into a single string.\n<code>(define (string-xor\
    \ a b)\n  (apply string-append\n         (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \            (string-&gt;number (string x)))))\n              (string-&gt;list\
    \ a))))\n</code>\n", "  (define (xor-char a b)\n    (cond\n      [(char=? a #\\\
    0) b]\n      [(char=? a #\\1) (if (char=? b #\\0) #\\1 #\\0)]))\n  (string-map\
    \ xor-char a b))\n", "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list a))\n   (map\
    \ (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list b))))\n</code>\n", "  (define (xor-char a b)\n    (if\
    \ (equal? a b)\n        #\\0\n        #\\1))\n  (define (xor-string a b)\n   \
    \ (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n     \
    \              (xor-string (substring a 1) (substring b 1))))\n  (if (or (empty?\
    \ a) (empty? b))\n      \"\"\n      (xor-string a b)))\n", "  (string-join\n \
    \  (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\n\
    \                                                 (string->number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\n\
    \                                                 (string->number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (define\
    \ (xor-string a b)\n    (if (or (equal? a \"\") (equal? b \"\"))\n        \"\"\
    \n        (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n\
    \                       (xor-string (substring a 1) (substring b 1)))))\n  (xor-string\
    \ a b))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x))\n                                              \
    \   (string->number (string (string-ref b (string-index x a)))))))\n        (string-&gt;list\
    \ a))\n   \"\"))\n", "  (string-join\n   (map (lambda (x) (number->string x))\n\
    \        (map (lambda (x y) (bitwise-xor x y))\n             (map string-&gt;number\
    \ (string-&gt;list a))\n             (map string-&gt;number (string-&gt;list b))))))\n",
  "  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\") a]\n    [else (string-append\
    \ (string_xor (substring a 1) (substring b 1))\n                        (string\
    \ (bitwise-xor (string-&gt;number (substring a 0 1))\n                       \
    \                      (string-&gt;number (substring b 0 1)))))]))\n", "  (string-join\
    \ (map (lambda (x y) (number->string (bitwise-xor (string->number x) (string->number\
    \ y)))) (string-&gt;list a) (string-&gt;list b))))\n", "  (string-append\n   (map\
    \ (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\n        (map list a\
    \ b))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string-append\
    \ (string_xor (rest a) (rest b))\n                         (string (bitwise-xor\
    \ (string->number (string (first a)))\n                                      \
    \        (string->number (string (first b))))))]))\n", "  (string-append\n   (map\
    \ (lambda (x) (string (logxor (string-&gt;number (string x))\n               \
    \                    (string-&gt;number (string (string-ref b (string-index x\
    \ a)))))))\n        a)))\n", "  (string-append\n   (map\n    (lambda (x)\n   \
    \   (if (equal? (car x) (cadr x))\n          \"0\"\n          \"1\"))\n    (list-ec\
    \ (string->list a) (string->list b)))))\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string x))\n          \
    \                                       (string-&gt;number (string x)))))\n  \
    \      (string-&gt;list a))))\n</code>\nI'm getting an error:\n<code>string_xor:\
    \ expects type &lt;string&gt; as 2nd argument, given: #&lt;procedure:string-&gt;number&gt;;\
    \ other arguments were: \"101\"\n</code>\nI'm not sure what I'm doing wrong.\n\
    \n\nA:\n\nYou're calling <code>string-&gt;number</code> twice, and the second\
    \ time you're passing it the procedure itself, not the result of calling it.\n\
    Also, you're using <code>string-&gt;list</code> to convert the string to a list\
    \ of characters, but then you're using <code>string</code> to convert each character\
    \ back to a string.\nThis should work:\n<code>(define (string-xor a b)\n  (string-append\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x))\n                                                 (string-&gt;number (string\
    \ x)))))\n        (string-&gt;list a))))\n</code>\n", "  (string-append\n   (map\
    \ (lambda (x) (string (logxor (char->integer (car x)) (char->integer (cadr x)))))\n\
    \        (zip (string->list a) (string->list b)))))\n", "  (let ([a (string->list\
    \ a)]\n        [b (string->list b)])\n    (string-join (map (lambda (x y)\n  \
    \                      (if (equal? x y) \"0\" \"1\"))\n                      a\
    \ b))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n    \
    \ (cons (xor (first a) (first b))\n           (string_xor (rest a) (rest b)))]))\n",
  "  (define (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n\
    \  (string-map xor-char a b))\n", "  (define (xor-char a b)\n    (cond\n     \
    \ [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=? b #\\0) #\\1 #\\0)]))\n\
    \  (define (xor-string a b)\n    (if (string=? a \"\")\n        \"\"\n       \
    \ (string-append (xor-char (string-ref a 0) (string-ref b 0))\n              \
    \         (xor-string (substring a 1) (substring b 1)))))\n  (xor-string a b))\n",
  "  (define (xor-char a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\\
    1)\n          ((and (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\\
    0)))\n  (define (xor-string a b)\n    (cond ((and (string=? a \"\") (string=?\
    \ b \"\")) \"\")\n          (else (string-append (list (xor-char (string-ref a\
    \ 0) (string-ref b 0)))\n                               (xor-string (substring\
    \ a 1) (substring b 1))))))\n  (xor-string a b))\n", "  (string-append (map (lambda\
    \ (x) (if (equal? x '0) #\\1 #\\0)) (string-zip a b))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string x)))))\n        (string-&gt;list a))\n   \"\"))\n",
  "  (let loop ([a (string->list a)]\n             [b (string->list b)]\n        \
    \     [result '()])\n    (cond [(empty? a) (list->string (reverse result))]\n\
    \          [(empty? b) (list->string (reverse result))]\n          [else (loop\
    \ (rest a)\n                      (rest b)\n                      (cons (if (equal?\
    \ (first a) (first b))\n                                #\\0\n               \
    \                 #\\1)\n                            result))])))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\
    \ (string-&gt;number (string x)))))\n        (string-&gt;list a))\n   (map (lambda\
    \ (x) (number-&gt;string (bitwise-xor (string-&gt;number (string x)) (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list b))))\n</code>\n", "  (define (xor-char\
    \ a b)\n    (string-&gt;number (number-&gt;string (bitwise-xor (string-&gt;number\
    \ (string a)) (string-&gt;number (string b))))))\n  (if (string=? a \"\")\n  \
    \    b\n      (if (string=? b \"\")\n          a\n          (string-append (string\
    \ (xor-char (substring a 0 1) (substring b 0 1))) (string_xor (substring a 1)\
    \ (substring b 1))))))\n</code>\nI'm not sure if this is the most elegant solution,\
    \ but it works.\n", "  (let ((a (string->list a))\n        (b (string->list b)))\n\
    \    (string-join (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\
    \ (list a b)) \"\")))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n \
    \   [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n", "  (string-append\n\
    \   (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\n        (zip\
    \ (string->list a) (string->list b)))))\n", "  (define (xor-char a b)\n    (cond\n\
    \      ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n      ((and (char=? a #\\\
    0) (char=? b #\\0)) #\\0)\n      (else #\\1)))\n  (define (xor-string a b)\n \
    \   (string-append (list (xor-char (string-ref a 0) (string-ref b 0)))\n     \
    \              (xor-string (substring a 1) (substring b 1))))\n  (cond\n    ((string=?\
    \ a \"\") b)\n    ((string=? b \"\") a)\n    (else (xor-string a b))))\n", " \
    \ (define (xor-char a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=?\
    \ a #\\1) (if (char=? b #\\0) #\\1 #\\0)]))\n  (apply string (map xor-char (string->list\
    \ a) (string->list b))))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x)) (string->number (string x)))))\n  \
    \      (string-&gt;list a))\n   \"\"))\n", "  (string-append\n   (map (lambda\
    \ (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\n        (map list a b))))\n",
  "  (string-append\n   (map (lambda (x) (number->string (logxor (string-&gt;number\
    \ (string x))\n                                            (string-&gt;number\
    \ (string (cdr x))))))\n        (zip (string-&gt;list a) (string-&gt;list b)))))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string_xor (substring a 1) (substring b 1))\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0)))))]))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n", "  (define\
    \ (xor a b)\n    (if (or (and (eq? a #\\1) (eq? b #\\0))\n            (and (eq?\
    \ a #\\0) (eq? b #\\1)))\n        #\\1\n        #\\0))\n  (string-map xor a b))\n",
  "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x))\n                                                 (string-&gt;number\
    \ (string x)))))\n        (string-&gt;list a))))\n</code>\nThis is the error I\
    \ get:\n<code>string_xor: expects argument of type &lt;string&gt;; given \"1\"\
    \n</code>\nI'm not sure why this is happening. I'm new to Racket so I'm not sure\
    \ if I'm missing something obvious.\n\n\nA:\n\nThe problem is that you're using\
    \ <code>string-&gt;number</code> on a single character, which is not a valid number.\
    \ You can use <code>string-&gt;number</code> on a string of digits, but not on\
    \ a single digit.\nYou can fix it by using <code>char-&gt;integer</code> instead:\n\
    <code>(define (string_xor a b)\n  (string-append\n   (map (lambda (x) (number-&gt;string\
    \ (bitwise-xor (char-&gt;integer x)\n                                        \
    \         (char-&gt;integer x))))\n        (string-&gt;list a))))\n</code>\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n", "  (string-append\n   (map (lambda (x) (string\
    \ (logxor (string-&gt;number (string x))\n                                   (string-&gt;number\
    \ (string (string-ref b (string-index x a)))))))\n        a)))\n", "  (let ([a\
    \ (string->list a)]\n        [b (string->list b)])\n    (string-join (map (lambda\
    \ (x y) (if (equal? x y) \"0\" \"1\")) a b))))\n", "  (let ([a (string->list a)]\n\
    \        [b (string->list b)])\n    (string-join\n     (map (lambda (x) (if (equal?\
    \ (car x) (cadr x)) \"0\" \"1\"))\n          (map list a b)))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string (cdr x))))))\n        (zip (string-&gt;list a) (string-&gt;list\
    \ b)))\n   \"\"))\n", "  (string-join (map (\u03BB (x) (number->string (bitwise-xor\
    \ (string->number (string x)) (string->number (string x))))) (string-&gt;list\
    \ a)) \"\"))\n", "  (string-append (map (lambda (x) (if (equal? x '1) '0 '1))\
    \ (string-intersect a b))\n                 (string-union a b)))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (let ([a (string->list a)]\n        [b (string->list b)])\n    (string-join (map\
    \ (lambda (x y) (if (equal? x y) #\\0 #\\1)) a b))))\n", "  (string-append\n \
    \  (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\n        (zip\
    \ (string->list a) (string->list b)))))\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string x))\n          \
    \                                       (string-&gt;number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1)))))\n        (map list (string->list\
    \ a) (string->list b)))\n   \"\"))\n", "  (define (xor-char a b)\n    (cond ((and\
    \ (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and (char=? a #\\0) (char=?\
    \ b #\\1)) #\\1)\n          (else #\\0)))\n  (string-map xor-char a b))\n", " \
    \ (string-join (map (lambda (x y) (if (equal? x y) #\"0\" #\"1\")) a b)))\n",
  "  (define (xor-char a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\\
    1)\n          ((and (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\\
    0)))\n  (define (xor-string a b)\n    (cond ((and (string=? a \"\") (string=?\
    \ b \"\")) \"\")\n          (else (string-append (xor-char (string-ref a 0) (string-ref\
    \ b 0))\n                               (xor-string (substring a 1) (substring\
    \ b 1))))))\n  (xor-string a b))\n", "  (define (xor-char a b)\n    (cond ((and\
    \ (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and (char=? a #\\0) (char=?\
    \ b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string a b)\n    (if\
    \ (or (string-null? a) (string-null? b))\n        \"\"\n        (string-append\
    \ (xor-char (string-ref a 0) (string-ref b 0))\n                       (xor-string\
    \ (string-drop a 1) (string-drop b 1)))))\n  (xor-string a b))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x))\n                                                 (string->number\
    \ (string (string-ref b (string-index x a)))))))\n        (string-&gt;list a))\n\
    \   \"\"))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x)) (string->number (string (string-ref b (string-index\
    \ x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (define (xor-char\
    \ a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (define (xor-string\
    \ a b)\n    (string-append\n     (list (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n     (xor-string (substring a 1) (substring b 1))))\n  (if (equal? (string-length\
    \ a) (string-length b))\n      (xor-string a b)\n      (error \"Strings are not\
    \ of equal length\")))\n", "  (string-append (map (lambda (x) (if (equal? (car\
    \ x) (cadr x)) \"0\" \"1\")) (zip (string->list a) (string->list b)))))\n", " \
    \ (string-append (map (lambda (x) (if (equal? x #\\1) #\\0 #\\1))\n          \
    \            (string-zip a b))))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x)) (string->number (string x)))))\n  \
    \      (string-&gt;list a))\n   \"\"))\n", "  (string-append\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string-&gt;number (string-ref x 0)) (string-&gt;number\
    \ (string-ref x 1)))))\n        (map list (string-&gt;list a) (string-&gt;list\
    \ b)))))\n", "  (define (xor_char a b)\n    (if (equal? a b)\n        #\\0\n \
    \       #\\1))\n  (string-map xor_char a b))\n", "  (cond\n    [(empty? a) b]\n\
    \    [(empty? b) a]\n    [else (cons (xor (first a) (first b)) (string_xor (rest\
    \ a) (rest b)))]))\n", "  (define (xor a b)\n    (cond ((and (eq? a 0) (eq? b\
    \ 0)) 0)\n          ((and (eq? a 1) (eq? b 1)) 0)\n          (else 1)))\n  (define\
    \ (xor-string a b)\n    (if (eq? (string-length a) 0)\n        \"\"\n        (string-append\
    \ (string (xor (string-ref a 0) (string-ref b 0)))\n                       (xor-string\
    \ (substring a 1) (substring b 1)))))\n  (xor-string a b))\n", "  (if (or (empty?\
    \ a) (empty? b))\n      \"\"\n      (string (bitwise-xor (string-&gt;number (string-ref\
    \ a 0))\n                           (string-&gt;number (string-ref b 0))))\n \
    \     (string_xor (substring a 1) (substring b 1))))\n</code>\n", "  (define (xor-char\
    \ a b)\n    (cond\n      [(char=? a #\\0) (if (char=? b #\\0) #\\0 #\\1)]\n  \
    \    [(char=? a #\\1) (if (char=? b #\\1) #\\0 #\\1)]))\n  (define (xor-string\
    \ a b)\n    (if (string=? a \"\")\n        \"\"\n        (string-append (string\
    \ (xor-char (string-ref a 0) (string-ref b 0)))\n                       (xor-string\
    \ (substring a 1) (substring b 1)))))\n  (xor-string a b))\n", "  (define (xor-char\
    \ a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=?\
    \ b #\\0) #\\1 #\\0)]))\n  (string-map xor-char a b))\n", "  (string-append (map\
    \ (lambda (x) (number->string (bitwise-xor (string-&gt;number (string-ref x 0))\
    \ (string-&gt;number (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list\
    \ b)))))\n", "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list a))\n   (map\
    \ (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list b))))\n</code>\n", "  (define (char_xor a b)\n    (cond\n\
    \      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=? b #\\0) #\\1 #\\\
    0)]))\n  (string-map char_xor a b))\n", "  (string-append\n   (map (lambda (x)\
    \ (number->string (bitwise-xor (string-&gt;number (string x))\n              \
    \                                   (string-&gt;number (string x)))))\n      \
    \  (string-&gt;list a))))\n</code>\nThe problem is that when I run this code,\
    \ I get the following error:\n<code>string_xor: expects type &lt;string&gt; as\
    \ 1st argument, given: \"101\"\n</code>\nI'm not sure what I'm doing wrong here.\
    \ I'm using Racket version 6.1.\n\n\nA:\n\nThe problem is that <code>string-&gt;number</code>\
    \ expects a string of digits, not a string of bits. You can use <code>string-&gt;list</code>\
    \ to get the individual characters, then <code>string-&gt;number</code> to convert\
    \ each character to a number.\n<code>(define (string-xor a b)\n  (string-append\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x))\n                                                 (string-&gt;number (string\
    \ x)))))\n        (string-&gt;list a))))\n</code>\n", "  (string-join\n   (map\
    \ (lambda (x) (number->string (bitwise-xor (string->number (string x)) (string->number\
    \ (string x)))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-append\n\
    \   (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"))\n        (list-tabulate\
    \ (string-length a) (lambda (i) (list (string-ref a i) (string-ref b i)))))))\n",
  "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x)) (string-&gt;number (string x)))))\n        (string-&gt;list a))\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x)) (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n\
    I'm not sure if this is the best way to do it, but it works.\n", "  (string-join\
    \ (map (lambda (x y) (number->string (logxor x y)))\n                   (string-&gt;list\
    \ a)\n                   (string-&gt;list b))))\n", "  (string-join\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string x)) (string->number\
    \ (string x)))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x))\
    \ (string->number (string x)))))\n        (string-&gt;list (string-append a b)))\n\
    \   \"\"))\n</code>\n", "  (string-append (map (lambda (x) (if (equal? x #\\1)\
    \ #\\0 #\\1)) a)\n                 (map (lambda (x) (if (equal? x #\\1) #\\0 #\\\
    1)) b)))\n", "  (let ([a (string->list a)]\n        [b (string->list b)])\n  \
    \  (string-join (map (lambda (x y)\n                        (if (equal? x y)\n\
    \                            #\\0\n                            #\\1))\n      \
    \                a b))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n",
  "  (string-append\n   (map (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\"\
    ))\n        (zip (string->list a) (string->list b)))))\n", "  (string-append (map\
    \ (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (zip (string->list a)\
    \ (string->list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string (string-ref\
    \ b (string-index x a)))))))\n        (string-&gt;list a))))\n", "  (define (xor\
    \ a b)\n    (if (or (and (eq? a 0) (eq? b 1))\n            (and (eq? a 1) (eq?\
    \ b 0)))\n        1\n        0))\n  (define (xor-string a b)\n    (if (eq? (string-length\
    \ a) 0)\n        \"\"\n        (string-append (string (xor (string-ref a 0) (string-ref\
    \ b 0)))\n                       (xor-string (substring a 1) (substring b 1)))))\n\
    \  (xor-string a b))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x)) (string->number (string x)))))\n  \
    \      (string-&gt;list a))\n   \"\"))\n", "  (define (xor-char a b)\n    (if\
    \ (equal? a b)\n        #\\0\n        #\\1))\n  (string-map xor-char a b))\n",
  "  (string-append (map (lambda (x) (number->string (xor (string-&gt;number (string-ref\
    \ x 0)) (string-&gt;number (string-ref x 1))))) (map list (string-&gt;list a)\
    \ (string-&gt;list b)))))\n", "  (string-append (map (lambda (x) (if (equal? (car\
    \ x) (cadr x)) \"0\" \"1\")) (list-tabulate (string-length a) (lambda (i) (list\
    \ (string-ref a i) (string-ref b i)))))))\n", "  (string-join (map (lambda (x\
    \ y) (if (equal? x y) \"0\" \"1\"))\n                    (string->list a)\n  \
    \                  (string->list b))\n               \"\"))\n", "  (define (xor-char\
    \ a b)\n    (if (char=? a b)\n        #\\0\n        #\\1))\n  (string-map xor-char\
    \ a b))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x)) (string->number (string x)))))\n        (string-&gt;list\
    \ (string-append a b)))\n   \"\"))\n</code>\nI'm not sure if this is the most\
    \ elegant way to do this, but it works.\n", "  (string-join\n   (map (lambda (x)\
    \ (number->string (bitwise-xor (string->number (string x))\n                 \
    \                                (string->number (string (string-ref b (string-index\
    \ x a)))))))\n        (string-&gt;list a))\n   \"\"))\n", "  (string-append\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number (string x))\
    \ (string-&gt;number (string (string-ref b (string-index x a)))))))\n        (string-&gt;list\
    \ a))))\n", "  (string-append\n   (map\n    (lambda (x)\n      (if (equal? (car\
    \ x) (cadr x))\n          \"0\"\n          \"1\"))\n    (list-ec a b))))\n", " \
    \ (string-append\n   (map (lambda (x) (number->string (bitwise-xor (string-&gt;number\
    \ (string x)) (string-&gt;number (string x)))))\n        (string-&gt;list a))\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x)) (string-&gt;number (string x)))))\n        (string-&gt;list b))))\n</code>\n\
    This is the error I get:\n<code>string_xor.rkt:6:0: string_xor: unbound identifier\
    \ in module in: string_xor\n</code>\nI am not sure what I am doing wrong. I am\
    \ new to Racket.\n\n\nA:\n\nYou have a typo in the name of the function <code>string-&gt;number</code>.\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x))\n                                                 (string->number\
    \ (string (string-ref b (string-index x a)))))))\n        (string-&gt;list a))\n\
    \   \"\"))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x))\n                                              \
    \   (string->number (string (string-ref b (string-index x a)))))))\n        (string-&gt;list\
    \ a))\n   \"\"))\n", "  (string-append\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string-&gt;number (string x))\n                                           \
    \      (string-&gt;number (string x)))))\n        (string-&gt;list a))\n   (map\
    \ (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string x))\n\
    \                                                 (string-&gt;number (string x)))))\n\
    \        (string-&gt;list b))))\n</code>\nThis is the error I get:\n<code>string_xor:\
    \ expects type &lt;string&gt; as 1st argument, given: #&lt;procedure:...&gt;;\
    \ other arguments were: \"1\"\n</code>\nI don't understand what is wrong with\
    \ my code.\n\n\nA:\n\nThe error message is telling you that the first argument\
    \ to <code>string_xor</code> is a procedure, not a string.  You can see this if\
    \ you look at the code you wrote:\n<code>(define (string_xor a b)\n  (string-append\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (string\
    \ x))\n                                                 (string-&gt;number (string\
    \ x)))))\n        (string-&gt;list a))\n   (map (lambda (x) (number-&gt;string\
    \ (bitwise-xor (string-&gt;number (string x))\n                              \
    \                   (string-&gt;number (string x)))))\n        (string-&gt;list\
    \ b))))\n</code>\nThe first argument to <code>map</code> is a procedure, and you're\
    \ calling <code>map</code> twice.  So, the first argument to <code>string_xor</code>\
    \ is the result of calling <code>map</code> twice.  That's a procedure, not a\
    \ string.\nThe solution is to call <code>map</code> once, and pass the result\
    \ to <code>string-append</code>.  You can do that by using <code>append</code>\
    \ to combine the two lists of strings into one list, and", "  (define (xor-char\
    \ a b)\n    (cond ((and (char=? a #\\1) (char=? b #\\0)) #\\1)\n          ((and\
    \ (char=? a #\\0) (char=? b #\\1)) #\\1)\n          (else #\\0)))\n  (define (xor-string\
    \ a b)\n    (cond ((and (string=? a \"\") (string=? b \"\")) \"\")\n         \
    \ (else (string-append (list (xor-char (string-ref a 0) (string-ref b 0)))\n \
    \                              (xor-string (substring a 1) (substring b 1))))))\n\
    \  (xor-string a b))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
