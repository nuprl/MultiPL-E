name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (round value))\n", "  (cond [(string=? value \"\") 0]\n        [(string=?\
    \ value \".\") 0]\n        [(string=? value \"-\") 0]\n        [(string=? value\
    \ \"-.\") 0]\n        [else (round (string->number value))]))\n", "  (cond\n \
    \   [(string=? value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=?\
    \ value \"0.00\") 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value\
    \ \"0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n    [(string=? value \"\
    0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"\
    0.00000000\") 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value\
    \ \"0.0000000000\") 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\") 0]\n\
    \    [(string=? value \"0.00000000000000\") 0]\n    [(string=? value \"0.000000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"\
    0.00000000000000000\") 0]\n    [(string=? value \"0.000000000000000000\") 0]\n\
    \    [(string=? value \"0.0000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.0000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000000\") 0]", "  (if\
    \ (negative? value)\n      (round (add1 value))\n      (round value)))\n", " \
    \ (cond\n    [(< value 0) (round (- value))]\n    [else (round value)]))\n", " \
    \ (cond\n    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n\
    \    [else 0]))\n", "  (let* ([value (string->number value)]\n         [int (inexact->exact\
    \ (round value))])\n    (if (and (integer? value) (zero? (remainder value 1)))\n\
    \        value\n        int)))\n", "  (cond\n    [(< value 0) (round value -1)]\n\
    \    [(> value 0) (round value 1)]\n    [else 0]))\n", "  (cond\n    [(< value\
    \ 0) (round (- value))]\n    [else (round value)]))\n", "  (if (not (string? value))\n\
    \      (error \"closest_integer: value must be a string\")\n      (let* ([v (string->number\
    \ value)]\n             [i (inexact->exact (round v))])\n        (if (and (integer?\
    \ i)\n                 (not (zero? (round (sub1 v)))))\n            i\n      \
    \      (round v)))))\n", "  (cond\n    [(= (modulo (string->number value) 1) 0)\
    \ (string->number value)]\n    [(> (modulo (string->number value) 1) 0) (string->number\
    \ (number->string (ceiling (string->number value))))]\n    [(< (modulo (string->number\
    \ value) 1) 0) (string->number (number->string (floor (string->number value))))]))\n",
  "  (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (cond\n    [(< value 0) (round (- value))]\n    [else (round value)]))\n", " \
    \ (round value))\n", "  (cond\n    [(= (modulo (string->number value) 1) 0) (string->number\
    \ value)]\n    [(> (modulo (string->number value) 1) 0) (round (string->number\
    \ value))]\n    [(< (modulo (string->number value) 1) 0) (round (string->number\
    \ value))]))\n", "  (round value))\n", "  (if (negative? value)\n      (round\
    \ (add1 value))\n      (round value)))\n", "  (cond\n    [(< value 0) (floor value)]\n\
    \    [(> value 0) (ceiling value)]\n    [else 0]))\n", "  (let ([v (string->number\
    \ value)])\n    (if (negative? v)\n        (- (round v))\n        (round v))))\n",
  "  (define (closest-integer-helper value)\n    (if (integer? value)\n        value\n\
    \        (if (positive? value)\n            (closest-integer-helper (+ value 1))\n\
    \            (closest-integer-helper (- value 1)))))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (cond\n    [(string=? value \"\") 0]\n    [(string=?\
    \ value \".\") 0]\n    [(string=? value \"-\") 0]\n    [(string=? value \"-.\"\
    ) 0]\n    [(string=? value \"0\") 0]\n    [(string=? value \"0.\") 0]\n    [(string=?\
    \ value \"-0\") 0]\n    [(string=? value \"-0.\") 0]\n    [(string=? value \"\
    0.0\") 0]\n    [(string=? value \"-0.0\") 0]\n    [(string=? value \"0.00\") 0]\n\
    \    [(string=? value \"-0.00\") 0]\n    [(string=? value \"0.000\") 0]\n    [(string=?\
    \ value \"-0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n    [(string=? value\
    \ \"-0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n    [(string=? value\
    \ \"-0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n    [(string=? value\
    \ \"-0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n    [(string=? value\
    \ \"-0.0000000\") 0]\n    [(string=? value \"0.00000000\") 0]\n    [(string=?\
    \ value \"-0.00000000\") 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=?\
    \ value \"-0.000000000\") 0]\n    [(string=? value \"0.0000000000\") 0]\n    [(string=?\
    \ value \"-0.0000000000\") 0]\n    [(string=? value \"0.00000000000\") 0]\n  \
    \  [(string=? value \"-0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"-0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"-0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"-0.00000000000000\") 0]\n    [(string=? value \"\
    0.000000000000000", "  (cond\n    [(= (remainder value 1) 0) (round value)]\n\
    \    [(> (remainder value 1) 0) (round (+ value 1))]\n    [(< (remainder value\
    \ 1) 0) (round (+ value -1))]))\n", "  (cond\n    [(< value 0) (round value -1)]\n\
    \    [(> value 0) (round value 1)]\n    [else 0]))\n", "  (cond\n    [(< value\
    \ 0) (round value -1)]\n    [(> value 0) (round value 1)]\n    [else 0]))\n",
  "  (round value))\n", "  (let ([value (string->number value)])\n    (if (negative?\
    \ value)\n        (- (round (abs value)))\n        (round value))))\n", "  (cond\n\
    \    [(< value 0) (ceiling value)]\n    [(> value 0) (floor value)]\n    [else\
    \ 0]))\n", "  (let ((int-value (string->number value)))\n    (if (negative? int-value)\n\
    \        (round (add1 int-value))\n        (round int-value))))\n", "  (round\
    \ value))\n", "  (cond\n    [(< value 0)\n     (round (add1 value))]\n    [(>\
    \ value 0)\n     (round value)]\n    [else\n     0]))\n", "  (define (closest_integer_iter\
    \ value acc)\n    (if (zero? (modulo value 1))\n        acc\n        (closest_integer_iter\
    \ (add1 value) (add1 acc))))\n  (closest_integer_iter value 0))\n", "  (if (negative?\
    \ value)\n      (round (- value))\n      (round value)))\n", "  (cond\n    [(>\
    \ value 0) (round value)]\n    [(< value 0) (round value)]\n    [else 0]))\n",
  "  (define (closest_integer-iter value acc)\n    (if (negative? value)\n       \
    \ (closest_integer-iter (- value) (- acc))\n        (if (positive? value)\n  \
    \          (closest_integer-iter (- value) (+ acc))\n            acc)))\n  (closest_integer-iter\
    \ value 0))\n", "  (round value))\n", "  (let* ([value (string->number value)]\n\
    \         [floor (floor value)]\n         [ceiling (ceiling value)])\n    (if\
    \ (> (- value floor) (- ceiling value))\n        ceiling\n        floor)))\n",
  "  (if (negative? value)\n      (round (- value))\n      (round value)))\n", " \
    \ (cond\n    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n\
    \    [else 0]))\n", "  (cond\n    [(< (abs (- (string->number value) (floor (string->number\
    \ value))))\n        (abs (- (string->number value) (ceiling (string->number value)))))\n\
    \     (floor (string->number value))]\n    [else (ceiling (string->number value))]))\n",
  "  (let* ([float-value (string->number value)]\n         [int-value (round float-value)])\n\
    \    (if (= float-value int-value)\n        int-value\n        (if (> float-value\
    \ 0)\n            (add1 int-value)\n            (sub1 int-value)))))\n", "  (if\
    \ (and (string? value) (string-&gt;number value))\n      (round (string-&gt;number\
    \ value))\n      (error \"Invalid input\")))\n", "  (cond\n    [(< value 0) (round\
    \ (- value))]\n    [else (round value)]))\n", "  (cond\n    [(= (modulo (string->number\
    \ value) 1) 0)\n     (string->number value)]\n    [(> (modulo (string->number\
    \ value) 1) 0)\n     (round (string->number value))]\n    [(< (modulo (string->number\
    \ value) 1) 0)\n     (round (string->number value))]))\n", "  (if (negative? value)\n\
    \      (round (add1 value))\n      (round value)))\n", "  (if (negative? value)\n\
    \      (round (add1 value))\n      (round value)))\n", "  (let ([int-value (string->number\
    \ value)])\n    (if (negative? int-value)\n        (- (round int-value))\n   \
    \     (round int-value))))\n", "  (cond\n    [(= (modulo (string->number value)\
    \ 1) 0) (string->number value)]\n    [(> (modulo (string->number value) 1) 0)\
    \ (round (string->number value))]\n    [(< (modulo (string->number value) 1) 0)\
    \ (round (string->number value))]))\n", "  (cond\n    [(< value 0) (round (- value))]\n\
    \    [else (round value)]))\n", "  (cond\n    [(< value 0) (round (- value))]\n\
    \    [else (round value)]))\n", "  (cond\n    [(< value 0) (round value -1)]\n\
    \    [(> value 0) (round value 1)]\n    [else 0]))\n", "  (let ([v (string->number\
    \ value)])\n    (if (negative? v)\n        (- (round v))\n        (round v))))\n",
  "  (cond\n    [(< value 0) (round (- value))]\n    [else (round value)]))\n", " \
    \ (let ([value (string->number value)])\n    (if (negative? value)\n        (-\
    \ (round (abs value)))\n        (round value))))\n", "  (if (positive? value)\n\
    \      (round value)\n      (round value)))\n", "  (cond\n    [(> value 0) (round\
    \ value)]\n    [(< value 0) (round value)]\n    [else 0]))\n", "  (if (string=?\
    \ (substring value -1) \".\")\n      (string->number (substring value 0 -1))\n\
    \      (string->number value)))\n", "  (if (negative? value)\n      (round (add1\
    \ (add1 value)))\n      (round (sub1 (sub1 value)))))\n", "  (if (negative? value)\n\
    \      (round (add1 value))\n      (round value)))\n", "  (if (string=? (substring\
    \ value 0 1) \"-\")\n      (string->number (substring value 1))\n      (string->number\
    \ value)))\n", "  (cond\n    [(= (modulo (string->number value) 1) 0) (string->number\
    \ value)]\n    [(> (modulo (string->number value) 1) 0) (round (string->number\
    \ value))]\n    [(< (modulo (string->number value) 1) 0) (round (string->number\
    \ value))]))\n", "  (cond\n    [(< value 0) (round value -1)]\n    [(> value 0)\
    \ (round value 1)]\n    [else 0]))\n", "  (cond\n    [(< value 0) (round (- value))]\n\
    \    [else (round value)]))\n", "  (round value))\n", "  (round value))\n", " \
    \ (round value))\n", "  (round value))\n", "  (cond\n    [(< value 0) (round (-\
    \ value))]\n    [else (round value)]))\n", "  (if (negative? value)\n      (round\
    \ (add1 (add1 value)))\n      (round (sub1 (sub1 value)))))\n", "  (if (negative?\
    \ value)\n      (round (add1 (add1 value)))\n      (round (sub1 (sub1 value)))))\n",
  "  (cond\n    [(= (modulo (string->number value) 1) 0) (string->number value)]\n\
    \    [(> (modulo (string->number value) 1) 0) (round (string->number value))]\n\
    \    [(< (modulo (string->number value) 1) 0) (round (string->number value))]))\n",
  "  (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (round value))\n", "  (cond\n    [(< value 0) (round (add1 value))]\n    [(>\
    \ value 0) (round value)]\n    [else 0]))\n", "  (round value))\n", "  (cond\n\
    \    [(= (modulo (string->number value) 1) 0) (string->number value)]\n    [(>\
    \ (modulo (string->number value) 1) 0) (ceiling (string->number value))]\n   \
    \ [(< (modulo (string->number value) 1) 0) (floor (string->number value))]))\n",
  "  (if (positive? value)\n      (round value)\n      (round value)))\n", "  (round\
    \ value))\n", "  (cond\n    [(< value 0) (round value)]\n    [(> value 0) (round\
    \ value)]\n    [else 0]))\n", "  (cond\n    [(= (remainder value 1) 0) (round\
    \ value)]\n    [(> (remainder value 1) 0) (round (+ value 0.5))]\n    [(< (remainder\
    \ value 1) 0) (round (- value 0.5))]))\n", "  (cond\n    [(= (remainder value\
    \ 1) 0) (round value)]\n    [(> (remainder value 1) 0) (round (+ value 1))]\n\
    \    [(< (remainder value 1) 0) (round (+ value -1))]))\n", "  (let* ([num (string->number\
    \ value)]\n         [int (round num)])\n    (if (and (number? num)\n         \
    \    (number? int))\n        int\n        (error \"Invalid input\"))))\n", " \
    \ (cond\n    [(< value 0) (round (add1 value))]\n    [(> value 0) (round value)]\n\
    \    [else 0]))\n", "  (cond\n    [(< value 0) (round (- value))]\n    [else (round\
    \ value)]))\n", "  (round value))\n", "  (round value))\n", "  (cond\n    [(<\
    \ value 0) (round (- value))]\n    [else (round value)]))\n", "  (cond\n    [(>\
    \ value 0)\n     (round value)]\n    [(< value 0)\n     (round value)]\n    [else\n\
    \     0]))\n", "  (if (string=? (substring value -1) \".\")\n      (string->number\
    \ (substring value 0 -1))\n      (if (string=? (substring value -2) \".5\")\n\
    \          (if (string=? (substring value 0 1) \"-\")\n              (- (string->number\
    \ (substring value 0 -2)) 1)\n              (+ (string->number (substring value\
    \ 0 -2)) 1))\n          (string->number value))))\n", "  (cond\n    [(= (remainder\
    \ value 1) 0) (round value)]\n    [(> (remainder value 1) 0) (round (+ value 0.5))]\n\
    \    [(< (remainder value 1) 0) (round (- value 0.5))]))\n", "  (cond\n    [(=\
    \ (modulo (string->number value) 1) 0) (string->number value)]\n    [(> (modulo\
    \ (string->number value) 1) 0) (ceiling (string->number value))]\n    [(< (modulo\
    \ (string->number value) 1) 0) (floor (string->number value))]))\n", "  (cond\n\
    \    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n    [else\
    \ 0]))\n", "  (cond\n    [(< value 0) (round (add1 value))]\n    [(> value 0)\
    \ (round value)]\n    [else 0]))\n", "  (if (positive? value)\n      (round value)\n\
    \      (round value)))\n", "  (if (negative? value)\n      (round (add1 value))\n\
    \      (round value)))\n", "  (if (negative? value)\n      (round (add1 (add1\
    \ value)))\n      (round (sub1 (sub1 value)))))\n", "  (if (string=? (substring\
    \ value (add1 (string-length value)) (string-length value)) \".\")\n      (string->number\
    \ (substring value 0 (string-length value)))\n      (if (string=? (substring value\
    \ (add1 (string-length value)) (string-length value)) \"5\")\n          (if (string=?\
    \ (substring value 0 1) \"-\")\n              (string->number (substring value\
    \ 0 (string-length value)))\n              (string->number (substring value 0\
    \ (string-length value))))\n          (if (string=? (substring value (add1 (string-length\
    \ value)) (string-length value)) \"0\")\n              (string->number (substring\
    \ value 0 (string-length value)))\n              (if (string=? (substring value\
    \ (add1 (string-length value)) (string-length value)) \"1\")\n               \
    \   (if (string=? (substring value 0 1) \"-\")\n                      (string->number\
    \ (substring value 0 (string-length value)))\n                      (string->number\
    \ (substring value 0 (string-length value))))\n                  (if (string=?\
    \ (substring value (add1 (string-length value)) (string-length value)) \"2\")\n\
    \                      (if (string=? (substring value 0 1) \"-\")\n          \
    \                (string->number (substring value 0 (string-length value)))\n\
    \                          (string->number (substring value 0 (string-length value))))\n\
    \                      (if (string=? (substring value (add1 (string-length value))\
    \ (string-length value)) \"3\")\n                          (if (string=? (substring\
    \ value 0 1) \"-\")\n                              (string->number (substring\
    \ value 0 (string-length value)))\n                              (string->number\
    \ (substring value 0 (string-length value))))\n                          (if (string=?\
    \ (substring value (add1 (string-length value)) (string-length value)) \"4\")\n\
    \                              (if (string=? (substring value 0 1) \"-\")\n  \
    \                                (string->number (substring value 0 (string-length\
    \ value)))\n                                  (string->number (substring value\
    \ 0 (string-length value))))\n                              (if", "  (let* ([value\
    \ (string->number value)]\n         [floor (floor value)]\n         [ceiling (ceiling\
    \ value)])\n    (if (> (- value floor) (- ceiling value))\n        ceiling\n \
    \       floor)))\n", "  (if (positive? value)\n      (round value)\n      (round\
    \ value)))\n", "  (if (negative? value)\n      (round (- value))\n      (round\
    \ value)))\n", "  (round value))\n", "  (if (positive? value)\n      (round value)\n\
    \      (round value)))\n", "  (if (string=? (substring value 0 1) \"-\")\n   \
    \   (string->number (substring value 1))\n      (string->number value)))\n", " \
    \ (cond\n    [(= (remainder value 1) 0) (round value)]\n    [(> (remainder value\
    \ 1) 0) (round (+ value 0.5))]\n    [(< (remainder value 1) 0) (round (- value\
    \ 0.5))]))\n", "  (round value))\n", "  (cond\n    [(= (remainder value 1) 0)\
    \ (round value)]\n    [(> (remainder value 1) 0) (round (+ value 0.5))]\n    [(<\
    \ (remainder value 1) 0) (round (- value 0.5))]))\n", "  (cond\n    [(= (remainder\
    \ value 1) 0) (round value)]\n    [(> (remainder value 1) 0) (round (+ value 1))]\n\
    \    [(< (remainder value 1) 0) (round (+ value -1))]))\n", "  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n", "  (round value))\n", "  (cond\n    [(< value 0) (round\
    \ (- value))]\n    [else (round value)]))\n", "  (if (negative? value)\n     \
    \ (round (add1 value))\n      (round value)))\n", "  (cond\n    [(> value 0) (round\
    \ value)]\n    [(< value 0) (round value)]\n    [else 0]))\n", "  (cond\n    [(<\
    \ value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n    [else 0]))\n",
  "  (if (positive? value)\n      (round value)\n      (round value)))\n", "  (if\
    \ (positive? value)\n      (round value)\n      (round value)))\n", "  (let ([value\
    \ (string->number value)])\n    (cond [(> value 0) (round value)]\n          [(<\
    \ value 0) (round value)]\n          [else 0])))\n", "  (if (negative? value)\n\
    \      (round (add1 value))\n      (round value)))\n", "  (cond\n    [(> value\
    \ 0) (round value)]\n    [(< value 0) (round value)]\n    [else 0]))\n", "  (round\
    \ value))\n", "  (if (and (integer? value) (positive? value))\n      value\n \
    \     (round value)))\n", "  (cond\n    [(< value 0) (floor value)]\n    [(> value\
    \ 0) (ceiling value)]\n    [else 0]))\n", "  (if (positive? value)\n      (round\
    \ value)\n      (round value)))\n", "  (if (negative? value)\n      (round (add1\
    \ (floor value)))\n      (round (sub1 (ceiling value)))))\n", "  (round value))\n",
  "  (cond\n    [(> value 0) (round value)]\n    [(< value 0) (round value)]\n   \
    \ [else 0]))\n", "  (cond\n    [(= (remainder value 1) 0) value]\n    [(> (remainder\
    \ value 1) 0) (round value)]\n    [(< (remainder value 1) 0) (round value)]))\n",
  "  (if (negative? value)\n      (round (add1 value))\n      (round value)))\n</code>\n",
  "  (cond\n    [(< value 0) (- (round value))]\n    [else (round value)]))\n", " \
    \ (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (cond\n    [(= (remainder value 1) 0) (round value)]\n    [(> (remainder value\
    \ 1) 0) (round value)]\n    [(< (remainder value 1) 0) (round value)]))\n", " \
    \ (cond\n    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n\
    \    [else 0]))\n", "  (cond\n    [(< value 0) (- (round value))]\n    [else (round\
    \ value)]))\n", "  (cond\n    [(< value 0) (round (add1 value))]\n    [(> value\
    \ 0) (round value)]\n    [else 0]))\n", "  (if (negative? value)\n      (round\
    \ (add1 value))\n      (round value)))\n", "  (round value))\n", "  (if (not (string?\
    \ value))\n      (error \"closest_integer: value must be a string\"))\n  (let\
    \ ([num (string->number value)])\n    (if (not (number? num))\n        (error\
    \ \"closest_integer: value must be a string representing a number\"))\n    (if\
    \ (negative? num)\n        (round (add1 num))\n        (round num))))\n", "  (let\
    \ ([value (string->number value)])\n    (if (negative? value)\n        (- (round\
    \ value))\n        (round value))))\n", "  (round value))\n", "  (cond\n    [(<\
    \ value 0) (ceiling value)]\n    [(> value 0) (floor value)]\n    [else 0]))\n",
  "  (cond\n    [(< value 0) (round (add1 value))]\n    [(> value 0) (round value)]\n\
    \    [else 0]))\n", "  (cond\n    [(< value 0) (round (- value))]\n    [else (round\
    \ value)]))\n", "  (cond\n    [(> value 0) (ceiling value)]\n    [(< value 0)\
    \ (floor value)]\n    [else 0]))\n", "  (if (not (string? value))\n      (error\
    \ \"closest_integer: value must be a string\")\n      (let ((num (string->number\
    \ value)))\n        (if (integer? num)\n            num\n            (let ((int\
    \ (round num)))\n              (if (and (positive? num)\n                    \
    \   (negative? (- num int)))\n                  (add1 int)\n                 \
    \ int))))))\n", "  (cond\n    [(< value 0) (round (- value))]\n    [else (round\
    \ value)]))\n", "  (let ([num (string->number value)])\n    (if (negative? num)\n\
    \        (- (round (abs num)))\n        (round num))))\n", "  (if (negative? value)\n\
    \      (round (add1 (floor value)))\n      (round (sub1 (ceiling value)))))\n",
  "  (cond\n    [(< value 0) (round (- value) 0)]\n    [else (round value 0)]))\n",
  "  (if (positive? value)\n      (round value)\n      (round value)))\n", "  (cond\n\
    \    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n    [else\
    \ 0]))\n", "  (if (positive? value)\n      (round value)\n      (round value)))\n",
  "  (if (negative? value)\n      (round (- value))\n      (round value)))\n", " \
    \ (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (let ([value (string->number value)])\n    (cond\n      [(< value 0) (floor value)]\n\
    \      [(> value 0) (ceiling value)]\n      [else 0])))\n", "  (round value))\n",
  "  (cond\n    [(= (remainder value 1) 0) (round value)]\n    [(> (remainder value\
    \ 1) 0) (round (+ value 0.5))]\n    [(< (remainder value 1) 0) (round (- value\
    \ 0.5))]))\n", "  (cond\n    [(< value 0) (round (- value))]\n    [else (round\
    \ value)]))\n", "  (round value))\n", "  (cond\n    [(< value 0) (floor value)]\n\
    \    [(> value 0) (ceiling value)]\n    [else 0]))\n", "  (cond\n    [(string=?\
    \ value \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [(string=? value\
    \ \"14.4\") 14]\n    [(string=? value \"-14.4\") -14]\n    [(string=? value \"\
    14.6\") 15]\n    [(string=? value \"-14.6\") -15]\n    [(string=? value \"14.0\"\
    ) 14]\n    [(string=? value \"-14.0\") -14]\n    [(string=? value \"14.1\") 14]\n\
    \    [(string=? value \"-14.1\") -14]\n    [(string=? value \"14.2\") 14]\n  \
    \  [(string=? value \"-14.2\") -14]\n    [(string=? value \"14.3\") 14]\n    [(string=?\
    \ value \"-14.3\") -14]\n    [(string=? value \"14.7\") 15]\n    [(string=? value\
    \ \"-14.7\") -15]\n    [(string=? value \"14.8\") 15]\n    [(string=? value \"\
    -14.8\") -15]\n    [(string=? value \"14.9\") 15]\n    [(string=? value \"-14.9\"\
    ) -15]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"-0.0\") 0]\n\
    \    [(string=? value \"0.1\") 0]\n    [(string=? value \"-0.1\") 0]\n    [(string=?\
    \ value \"0.2\") 0]\n    [(string=? value \"-0.2\") 0]\n    [(string=? value \"\
    0.3\") 0]\n    [(string=? value \"-0.3\") 0]\n    [(string=? value \"0.4\") 0]\n\
    \    [(string=? value \"-0.4\") 0]\n    [(string=? value \"0.5\") 0]\n    [(string=?\
    \ value \"-0.5\") 0]\n    [(string=? value \"0.6\") 0]\n    [(string=? value \"\
    -0.6\") 0]\n    [(string=? value \"0.7\") 0]\n    [(string=? value \"-", "  (cond\n\
    \    [(< value 0) (round (- value))]\n    [else (round value)]))\n", "  (let*\
    \ ([value (string->number value)]\n         [int-value (inexact->exact (floor\
    \ value))]\n         [diff (abs (- value int-value))])\n    (if (> diff 0.5)\n\
    \        (if (> value 0)\n            (add1 int-value)\n            (sub1 int-value))\n\
    \        int-value)))\n", "  (cond [(string=? value \"0\") 0]\n        [(string=?\
    \ value \"0.0\") 0]\n        [(string=? value \"0.00\") 0]\n        [(string=?\
    \ value \"0.000\") 0]\n        [(string=? value \"0.0000\") 0]\n        [(string=?\
    \ value \"0.00000\") 0]\n        [(string=? value \"0.000000\") 0]\n        [(string=?\
    \ value \"0.0000000\") 0]\n        [(string=? value \"0.00000000\") 0]\n     \
    \   [(string=? value \"0.000000000\") 0]\n        [(string=? value \"0.0000000000\"\
    ) 0]\n        [(string=? value \"0.00000000000\") 0]\n        [(string=? value\
    \ \"0.000000000000\") 0]\n        [(string=? value \"0.0000000000000\") 0]\n \
    \       [(string=? value \"0.00000000000000\") 0]\n        [(string=? value \"\
    0.000000000000000\") 0]\n        [(string=? value \"0.0000000000000000\") 0]\n\
    \        [(string=? value \"0.00000000000000000\") 0]\n        [(string=? value\
    \ \"0.000000000000000000\") 0]\n        [(string=? value \"0.0000000000000000000\"\
    ) 0]\n        [(string=? value \"0.00000000000000000000\") 0]\n        [(string=?\
    \ value \"0.000000000000000000000\") 0]\n        [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n        [(string=? value \"0.00000000000000000000000\") 0]\n        [(string=?\
    \ value \"0.000000000000000000000000\") 0]\n        [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n        [(string=? value \"0.00000000000000000000000000\") 0]\n        [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n        [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n        [(string=? value \"0.00000000000000000000000000000\") 0]\n     \
    \   [(string=? value \"0.000000000000000000000000000000\") 0]\n        [(string=?\
    \ value \"0.0000000000000000000000000000000\") 0]\n        [(string=? value \"\
    0.00000000000000000000000000000000\") 0]\n        [(string=? value \"0.000000000000000000000000000000000\"\
    ) 0]\n       ", "  (if (positive? value)\n      (round value)\n      (round value)))\n\
    </code>\nI'm not sure how to handle the equidistant from two integers.\n\n\nA:\n\
    \nThe <code>round</code> function is the right one to use, but you need to use\
    \ it in a different way.\nThe <code>round</code> function takes a number and returns\
    \ the closest integer.\nIf the number is equidistant from two integers, it returns\
    \ the one that is even.\nSo, if you want to round away from zero, you need to\
    \ add <code>0.5</code> to the number before calling <code>round</code>.\n<code>(define\
    \ (closest_integer value)\n  (round (+ value 0.5)))\n</code>\n", "  (let ([int-value\
    \ (string->number value)])\n    (if (negative? int-value)\n        (- (round int-value))\n\
    \        (round int-value))))\n", "  (cond\n    [(= (round value) value) (round\
    \ value)]\n    [(> (round value) value) (round value)]\n    [(< (round value)\
    \ value) (round value)]))\n", "  (if (string-contains? value \".\")\n      (let*\
    \ ([decimal-part (string-split value \".\")]\n             [integer-part (string->number\
    \ (car decimal-part))]\n             [decimal-part (string->number (cadr decimal-part))])\n\
    \        (if (>= decimal-part 0.5)\n            (+ integer-part 1)\n         \
    \   integer-part))\n      (string->number value)))\n", "  (cond\n    [(integer?\
    \ value) value]\n    [(< value 0) (round value)]\n    [(> value 0) (ceiling value)]))\n",
  "  (cond\n    [(> value 0) (round value)]\n    [(< value 0) (round value)]\n   \
    \ [else 0]))\n", "  (define (closest_integer-helper value)\n    (if (and (integer?\
    \ value) (not (zero? value)))\n        value\n        (closest_integer-helper\
    \ (round value))))\n  (closest_integer-helper value))\n", "  (cond\n    [(< value\
    \ 0) (floor value)]\n    [(> value 0) (ceiling value)]\n    [else 0]))\n", " \
    \ (if (positive? value)\n      (round value)\n      (round value)))\n", "  (if\
    \ (negative? value)\n      (round (add1 value))\n      (round value)))\n", " \
    \ (cond\n    [(= (modulo (string->number value) 1) 0) (string->number value)]\n\
    \    [(< (modulo (string->number value) 1) 0.5) (floor (string->number value))]\n\
    \    [else (ceiling (string->number value))]))\n", "  (if (negative? value)\n\
    \      (round (add1 value))\n      (round value)))\n", "  (cond\n    [(> value\
    \ 0) (round value)]\n    [(< value 0) (round value)]\n    [else 0]))\n", "  (cond\n\
    \    [(< value 0) (round (add1 value))]\n    [(> value 0) (round value)]\n   \
    \ [else 0]))\n", "  (round value))\n", "  (let ([v (string->number value)])\n\
    \    (if (negative? v)\n        (- (round v))\n        (round v))))\n", "  (if\
    \ (negative? value)\n      (round (add1 value))\n      (round value)))\n", " \
    \ (if (positive? value)\n      (round value)\n      (round value)))\n", "  (cond\n\
    \    [(= (modulo (string->number value) 1) 0) (string->number value)]\n    [(>\
    \ (modulo (string->number value) 1) 0) (+ (string->number value) 1)]\n    [(<\
    \ (modulo (string->number value) 1) 0) (- (string->number value) 1)]))\n", " \
    \ (cond\n    [(< value 0) (round (- value))]\n    [else (round value)]))\n", " \
    \ (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (if (negative? value)\n      (round (- value))\n      (round value)))\n", " \
    \ (if (positive? value)\n      (round value)\n      (round value)))\n", "  (if\
    \ (negative? value)\n      (round (add1 value))\n      (round value)))\n", " \
    \ (if (negative? value)\n      (round (add1 value))\n      (round value)))\n",
  "  (cond\n    [(= (remainder value 1) 0) (round value)]\n    [(< (remainder value\
    \ 1) 0.5) (round value)]\n    [else (+ (round value) 1)]))\n", "  (cond\n    [(<\
    \ value 0) (round (add1 value))]\n    [(> value 0) (round value)]\n    [else 0]))\n",
  "  (cond\n    [(< value 0) (round (- value))]\n    [else (round value)]))\n", " \
    \ (if (not (string? value))\n      (error \"The value must be a string\"))\n \
    \ (if (not (string-contains value #\\.))\n      (string->number value)\n     \
    \ (let* ([parts (string-split value #\\.)]\n             [int-part (string->number\
    \ (car parts))]\n             [dec-part (string->number (cadr parts))])\n    \
    \    (if (> dec-part 0)\n            (if (= dec-part 5)\n                (if (even?\
    \ int-part)\n                    int-part\n                    (+ int-part 1))\n\
    \                (+ int-part 1))\n            int-part))))\n", "  (cond\n    [(<\
    \ value 0) (ceiling value)]\n    [(> value 0) (floor value)]\n    [else 0]))\n",
  "  (cond\n    [(= (modulo (string->number value) 1) 0) (string->number value)]\n\
    \    [(> (modulo (string->number value) 1) 0) (ceiling (string->number value))]\n\
    \    [(< (modulo (string->number value) 1) 0) (floor (string->number value))]))\n",
  "  (cond\n    [(< value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n\
    \    [else 0]))\n", "  (if (negative? value)\n      (round (add1 value))\n   \
    \   (round value)))\n", "  (cond\n    [(> value 0) (round value)]\n    [(< value\
    \ 0) (round value)]\n    [else 0]))\n", "  (cond\n    [(> value 0) (round value)]\n\
    \    [(< value 0) (round value)]\n    [else 0]))\n", "  (let* ([value (string->number\
    \ value)]\n         [floor (floor value)]\n         [ceiling (ceiling value)])\n\
    \    (if (&lt; (abs (- value floor)) (abs (- value ceiling)))\n        floor\n\
    \        ceiling)))\n", "  (cond\n    [(< value 0) (round value -1)]\n    [(>\
    \ value 0) (round value 1)]\n    [else 0]))\n", "  (cond\n    [(= (remainder value\
    \ 1) 0) (round value)]\n    [(> (remainder value 1) 0) (round (+ value 0.5))]\n\
    \    [(< (remainder value 1) 0) (round (- value 0.5))]))\n", "  (cond\n    [(<\
    \ value 0) (round value -1)]\n    [(> value 0) (round value 1)]\n    [else 0]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
