name: HumanEval_2_truncate_number
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a positive floating point number, it can be decomposed\
  \ into\n    // and integer part (largest integer smaller than given number) and\
  \ decimals\n    // (leftover part always smaller than 1).\n    // Return the decimal\
  \ part of the number.\n    // >>> TruncateNumber((3.5f))\n    // (0.5f)\n    public\
  \ static float TruncateNumber(float number) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(TruncateNumber((3.5f))\
  \ == (0.5f));\n    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));\n    Debug.Assert(TruncateNumber((123.0f))\
  \ == (0.0f));\n    }\n\n}\n"
completions: ["        float fractionalPart;\n        if (number < 0) {\n        \
    \    fractionalPart = -number;\n        }\n        else {\n            fractionalPart\
    \ = number;\n        }\n        int integerPart;\n        while (fractionalPart\
    \ > 1) {\n            fractionalPart /= 10;\n            integerPart++;\n    \
    \    }\n        while (fractionalPart > 0) {\n            fractionalPart /= 10;\n\
    \        }\n        return (float)integerPart;", "        BigInteger bi = BigInteger.Parse(number.ToString());\n\
    \        BigInteger remainder = bi.Remainder(BigInteger.One);\n        float result\
    \ = (float)Math.Truncate(bi.ToString());\n        if (remainder.CompareTo(BigInteger.One)\
    \ < 0) {\n            result += 1;\n        }\n        return result;", "    \
    \    int integerPart = (int)number;\n        int decimalPart = (int)Math.Round(number\
    \ - integerPart);\n\n        return float.Parse(integerPart.ToString().PadLeft(32,\
    \ '0') + (decimalPart % 1).ToString().PadLeft(32, '0'));", "        float fraction\
    \ = number - Math.Floor(number);\n        return fraction;", "        Debug.Assert(number\
    \ >= 0);\n        // Get an integer part\n        long integer = long.MaxValue;\n\
    \        while (true) {\n            float floored = System.Math.Round(number);\n\
    \            if (floored == number) {\n                integer = (long) (floored\
    \ - 0.5f);\n                break;\n            }\n            int flooredAsInt\
    \ = Convert.ToInt32(floored);\n            if (flooredAsInt < integer)\n     \
    \           integer = flooredAsInt;\n            else\n                number\
    \ = floored;\n        }\n        // Get the decimal part\n        long fraction\
    \ = long.MaxValue;\n        while (true) {\n            float floored = System.Math.Round(number\
    \ * 10m);\n            if (floored == number) {\n                fraction = (long)\
    \ (floored - 0.5f);\n                break;\n            }\n            int flooredAsInt\
    \ = Convert.ToInt32(floored);\n            if (flooredAsInt < fraction)\n    \
    \            fraction = flooredAsInt;\n            else\n                number\
    \ = floored;\n        }\n        return (float) integer / 10m + (float) fraction\
    \ / 10m;", "        float integerPart = (float)number * 100;\n        int decimals\
    \ = (int)((number - integerPart) * 100f);\n        return integerPart + (decimals\
    \ / 100f);", "        int integerPart = (int) (number + 0.5);\n        int decimalPart\
    \ = (int) (number - integerPart);\n\n        return (float) decimalPart;", " \
    \       // Get the integer part\n        float truncatedNumber = number;\n   \
    \     int integerPart = (int)truncatedNumber;\n        // Get the remainder\n\
    \        truncatedNumber = truncatedNumber - integerPart;\n        // Calculate\
    \ the decimal part\n        float decimalPart = truncatedNumber / 1;\n       \
    \ // Return the result\n        return decimalPart;", "        float rounded =\
    \ Math.Round(number, 0);\n        int integerPart = (int)rounded;\n        int\
    \ decimalsPart = (rounded - integerPart) * 10;\n        return (float)(decimalsPart\
    \ / 10);", "        // return number.Truncate();\n        float intPart = (float)((int)(number\
    \ * Math.Pow(10f, -9)));\n        float decimalPart = (float)(number - intPart);\n\
    \        return (float)decimalPart;", "        float result;\n        long integerPart\
    \ = Convert.ToInt64(Math.Truncate(number));\n        float decimalPart = number\
    \ - integerPart;\n        // Return decimalPart as the truncated number.\n   \
    \     result = float.Parse(decimalPart.ToString());\n        return result;",
  "        BigInteger bi = new BigInteger(number.ToString());\n        int integer\
    \ = bi.IntValue;\n        decimal d = bi.DivRem(new BigInteger(1), 10);\n    \
    \    float result = d.Value / 10;\n        return result;", "        int integerPart\
    \ = (int)number;\n        float decimalPart = number - integerPart;\n        return\
    \ decimalPart;", "        int integerPart = (int)number;\n        float fractionPart\
    \ = number - integerPart;\n        return fractionPart;", "        float remainder\
    \ = number;\n        int decimalPart = 0;\n        while (number >= 1) {\n   \
    \         number /= 10;\n            decimalPart++;\n        }\n        return\
    \ remainder + decimalPart * 0.1f;", "        // Find largest integer smaller than\
    \ the given number\n        var intPart = (int) Math.Floor(number);\n\n      \
    \  // Find any remaining decimal part of the number after the integer\n      \
    \  // part\n        var decimalPart = number - intPart;\n\n        // Return the\
    \ float of the integer part and decimal part of the number\n        return float.Parse(\"\
    0.\" + intPart.ToString());", "        BigInteger bigInteger = BigInteger.Parse(number.ToString());\n\
    \        BigInteger decimal = bigInteger.Remainder(BigInteger.Twice);\n      \
    \  if (decimal.Equals(BigInteger.Zero))\n        {\n            return float.Parse(decimal.ToString());\n\
    \        }\n        return float.Parse(decimal.ToString()) / BigInteger.Twice;",
  "        double dblDouble = (double)number;\n        double dblIntPart = Math.Floor(dblDouble);\n\
    \        double dblRemainder = dblDouble - dblIntPart;\n        if (dblRemainder\
    \ > 0.5) {\n            dblIntPart++;\n        }\n        return (float)dblIntPart;",
  "        BigInteger integer = new BigInteger(number);\n        int fraction = integer.SignedValue;\
    \ // integer part is positive and fraction is negative\n        BigInteger remainder\
    \ = integer.Remainder(BigInteger.One); // remainder = 0 if integer is 0\n    \
    \    return remainder.Multiply(BigInteger.Pow(10, fraction)); // return integer\
    \ part divided by 10", "        float truncatedPart = 0;\n        int intPart\
    \ = 0;\n        int decimals = 0;\n        while (intPart + decimals < number.Length)\
    \ {\n            string str = number.ToString(\"0.##\");\n            truncatedPart\
    \ += (float)(Math.Round(str));\n            float trunc = (float)Math.Round(str);\n\
    \            int integer = int.Parse(str);\n            if (integer >= intPart)\n\
    \                decimals++;\n            else\n                intPart = integer;\n\
    \        }\n        return truncatedPart;", "        float truncNumber = number;\n\
    \        float truncDecimal = number/decimal.MaxValue;\n        float truncDecimalRound\
    \ = truncDecimal;\n        while (truncDecimalRound < 1) {\n            truncDecimalRound\
    \ *= 10;\n        }\n        truncDecimalRound /= 10.0;\n        return truncDecimalRound;",
  "        Debug.Assert(number >= 0);\n        float fraction = number - (float)Math.floor(number);\n\
    \        return number - fraction;", "        // Truncating the number will remove\
    \ all decimals\n        int intPart = (int)(number * 10000.0f);\n        int decimalPart\
    \ = (int)((number - intPart) * 100.0f);\n        return ((float)intPart) / 100f\
    \ + (float)decimalPart;", "        float rounded = (int)(number*100)/100f;\n \
    \       return Math.Truncate(rounded);", "        // return (number - Math.Floor(number))\
    \ > 0.5f ? number - Math.Floor(number) : 0;\n        int intPart = (int)(number);\n\
    \        if (intPart == 0) {\n            return 0;\n        }\n        float\
    \ floatPart = number - intPart;\n        return floatPart;", "        BigInteger\
    \ truncatedNumber = BigInteger.Zero;\n        BigInteger decimalPartOfNumber =\
    \ BigInteger.One;\n        BigInteger wholeNumber = number;\n        while (wholeNumber.Remainder(BigInteger.One).CompareTo(BigInteger.Zero)\
    \ <= 0) {\n            wholeNumber = wholeNumber.Divide(BigInteger.One);\n   \
    \         truncatedNumber = BigInteger.Add(truncatedNumber, wholeNumber);\n  \
    \      }\n        truncatedNumber = BigInteger.Add(truncatedNumber, BigInteger.One);\n\
    \        if (number - truncatedNumber == BigInteger.Zero) {\n            decimalPartOfNumber\
    \ = number;\n        } else {\n            decimalPartOfNumber = truncatedNumber;\n\
    \        }\n        return decimalPartOfNumber.Normalize();", "        Debug.Assert(number\
    \ >= 0.0f);\n        Debug.Assert(number < 1.0f);\n\n        float integer = (float)number;\n\
    \        float remainder = (float)number - (float)integer;\n        float roundedRemainder;\n\
    \n        // For positive numbers, if we round the left side up to the next\n\
    \        // whole number, the remainder will be zero. This means we can\n    \
    \    // always round down to the integer part while dropping the decimals.\n \
    \       if (remainder >= 0.5f) {\n            roundedRemainder = (float)Math.Round(remainder);\n\
    \        }\n        else {\n            roundedRemainder = (float)Math.Floor(remainder);\n\
    \        }\n\n        return roundedRemainder + integer;", "        double dnumber\
    \ = (double) number;\n        int integerPart = (int) (dnumber - (double) dnumber\
    \ % 1);\n        float decimalPart = (float) dnumber % 1;\n        return decimalPart;",
  "        if (number == 0.0f) return 0.0f;\n        float precision = 1e-7f;\n  \
    \      float truncatedNumber = Math.Floor(number * precision) + Math.Truncate(number\
    \ / precision) * precision;\n        return truncatedNumber;", "        float\
    \ truncatedPart = 0.0f;\n\n        long longNumber = 0;\n        long numDigits\
    \ = 0;\n\n        // Convert number to string and count the number of digits\n\
    \        string strNumber = number.ToString();\n        int numberLength = strNumber.Length;\n\
    \n        // Remove trailing zeros\n        while (numberLength > 0 && strNumber[numberLength\
    \ - 1] == '0') {\n            numberLength--;\n        }\n\n        // Count digits\n\
    \        for (int i = numberLength - 1; i >= 0; i--) {\n            char ch =\
    \ strNumber[i];\n            if (!char.IsDigit(ch)) {\n                break;\n\
    \            }\n            numDigits++;\n        }\n\n        // Calculate and\
    \ truncate to integer\n        long numLongDigits = numDigits + 1;\n        long\
    \ numLongDiv = (long)Math.Pow(10, numLongDigits - 1);\n        long numLongRem\
    \ = numDigits - numLongDiv;\n        long numLongResult = longNumber.ToString().Length;\n\
    \        long numLongDiv = numLongResult - numLongRem;\n\n        // Calculate\
    \ and truncate to decimal\n        long numLongDiv2 = 0;\n        if (numLongDigits\
    \ > 3) {\n            numLongDiv2 = 3 - (int)numLongDiv;\n        }\n\n      \
    \  // Convert to decimal and truncate\n        truncatedPart = (float)((double)numLongDiv\
    \ / numLongDiv2);\n\n        // Convert decimal to string\n        string strTruncatedPart\
    \ = truncatedPart.ToString();\n\n        // Remove trailing zeros\n        truncatedPart\
    \ = (float)numTruncatedPart.Truncate();\n\n        // Return the result\n    \
    \    return truncatedPart;", "        Debug.Assert(number > 0);\n        var result\
    \ = number / (float)Math.Pow(10.0f, 3);\n        if (number == result) {\n   \
    \         while (result > 1.0f) {\n                result /= 10.0f;\n        \
    \    }\n        }\n        return result;", "        var intPart = BitConverter.GetBytes(number)[1];\n\
    \        var floatPart = BitConverter.GetBytes(number)[0];\n        float truncatedNum\
    \ = 0;\n        var i = 0;\n        while(i < intPart.Length){\n            if(intPart[i]\
    \ == 1)\n                truncatedNum += floatPart[i];\n            i++;\n   \
    \     }\n        return truncatedNum;", '        return number - (float)Math.Truncate(number);',
  "        float intPart = 0.0f;\n        float fracPart = 0.0f;\n        int decPoints\
    \ = 0;\n        while (number > 0.0f && decPoints < 15) {\n            intPart\
    \ = intPart + number % 1;\n            number = number / 1;\n            fracPart\
    \ = fracPart + number % 1;\n            decPoints++;\n        }\n        return\
    \ intPart + fracPart;", "        float numberWithDecimals = number;\n        numberWithDecimals\
    \ -= numberWithDecimals > 0.5f ? numberWithDecimals - 0.5f : numberWithDecimals;\n\
    \        return numberWithDecimals;", "        float wholePart = number - (int)\
    \ number;\n        float decimalPart = number - wholePart;\n        return decimalPart;",
  "        float result = number - (float)Math.Truncate(number);\n        if (result\
    \ > 0) return result;\n        return number - (float)Math.Ceiling(number);",
  "        BigInteger bint;\n        BigInteger remainder;\n        BigInteger bigint\
    \ = new BigInteger(number.ToString());\n        bint = new BigInteger(number.ToString());\n\
    \        remainder = new BigInteger(number.ToString());\n        remainder.ShiftLeft(32);\n\
    \        return bint.Div(remainder);", "        // Using Decomposition\n     \
    \   double d = number;\n        int iMax = d.ToInt64(CultureInfo.InvariantCulture);\n\
    \        int iPart = iMax / Math.Pow(10, iMax.ToString().Length - 1);\n      \
    \  float fPart = iPart / 10.0f;\n\n        // Return fractional part\n       \
    \ return fPart;", "        Debug.Assert(number >= 0.0f);\n        Debug.Assert(number\
    \ <= 1.0f);\n        Debug.Assert(number != 0.0f);\n\n        int integerPart\
    \ = (int)(number * 100.0f);\n        int decimalPart = (int)((number - integerPart)\
    \ * 10.0f);\n\n        return decimalPart;", '        return number - (int)number;',
  "        if (number == 0) {\n            return 0;\n        }\n        Decimal fDecimal\
    \ = new Decimal(number);\n        int iLargestInt = fDecimal.Floor();\n      \
    \  int iLargestDecimal = fDecimal.Ceiling();\n        return float.Parse(string.Format(\"\
    {0}.{1}f\", iLargestInt, iLargestDecimal));", "        double dbl = (double)number;\n\
    \        double intPart = Math.Truncate(dbl);\n        double decimalPart = Math.Ceiling(dbl);\n\
    \        double result = decimalPart / Math.Pow(10.0, dbl);\n        return result;",
  "        float quotient = Convert.ToSingle(number);\n        int integer_part =\
    \ Convert.ToInt32(quotient);\n        float decimal_part = number - integer_part;\n\
    \        return decimal_part;", "        Debug.Assert(number >= 0);\n        //\
    \ Convert number to double and back to float to prevent integer rounding.\n  \
    \      double doubleNumber = Math.Truncate(number);\n        return float.Parse(Convert.ToString(doubleNumber));",
  "        int integerPart = (int)(number * 100f);\n        float decimalPart = number\
    \ - integerPart * 100f;\n        return decimalPart;", '        return number
    - Math.Floor(number);', "        var integerPart = (int)(Math.Floor(number));\n\
    \        var decimalPart = number - integerPart;\n        return (float)(decimalPart);",
  "        float precision = 1;\n        long factor = 1;\n        float temp;\n \
    \       long temp2;\n        int exponent;\n        temp = number * factor;\n\
    \        exponent = (int)Math.Log10(temp);\n        while (exponent >= 5) {\n\
    \            exponent -= 5;\n            factor *= 10;\n        }\n        factor\
    \ *= precision;\n        precision *= Math.Pow(10, exponent);\n        temp2 =\
    \ (float)Math.Truncate(temp);\n        return (float)Math.Round(temp2 / factor);",
  "        if (number > 0) \n            number = Math.Round(number, 0);\n       \
    \ var decimalPart = number % 1;\n        var integerPart = number - decimalPart;\n\
    \        return integerPart;", "        double integralPart = number;\n      \
    \  double decimalPart = number - integralPart;\n        float truncatedNumber\
    \ = (float)integralPart;\n        return (float)decimalPart;", "        float\
    \ max = (float)Math.Sqrt(number);\n        int intPart = (int)(max);\n       \
    \ return float.Parse((max).ToString(\"0.\" + new string('0', intPart));", "  \
    \      ulong lowBits = (uint)number;\n        ulong highBits = (ulong)number >>\
    \ 32;\n        float lowBitsFloat = (float)lowBits;\n        float highBitsFloat\
    \ = (float)highBits;\n        return ((float)highBitsFloat - lowBitsFloat) / (float)highBitsFloat;",
  "        long wholeNumber;\n        float fraction;\n        byte[] array = new\
    \ byte[4];\n\n        Debug.Assert(number >= 0f, \"Number must be positive.\"\
    );\n        Debug.Assert(number <= 1f && number != 0.0f, \"Number must be smaller\"\
    \ +\n            \" than 1 and different from zero.\");\n\n        // Split into\
    \ integer and decimal parts of number.\n        wholeNumber = BitConverter.ToInt64(BitConverter.GetBytes(number),\
    \ 0);\n        fraction = number - BitConverter.ToSingle(BitConverter.GetBytes(number),\n\
    \            0);\n\n        // Round decimal part.\n        fraction = fraction\
    \ * 2f + 0.5f;\n\n        // Convert to integer part.\n        wholeNumber = (long)wholeNumber;\n\
    \n        // Return decimal part + integer part.\n        return (float)wholeNumber\
    \ + fraction;", "        Decimal a = number.ToDecimal();\n        Decimal b =\
    \ a % 1;\n        a = a / 1;\n        if (a > 0.5f)\n            return b;\n \
    \       return a;", "        // If there is no fraction, just return number.\n\
    \        if (number == 0)\n            return number;\n\n        // Otherwise,\
    \ first calculate the integer part.\n        int integerPart = (int)Math.Truncate(number);\n\
    \n        // Then calculate the decimal part.\n        float decimalPart = number\
    \ - integerPart;\n        \n        return decimalPart;", "        Decimal d =\
    \ new Decimal(number);\n        Decimal factor = new Decimal(10).pow(d);\n   \
    \     Decimal intPart = d.times(factor).divide(factor);\n        return intPart.floatValue;",
  "        float f = (float)Math.Floor(number);\n        float s = (float)Math.Ceiling(number);\n\
    \        int a = (int)f;\n        float p = f - a;\n        return a + p / (10\
    \ * s);", "        float intPart = 0;\n        float fracPart = 0;\n        float\
    \ intDigits = 0;\n        float intPow = 0;\n        float fracDigits = 0;\n \
    \       float fracPow = 0;\n        while (number > 0) {\n            intDigits\
    \ = (int)(number % 10);\n            fracDigits = number % 10;\n            intPow\
    \ = (int)(Math.Pow(intDigits + 1, 2));\n            fracPow = (float)Math.Pow(fracDigits\
    \ + 1, 2);\n            if (intPow > intPart && fracPow < fracPart) {\n      \
    \          intPart = intPow;\n                fracPart = fracPow;\n          \
    \  }\n            number = (int)((number - intDigits * intPow) / fracPow);\n \
    \       }\n        return fracPart;", "        if (number == 0) {\n          \
    \  return 0;\n        }\n        int integerPart = Convert.ToInt32(Math.Floor(number));\n\
    \        int decimalPart = (int)Math.Floor((number - integerPart) * 100);\n  \
    \      return integerPart + (decimalPart / 100);", "        BigInteger bigInteger\
    \ = new BigInteger(number);\n        bigInteger = bigInteger.MultiplyPow2(1000);\n\
    \        bigInteger = bigInteger.Divide(100);\n        bigInteger = bigInteger.Divide(100);\n\
    \        bigInteger = bigInteger.Divide(100);\n        bigInteger = bigInteger.MultiplyPow2(1000);\n\
    \        bigInteger = bigInteger.Divide(100);\n        bigInteger = bigInteger.Divide(100);\n\
    \        bigInteger = bigInteger.Divide(100);\n        bigInteger = bigInteger.MultiplyPow2(1000);\n\
    \        bigInteger = bigInteger.Divide(100);\n        bigInteger = bigInteger.Divide(100);\n\
    \        bigInteger = bigInteger.Divide(100);\n        return bigInteger.Value;",
  "        float integerPart = number % 1;\n        float decimalPart = number / integerPart;\n\
    \        return integerPart + decimalPart;", "        BigInteger bigInteger =\
    \ new BigInteger(number);\n        int integerPart = bigInteger.IntValue;\n  \
    \      int decimals = bigInteger.Remainder;\n        return float.Parse(integerPart.ToString())\
    \ + decimals / float(10);", "        Decimal num = new Decimal((int)number);\n\
    \        return num.Truncate();", "        var integerPart = Convert.ToInt32(Math.Truncate(number));\n\
    \        var decimalPart = number - integerPart;\n        return (float) integerPart\
    \ + decimalPart;", '        return Math.Truncate(number);', "        long largestIntegerPart\
    \ = (long)(number);\n        float leftoverPart = number - largestIntegerPart;\n\
    \        return (float)leftoverPart;", "        Decimal integerPart = new Decimal(0);\n\
    \        Decimal decimalPart = new Decimal(0);\n\n        // Find integer part:\n\
    \        for (int i = 7; i >= 0; i--) {\n            if (number < Math.Pow(10.0f,\
    \ (float)i)) {\n                integerPart += (Decimal)(Math.Pow(10.0f, (float)i));\n\
    \                decimalPart = new Decimal(number - Math.Pow(10.0f, (float)i));\n\
    \                break;\n            }\n        }\n\n        // Find decimal part:\n\
    \        for (int i = 3; i >= 0; i--) {\n            if (Math.Pow(10.0f, (float)i)\
    \ < number) {\n                decimalPart += (Decimal)Math.Pow(10.0f, (float)i);\n\
    \                break;\n            }\n        }\n\n        return (float)decimalPart;",
  "        if (number == (float)number) {\n            return number;\n        }\n\
    \        Decimal d = new Decimal(number);\n        float result = d.ToSingle();\n\
    \        return result;", "        float part1 = number % 1;\n        float part2\
    \ = number - part1;\n        float result = part1;\n        if (part2 > 0.5f)\
    \ {\n            float factor = 1f;\n            result = part1 * factor;\n  \
    \      }\n        return result;", "        // Use a BigInteger to store the number\
    \ without decimal part.\n        // BigInteger class can store numbers ranging\
    \ from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.\n        BigInteger\
    \ bigInteger = new BigInteger(number);\n        // Return the decimal part if\
    \ the number is negative.\n        if (bigInteger < 0)\n            return ((float)bigInteger);\n\
    \        // Return integer part and divide it by 10^decimals.\n        return\
    \ (float)bigInteger / BigInteger.Pow(10.0, (float)Math.Ceiling((float)Math.Log10(Math.Abs(bigInteger)))\
    \ - 1);", "        if (number == 0.0) {\n            return number;\n        }\n\
    \n        float largest = float.NegativeInfinity;\n        float result = 0.0f;\n\
    \        int decimalCount = 0;\n\n        while (number >= largest) {\n      \
    \      largest *= 1.0f;\n            result += 1.0f;\n        }\n\n        while\
    \ (number != 0.0f) {\n            result *= 1.0f;\n            number -= result\
    \ * largest;\n            decimalCount++;\n        }\n\n        return number\
    \ / result;", "        Debug.Assert(number > 0);\n\n        Decimal d = new Decimal(number);\n\
    \        double integralPart = Convert.ToDouble(d);\n        double decimalPart\
    \ = Convert.ToDouble(d.Subtract(integralPart));\n\n        // Truncate\n     \
    \   if (decimalPart > 1) {\n            decimalPart -= 1;\n        }\n       \
    \ // Round to nearest integer\n        decimalPart = Math.Round(decimalPart, MidpointRounding.AwayFromZero);\n\
    \n        // Rounding may cause us to lose precision. Resolve that.\n        while\
    \ (decimalPart != Math.Round(decimalPart, MidpointRounding.AwayFromZero)) {\n\
    \            if (decimalPart < 0) {\n                decimalPart += 1;\n     \
    \       }\n        }\n        return decimalPart / Convert.ToSingle(Math.Pow(10,\
    \ d.Exponent));", "        // Use floating point arithmetic since integer values\
    \ would not make any sense.\n        var integerPart = (int) number;\n       \
    \ var fractionalPart = number - integerPart;\n        return (float) fractionalPart;",
  "        double decimalPart = 0;\n        BigInteger integerPart;\n\n        BigInteger\
    \ temp = (BigInteger)number;\n        decimalPart = temp % 1;\n        integerPart\
    \ = temp / 1;\n\n        float truncatedNum = Convert.ToSingle(integerPart);\n\
    \        float truncatedDer = (float)decimalPart;\n        return truncatedNum;",
  "        int integerPart = (int)number;\n        float fracPart = number - integerPart;\n\
    \        if (fracPart == 0) {\n            return integerPart;\n        }\n  \
    \      return fracPart;", "        if (number <= 0) {\n            return 0f;\n\
    \        }\n        number *= 100;\n        float integralPart = number;\n   \
    \     float fractionalPart = number - integralPart;\n        float decimalPart\
    \ = fractionalPart / 100;\n        return decimalPart;", '        return Math.Truncate(number);',
  '        return number - (float)Math.Floor(number);', "        Debug.Assert(number\
    \ > 0);\n        // Get the integer part of the number.\n        float int_part\
    \ = (float) number;\n        // Get the decimal part of the number.\n        float\
    \ frac_part = number - int_part;\n        // Divide the number by 10 to get the\
    \ decimal part of the number.\n        float decimal_part = frac_part / 10.0f;\n\
    \        return decimal_part;", '        return Math.Truncate(number);', "   \
    \     // Truncate decimal part of a number using truncation method\n        //\
    \ and decompose the number into integer and decimal parts\n        double dbl\
    \ = Convert.ToDouble(number);\n        double trunc = Math.Truncate(dbl);\n  \
    \      double intPart = dbl - trunc;\n        double decPart = 1.0 - Math.Pow(10.0,\
    \ -(intPart % 1));\n        return (float)(trunc * decPart);", "        // Split\
    \ off the sign\n        float sign = number;\n        number -= sign * Float.Epsilon;\n\
    \        // Split off integer part\n        float integer = number;\n        number\
    \ -= integer * Float.Epsilon;\n        // Calculate the remainder by dividing\
    \ by 10\n        float remainder = number / Float.Epsilon;\n        // Calculate\
    \ the decimal part\n        float decimal = remainder * 10;\n        // Return\
    \ the decimal part of the number\n        return sign * decimal;", '        return
    number - number % 1;', "        if (number == Math.Abs(number)) {\n          \
    \  throw new System.ArgumentException();\n        }\n        if (number < 1.0f)\
    \ {\n            throw new System.ArgumentException();\n        }\n        bool\
    \ isNegative = number < 0.0f;\n        int digits = Convert.ToInt32(Math.Ceiling(Math.Log10(number)));\n\
    \        double temp = Math.Truncate(number);\n        double truncated = (temp\
    \ * Math.Pow(10, digits)) / Math.Pow(10, digits);\n        if (isNegative) {\n\
    \            truncated = -truncated;\n        }\n        return (float)(truncated);",
  "        float ipart = number;\n        while (ipart != 0) {\n            if (ipart\
    \ < number) {\n                ipart *= 10;\n            } else {\n          \
    \      number -= ipart;\n                ipart /= 10;\n            }\n       \
    \ }\n        return number;", '        return number - Math.Floor(number);', " \
    \       // Find the largest integer smaller than the input number.\n        //\
    \ If the number is too small, then return 0.\n        ulong numberToBiggestInt\
    \ = BitConverter.ToUInt64Bits(number);\n        ulong numberToBiggest = numberToBiggestInt\
    \ >> 63; // the highest bit is the sign bit\n        ulong numberToBiggestBits\
    \ = (numberToBiggestInt - numberToBiggest) >> 63; // get the rest of the bits\
    \ without sign\n        ulong numberToBiggestBitsPlusOne = numberToBiggestBits\
    \ + 1; // add one to the highest bit\n        if (numberToBiggest < numberToBiggestBitsPlusOne)\
    \ {\n            return 0;\n        }\n        ulong numberToRest = numberToBiggestBits\
    \ - numberToBiggestBitsPlusOne; // get the rest of bits without sign\n       \
    \ // Truncate to the integer part. Return the result.\n        return BitConverter.ToSingle(BitConverter.GetBytes(numberToBiggest),\
    \ 0);", "        if (number == (float)(-1)) return (float)(0);\n        float\
    \ temp;\n        float intPart = (float)0;\n        float dec = 0.0;\n       \
    \ for (int i = 0; i < 4; i++) {\n            temp = (float)Math.Floor(number *\
    \ (float)Math.Pow(10, i));\n            intPart = (int)temp;\n            dec\
    \ += (temp - intPart) / Math.Pow(10, i);\n        }\n        return intPart +\
    \ dec;", "        float truncated = number; // Start with original number\n  \
    \      int remainder = 0; // Part of number that will not be truncated\n     \
    \   int intPart = 0; // Integer part of number\n        while (truncated*10 <=\
    \ number) {\n            int tenToPowerOf10 = Mathf.Floor(truncated*10);\n   \
    \         truncated = (truncated/10f); // Divide by 10\n            remainder\
    \ += (number-truncated)*tenToPowerOf10; // Accumulate remainder\n            intPart\
    \ += tenToPowerOf10; // Increment integer part of number\n        }\n        while\
    \ (truncated>=10) {\n            int tenToPowerOf10 = Mathf.Floor(truncated);\n\
    \            truncated = (truncated/10f); // Divide by 10\n            remainder\
    \ += (number-truncated)*tenToPowerOf10; // Accumulate remainder\n            intPart\
    \ += tenToPowerOf10; // Increment integer part of number\n        }\n        truncated\
    \ = remainder; // Truncate remainder and store as float\n        truncated = truncated*10;\
    \ // Convert to integer\n        return (float)truncated;", "        BigInteger\
    \ big = new BigInteger(number);\n        BigInteger small = new BigInteger(number.ToString());\n\
    \        if (small.ToString() + number.ToString() == big.ToString()) {\n     \
    \       BigInteger mid = big.Divide(small);\n            return mid.Remainder(small);\n\
    \        }\n        return number;", "        float floorPart = number - (int)number;\n\
    \        float floorPart2 = (float)Math.Floor(number);\n        return (floorPart\
    \ + floorPart2) / 2;", "        float floatPart = (float)number;\n        float\
    \ intPart = (float)Math.Floor(floatPart);\n        float decimalPart = floatPart\
    \ - intPart;\n        return decimalPart;", "        // Truncate the number to\
    \ get the integer part\n        float truncatedNumber = System.Math.Truncate(number);\n\
    \n        // Use integer division (/) to get the decimal part\n        float truncatedDecimalPart\
    \ = truncatedNumber / System.Math.Pow(10, truncatedNumber.GetDecimalPlaces() -\
    \ 1);\n\n        // Return the decimal part\n        return truncatedDecimalPart;",
  "        Debug.Assert(number >= 0);\n        \n        Decimal integerPart;\n  \
    \      Decimal decimalPart;\n        if (number == 0) {\n            integerPart\
    \ = new Decimal(0);\n            decimalPart = new Decimal(1);\n        }\n  \
    \      else if (number < 1) {\n            integerPart = new Decimal(1);\n   \
    \         decimalPart = new Decimal(1);\n        }\n        else {\n         \
    \   \n            float temp = number;\n            \n            // First we\
    \ determine whether there will be any decimals in number\n            while (temp\
    \ < 1)\n            {\n                decimalPart.Add(new Decimal(0));\n    \
    \            temp = temp * 10;\n            }\n            \n            // Next\
    \ we find the largest integer smaller than number\n            while (temp >=\
    \ 1)\n            {\n                integerPart.Add(new Decimal(0));\n      \
    \          temp = temp / 10;\n            }\n            \n            // Finally\
    \ we add the leftover part of the number to the decimalPart\n            decimalPart.Add(temp);\n\
    \        }\n        \n        Debug.Assert(decimalPart.CompareTo(new Decimal(0))\
    \ < 0);\n        Debug.Assert(integerPart.CompareTo(new Decimal(0)) < 0);\n  \
    \      \n        return decimalPart.ToSingle();", "        // Using floating point\
    \ arithmetic is necessary since we want\n        // the exact decimal value and\
    \ not just rounded down value\n        // which is what Math.Round would give\
    \ us.\n        // The idea is to find an exponent that would give us the\n   \
    \     // closest decimal value to our original input value.\n        Debug.Assert(number\
    \ >= 0.0f);\n\n        double exponent;\n        double inputExponent = Math.Floor(Math.Log(number))\
    \ / Math.Log10(10); // Find exponent of the input number\n        if (inputExponent\
    \ == 0.0f) {\n            return 0.0f; // Input number doesn't have an integer\
    \ part\n        }\n        if (inputExponent < 0.0f) {\n            inputExponent\
    \ += 2.0f;\n        }\n        // Now we subtract the exponent to get the number\
    \ in decimal\n        exponent = inputExponent - 1;\n        // Now we find the\
    \ closest decimal value we can get from input number\n        double closestDecimal\
    \ = Math.Pow(10, exponent);\n        // Now we truncate this value to our input\
    \ number's decimal part\n        float truncatedNumber = Math.Truncate(closestDecimal);\n\
    \        return truncatedNumber;", "        float remainder;\n        System.Int32\
    \ intPart;\n        System.Decimal decPart;\n        System.Int32 decCount;\n\
    \        float dec;\n        System.Int32 i;\n        remainder = 0;\n       \
    \ intPart = 0;\n        decCount = 0;\n        for (i = 0; i < number.Length;\
    \ i++) {\n            decPart = System.Convert.ToDecimal(number[i]);\n       \
    \     dec = decPart;\n            decCount += dec.ToString().Length;\n       \
    \     if (remainder < dec) {\n                remainder = dec;\n            }\n\
    \            if (decCount == 5) {\n                intPart++;\n              \
    \  decCount = 0;\n            }\n        }\n        if (remainder > 1) {\n   \
    \         remainder = 1;\n            intPart++;\n        }\n        return remainder;",
  "        float trunc = number;\n        while(trunc > 1) trunc /= 10;\n        return\
    \ trunc;", "        Decimal result = new Decimal((int)number);\n        return\
    \ number.CompareTo(result) < 0 ? result.Truncate() : result.Truncate().Multiply(new\
    \ Decimal(1));", "        long integerPart = (long)number;\n        float decimalPart\
    \ = (float)integerPart;\n        return (float)decimalPart;", "        int integerPart\
    \ = (int)(number * 100);\n        return (float)(integerPart / 100);", "     \
    \   float intPart = (float)Math.Truncate(number);\n        float decimalPart =\
    \ number - intPart;\n        return intPart;", "        int intPart = (int) number;\
    \ // Truncate to nearest integer part.\n        float floatPart = (float) (number\
    \ - intPart); // Floor or ceil it to nearest integer part.\n        return floatPart;",
  "        BigInteger bigInteger = new BigInteger(number.ToString());\n        return\
    \ bigInteger.Remainder(BigInteger.One).ToSingle();", "        float result;\n\
    \        float intPart;\n        float decimalPart;\n        float floatPart;\n\
    \n        intPart = number;\n        decimalPart = number - intPart;\n       \
    \ floatPart = (intPart + decimalPart);\n        result = floatPart;\n        return\
    \ result;", "        double trunc = 0;\n        if (number > 0) {\n          \
    \  trunc = Math.Truncate(number);\n        }\n        return (float)trunc;", " \
    \       var number = Math.Floor(number);\n        var result = (number - number)\
    \ % 1.0f;\n        return result;", "        // This algorithm works by first\
    \ finding the integer\n        // part of the number, then rounding up to the\
    \ next\n        // decimal place if needed. We also need to keep\n        // track\
    \ of the decimal part of the number since\n        // the integer part will likely\
    \ be rounded away.\n        float intPart;\n        if (number == (int) number)\
    \ {\n            intPart = number;\n        } else {\n            intPart = (int)\
    \ Math.Ceiling(number);\n        }\n\n        // Find the decimal part by dividing\
    \ the number by 10\n        // until we get a whole number or hit the origin.\n\
    \        float decimalPart = (float) ((intPart * 10) % 10);\n        return Math.Round(intPart\
    \ + decimalPart);", "        // Truncate decimal part\n        float truncated\
    \ = (float)number;\n        truncated = truncated.Truncate(MathContext.Single.Epsilon);\n\
    \        \n        // Truncate integer part\n        float truncatedIntPart =\
    \ truncated - truncated.Truncate(MathContext.Single.Epsilon);\n        \n    \
    \    // Calculate integer part decimal parts\n        float intPartDecimalPart;\n\
    \        if (truncatedIntPart < 0) {\n            intPartDecimalPart = 0;\n  \
    \      }\n        else {\n            intPartDecimalPart = truncatedIntPart.Truncate(MathContext.Single.Epsilon);\n\
    \        }\n        \n        // Calculate decimal part decimal parts\n      \
    \  float decimalPartDecimalPart = truncatedIntPart - intPartDecimalPart;\n   \
    \     \n        return intPartDecimalPart;", "        if (number >= 1) {\n   \
    \         int integer = (int)number;\n            float fraction = number - integer;\n\
    \            return (float )fraction;\n        }\n        else {\n           \
    \ return number;\n        }", "        // If there is more than 1 decimal, truncate\
    \ to integer,\n        // otherwise return 0 because no truncation is required.\n\
    \        // http://stackoverflow.com/questions/341823/net-c-sharp-truncate-a-double-to-the-precision-of-a-float\n\
    \        float f = Convert.ToSingle(number);\n        int i = (int)f;\n      \
    \  float f2 = i - f;\n        if (f2 > 0) return f2;\n        else return 0;",
  "        // Extract the integer part\n        float integer = (number * 100).RoundToInt()\
    \ / 100;\n        // Extract the decimals\n        float decimals = (number -\
    \ integer).RoundToInt() / 1;\n        // Return the decimal part\n        return\
    \ decimals;", "        int integerPart = Convert.ToInt32(number);\n        float\
    \ decimalPart = number - integerPart;\n        return decimalPart;", "       \
    \ // Convert to int and back to float to lose decimal part\n        return Convert.ToSingle(Convert.ToInt32(number)).ToSingle();",
  "        var remainder = number - Convert.ToSingle(number).Truncate();\n       \
    \ float f = remainder / Convert.ToSingle(number).Truncate();\n        return f;",
  "        // Floating point numbers don't have decimal part.\n        if (number\
    \ == float.MinValue || number == float.MaxValue)\n            return float.MaxValue;\n\
    \        if (Math.Abs(number) < float.Epsilon && number >= (float)Math.Floor(number))\
    \ {\n            return Math.Floor(number);\n        }\n        double doubleNumber\
    \ = Math.Abs(number);\n        double intPart = (double)Math.Floor(doubleNumber);\n\
    \        double decimalPart = doubleNumber - intPart;\n        if (decimalPart\
    \ < doubleNumber.Epsilon && decimalPart >= doubleNumber.Epsilon) {\n         \
    \   return (intPart + (decimalPart)) / doubleNumber.Epsilon;\n        } else {\n\
    \            return (intPart + (decimalPart - doubleNumber.Epsilon)) / doubleNumber.Epsilon;\n\
    \        }", "        // Assume number is positive\n        float integer = Math.Truncate(number);\n\
    \        float decimal = (number - integer);\n        return decimal;", "    \
    \    Decimal d = new Decimal(number);\n        int i = d.FloorToInt();\n     \
    \   int decimals = d.LeadingZeroes;\n        return i / (float) Math.Pow(10, decimals);",
  "        int precision = number.ToString().IndexOf('.');\n        if (precision\
    \ < 0) {\n            throw new System.Exception(\"Floating point value not provided.\"\
    );\n        }\n        int integer = Convert.ToInt32(Math.Truncate(number));\n\
    \        if (precision == integer.ToString().Length) {\n            return number;\n\
    \        }\n        int decimals = Convert.ToInt32(Math.Truncate(Math.Abs(number)));\n\
    \        return (float)(integer + (float)decimals / Math.Pow(10, precision));",
  "        if (number == 0)\n            return number;\n        if (number >= 1)\n\
    \            return number;\n        BigInteger bigInteger = new BigInteger(number);\n\
    \        int decimalPart = bigInteger.Remainder;\n        return Math.Ceiling(number\
    \ * 10f) / 10f + decimalPart;", "        float trunc;\n        long quotient,\
    \ remainder, exponent;\n        long number = System.BitConverter.ToInt64(number,\
    \ 0);\n        bool isNegative = number < 0;\n        quotient = System.BitConverter.ToInt64(number,\
    \ 0);\n        remainder = (long) Math.Pow(10.0, System.BitConverter.GetBytes(quotient)[0]);\n\
    \        exponent = System.BitConverter.GetBytes(quotient)[1];\n        if (isNegative)\
    \ {\n            number = System.BitConverter.ToInt64(number, 0);\n          \
    \  trunc = (float) System.Math.Pow(10.0, System.BitConverter.GetBytes(number)[0]);\n\
    \        } else {\n            trunc = System.Math.Truncate((float) System.Math.Pow(10.0,\
    \ System.BitConverter.GetBytes(number)[0]));\n        }\n        float trunc2\
    \ = trunc;\n        return trunc2;", "        float factor = 1 / (int)Math.Pow(10,\
    \ (number.ToString().Length - 1 ));\n        int result = (int)Math.Round(number\
    \ * factor) / factor;\n        return result;", "        BigInteger bigInteger\
    \ = new BigInteger(number.ToString());\n        int intPart = (bigInteger >> 24)\
    \ & 0xFF;\n        int decPart = (bigInteger >> 16) & 0xFF;\n        int lastBits\
    \ = (decPart & 0x800) >> 15;\n        decPart &= 0x7FF;\n        if (decPart !=\
    \ 0) {\n            decPart = decPart + 1;\n        }\n        return float.Parse((float.Parse(number.ToString())\
    \ + decPart).ToString());", "        float intPart = 0;\n        float decimalPart\
    \ = 0;\n        if (number > 0.0f) {\n            int splitpoint = Mathf.Floor(number);\n\
    \            intPart = number - splitpoint;\n            decimalPart = (number\
    \ - splitpoint);\n        } else {\n            intPart = 0;\n            decimalPart\
    \ = (-1) * number;\n        }\n        return decimalPart;", '        return Math.Truncate(number);',
  "        Debug.Assert(number >= 0);\n        int integerPart = (int) (number * 100);\n\
    \        if (integerPart == 100) {\n            return 0;\n        }\n       \
    \ float truncated = number - (number * integerPart);\n        if (Math.Abs(truncated)\
    \ > 1) {\n            return TruncateNumber(truncated);\n        }\n        return\
    \ truncated;", "        float result = number;\n        int exp = 0;\n       \
    \ while(result > 1)\n        {\n            ++exp;\n            result = result\
    \ / 10f;\n        }\n        return result;", "        // Get the integer part\n\
    \        int intPart = (int) number;\n        // Get the remainder\n        int\
    \ decimalPart = (int) (number - intPart);\n\n        // Return the number with\
    \ decimals truncated\n        return float.Parse((decimalPart.ToString()));",
  "        float integerPart = number;\n        float decimalPart = number - integerPart;\n\
    \        return integerPart;", '        return Math.Truncate(number);', "    \
    \    float x = number;\n        int a = (int)x;\n        int b = (int)(x - a);\n\
    \        float result = (float)(b / 10f);\n        return result;", "        //\
    \ Calculate the absolute value of the given number.\n        // The absolute value\
    \ of positive numbers is positive.\n        // The absolute value of negative\
    \ numbers is negative.\n        // The absolute value of 0 is 0.\n        // >>>\
    \ Abs(3)\n        // (3)\n        // >>> Abs(-3.0)\n        // (-3.0)\n      \
    \  float absnumber = (float)Math.Abs(number);\n\n        // If absnumber >= 1,\
    \ then absnumber will be a positive number.\n        // If absnumber < 1, then\
    \ absnumber will be a negative number.\n        // Otherwise, absnumber will be\
    \ 0.\n        // >>> Abs(0.1f)\n        // (0.1f)\n        // >>> Abs(-0.1)\n\
    \        // (-0.1)\n        if (absnumber >= 1f) {\n            // The absolute\
    \ value of the given number is greater or equal to 1.\n            // We return\
    \ the given number.\n            return number;\n        } else if (absnumber\
    \ < 1f) {\n            // The absolute value of the given number is smaller than\
    \ 1.\n            // We truncate the given number to remove all decimal places.\n\
    \            float remaining = absnumber % 1f;\n            // Return the truncated\
    \ number.\n            return (float)remaining + 1f;\n        } else {\n     \
    \       // The absolute value of the given number is equal to 1.\n           \
    \ // We return the absolute value of 0.\n            return 0;\n        }", " \
    \       // Truncate to nearest integer.\n        int truncatedNumber = (int) (number\
    \ * Math.Pow(10, numberFloatTruncateFactor)) - 1;\n        return truncatedNumber;",
  "        if (number == 0)\n            return 0;\n        Debug.WriteLine(number);\n\
    \        Debug.WriteLine(Math.Abs(number));\n        int intPart = Convert.ToInt32(Math.Floor(number));\n\
    \        int decimals = Convert.ToInt32(Math.Ceiling(Math.Abs(number)));\n   \
    \     return float.Parse(\"0.\" + Math.Abs(decimals) + \"f\");", "        int\
    \ iPart = (int) Math.Ceiling(number);\n        float fPart = (number - iPart)\
    \ * Math.Sign(number);\n        return fPart;", '        return TruncateNumber(number,
    10);', "        var digits = BitConverter.GetBytes(number);\n        var fractionalDigits\
    \ = BitConverter.GetBytes((number - digits\n            .Aggregate((x, y) => x\
    \ + y)) - BitConverter.GetBytes((long)0));\n        return (float)(Math.Round(number\
    \ * Math.Pow(10.0, digits[3]), 0) /\n            Math.Pow(10.0, digits[3]));",
  "        BigInteger integer = new BigInteger(number.ToString());\n        BigInteger\
    \ fraction = integer % 1;\n        return fraction.Equals(BigInteger.Zero) ? number.ToDecimal()\
    \ : number.ToDecimal() / fraction.ToDecimal();", "        long tempIntPart = Convert.ToInt64(Math.Truncate(number));\n\
    \        float tempFraction = number - Convert.ToSingle(tempIntPart);\n      \
    \  return tempFraction;", '        return number / Math.Truncate(number);', " \
    \       if (number == 0.0f) {\n            return 0.0f;\n        }\n        var\
    \ integer = (int)number;\n        Debug.Assert(integer >= 0);\n        if (number\
    \ - integer > 0.000000001f) {\n            return (float)(integer);\n        }\
    \ else {\n            return (float)(integer + 1);\n        }", "        long\
    \ intPart = (long) number;\n        float decPart = (float) (intPart % 1);\n \
    \       return (number - decPart);", "        int intPart = (int) number;\n  \
    \      float decPart = number - intPart;\n        return decPart;", "        if\
    \ (number == 0.0f) {\n            return 0.0f;\n        }\n        int intPart\
    \ = (int)number;\n        if (intPart < number) {\n            return number;\n\
    \        }\n        // If intPart is larger than number, then number is negative.\n\
    \        // So the largest integer smaller than number is intPart + 1.\n     \
    \   float intPart_next = intPart + 1.0f;\n        float intPart_trunc = (float)intPart;\n\
    \        float remainder;\n        if (intPart_next >= number) {\n           \
    \ remainder = number - intPart;\n        } else {\n            remainder = intPart_next\
    \ - number;\n        }\n        return remainder;", "        BigInteger bigInteger\
    \ = new BigInteger(number.ToString());\n        BigInteger decimals = bigInteger.Remainder(new\
    \ BigInteger(1));\n        return float.Parse(decimals.ToString());", "      \
    \  double temp = number;\n        int integerPart;\n        float decimalPart;\n\
    \        if (temp > 0.0) {\n            integerPart = (int)temp;\n           \
    \ decimalPart = temp - integerPart;\n        } else {\n            integerPart\
    \ = 0;\n            decimalPart = 0.0f;\n        }\n        return float.Parse(integerPart.ToString())\
    \ + \".\" +\n            float.Parse(decimalPart.ToString());", "        var remainder\
    \ = number - (int)(number);\n        return remainder > 0 ? remainder : 0.0f;",
  "        double doubleNumber = (double)number;\n        double intPart = (double)Math.Truncate(doubleNumber);\n\
    \        double decimalPart = doubleNumber - intPart;\n        return decimalPart;",
  "        float integerPart = 0, decimalPart = 1;\n        while (number - integerPart\
    \ >= decimalPart) {\n            integerPart += decimalPart;\n            decimalPart++;\n\
    \        }\n        return number * (float)decimalPart;", "        int[] power\
    \ = { 10, 100, 1000, 10000 };\n        foreach (int p in power) {\n          \
    \  if (number < p) {\n                return (float)p;\n            }\n      \
    \  }\n        float remaining = number;\n        BigInteger i = 1;\n        bool\
    \ found = false;\n        while (true) {\n            BigInteger temp = new BigInteger(remaining.ToString());\n\
    \            if (temp.Equals(i)) {\n                found = true;\n          \
    \      break;\n            }\n            BigInteger remainder = new BigInteger(remaining.ToString());\n\
    \            remaining -= remainder;\n            i += 1;\n        }\n       \
    \ if (found == true) {\n            return (float)i;\n        } else {\n     \
    \       throw new ArgumentException(\"Can't truncate number \" + number);\n  \
    \      }", "        int intPart = Convert.ToInt32(Math.Floor(number));\n     \
    \   int decimals = Convert.ToInt32((number - intPart) * 10);\n        return float.Parse((intPart\
    \ / 10).ToString() + decimals.ToString());", "        Decimal integerPart = new\
    \ Decimal((int)(Math.Floor(number)));\n        Decimal decimals = new Decimal(number\
    \ - integerPart);\n        return decimals.Truncate();", "        // Decompose\
    \ the number into integer part and decimals.\n        decimal result = Math.Truncate(number);\n\
    \        float resultFloat = Math.Truncate(result);\n        bool isIndented =\
    \ number % 1 != 0.0m;\n        string strDecimal = resultFloat.ToString(\"#.##\"\
    , CultureInfo.InvariantCulture);\n        if (strDecimal.Length <= 9) {\n    \
    \        Debug.Assert(resultFloat == result, \"The number is not truncated\");\n\
    \        }\n        // Remove the leading zeros (if any) from the decimal.\n \
    \       string strDecimalNoLeadingZeros = strDecimal.TrimStart('0');\n       \
    \ // Check if the remaining decimals after the decimal point are zero.\n     \
    \   if (strDecimalNoLeadingZeros.IndexOf('.') > 0 && strDecimalNoLeadingZeros.Length\
    \ > 9) {\n            // If so, the number is truncated.\n            return resultFloat;\n\
    \        }\n        // Check if the decimal part is zero.\n        if (strDecimalNoLeadingZeros.Length\
    \ > 9) {\n            // If so, truncate the number as per IEEE-754 rules.\n \
    \           return (float)result;\n        }\n        // Truncate as per IEEE-754\
    \ rules.\n        return (float)result;", "        Debug.Assert(number > 0.0f);\n\
    \        Debug.Assert(number < 1.0f);\n        // Take the integer part\n    \
    \    int integerPart = (int)(number * (float)Math.Pow(10, (int)Math.Log10(number)));\n\
    \        // Truncate to account for remainder of float\n        float fractionPart\
    \ = (float)Math.Truncate((float)(number * (float)Math.Pow(10, (int)Math.Log10(number)\
    \ - 1)));\n        return integerPart + fractionPart;", "        var integer =\
    \ Convert.ToInt32(number);\n        while(integer >= 10) {\n            integer\
    \ /= 10;\n        }\n        return number;", "        double d = (double) number;\n\
    \        long l = (long) d;\n        return l / Convert.ToDouble(10); // truncate,\
    \ no rounding", "        double dblNumber = Math.Truncate(number);\n        return\
    \ (float)((float)dblNumber);", "        BigInteger big = new BigInteger(number.ToString());\n\
    \        float truncate = big.DivRem(new BigInteger(1), 256).FloatValue;\n   \
    \     return truncate;", "        int decimalPart = (int)number;\n        return\
    \ (float)number - decimalPart;", "        BigInteger integerPart = new BigInteger(number.ToString());\n\
    \        BigInteger decimalPart = integerPart.Remainder(new BigInteger(10));\n\
    \n        return decimalPart.Value / 10;", "        if (number == 0)\n       \
    \     return 0;\n        // Find the largest integer less than or equal to number.\n\
    \        int intPart = (int) number;\n        // Find the fractional part.\n \
    \       float fraction = number - intPart;\n        // Truncate fractional part\
    \ by rounding toward zero.\n        float truncated = Math.Truncate(fraction);\n\
    \        // Return the truncated integer.\n        return intPart + truncated;",
  "        int integerPart = Convert.ToInt32(Math.Truncate(number));\n        float\
    \ decimalPart = number - integerPart;\n        return decimalPart;", "       \
    \ float intPart = (float)Math.Truncate(number);\n        float remainder = (float)number\
    \ - intPart;\n        return intPart;", "        BigInteger x = BigInteger.Abs(number);\n\
    \        BigInteger remainder = BigInteger.Divide(x, BigInteger.One);\n      \
    \  Decimal decimal = new Decimal(remainder);\n        return decimal.ToSingle();",
  '        return (int)(number + 0.5f);', "        // We want two decimal places.\n\
    \        Decimal maxDecimal = new Decimal(Math.Round(number, 2));\n        //\
    \ Truncate the decimal portion.\n        return Math.Ceiling(maxDecimal);", " \
    \       float intPart = System.Math.Floor(number);\n        float decimalPart\
    \ = number - intPart;\n        float result = decimalPart;\n        return result;",
  "        int intPart = Convert.ToInt32(number);\n        float fracPart = number\
    \ - intPart;\n        return (float)intPart;", "        float f = (float)number;\n\
    \        float integerPart = (float)Math.Floor(f);\n        float fractionalPart\
    \ = f - integerPart;\n        return (fractionalPart > 0.0 ? fractionalPart :\
    \ 0.0f);", "        BigInteger integer = BigInteger.Parse(number.ToString(), NumberStyles.Float);\n\
    \        BigInteger decimals = BigInteger.Parse(Math.Floor(Math.Log10(number)\
    \ + 1).ToString(), NumberStyles.Float);\n        return (decimals.CompareTo(BigInteger.One)\
    \ < 0) ? number : (float)integer.Divide(decimals);", "        // Get the fractional\
    \ part.\n        float fractionalPart = number - Math.Truncate(number);\n\n  \
    \      // Return the decimal part.\n        return fractionalPart;", "       \
    \ float integerPart = 0, decimalPart = 0;\n        float temp = 0;\n\n       \
    \ int exponent = 0;\n        while (Math.Floor(number) == number) {\n        \
    \    exponent += 1;\n            number *= 10;\n        }\n\n        while (exponent\
    \ >= 0 && Math.Floor(number) == number) {\n            temp += Math.Floor(number);\n\
    \            number *= 10;\n            exponent -= 1;\n        }\n\n        integerPart\
    \ = temp / Math.Pow(10, exponent);\n        decimalPart = temp - integerPart *\
    \ Math.Pow(10, exponent);\n\n        return decimalPart;", "        if (number\
    \ < 0) {\n            throw new ArgumentOutOfRangeException(\"number\", \"Argument\
    \ must be positive.\");\n        }\n        // Get rid of any trailing zeros from\
    \ the fractional part of the number\n        int decimals = Convert.ToInt32(Math.Truncate(number\
    \ * 1000));\n        if (decimals <= 0) {\n            decimals = 1;\n       \
    \ }\n        if (decimals == 1000) {\n            decimals = 0;\n        }\n \
    \       return number / decimals;", "        double d = 0;\n        double d1\
    \ = 0;\n        if (number > 0)\n            d = Convert.ToDouble(number);\n \
    \       double d2 = Math.Truncate(d);\n        if (number > 0)\n        {\n  \
    \          d1 = Convert.ToDouble(d2);\n        }\n        float f = 0;\n     \
    \   f = (float)(d1 * 100 + d2);\n        return f;", "        int intPart = (int)number;\n\
    \        int decimalPart = number - intPart;\n        return (float)decimalPart;",
  "        // The easiest way is to use decimal type\n        Decimal result = new\
    \ Decimal((long)number);\n        // truncate decimal part (remove everything\
    \ after the decimal point)\n        result = result.Truncate();\n        // convert\
    \ decimal to float\n        return result.ToSingle();", "        var result =\
    \ Math.Floor(number);\n        decimal remainder;\n        if (result > 0)\n \
    \       {\n            remainder = number - result;\n        }\n        else\n\
    \        {\n            remainder = result;\n        }\n        return remainder;",
  '        // TODO: Write the code.', "        BigInteger n = number;\n        if\
    \ (n < 0)\n        {\n            n = -n;\n        }\n        BigInteger i = BigInteger.Zero;\n\
    \        while (true)\n        {\n            if (BigInteger.TryParse(n.ToString(),\
    \ out i))\n            {\n                BigInteger i2 = BigInteger.DivRem(n,\
    \ i, out n, out i);\n                if (i2 == 0 || i2 == 1)\n               \
    \ {\n                    break;\n                }\n            }\n          \
    \  else\n            {\n                BigInteger i3 = BigInteger.DivRem(i, i,\
    \ out n, out i);\n                if (i3 == 0)\n                {\n          \
    \          break;\n                }\n            }\n        }\n        if (n\
    \ != i)\n        {\n            BigInteger i4 = BigInteger.DivRem(i, i, out n,\
    \ out i);\n            if (i4 != 0)\n            {\n                throw new\
    \ Exception(\"Bad number: \" + number);\n            }\n        }\n        return\
    \ i;", "        int integerPart = ((int) number);\n        int decimalPart = (int)(number\
    \ * 100);\n\n        if (integerPart > decimalPart) {\n            return number\
    \ - decimalPart;\n        } else {\n            return number;\n        }", " \
    \       float result = number;\n        result *= 1.0f - (float)Math.Truncate(number);\n\
    \        return result;", "        if (number == 0)\n            return 0;\n \
    \       if (number < 0)\n            return -TruncateNumber(-number);\n      \
    \  int decimals = (int)Math.Ceiling(Math.Log10(number) + 1);\n        return number\
    \ / Math.Pow(10, decimals);", "        Debug.Assert(number > 0);\n        Debug.Assert(number\
    \ != float.MinValue);\n        Debug.Assert(number != float.NegativeInfinity);\n\
    \        Debug.Assert(number != float.PositiveInfinity);\n        Debug.Assert(number\
    \ != float.NaN);\n        Debug.Assert(Math.Abs(number) < float.Epsilon);\n  \
    \      // Find the integer part of the number.\n        BigInteger integer = BigInteger.Parse(number.ToString());\n\
    \        Debug.Assert(Math.Abs(integer) < float.Epsilon);\n        // Find the\
    \ fractional part of the number.\n        BigInteger fractionalPart = integer.Remainder(new\
    \ BigInteger(1));\n        if (fractionalPart.IsPositive) {\n            // The\
    \ number was rounded up, so remove the last digit.\n            fractionalPart\
    \ = fractionalPart.Subtract(new BigInteger(1));\n        } else {\n          \
    \  // The number was rounded down, so remove the first digit.\n            fractionalPart\
    \ = fractionalPart.Add(new BigInteger(1));\n        }\n        return fractionalPart.ToSingle();",
  "        BigInteger result = new BigInteger(number);\n        int sign = number.Sign;\n\
    \        if (sign == 0)\n            return number.ToDecimal();\n        int exponent\
    \ = result.BitLength - 1;\n        if (exponent < 0)\n            exponent = 0;\n\
    \        int mantissaBits = exponent + 8;\n        if (mantissaBits < 16)\n  \
    \          mantissaBits = 16;\n        BigInteger mantissa = result.Mask(BigInteger.Zero,\
    \ mantissaBits);\n        BigInteger quotient = BigInteger.DivMod(mantissa, BigInteger.Twice,\
    \ (BigInteger) BigInteger.One);\n        int quotientSign = quotient.Sign;\n \
    \       BigInteger quotientExponent = quotient.BitLength - 1;\n        if (quotientExponent\
    \ < 0)\n            quotientExponent = 0;\n        float quotientMantissa = quotient.ToSingle();\n\
    \        return sign * ((float) quotientMantissa);", "        number *= 1.0f;\n\
    \        BigInteger bi = BigInteger.Parse(number.ToString());\n        bi = bi.Multiply(bi.SignValue\
    \ == 0 ? 1 : -1);\n        BigInteger truncatedBi = bi.Remainder(BigInteger.Two);\n\
    \        return truncatedBi.Value / (float)Math.Pow(10.0f, truncatedBi.Exponent);",
  "        float factor = Float.PositiveInfinity;\n        while (number > factor)\
    \ {\n            number *= 10;\n        }\n        return number;", "        if\
    \ (number < 0) {\n            throw new ArgumentOutOfRangeException(\"number\"\
    );\n        }\n        int intPart = (int)(number);\n        int decimalPart =\
    \ (int)(Math.Ceiling(Math.Abs(number)));\n        return (float)(intPart + decimalPart);",
  "        Debug.Assert(number >= 0.0f);\n        if (number == 0.0f) {\n        \
    \    return 0.0f;\n        }\n        if (number < 0.0f) {\n            return\
    \ number;\n        }\n        // Convert number to a long to prevent overflow\n\
    \        long numberAsLong = number * (long)1.0e9;\n        // Find the highest\
    \ integer smaller than the given number\n        long highestIntegerAsLong = numberAsLong;\n\
    \        while (true) {\n            long temp = highestIntegerAsLong;\n     \
    \       if (temp > numberAsLong) {\n                break;\n            }\n  \
    \          highestIntegerAsLong = temp;\n        }\n        // Find the lowest\
    \ integer larger than the given number\n        long lowestIntegerAsLong = numberAsLong;\n\
    \        while (true) {\n            long temp = lowestIntegerAsLong;\n      \
    \      if (temp < numberAsLong) {\n                break;\n            }\n   \
    \         lowestIntegerAsLong = temp;\n        }\n        // Find the decimal\
    \ part after division of number by 10\n        int decimalPart = (int)((number\
    \ - highestIntegerAsLong) / lowestIntegerAsLong);\n        // Return the decimal\
    \ part\n        return (float)decimalPart;", "        BigInteger integer = new\
    \ BigInteger(number.ToString());\n        float fraction = float.Parse(integer.ToString());\n\
    \        return fraction;", "        Debug.Assert(number >= 0.0f);\n        int\
    \ integerPart = (int) number; // largest integer smaller than given number\n \
    \       int decimalPart = number - integerPart;\n        return decimalPart;",
  "        var numBits = BitConverter.GetBytes(number).Length;\n        Debug.Assert(numBits\
    \ < 4);\n        if (numBits < 4) {\n            // The number is too small to\
    \ be represented as a float.\n            throw new ArgumentOutOfRangeException();\n\
    \        }\n\n        // The IEEE754 standard defines a float as having 24 bits,\
    \ which\n        // is enough to represent all numbers between -(253), +253 inclusively.\n\
    \        // If the number is too big to be represented as a float, we can\n  \
    \      // still return a float and use the fractional part to represent the\n\
    \        // value as a float. \n        //\n        // In a decimal system, we\
    \ define a float as having 52 bits.\n        // If we're dealing with a number\
    \ which is not too big to be\n        // represented as a float, we can still\
    \ use 52 bits to represent it\n        // as an integer. For example we can represent\
    \ 3.5 using 32 bits\n        // as shown below. \n        //\n        // float\
    \ val = 3.5;\n        //\n        // numBits == 52\n        // BitConverter.GetBytes(val).Length\
    \ == 52\n        // BitConverter.GetBytes(val).Length < 4\n        // numBits\
    \ == 24\n        //\n        // So the number is too big to be represented as\
    \ a float.\n\n        // The float number that we would represent 3.5 with is\
    \ represented\n        // by our float as having 52 bits. Our integer part is\
    \ 0x381\n        // and our fraction is 0x371.\n        //\n        // When we\
    \ try to represent this number in binary, we must have\n        // the integer\
    \ part first. The fraction is given to us by the\n        // fractional part.\n\
    \n        // First, convert this float into integer and fraction parts respectively.\n\
    \        var integralPart = BitConverter.GetBytes(number).Reverse().Take(5).ToArray();\n\
    \        var fractionalPart = BitConverter.GetBytes(number).Reverse().Skip(5).Take(32).ToArray();\n\
    \n        // Now calculate the integer part and fraction parts of our\n      \
    \  // float number.\n        // The integer part of the float is given by \n \
    \       // (0x381 & 0xFFFFFFFF)\n        // The fraction part is given by\n  \
    \      // ((0x381 & 0xFFFFFFFF) | (0x371 & 0xFFFFFFFF))\n        var integralPartInt\
    \ = BitConverter.GetBytes(0x381).Reverse().Take(32).ToArray();\n        var fractionalPartInt\
    \ = BitConverter.GetBytes((0x381 & 0xFFFFFFFF) | (0x371 & 0xFFFFFFFF)).Reverse().Take(32).ToArray();\n\
    \n        // Now let's recalculate the float and compare it to the original one.\n\
    \        // ", "        var result = Convert.ToSingle(number);\n        if (number\
    \ >= 0) {\n            var bits = result.ToString(CultureInfo.InvariantCulture).ToCharArray();\n\
    \            bits[bits.Length - 1] = '\\0';\n            return Convert.ToSingle(bits);\n\
    \        }\n        var bits = result.ToString(CultureInfo.InvariantCulture).ToCharArray();\n\
    \        bits[0] = '\\0';\n        return Convert.ToSingle(bits);", "        if\
    \ (number < 0) {\n            return number;\n        }\n        double d = (double)number;\n\
    \        int integerPart = (int)d;\n        double fractional = d - integerPart;\n\
    \        return (float)(integerPart + fractional);", "        int integerPart\
    \ = (int)Math.Ceiling(number);\n        int decimalPart = (int)((number - integerPart)\
    \ * 100.0f);\n        return decimalPart / 100.0f;", "        // First we check\
    \ for negatives since we need to work with positive\n        // numbers. We have\
    \ to make sure we truncate to 0 if the given number\n        // is negative.\n\
    \        if (number < 0) {\n            number *= -1;\n        }\n\n        //\
    \ Get the fractional part and truncate to ensure we don't lose any digits\n  \
    \      double fractionalPart = Math.Truncate(number * 10000) / 10000.0d;\n\n \
    \       // Get the integer part and truncate to the same precision\n        double\
    \ integerPart = Math.Truncate(fractionalPart);\n\n        // Return the truncated\
    \ number\n        return (float)integerPart;", "        var result = new Decimal(number);\n\
    \        var intPart = result.ToInt32(CultureInfo.InvariantCulture);\n       \
    \ return intPart % 1f / 1f;", "        double d = (double)number;\n        int\
    \ integerPart = (int)d;\n        int decimalPart = (int)((d - (double)integerPart)\
    \ * Math.Pow(10, (integerPart > 0 ? 1 : 0)));\n        return decimalPart;", " \
    \       float rounded = Math.Round(number, 4);\n        return rounded;", "  \
    \      long maxValue = (long)Math.Ceiling(number);\n        return maxValue /\
    \ (long)Math.Pow(10, (int)Math.Ceiling(Math.Log10(number)));", "        var intPart\
    \ = number / Int32.MaxValue;\n        var fractPart = number - intPart * Int32.MaxValue;\n\
    \        return fractPart;"]
stop_tokens:
- "\n    }\n"
