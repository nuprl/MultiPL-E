name: HumanEval_26_remove_duplicates
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // From a list of integers, remove all elements that occur more\
  \ than once.\n    // Keep order of elements left the same as in the input.\n   \
  \ // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
  \ (long)2L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L, (long)3L,\
  \ (long)4L}))\n    public static List<long> RemoveDuplicates(List<long> numbers)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(RemoveDuplicates((new\
  \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(RemoveDuplicates((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(RemoveDuplicates((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L,\
  \ (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));\n\
  \    }\n\n}\n"
completions: ["        var seen = new List<long>();\n        foreach (long n in numbers)\
    \ {\n            if (seen.Contains(n)) {\n                numbers.Remove(n);\n\
    \            } else {\n                seen.Add(n);\n            }\n        }\n\
    \        return numbers;", "        if (numbers == null || numbers.Count == 0)\n\
    \            return new List<long>(new long[0]);\n        List<long> result =\
    \ new List<long>(numbers.Count);\n        HashSet<long> seen = new HashSet<long>();\n\
    \        foreach (long n in numbers) {\n            if (!seen.Add(n)) {\n    \
    \            result.Add(n);\n            }\n        }\n        return result;",
  "        long count = 1;\n        var newNumbers = new List<long>(numbers.Count);\n\
    \        foreach (long n in numbers) {\n            if (newNumbers.Contains(n))\
    \ {\n                count++;\n            } else {\n                newNumbers.Add(n);\n\
    \            }\n        }\n        if (count == numbers.Count) {\n           \
    \ return newNumbers;\n        } else {\n            return new List<long>();\n\
    \        }", "        List<long> results = new List<long>();\n        HashSet<long>\
    \ hashset = new HashSet<long>();\n        foreach (long number in numbers) {\n\
    \            if (!hashset.Add(number)) {\n                results.Add(number);\n\
    \            }\n        }\n        return results;", "        List<long> result\
    \ = new List<long>();\n        foreach (long x in numbers) {\n            if (result.Contains(x))\
    \ {\n                continue;\n            }\n            result.Add(x);\n  \
    \      }\n        return result;", "        int maxCount = 0;\n        List<long>\
    \ result = new List<long>();\n        foreach (long number in numbers) {\n   \
    \         if (maxCount == 0) {\n                maxCount = 1;\n              \
    \  result.Add(number);\n            } else {\n                if (maxCount !=\
    \ 1) {\n                    maxCount = 1;\n                    result.Add(number);\n\
    \                }\n                if (number > result.Last()) {\n          \
    \          maxCount++;\n                    result.Add(number);\n            \
    \    }\n            }\n        }\n        return result;", "        List<long>\
    \ results = new List<long>();\n        HashSet<long> seen = new HashSet<long>();\n\
    \n        for (int i = 0; i < numbers.Count; i++) {\n            if (seen.Contains(numbers[i]))\
    \ {\n                continue;\n            }\n            seen.Add(numbers[i]);\n\
    \            results.Add(numbers[i]);\n        }\n        return results;", " \
    \       var groups = numbers.GroupBy(x => x).ToList();\n        var distinctGroups\
    \ = groups.Where(x => x.Count() == 1).ToList();\n        return distinctGroups.Concat(groups.Where(x\
    \ => x.Count() > 1)).ToList();", "        HashSet<long> values = new HashSet<long>();\n\
    \        foreach (long num in numbers)\n            if (values.Add(num))\n   \
    \             numbers.Remove(num);\n        return numbers;", "        var distinct\
    \ = new List<long>();\n        foreach (var number in numbers)\n            if\
    \ (distinct.Contains(number))\n                distinct.Remove(number);\n    \
    \        else\n                distinct.Add(number);\n        return distinct;",
  "        if (numbers.Count < 2)\n            return numbers;\n\n        Dictionary<long,\
    \ List<long>> seenNumbers = new Dictionary<long, List<long>>();\n\n        foreach\
    \ (long n in numbers) {\n            if (seenNumbers.ContainsKey(n)) {\n     \
    \           seenNumbers[n].Add(n);\n            } else {\n                seenNumbers.Add(n,\
    \ new List<long>());\n                seenNumbers[n].Add(n);\n            }\n\
    \        }\n\n        List<long> output = new List<long>();\n\n        foreach\
    \ (long n in seenNumbers.Keys) {\n            if (!seenNumbers[n].Any()) {\n \
    \               output.Add(n);\n            }\n        }\n\n        return output;",
  "        var seen = new HashSet<long>();\n        var result = new List<long>();\n\
    \        foreach (var number in numbers) {\n            if (seen.Add(number))\
    \ {\n                result.Add(number);\n            }\n        }\n        return\
    \ result;", "        List<long> distinctNumbers = new List<long>();\n        long\
    \ numberCount = 0;\n        // Create a hash set\n        HashSet<long> hashSet\
    \ = new HashSet<long>();\n        foreach (long number in numbers) {\n       \
    \     if (!hashSet.Add(number)) {\n                hashSet = new HashSet<long>();\n\
    \                distinctNumbers.Add(number);\n                numberCount++;\n\
    \            }\n        }\n        if (numberCount > 0) {\n            distinctNumbers.AddRange(numbers.Where(n\
    \ => !hashSet.Contains(n)).ToList());\n        }\n        return distinctNumbers;",
  "        int len = numbers.Count;\n        numbers.Sort();\n\n        List<long>\
    \ result = new List<long>();\n        int lastValue = numbers[0];\n        for\
    \ (int i = 1; i < len; i++) {\n            if (numbers[i] == lastValue) {\n  \
    \              continue;\n            }\n            result.Add(numbers[i]);\n\
    \            lastValue = numbers[i];\n        }\n        return result;", "  \
    \      int count = 0;\n        List<long> output = new List<long>();\n       \
    \ foreach (long value in numbers) {\n            if (count == 0 || output.LastOrDefault()\
    \ == value)\n            {\n                output.Add(value);\n             \
    \   count++;\n            }\n            else\n            {\n               \
    \ if (count > 1)\n                {\n                    long prev = output.LastOrDefault();\n\
    \                    output[output.Count - 1] = prev;\n                }\n   \
    \             output.Add(value);\n                count = 1;\n            }\n\
    \        }\n        return output;", "        long[] vals = new long[numbers.Count];\n\
    \        int i = 0;\n        foreach (long n in numbers) {\n            vals[i++]\
    \ = n;\n        }\n        Array.Sort(vals);\n        int j = 0;\n        List<long>\
    \ result = new List<long>();\n        foreach (long n in vals) {\n           \
    \ if (j++ < i) continue;\n            result.Add(n);\n        }\n        return\
    \ result;", "        if (numbers == null || numbers.Count == 0)\n            return\
    \ numbers;\n        HashSet<long> hashSet = new HashSet<long>();\n        List<long>\
    \ result = new List<long>();\n        foreach (long n in numbers) {\n        \
    \    if (hashSet.Add(n)) {\n                result.Add(n);\n            }\n  \
    \      }\n        return result;", "        var result = new List<long>(numbers.Count);\n\
    \        List<long> seen = new List<long>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            if (!seen.Contains(numbers[i])) {\n                seen.Add(numbers[i]);\n\
    \                result.Add(numbers[i]);\n            }\n        }\n        return\
    \ result;", "        var results = new List<long>(numbers);\n\n        // Use\
    \ a HashSet to remove duplicates.  HashSet.Contains returns false if an element\
    \ is present, so no need to check count.\n        HashSet<long> numberSet = new\
    \ HashSet<long>();\n\n        foreach(long number in numbers)\n        {\n   \
    \         if (!numberSet.Contains(number))\n            {\n                results.Remove(number);\n\
    \                numberSet.Add(number);\n            }\n        }\n\n        return\
    \ results;", "        if (numbers.Count == 0) return new List<long>();\n     \
    \   var duplicates = new List<long>();\n        long lastNumber = numbers[0];\n\
    \        bool first = true;\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            if (numbers[i] == lastNumber) {\n                duplicates.Add(lastNumber);\n\
    \                continue;\n            }\n            lastNumber = numbers[i];\n\
    \            if (first) {\n                first = false;\n            } else\
    \ {\n                duplicates.Add(lastNumber);\n            }\n        }\n \
    \       return new List<long>(duplicates.ToArray());", "        HashSet<long>\
    \ uniqueNumbers = new HashSet<long>();\n        foreach (long num in numbers)\
    \ {\n            if (uniqueNumbers.Add(num)) {\n                numbers.Remove(num);\n\
    \            }\n        }\n        return numbers;", "        HashSet<long> numberSet\
    \ = new HashSet<long>(numbers);\n        numbers.Clear();\n        foreach (long\
    \ x in numberSet) {\n            numbers.Add(x);\n        }\n        return numbers;",
  "        if (numbers.Count < 2)\n            return numbers;\n\n        List<long>\
    \ result = new List<long>();\n        List<long> previous = null;\n        long\
    \ first = numbers.First();\n\n        long last = numbers.Last();\n\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            if (numbers.ElementAt(i)\
    \ == first && !previous.Contains(numbers.ElementAt(i))) {\n                result.Add(first);\n\
    \                result.Add(numbers.ElementAt(i));\n                previous.Add(numbers.ElementAt(i));\n\
    \            }\n            else if (numbers.ElementAt(i) == last && previous.Contains(numbers.ElementAt(i)))\
    \ {\n                result.Add(numbers.ElementAt(i));\n            }\n      \
    \      else {\n                previous.Add(numbers.ElementAt(i));\n         \
    \   }\n        }\n        return result;", "        // Use a dictionary to store\
    \ each occurrance of a number\n        var dict = numbers.GroupBy(n => n)\n  \
    \          .ToDictionary(g => g.Key, g => g.Count());\n\n        // Filter each\
    \ number to remove all numbers with frequency of more than 1\n        var numbersWithoutDuplicates\
    \ = numbers.Where(n => !dict.ContainsKey(n));\n\n        // Return result as list\
    \ of longs.\n        return numbersWithoutDuplicates;", "        List<long> result\
    \ = new List<long>(numbers);\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            for (int j = i + 1; j < numbers.Count; j++) {\n             \
    \   if (numbers[i] == numbers[j]) {\n                    result.RemoveAt(j);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return result;", "        var seen = new HashSet<long>();\n        var result\
    \ = new List<long>();\n        foreach (long n in numbers)\n        {\n      \
    \      if (seen.Add(n))\n            {\n                result.Add(n);\n     \
    \       }\n        }\n        return result;", "        List<long> result = new\
    \ List<long>();\n\n        for (int i = 0; i < numbers.Count; i++) {\n       \
    \     long num = numbers[i];\n            if (result.Contains(num)) {\n      \
    \          result.Remove(num);\n            }\n            else {\n          \
    \      result.Add(num);\n            }\n        }\n\n        return result;",
  "        SortedSet<long> seen = new SortedSet<long>();\n        List<long> result\
    \ = new List<long>();\n        foreach (long n in numbers) {\n            if (seen.Contains(n))\
    \ {\n                continue;\n            }\n            seen.Add(n);\n    \
    \        result.Add(n);\n        }\n        return result;", "        var distinct\
    \ = new HashSet<long>();\n        var result = new List<long>();\n        foreach\
    \ (var number in numbers) {\n            if (distinct.Add(number)) {\n       \
    \         result.Add(number);\n            }\n        }\n        return new List<long>(result);",
  "        var uniques = new HashSet<long>();\n        var distinct = new List<long>();\n\
    \        foreach (var number in numbers) {\n            if (!uniques.Contains(number))\
    \ {\n                distinct.Add(number);\n                uniques.Add(number);\n\
    \            }\n        }\n        return new List<long>(distinct);", "      \
    \  // For each duplicate in the list, remove it entirely.\n        List<long>\
    \ removed = new List<long>();\n        bool isDuplicate = false;\n        foreach\
    \ (long number in numbers) {\n            if (isDuplicate) {\n               \
    \ // The duplicate has been removed.\n                removed.Add(number);\n \
    \               isDuplicate = false;\n            } else {\n                //\
    \ The number hasn't yet been removed.\n                if (numbers.Contains(number))\
    \ {\n                    isDuplicate = true;\n                } else {\n     \
    \               // The number hasn't yet been removed. Add the number.\n     \
    \               removed.Add(number);\n                }\n            }\n     \
    \   }\n        return removed;", "        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long n in numbers) {\n            if (set.Add(n))\n        \
    \        set.Remove(n);\n        }\n        return new List<long>(set);", "  \
    \      HashSet<long> hs = new HashSet<long>();\n        List<long> result = new\
    \ List<long>();\n        long count;\n        foreach (long x in numbers) {\n\
    \            count = hs.Count(x => x == x);\n            if (count > 0) {\n  \
    \              hs.Remove(x);\n            } else {\n                result.Add(x);\n\
    \            }\n        }\n        return result;", "        // Make a new list\n\
    \        List<long> newNumbers = new List<long>();\n        // Sort the list so\
    \ that we only go through the list once\n        numbers.Sort();\n\n        //\
    \ Keep track of which numbers we've seen before\n        HashSet<long> seen =\
    \ new HashSet<long>();\n\n        long previousNumber = numbers.First();\n\n \
    \       // Keep going through the list until we see a new number that hasn't \n\
    \        // been seen before\n        while (numbers.Any()) {\n            //\
    \ If this number is new, we add it to the new list\n            if (!seen.Contains(numbers.First()))\
    \ {\n                newNumbers.Add(numbers.First());\n\n                // And\
    \ if it's been seen before, we remove it from the list\n                seen.Add(numbers.First());\n\
    \n                // Otherwise we keep going\n            } else {\n         \
    \       // Remove it from the list\n                numbers.RemoveAt(0);\n   \
    \         }\n        }\n\n        // Return the list we've made\n        return\
    \ newNumbers;", "        if (numbers == null)\n            throw new ArgumentNullException(\"\
    numbers\");\n        if (numbers.Count <= 1)\n            return numbers;\n  \
    \      SortedList<long, long> results = new SortedList<long, long>();\n      \
    \  long total = 0;\n        foreach (long n in numbers)\n        {\n         \
    \   total = total + n;\n            results.Add(total, n);\n        }\n      \
    \  long total2 = results.Sum;\n        foreach (KeyValuePair<long, long> kvp in\
    \ results)\n        {\n            if (kvp.Value != 0)\n            {\n      \
    \          total2 -= kvp.Value;\n                results.Remove(kvp.Key);\n  \
    \          }\n        }\n        List<long> result = new List<long>();\n     \
    \   foreach (KeyValuePair<long, long> kvp in results)\n            result.Add(kvp.Value);\n\
    \        return result;", "        int lastCount = 0;\n        List<long> result\
    \ = new List<long>();\n        foreach (var item in numbers) {\n            int\
    \ count = numbers.Count(n => n == item);\n            if (count > lastCount) {\n\
    \                result.Add(item);\n                lastCount = count;\n     \
    \       }\n        }\n        return result;", "        Debug.Assert(numbers.Count\
    \ > 0);\n        List<long> toRemove = new List<long>();\n        HashSet<long>\
    \ seen = new HashSet<long>();\n        foreach (long number in numbers) {\n  \
    \          if (seen.Add(number)) {\n                toRemove.Add(number);\n  \
    \          }\n        }\n        return toRemove;", "        if (numbers == null\
    \ || numbers.Count == 0) {\n            return numbers;\n        }\n        HashSet<long>\
    \ noDupes = new HashSet<long>();\n        numbers.Sort();\n        for (int i\
    \ = 0; i < numbers.Count; i++) {\n            if (noDupes.Contains(numbers[i]))\
    \ {\n                continue;\n            }\n            noDupes.Add(numbers[i]);\n\
    \        }\n        return new List<long>(noDupes);", "        List<long> result\
    \ = new List<long>(numbers.Count);\n\n        long lastValue = numbers.First();\n\
    \        bool first = true;\n\n        // Loop over all numbers in list\n    \
    \    foreach (long number in numbers) {\n            // If first element, add\
    \ number to result and continue\n            if (first) {\n                result.Add(number);\n\
    \                first = false;\n                continue;\n            }\n\n\
    \            // If number is the same as the last number, remove it from result.\n\
    \            if (number == lastValue) {\n                result.Remove(number);\n\
    \                continue;\n            }\n\n            // Add all subsequent\
    \ numbers that are not equal to last number to result\n            while (result.Count\
    \ > 0 && number != result[result.Count - 1]) {\n                result.Add(number);\n\
    \            }\n\n            // If last value is not equal to number, remove\
    \ it from the list\n            if (number != lastValue) {\n                result.Remove(number);\n\
    \            }\n\n            lastValue = number;\n        }\n\n        return\
    \ result;", "        List<long> result = new List<long>();\n        HashSet<long>\
    \ set = new HashSet<long>();\n        foreach (long num in numbers) {\n      \
    \      if (set.Add(num)) {\n                result.Add(num);\n            }\n\
    \        }\n        return result;", "        List<long> output = new List<long>();\n\
    \        HashSet<long> remove = new HashSet<long>();\n        foreach (long n\
    \ in numbers) {\n            if (remove.Contains(n))\n                continue;\n\
    \            remove.Add(n);\n            output.Add(n);\n        }\n        return\
    \ output;", "        if (numbers == null || numbers.Count == 0)\n            return\
    \ numbers;\n        List<long> uniqueNumbers = new List<long>();\n        List<long>\
    \ dupNumbers = new List<long>();\n        long lastNumber = numbers[0];\n    \
    \    bool found = false;\n        foreach (long number in numbers) {\n       \
    \     if (number == lastNumber) {\n                found = true;\n           \
    \ } else {\n                if (found)\n                    dupNumbers.Add(lastNumber);\n\
    \                found = false;\n            }\n            lastNumber = number;\n\
    \        }\n        if (found)\n            dupNumbers.Add(lastNumber);\n    \
    \    numbers.RemoveRange(0, dupNumbers.Count);\n        foreach (long number in\
    \ dupNumbers)\n            uniqueNumbers.Add(number);\n        return uniqueNumbers;",
  "        List<long> ret = new List<long>();\n        long lastValue = -1;\n    \
    \    bool inSequence = false;\n        foreach (long number in numbers) {\n  \
    \          if (inSequence) {\n                if (number == lastValue + 1) {\n\
    \                    inSequence = false;\n                }\n                else\
    \ {\n                    ret.Add(number);\n                    lastValue = number;\n\
    \                    inSequence = false;\n                }\n            }\n \
    \           else if (number == lastValue + 1) {\n                inSequence =\
    \ true;\n                lastValue = number;\n            }\n            else\
    \ {\n                ret.Add(number);\n            }\n        }\n        return\
    \ ret;", "        numbers.Sort();\n        List<long> result = new List<long>(numbers);\n\
    \        HashSet<long> seen = new HashSet<long>();\n        while (numbers.Any())\
    \ {\n            long current = numbers.First();\n            if (seen.Add(current))\
    \ {\n                numbers.RemoveAt(0);\n            } else {\n            \
    \    seen.Remove(current);\n            }\n            result.Remove(current);\n\
    \        }\n        return result;", "        long first = numbers.First();\n\
    \        long last = numbers.Last();\n        List<long> newNumbers = new List<long>();\n\
    \        long counter = 1;\n        foreach (long number in numbers) {\n     \
    \       if (number == first) continue;\n            if (number == last) break;\n\
    \            if (number != first && number != last) {\n                newNumbers.Add(number);\n\
    \                counter++;\n            }\n        }\n        return newNumbers;",
  "        HashSet<long> seen = new HashSet<long>();\n        List<long> duplicates\
    \ = new List<long>();\n        foreach (long n in numbers)\n        {\n      \
    \      if (seen.Add(n))\n            {\n                duplicates.Add(n);\n \
    \           }\n        }\n        return duplicates;", "        long count = numbers.Where((x)\
    \ => numbers.Contains(x)).Count();\n        var result = new List<long>();\n \
    \       foreach (var n in numbers) {\n            if (numbers.Contains(n)) {\n\
    \                if (n > count) {\n                    result.Add(n);\n      \
    \          } else {\n                    count = count - 1;\n                }\n\
    \            }\n        }\n        return result;", "        if (numbers == null)\
    \ return null;\n        var ret = new List<long>();\n        // Find how many\
    \ times each number occurs.\n        var counts = numbers.GroupBy(i => i).Select(x\
    \ => new { Number = x.Key, Count = x.Count() }).ToList();\n        // Remove the\
    \ number if there are more than 1 occurrences.\n        foreach (var num in counts)\
    \ {\n            if (num.Count > 1) {\n                ret.add(num.Number);\n\
    \            }\n        }\n        // Return the list with elements left in the\
    \ same order as input.\n        return ret;", "        // Sort the list before\
    \ removing dupes\n        numbers.Sort();\n        // Remove all dupes\n     \
    \   var result = new List<long>();\n        long previous = numbers.First();\n\
    \        result.Add(previous);\n        for (int i = 0; i < numbers.Count - 1;\
    \ i++) {\n            if (numbers[i + 1] == previous) {\n                result.Add(numbers[i]);\n\
    \            } else {\n                previous = numbers[i + 1];\n          \
    \  }\n        }\n        return result;", "        long[] hash = new long[numbers.Count];\n\
    \        long temp = 0;\n        int numDuplicates = 0;\n        for (int i =\
    \ 0; i < numbers.Count; i++) {\n            long current = numbers[i];\n     \
    \       // Hash current number.\n            hash[i] = current ^ temp;\n     \
    \       temp = current ^ temp;\n            // Count number of times a number\
    \ occurs.\n            while (hash[numDuplicates + 1] == current) {\n        \
    \        numDuplicates++;\n            }\n        }\n        // Create a result\
    \ list from remaining numbers.\n        List<long> result = new List<long>();\n\
    \        for (int i = 0; i < numDuplicates; i++) {\n            result.Add(hash[i]);\n\
    \        }\n        // Return result list.\n        return result;", "       \
    \ var output = new List<long>();\n        // HashSet doesn't allow duplicate elements,\
    \ so we'll keep track of duplicates\n        var outputSet = new HashSet<long>();\n\
    \        foreach(var number in numbers) {\n            if (outputSet.Contains(number))\
    \ {\n                // Already saw this number, skip it\n                continue;\n\
    \            }\n            // Not yet seen this number, add it\n            outputSet.Add(number);\n\
    \            output.Add(number);\n        }\n        return output;", "      \
    \  if (numbers == null || numbers.Count == 0)\n            return numbers;\n \
    \       long[] hashTable = new long[numbers.Count];\n        for (int i = 0; i\
    \ < numbers.Count; i++) {\n            long currentNumber = numbers[i];\n    \
    \        if (hashTable[currentNumber] != 0) {\n                numbers.RemoveAt(i--);\n\
    \            } else {\n                hashTable[currentNumber] = 1;\n       \
    \     }\n        }\n        return numbers;", "        List<long> results = new\
    \ List<long>();\n        HashSet<long> seen = new HashSet<long>();\n        foreach(long\
    \ n in numbers) {\n            if (seen.Add(n)) {\n                results.Add(n);\n\
    \            }\n        }\n        return results;", "        var seen = new HashSet<long>();\n\
    \        return numbers.GroupBy(n => n, (n, g) => g.Skip(1).Aggregate(0, (a, x)\
    \ => a + (seen.add(x) ? 0 : 1)));", "        HashSet<long> hashSet = new HashSet<long>(numbers);\n\
    \        List<long> result = new List<long>();\n        foreach (long num in hashSet)\n\
    \            result.Add(num);\n        return result;", "        HashSet<long>\
    \ seen = new HashSet<long>();\n        List<long> result = new List<long>(numbers);\n\
    \        foreach (long num in numbers) {\n            if (seen.Add(num)) {\n \
    \               result.Remove(result.IndexOf(num));\n            }\n        }\n\
    \        return result;", "        var groups = numbers.GroupBy(n => n).Where(g\
    \ => g.Count() > 1).Select(x => x.Key).ToList();\n        var result = new List<long>();\n\
    \        foreach(var group in groups) {\n            result.AddRange(numbers);\n\
    \            result.RemoveAll(n => n == group);\n        }\n        return result;",
  "        HashSet<long> hashSet = new HashSet<long>();\n        List<long> output\
    \ = new List<long>();\n        long count = 0;\n        bool done = false;\n \
    \       while (numbers.Count > 0 && !done) {\n            long value = numbers.First();\n\
    \            if (!hashSet.Contains(value)) {\n                hashSet.Add(value);\n\
    \                output.Add(value);\n                count++;\n            }\n\
    \            else {\n                numbers.RemoveFirst();\n            }\n \
    \       }\n        done = true;\n        while (count > 0) {\n            output.Add(numbers.First());\n\
    \            numbers.RemoveAt(0);\n            count--;\n        }\n        return\
    \ output;", "        if (numbers == null || numbers.Count <= 0)\n            throw\
    \ new ArgumentException(\"The numbers list is empty\");\n\n        HashSet<long>\
    \ hashSet = new HashSet<long>();\n        foreach (long num in numbers)\n    \
    \    {\n            if (hashSet.Add(num))\n            {\n                numbers.Remove(num);\n\
    \            }\n        }\n        return numbers;", "        if (numbers == null)\n\
    \            return null;\n        HashSet<long> hashSet = new HashSet<long>();\n\
    \        foreach (long number in numbers) {\n            if (hashSet.Add(number))\
    \ {\n                numbers.Remove(number);\n            }\n        }\n     \
    \   return numbers;", "        var sorted = numbers.OrderBy(n => n);\n\n     \
    \   var result = new List<long>();\n        \n        long prevValue = sorted[0];\n\
    \        int index;\n        for (index = 1; index < sorted.Count; index++) {\n\
    \            var currentValue = sorted[index];\n            if (currentValue !=\
    \ prevValue &&\n                result.Where(x => x == currentValue).Count() ==\
    \ 0) {\n                result.Add(currentValue);\n            }\n           \
    \ prevValue = currentValue;\n        }\n\n        return result;", "        var\
    \ seen = new List<long>(numbers.Count);\n\n        foreach (var number in numbers)\
    \ {\n            if (seen.Contains(number)) {\n                numbers.Remove(number);\n\
    \            } else {\n                seen.Add(number);\n            }\n    \
    \    }\n\n        return numbers;", "        List<long> result = new List<long>();\n\
    \        HashSet<long> seen = new HashSet<long>();\n\n        foreach (long n\
    \ in numbers) {\n            if (!seen.Contains(n)) {\n                seen.Add(n);\n\
    \                result.Add(n);\n            }\n        }\n\n        return result;",
  "        int count = 0;\n        bool found;\n        for (int index = 0; index\
    \ < numbers.Count; index++) {\n            found = false;\n            count =\
    \ 0;\n            for (int subIndex = index + 1; subIndex < numbers.Count; subIndex++)\
    \ {\n                if (numbers[subIndex] == numbers[index]) {\n            \
    \        count++;\n                } else {\n                    break;\n    \
    \            }\n            }\n            if (count == 1) {\n               \
    \ numbers.RemoveAt(index);\n                found = true;\n            }\n   \
    \     }\n        return numbers;", "        var result = new List<long>();\n \
    \       var seen = new Dictionary<long, bool>();\n        foreach (var num in\
    \ numbers) {\n            if (!seen.ContainsKey(num)) {\n                seen.Add(num,\
    \ true);\n                result.Add(num);\n            }\n        }\n       \
    \ return result;", "        var seen = new HashSet<long>();\n        foreach (var\
    \ number in numbers) {\n            if (seen.Add(number)) {\n                numbers.Remove(number);\n\
    \            }\n        }\n        return numbers;", "        var seen = new List<long>();\n\
    \        foreach (var n in numbers) {\n            if (seen.Contains(n)) {\n \
    \               numbers.Remove(numbers.IndexOf(n));\n            } else {\n  \
    \              seen.Add(n);\n            }\n        }\n        return numbers;",
  "        List<long> newList = new List<long>();\n        HashSet<long> set = new\
    \ HashSet<long>();\n        foreach (long num in numbers) {\n            if (!set.Add(num))\
    \ {\n                newList.Add(num);\n            }\n        }\n        return\
    \ newList;", "        List<long> result = new List<long>();\n        long count\
    \ = 1;\n        foreach (long number in numbers) {\n            count += number;\n\
    \            if (count > 1) {\n                result.Add(number);\n         \
    \       count = 1;\n            }\n        }\n        return result;", "     \
    \   var dict = new Dictionary<long, List<long>>();\n        foreach(var number\
    \ in numbers) {\n            if (dict.ContainsKey(number)) {\n               \
    \ dict[number].Add(number);\n            } else {\n                dict[number]\
    \ = new List<long>() { number };\n            }\n        }\n        List<long>\
    \ results = new List<long>();\n        foreach (var pair in dict) {\n        \
    \    results.AddRange(pair.Value);\n        }\n        return results;", "   \
    \     var result = new List<long>();\n        long uniqueCount = 0;\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            long current = numbers[i];\n\
    \            if (numbers.Count(i => i == current) > 1) {\n                long\
    \ newNumber;\n                if (i == numbers.Count - 1) {\n                \
    \    newNumber = numbers[i - 1];\n                } else {\n                 \
    \   newNumber = numbers[i + 1];\n                }\n                uniqueCount++;\n\
    \                if (!result.Contains(newNumber)) {\n                    result.Add(newNumber);\n\
    \                }\n            }\n        }\n        return result.ToList();",
  "        // First, find the duplicate elements.\n        List<long> duplicates =\
    \ new List<long>();\n        foreach (long number in numbers) {\n            if\
    \ (duplicates.Contains(number)) {\n                numbers.Remove(numbers.IndexOf(number));\n\
    \            } else {\n                duplicates.Add(number);\n            }\n\
    \        }\n        return duplicates;", "        if (numbers.Count == 0)\n  \
    \          return new List<long>();\n        if (numbers.Count == 1)\n       \
    \     return numbers;\n        var lookup = new Dictionary<long, int>();\n   \
    \     foreach (var number in numbers) {\n            if (!lookup.ContainsKey(number))\n\
    \                lookup[number] = 0;\n            else\n                lookup[number]++;\n\
    \        }\n        var results = new List<long>();\n        foreach (var item\
    \ in lookup.Where(item => item.Value > 1).OrderBy(item => item.Key))\n       \
    \     results.Add(item.Key);\n        return results;", "        if (numbers ==\
    \ null || numbers.Count == 0)\n            return new List<long>();\n        List<long>\
    \ ret = new List<long>();\n        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long n in numbers) {\n            if (set.Add(n)) {\n      \
    \          ret.Add(n);\n            }\n        }\n        return ret;", "    \
    \    // TODO: Use Linq\n        List<long> result = new List<long>();\n      \
    \  long lastNumber;\n        foreach (long number in numbers) {\n            if\
    \ (number != lastNumber) {\n                lastNumber = number;\n           \
    \     result.Add(number);\n            }\n        }\n        return result;",
  "        // Keep track of how many elements have been seen so far.\n        long\
    \ seen = 0;\n        long current;\n        bool found = false;\n        numbers.Sort();\n\
    \n        for (int i = numbers.Count - 1; i >= 0; --i) {\n            // If we've\
    \ seen this element before, skip it.\n            if (numbers.ElementAt(i) ==\
    \ current) {\n                --i;\n                continue Outerloop;\n    \
    \        }\n            // If we've seen it at least twice, remove it.\n     \
    \       found = numbers[i] > current ? true : false;\n            if (found ==\
    \ false) {\n                current = numbers.ElementAt(i);\n                numbers.RemoveAt(i);\n\
    \                seen++;\n            }\n        }\n\n        // Sort the remaining\
    \ elements (the numbers that haven't been removed yet).\n        numbers.Sort();\n\
    \        foreach (var number in numbers) {\n            Console.Write(number.ToString()\
    \ + \" \");\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"\
    Total numbers: \" + numbers.Count);\n        Console.WriteLine(\"Total seen: \"\
    \ + seen);\n\n        return numbers;", "        HashSet<long> hs = new HashSet<long>();\n\
    \        List<long> result = new List<long>();\n        foreach (long i in numbers)\
    \ {\n            if (!hs.Add(i)) {\n                result.Add(i);\n         \
    \   }\n        }\n        return result;", "        // Set of seen elements\n\
    \        HashSet<long> seen = new HashSet<long>();\n        // Index of current\
    \ element in the input list\n        int i = 0;\n        // Result list\n    \
    \    List<long> result = new List<long>();\n        // Loop through input list\n\
    \        while (i < numbers.Count) {\n            // Add current element to result\
    \ list if it's not in the seen set already\n            if (!seen.Contains(numbers[i]))\n\
    \                result.Add(numbers[i]);\n            // Add current element to\
    \ seen set\n            seen.Add(numbers[i]);\n            // Increment index\n\
    \            i++;\n        }\n        // Return result list\n        return result;",
  "        HashSet<long> set = new HashSet<long>();\n        foreach (long n in numbers)\
    \ {\n            if (!set.Add(n)) {\n                numbers.Remove(n);\n    \
    \        }\n        }\n        return numbers;", "        Dictionary<long, long>\
    \ dict = new Dictionary<long, long>();\n        foreach (var number in numbers)\
    \ {\n            long count = dict[number];\n            dict[number] = (count\
    \ == 0) ? 1 : count + 1;\n        }\n\n        var result = new List<long>();\n\
    \        foreach (var entry in dict)\n        {\n            result.Add(entry.Value);\n\
    \        }\n        return result;", "        var output = new List<long>();\n\
    \n        // Count how many elements have been seen so far\n        var count\
    \ = new Dictionary<long, int>();\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            count[numbers[i]] = (i + 1);\n        }\n\n        // Store current\
    \ item in the output list\n        long item;\n\n        while (numbers.Any())\
    \ {\n            // Iterate through all the elements in the current list\n   \
    \         item = numbers.Take(1).First();\n            if (count.ContainsKey(item))\
    \ {\n                // If the element hasn't been seen before, add it to the\
    \ output\n                // and remove it from current list\n               \
    \ output.Add(item);\n                numbers.Remove(item);\n                count[item]--;\n\
    \            } else {\n                // Otherwise increment the count and remove\
    \ the item from the list\n                count[item] = count[item] + 1;\n   \
    \         }\n        }\n\n        // Return the output list\n        return output;",
  "        Debug.Assert(numbers.Count > 0);\n        var duplicates = numbers.GroupBy(n\
    \ => n).Where(g => g.Count() > 1).Select(g => g.Key).ToList();\n        foreach\
    \ (var number in duplicates) {\n            numbers.Remove(number);\n        }\n\
    \        return numbers;", "        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long i in numbers) {\n            if (set.Add(i)) {\n      \
    \          numbers.Remove(i);\n            }\n        }\n        return new List<long>(numbers);",
  "        long n = numbers.Count;\n        List<long> result = new List<long>(n);\n\
    \n        for (int i = 0; i < n; i++)\n        {\n            long currentCount\
    \ = numbers.Count(x => x == numbers[i]);\n            if (currentCount > 1)\n\
    \            {\n                result.Add(numbers[i]);\n            }\n     \
    \   }\n        return result;", "        // Get a hash set from the list of numbers.\
    \ No need to sort as we\n        // assume that the list is already sorted.\n\
    \        HashSet<long> numberSet = new HashSet<long>(numbers);\n        List<long>\
    \ result = new List<long>();\n        foreach (long num in numberSet) {\n    \
    \        result.Add(num);\n        }\n        return result;", "        List<long>\
    \ ret = new List<long>();\n        long previousValue = 0;\n        bool first\
    \ = true;\n        long previousCount = 0;\n        foreach (long number in numbers)\
    \ {\n            long count = numbers.Count(n => n == number);\n            if\
    \ (first) {\n                ret.Add(number);\n                first = false;\n\
    \            }\n            else {\n                ret.Add((previousCount ==\
    \ 0) ? number : previousValue);\n                ret.Add(number);\n          \
    \  }\n            previousValue = number;\n            previousCount = count;\n\
    \        }\n        long lastValue = ret.Last();\n        ret.AddRange(numbers.Except(ret.OrderBy(i\
    \ => i)).TakeWhile(i => i != lastValue).ToList());\n        return ret;", "  \
    \      var groups = numbers.GroupBy(n => n, (k, v) => new { key, count = v.Count()\
    \ });\n        return groups.Where(g => g.count > 1).Select(g => g.key).ToList();",
  "        var uniqueNumbers = new List<long>();\n        var duplicateNumbers = new\
    \ List<long>();\n        foreach (var number in numbers) {\n            if (!uniqueNumbers.Contains(number))\
    \ {\n                uniqueNumbers.Add(number);\n            } else {\n      \
    \          duplicateNumbers.Add(number);\n            }\n        }\n        return\
    \ uniqueNumbers.Count == numbers.Count ? duplicateNumbers : uniqueNumbers;", " \
    \       List<long> result = new List<long>();\n        List<long> seen = new List<long>();\n\
    \n        // Scan numbers from left side of input.\n        for (int i = 0; i\
    \ < numbers.Count - 1; i++) {\n            long currNum = numbers[i];\n\n    \
    \        // If the current number is not in the seen list, add it and mark\n \
    \           // it seen.  This is done to handle duplicate numbers left after removing\n\
    \            // duplicates.\n            if (!seen.Contains(currNum)) {\n    \
    \            result.Add(currNum);\n                seen.Add(currNum);\n      \
    \      }\n        }\n\n        // Move numbers from seen list to result.\n   \
    \     seen = seen.Skip(1);\n        while (seen.Count > 0) {\n            result.Add(seen[0]);\n\
    \            seen.RemoveAt(0);\n        }\n\n        // Return result.\n     \
    \   return result;", "        List<long> result = new List<long>();\n        numbers.ForEach(x\
    \ => result.Add(x));\n        int index = -1;\n        bool removed = numbers.Remove(x\
    \ => ++index == 0 && result.Remove(x));\n        if (removed) {\n            return\
    \ result;\n        }\n        List<long> removed = new List<long>();\n       \
    \ numbers.ForEach(x => removed.Add(x));\n        index = -1;\n        removed\
    \ = numbers.Remove(x => ++index == 1 && removed.Remove(x));\n        if (removed)\
    \ {\n            return removed;\n        }\n        List<long> removed = new\
    \ List<long>();\n        numbers.ForEach(x => removed.Add(x));\n        index\
    \ = -1;\n        removed = numbers.Remove(x => ++index == 2 && removed.Remove(x));\n\
    \        if (removed) {\n            return removed;\n        }\n        List<long>\
    \ removed = new List<long>();\n        numbers.ForEach(x => removed.Add(x));\n\
    \        index = -1;\n        removed = numbers.Remove(x => ++index == 3 && removed.Remove(x));\n\
    \        if (removed) {\n            return removed;\n        }\n        List<long>\
    \ removed = new List<long>();\n        numbers.ForEach(x => removed.Add(x));\n\
    \        index = -1;\n        removed = numbers.Remove(x => ++index == 4 && removed.Remove(x));\n\
    \        if (removed) {\n            return removed;\n        }\n        List<long>\
    \ removed = new List<long>();\n        numbers.ForEach(x => removed.Add(x));\n\
    \        index = -1;\n        removed = numbers.Remove(x => ++index == 5 && removed.Remove(x));\n\
    \        if (removed) {\n            return removed;\n        }\n        return\
    \ removed;", "        HashSet<long> hashSet = new HashSet<long>();\n        foreach\
    \ (long number in numbers) {\n            hashSet.Add(number);\n        }\n  \
    \      List<long> result = new List<long>();\n        foreach (long number in\
    \ hashSet) {\n            result.Add(number);\n        }\n        return result;",
  "        var output = new List<long>(numbers);\n        HashSet<long> set = new\
    \ HashSet<long>();\n        foreach (long number in output) {\n            if\
    \ (set.Add(number)) {\n                output.Remove(number);\n            }\n\
    \        }\n        return output;", "        if (numbers.Count <= 1)\n      \
    \      return numbers;\n        var result = new List<long>(numbers.Count);\n\
    \        List<long> seen = new List<long>(numbers.Count);\n        foreach (var\
    \ number in numbers) {\n            if (!seen.Contains(number))\n            \
    \    seen.Add(number);\n            else\n                result.Add(number);\n\
    \        }\n        return result;", "        List<long> noDuplicates = new List<long>();\n\
    \        HashSet<long> numberHashSet = new HashSet<long>(numbers);\n        foreach\
    \ (long number in numberHashSet) {\n            noDuplicates.Add(number);\n  \
    \      }\n        return noDuplicates;", "        SortedSet<long> set = new SortedSet<long>();\n\
    \        foreach (long i in numbers)\n            set.Add(i);\n        List<long>\
    \ result = new List<long>();\n        foreach (long i in set)\n            if\
    \ (!result.Contains(i))\n                result.Add(i);\n        return result;",
  "        if (numbers.Count == 0)\n            return new List<long>();\n       \
    \ List<long> uniqueNumbers = new List<long>();\n        List<long> seen = new\
    \ List<long>();\n        long prevValue = numbers[0];\n        bool seenOnce =\
    \ false;\n        foreach (long value in numbers.Skip(1)) {\n            if (seenOnce\
    \ && value == prevValue) {\n                seen.Remove(value);\n            \
    \    prevValue = numbers[0];\n                seenOnce = false;\n            }\
    \ else if (seen.Contains(value)) {\n                seenOnce = true;\n       \
    \     } else {\n                uniqueNumbers.Add(value);\n                seen.Add(value);\n\
    \                prevValue = value;\n            }\n        }\n        return\
    \ uniqueNumbers;", "        List<long> result = new List<long>();\n        HashSet<long>\
    \ seen = new HashSet<long>();\n        foreach (var n in numbers) {\n        \
    \    if (seen.Add(n)) {\n                result.Add(n);\n            }\n     \
    \   }\n        return result;", "        HashSet<long> unique = new HashSet<long>();\n\
    \        List<long> result = new List<long>();\n\n        foreach(long n in numbers)\
    \ {\n            if (unique.Contains(n)) {\n                result.Add(n);\n \
    \           } else {\n                unique.Add(n);\n            }\n        }\n\
    \n        return result;", "        HashSet<long> hs = new HashSet<long>();\n\
    \        foreach (long n in numbers)\n            if (!hs.Add(n))\n          \
    \      numbers.Remove(n);\n        return numbers;", "        Dictionary<long,\
    \ List<long>> list = new Dictionary<long, List<long>>();\n        foreach (var\
    \ num in numbers) {\n            List<long> values;\n            if (!list.TryGetValue(num,\
    \ out values))\n            {\n                values = new List<long>();\n  \
    \              values[num] = num;\n                list[num] = values;\n     \
    \       }\n            else\n            {\n                values.Add(num);\n\
    \            }\n        }\n        return list.Select(x => x.Value).Distinct().ToList();",
  "        var uniques = new HashSet<long>();\n        foreach (var number in numbers)\
    \ {\n            if (uniques.Add(number)) {\n                uniques.Remove(number);\n\
    \            }\n        }\n        return new List<long>(uniques);", "       \
    \ var duplicates = new List<long>();\n        HashSet<long> seen = new HashSet<long>();\n\
    \n        foreach (long number in numbers) {\n            if (seen.Add(number))\
    \ {\n                duplicates.Add(number);\n            }\n        }\n\n   \
    \     return new List<long>(duplicates);", "        Debug.Assert(numbers.Count\
    \ > 0);\n        long lastNumber = numbers.Last();\n        List<long> results\
    \ = new List<long>();\n        for(int i = 0; i < numbers.Count; ++i) {\n    \
    \        long current = numbers[i];\n            if (current == lastNumber) {\n\
    \                continue;\n            }\n            results.Add(current);\n\
    \            lastNumber = current;\n        }\n        return results;", "   \
    \     // Hash table to keep track of elements seen so far.\n        Hashtable\
    \ seen = new Hashtable();\n        // Return original list if there are none left.\n\
    \        if (numbers == null || numbers.Count == 0)\n            return numbers;\n\
    \        // Scan the numbers from left to right.\n        for (int i = 0; i <\
    \ numbers.Count; ++i) {\n            // Add current number to the hash table.\
    \ \n            if (!seen.ContainsKey(numbers[i]))\n                seen.Add(numbers[i],\
    \ new List<long>());\n            // Add this number to the list of numbers seen\
    \ so far.\n            seen[numbers[i]].Add(numbers[i]);\n        }\n        //\
    \ Loop through numbers from the hash table and remove duplicates.\n        List<long>\
    \ result = new List<long>();\n        foreach (DictionaryEntry entry in seen)\
    \ {\n            result.AddRange((List<long>)entry.Value);\n        }\n      \
    \  return result;", "        var seen = new List<long>();\n        foreach (var\
    \ num in numbers) {\n            if (!seen.Contains(num)) {\n                seen.Add(num);\n\
    \            }\n        }\n        return new List<long>(seen);", "        HashSet<long>\
    \ set = new HashSet<long>(numbers);\n        List<long> result = new List<long>();\n\
    \        foreach (long number in set) {\n            if (!result.Contains(number))\
    \ {\n                result.Add(number);\n            }\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        Dictionary<long,\
    \ long> dict = new Dictionary<long, long>();\n        foreach (long number in\
    \ numbers) {\n            if (!dict.ContainsKey(number)) {\n                dict.Add(number,\
    \ number);\n                result.Add(number);\n            }\n            else\
    \ {\n                dict[number]--;\n            }\n        }\n        return\
    \ result;", "        var distinct = new HashSet<long>();\n        foreach (var\
    \ n in numbers) {\n            if (!distinct.Contains(n)) {\n                distinct.Add(n);\n\
    \            }\n        }\n        var output = new List<long>();\n        foreach\
    \ (var n in distinct) {\n            output.Add(n);\n        }\n        return\
    \ output;", "        if (numbers == null || numbers.Count == 0) {\n          \
    \  return null;\n        }\n\n        List<long> result = new List<long>();\n\
    \        HashSet<long> hashSet = new HashSet<long>();\n        foreach (long number\
    \ in numbers) {\n            if (!hashSet.Add(number)) {\n                result.Add(number);\n\
    \            }\n        }\n        return result;", "        long counter = 0;\n\
    \        numbers.RemoveAll(x => numbers.Count(y => (y == x && ++counter) > 1));\n\
    \        return numbers;", "        HashSet<long> hashSet = new HashSet<long>();\n\
    \        List<long> result = new List<long>();\n        foreach(long n in numbers)\
    \ {\n            if (hashSet.Contains(n)) {\n                continue;\n     \
    \       }\n            hashSet.Add(n);\n            result.Add(n);\n        }\n\
    \        return result;", "        long previousValue = 0;\n        int index\
    \ = -1;\n        List<long> results = new List<long>();\n        while (index\
    \ != numbers.Count - 1) {\n            index = numbers.IndexOf(numbers[index],\
    \ index + 1);\n            if (index != numbers.Count - 1) {\n               \
    \ if (numbers[index] == previousValue) {\n                    results.Add(numbers[index]);\n\
    \                    numbers.RemoveAt(index);\n                }\n           \
    \     else {\n                    previousValue = numbers[index];\n          \
    \          index = index;\n                }\n            }\n        }\n     \
    \   return results;", "        HashSet<long> seen = new HashSet<long>();\n   \
    \     var result = new List<long>();\n\n        foreach (var n in numbers) {\n\
    \            if (!seen.Add(n)) {\n                result.Add(n);\n           \
    \ }\n        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        HashSet<long> hashSet = new HashSet<long>();\n        foreach (long number\
    \ in numbers) {\n            if (hashSet.Add(number)) {\n                result.Add(number);\n\
    \            }\n        }\n        return result;", "        List<long> newNumbers\
    \ = new List<long>();\n        Dictionary<long, int> counts = new Dictionary<long,\
    \ int>();\n        numbers.ForEach(x => {\n            if(!counts.ContainsKey(x))\
    \ {\n                counts.Add(x, 1);\n                newNumbers.Add(x);\n \
    \           } else {\n                counts[x]++;\n            }\n        });\n\
    \        return newNumbers;", "        List<long> result = new List<long>();\n\
    \        HashSet<long> set = new HashSet<long>();\n        foreach (long n in\
    \ numbers) {\n            if (set.Add(n)) {\n                result.Add(n);\n\
    \            }\n        }\n        return result;", "        var result = new\
    \ List<long>();\n        long seen = 0;\n        long lastSeen = numbers.First();\n\
    \        foreach (var number in numbers) {\n            if (number == lastSeen)\
    \ {\n                seen++;\n                continue;\n            }\n     \
    \       if (seen > 0) {\n                if (seen == numbers.Count() - 1) {\n\
    \                    // Add the last element in the list.\n                  \
    \  result.Add(lastSeen);\n                }\n                else {\n        \
    \            // Add the last element in the list and the element just before it.\n\
    \                    result.Add(lastSeen);\n                    result.Add(number);\n\
    \                }\n            }\n            else {\n                // Add\
    \ the first element.\n                result.Add(number);\n            }\n   \
    \         lastSeen = number;\n            seen = 1;\n        }\n        return\
    \ result;", "        var result = new List<long>(numbers.Count);\n        HashSet<long>\
    \ unique = new HashSet<long>();\n        foreach (long num in numbers) {\n   \
    \         if (unique.Add(num)) {\n                result.Add(num);\n         \
    \   }\n        }\n        return result;", "        HashSet<long> numberSet =\
    \ new HashSet<long>(numbers);\n        List<long> result = new List<long>();\n\
    \        foreach (long n in numberSet)\n            if (numberSet.Count > 1)\n\
    \                result.Add(n);\n        return result;", "        var grouped\
    \ = numbers.GroupBy(n => n);\n        var duplicates = grouped.Where(g => g.Skip(1).Any());\n\
    \        var nonDuplicates = grouped.Where(g => !g.Skip(1).Any());\n\n       \
    \ foreach (var d in duplicates) {\n            numbers.RemoveAll(n => n == d.Key);\n\
    \        }\n\n        foreach (var n in nonDuplicates) {\n            numbers.RemoveAll(n\
    \ => n == n.First());\n        }\n\n        return numbers;", "        List<long>\
    \ result = new List<long>();\n        long seen = 1;\n        foreach (long n\
    \ in numbers) {\n            if (seen == n) continue;\n            if (result.Contains(n))\
    \ {\n                seen++;\n                continue;\n            }\n     \
    \       seen.Add(n);\n            result.Add(n);\n        }\n        return result;",
  "        List<long> results = new List<long>();\n        HashSet<long> numberSet\
    \ = new HashSet<long>();\n        foreach (long number in numbers) {\n       \
    \     if (!numberSet.Add(number)) {\n                results.Add(number);\n  \
    \          }\n        }\n        return results;", "        List<long> result\
    \ = new List<long>();\n        long value;\n        foreach (var item in numbers)\
    \ {\n            value = item;\n            while (result.Contains(value)) {\n\
    \                value = value + 1;\n            }\n            result.Add(value);\n\
    \        }\n        return result;", "        if (numbers == null || numbers.Count\
    \ == 0) {\n            return null;\n        }\n        List<long> result = new\
    \ List<long>(numbers.Count);\n        bool hasDuplicate = false;\n        long\
    \ previousNumber = numbers.First();\n        foreach (long number in numbers)\
    \ {\n            if (number != previousNumber) {\n                hasDuplicate\
    \ = true;\n            }\n            result.Add(number);\n            previousNumber\
    \ = number;\n        }\n        if (hasDuplicate) {\n            Debug.WriteLine(\"\
    RemoveDuplicates(new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L,\
    \ (long)4L})) returns new List<long>(new long[]{(long)1L, (long)3L, (long)4L})\"\
    );\n            return result;\n        }\n        return null;", "        if\
    \ (numbers == null || numbers.Count <= 1) return numbers;\n        long largest\
    \ = numbers.Max();\n        numbers.RemoveAll(i => i > largest);\n        return\
    \ numbers;", "        List<long> ret = new List<long>();\n\n        bool isFirst\
    \ = true;\n        long lastValue = numbers.First();\n        ret.Add(lastValue);\n\
    \        foreach (long val in numbers) {\n            if (lastValue == val) {\n\
    \                isFirst = false;\n            }\n            else {\n       \
    \         if (isFirst) {\n                    ret.Add(val);\n                \
    \    isFirst = true;\n                }\n                else {\n            \
    \        ret[ret.Count - 1] = val;\n                }\n            }\n       \
    \     lastValue = val;\n        }\n        return ret;", "        // O(n^2) solution\n\
    \        HashSet<long> hs = new HashSet<long>();\n        List<long> result =\
    \ new List<long>();\n        foreach (long num in numbers) {\n            if (hs.Contains(num))\
    \ {\n                continue;\n            }\n            hs.Add(num);\n    \
    \        result.Add(num);\n        }\n        return result;", "        long count\
    \ = numbers.GroupBy(x => x).Count().Where(x => x > 1).Select(x => x.Key).FirstOrDefault();\n\
    \        if(count == 0) return numbers;\n        List<long> removed = new List<long>();\n\
    \        for(int i = 0; i < numbers.Count; i++) {\n            if(numbers.ElementAt(i)\
    \ == removed.ElementAt(i)) continue;\n            removed.Add(numbers.ElementAt(i));\n\
    \        }\n        return removed;", "        var seen = new HashSet<long>();\n\
    \        foreach (var n in numbers)\n        {\n            if (seen.Add(n))\n\
    \                numbers.Remove(n);\n        }\n        return numbers;", "  \
    \      int max = numbers.Max();\n        HashSet<long> uniqueNumbers = new HashSet<long>();\n\
    \n        // Filter duplicate numbers\n        foreach (var number in numbers)\
    \ {\n            if (uniqueNumbers.Add(number)) {\n                numbers = numbers.RemoveAll(n\
    \ => n == number);\n            }\n        }\n\n        // Filter out elements\
    \ that occur more than once\n        numbers = numbers.Where(n => !uniqueNumbers.Contains(n)).ToList();\n\
    \n        // Add duplicates of last number back\n        int maxDuplicates = numbers.Count;\n\
    \        if (max != maxDuplicates) {\n            numbers = numbers.AddRange(Enumerable.Repeat(max,\
    \ maxDuplicates));\n        }\n\n        return numbers;", "        if (numbers\
    \ == null || numbers.Count == 0) return numbers;\n        SortedDictionary<long,\
    \ List<long>> dict = numbers.GroupBy(n => n).ToDictionary(g => g.Key, g => g.ToList());\n\
    \        foreach (var key in dict.Keys)\n            dict[key].Sort();\n     \
    \   List<long> result = new List<long>();\n        int j = 0;\n        for (int\
    \ i = numbers.Count-1; i >= 0; i--) {\n            if (j >= dict[i].Count || dict[i][j]\
    \ == numbers[i]) continue;\n            numbers.RemoveAt(i);\n            int\
    \ k = j;\n            while ((k < dict[i].Count) && (dict[i][k] == numbers[i]))\
    \ k++;\n            if (k > j) j = k;\n            result.Add(numbers[i]);\n \
    \       }\n        return result;", "        // First find the count of each number\n\
    \        var counts = numbers.GroupBy(n => n)\n            .Select(group => new\
    \ { Value = group.Key, Count = group.Count() })\n            .OrderByDescending(item\
    \ => item.Count)\n            .ToList();\n\n        // Now remove the items that\
    \ occur more than once\n        List<long> uniqueNumbers = new List<long>();\n\
    \        foreach (var item in counts) {\n            if (item.Count == 1) {\n\
    \                uniqueNumbers.Add(item.Value);\n            } else {\n      \
    \          for (int i = item.Count - 1; i >= 0; i--) {\n                    if\
    \ (!uniqueNumbers.Contains(numbers[item.Value - i])) {\n                     \
    \   uniqueNumbers.Insert(i, numbers[item.Value - i]);\n                    }\n\
    \                }\n            }\n        }\n\n        return uniqueNumbers;",
  "        if (numbers == null || numbers.Count == 0) return null;\n        List<long>\
    \ toReturn = new List<long>();\n        List<long> seen = new List<long>();\n\
    \        seen = seen.Concat(numbers).ToList();\n        List<long> removedNumbers\
    \ = new List<long>();\n        int counter = 0;\n        foreach (long n in numbers)\
    \ {\n            if (seen.Contains(n)) {\n                toReturn.Add(n);\n \
    \               removedNumbers.Add(n);\n            }\n            else {\n  \
    \              counter++;\n            }\n        }\n        return toReturn;",
  "        Dictionary<long, long> checkedNumbers = new Dictionary<long, long>();\n\
    \        foreach (long number in numbers) {\n            if (checkedNumbers.ContainsKey(number))\
    \ {\n                checkedNumbers[number]--;\n            } else {\n       \
    \         checkedNumbers.Add(number, 1);\n            }\n        }\n        List<long>\
    \ newNumbers = new List<long>();\n        foreach (KeyValuePair<long, long> checkedNumber\
    \ in checkedNumbers) {\n            if (!newNumbers.Contains(checkedNumber.Key))\
    \ {\n                newNumbers.Add(checkedNumber.Key);\n            }\n     \
    \   }\n        return newNumbers;", "        if (numbers == null || numbers.Count\
    \ == 0) {\n            return numbers;\n        }\n        // Create HashSet<T>\
    \ for holding the unique numbers.\n        var result = new HashSet<long>(numbers);\n\
    \        // Remove the numbers from the original list which are in the HashSet\n\
    \        List<long> uniqueNumbers = numbers.Where(number => !result.Contains(number)).ToList();\n\
    \        return uniqueNumbers;", "        HashSet<long> set = new HashSet<long>();\n\
    \        List<long> list = new List<long>();\n        foreach (long n in numbers)\
    \ {\n            if (set.Contains(n))\n                continue;\n           \
    \ set.Add(n);\n            list.Add(n);\n        }\n        return list;", " \
    \       if (numbers.Count < 2) return numbers;\n        if (numbers.Count == 2)\
    \ return new List<long> { numbers[0], numbers[1] };\n        List<long> result\
    \ = new List<long>();\n        List<long> previous = new List<long> { numbers[0]\
    \ };\n        List<long> current;\n        for (int i = 1; i < numbers.Count;\
    \ ++i) {\n            current = new List<long>();\n            current.Add(numbers[i]);\n\
    \            while (current.Count > 1) {\n                if (current.Where(n\
    \ => n == previous.Last()).Count() > 1) {\n                    previous.Add(previous.Last());\n\
    \                    current.RemoveAt(current.Count - 1);\n                } else\
    \ {\n                    previous.Add(current.First());\n                    current.RemoveAt(0);\n\
    \                }\n            }\n            previous.Add(current.First());\n\
    \            result.AddRange(previous);\n        }\n        return result;", " \
    \       List<long> result = new List<long>(numbers.Count);\n        Dictionary<long,\
    \ int> map = new Dictionary<long, int>();\n        foreach (long num in numbers)\
    \ {\n            if (!map.ContainsKey(num)) {\n                result.Add(num);\n\
    \                map[num] = 1;\n            } else {\n                map[num]++;\n\
    \            }\n        }\n        return result;", "        long count = 1;\n\
    \        List<long> newnumbers = new List<long>();\n        bool done = false;\n\
    \        while (count < numbers.Count && done == false) {\n            if (numbers[count]\
    \ == numbers[count - 1]) {\n                count++;\n            } else {\n \
    \               newnumbers.Add(numbers[count]);\n                done = true;\n\
    \            }\n        }\n        return newnumbers;", "        var distinctNumbers\
    \ = new List<long>();\n        foreach (var number in numbers) {\n           \
    \ if (distinctNumbers.Contains(number)) {\n                numbers.Remove(number);\n\
    \            } else {\n                distinctNumbers.Add(number);\n        \
    \    }\n        }\n        return distinctNumbers;", "        var hashset = new\
    \ HashSet<long>(numbers);\n        var result = new List<long>();\n        foreach\
    \ (long x in hashset) {\n            result.Add(x);\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        HashSet<long>\
    \ seen = new HashSet<long>();\n        foreach (long n in numbers) {\n       \
    \     if (seen.Add(n)) {\n                result.Add(n);\n            }\n    \
    \    }\n        return result;", "        HashSet<long> numberSet = new HashSet<long>();\n\
    \        foreach (long number in numbers) {\n            if (numberSet.Add(number))\
    \ {\n                numbers.Remove(number);\n            }\n        }\n     \
    \   return numbers;", "        List<long> result = new List<long>();\n       \
    \ int i = 0, n = numbers.Count;\n        while (i<n) {\n            int j;\n \
    \           for (j=i; j<n && numbers[j]==numbers[i]; j++)\n                ;\n\
    \            if (j==n) result.Add(numbers[i]);\n            i++;\n        }\n\
    \        return result;", "        if (numbers == null) {\n            throw new\
    \ ArgumentNullException(\"numbers\");\n        }\n\n        var result = new List<long>();\n\
    \        long lastValue = numbers.Last();\n        numbers.ToList().RemoveAll(number\
    \ => number != lastValue);\n        numbers.ToList().ForEach(number => result.Add(number));\n\
    \        return result;", "        var duplicates = numbers.GroupBy(n => n).Where(g\
    \ => g.Count() > 1);\n        foreach (var number in duplicates.Keys) {\n    \
    \        numbers.Remove(number);\n        }\n        return numbers;", "     \
    \   if (numbers == null || numbers.Count == 0) return numbers;\n        List<long>\
    \ newNumbers = new List<long>();\n        Dictionary<long, bool> checked = new\
    \ Dictionary<long, bool>();\n        foreach (long num in numbers) {\n       \
    \     if (checked.ContainsKey(num)) {\n                continue;\n           \
    \ }\n            checked.Add(num, false);\n            newNumbers.Add(num);\n\
    \        }\n        return newNumbers;", "        List<long> result = new List<long>();\n\
    \n        // O(n) time and O(1) space\n        HashSet<long> seenNumbers = new\
    \ HashSet<long>();\n        for (int i = 0; i < numbers.Count; i++) {\n      \
    \      long number = numbers[i];\n            if (seenNumbers.Contains(number))\
    \ {\n                result.Add(number);\n            } else {\n             \
    \   seenNumbers.Add(number);\n            }\n        }\n\n        return result;",
  "        if (numbers.Count == 0)\n            return new List<long>();\n       \
    \ // Create buckets where the key is the number and the value is the number count.\n\
    \        var buckets = new Dictionary<long, int>();\n        foreach (var number\
    \ in numbers)\n        {\n            if (buckets.ContainsKey(number))\n     \
    \           buckets[number]++;\n            else\n                buckets[number]\
    \ = 1;\n        }\n        // Scan the buckets until the first element with count\
    \ > 1.\n        var list = new List<long>();\n        for (int i = 1; i < buckets.Count;\
    \ i++)\n        {\n            if (buckets[i] <= 1)\n                break;\n\
    \            list.Add(buckets.ElementAt(i));\n        }\n        // Remove elements\
    \ from bucket until there is only one left\n        for (int i = buckets.Count\
    \ - 1; i >= 1; i--)\n        {\n            if (buckets[i] > 1)\n            \
    \    buckets[i]--;\n            else\n            {\n                list.RemoveAt(i);\n\
    \                buckets.RemoveAt(i);\n            }\n        }\n        // Put\
    \ remaining numbers in the list.\n        for (int i = buckets.Count; i > 1; i--)\n\
    \        {\n            list.Add(buckets.ElementAt(i));\n        }\n        return\
    \ list;", "        if (numbers == null) throw new ArgumentNullException(\"numbers\"\
    );\n        var result = numbers.Distinct().ToList();\n        result.Sort();\n\
    \        return result;", "        Dictionary<long, int> dictionary = new Dictionary<long,\
    \ int>();\n        List<long> result = new List<long>();\n        foreach (var\
    \ number in numbers)\n        {\n            dictionary.Add(number, 0);\n    \
    \    }\n        foreach (var pair in dictionary)\n        {\n            if (pair.Value\
    \ == 1)\n            {\n                result.Add(pair.Key);\n            }\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        HashSet<long> set = new HashSet<long>();\n        foreach (long number\
    \ in numbers) {\n            if (set.Add(number)) {\n                result.Add(number);\n\
    \            }\n        }\n        return result;", "        HashSet<long> hashSet\
    \ = new HashSet<long>();\n        foreach (long n in numbers) {\n            if\
    \ (hashSet.Add(n)) {\n                numbers.Remove(n);\n            }\n    \
    \    }\n        return numbers;", "        if (numbers == null || numbers.Count\
    \ == 0) {\n            return new List<long>();\n        }\n        var distinct\
    \ = new HashSet<long>(numbers);\n        foreach (var number in distinct) {\n\
    \            numbers.Remove(number);\n        }\n        return numbers;", " \
    \       HashSet<long> noDuplicates = new HashSet<long>();\n        List<long>\
    \ duplicateNumbers = new List<long>();\n        foreach (var number in numbers)\
    \ {\n            if (!noDuplicates.Contains(number)) {\n                noDuplicates.Add(number);\n\
    \            } else {\n                duplicateNumbers.Add(number);\n       \
    \     }\n        }\n        return duplicateNumbers;", "        var seen = new\
    \ HashSet<long>();\n        return numbers.Where(x => seen.Add(x)).ToList();",
  "        Dictionary<long, int> seen = new Dictionary<long, int>();\n        long\
    \ previous = numbers.FirstOrDefault();\n        int i = 0;\n\n        foreach\
    \ (long number in numbers) {\n            if (seen.ContainsKey(number)) {\n  \
    \              seen[number]++;\n            } else {\n                seen.Add(number,\
    \ 1);\n            }\n\n            long next = numbers.ElementAtOrDefault(i +\
    \ (seen.ContainsKey(number) ? seen[number] : 0));\n            if (previous !=\
    \ next) {\n                numbers.Remove(previous);\n            }\n        \
    \    previous = next;\n            i++;\n        }\n\n        return numbers;",
  "        var list = new List<long>();\n        // Hash all elements in the list\
    \ so that we won't be doing any comparisons.\n        HashSet<long> set = new\
    \ HashSet<long>(numbers);\n        foreach (long number in numbers) {\n      \
    \      if (!set.Contains(number)) {\n                list.Add(number);\n     \
    \       }\n        }\n        return list;", "        HashSet<long> hashSet =\
    \ new HashSet<long>();\n        List<long> results = new List<long>();\n     \
    \   bool isFirst = true;\n        foreach (long number in numbers) {\n       \
    \     if (!hashSet.Contains(number)) {\n                results.Add(number);\n\
    \                hashSet.Add(number);\n                if (isFirst)\n        \
    \            isFirst = false;\n            }\n        }\n        return results;",
  "        List<long> result = new List<long>();\n\n        long previousNumber =\
    \ 0;\n\n        foreach (long number in numbers) {\n            if (number !=\
    \ previousNumber) {\n                result.Add(number);\n            }\n\n  \
    \          previousNumber = number;\n        }\n\n        return result;", " \
    \       List<long> result = new List<long>();\n\n        HashSet<long> hashes\
    \ = new HashSet<long>();\n        foreach (long i in numbers) {\n            if\
    \ (!hashes.Add(i)) {\n                result.Add(i);\n            }\n        }\n\
    \n        return result;", "        List<long> result = new List<long>();\n  \
    \      HashSet<long> numberSet = new HashSet<long>();\n        for (int i = 0;\
    \ i < numbers.Count; ++i) {\n            long currentNumber = numbers[i];\n  \
    \          if (!numberSet.Add(currentNumber)) {\n                result.Add(currentNumber);\n\
    \            }\n        }\n        return result;", "        if (numbers == null\
    \ || numbers.Count == 0) return null;\n\n        long[] uniqueValues = new long[numbers.Count];\n\
    \n        foreach (long number in numbers) {\n            uniqueValues[uniqueValues.FindIndex(a\
    \ => a == number)] = number;\n        }\n        return new List<long>(uniqueValues);",
  "        // Using a hashing algorithm to remove duplicates.\n        // Hash the\
    \ numbers into a HashSet<int> and then return the numbers as a list.\n       \
    \ // This guarantees the original order of the input numbers.\n        HashSet<long>\
    \ numberSet = new HashSet<long>();\n        numbers.ForEach(n => numberSet.Add(n));\n\
    \        return numbers.ToList();", "        var result = new List<long>();\n\
    \        var seen = new HashSet<long>();\n        foreach (var n in numbers) {\n\
    \            if (seen.Add(n)) {\n                result.Add(n);\n            }\n\
    \        }\n        return result;", "        numbers.Sort();\n        List<long>\
    \ output = new List<long>();\n        long lastNumber;\n        for (int index\
    \ = 0; index < numbers.Count; index++) {\n            if (index == 0) {\n    \
    \            lastNumber = numbers[index];\n                output.Add(lastNumber);\n\
    \                continue;\n            }\n\n            if (lastNumber != numbers[index])\
    \ {\n                output.Add(lastNumber);\n                lastNumber = numbers[index];\n\
    \            }\n        }\n        output.Add(lastNumber);\n\n        return output;",
  "        List<long> ret = new List<long>();\n        long lastNumber = 0;\n\n  \
    \      foreach (long number in numbers) {\n            if (number != lastNumber)\
    \ {\n                lastNumber = number;\n                ret.Add(number);\n\
    \            }\n        }\n\n        return ret;", "        int count = numbers.Distinct().Count();\n\
    \        List<long> answer = new List<long>();\n        for (int i = 0; i < count;\
    \ i++) {\n            answer.Add(numbers.Find(x => x == i));\n        }\n    \
    \    return answer;", "        HashSet<long> hs = new HashSet<long>();\n     \
    \   foreach (var n in numbers)\n        {\n            if (!hs.Contains(n))\n\
    \            {\n                hs.Add(n);\n            }\n        }\n       \
    \ return new List<long>(hs.ToArray());", "        HashSet<long> set = new HashSet<long>();\n\
    \        numbers.Where(item => set.Add(item)).ToList();\n        return numbers;",
  "        if (numbers == null)\n            return null;\n        if (numbers.Count\
    \ == 0)\n            return numbers;\n        if (numbers.Count == 1)\n      \
    \      return numbers;\n        List<long> uniqueNumbers = new List<long>(numbers);\n\
    \        for (int i = 0; i < uniqueNumbers.Count - 1; i++)\n        {\n      \
    \      for (int j = i + 1; j < uniqueNumbers.Count; j++)\n            {\n    \
    \            if (uniqueNumbers[i] == uniqueNumbers[j])\n                {\n  \
    \                  uniqueNumbers.RemoveAt(i);\n                    break;\n  \
    \              }\n            }\n        }\n        return uniqueNumbers;", " \
    \       // If there are any duplicates, remove them by swapping them with any\
    \ element that\n        // occurs less than two times (for example, 4 is swapped\
    \ with 2, and 2 is swapped with 3).\n        if (numbers.Count() == 0 || numbers.Count()\
    \ > numbers.Max()) {\n            return numbers;\n        }\n\n        // Keep\
    \ track of elements that occur less than two times, so we can swap them\n    \
    \    // with the element that occurs twice as many times.\n        List<long>\
    \ lessThanTwoTimes = new List<long>();\n\n        bool swap = false;\n       \
    \ foreach (long number in numbers) {\n            // If we've already seen this\
    \ number less than two times, don't do anything.\n            // Otherwise, swap\
    \ with this number if it occurs twice as many times as it does not.\n        \
    \    if (lessThanTwoTimes.Contains(number)) {\n                continue;\n   \
    \         }\n\n            bool swapTo = false;\n            foreach (long numberLessThanTwoTimes\
    \ in lessThanTwoTimes) {\n                if (numberLessThanTwoTimes == number)\
    \ {\n                    swap = true;\n                    swapTo = true;\n  \
    \                  break;\n                }\n            }\n\n            if\
    \ (swapTo) {\n                numbers.Remove(number);\n            } else {\n\
    \                lessThanTwoTimes.Add(number);\n            }\n        }\n\n \
    \       return numbers;", "        if (numbers.Count == 0)\n            return\
    \ new List<long>();\n        var numHash = new HashSet<long>(numbers);\n     \
    \   List<long> results = new List<long>();\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            if (numHash.Contains(numbers[i]))\n                results.Add(numbers[i]);\n\
    \        return results;", "        // Hashset is much faster than a dictionary\n\
    \        // http://stackoverflow.com/questions/136081/what-is-the-fastest-way-to-remove-duplicates-from-a-list-in-net\n\
    \        var uniqueNumbers = new HashSet<long>();\n        foreach(var number\
    \ in numbers) {\n            // If item isn't in the hash set, add it (this is\
    \ O(1) lookup)\n            if (!uniqueNumbers.Contains(number)) {\n         \
    \       uniqueNumbers.Add(number);\n            }\n        }\n        return new\
    \ List<long>(uniqueNumbers);", "        var dictionary = numbers.ToDictionary(i\
    \ => i);\n        foreach (var key in dictionary.Keys) {\n            dictionary.Remove(key);\n\
    \        }\n        return new List<long>(dictionary.Keys);", "        if (numbers\
    \ == null || numbers.Count == 0)\n            return numbers;\n        List<long>\
    \ result = new List<long>();\n        numbers.Sort();\n        int index = 0;\n\
    \        while (index < numbers.Count - 1) {\n            if (numbers[index] ==\
    \ numbers[index + 1]) {\n                result.Add(numbers[index + 1]);\n   \
    \             index++;\n                continue;\n            }\n           \
    \ result.Add(numbers[index]);\n            index++;\n        }\n        return\
    \ result;", "        var seen = new HashSet<long>();\n        var result = new\
    \ List<long>();\n\n        for (int i = 0; i < numbers.Count; i++) {\n       \
    \     if (seen.Add(numbers[i])) {\n                result.Add(numbers[i]);\n \
    \           }\n        }\n\n        return result;", "        Dictionary<long,\
    \ int> dict = new Dictionary<long, int>();\n        foreach (long n in numbers)\
    \ {\n            if (dict.ContainsKey(n)) {\n                dict[n]++;\n    \
    \        } else {\n                dict.Add(n, 1);\n            }\n        }\n\
    \        List<long> result = new List<long>();\n        foreach (KeyValuePair<long,\
    \ int> item in dict) {\n            if (item.Value == 1) {\n                result.Add(item.Key);\n\
    \            }\n        }\n        return result;", "        var result = new\
    \ List<long>();\n        var seen = new HashSet<long>();\n        foreach (var\
    \ n in numbers) {\n            if (!seen.Add(n)) {\n                result.Add(n);\n\
    \            }\n        }\n        return result;", "        // TODO: Implement\
    \ me!\n        return new List<long>();", "        if (numbers == null || numbers.Count\
    \ == 0)\n            return numbers;\n        var newList = new List<long>();\n\
    \        long last = numbers.First();\n        bool first = true;\n        foreach\
    \ (var num in numbers) {\n            if (num == last)\n                continue;\n\
    \            if (first) {\n                first = false;\n                newList.Add(num);\n\
    \            }\n            else {\n                var found = false;\n     \
    \           foreach (var n in newList) {\n                    if (n == num) {\n\
    \                        found = true;\n                        break;\n     \
    \               }\n                }\n                if (!found)\n          \
    \          newList.Add(num);\n            }\n            last = num;\n       \
    \ }\n        return newList;", "        List<long> result = new List<long>();\n\
    \        // use HashSet to avoid duplicates\n        HashSet<long> uniqueNumbers\
    \ = new HashSet<long>(numbers);\n        foreach (long number in uniqueNumbers)\
    \ {\n            if (uniqueNumbers.Remove(number)) {\n                result.Add(number);\n\
    \            }\n        }\n        return result;", "        var seen = new HashSet<long>();\n\
    \        var result = new List<long>(numbers);\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n        {\n            if (seen.Contains(numbers[i]))\n            {\n\
    \                numbers.RemoveAt(i);\n                i--;\n            }\n \
    \           else\n            {\n                seen.Add(numbers[i]);\n     \
    \       }\n        }\n        return result;", "        HashSet<long> hashSet\
    \ = new HashSet<long>();\n        foreach (long number in numbers) {\n       \
    \     if (hashSet.Contains(number)) {\n                numbers.Remove(numbers.IndexOf(number));\n\
    \            } else {\n                hashSet.Add(number);\n            }\n \
    \       }\n        return numbers;", "        List<long> output = new List<long>(numbers);\n\
    \        HashSet<long> dupes = new HashSet<long>(output);\n        output.RemoveAll(x\
    \ => dupes.Contains(x));\n        return output;", "        Debug.Assert(numbers.Count\
    \ > 0);\n        List<long> result = new List<long>();\n        HashSet<long>\
    \ set = new HashSet<long>();\n\n        foreach (long n in numbers) {\n      \
    \      if (set.Contains(n)) {\n                result.Add(n);\n            } else\
    \ {\n                set.Add(n);\n            }\n        }\n        return result;",
  "        if (numbers == null || numbers.Count < 1)\n            throw new ArgumentException(\"\
    Invalid parameter\", \"numbers\");\n        var seen = new HashSet<long>(numbers);\n\
    \        List<long> result = new List<long>();\n        foreach (long n in numbers)\n\
    \        {\n            if (!seen.Contains(n) && result.IndexOf(n) == -1) result.Add(n);\n\
    \            seen.Add(n);\n        }\n        return result;", "        List<long>\
    \ output = new List<long>();\n        List<long> removed = new List<long>();\n\
    \        HashSet<long> hs = new HashSet<long>();\n        foreach(long n in numbers)\
    \ {\n            if(hs.Contains(n)) {\n                removed.Add(n);\n     \
    \       } else {\n                hs.Add(n);\n                output.Add(n);\n\
    \            }\n        }\n        foreach(long n in removed) {\n            hs.Remove(n);\n\
    \        }\n        return output;", "        if (numbers.Count < 2) return numbers;\n\
    \        var sorted = numbers.OrderByDescending(x => x).Distinct();\n        return\
    \ sorted.Select(x => numbers.RemoveAll(y => y == x).First()).ToList();", "   \
    \     List<long> result = new List<long>();\n        HashSet<long> hashSet = new\
    \ HashSet<long>();\n        foreach (long number in numbers) {\n            if\
    \ (!hashSet.Add(number)) {\n                result.Add(number);\n            }\n\
    \        }\n        return result;", "        List<long> duplicatesRemoved = new\
    \ List<long>();\n\n        // Add every number to the set that has been seen before\n\
    \        HashSet<long> set = new HashSet<long>(numbers);\n\n        // Iterate\
    \ over the numbers in the list one at a time\n        // If the number is not\
    \ in the set, remove it\n        foreach (long num in numbers) {\n           \
    \ if (!set.Contains(num)) {\n                duplicatesRemoved.Add(num);\n   \
    \         }\n            set.Add(num);\n        }\n\n        // Return the new\
    \ list with the duplicates removed\n        return duplicatesRemoved;", "    \
    \    var distinct = new HashSet<long>();\n        return numbers.Where(x => !distinct.Add(x)).ToList();",
  "        // Use HashSet to store unique elements\n        var uniqueNumbers = new\
    \ HashSet<long>(numbers);\n        // Filter out the numbers that are in the set\n\
    \        // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)2L, (long)4L})).Where(n => !uniqueNumbers.Contains(n)))\n  \
    \      // (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))\n       \
    \ var distinctNumbers = numbers.Where(n => !uniqueNumbers.Contains(n)).ToList();\n\
    \n        return distinctNumbers;", "        // Build a hash table from numbers.\n\
    \        Hashtable counts = new Hashtable();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            long number = numbers[i];\n            if (counts.ContainsKey(number))\
    \ {\n                counts[number]++;\n            } else {\n               \
    \ counts.Add(number, 1);\n            }\n        }\n        // Remove items from\
    \ the hash if they have more than two occurrences.\n        List<long> remove\
    \ = new List<long>();\n        foreach (DictionaryEntry entry in counts) {\n \
    \           if (entry.Value > 1) {\n                remove.Add(entry.Key);\n \
    \           }\n        }\n        // Remove original list items containing duplicates.\n\
    \        numbers.RemoveAll(i => remove.Contains(i));\n        return numbers;",
  "        List<long> result = new List<long>();\n        bool first = true;\n   \
    \     foreach (var number in numbers) {\n            if (first) {\n          \
    \      first = false;\n            } else {\n                if (number == result.Last())\
    \ {\n                    result.Remove(result.Last());\n                } else\
    \ {\n                    result.Add(number);\n                }\n            }\n\
    \        }\n        return result;", "        List<long> output = new List<long>();\n\
    \        Dictionary<long, bool> seen = new Dictionary<long, bool>();\n\n     \
    \   // Loop through every element in the input list\n        foreach (long x in\
    \ numbers) {\n            // If we've seen this element before, then ignore it\
    \ (it's been processed before)\n            if (seen.ContainsKey(x)) {\n     \
    \           continue;\n            }\n            // If we've not seen this element\
    \ before, then add it as the new output\n            seen.Add(x, true);\n    \
    \        output.Add(x);\n        }\n        return output;", "        List<long>\
    \ result = new List<long>();\n        long lastNumberWasDuplicate;\n        int\
    \ currentCount;\n        bool lastNumberWasDeleted;\n\n        foreach (long number\
    \ in numbers) {\n            if (lastNumberWasDeleted && currentCount > 1) {\n\
    \                result.Add(number);\n                lastNumberWasDeleted = false;\n\
    \            }\n            else if (lastNumberWasDeleted && currentCount == 1)\
    \ {\n                lastNumberWasDeleted = false;\n            }\n          \
    \  else if (lastNumberWasDeleted && currentCount < 1) {\n                lastNumberWasDeleted\
    \ = false;\n            }\n            else if (number != lastNumberWasDuplicate)\
    \ {\n                result.Add(number);\n                lastNumberWasDuplicate\
    \ = number;\n            }\n            else {\n                currentCount++;\n\
    \            }\n        }\n        return result;", "        int[] count = new\
    \ int[numbers.Count];\n        for (int i = 0; i < numbers.Count; i++) {\n   \
    \         count[numbers[i]] = count[numbers[i]] + 1;\n        }\n        List<long>\
    \ result = new List<long>(numbers);\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            if (count[numbers[i]] == 1) {\n                result.RemoveAt(i);\n\
    \                i--;\n            }\n        }\n        return result;", "  \
    \      // Store results to return\n        List<long> returnValue = new List<long>();\n\
    \n        // Initialize count for element occurances\n        Dictionary<long,\
    \ int> counter = new Dictionary<long, int>();\n        foreach (long num in numbers)\
    \ {\n            counter[num] = counter.ContainsKey(num) ? counter[num] + 1 :\
    \ 1;\n        }\n\n        // Remove duplicates from counter dictionary\n    \
    \    foreach (KeyValuePair<long, int> numPair in counter) {\n            if (numPair.Value\
    \ > 1) {\n                returnValue.Add(numPair.Key);\n                counter.Remove(numPair.Key);\n\
    \            }\n        }\n\n        // Return the result list\n        return\
    \ returnValue;", "        var seen = new HashSet<long>();\n        var duplicates\
    \ = numbers.Where(x => seen.Add(x) && seen.Count > 1).ToList();\n        seen.Clear();\n\
    \        return duplicates;"]
stop_tokens:
- "\n    }\n"
