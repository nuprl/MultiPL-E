name: HumanEval_90_next_smallest
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return null if there\
  \ is no such element.\n    // >>> NextSmallest((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)4L, (long)5L})))\n    // 2L\n    // >>> NextSmallest((new\
  \ List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))\n \
  \   // 2L\n    // >>> NextSmallest((new List<long>()))\n    // null\n    // >>>\
  \ NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))\n    // null\n\
  \    public static Nullable<long> NextSmallest(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L,\
  \ (long)3L, (long)2L}))).Equals(2L));\n    Debug.Assert(NextSmallest((new List<long>())).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L, (long)0L}))).Equals(1L));\n    Debug.Assert(NextSmallest((new List<long>(new\
  \ long[]{(long)1L, (long)1L}))).Equals(null));\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));\n\
  \    }\n\n}\n"
completions: ["        long smallest = null;\n        foreach(long i in lst) {\n \
    \           if (smallest == null || i < smallest) {\n                smallest\
    \ = i;\n            }\n        }\n        return smallest != null ? smallest :\
    \ null;", "        int firstIndex = 0;\n        int secondIndex = 1;\n       \
    \ while (lst.Count() > 0) {\n            if (lst[firstIndex] >= lst[secondIndex])\
    \ {\n                secondIndex++;\n                firstIndex++;\n         \
    \   } else {\n                secondIndex = firstIndex + 1;\n            }\n \
    \       }\n        if (lst[secondIndex] == null) return null;\n        return\
    \ lst[secondIndex];", "        if (lst.Count == 0) {\n            return null;\n\
    \        }\n        long[] arr = lst.ToArray();\n        Array.Sort(arr);\n  \
    \      return lst.ElementAt(1);", '        return lst.SkipWhile(x => x < lst[1]).Skip(1).FirstOrDefault();',
  "        if (lst == null || lst.Count == 0) return null;\n        int n = lst.Count;\n\
    \        if (n % 2 == 0)\n            return (lst[n/2] + lst[n/2+1]) / 2;\n  \
    \      else\n            return lst[n/2];", "        if (lst.Count == 0)\n   \
    \         return null;\n        var sorted = new List<long>(lst);\n        sorted.Sort();\n\
    \        if (sorted.Count > 1)\n            return sorted[1];\n        else\n\
    \            return null;", "        if (lst.Count == 0)\n            return null;\n\
    \        var sorted = lst.OrderBy(x => x).ToList();\n        return sorted.Count\
    \ > 0 ? sorted[1] : null;", "        if (lst.Count == 0)\n            return null;\n\
    \        var min = lst[0];\n        var max = lst[0];\n        for (int i = 1;\
    \ i < lst.Count; ++i) {\n            if (lst[i] < min)\n                min =\
    \ lst[i];\n            if (lst[i] > max)\n                max = lst[i];\n    \
    \    }\n        if (min != max)\n            return max;\n        if (lst.Count\
    \ == 1)\n            return lst[0];\n        var idx = lst.Count - 1;\n      \
    \  long[] arr = new long[lst.Count - 1];\n        for (long i = 0; i < lst.Count\
    \ - 1; i++)\n            arr[i] = lst[i];\n        Array.Sort(arr);\n        idx\
    \ = lst.Count - 1;\n        for (long i = lst.Count - 2; i >= 0; i--) {\n    \
    \        if (arr[i] > arr[idx + 1]) {\n                idx--;\n            }\n\
    \            if (idx < 0)\n                break;\n        }\n        return arr[idx];",
  '        return NextSmallest(lst, 0);', "        \n        // Your code goes here\n\
    \        \n        Nullable<long> res = lst[0];\n        int min = Math.Abs(lst[0])\
    \ + 1;\n        for(int i = 1; i < lst.Count; i++) {\n            if(lst[i] <\
    \ min) {\n                min = Math.Abs(lst[i]) + 1;\n                res = lst[i];\n\
    \            }\n        }\n        \n        return res;", "        if (lst.Count\
    \ == 0)\n            return null;\n        long nextsmallest = new long(lst.Min());\n\
    \        int k = 1;\n        long mindiff = 0;\n        foreach (var el in lst)\
    \ {\n            if (el < nextsmallest) {\n                mindiff = nextsmallest\
    \ - el;\n                nextsmallest = el;\n            }\n            else if\
    \ (mindiff > 0) {\n                mindiff--;\n            }\n            else\
    \ if (el == nextsmallest) {\n                k++;\n            }\n        }\n\
    \        if (k == lst.Count)\n            return nextsmallest;\n        if (k\
    \ < lst.Count)\n            return null;\n        return nextsmallest;", "   \
    \     if (lst == null)\n            return null;\n        Nullable<long> ret =\
    \ lst.Skip(1).Min();\n        if (ret != null)\n            return ret;\n    \
    \    return NextSmallest(lst.Skip(1).Skip(1).FirstOrDefault());", "        if\
    \ (lst.Count > 0) {\n            long[] array = new long[lst.Count];\n       \
    \     int pos = 0;\n            for (int i = 0; i < lst.Count; ++i) {\n      \
    \          array[pos] = lst[i];\n                ++pos;\n            }\n     \
    \       if (pos < array.Length) {\n                long value = array[pos];\n\
    \                for (int i = pos; i < array.Length; ++i) {\n                \
    \    array[i] = array[i + 1];\n                }\n                array[array.Length\
    \ - 1] = value;\n                return array[array.Length - 2];\n           \
    \ }\n        }\n        return null;", "        if (lst.Count == 0) {\n      \
    \      return null;\n        }\n        // Sort the list.\n        List<long>\
    \ lst_sorted = lst.OrderBy(l => (long)(-l)).ToList();\n\n        // Get the 2nd\
    \ smallest element.\n        if (lst_sorted.Count > 2) {\n            return lst_sorted[1];\n\
    \        }\n\n        // If there are no elements, return null.\n        return\
    \ null;", "        if (lst == null || lst.Count < 2) {\n            return null;\n\
    \        }\n\n        long max = lst.Max();\n        long min = lst.Min();\n\n\
    \        if (max == min) {\n            return null;\n        }\n\n        long\
    \ largest = max > min ? max : min;\n\n        if (lst.Skip(1).All(x => x <= largest))\
    \ {\n            return largest;\n        }\n\n        return lst.Skip(1).FirstOrDefault(x\
    \ => x >= largest);", "        Debug.Assert(lst.Count > 0);\n        Debug.Assert(lst[0]\
    \ < lst[1]);\n        int smallest = lst[0];\n        int second = smallest;\n\
    \        for (int i = 0; i < lst.Count - 1; i++) {\n            if (lst[i] < smallest)\
    \ {\n                second = smallest;\n                smallest = lst[i];\n\
    \            } else if (lst[i] > smallest) {\n                second = lst[i];\n\
    \            }\n        }\n        return second == smallest ? null : second;",
  "        int? index = null;\n        foreach (long value in lst)\n            if\
    \ (index == null || value < index.value) {\n                index = value;\n \
    \           }\n\n        if (index.HasValue)\n            return index.Value;\n\
    \        return null;", "        List<long> result = new List<long>();\n     \
    \   long temp = lst.First();\n        long smallest = lst.First();\n        bool\
    \ found = false;\n        foreach (long number in lst) {\n            if (!found)\
    \ {\n                if (number > smallest) {\n                    found = true;\n\
    \                }\n            }\n            if (found) {\n                if\
    \ (number < smallest) {\n                    result.Add(number);\n           \
    \         smallest = number;\n                }\n            }\n            if\
    \ (number > temp) {\n                found = true;\n            }\n          \
    \  temp = number;\n        }\n        if (found) {\n            return result.First();\n\
    \        }\n        return null;", "        long[] nums = new long[lst.Count];\n\
    \        for (int i = 0; i < lst.Count; i++)\n            nums[i] = lst[i];\n\
    \        Array.Sort(nums);\n        return lst.Skip(1).FirstOrDefault();", " \
    \       if (lst.Count == 0) return null;\n        double min = lst[0];\n     \
    \   int minIndex = 0;\n        double minVal = lst[0];\n        for (int i = 1;\
    \ i < lst.Count; i++) {\n            double temp = lst[i];\n            if (temp\
    \ < min) {\n                minVal = min;\n                minIndex = i;\n   \
    \             min = temp;\n            }\n            if (temp == min) {\n   \
    \             if (lst[i] != min) minIndex++;\n            }\n        }\n     \
    \   if (lst.Count > minIndex) {\n            return new Nullable<long>(lst.ElementAt(minIndex));\n\
    \        }\n        return null;", "        long smallest = lst.Min();\n     \
    \   long nextSmallest = lst.SkipWhile(e => e < smallest).Skip(1).FirstOrDefault();\n\
    \        if (nextSmallest == 0L)\n            return null;\n        return nextSmallest;",
  "        long max = lst.Max();\n        long min = 0;\n        long nextMin = min\
    \ + 1;\n        for (long i = min; i <= max; i++) {\n            if (lst.Contains(i))\
    \ {\n                for (long k = i; k < nextMin && lst.Contains(k); k++) {\n\
    \                    if (lst.Contains(k)) {\n                        nextMin =\
    \ k;\n                    }\n                }\n                if (nextMin !=\
    \ min + 1) {\n                    return new long?(long)nextMin;\n           \
    \     }\n            }\n            min = i;\n        }\n        return null;",
  "        if (lst.Count < 2) return null;\n        var result = lst[1];\n       \
    \ for (int i = 2; i < lst.Count; i++)\n            if (lst[i] < result) result\
    \ = lst[i];\n        return result;", "        long smallest = lst.OrderBy(i =>\
    \ i).First();\n        if (lst.Contains(smallest))\n            return lst.Where(i\
    \ => i != smallest).OrderBy(i => i).First();\n        return null;", "       \
    \ if (lst.Count == 0) return null;\n        var first = lst[0];\n        lst.Remove(first);\n\
    \        var secondSmallest = first;\n        foreach (var value in lst) {\n \
    \           if (value < first) {\n                secondSmallest = value;\n  \
    \              break;\n            }\n        }\n        first = null;\n     \
    \   return secondSmallest;", "        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n        var list = new List<long>();\n        list.Add(lst[0]);\n\
    \        for (var i = 1; i < lst.Count; i++) {\n            if (lst[i] < lst[i\
    \ - 1]) {\n                return lst[i];\n            }\n            list.Add(lst[i]);\n\
    \        }\n        return null;", "        long min = lst.Min();\n        if\
    \ (lst.Count == 0)\n            return null;\n        if (lst.Count == 1)\n  \
    \          return min;\n        long newMin = lst.Min();\n        foreach (long\
    \ val in lst) {\n            if (val < min) {\n                newMin = min;\n\
    \                min = val;\n            }\n        }\n        return min;", '        return
    lst.OrderBy(item => item).Skip(1).FirstOrDefault();', "        Nullable<long>\
    \ ret = null;\n        if (lst.Any()) {\n            var first = lst.First();\n\
    \            var lstMin = lst;\n            lstMin.Remove(first);\n          \
    \  if (lstMin.Any())\n                ret = lstMin.First();\n        }\n     \
    \   return ret;", "        // Your code here.\n        // Return null\n      \
    \  if (lst==null)\n        {\n            return null;\n        }\n\n        int\
    \ size = lst.Count;\n        int min = 1;\n        long minItem = lst[0];\n  \
    \      long minItemValue = minItem;\n        long currentMinItem = minItem;\n\
    \        for (int i = 1; i < size; i++)\n        {\n            if (lst[i] < minItem)\n\
    \            {\n                if (lst[i] < minItemValue && (minItemValue < currentMinItem))\n\
    \                {\n                    minItem = lst[i];\n                  \
    \  minItemValue = currentMinItem;\n                    currentMinItem = minItem;\n\
    \                }\n                else if (lst[i] == minItemValue && (minItem\
    \ == currentMinItem))\n                {\n                    minItem = lst[i];\n\
    \                }\n                else\n                {\n                \
    \    return null;\n                }\n            }\n        }\n        return\
    \ minItem;", "        if (lst.Count == 0) return null;\n        if (lst.Count\
    \ == 1) return lst[0];\n        var min_val = lst[0];\n        var min_idx = 0;\n\
    \        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < min_val)\
    \ {\n                min_val = lst[i];\n                min_idx = i;\n       \
    \     }\n        }\n        if (lst.Count > 2) {\n            int len = lst.Count\
    \ - 1;\n            for (int i = 0; i < len; i++) {\n                if (lst[i\
    \ + min_idx] > min_val) {\n                    min_val = lst[i + min_idx];\n \
    \                   min_idx = i + min_idx;\n                }\n            }\n\
    \        }\n        if (min_idx == lst.Count - 1) return null;\n        return\
    \ lst[min_idx + 1];", "        Nullable<long> n = null;\n        if (lst.Count\
    \ > 0) {\n            long x = lst[0];\n            long y = x;\n            for\
    \ (int i = 1; i < lst.Count; i++) {\n                if (lst[i] < y) {\n     \
    \               y = lst[i];\n                }\n            }\n            if\
    \ (y == x) {\n                n = x;\n            } else {\n                n\
    \ = y;\n            }\n        }\n        return n;", "        // Write your code\
    \ here\n        if (lst.Count == 0) {\n            return null;\n        }\n \
    \       var smallest = lst[0];\n        var secondSmallest = null;\n\n       \
    \ for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n\
    \                secondSmallest = smallest;\n                smallest = lst[i];\n\
    \            } else if (lst[i] == smallest) {\n                secondSmallest\
    \ = lst[i];\n            }\n        }\n        return secondSmallest;", "    \
    \    if (lst.Count == 0)\n            return null;\n\n        long smallest =\
    \ lst.Min();\n        long second = smallest;\n        foreach (long x in lst)\n\
    \            if (x > second)\n                second = x;\n        return smallest;",
  "        var min = lst.Min();\n        if (lst.SkipWhile(e => e < min).Skip(1).Any())\
    \ return null;\n        return min;", "        // Your code goes here\n      \
    \  long[] arr = lst.ToArray();\n        if (arr.Length > 2) {\n            long[]\
    \ sorted = arr.OrderBy(x => x).ToArray();\n            long temp = sorted[0];\n\
    \            long min = sorted[1];\n            for (int i = 2; i < sorted.Length;\
    \ i++)\n            {\n                if (sorted[i] < min)\n                {\n\
    \                    min = sorted[i];\n                    temp = sorted[i];\n\
    \                }\n            }\n            return temp;\n        }\n     \
    \   else\n        {\n            return null;\n        }", '        return lst?.OrderBy(x
    => x).Skip(1).FirstOrDefault();', "        using (var md5 = MD5.Create()) {\n\
    \            byte[] buffer = md5.ComputeHash(Encoding.UTF8.GetBytes(lst.Select(x\
    \ => x.ToString()).ToArray()));\n            var builder = new StringBuilder();\n\
    \            for (int i = 0; i < buffer.Length / 4; ++i) {\n                builder.AppendFormat(\"\
    {0:X8}\", BitConverter.ToUInt64(buffer, i * 4));\n            }\n            Console.WriteLine(builder.ToString());\n\
    \            var longArray = Convert.FromBase64String(builder.ToString());\n \
    \           int size = longArray.Length;\n            if (size == 0) {\n     \
    \           return null;\n            }\n            long val = longArray[0];\n\
    \            while (--size > 0) {\n                long a = longArray[size - 1];\n\
    \                long b = longArray[size];\n                if (a != b) {\n  \
    \                  return val;\n                }\n            }\n           \
    \ return null;\n        }", "        if (lst.Count == 0) return null;\n      \
    \  long minVal = lst[0];\n        long nextMin = lst[1];\n        foreach (long\
    \ val in lst.Skip(2))\n        {\n            if (val > minVal) {\n          \
    \      minVal = val;\n                nextMin = minVal;\n            } else if\
    \ (val < minVal) {\n                minVal = val;\n                nextMin = val;\n\
    \            }\n        }\n        return nextMin;", "        long min_val = lst[0];\n\
    \        int min_pos = 0;\n\n        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n\n        for (int i = 1; i < lst.Count; i++) {\n        \
    \    if (lst[i] < min_val) {\n                min_pos = i;\n                min_val\
    \ = lst[i];\n            }\n        }\n\n        if (min_pos != 0) {\n       \
    \     lst[min_pos] = lst[min_pos - 1];\n            lst[min_pos - 1] = null;\n\
    \            return min_val;\n        }\n\n        return null;", "        if\
    \ (lst.Count == 0) {\n            return null;\n        }\n\n        long? smallest\
    \ = lst.Min();\n\n        foreach (var n in lst) {\n            if (n < smallest)\
    \ {\n                smallest = n;\n            }\n        }\n\n        return\
    \ smallest;", "        if (lst.Count <= 0) return null;\n        if (lst.Count\
    \ == 1) return lst[0];\n        long[] arr = lst.ToArray();\n        int len =\
    \ arr.Length;\n        Array.Sort(arr);\n        long res = arr[len-1];\n    \
    \    if (arr[len-2] == res)\n            return arr[len-2];\n        return null;",
  "        // Write code here\n\n        long smallest = lst.First();\n        List<long>\
    \ newList = new List<long>();\n        foreach(long x in lst){\n            if(x<smallest){\n\
    \                smallest = x;\n            }\n            newList.Add(x);\n \
    \       }\n        if (newList.Count>1)\n            return newList.OrderBy(x\
    \ => x).Skip(1).FirstOrDefault();\n        else\n            return null;", " \
    \       if (lst.Count == 0) return null;\n        long min = lst.First();\n  \
    \      long max = lst.Last();\n        if (max == min) return null;\n        bool\
    \ min_inv = !lst.Contains(min);\n        int n = lst.Count - 1;\n        for (long\
    \ i = lst.Count; i > 0; --i) {\n            if (lst.ElementAt(i) == min) {\n \
    \               return lst.ElementAt(n - 1);\n            }\n            if (lst.ElementAt(i)\
    \ < min) {\n                min = lst.ElementAt(i);\n                min_inv =\
    \ !min_inv;\n            }\n            if (lst.ElementAt(i) > max) {\n      \
    \          max = lst.ElementAt(i);\n                min_inv = !min_inv;\n    \
    \        }\n            if (min_inv) --n;\n        }\n        return null;", " \
    \       var smallest = lst[0];\n        var index = lst.IndexOf(smallest);\n \
    \       var previous = lst.ElementAt(index - 1);\n        if(previous == null)\
    \ {\n            return null;\n        }\n        long tmp = previous;\n     \
    \   previous = lst.ElementAt(index - 2);\n        if(previous != null) {\n   \
    \         tmp = previous;\n        }\n        var next = lst.ElementAt(index +\
    \ 1);\n        if(next == null) {\n            return previous;\n        }\n \
    \       tmp = next.CompareTo(previous);\n        return tmp < 0 ? previous : next;",
  "        if (lst?.Count != 0) \n            return lst[1+lst.Min(x => x - lst[0]).ToArray().Length-1];\n\
    \        return null;", "        // Write your code here\n        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n\n        long min = lst[0];\n\
    \        long min2 = lst[1];\n\n        for (int i = 2; i < lst.Count; i++) {\n\
    \            if (lst[i] < min) {\n                min2 = min;\n              \
    \  min = lst[i];\n            } else if (lst[i] < min2) {\n                min2\
    \ = lst[i];\n            }\n        }\n\n        if (min2 < min) {\n         \
    \   return null;\n        }\n\n        return min2;", '        return lst.Skip(1).FirstOrDefault();',
  "        if (lst.Count == 0) {\n            return null;\n        }\n        long\
    \ minValue = lst[0];\n        long minPosition = lst.Count - 1;\n        bool\
    \ firstElement = lst.FirstOrDefault();\n        if (firstElement == minValue)\
    \ {\n            return firstElement;\n        }\n        foreach (long value\
    \ in lst) {\n            if (value < minValue || (value < minValue && value >\
    \ minPosition)) {\n                minValue = value;\n                minPosition\
    \ = lst.IndexOf(value);\n            }\n        }\n        if (minPosition ==\
    \ lst.Count - 1) {\n            return null;\n        }\n        return lst.ElementAt(minPosition\
    \ + 2);", "        var sortedLst = lst.OrderBy(l => (long)(Math.Abs(l)));\n  \
    \      if (sortedLst.Count == 0)\n            return null;\n        return sortedLst[sortedLst.Count\
    \ - 2];", "        long lowest = lst.Min();\n        int highest = lst.Max();\n\
    \        if (highest < lst.Count) {\n            lst = (from x in lst\n      \
    \              let y = x - 1\n                    let z = x - 2\n            \
    \        let a = y - z\n                    let b = y + z\n                  \
    \  where a > lowest\n                    where b > lowest\n                  \
    \  where a <= highest\n                    where b <= highest\n              \
    \      let c = y - 1\n                    let d = y + 1\n                    where\
    \ c > lowest\n                    where d > lowest\n                    where\
    \ c <= highest\n                    where d <= highest\n                    where\
    \ a == c\n                    where b == c\n                    let e = y - 1\n\
    \                    let f = y + 1\n                    where e > lowest\n   \
    \                 where f > lowest\n                    where e <= highest\n \
    \                   where f <= highest\n                    where f == e\n   \
    \                 let g = (y % 2) == 0\n                    let h = (y % 3) ==\
    \ 0\n                    let i = g == h\n                    let k = y % 2 !=\
    \ 0 && y % 3 != 0\n                    let l = y % 2 != 0 && y % 3 != 1\n    \
    \                let m = y % 2 == 1 && y % 3 == 0\n                    let n =\
    \ y % 2 == 1 && y % 3 == 1\n                    where i != k && i != l && i !=\
    \ m && i != n\n                    select x).ToList();\n        }\n        if\
    \ (lst.Count == 0) {\n            return null;\n        }\n        return lst[lst[0]];",
  "        int smallest = lst.Min();\n        int idx = lst.FindIndex(x => x < smallest);\n\
    \        if (idx == -1) return null;\n        if (idx < lst.Count - 1) return\
    \ lst[idx+1];\n        return null;", "        if (lst.Count < 2) return null;\n\
    \        long min = lst.Min();\n        long max = lst.Max();\n        long mid\
    \ = (max + min) / 2;\n        if (min > max) return mid;\n        if (min == max)\
    \ return null;\n        long right = lst.Skip(1).FirstOrDefault();\n        long\
    \ left = lst.Skip(2).FirstOrDefault();\n        if (right > left && right == mid)\
    \ return right;\n        if (right > left) return right;\n        if (left ==\
    \ mid) return left;\n        if (left < mid) return left;\n        return null;",
  "        if (lst.Count == 0)\n            return null;\n        long min = lst.Min();\n\
    \        int count = 0;\n        for (long i = min; i <= lst.Max(); i++) {\n \
    \           if (lst.Contains(i)) {\n                count++;\n               \
    \ if (count >= 2) return i;\n            }\n        }\n        return null;",
  "        if(lst.Count == 0) return null;\n        long current = lst[0];\n     \
    \   int index = 0;\n        foreach(long value in lst)\n            if( value\
    \ < current ) {\n                current = value;\n                index = index;\n\
    \            }\n        if( index == 2 )\n            return current;\n      \
    \  else\n            return NextSmallest(new List<long>(lst.Skip(index).ToArray()));",
  "        if (lst.Count <= 1) return null;\n        long val = lst[1];\n        lst.RemoveAt(1);\n\
    \        return val;", "        if (lst.Count == 0) {\n            return null;\n\
    \        }\n        long smallest = lst[0];\n        long secondSmallest = lst[0];\n\
    \        long thirdSmallest = lst[0];\n        foreach (long i in lst) {\n   \
    \         if (i < smallest) {\n                secondSmallest = smallest;\n  \
    \              thirdSmallest = secondSmallest;\n                smallest = i;\n\
    \            } else if (i < secondSmallest) {\n                secondSmallest\
    \ = i;\n                thirdSmallest = secondSmallest;\n            } else if\
    \ (i < thirdSmallest) {\n                thirdSmallest = i;\n            }\n \
    \       }\n        if (secondSmallest != smallest) {\n            return secondSmallest;\n\
    \        } else {\n            return thirdSmallest;\n        }", "        if\
    \ (lst.Count <= 0) {\n            return null;\n        }\n        if (lst.Count\
    \ == 1) {\n            return lst[0];\n        }\n        var nsmallest = lst[0];\n\
    \        var lstIndex = lst.IndexOf(nsmallest);\n        foreach (var item in\
    \ lst.Skip(1)) {\n            if (lstIndex > lst.IndexOf(item)) {\n          \
    \      break;\n            }\n            nsmallest = item;\n            lstIndex\
    \ = lst.IndexOf(nsmallest);\n        }\n        return nsmallest;", "        if\
    \ (lst.Count > 0) {\n            var min = lst.Min();\n            var max = lst.Max();\n\
    \            if (min <= max) {\n                return min;\n            } else\
    \ {\n                var middle = lst.Count() / 2;\n                if (middle\
    \ > 1) {\n                    return NextSmallest(lst.GetRange(2 * middle, 2 *\
    \ middle));\n                } else if (middle > 0) {\n                    var\
    \ mid = lst.GetRange(0, middle);\n                    return mid.Min();\n    \
    \            } else {\n                    return null;\n                }\n \
    \           }\n        } else {\n            return null;\n        }", "     \
    \   if (lst.Count < 2) {\n            return null;\n        }\n        long min\
    \ = lst.Min();\n        long max = lst.Max();\n        if (min > max) {\n    \
    \        return null;\n        }\n        long secondMin = lst.Skip(1).Take(1).FirstOrDefault();\n\
    \        if (secondMin == min) {\n            return null;\n        }\n      \
    \  return secondMin;", '        return lst.OrderBy(x => x).Skip(1).FirstOrDefault();',
  "        if (lst.Count == 0) return null;\n        var x = lst[0], min = x;\n  \
    \      foreach (var i in lst.Skip(1))\n            if (i < min)\n            \
    \    min = i;\n        else\n            return null;\n        if (min == x) return\
    \ null;\n        return min;", "        long smallest = lst.Min();\n        long\
    \ nextSmallest = null;\n        if (smallest == lst.Max()) {\n            return\
    \ null;\n        }\n        bool isSmallest = true;\n        foreach (long val\
    \ in lst) {\n            if (val <= smallest) {\n                isSmallest =\
    \ false;\n            }\n        }\n        if (isSmallest) {\n            nextSmallest\
    \ = smallest;\n            foreach (long val in lst) {\n                if (val\
    \ > smallest) {\n                    nextSmallest = val;\n                   \
    \ break;\n                }\n            }\n        }\n        return nextSmallest;",
  "        long smallest = lst.Min();\n        if (lst.Count == 0) {\n           \
    \ return null;\n        }\n        if (lst.Count() == 1) {\n            return\
    \ lst[0];\n        }\n        for (int i = 1; i < lst.Count(); i++) {\n      \
    \      if (lst[i] < smallest) {\n                smallest = lst[i];\n        \
    \    }\n        }\n        return smallest;", "        if (lst.Count == 0)\n \
    \           return null;\n        long largest = lst.Max();\n        if (largest\
    \ == 0 || largest == lst.Count)\n            return null;\n        List<long>\
    \ lst2 = lst.Where(x => x < largest).ToList();\n        if (lst2.Count == 0)\n\
    \            return null;\n        long smallest = lst2.Min();\n        if (smallest\
    \ == 0 || smallest == lst2.Count)\n            return null;\n        long next\
    \ = lst.Find(x => x == smallest);\n        if (next == smallest)\n           \
    \ return null;\n        return next;", "        // Write your code here.\n   \
    \     if (lst.Count < 2) return null;\n        var sortedList = lst.OrderBy(i\
    \ => i).ToList();\n        if (sortedList[1] > sortedList[0]) return sortedList[1];\n\
    \        return sortedList[0];", "        if (lst.Count == 0)\n            return\
    \ null;\n        long min = lst.Min();\n        long minIndex = lst.IndexOf(min);\n\
    \        if (minIndex < lst.Count - 1) {\n            long nextSmallest = lst[minIndex\
    \ + 1];\n            if (nextSmallest < min) {\n                return nextSmallest;\n\
    \            } else {\n                return null;\n            }\n        }\
    \ else {\n            return null;\n        }", "        long max = lst.Max();\n\
    \        long min = lst.Min();\n        List<long> list = new List<long>();\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            long temp = lst[i];\n\
    \            if (temp > max) max = temp;\n            if (temp < min) min = temp;\n\
    \            list.Add(temp);\n        }\n        bool found = false;\n       \
    \ for (int i = 0; i < list.Count; i++) {\n            if (list[i] == max) {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if (found) {\n            return max;\n        }\n        long result\
    \ = lst.Min();\n        long max2 = lst.Max();\n        for (int i = 0; i < list.Count;\
    \ i++) {\n            if (list[i] != max2) {\n                if (list[i] < result)\
    \ {\n                    result = list[i];\n                }\n              \
    \  if (list[i] > max2) {\n                    max2 = list[i];\n              \
    \  }\n            }\n        }\n        if (result != lst.Min()) {\n         \
    \   return null;\n        }\n        return result;", "        int i = 1;\n  \
    \      if (lst.Count > 0) {\n            long tmp = lst[0];\n            while\
    \ (i < lst.Count) {\n                if (lst[i] < tmp)\n                    return\
    \ tmp;\n                i++;\n            }\n        }\n        return null;",
  "        if (lst==null || lst.Count == 0) return null;\n        if (lst.Count <=\
    \ 2) return lst[1];\n        long min = lst[0];\n        long max = lst[0];\n\
    \        long val = lst[1];\n        for (int i = 1; i < lst.Count; ++i) {\n \
    \           if (lst[i] < val) val = lst[i];\n            if (lst[i] > max) max\
    \ = lst[i];\n        }\n        Debug.Assert(val == max);\n        return max;",
  "        var smallest = lst.OrderBy(x => x).FirstOrDefault();\n        if (smallest\
    \ == null) return null;\n        if (smallest.NextSmallest() == null) {\n    \
    \        return smallest;\n        } else {\n            return smallest.NextSmallest();\n\
    \        }", "        if (lst.Count == 0) return null;\n        if (lst.Count\
    \ == 1) return lst[0];\n        var arr = lst.ToArray();\n        var smallest\
    \ = arr[0];\n        var smallestIdx = 0;\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            var temp = arr[i];\n            if (temp < smallest) {\n\
    \                smallest = temp;\n                smallestIdx = i;\n        \
    \    }\n        }\n        if (smallest == arr[0]) return null;\n        return\
    \ arr[smallestIdx];", "        long maxLst = lst.Max();\n        if (maxLst ==\
    \ 0L)\n            return null;\n\n        long minLst = lst.Min();\n        if\
    \ (minLst == 0L)\n            return null;\n\n        long minLstIdx = 0;\n  \
    \      long maxLstIdx = 0;\n        for (long i = lst.Count - 1; i >= 0; i--)\
    \ {\n            long current = lst[i];\n            if (current < minLst) {\n\
    \                minLstIdx = i;\n                minLst = current;\n         \
    \   }\n            if (current > maxLst) {\n                maxLstIdx = i;\n \
    \               maxLst = current;\n            }\n        }\n\n        if (minLstIdx\
    \ >= maxLstIdx)\n            return null;\n\n        if (minLst == 0L)\n     \
    \       return null;\n\n        return lst[minLstIdx];", "        if (lst.Count\
    \ == 0) return null;\n        var smallest = lst.OrderBy(n => n).FirstOrDefault();\n\
    \        if (smallest == null) return null;\n        int index = lst.IndexOf(smallest);\n\
    \        int secondSmallest = lst.Skip(index).Take(2).Select(n => n).Min();\n\
    \        if (secondSmallest == smallest) {\n            secondSmallest = lst.Skip(index).Skip(1).Take(2).Select(n\
    \ => n).Min();\n        }\n        if (secondSmallest == smallest) return null;\n\
    \        return smallest;", "        long curr = lst[0], min = lst[0];\n     \
    \   foreach (var item in lst) {\n            if (item < curr) {\n            \
    \    curr = item;\n                min = item;\n            } else if (item <\
    \ min) {\n                min = item;\n            }\n        }\n        if (lst.Count\
    \ > 0) {\n            lst[lst.Count - 1] = min;\n        }\n        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n        return min;", "      \
    \  if (lst.Count == 0)\n            return null;\n        Nullable<long> ret =\
    \ null;\n        long smallest = lst[0];\n        long largest = lst[lst.Count\
    \ - 1];\n        foreach (var item in lst) {\n            if (smallest * 2 > item)\n\
    \                smallest = item;\n            else if (smallest * 2 < item)\n\
    \                largest = item;\n        }\n        if (smallest * 2 > largest)\n\
    \            ret = smallest;\n        else\n            ret = largest;\n     \
    \   return ret;", "        if (lst.Count == 0) return null;\n        long[] arr\
    \ = lst.ToArray();\n        Array.Sort(arr);\n        if (arr[0] != arr[1]) {\n\
    \            return arr[1];\n        }\n        return null;", "        Nullable<long>\
    \ ret = null;\n        if (lst?.Count > 0) ret = lst[1];\n        return ret?.NextOrDefault(a\
    \ => a == lst[0]);", "        if (lst==null || lst.Count == 0) {\n           \
    \ return null;\n        }\n        if (lst.Count == 1) { // if lst.Count == 1\n\
    \            return lst[0];\n        }\n        long[] nums = lst.ToArray();\n\
    \        int m = nums.Length;\n        long[] nums2 = new long[m];\n        nums2[0]\
    \ = (long)Math.Min(nums[0], nums[1]);\n        int i = 0;\n        for (i=2; i<m;\
    \ i++) {\n            nums2[i] = Math.Min(nums[i], nums[i-1]);\n        }\n  \
    \      long smallest = nums2[0];\n        for (int j = 1; j < m; j++){\n     \
    \       if (nums2[j] < smallest) {\n                smallest = nums2[j];\n   \
    \         }\n        }\n        return smallest;", "        if (lst.Count == 0)\n\
    \            return null;\n        long curr = lst[0];\n        long min = curr;\
    \ // min is the smallest element in the list\n        long nxt = curr; // nxt\
    \ is the element from the list that we're going to move through next.\n      \
    \  for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < min) {\n  \
    \              min = lst[i];\n                nxt = lst[i];\n            } else\
    \ {\n                long tmp = lst[i];\n                lst[i] = nxt;\n     \
    \           nxt = tmp;\n            }\n        }\n        if (nxt > curr)\n  \
    \          return null;\n        else\n            return nxt;", "        Nullable<long>\
    \ min = null;\n        if (lst.Any()) {\n            min = lst[lst.Count - 1];\n\
    \            for (int i = lst.Count - 2; i >= 0; i--) {\n                if (lst[i]\
    \ < min) {\n                    min = lst[i];\n                }\n           \
    \ }\n        }\n        return min;", "        var minI = lst.IndexOf(lst.Min());\n\
    \        if (minI == -1) return null;\n        var min = lst.Min();\n        lst.RemoveAt(minI);\n\
    \        var min2 = lst.Min();\n        lst.Insert(minI, min);\n        lst.Insert(min2,\
    \ min);\n        return min2;", "        long max = lst.Max();\n        long min\
    \ = lst.Min();\n        if (min == max) {\n            return null;\n        }\n\
    \        long smallest = min;\n        long cur = max;\n        while (smallest\
    \ != cur && cur != 0) {\n            cur = cur - 1;\n            if (cur > smallest)\
    \ {\n                return null;\n            }\n            smallest = cur;\n\
    \        }\n        return smallest;", "        long smallest = lst.Min();\n \
    \       long smallest2 = lst.Min();\n        for (int i = 0; i < lst.Count; i++)\
    \ {\n            if (lst.ElementAt(i) < smallest) {\n                smallest2\
    \ = smallest;\n                smallest = lst.ElementAt(i);\n            }\n \
    \           else if (lst.ElementAt(i) < smallest2) {\n                smallest2\
    \ = lst.ElementAt(i);\n            }\n        }\n        return smallest2;", " \
    \       long? smallest = lst.First();\n        foreach (var item in lst.Skip(1)){\n\
    \            long? temp = smallest;\n            if (item < smallest) {\n    \
    \            smallest = item;\n            }\n            if (temp != null){\n\
    \                return temp;\n            }\n        }\n        return null;",
  "        if (lst.Count == 0) return null;\n        int index = lst.Count - 1;\n\
    \        while (index >= 0) {\n            if (lst[index] < lst[index + 1]) {\n\
    \                long tmp = lst[index];\n                lst[index] = lst[index\
    \ + 1];\n                lst[index + 1] = tmp;\n            } else {\n       \
    \         index--;\n            }\n        }\n        return lst[index + 1];",
  "        if (lst.Count == 0)\n            return null;\n        Nullable<long> smallest\
    \ = lst[0];\n        Nullable<long> secondSmallest = null;\n        foreach (var\
    \ item in lst.Skip(1))\n        {\n            Nullable<long> diff = item - smallest;\n\
    \            if (diff == 0L)\n            {\n                secondSmallest =\
    \ smallest;\n                break;\n            }\n            if (diff < 0L)\n\
    \            {\n                secondSmallest = null;\n                break;\n\
    \            }\n            secondSmallest = smallest;\n            smallest =\
    \ item;\n        }\n        if (secondSmallest != null)\n            return secondSmallest;\n\
    \        if (smallest == 0L)\n            return null;\n        return smallest;",
  "        long[] arr = lst.ToArray();\n        // find next smallest in array\n \
    \       for (int i = arr.Length - 1; i > 0; --i) {\n            long x = arr[i];\n\
    \            if (x < arr[(i - 1)]) {\n                long y = arr[(i - 1)];\n\
    \                arr[i] = y;\n                arr[(i - 1)] = x;\n            }\n\
    \        }\n        return arr[0];", "        // Write your code here\n      \
    \  if (lst.Count == 0)\n            return null;\n        if (lst.Count == 1)\n\
    \            return lst[0];\n\n        var pivot = lst[0];\n        var lesser\
    \ = lst[1];\n        var greater = lst[1];\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < pivot) {\n                lesser = lst[i];\n\
    \            }\n            else if (lst[i] > pivot) {\n                greater\
    \ = lst[i];\n            }\n        }\n        if (lesser < pivot)\n         \
    \   return lesser;\n        else if (greater < pivot)\n            return greater;\n\
    \        else\n            return null;", "        SortedDictionary<long, long>\
    \ sortedDict = new SortedDictionary<long, long>();\n\n        foreach (long l\
    \ in lst) {\n            if (sortedDict.ContainsKey(l))\n                sortedDict[l]++;\n\
    \            else\n                sortedDict.Add(l, 1);\n        }\n\n      \
    \  SortedDictionary<long, long> sortedDict2 = new SortedDictionary<long, long>();\n\
    \n        foreach (long l in sortedDict) {\n            if (sortedDict2.ContainsKey(l))\n\
    \                sortedDict2[l]++;\n            else\n                sortedDict2.Add(l,\
    \ 1);\n        }\n        if (sortedDict.Count == 0)\n            return null;\n\
    \        if (sortedDict2.Count > 0 && sortedDict2[sortedDict.FirstKey()] == sortedDict.LastValue())\n\
    \            return sortedDict.FirstKey();\n        if (sortedDict2.Count > 0\
    \ && sortedDict2[sortedDict.FirstKey()] > sortedDict.LastValue())\n          \
    \  return sortedDict2.FirstKey();\n        if (sortedDict2.Count < sortedDict.Count)\n\
    \            return null;\n        return sortedDict2.FirstKey();", "        if\
    \ (lst.Count < 2)\n            return null;\n        else\n            return\
    \ lst.Where(l => l < lst.Skip(1).Take(1).Single()).SingleOrDefault();", "    \
    \    if (lst.Count <= 0) {\n            return null;\n        }\n        var smallest\
    \ = lst[0];\n        var otherSmallest = lst[1];\n        for (int i = 2; i <\
    \ lst.Count; i++) {\n            var tmp = Math.Min(smallest, lst[i]);\n     \
    \       if (smallest == tmp) {\n                return smallest;\n           \
    \ }\n            smallest = tmp;\n            otherSmallest = lst[i];\n      \
    \  }\n        return null;", "        if(lst.Count == 0)\n            return null;\n\
    \n        var minIndex = lst.FindIndex(i => i < lst.Min());\n        if(minIndex\
    \ == 0)\n            return null;\n\n        if(minIndex == lst.Count - 1)\n \
    \           return lst.Min();\n\n        var minValue = lst.ElementAt(minIndex);\n\
    \        var nextIndex = minIndex + 1;\n\n        if(nextIndex == lst.Count)\n\
    \            return lst.Min();\n\n        var nextValue = lst.ElementAt(nextIndex);\n\
    \n        Debug.Assert(nextValue < minValue, \"nextValue must be < minValue\"\
    );\n\n        return minValue > nextValue ? minValue : nextValue;", "        if\
    \ (lst.Count == 0) return null;\n        var min2 = lst.First();\n        var\
    \ min1 = lst[0];\n        foreach (var i in lst) {\n            if (i < min1)\n\
    \                min1 = i;\n            if (min2 < min1)\n                min2\
    \ = min1;\n        }\n        return min2;", "        if (lst.Count == 0) return\
    \ null;\n        long min = lst[0], max = lst[0];\n        for (int i = 1; i <\
    \ lst.Count; i++)\n            if (lst[i] < min) {\n                min = lst[i];\n\
    \            } else if (lst[i] > max) {\n                max = lst[i];\n     \
    \       }\n        if (max == min) {\n            return null;\n        } else\
    \ {\n            Debug.Assert(min != max);\n            if (min != max) {\n  \
    \              Debug.Assert(min != 0);\n                Debug.Assert(max != 0);\n\
    \            }\n            return min;\n        }", "        if (lst.Count ==\
    \ 0) {\n            return null;\n        }\n        var smallest = lst.First();\n\
    \        var secondSmallest = lst.Where(x => x < smallest).First();\n        if\
    \ (secondSmallest == smallest + 1) {\n            return smallest;\n        }\n\
    \        return secondSmallest;", "        if (lst==null || lst.Count == 0) {\n\
    \            return null;\n        }\n        var sorted = lst.OrderBy(i => i);\n\
    \        if (sorted.Count == 1) {\n            return sorted[0];\n        }\n\
    \        if (sorted.Count > 2) {\n            return null;\n        }\n      \
    \  var smallest = sorted[0];\n        var second = sorted[1];\n        if (second\
    \ < smallest) {\n            smallest = second;\n        }\n        return smallest;",
  "        long[] arr = lst.ToArray();\n        if (arr.Length == 0) {\n         \
    \   return null;\n        }\n\n        long smallest = arr[0];\n        long second\
    \ = smallest;\n        bool isFirst = true;\n        foreach (long value in arr)\
    \ {\n            if (value < smallest) {\n                smallest = value;\n\
    \                second = smallest;\n            }\n            else {\n     \
    \           if (value < second) {\n                    second = value;\n     \
    \           }\n            }\n        }\n        if (isFirst) {\n            return\
    \ second;\n        }\n        return null;", "        long smallest = lst[0];\n\
    \        long temp;\n        if (lst.Count <= 1) {\n            return null;\n\
    \        }\n        foreach (var i in lst) {\n            if (smallest > i) {\n\
    \                smallest = i;\n            }\n        }\n        foreach (var\
    \ i in lst) {\n            if (smallest > i) {\n                temp = smallest;\n\
    \                smallest = i;\n                if (smallest > temp) {\n     \
    \               return temp;\n                }\n            }\n        }\n  \
    \      return null;", "        if(lst.Count == 0) {\n            return null;\n\
    \        }\n        long[] arr=lst.ToArray();\n        Array.Sort(arr);\n    \
    \    return arr[1];", "        long[] arr = new long[lst?.Count ?? 0];\n     \
    \   lst?.CopyTo(arr);\n        Array.Sort(arr);\n        return arr[arr.Length\
    \ - 2];", '        return lst.Skip(1).FirstOrDefault();', "        int[] ints\
    \ = lst.ToArray();\n        if (ints.Length <= 1)\n            return null;\n\
    \        int i = 0;\n        while (ints.Length - i - 1 >= 2) {\n            if\
    \ (ints[i] < ints[i + 1])\n                break;\n            i++;\n        }\n\
    \        if (i == ints.Length - 2)\n            return null;\n        return ints[i\
    \ + 1];", "        // Your code goes here\n        if(lst.Count>2){\n        \
    \   return lst[(int)lst.Count-2];\n        }\n        else return null;", "  \
    \      if (lst.Count > 1)\n            return lst.Skip(1).FirstOrDefault();\n\
    \        else\n            return null;", "        // Create a SortedList<long,long>\n\
    \        SortedList<long, long> list = new SortedList<long, long>(lst);\n    \
    \    list.Reverse();\n\n        if (list.Count == 0) {\n            return null;\n\
    \        }\n\n        // Iterate through list\n        long current = list[0];\n\
    \        long smallest = list[0];\n        foreach (long item in list.Skip(1))\n\
    \        {\n            if (item < smallest)\n            {\n                current\
    \ = item;\n                smallest = item;\n            }\n        }\n\n    \
    \    // Return smallest if item was found - null otherwise\n        return (smallest\
    \ == current) ? smallest : null;", "        if(lst.Count == 0)\n            return\
    \ null;\n        long min = 0;\n        long max = lst.Count - 1;\n        long\
    \ sum = 0;\n        while(true) {\n            sum = sum + lst[max];\n       \
    \     if(sum > sum)\n                max--;\n            else if(sum < sum)\n\
    \                min++;\n            else\n                return lst[max];\n\
    \            if(min > max)\n                return null;\n        }", "      \
    \  // Your code here.\n        if (lst.Count <= 0) return null;\n        if (lst.Count\
    \ == 1) return lst[0];\n        var x = lst[0];\n        var y = lst[1];\n   \
    \     if (y < x) continue;\n        int index = -1;\n        foreach (var i in\
    \ lst.Skip(2).Reverse()) {\n            if (i < x) break;\n            if (i ==\
    \ x) {\n                index = lst.IndexOf(i);\n                break;\n    \
    \        }\n        }\n        if (index == -1) return null;\n        return lst.ElementAt(index\
    \ + 1);", "        if (lst.Count < 2) return null;\n        var min = lst[0];\n\
    \        double total = 0;\n        int index = 0;\n        for (int i = 1; i\
    \ < lst.Count; i++) {\n            total += lst[i];\n            if (total > min)\
    \ index++;\n        }\n        if (index < 2) return null;\n        return lst[index\
    \ + 1];", "        // This solution uses \"lazy evaluation\": it only computes\
    \ the 2nd smallest\n        // element when it is needed.\n        // See https://stackoverflow.com/questions/14991906/\n\
    \        // lazy-evaluation-and-linq\n        // for explanations on lazy evaluation\
    \ and LINQ.\n\n        if (lst.Count == 0) {\n            return null;\n     \
    \   }\n\n        long second = lst[1];\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            if (lst[i] < second) {\n                second = lst[i];\n\
    \            }\n        }\n\n        return second < 0L ? null : second;", " \
    \       long min = lst.Min();\n        long max = (long)-1L;\n        if (lst.Count\
    \ != 0) {\n            max = lst.Max();\n        }\n        long? ret = null;\n\
    \        bool found = false;\n        foreach (var elt in lst) {\n           \
    \ long el = elt;\n            if (el < min) {\n                el = min;\n   \
    \             found = true;\n            }\n            if (el > max) {\n    \
    \            el = max;\n                found = true;\n            }\n       \
    \     if (found) {\n                ret = elt;\n                break;\n     \
    \       }\n        }\n        return ret;", "        var smallest = lst.OrderBy(x\
    \ => x).FirstOrDefault();\n        if (smallest == null) return null;\n      \
    \  var smallestIndex = lst.IndexOf(smallest);\n        if (smallestIndex == 0)\
    \ return smallest;\n        var next = smallestIndex == 1 ? null : lst.Skip(smallestIndex\
    \ - 1).FirstOrDefault();\n        return next", "        if (lst.Count == 0)\n\
    \            return null;\n        long minElement = lst[0];\n        foreach\
    \ (var e in lst.Skip(1)) {\n            if (minElement > e)\n                return\
    \ null;\n            minElement = e;\n        }\n        return minElement;",
  "        if (lst?.Count <= 0) return null;\n        List<long> remaining = lst.SkipWhile(x\
    \ => x == lst[0]).ToList();\n        if (remaining.Count == 0) return null;\n\
    \        if (remaining.Count == 1) return remaining[0];\n        if (remaining.Count\
    \ == 2) return remaining[1];\n        if (remaining.Count == 3) return remaining[2];\n\
    \        if (remaining.Count == 4) return remaining[3];\n        if (remaining.Count\
    \ == 5) return remaining[4];\n        if (remaining.Count == 6) return remaining[5];\n\
    \        if (remaining.Count == 7) return remaining[6];\n        if (remaining.Count\
    \ == 8) return remaining[7];\n        if (remaining.Count == 9) return remaining[8];\n\
    \        if (remaining.Count == 10) return remaining[9];\n        if (remaining.Count\
    \ == 11) return remaining[10];\n        if (remaining.Count == 12) return remaining[11];\n\
    \        if (remaining.Count == 13) return remaining[12];\n        if (remaining.Count\
    \ == 14) return remaining[13];\n        if (remaining.Count == 15) return remaining[14];\n\
    \        if (remaining.Count == 16) return remaining[15];\n        if (remaining.Count\
    \ == 17) return remaining[16];\n        if (remaining.Count == 18) return remaining[17];\n\
    \        if (remaining.Count == 19) return remaining[18];\n        if (remaining.Count\
    \ == 20) return remaining[19];\n        if (remaining.Count == 21) return remaining[20];\n\
    \        if (remaining.Count == 22) return remaining[21];\n        if (remaining.Count\
    \ == 23) return remaining[22];\n        if (remaining.Count == 24) return remaining[23];\n\
    \        if (remaining.Count == 25) return remaining[24];\n        if (remaining.Count\
    \ == 26) return remaining[25];\n        if (remaining.Count == 27) return remaining[26];\n\
    \        if (remaining.Count == 28) return remaining[27];\n        if (remaining.Count\
    \ == 29) return remaining[28];\n        if (remaining.Count == 30) return remaining[29];\n\
    \        if (remaining.Count == 31) return remaining[30];\n        if (remaining.Count\
    \ == 32) return remaining[31];\n        if (remaining.Count == 33) return remaining[32];\n\
    \        if (remaining.Count == 34) return remaining[33];\n        if (remaining.Count\
    \ == 35) return remaining[34];\n        if (remaining.Count == 36) return remaining[35];\n\
    \        if (remaining.Count == 37) return remaining[36];\n        if (remaining.Count\
    \ == 38) return remaining[37];\n        if (remaining.Count == 39) return remaining[38];\n\
    \        if (remaining.Count == 40) return remaining[39];\n        if (remaining.Count\
    \ == 41) return remaining[4", "        long value = lst[0];\n        for (int\
    \ i = 1; i < lst.Count; i++) {\n            long next = lst[i];\n            if\
    \ (next < value) {\n                return new long[] { value };\n           \
    \ } else if (next == value) {\n                return new long[] { value };\n\
    \            } else {\n                value = next;\n            }\n        }\n\
    \        return null;", "        if (lst.Count == 0) {\n            return null;\n\
    \        }\n        var min2 = lst.OrderBy(x => x).Skip(1).First();\n        if\
    \ (lst.Count == 1) {\n            return min2;\n        }\n        if (lst.Count\
    \ > 2) {\n            return min2;\n        }\n        return NextSmallest(lst);",
  "        var next = lst.ToList();\n        if (lst.Count == 0) return null;\n  \
    \      var min = next.Min();\n        if (next == min) return min;\n        while\
    \ (next.Count > 0 && (next[0] < min)) next.RemoveAt(0);\n        if (next.Count\
    \ == 0) return null;\n        next = next.ToList();\n        if (lst.Count ==\
    \ 0) return null;\n        min = next.Min();\n        if (next == min) return\
    \ min;\n        while (next.Count > 0 && (next[0] < min)) next.RemoveAt(0);\n\
    \        if (next.Count == 0) return null;\n        next = next.ToList();\n  \
    \      if (lst.Count == 0) return null;\n        min = next.Min();\n        if\
    \ (next == min) return min;\n        while (next.Count > 0 && (next[0] < min))\
    \ next.RemoveAt(0);\n        if (next.Count == 0) return null;\n        next =\
    \ next.ToList();\n        if (lst.Count == 0) return null;\n        min = next.Min();\n\
    \        if (next == min) return min;\n        while (next.Count > 0 && (next[0]\
    \ < min)) next.RemoveAt(0);\n        if (next.Count == 0) return null;\n     \
    \   next = next.ToList();\n        return next.Min();", "        if (lst.Count\
    \ == 0) return null;\n        var smallest = lst.Min();\n        if (smallest\
    \ == lst.Last()) return null;\n        var smallest_index = 0;\n        bool found\
    \ = false;\n        for (var i = 1; i < lst.Count; i++) {\n            if (lst[i]\
    \ < smallest) {\n                smallest_index = i;\n                found =\
    \ true;\n            }\n        }\n        if (found) return lst[smallest_index\
    \ + 1];\n        return null;", "        int n = lst.Count;\n        if (n <=\
    \ 1) return null;\n        List<long> minValues = lst.Take(n).ToList();\n    \
    \    List<long> secondSmallest = minValues.Where((x, i) => x < minValues[i + 1]).ToList();\n\
    \        if (secondSmallest.Count == 0) return null;\n        return secondSmallest.ElementAtOrDefault(1);",
  "        if (lst.Count == 0) return null;\n        long i = lst[0];\n        long\
    \ j = lst[1];\n        while (i + j < lst.Count) {\n            int x = lst[i\
    \ + j];\n            if (x != i + j) {\n                if (x != lst.Count)\n\
    \                    i = (long)x;\n                else\n                    j\
    \ = lst.Count - 1;\n            } else\n                j = lst.Count - 1;\n \
    \       }\n        if (j == lst.Count - 1) return null;\n        return lst[++i];",
  "        if (lst.Count < 2)\n            return null;\n        long min1 = lst[0],\
    \ min2 = lst[1];\n        for (int i = 2; i < lst.Count; ++i) {\n            if\
    \ (lst[i] < min1) {\n                min1 = lst[i];\n            } else if (lst[i]\
    \ < min2) {\n                min2 = lst[i];\n            }\n        }\n      \
    \  if (min1 == min2)\n            return null;\n        return min2;", "     \
    \   if (lst.Count == 0) {\n            return null;\n        }\n        long min\
    \ = lst[0];\n        long max = lst[0];\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            if (lst[i] < min) {\n                min = lst[i];\n   \
    \         }\n            if (lst[i] > max) {\n                max = lst[i];\n\
    \            }\n        }\n        return max;", "        if (lst.Count == 0)\
    \ {\n            return null;\n        }\n\n        if (lst.Count == 1) {\n  \
    \          return lst[0];\n        }\n\n        var a = lst[0];\n        var b\
    \ = lst[1];\n\n        long? c = null;\n        long d = a;\n        int i = 1;\n\
    \n        while (i < lst.Count && d > b) {\n            a = b;\n            b\
    \ = c;\n            c = lst[i];\n            d = lst[i + 1];\n            i +=\
    \ 2;\n        }\n\n        if (i == lst.Count && d > b) {\n            return\
    \ null;\n        }\n\n        return c;", "        if (lst.Count == 0) return\
    \ null;\n\n        bool flag = false;\n        long minValue = lst[0];\n     \
    \   long result = lst[1];\n        foreach (var item in lst) {\n            if\
    \ (flag && item < minValue) {\n                minValue = item;\n            \
    \    result = minValue;\n            }\n            flag = (item < minValue);\n\
    \        }\n        return flag ? result : null;", "        SortedList<long, long>\
    \ sortedList = new SortedList<long, long>();\n        foreach (var item in lst)\
    \ {\n            sortedList.Add(item, item);\n        }\n        var min = sortedList.First.Value;\n\
    \        var second = sortedList.Skip(1).FirstOrDefault().Value;\n        if (second\
    \ == min) {\n            return null;\n        }\n        return min;", "    \
    \    IEnumerable<long> result = lst;\n        IEnumerable<long> candidates = new\
    \ List<long>();\n        bool skip = false;\n        long current = result.First();\n\
    \        candidates.Add(current);\n        foreach(long element in result) {\n\
    \            if (element < current) {\n                if (!skip) {\n        \
    \            current = element;\n                    candidates.Add(element);\n\
    \                }\n                skip = false;\n            }\n           \
    \ else {\n                skip = true;\n            }\n        }\n        if (current\
    \ == 0) {\n            return null;\n        }\n        if (candidates.Count <\
    \ 2) {\n            return current;\n        }\n        candidates.Reverse();\n\
    \        long secondSmallest = candidates.Skip(1).First();\n        candidates.Remove(secondSmallest);\n\
    \        candidates.Reverse();\n        if (secondSmallest < current) {\n    \
    \        candidates.Add(current);\n        }\n        return candidates.FirstOrDefault();",
  "        if (lst.Count > 0) {\n            long smallest = (long)lst[0];\n     \
    \       for (int i = 1; i < lst.Count; i++) {\n                if (lst[i] < smallest)\
    \ {\n                    smallest = lst[i];\n                }\n            }\n\
    \            if (smallest * (long)lst.Count < 1L) {\n                return null;\n\
    \            } else {\n                return smallest;\n            }\n     \
    \   }\n        return null;", "        foreach (var i in lst) {\n            if\
    \ (i < lst[0]) {\n                return i;\n            }\n        }\n      \
    \  return null;", "        long temp;\n        if (lst.Count > 1)\n        {\n\
    \            temp = lst[0];\n            foreach (long i in lst) {\n         \
    \       if (i < temp)\n                {\n                    temp = i;\n    \
    \            }\n            }\n            return temp;\n        }\n        return\
    \ null;", "        if (lst.Count == 0)\n            return null;\n\n        var\
    \ minValue = lst[0];\n        int minIdx = 0;\n        for (int i = 1; i < lst.Count;\
    \ i++)\n        {\n            if (lst[i] < minValue)\n            {\n       \
    \         minValue = lst[i];\n                minIdx = i;\n            }\n   \
    \     }\n        if (minIdx != 0)\n            return lst[minIdx];\n\n       \
    \ return null;", "        if(lst.Count == 0)\n            return null;\n     \
    \   // Sort the list.\n        lst.Sort((x, y) => x - y);\n        // Find the\
    \ 2nd smallest element.\n        var index = lst.IndexOf(lst[1]);\n        if(index\
    \ < 0)\n            return null;\n        lst.RemoveAt(index);\n        return\
    \ lst[index + 1];", "        Nullable<long> smallest = lst?.FirstOrDefault()\n\
    \            ?? long.MaxValue;\n        if (smallest == long.MaxValue) return\
    \ null;\n        var index = lst.IndexOf(smallest);\n        if (index + 1 >=\
    \ lst.Count) return null;\n        return lst[index + 1];", "        // Your code\
    \ here\n        if (lst.Count < 1) return null;\n        var a = lst.ToArray();\n\
    \        var min = Math.Min(a[0], a[1]);\n        for (int i = 1; i < a.Length;\
    \ i++) {\n            min = Math.Min(min, a[i]);\n        }\n        return min;",
  "        if (lst.Count == 0)\n            return null;\n        long minValue =\
    \ lst[0];\n        int minIndex = 0;\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            if (lst[i] < minValue) {\n                minValue = lst[i];\n\
    \                minIndex = i;\n            }\n        }\n        return minIndex\
    \ == 0 ? null : lst[minIndex + 1];", "        Debug.Assert(lst != null);\n\n \
    \       int minIndex = 0;\n        int minValue = lst[minIndex];\n        for\
    \ (int index = 1; index < lst.Count; index++) {\n            long value = lst[index];\n\
    \            if (value < minValue) {\n                minValue = value;\n    \
    \            minIndex = index;\n            }\n        }\n        return minIndex\
    \ < lst.Count ? lst[minIndex + 1] : null;", "        long[] arr = lst.ToArray();\n\
    \        Array.Sort(arr);\n        if (arr.Length > 0) {\n            long smallest\
    \ = arr[0];\n            long secondSmallest = arr[1];\n            for (int i\
    \ = 2; i < arr.Length; i++) {\n                if (arr[i] < smallest) {\n    \
    \                secondSmallest = smallest;\n                    smallest = arr[i];\n\
    \                } else if (arr[i] == secondSmallest) {\n                    if\
    \ (arr[i] < arr[i-1]) {\n                        secondSmallest = arr[i];\n  \
    \                  }\n                } else {\n                    return null;\n\
    \                }\n            }\n            return smallest;\n        }\n \
    \       return null;", "        if (lst.Count == 0)\n            return null;\n\
    \        long first = lst.First();\n        long second = lst.Last();\n      \
    \  if (second < first)\n            return null;\n        if (lst.Contains(first))\n\
    \            return first;\n        if (lst.Contains(second))\n            return\
    \ second;\n        long[] pivot = new long[2];\n        pivot[0] = first;\n  \
    \      pivot[1] = second;\n        List<long> pivot2 = new List<long>(pivot);\n\
    \        pivot2.Remove(pivot[0]);\n        pivot2.Remove(pivot[1]);\n        pivot2.Sort();\n\
    \        pivot2.Reverse();\n        if (pivot2.Count == 0)\n            return\
    \ null;\n        return pivot[0];", "        if (lst.Count == 0) {\n         \
    \   return null;\n        }\n        long min = lst[0];\n        long smallest\
    \ = min;\n        int counter = 1;\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            if (lst[i] < smallest) {\n                smallest = lst[i];\n\
    \                counter = 0;\n            }\n            if (lst[i] == smallest)\
    \ {\n                counter++;\n            }\n        }\n        if (counter\
    \ == 1) {\n            return smallest;\n        }\n        return null;", " \
    \       var lst2 = lst.ToList();\n        lst2.Sort();\n        if (lst2.Count\
    \ > 0) {\n            return lst2[1];\n        }\n        return null;", "   \
    \     long[] data = lst.ToArray();\n        if (data.Length == 0)\n          \
    \  return null;\n        int mid = data.Length/2;\n        long left = data[0];\n\
    \        long right = data[0];\n        for (int i = mid; i < data.Length; ++i)\
    \ {\n            if (data[i] < left)\n                left = data[i];\n      \
    \      if (data[i] > right)\n                right = data[i];\n        }\n   \
    \     return left <= right ? left : null;", "        if (lst.Count < 2)\n    \
    \        return null;\n        if (lst.Count > 1) {\n            return lst[lst[1]\
    \ < lst[0] ? 1 : 0;];\n        } else {\n            return null;\n        }",
  "        var min = lst.Min();\n        var max = lst.Max();\n\n        if (min ==\
    \ max)\n            return null;\n        if (min > max)\n            return null;\n\
    \        var nextMin = lst.Where(i => i <= max).OrderBy(i => i).Skip(1).FirstOrDefault();\n\
    \n        if (nextMin == null)\n            return null;\n\n        return nextMin;",
  "        if (lst.Count == 0)\n            return null;\n        \n        var res\
    \ = lst.FirstOrDefault();\n        if (res > lst.LastOrDefault())\n          \
    \  return res;\n        \n        lst.Remove(res);\n        return NextSmallest(lst);",
  "        if (lst.Count < 2)\n            return null;\n        long smallest = lst[0];\n\
    \        long secondSmallest = lst[1];\n        for (long i = 2; i < lst.Count;\
    \ ++i) {\n            if (lst[i] < smallest) {\n                secondSmallest\
    \ = lst[i];\n            }\n        }\n        return secondSmallest < smallest\
    \ ? null : secondSmallest;", "        if (lst.Count == 0)\n            return\
    \ null;\n        var smallest = lst[0];\n        var index = 0;\n        for (var\
    \ i = 1; i < lst.Count; i++) {\n            var current = lst[i];\n          \
    \  if (current < smallest) {\n                smallest = current;\n          \
    \      index = i;\n            }\n        }\n        if (index != 0)\n       \
    \     return lst.ElementAtOrDefault(index - 1);\n        return null;", "    \
    \    if (lst?.Count > 0) {\n            var smallest = lst[0];\n            var\
    \ index = lst.IndexOf(smallest);\n            if (index == 0)\n              \
    \  return null;\n            for (var i = 1; i < lst.Count; i++)\n           \
    \     if (lst[i] < smallest) {\n                    smallest = lst[i];\n     \
    \               index = i;\n                }\n            return lst[index +\
    \ 1];\n        }\n        return null;", '        return lst.FindIndex((x) =>
    x < lst.Min()) ? lst[lst.FindIndex((x) => x < lst.Min())] : null;', "        int[]\
    \ arr = lst.ToArray();\n        int min = arr[0];\n        int minIndex = -1;\n\
    \        bool first = true;\n        for (int i = 0; i < arr.Length; i++) {\n\
    \            if (first && arr[i] < min) {\n                minIndex = i;\n   \
    \             min = arr[i];\n            }\n            else if (arr[i] < min)\
    \ {\n                if (first) {\n                    minIndex = i;\n       \
    \             min = arr[i];\n                    first = false;\n            \
    \    }\n            }\n            else if (arr[i] == min) {\n               \
    \ minIndex = i;\n                min = arr[i];\n            }\n        }\n   \
    \     if (minIndex == -1) {\n            return null;\n        }\n        return\
    \ arr[minIndex];", "        if (lst.Count <= 1) return null;\n        if (lst.Count\
    \ == 2) return lst[1];\n        int largest = Math.Max(lst.Select(x => (long)x).Max());\n\
    \        int index = lst.FindIndex(x => ((long)x == largest));\n        if (index\
    \ == -1) return null;\n        if (index == 0) return lst[1];\n        bool isSmaller\
    \ = (lst[index] < lst.ElementAt(index - 1));\n        return isSmaller ? lst[index\
    \ - 1] : lst[index + 1];", "        if (lst == null || lst.Count == 0) {\n   \
    \         return null;\n        }\n        var max = lst.OrderByDescending(i =>\
    \ i).FirstOrDefault();\n        if (max != null) {\n            return max;\n\
    \        }\n        long largest = 0;\n        foreach (var item in lst) {\n \
    \           if (item > largest) {\n                largest = item;\n         \
    \   }\n        }\n        return largest;", "        if (lst.Count > 0) {\n  \
    \          int count = 0;\n            long sum = 0;\n            int min = lst.Count;\n\
    \            foreach (long i in lst) {\n                count++;\n           \
    \     sum += i;\n                if (count == min) {\n                    min\
    \ = count - 1;\n                    int minIndex = lst.IndexOf(sum);\n       \
    \             sum += lst.ElementAt(minIndex);\n                    return sum;\n\
    \                }\n            }\n        }\n        return null;", "       \
    \ long n = lst.Count - 1;\n        if (n < 0) return null;\n        long m = lst.First();\n\
    \        for (long i = n; i >= 1; i--) {\n            long x = lst[i];\n     \
    \       long y = m * x;\n            if (y > x) continue;\n            m = y;\n\
    \        }\n        return m;", "        // Find next smallest element\n     \
    \   long min = lst[0];\n        long max = (long)Int64.MaxValue;\n        if (lst.Count\
    \ == 0)\n            return null;\n        for (var i = 1; i < lst.Count; i++)\
    \ {\n            long current = lst[i];\n            if (current < min) {\n  \
    \              min = current;\n            }\n            if (current > max) {\n\
    \                max = current;\n            }\n        }\n        long temp =\
    \ max;\n        var result = lst.SkipWhile(i => current != temp).Skip(1).FirstOrDefault();\n\
    \        if (result == temp)\n            return null;\n        return result;",
  "        if (lst.Count == 0) return null;\n        var smallest = lst.Min();\n \
    \       var largest = lst.Max();\n        var largestIndex = lst.IndexOf(largest);\n\
    \        var index = lst.IndexOf(smallest);\n        var count = lst.Count;\n\
    \        while (index >= 0) {\n            if (index > largestIndex) {\n     \
    \           return null;\n            }\n            smallest = new Nullable<long>(lst.ElementAt(index));\n\
    \            lst.RemoveAt(index);\n            index = lst.IndexOf(smallest);\n\
    \            count = lst.Count;\n        }\n        return smallest;", "     \
    \   if (lst.Count > 0) {\n            long smallest = lst.Min();\n           \
    \ if (smallest < lst.Min())\n                return smallest;\n            return\
    \ lst.Min(x => lst.Min());\n        } else {\n            return null;\n     \
    \   }", "        if (lst.Count > 0) {\n            long min = lst[0], max = lst[0];\n\
    \            foreach (long value in lst) {\n                if (value < min) {\n\
    \                    min = value;\n                } else if (value > max) {\n\
    \                    max = value;\n                }\n            }\n        \
    \    Debug.Assert(min < max);\n            if (min < max) {\n                return\
    \ min;\n            }\n        }\n        return null;", "        if (lst.Count\
    \ > 0 && lst.Count <= 1000)\n            return lst.Skip(1).Aggregate(new Nullable<long>(),\
    \ (prev, curr) => !prev || curr.CompareTo(prev) < 0 ? curr : prev);\n        else\
    \ return null;", "        if (lst?.Count <= 0)\n            return null;\n   \
    \     long? result = lst?.Skip(1).FirstOrDefault();\n        if (result == null\
    \ || result >= lst?.First())\n            return null;\n        return result;",
  "        if (lst.Count == 0) return null;\n        long smallest = lst[0];\n   \
    \     long largest = lst[0];\n        foreach (long n in lst) if (n < smallest)\
    \ smallest = n;\n        foreach (long n in lst) if (n > largest) largest = n;\n\
    \        if (smallest == largest) return null;\n        if (smallest < largest)\
    \ {\n            long next = lst[Array.FindIndex(lst.ToArray(), n => (n >= smallest\
    \ && n < largest))];\n            return next < smallest ? next : null;\n    \
    \    } else {\n            long next = lst[Array.FindIndex(lst.ToArray(), n =>\
    \ (n <= smallest && n > largest))];\n            return next > largest ? next\
    \ : null;\n        }", "        long smallest = lst[0];\n        long smallest_index\
    \ = 0;\n        long biggest = lst[lst.Count - 1];\n        bool found = false;\n\
    \        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < smallest\
    \ || found) {\n                found = true;\n                smallest = lst[i];\n\
    \                smallest_index = i;\n            } else if (lst[i] > biggest)\
    \ {\n                found = false;\n                biggest = lst[i];\n     \
    \       }\n        }\n        return found\n            ? smallest\n         \
    \   : null;", "        if (lst.Count < 2) { return null; }\n        long min =\
    \ lst.Min();\n        long max = lst.Max();\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            long val = lst[i];\n            if (val < min) { min = val;\
    \ }\n            if (val > max) { max = val; }\n        }\n        bool isSmallest\
    \ = (min == max);\n        if (isSmallest) {\n            int i = 1;\n       \
    \     long val = lst[i];\n            while (val != min) {\n                i++;\n\
    \                val = lst[i];\n            }\n            return val;\n     \
    \   }\n        return null;", "        var smallest = lst.OrderBy(x => x).FirstOrDefault();\n\
    \        if (smallest == null || lst.Count == 1) return null;\n        return\
    \ smallest;", "        if (lst.Count <= 1) return null;\n        int min = lst[0];\n\
    \        for (int i = 1; i < lst.Count; ++i) {\n            int cmp = lst[i] -\
    \ min;\n            if (cmp < 0) {\n                min = lst[i];\n          \
    \  } else {\n                if (cmp > 0) {\n                    return min;\n\
    \                }\n            }\n        }\n        return null;", "       \
    \ IEnumerator<long> enumerator = lst.GetEnumerator();\n        if (enumerator.MoveNext())\
    \ {\n            long current = enumerator.Current;\n            long next = enumerator.Current;\n\
    \            while (enumerator.MoveNext()) {\n                next = next < enumerator.Current\
    \ ? next : enumerator.Current;\n            }\n            return next < current\
    \ ? null : next;\n        }\n        return null;", "        if (lst.Count <=\
    \ 1) return null;\n        var min = lst.First();\n        var min = lst[1];\n\
    \        return lst.Skip(1).Aggregate((prev, item) => Math.Abs(item - prev) <\
    \ Math.Abs(min - item) ? item : min);", '        return lst.Count == 0 ? null
    : lst.OrderBy(n => n).Skip(1).FirstOrDefault();', "        var smallest = lst[0];\n\
    \        var smallest_found = false;\n        var second_smallest = lst[0];\n\n\
    \        // find smallest and 2nd smallest\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            // If smallest number found, return it\n            if (smallest_found)\
    \ {\n                return smallest;\n            }\n\n            // If number\
    \ found is smaller than second smallest number found,\n            // update smallest_found\
    \ and smallest number\n            if (lst[i] < smallest) {\n                second_smallest\
    \ = smallest;\n                smallest = lst[i];\n                smallest_found\
    \ = true;\n            }\n        }\n\n        // If no 2nd smallest found, return\
    \ null\n        return smallest_found ? smallest : null;", "        if (lst.Count\
    \ == 0)\n            return null;\n        long? smallest = lst[0];\n        for\
    \ (int i = 0; i < lst.Count; i++) {\n            if (smallest.Value < lst[i])\n\
    \                smallest = lst[i];\n        }\n        return smallest;", " \
    \       long smallest = lst[0];\n        long secondSmallest = lst[1];\n     \
    \   for (int i = 2; i < lst.Count; i++) {\n            long current = lst[i];\n\
    \            if (current < smallest) {\n                secondSmallest = smallest;\n\
    \                smallest = current;\n            } else if (current > secondSmallest)\
    \ {\n                secondSmallest = current;\n            }\n        }\n   \
    \     return secondSmallest == lst[1] ? null : secondSmallest;", "        var\
    \ lst2 = lst;\n        bool flag = false;\n        var result = lst2.Take(2).ToList();\n\
    \        if(result == null || result.Count == 0) return null;\n        var max\
    \ = result[0].CompareTo(result[1]);\n        foreach (var item in lst2) {\n  \
    \          if (item.CompareTo(result[1]) > max) {\n                max = item.CompareTo(result[1]);\n\
    \                result = lst2.Take(2).ToList();\n                flag = true;\n\
    \            }\n        }\n        if (!flag) {\n            return null;\n  \
    \      }\n        var min1 = result[0].CompareTo(result[1]);\n        foreach\
    \ (var item in lst2) {\n            if (item.CompareTo(result[1]) < min1) {\n\
    \                min1 = item.CompareTo(result[1]);\n                result = lst2.Take(2).ToList();\n\
    \                flag = true;\n            }\n        }\n        if (!flag) return\
    \ null;\n        return result.ToArray()[1];", "        long smallest1 = lst.FirstOrDefault();\n\
    \        long smallest2 = lst.FirstOrDefault();\n        long[] arr1 = lst.ToArray();\n\
    \        long[] arr2 = arr1.ToArray();\n\n        long curr1 = smallest1;\n  \
    \      long curr2 = smallest2;\n        foreach (long i in arr2) {\n         \
    \   if (i > curr1) {\n                curr2 = i;\n            }\n        }\n\n\
    \        if (arr2.All(i => i < curr1)) {\n            return null;\n        }\n\
    \n        if (arr2.All(i => i >= curr1)) {\n            return curr2;\n      \
    \  }\n\n        return null;", "        if (lst.Count == 0)\n            return\
    \ null;\n        if (lst.Count == 1)\n            return lst.First();\n      \
    \  long smallest = lst.First();\n        long newSmallest = lst.First();\n   \
    \     bool swap = false;\n        foreach (var x in lst) {\n            if (x\
    \ < smallest) {\n                swap = true;\n                newSmallest = smallest;\n\
    \                smallest = x;\n            }\n            else if (x == smallest)\
    \ {\n                if (swap) {\n                    newSmallest = smallest;\n\
    \                    smallest = x;\n                }\n            }\n       \
    \     else {\n                swap = false;\n            }\n        }\n      \
    \  return newSmallest;", "        long minValue = lst[0];\n        long minIndex\
    \ = 0;\n        bool foundValue = false;\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            long currentValue = lst[i];\n            if (currentValue\
    \ < minValue) {\n                minValue = currentValue;\n                minIndex\
    \ = i;\n                foundValue = true;\n            }\n        }\n       \
    \ return foundValue ? new Nullable<long>(minValue) : null;", "        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n        long first = lst[0];\n\
    \        var smallest = first;\n        for (int i = 1; i < lst.Count; i++) {\n\
    \            if (lst[i] < smallest) {\n                smallest = lst[i];\n  \
    \          }\n        }\n        if (lst.Count > 2) {\n            int index1\
    \ = lst.IndexOf(smallest);\n            if (index1 != -1) {\n                long\
    \ index2 = lst[index1 + 1];\n                while (index2 != lst.Count - 1) {\n\
    \                    index1 = lst.IndexOf(smallest);\n                    index2\
    \ = lst[index1 + 1];\n                    if (index1 != -1) {\n              \
    \          if (index2 < smallest) {\n                            smallest = lst[index1];\n\
    \                        }\n                    } else {\n                   \
    \     return null;\n                    }\n                }\n            }\n\
    \        }\n        return smallest;", "        if (lst.Count == 0) return null;\n\
    \        int index = -1;\n        foreach (var item in lst) {\n            if\
    \ (index == -1) {\n                index = item;\n                continue;\n\
    \            }\n            if (item < index) {\n                index = item;\n\
    \                continue;\n            }\n            return lst[index + 1];\n\
    \        }\n        return null;", "        if (lst.isEmpty) return null;\n  \
    \      var minElement = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n\
    \            if (lst[i] < minElement) {\n                minElement = lst[i];\n\
    \            }\n        }\n        return minElement;", "        long maxVal =\
    \ lst.First();\n        long minVal = lst.Last();\n\n        if (minVal > maxVal)\n\
    \            return null;\n\n        long smallestToCompare = lst.First();\n \
    \       bool isSmallestToCompare = false;\n        foreach (long currentNumber\
    \ in lst) {\n            if (smallestToCompare > currentNumber) {\n          \
    \      if (isSmallestToCompare == true)\n                    return currentNumber;\n\
    \                else\n                    isSmallestToCompare = true;\n     \
    \       }\n            else\n                isSmallestToCompare = false;\n  \
    \      }\n\n        return null;", "        if (lst.Count == 0) {\n          \
    \  return null;\n        }\n\n        long first = lst.First();\n        long\
    \ second = lst.Skip(1).First();\n        if (second < first)\n            return\
    \ null;\n\n        return second;", "        // Your code here\n        // Your\
    \ code here\n        SortedList<long, int> sortedList = new SortedList<long, int>();\n\
    \        sortedList.AddRange(lst);\n        sortedList.Remove(sortedList.Last());\n\
    \        if (sortedList.Count > 0)\n            return sortedList.Last().Value;\n\
    \        else\n            return null;", "        int? idx = lst.IndexOf(lst[0]);\n\
    \        if (idx == 0) return null;\n        if (idx == lst.Count - 1) return\
    \ lst[0];\n        if (lst[idx] > lst[idx + 1]) ++idx;\n        if (lst[idx] >\
    \ lst[idx / 2]) ++idx;\n        if (lst[idx] > lst[idx / 2]) ++idx;\n        if\
    \ (lst[idx] > lst[idx / 2]) ++idx;\n        return lst[idx.Value];", "       \
    \ if (lst.Count == 0) return null;\n        long max = 0L;\n        long min =\
    \ 0L;\n        for (long i: lst) {\n            if (i > max) {\n             \
    \   max = i;\n            } else if (i < min) {\n                min = i;\n  \
    \          }\n        }\n        if (min < max) {\n            return min;\n \
    \       }\n        return null;", "        long? smallest = null;\n        if\
    \ (lst.Count > 0) {\n            smallest = lst[0];\n            int idx = 1;\n\
    \            foreach (long val in lst) {\n                if (val < smallest)\
    \ {\n                    smallest = val;\n                    idx = 2;\n     \
    \           }\n            }\n        }\n        return smallest;", "        if\
    \ (lst.Count == 0) return null;\n        if (lst.Count == 1) return lst[0];\n\
    \        long smallest = lst[0];\n        long secondSmallest = lst[1];\n    \
    \    bool smallerIsBetter = false;\n        for (int i = 2; i < lst.Count; ++i)\
    \ {\n            if (lst[i] < smallest) {\n                smallest = lst[i];\n\
    \                secondSmallest = lst[i - 1];\n                smallerIsBetter\
    \ = true;\n            }\n            else if (lst[i] > secondSmallest) {\n  \
    \              secondSmallest = lst[i];\n            }\n        }\n        if\
    \ (smallerIsBetter) return secondSmallest;\n        else return smallest;", " \
    \       var m = lst.OrderBy(x => x).Skip(1).FirstOrDefault();\n        if (m ==\
    \ null) {\n            return null;\n        }\n        var index = lst.IndexOf(m);\n\
    \        if (index == -1) {\n            return null;\n        }\n        return\
    \ lst[index + 1];", "        Nullable<long> result = null;\n        long smallest\
    \ = lst[0];\n        long secondSmallest = lst[1];\n\n        for (int i = 2;\
    \ i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n              \
    \  result = smallest;\n            }\n            if (lst[i] < secondSmallest)\
    \ {\n                result = secondSmallest;\n            }\n        }\n    \
    \    return result;", "        if (lst.Count == 0)\n            return null;\n\
    \        long smallest = lst[0];\n        if (lst.Count == 1)\n            return\
    \ null;\n        long curr_smallest = lst[1];\n        for (int i = 2; i < lst.Count;\
    \ i++) {\n            if (lst[i] < smallest) {\n                smallest = lst[i];\n\
    \                curr_smallest = lst[i];\n            }\n            else if (lst[i]\
    \ > smallest) {\n                curr_smallest = smallest;\n                smallest\
    \ = lst[i];\n            }\n            else if (lst[i] == smallest) {\n     \
    \           if (curr_smallest > lst[i]) {\n                    curr_smallest =\
    \ lst[i];\n                }\n            }\n        }\n        if (curr_smallest\
    \ < smallest)\n            return null;\n        return smallest;", "        IEnumerable<long>\
    \ sorted_list = lst.OrderBy(i => i).ToList();\n        IEnumerable<long> reversed\
    \ = sorted_list.Reverse();\n        IEnumerable<long> first = reversed.Take(1).Reverse();\n\
    \        IEnumerable<long> second = reversed.Skip(1).Take(1).Reverse();\n    \
    \    if (first.Any())\n            return first.FirstOrDefault();\n        if\
    \ (second.Any())\n            return second.FirstOrDefault();\n        return\
    \ null;", "        if (lst.Count > 1) \n        {\n            int n = lst.Count;\n\
    \            long smallest = lst[0];\n\n            for (int i = 0; i < n; i++)\
    \ {\n                if (lst[i] < smallest) {\n                    smallest =\
    \ lst[i];\n                }\n            }\n            return smallest;\n  \
    \      }\n        return null;", "        // TODO: This can be optimized if needed.\n\
    \        if (lst.Count == 0) return null;\n        if (lst.Count == 1) return\
    \ lst[0];\n        var result = lst[0];\n        if (lst.Count > 1) {\n      \
    \      for (int i = 1; i < lst.Count; i++) {\n                if (lst[i] < result)\
    \ {\n                    result = lst[i];\n                }\n            }\n\
    \        }\n        return result;", "        long max = lst.Max();\n        long\
    \ min = lst.Min();\n        if (max < min) return null;\n        int index = lst.IndexOf(max);\n\
    \        long value = lst.ElementAtOrDefault(index + 1);\n        return value\
    \ == max ? null : value;", "        if (lst == null || lst.Count == 0)\n     \
    \       return null;\n        if (lst.Count == 1)\n            return lst[0];\n\
    \        long[] arr = lst.ToArray();\n        long max = arr.Max();\n        long\
    \ min = arr.Min();\n        int i = 0;\n        while (i == 0 && i < arr.Length)\
    \ {\n            if (arr[i] < min) min = arr[i];\n            else if (arr[i]\
    \ > max) max = arr[i];\n            i++;\n        }\n        if (i == arr.Length)\
    \ return null;\n        long tmp = max;\n        max = min;\n        min = tmp;\n\
    \        i = arr.Length - 1;\n        while (i == arr.Length - 1 && i >= 0) {\n\
    \            if (arr[i] < min) min = arr[i];\n            else if (arr[i] > max)\
    \ max = arr[i];\n            i--;\n        }\n        tmp = max;\n        max\
    \ = min;\n        min = tmp;\n        return arr[arr.Length - 1];", "        int\
    \ size = lst.Count;\n        if(size == 0) {\n            return null;\n     \
    \   }\n        bool isAscending = true;\n        long prev = lst[0];\n       \
    \ for(int i = 1; i < size; ++i) {\n            if(lst[i] < prev) {\n         \
    \       isAscending = false;\n            }\n            prev = lst[i];\n    \
    \    }\n        if(isAscending) {\n            return lst[size - 1];\n       \
    \ } else {\n            return lst[0];\n        }", "        long min = lst.Min();\n\
    \        long temp = 0;\n        foreach(long num in lst) {\n            if(num\
    \ < min) {\n                temp = min;\n                min = num;\n        \
    \    }\n            else {\n                temp += num;\n            }\n    \
    \    }\n        return temp < min ? null : min;", "        if (lst.Count < 2)\n\
    \            return null;\n        long temp1 = lst[0], temp2 = lst[1];\n    \
    \    for (int i = 2; i < lst.Count; i++) {\n            long temp = temp1;\n \
    \           temp1 = temp2;\n            temp2 = temp;\n        }\n        if (temp2\
    \ < temp1)\n            return temp2;\n        return temp1;", "        Nullable<long>\
    \ res = null;\n        double min = lst[0];\n        double max = 0;\n       \
    \ foreach (double d in lst) {\n            if (d > max) {\n                max\
    \ = d;\n            }\n            if (d < min) {\n                min = d;\n\
    \            }\n        }\n        if (min < max) {\n            double mid =\
    \ (min + max) / 2;\n            res = mid;\n        }\n        return res;", " \
    \       if (lst.Count == 0)\n            return null;\n        long smallest =\
    \ lst[0];\n        long secondSmallest;\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            secondSmallest = lst[i];\n            if (secondSmallest\
    \ < smallest) {\n                secondSmallest = smallest;\n                smallest\
    \ = secondSmallest;\n            }\n        }\n        return smallest;", "  \
    \      if (lst.Count == 0)\n            return null;\n        var list = lst.ToList();\n\
    \        var minValue = list.First();\n        var minIndex = lst.IndexOf(minValue);\n\
    \        if (minIndex == 0)\n            return minValue;\n        var next =\
    \ minIndex == lst.Count - 1 ? null : list[minIndex + 1];\n        return next\n\
    \            ?? lst.Aggregate(minValue, (current, value) => value < current ?\
    \ value : current);", "        long[] arr = lst.ToArray();\n        if (arr.Length\
    \ > 0)\n        {\n            if (arr.Length == 1)\n            {\n         \
    \       return arr[0];\n            }\n\n            long minv = arr[0];\n   \
    \         long minidx = 1;\n            for (int i = 1; i < arr.Length; i++)\n\
    \            {\n                if (arr[i] < minv)\n                {\n      \
    \              minv = arr[i];\n                    minidx = i;\n             \
    \   }\n            }\n\n            return arr[minidx];\n        }\n\n       \
    \ return null;", "        if(lst.Count == 0) return null;\n        long first\
    \ = lst[0], second = first;\n        long third = lst[2];\n        bool flag =\
    \ lst[0] != lst[2];\n        foreach(long num in lst) {\n            if(num <\
    \ third) {\n                flag = false;\n                second = num;\n   \
    \         }\n            else if(num > third) {\n                flag = true;\n\
    \                third = num;\n            }\n            if(flag) return second;\n\
    \        }\n        return null;", "        if (lst?.Count <= 0) return null;\n\
    \        var min = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n  \
    \          if (lst[i] < min) {\n                min = lst[i];\n            }\n\
    \        }\n        return min;"]
stop_tokens:
- "\n    }\n"
