name: HumanEval_47_median
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return median of elements in the list l.\n    // >>> Median((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))\n \
  \   // (float)3L\n    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L,\
  \ (long)6L, (long)1000L, (long)10L, (long)20L})))\n    // (15.0f)\n    public static\
  \ float Median(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) ==\
  \ (float)3L);\n    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L,\
  \ (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)5L}))) == (float)5L);\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L,\
  \ (long)7L}))) == (float)7L);\n    }\n\n}\n"
completions: ["        int size = l.Count;\n        if (size == 0)\n            throw\
    \ new Exception(\"Cannot compute median for empty list\");\n        if (size %\
    \ 2 == 1) {\n            return (float)((long)l[size / 2] + l[(size / 2) - 1])\
    \ / 2f;\n        }\n        int[] a = new int[size / 2];\n        float[] b =\
    \ new float[size / 2];\n        for (int i = 0; i < size / 2; i++) {\n       \
    \     a[i] = (int) l[i];\n            b[i] = (float) l[i];\n        }\n      \
    \  a[size / 2] = size - 1;\n        b[size / 2] = 0.0f;\n        Array.Sort(a,\
    \ b);\n        return b[size / 2];", "        if (l == null || l.Count < 2) {\n\
    \            throw new ArgumentException(\"List must contain at least two elements\
    \ to compute median.\");\n        }\n        float v = l.Average();\n        int\
    \ pos = 0;\n        for (int i = 1; i < l.Count; ++i) {\n            if (v > l[i])\
    \ {\n                pos = i;\n                break;\n            }\n       \
    \ }\n        return l[pos];", '        return l.OrderBy(x => x).Skip(l.Count /
    2).Average();', "        int n = l.Count;\n        if (n < 2)\n            return\
    \ (float)0;\n\n        int half = n / 2;\n        long leftSum = 0L, rightSum\
    \ = 0L;\n        long sum = 0L;\n\n        // Add up all numbers except the middle\
    \ one\n        for (int i = 0; i < half; i++)\n            sum += l[i];\n\n  \
    \      leftSum += sum;\n\n        // Add up all numbers except the first half\
    \ (first half\n        // contains the median and second half contains first half)\n\
    \        for (int i = 0; i < half; i++)\n            sum += l[i];\n\n        rightSum\
    \ += sum;\n\n        // Divide the two numbers and return the result\n       \
    \ return (float)(leftSum + rightSum / 2) / n;", "        if (l.Count == 0) return\
    \ 0.0f;\n        List<long> sorted = l.OrderBy(item => item).ToList();\n     \
    \   if (sorted.Count == 1) return sorted[0];\n        long middle = sorted.Count\
    \ / 2;\n        float leftMedian = Median(sorted.Take(middle).ToList());\n   \
    \     float rightMedian = Median(sorted.Skip(middle + 1).ToList());\n        return\
    \ float.Parse((leftMedian + rightMedian) / 2);", "        // Write your code here.\n\
    \        if (l.Count == 0) throw new ArgumentOutOfRangeException(\"l\", \"l is\
    \ empty\");\n        if (l.Count == 1) return l[0];\n        long half = l.Count\
    \ / 2;\n        long[] left = l.Take(half).ToArray();\n        long[] right =\
    \ l.Skip(half).ToArray();\n        float mid1 = (float)Median(left);\n       \
    \ float mid2 = (float)Median(right);\n        return mid1 + (mid2 - mid1) / 2;",
  "        Debug.Assert(!l.Any());\n        if (l.Count < 2) return float.MaxValue;\n\
    \        long a = l[0], b = l[1], c = l[2];\n        int count = 1;\n        for\
    \ (int i = 3; i < l.Count; i++) {\n            a = (a * count) + l[i];\n     \
    \       b = b * count) + l[i];\n            c = c * count) + l[i];\n         \
    \   count++;\n        }\n        float average = (float)(a + b + c) / 3;\n   \
    \     if (average == (float)a) {\n            return (float)a;\n        }\n  \
    \      if (average == (float)b) {\n            return (float)b;\n        }\n \
    \       if (average == (float)c) {\n            return (float)c;\n        }\n\
    \        return average;", "        if (l.Count < 2) return (float)l.First();\n\
    \        float v = l.Where(a => a > l.First()).OrderBy(a => a).First();\n    \
    \    foreach (long n in l.Skip(1)) {\n            if (n > v) v = n;\n        }\n\
    \        return (float)v;", "        // Sort list in increasing order.\n     \
    \   l.Sort();\n\n        // Find median in two sublists.\n        float median\
    \ = ((l.Count % 2 == 0) ?\n            l.ElementAt(l.Count / 2L) :\n         \
    \   (l.Count / 2.0f) * l.ElementAt(l.Count / 2L) + ((float)l.ElementAt(l.Count\
    \ / 2L + 1L) - l.ElementAt(l.Count / 2L)));\n\n        // Return median.\n   \
    \     return median;", "        long median = l.Skip(l.Count / 2).Average();\n\
    \        if (l.Count % 2 == 0) return (float)(median + l.Skip(l.Count / 2).Average());\n\
    \        else return (float)(median + l.Skip(l.Count / 2 - 1).Average());", " \
    \       ArrayList list = new ArrayList();\n        foreach (long element in l)\
    \ {\n            list.Add(element);\n        }\n        Array.Sort(list);\n  \
    \      return (float)list[list.Count / 2];", "        double s = 0.0;\n      \
    \  long median, pos;\n        double nums = new List<double>();\n        for (int\
    \ i = 0; i < l.Count; i++) {\n            nums.Add(l[i]);\n            pos = i;\n\
    \        }\n        nums.Sort();\n        median = (long)nums[(nums.Count / 2)];\n\
    \        for (int i = l.Count - 1; i > -1; i--) {\n            if (l[i] < median)\
    \ {\n                median = l[i];\n                pos = i;\n            }\n\
    \        }\n        if (l.Count == 1) {\n            return (float)(l[0]);\n \
    \       }\n        return (float)median;", "        IList<long> sorted = l.OrderBy(x\
    \ => x).ToList();\n        if (sorted.Count % 2 != 0) // If list is odd length,\
    \ middle element is always the median.\n            return sorted[sorted.Count\
    \ / 2];\n        else\n            return (float)((sorted.Sum(x => x) + sorted.Last())\
    \ / 2);", "        long mid = l.Count / 2;\n        long median = 0;\n       \
    \ long min = 0;\n        long max = 0;\n\n        if (l.Count % 2 == 0) {\n  \
    \          median = (l[mid] + l[mid-1]) / 2L;\n        } else {\n            median\
    \ = l[mid];\n        }\n        if (l.Count % 2 == 1) {\n            min = (long)l[mid];\n\
    \        } else {\n            min = l[mid-1];\n        }\n        if (l.Count\
    \ % 2 == 0) {\n            max = (long)l[mid];\n        } else {\n           \
    \ max = l[mid+1];\n        }\n\n        return (float)(median + ((max - min) /\
    \ 2));", "        float median = 0f;\n        if (l.Count > 1)\n            median\
    \ = l.Sum(x => x) / l.Count;\n        return median;", "        float sum = 0.0f;\n\
    \        float average = 0.0f;\n        int size = l.Count;\n        if (size\
    \ > 1) {\n            for (int i = 1; i < size; i++) {\n                sum +=\
    \ l[i];\n            }\n            average = sum / size;\n        }\n       \
    \ if (size > 2) {\n            int mid = size / 2;\n            float sum1 = 0.0f;\n\
    \            float sum2 = 0.0f;\n            for (int i = mid; i < size; i++)\
    \ {\n                sum1 += l[i];\n            }\n            sum2 += l[mid];\n\
    \            average = sum1 / mid;\n            return (float)((sum2 - sum1) /\
    \ mid);\n        }\n        return average;", "        long min = l.Min();\n \
    \       long max = l.Max();\n        if (l.Count > 1) {\n            float a =\
    \ (float)(l.Sum() / l.Count);\n            float b = (float)(max - min);\n   \
    \         return (a * b) / (a + b); // median = (sum - min) / (max - min)\n  \
    \      }\n        return 0.0f;", "        if (l.Count > 1) return l.Select((x,\
    \ i) => new { Value = x, Index = i })\n            .OrderByDescending(x => x.Value)\n\
    \            .Select(x => x.Value)\n            .First();\n        return 0.0f;",
  "        l.Sort();\n        long num1 = l[0], num2 = l[l.Count/2];\n        if (num1\
    \ > num2) {\n            return num1;\n        }\n        return num2;", "   \
    \     Debug.Assert(l != null);\n        Debug.Assert(l.Count > 0);\n        long\
    \ total = l.Sum();\n        if (total%2 == 0)\n            return l.Where((i,\
    \ n) => i % 2 == 0).First() + (float)l.Where((i, n) => i % 2 == 0).Last() /2;\n\
    \        else\n            return l.Where((i, n) => i % 2 != 0).First() + (float)l.Where((i,\
    \ n) => i % 2 != 0).Last() /2;", "        List<long> sorted = l.OrderBy(o => o).ToList();\n\
    \        if (sorted.Count % 2 == 0) return (float)sorted[sorted.Count / 2] + sorted[sorted.Count\
    \ / 2 - 1] / 2;\n        else return (float)sorted[sorted.Count / 2 - 1] / 2;",
  "        if (l.Count <= 1) {\n            return l.ElementAt(0);\n        }\n  \
    \      var n = l.Count;\n        if (n % 2 == 0) {\n            return (l.ElementAt(n\
    \ / 2) - l.ElementAt(n / 2).ElementAt(0)) /\n                (float)((n / 2.0)\
    \ - 1);\n        } else {\n            return l.ElementAt(n / 2);\n        }",
  "        long total = 0;\n        float average = 0;\n        foreach (long x in\
    \ l)\n        {\n            total += x;\n        }\n        if (total == 0)\n\
    \            return average;\n        average = (float)total / l.Count;\n    \
    \    float median = l.Skip(l.Count / 2).Average();\n        if (average == median)\n\
    \            return median;\n        else if (median == 0)\n            return\
    \ 0;\n        else\n            return average - Median(l.Take(l.Count / 2 - 1));",
  "        var sorted = l.OrderBy( o => o );\n        return sorted.Count % 2 == 0\n\
    \            ? (float)sorted.Skip(sorted.Count / 2).First() + (float)sorted.Skip(sorted.Count\
    \ / 2).Last()\n            : (float)sorted.Skip(sorted.Count / 2).Last();", " \
    \       long[] arr = l.ToArray();\n        long[] sorted = new long[arr.Length];\n\
    \        Array.Sort(arr);\n        long middle = sorted.Length / 2;\n        long\
    \ first = 0;\n        long last = arr.Length - 1;\n        float f = (float)sorted[middle];\n\
    \        float m = (float)arr[(sorted.Length - 1) / 2];\n        if (arr[0] <\
    \ arr[m]) {\n            return f;\n        }\n        if (arr[m] < arr[0]) {\n\
    \            m = sorted[0];\n        }\n        return (first <= last) ? f : (float)sorted[sorted.Length\
    \ / 2];", "        long mid = l.Count/2;\n        long low = l.Take(mid).Sum();\n\
    \        long high = l.Skip(mid).Sum();\n        long median = (high + low) /\
    \ 2;\n        return (float)median;", "        if (l.Count < 2) throw new ArgumentException(\"\
    Need at least two elements to do median\");\n        l.Sort();\n        var mid\
    \ = l.Count/2; // midpoint of list\n        var median = (float)l[mid]; // median\
    \ of the elements\n        var left = new List<long>(l.Skip(mid).Take(l.Count\
    \ - mid));\n        var right = new List<long>(l.Skip((mid+1)).Take(l.Count -\
    \ mid));\n        // If median is either left or right, return it.\n        if\
    \ (median <= left[0] || median <= right[0]) return (float)median;\n        if\
    \ (median >= left[left.Count - 1] || median >= right[right.Count - 1]) return\
    \ (float)median;\n        // If median is in the center of both lists, return\n\
    \        // the smaller of the two medians encountered so far.\n        float\
    \ m1, m2;\n        if (left[0] >= right[0])\n            m1 = left[0];\n     \
    \   else\n            m1 = right[0];\n        if (left[left.Count - 1] >= right[right.Count\
    \ - 1])\n            m2 = left[left.Count - 1];\n        else\n            m2\
    \ = right[right.Count - 1];\n        if (m1 < m2) return (float)m1;\n        if\
    \ (m2 < m1) return (float)m2;\n        // If median is in the left list but not\
    \ the right,\n        // return the left median.\n        if (left[0] < right[right.Count\
    \ - 1])\n            return (float)left[0];\n        // If median is in the right\
    \ list but not the left,\n        // return the right median.\n        if (left[left.Count\
    \ - 1] < right[0])\n            return (float)left[left.Count - 1];\n        //\
    \ Otherwise, we return the median that lies in the middle of the\n        // lists.\n\
    \        return (float)((left + right).Skip(1).Take(l.Count - 1).Average());",
  "        long[] arr = l.ToArray();\n        if (arr.Length % 2 == 0) {\n       \
    \     return (arr[arr.Length / 2] + arr[arr.Length / 2 - 1]) / 2;\n        }\n\
    \        return arr[arr.Length / 2];", "        // If there are less than two\
    \ elements in the list, return zero.\n        if (l.Count == 0)\n            return\
    \ 0f;\n\n        // If there are two or fewer elements, return middle element.\n\
    \        if (l.Count == 1 || l.Count % 2 == 0)\n            return l.Count / 2.0f;\n\
    \n        // Sort the list and return the middle element.  \n        // Note the\
    \ sort algorithm used is stable.  Thus duplicates are sorted \n        // to the\
    \ front.  \n        l.Sort();\n        return l[l.Count / 2];", "        // return\
    \ median of elements in the list\n        return float.Parse(l.Average(d => d));",
  "        if (l.Count == 0) {\n            return 0.0f;\n        }\n\n        if\
    \ (l.Count == 1) {\n            return l[0];\n        }\n\n        double min\
    \ = l[0];\n        double max = l[0];\n        foreach (double x in l) {\n   \
    \         min = MathNet.Numerics.LinearAlgebra.Min(min, x);\n            max =\
    \ MathNet.Numerics.LinearAlgebra.Max(max, x);\n        }\n\n        return MathNet.Numerics.LinearAlgebra.DivRem(min,\
    \ max, out double m);", "        long[] data = new long[l.Count];\n        for\
    \ (int i = 0; i < l.Count; i++)\n            data[i] = l[i];\n        Array.Sort(data);\n\
    \        int index = (data.Length + 1) / 2;\n        if (data.Length % 2 == 1)\n\
    \            return data[index];\n        if (data.Length % 2 == 0)\n        \
    \    return data[index - 1] + (data[index] - data[index - 1]) / 2f;", "      \
    \  int count = l.Count;\n        if (count == 0) throw new InvalidOperationException(\"\
    Count of elements is 0.\");\n        float median = (float)l.Average();\n    \
    \    foreach (long i in l) {\n            if (i < median) median = i;\n      \
    \  }\n        return median;", "        if (l.Count % 2 == 0)\n            return\
    \ (float)(l.Skip(l.Count / 2).Average());\n        else\n            return (float)(l.Skip(l.Count\
    \ / 2 + 1).Average());", '        return l.OrderBy(x => x).Select(x => x).Where(x
    => x >= 0).OrderBy(x => x).LastOrDefault() / 2;', "        if (l.Count < 2)\n\
    \            return 0.0f;\n        long m = l[l.Count / 2];\n        l.Sort();\n\
    \        for (int i = 0; i < l.Count - 1; ++i)\n            if (l[i] < m)\n  \
    \              l[i] = m + 1;\n            else\n                l[i] = m - 1;\n\
    \        return (float)m;", "        float n = l.Count;\n        if (n < 1) return\
    \ 0f;\n\n        float v = l.Count / 2;\n        float m = l.Count / 2;\n    \
    \    if (n & 1) return (float)l[n/2];\n        float x = (float)(l[n/2] - l[v]);\n\
    \        if (n < 3) return x;\n        float y = (float)(l[v+1] - l[n/2]);\n \
    \       if (n < 5) return y;\n        return m + x;", "        if (l.Count ==\
    \ 0)\n            return float.NaN;\n        l.Sort();\n        if (l.Count ==\
    \ 1)\n            return l[0];\n        if (l.Count % 2 == 0)\n            return\
    \ (float)l[(l.Count / 2) - 1] + (float)l[l.Count / 2];\n        else\n       \
    \     return (float)l[l.Count / 2];", "        if (l.Count < 1) throw new ArgumentException(\"\
    List is empty.\");\n        if (l.Count % 2 != 0) return (float)(l.Sorted((x,y)\
    \ => x-y).ElementAt(l.Count / 2));\n        else return (float)(l.Sorted((x,y)\
    \ => x-y).ElementAt(l.Count / 2) + l.Sorted((x,y) => x-y).ElementAt(l.Count /\
    \ 2 - 1));", "        var n = l.Count;\n        if (n < 2) return 0.0;\n     \
    \   // Use an intermediate list to sort each element,\n        // then return\
    \ (l + n/2).Skip(1).First()\n        return (l.Concat(l.Skip(1).Select(x => x)).OrderBy(x\
    \ => x).Take((n + 1) >> 1).Sum()) / n;", "        var sortedList = l.OrderBy(x\
    \ => (float)x).ToArray();\n        if (sortedList.Length % 2 == 0) {\n       \
    \     return (sortedList[sortedList.Length / 2] + (sortedList[sortedList.Length\
    \ / 2 - 1])) / 2.0;\n        }\n        return sortedList[(sortedList.Length -\
    \ 1) / 2];", "        bool oddElement = false;\n        float media = -1f;\n\n\
    \        if (l.Count % 2 == 1) {\n            float median = (l[l.Count / 2] +\
    \ (l.Count / 2) / 2f);\n            media = median;\n        }\n        else {\n\
    \            float median = (l[l.Count / 2] + l[l.Count / 2 - 1]) / 2;\n     \
    \       media = median;\n            oddElement = true;\n        }\n        if\
    \ (oddElement == true) {\n            media = median + .5f;\n        }\n     \
    \   return media;", "        if (l.Count == 0) {\n            throw new InvalidOperationException(\"\
    Median of empty list.\");\n        }\n        long mid = l.Count / 2;\n      \
    \  float firstHalf;\n        float secondHalf;\n        if (l.Count % 2 == 0)\
    \ {\n            firstHalf = l.Take(mid).Sum(x => (float)x);\n            secondHalf\
    \ = l.Skip(mid).Sum(x => (float)x);\n        } else {\n            firstHalf =\
    \ l.Skip(mid).Sum(x => (float)x);\n            secondHalf = l.Take(mid).Sum(x\
    \ => (float)x);\n        }\n        return firstHalf / secondHalf;", "       \
    \ if (l.Count <= 1) {\n            return l[0];\n        }\n        float x =\
    \ (float)l.Count / 2L;\n        float median = l[x];\n        long medianIndex\
    \ = 0L;\n        for (long i = x; i > 0; i--) {\n            if (l[i] < median)\
    \ {\n                median = l[i];\n                medianIndex = i;\n      \
    \      }\n        }\n        long count = 0;\n        for (long i = medianIndex;\
    \ i < l.Count; i++) {\n            if (l[i] != median) {\n                count++;\n\
    \            }\n        }\n        return (float)median;", "        long l = l.Sum();\n\
    \        double m = l.Where((long x) => x >= 0).Sum() / l.Count;\n        if (l\
    \ % 2 == 0)\n            return (float)m;\n        return (float)((m + 0.5m) /\
    \ 2);", "        float ret = (float)((l.Count > 1) ? (l.Skip(l.Count / 2).Take(l.Count\
    \ / 2).Average()) : (l[0]));\n        return ret;", "        long[] v = l.ToArray();\n\
    \        v.Sort();\n        return v[v.length / 2];", "        int[] nums = new\
    \ int[l.Count];\n        int count = 0;\n        foreach(long l in l) {\n    \
    \        if (nums[count] != 0) nums[count] = Math.Min(nums[count], l);\n     \
    \       else nums[count++] = l;\n        }\n        return nums[(l.Count / 2)\
    \ + (l.Count % 2)] / 2L;", "        long sum = 0;\n        foreach (var x in l)\n\
    \            sum += x;\n        float median = (float)sum / l.Count;\n       \
    \ return median;", "        l.Sort();\n        if (l.Count % 2 == 0) {\n     \
    \       return (float)(l[l.Count / 2-1] + l[l.Count / 2]) / 2;\n        }\n  \
    \      return l[l.Count / 2];", "        if (l.Count == 0) {\n            return\
    \ 0f;\n        }\n        float[] d = new float[l.Count];\n        int count =\
    \ 0;\n        foreach (long l in l) {\n            ++count;\n            d[count]\
    \ = (float)l;\n        }\n        Array.Sort(d, (d, i) => { return (float)i; });\n\
    \        int mid = count / 2;\n        float x = (float)d[mid];\n        float\
    \ y = (float)d[mid + 1];\n        if (count % 2 == 0) {\n            return (x\
    \ + y) / 2;\n        }\n        return y;", "        l.Sort();\n        int mid\
    \ = (l.Count - 1) / 2;\n        if (l.Count % 2 == 1) {\n            return (float)l[mid];\n\
    \        }\n        return (float)(l[mid] + l[mid-1]) / 2;", "        ArrayList\
    \ a = new ArrayList();\n        foreach (long l in l) {\n            a.Add(l);\n\
    \        }\n        Array.Sort(a);\n        return a[a.Count/2];", "        IEnumerable<long>\
    \ sorted = l.OrderBy(i => i);\n        return sorted.Skip(sorted.Count() / 2).Take(1).Single();",
  "        if (l.Count < 2) return (float)l.ElementAt((l.Count/2)-1);\n        //\
    \ Find the middle point.\n        int i = (l.Count/2)-1;\n        int j = (l.Count/2)+1;\n\
    \        // Loop over list to find median.\n        float middle = l[i];\n   \
    \     for (int k = i; k < l.Count; k++) {\n            middle = (middle + l[k])\
    \ / 2;\n        }\n        // Find the first and last elements which are less\
    \ than or equal to median.\n        int lower = 0;\n        int upper = l.Count\
    \ - 1;\n        // While there are elements which are not less than median.\n\
    \        while (upper - lower >= 1) {\n            // Find the midpoint of median.\n\
    \            float x = l[i];\n            int m = (int)(x + l[lower]) / 2;\n \
    \           // If median element is less than or equal to median.\n          \
    \  if (x < m) {\n                lower = m;\n                i++;\n          \
    \  }\n            else {\n                upper = m;\n                j--;\n \
    \           }\n        }\n        // Check if there are two elements less than\
    \ median.\n        if (upper - lower == 1) return (float)middle;\n        if (upper\
    \ - lower == 2) return (float)l[j];\n        // Return median of elements between\
    \ lower and upper.\n        return (l[lower] + l[upper]) / 2;", "        int count\
    \ = l.Count;\n        if (count % 2 == 0) {\n            float left = (float)l[count\
    \ / 2 - 1];\n            float right = (float)l[count / 2];\n            return\
    \ (left + right) / 2.0f;\n        }\n        float middle = l[count / 2];\n  \
    \      if (l.Count % 2 == 1) {\n            float left = l[count / 2];\n     \
    \       float right = l[count / 2 - 1];\n            return (left + right) / 2.0f;\n\
    \        }\n        return middle; // even", "        // http://stackoverflow.com/questions/1354203/median-in-linq\n\
    \        // http://stackoverflow.com/questions/2760884/median-function-in-linq\n\
    \        // https://stackoverflow.com/questions/4498465/how-to-calculate-median-using-linq\n\
    \        // http://stackoverflow.com/questions/1044542/how-to-find-median-with-c\n\
    \        l.Sort();\n        int n = l.Count;\n        if (n < 3)\n           \
    \ return l[n/2];\n        float m = l[(n - 1) / 2];\n        float lb = l[n/2-1];\n\
    \        float ub = l[n/2];\n        return (float)(m + (ub - lb)/2.0);", "  \
    \      float median = 0;\n        if (l.Count % 2 != 0)\n            return (float)l.SortedIndexOf((long)((l.SortedLast()+l.SortedFirst())/2)).Item1;\n\
    \        int low = l.Count / 2;\n        int high = l.Count - 1;\n        if (l[low]\
    \ > l[high])\n            swap(l, low, high);\n        median += l[low];\n   \
    \     for (int i = low; i <= high; i++)\n            median += l[i];\n       \
    \ median /= 2;\n        return median;", "        float median;\n        long\
    \ medianVal;\n        float temp;\n        int size = l.Count;\n        if (size\
    \ == 0) return (float)0f;\n        median = (float)0;\n        medianVal = (long)0;\n\
    \        l.Sort();\n        float medianValue = 0;\n        temp = l.Count / 2;\n\
    \        for (int i = 0; i < size; i++) {\n            if (i == temp) {\n    \
    \            medianValue = l[i];\n            } else {\n                median\
    \ = (float)(medianValue + l[i]);\n            }\n        }\n        return median;",
  "        l.Sort();\n        long sum = 0;\n        foreach (long item in l)\n  \
    \          sum += item;\n        long index = (long)l.Count / 2;\n        float\
    \ average = (float)sum / index;\n        if (l.Count == 0)\n            return\
    \ 0;\n        if (l.Count % 2 == 0)\n            return l[index];\n        else\n\
    \            return average + (l[index + 1] - average);", "        var nums =\
    \ new double[l.Count];\n        for (int i = 0; i < nums.Length; i++)\n      \
    \      nums[i] = l[i];\n        nums.Sort();\n        return nums[nums.Length\
    \ / 2];", "        l.Sort();\n        return l.Count % 2 == 0 ? l.Where((x, i)\
    \ => i % 2 == 0).Sum() / (l.Count / 2.0) \n                : l.Where((x, i) =>\
    \ i % 2 == 1).Sum() / (l.Count / 2.0);", "        if (l.Count < 2) {\n       \
    \     return l[0];\n        }\n        l.Sort();\n        float midPoint = (float)\
    \ l.Count / 2;\n        float midIndex = 0;\n        float lowerBound = 0;\n \
    \       float upperBound = l[midPoint];\n        while (midPoint < l.Count) {\n\
    \            if (l[midPoint] < lowerBound) {\n                lowerBound = l[midPoint];\n\
    \            }\n            if (l[midPoint] >= upperBound) {\n               \
    \ upperBound = l[midPoint];\n            }\n            midPoint++;\n        \
    \    midIndex++;\n        }\n        return (lowerBound + upperBound) / 2;", " \
    \       if (l == null)\n            throw new ArgumentNullException(\"list\");\n\
    \        long total = 0;\n        float mid = 0;\n        foreach (long item in\
    \ l)\n            total += item;\n        float count = 0;\n        while (total\
    \ > 0 && count < l.Count) {\n            mid = total / 2;\n            total -=\
    \ mid * 2;\n            count++;\n        }\n        float median = 0;\n     \
    \   if (count > 0)\n            median = (float)(total / count);\n        return\
    \ median;", "        var median = l.Count / 2;\n        var medianValue = l.Skip(median).Take(1).Single();\n\
    \        return (float)medianValue;", "        if (l.Count % 2 == 0)\n       \
    \     return (float)((float)l.Where(x => x % 2 == 0).Min() + (float)l.Where(x\
    \ => x % 2 == 1).Min()) / 2.0f;\n        else\n            return (float)((float)l.Where(x\
    \ => x % 2 == 1).Min() + (float)l.Where(x => x % 2 == 0).Min()) / 2.0f;", "  \
    \      int n = l.Count;\n        if (n % 2 == 0) {\n            float a = l.ElementAt(n\
    \ / 2);\n            float b = l.ElementAt(n / 2 - 1);\n            return (a\
    \ * n + b) / n;\n        } else {\n            return (float)(l.ElementAt(n /\
    \ 2)) + 0.5f;\n        }", "        if (l.Count == 0)\n            throw new ArgumentException(\"\
    Input list must be non-empty.\");\n\n        long[] arr = l.ToArray();\n     \
    \   int n = arr.Length;\n        if (n % 2 == 0) {\n            return float.Parse(string.Format(\"\
    {0}.0f\", arr[n/2 - 1] + (arr[n/2] / 2.0f)));\n        } else {\n            return\
    \ float.Parse(string.Format(\"{0}.0f\", arr[(n-1)/2]));\n        }", "       \
    \ float[] vals = l.Select(x => (float)x).ToArray();\n        Array.Sort(vals);\n\
    \        return (float)vals[vals.Length / 2]; ", "        float x = 0.0f;\n  \
    \      var n = l.Count;\n        if (n > 0) {\n            long a = l[n / 2];\n\
    \            for (int i = n - 1; i >= 0; i--) {\n                var b = l[i];\n\
    \                float delta = b - a;\n                if (delta < 0) {\n    \
    \                delta = -delta;\n                }\n                a = b;\n\
    \                x = delta;\n            }\n        }\n        return x;", " \
    \       // Convert to array of doubles.\n        double[] d = l.ToArray();\n \
    \       Array.Sort(d);\n        double mid = d.Length / 2;\n        return (d.Length\
    \ % 2 == 1) ? (d[mid] + d[mid + 1]) / 2 : d[mid];", "        Debug.Assert(l.Count\
    \ > 0);\n        var n = l.Count;\n        if (n & 1 == 1) {\n            return\
    \ l[(n >> 1) + 1];\n        }\n        long mid = n >> 1;\n        if (n > 25)\
    \ {\n            return Median(l.Take(mid).Concat(l.Skip(mid)).ToList());\n  \
    \      }\n        return Median(l.Take(mid).Concat(l.Skip(mid)).OrderBy(x => x).Select(x\
    \ => x).ToList());", "        if (l.Count == 0) {\n            return 0f;\n  \
    \      }\n        float res = l[0];\n        int count = 0;\n        foreach (long\
    \ i in l) {\n            if (i != res) {\n                count++;\n         \
    \   }\n        }\n        int size = (int)(l.Count / count);\n        if (l.Count\
    \ % count != 0) {\n            size++;\n        }\n        for (int i = 0; i <\
    \ size; i++) {\n            res += l[count * size + i];\n        }\n        return\
    \ res / count;", "        if (l.Count == 0) return 0f;\n\n        long sum = 0;\n\
    \        long m = l.Count / 2;\n        for (long i = 1; i < m; i++)\n       \
    \     sum += l[i];\n\n        float median = (float)(sum / m);\n        return\
    \ median;", '        return l.Sort().Skip(l.Count()/2).Average();', "        if\
    \ (l.Count == 0)\n            return 0;\n        var sorted = l.OrderBy(x => x).ToList();\n\
    \        return sorted.Skip(sorted.Count / 2).Select(x => x).Average();", "  \
    \      long med = l.OrderBy(x => x).First();\n        return med;", '        return
    l.Sort().Skip(l.Count/2).Average();', "        long mid = l.Count / 2;\n     \
    \   if (l.Count % 2 == 1) return l[mid];\n        int left = 0, right = 0;\n \
    \       while (left < mid) {\n            if (l[left] > l[right]) { right = left;\
    \ }\n            else { left = left + 1;  }\n        }\n        return (float)l[left]\
    \ + (float)l[right] / 2;", "        var sorted = l.OrderBy(x => x).ToArray();\n\
    \        if (sorted.Length == 1)\n            return sorted[0];\n        return\
    \ SortedArrayExtensions.Median(sorted);", '        return l.GroupBy(x => x).OrderByDescending(g
    => g.Count()).First().Average();', "        if (l.Count == 0) throw new ArgumentException(\"\
    List must contain at least one element.\");\n        float median = l.Count >\
    \ 1 ? l.OrderByDescending(n => n).Take(1).First() : 0;\n        float mean = l.Sum()\
    \ / l.Count;\n        return mean == 0 ? median : median - new Numerics.Statistics.Median().Compute(new\
    \ float[] { mean }, null);", "        var x = new long[l.Count];\n        l.CopyTo(x,\
    \ 0);\n\n        long median = 0;\n        long smallest = long.MaxValue;\n  \
    \      long largest = long.MinValue;\n\n        for (int i = 0; i < x.Length;\
    \ i++) {\n            long x = x[i];\n\n            if (x < smallest) {\n    \
    \            smallest = x;\n            }\n            if (x > largest) {\n  \
    \              largest = x;\n            }\n        }\n\n        if (x.Length\
    \ % 2 == 0) {\n            return (smallest + largest) / 2;\n        }\n\n   \
    \     int i = x.Length / 2;\n        long left = 0;\n        long right = x.Length\
    \ - 1;\n\n        double mid = (left + right) / 2;\n        long midValue = x[mid];\n\
    \        double leftValue = 0;\n        double rightValue = 0;\n\n        while\
    \ (left < right) {\n            leftValue = x[left];\n            rightValue =\
    \ x[right];\n\n            if (leftValue < rightValue && midValue < leftValue)\
    \ {\n                median = (left + right) / 2;\n                break;\n  \
    \          }\n            if (leftValue < rightValue && midValue > rightValue)\
    \ {\n                median = left + 1;\n                break;\n            }\n\
    \            if (leftValue > rightValue && midValue > leftValue) {\n         \
    \       median = right - 1;\n                break;\n            }\n         \
    \   if (leftValue > rightValue && midValue == leftValue) {\n                median\
    \ = left + 1;\n                break;\n            }\n\n            left++;\n\
    \            right--;\n        }\n        return float.Parse((midValue.ToString(\"\
    F1\") + \"f\"));", "        Debug.Assert(l.Count > 0);\n        if (l.Count ==\
    \ 1)\n            return l[0];\n        var half = l.Count / 2;\n        return\
    \ l.Sort((x, y) => y - x).Skip(half).First() + l.Sort((x, y) => y - x).Take(half).First();",
  "        l.Sort();\n        return l.Skip(l.Count / 2).Take(l.Count / 2).Average();",
  "        Debug.Assert(l != null);\n        var n1 = l.Count;\n        if (n1 <=\
    \ 1) return (float)l1[0];\n        float median = (float)l1[n1/2];\n        float\
    \ temp;\n        for (int i = 0; i < n1/2; ++i) {\n            temp = l[i];\n\
    \            l[i] = l[n1 - 1 - i];\n            l[n1 - 1 - i] = temp;\n      \
    \  }\n        float temp2 = l1[n1 - 1];\n        temp2 = ((float)((double)n1 /\
    \ 2) + temp2) / 2;\n        return median + (float)temp2;", "        // Sort the\
    \ array. \n        // The sort is stable, so equal elements are sorted in order.\n\
    \        Array.Sort(l);\n        // Get the middle value\n        int m = (int)l.Count\
    \ / 2;\n        // If number of elements is odd, return the middle element.\n\
    \        if (l.Count % 2 == 1) {\n            return l[m];\n        }\n      \
    \  // Otherwise, return the average of the two middle elements.\n        float\
    \ ret = (float)l[m] + (float)l[m + 1];\n        // Return median value.\n    \
    \    return ret;", "        if (l == null || l.Count == 0)\n            return\
    \ (float)0;\n        if (l.Count % 2 == 1)\n            return (float)l[(l.Count\
    \ / 2) - 1]; // Even\n        else // Odd\n            return (l.Max() + l.Min())\
    \ / 2.0f;", "        if (l.Count == 0)\n            return 0.0f;\n        long\
    \ min = l.Min();\n        long max = l.Max();\n        if (min == max)\n     \
    \       return (float)min;\n        float v = (float)min + (max - min) / 2.0f;\n\
    \        int count = 0;\n        foreach (long x in l)\n            if (x > v)\n\
    \                count++;\n        if (count % 2 == 0)\n            return (float)(v\
    \ + l[count / 2 - 1]) / 2.0f;\n        else\n            return v;", "       \
    \ if (l == null)\n            throw new ArgumentNullException(\"l\");\n\n    \
    \    if (l.Count < 2)\n            return l[0];\n\n        long[] array = new\
    \ long[l.Count - 1];\n        l.CopyTo(array, 0);\n\n        Array.Sort(array);\n\
    \n        return array[l.Count / 2];", "        float median = 0;\n        if\
    \ (l.Count % 2 == 0) {\n            median = (float)Math.Sqrt(l.Take(l.Count/2-1).Sum()/l.Count);\n\
    \        } else {\n            median = (float)l.Take(l.Count/2-1).Sum()/l.Count;\n\
    \        }\n        return median;", "        if (l.Count == 0) return 0.0f;\n\
    \        var x = l.OrderBy(v => v).Skip(l.Count / 2).Take(l.Count / 2).ToList();\n\
    \        if (x.Count % 2 == 0) return x[(x.Count / 2)];\n        return (x[x.Count\
    \ / 2 - 1] + x[x.Count / 2]) / 2.0f;", "        Debug.Assert(l.Count >= 1);\n\
    \        long median = (long) l.Count / 2.0;\n        long left = median;\n  \
    \      long right = median;\n        float result = 0.0f;\n        while (true)\
    \ {\n            if (left < right) {\n                long tmp = l[left];\n  \
    \              l[left] = l[right];\n                l[right] = tmp;\n        \
    \        left++;\n                right--;\n            } else if (left == right)\
    \ {\n                return l[left];\n            } else {\n                long\
    \ tmp = l[left];\n                l[left] = l[right];\n                l[right]\
    \ = tmp;\n                left++;\n                right--;\n            }\n \
    \       }", "        var count = l.Count;\n        if (count == 0) return 0f;\n\
    \        long middle = (count / 2);\n        if (count == 1) return l.First();\n\
    \        if (count == 2) return l.ElementAt(0);\n        double result = (double)l.ElementAt(middle);\n\
    \        int i = middle - 1;\n        for (int j = 2; j <= count; ++j) {\n   \
    \         if (i == middle - 1) {\n                long temp = (long)l.ElementAt(j);\n\
    \                if (temp > result) result = temp;\n                continue;\n\
    \            }\n            long temp = (long)l.ElementAt(j);\n            if\
    \ (temp < result) result = temp;\n            ++i;\n        }\n        return\
    \ result + 0.5f;", "        float avg = 0.0f;\n        var numElements = l.Count;\n\
    \        if (numElements > 0) {\n            var sum = 0.0f;\n            for\
    \ (var i = 0; i < numElements; i++)\n                sum += l[i];\n          \
    \  avg = sum / numElements;\n        }\n        return avg;", "        if (l.Count\
    \ > 1)\n            return (float)(l.Cast<long>().OrderByDescending(x => x).ElementAtOrDefault(l.Count\
    \ / 2));\n        else if (l.Count == 1)\n            return (float)l.First();\n\
    \        else\n            return (long)0;", "        // Get the middle element\
    \ of the list.\n        var m = l.Skip(l.Count / 2).First();\n        // Get the\
    \ number of elements.\n        var n = l.Count;\n        // Get the arithmetic\
    \ mean of the list.\n        var mean = l.Average();\n        // Calculate the\
    \ median of the list.\n        var median = m + 0.5f * (n - 1.0);\n        //\
    \ Return the arithmetic mean of the list.\n        return (float)(mean * n) /\
    \ n;", "        if (l.Count % 2 == 0) {\n            return (float)l.Sort((a,\
    \ b) => a > b)[l.Count / 2];\n        }\n        else {\n            return (float)l.Sort((a,\
    \ b) => a > b)[l.Count / 2 + 1];\n        }", '        return l.Select(x => x).OrderBy(x
    => x).Skip(1).FirstOrDefault() ?? l.Last();', '        return l.OrderBy(n => n).Skip(l.Count
    / 2).FirstOrDefault();', "        if (l.Count == 0)\n            return 0.0f;\n\
    \n        float temp = (l.Sum() / l.Count);\n        var sorted = l.OrderBy(l\
    \ => l);\n\n        if (sorted.Count() > 1)\n        {\n            float median\
    \ = sorted.Skip(1).First();\n            return sorted[sorted.Count() / 2 - 1].Count\
    \ > 1\n                ? (median + sorted[sorted.Count() / 2].Average()) / 2\n\
    \                : median;\n        }\n        else\n        {\n            return\
    \ sorted[0];\n        }", "        ArrayList al = new ArrayList();\n        foreach\
    \ (long i in l) {\n            al.Add(i);\n        }\n        if (al.Count ==\
    \ 0) return (float)0f;\n        ArrayList al2 = new ArrayList();\n        foreach\
    \ (long i in al) {\n            al2.Add(i);\n        }\n        al2.Sort();\n\
    \        return (float)al2[(al2.Count - 1) / 2];", "        long total = 0L;\n\
    \        long count = 0;\n        float med = (float)(int.MinValue + int.MaxValue);\n\
    \        foreach (long l in l) {\n            total += l;\n            count++;\n\
    \        }\n        if (count % 2 == 1) {\n            med = total / 2;\n    \
    \    } else {\n            med = total / 2 + total / 2;\n        }\n        return\
    \ med;", "        double len = l.Sum();\n        if (len <= 0) {\n           \
    \ throw new ArgumentException();\n        }\n        float low = 0, high = len\
    \ / 2;\n        float median = (float)low + high;\n        for (int i = 0; i <\
    \ l.Count; i++) {\n            low = high;\n            high = (float)l.ElementAt(i);\n\
    \            double d = high - low;\n            if (d == 0) {\n             \
    \   median = float.NaN;\n                break;\n            }\n            float\
    \ f = (float)d / (float)len;\n            low = median + f;\n            high\
    \ = median - f;\n        }\n        return median;", "        l.Sort();\n    \
    \    int size = l.Count;\n        if (size == 0) throw new ArgumentException(\"\
    List is empty.\", \"l\");\n        float r = float.MaxValue;\n        float median\
    \ = float.MinValue;\n        int mid;\n        if (size / 2 == 0) throw new ArgumentException(\"\
    List is empty.\", \"l\");\n        mid = size / 2;\n        mid = size / 2;\n\
    \        for (int i = 0; i < mid; i++) {\n            r = r + l[i];\n        }\n\
    \        mid = size / 2;\n        for (int i = mid; i < size; i++) {\n       \
    \     if (l[i] > r) {\n                r = l[i];\n            }\n        }\n \
    \       median = (r + l[mid]) / 2;\n        return median;", "        if (l.Count\
    \ == 0)\n            throw new ArgumentException(\"List cannot be empty.\");\n\
    \        l.Sort();\n        if (l.Count % 2 == 0)\n            return l.Count\
    \ == 1 ? l[0] : (l.Count / 2 + l[(l.Count / 2) - 1] + l[l.Count / 2]) / 2;\n \
    \       else\n            return (l.Count / 2) / 2;", "        long a = l.Sum()\
    \ % 2 == 0 ? l.Sum() : (long) l.Count;\n        long c = l.Count % 2 == 0 ? l.Count\
    \ : (long) l.Count / 2;\n        long[] x = l.ToArray();\n        Array.Sort(x);\n\
    \        if ((x.Length % 2) == 0) {\n            return (float) x[(x.Length /\
    \ 2) - 1];\n        } else {\n            return (float) (float) x[(x.Length /\
    \ 2)];\n        }", "        double s = l.Sum();\n        int n = l.Count;\n \
    \       if (n == 0) return (float)0;\n        double d = s / n;\n        long\
    \ i = l.IndexOf(Math.Round(d, MidpointRounding.ToEven));\n        if (i != 0)\
    \ return l[i - 1];\n        int half = n/4 + 1;\n        if (n <= 3) return (float)s;\n\
    \        if (n == 1) return (float)d;\n        if (n == 2) return (float)(Math.Sqrt(d));\n\
    \        if (n == half) return (float)(((double)((l[half-1] + l[half]) / 2)) +\
    \ d);\n        if (n == half) return (float)(((double)((l[half-1] + l[half]) /\
    \ 2)) + d);\n        if (n == half + 1) return (float)(((double)((l[half-2] +\
    \ l[half]) / 2)) + d);\n        return (float)(((double)((l[half-1] + l[half])\
    \ / 2)) + d);", "        float x = 0;\n        double sum = 0;\n        foreach\
    \ (long n in l) {\n            sum += n;\n            x = sum / l.Count;\n   \
    \     }\n        return Convert.ToSingle(x);", "        IList<float> list = l.ToList().ConvertAll(f\
    \ => (float)f);\n        if (list.Count == 0) throw new ArgumentException(\"Input\
    \ must be a list of positive numbers.\");\n        if (list.Count % 2 == 0) return\
    \ list[list.Count / 2];\n        int middle = list.Count / 2;\n        int left\
    \ = middle - 1;\n        int right = middle;\n        if (list[left] > list[right])\
    \ right--;\n        while (right >= left) {\n            if (list[left] >= list[right])\
    \ break;\n            right--;\n        }\n        if (right <= left + 1) return\
    \ list[left];\n        left++;\n        while (right < list.Count) {\n       \
    \     if (list[right] <= list[left]) break;\n            left++;\n        }\n\
    \        return list[left];", "        if (l.Count == 0)\n            return 0.0;\n\
    \        long mid = l[l.Count / 2].Value;\n        var low = l.Where(x => x.Value\
    \ <= mid);\n        var high = l.Where(x => x.Value > mid);\n        var result\
    \ = low.Count() > high.Count() ? low.Average() : high.Average();\n        return\
    \ result;", "        if (l.Count <= 1) return l.Average();\n        long median\
    \ = l.OrderByDescending(e => e).Skip(1).First();\n        float mid = l.FindIndex(e\
    \ => e == median);\n        if (mid == -1) return (float)median;\n        return\
    \ (float)median;", "        // Return median. Assumes list l is sorted.\n    \
    \    if (l.Count % 2 == 1) {\n            return (float)l.ElementAt((l.Count /\
    \ 2));\n        }\n        long m = ((long)(l.Count / 2)) + 1;\n        return\
    \ (float)l.ElementAt(m);", '        return l.OrderByDescending(x => x).First();',
  "        if (l.Count == 0) return (float)0.0;\n        SortedDictionary<long, int>\
    \ counts = new SortedDictionary<long, int>();\n        foreach (long n in l) {\n\
    \            if (counts.ContainsKey(n)) {\n                counts[n] = counts[n]\
    \ + 1;\n            } else {\n                counts.Add(n, 1);\n            }\n\
    \        }\n        int m = (int)((l.Count() + 1.0f - 1.0f) / (2.0f - 1.0f));\n\
    \        int count = 0;\n        foreach (long n in counts) {\n            count\
    \ = Math.Max(count, n);\n        }\n        float x = 0.0f;\n        for (int\
    \ i = m; i >= 0; i--) {\n            x = count / (i + 1.0f);\n            if (x\
    \ >= (count / 2.0f)) break;\n        }\n        return x;", "        List<long>\
    \ a = new List<long>(l);\n        if (Math.Sqrt(a.Count) < 1) return float.NaN;\n\
    \        long a = a.Count / 2;\n        return a[Math.Floor(a)].CompareTo(a[Math.Floor(a+1)])\
    \ < 0 ? a[Math.Floor(a)] : a[Math.Floor(a+1)];", "        var sortedList = l.OrderByDescending(i\
    \ => i);\n        var midpoint = (int)sortedList.Count / 2;\n        return sortedList[midpoint];",
  "        // Return median of elements in the list l.\n        double sum = 0;\n\
    \        double max = l.Max();\n        double min = l.Min();\n        // For\
    \ each element e in the list...\n        foreach (long e in l) {\n           \
    \ // ...compute sum of elements less than e.\n            double l = e.CompareTo(min);\n\
    \            // ...and sum of elements greater than e.\n            double r =\
    \ e.CompareTo(max);\n            sum += l < r ? l : r;\n        }\n        //\
    \ Return median as float.\n        return sum / l.Count;", "        int size =\
    \ l.Count;\n        long median = l[size / 2];\n        for (int i = size / 2;\
    \ i < size; i++)\n            median = (long)((median + l[size - i]) / 2.0f);\n\
    \        return (float)median;", "        Array.Sort(l);\n        return (l.Count\
    \ == 0) ? 0f : (float)l.Count / 2;", "        if (l.Count % 2 == 0) {\n      \
    \      return (float)l.OrderBy(x => (float)x).Skip(l.Count/2).First();\n     \
    \   }\n        else {\n            return (float)l.OrderByDescending(x => (float)x).Skip(l.Count/2).First();\n\
    \        }", "        ArrayList list = new ArrayList(l);\n        Array.Sort(list);\n\
    \        float x = (float)list[list.Count / 2];\n        list = new ArrayList();\n\
    \        return list;", "        l.Sort();\n        if (l.Count == 0) return 0f;\n\
    \        return l.Skip(l.Count / 2).Sum() / 2;", "        if (l.Count <= 1) return\
    \ (float)l[0];\n        var m = l.Count / 2;\n        float left = (float)l.ElementAt(m\
    \ - 1);\n        float right = (float)l.ElementAt(m);\n        return ((left +\
    \ right) / 2.0f);", "        long middle = l.Count / 2;\n        if (l.Count %\
    \ 2 == 0) {\n            return (float)l.Sort((x, y) => y - x).Last();\n     \
    \   } else {\n            return (float)l.Sort((x, y) => y - x).First();\n   \
    \     }", "        if (l.Count < 3) {\n            return float.MaxValue;\n  \
    \      }\n        float f1 = l[0];\n        float f2 = l[1];\n        float f3\
    \ = l[2];\n        float f = (f1 + f2 + f3) / 3f;\n        float f4 = f;\n   \
    \     for (int i = 3; i < l.Count; ++i) {\n            f = ((f1 + f2 + f3) / 3f)\
    \ + ((f[i] - f[i - 1]) / 2f);\n            f4 = f + f4;\n        }\n        return\
    \ f;", "        double size = l.Count;\n        if (size % 2 == 0) {\n       \
    \     int mid = size / 2;\n            int count = 0;\n            double x =\
    \ 0.0;\n            long min = l[mid];\n            foreach (long value in l)\
    \ {\n                count += 1;\n                if (count == mid) {\n      \
    \              x = (float)value;\n                    break;\n               \
    \ } else if (value < min) {\n                    min = value;\n              \
    \  }\n            }\n            return (float)(mid + (float)((count + 1) / (2.0f\
    \ * size)));\n        } else {\n            int mid = size / 2 - 1;\n        \
    \    double x = 0.0;\n            long max = l[mid];\n            foreach (long\
    \ value in l) {\n                if (value == max) {\n                    x =\
    \ (float)value;\n                    break;\n                } else if (value\
    \ > max) {\n                    max = value;\n                }\n            }\n\
    \            return (float)(mid + (float)((count + 1) / (2.0f * size)));\n   \
    \     }", "        long median = 0;\n        long first;\n        long second;\n\
    \        long third;\n        long fourth;\n        if (l.Count == 0) {\n    \
    \        return 0.0f;\n        }\n        if (l.Count == 1) {\n            return\
    \ l[0];\n        }\n        first = l.OrderBy(x => x).First();\n        median\
    \ = first;\n        second = l.Skip(1).OrderBy(x => x).First();\n        third\
    \ = l.Skip(2).OrderBy(x => x).First();\n        fourth = l.Skip(3).OrderBy(x =>\
    \ x).First();\n        if (first < second && first < third && first < fourth)\
    \ {\n            median = first;\n        } else if (second < third && second\
    \ < fourth) {\n            median = second;\n        } else if (third < fourth)\
    \ {\n            median = third;\n        }\n        return (float)median;", " \
    \       if (l.Count % 2 == 0) {\n            l.Sort();\n            return (float)(l.GetValue((l.Count\
    \ - 1) / 2.0f));\n        }\n        else {\n            l.Sort();\n         \
    \   l.Remove((l.Count - 1) / 2.0f);\n            return (l.GetValue((l.Count -\
    \ 1) / 2.0f));\n        }", "        long sortedLstLong = l.OrderBy(x => x).ToArray()[0];\n\
    \        long sum = 0;\n        foreach (long num in l) {\n            sum +=\
    \ num;\n        }\n        return sum/l.Count();", "        var sorted = l.OrderBy(x\
    \ => x).ToArray();\n        if (sorted.Length % 2 == 0) {\n            int center\
    \ = sorted.Length / 2;\n            float median = (float)(sorted[center-1] +\
    \ sorted[center]) / 2.0f;\n            return median;\n        }\n        else\
    \ {\n            int center = sorted.Length / 2;\n            return (float)(sorted[center\
    \ - 1] + sorted[center + 1]) / 2.0f;\n        }", "        // Sort list l.\n \
    \       l.Sort();\n\n        // Find midpoint.\n        long midPoint = l.Count\
    \ / 2;\n\n        // If list contains at least two elements, return average of\
    \ medians of first and last elements,\n        // otherwise return None.\n   \
    \     if (l.Count > 1) {\n            return l.Skip(1).Take(2).Select(x => (x\
    \ - l[0]) / 2).Average();\n        }\n\n        // If list contains no elements,\
    \ return None.\n        return float.NaN;", "        float m = (float)l.Count\
    \ / 2.0f;\n        l.Sort();\n        int low = 0;\n        int high = l.Count\
    \ - 1;\n        while (low < high) {\n            float mid = (float)low + (float)high;\n\
    \            if (mid % 2 == 0) {\n                if (m[mid / 2] == m[mid]) {\n\
    \                    low++;\n                } else {\n                    high--;\n\
    \                }\n            } else {\n                if (m[mid / 2] > m[mid])\
    \ {\n                    high--;\n                } else {\n                 \
    \   low++;\n                }\n            }\n        }\n        return m[high];",
  "        int k = (l.Count - 1) / 2;\n        if (k < 0) k = k + 1;\n        return\
    \ l.OrderBy(n => n).Skip(k).Take(1).Average();", "        // Find the median as\
    \ the (sorted) middle element, i.e.:\n        // >>> Median((new List<long>(new\
    \ long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))\n        // (float)2L\n\
    \        // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L,\
    \ (long)1000L, (long)10L, (long)20L})))\n        // (10.0f)\n        var n = l.Count;\n\
    \        if (n % 2 == 0) {\n            return l[n / 2];\n        } else {\n \
    \           var half = (int)(n / 2);\n            var left = l.Take(half);\n \
    \           var right = l.Skip(half);\n            return Median(left) + Median(right);\n\
    \        }", "        long l1 = l.Count() / 2;\n        return l.Skip(l1).Take(l1).Average();",
  "        var list = l.ToArray();\n        if (list.Length % 2 == 1) {\n        \
    \    list.Add(list[list.Count - 1]);\n        }\n        Array.Sort(list);\n \
    \       int mid = list.Length / 2;\n        int i = (list.Length / 2) - 1;\n \
    \       return (float)list[mid];", "        float n = l.Count;\n        float\
    \ sum = 0.0f;\n        foreach (float v in l)\n            sum += v;\n       \
    \ if (n < 1) return 0.0f;\n        if (sum % 2 == 0) {\n            return (float)l[(int)n\
    \ / 2];\n        }\n        return (float)((l[n / 2] + l[n / 2 - 1]) / 2.0);",
  "        long median = 0;\n        long middle = 0;\n        int leng = l.Count;\n\
    \        if (leng < 1) throw new ArgumentOutOfRangeException(\"l\");\n       \
    \ if (leng % 2 != 0) throw new ArgumentOutOfRangeException(\"l\");\n        long\
    \ mid = leng / 2;\n        foreach (long l in l)\n        {\n            if (l\
    \ < mid) continue;\n            if (l > mid) break;\n            median = l;\n\
    \            break;\n        }\n        return float.Parse(Math.Truncate(median.ToString(\"\
    F0\")));", "        float a = 0.0;\n        float b = 0.0;\n        float c =\
    \ 0.0;\n        l.Sort();\n        bool first = true;\n        float c = l[l.Count/2];\n\
    \        for (int i = 0; i < l.Count/2; i++)\n        {\n            if (first)\n\
    \            {\n                a = l[i];\n                first = false;\n  \
    \          }\n            else\n            {\n                b = l[i];\n   \
    \             if (b < a)\n                {\n                    a = b;\n    \
    \            }\n            }\n        }\n        for (int i = 0; i < l.Count/2;\
    \ i++)\n        {\n            c = l[i];\n            if (c == a)\n          \
    \  {\n                return a;\n            }\n        }\n        Console.WriteLine(\"\
    Median() fails\");\n        return 0.0;", "        var list = l.ToList();\n  \
    \      if (list.Count == 0) return 0f;\n        list.Sort();\n        if (list.Count\
    \ == 1) return list[0];\n        float lower = list[list.Count / 2];\n       \
    \ float upper = list[list.Count / 2 - 1];\n        return (float)(lower + upper)\
    \ / 2;", "        // Find the middle element of the list.\n        int mid = l.Count\
    \ / 2;\n        float val1 = l[mid];\n        float val2 = l[mid];\n        if\
    \ (mid > 0)\n            val2 = l[mid - 1];\n        return val1 + (val2 - val1)\
    \ / 2.0f;", "        Array.Sort(l);\n        int size = l.Count;\n        if (size\
    \ == 1) return l[0];\n        if (size == 2) {\n            long first = l[0];\n\
    \            long second = l[1];\n            return first + second;\n       \
    \ }\n        float middle = (int)(size / 2);\n        if (size == 3) return l[middle];\n\
    \        float leftMedian = Median(l);\n        float rightMedian = Median(l.Skip(middle\
    \ + 1).Take(size - middle - 1));\n        return (leftMedian + rightMedian) /\
    \ 2;", "        float x = 0.0f;\n        float y = 0.0f;\n        l.Sort();\n\
    \        int n = l.Count;\n        if (n > 0) {\n            x = l[(n - 1) / 2];\n\
    \            y = l[n / 2];\n        }\n        return (x < y) ? x : y;", "   \
    \     int n = l.Count;\n        if (n < 2)\n            return l[n / 2];\n   \
    \     var sorted = l.OrderBy(i => i);\n        int mid = sorted.Count / 2;\n \
    \       if (mid == 0)\n            return sorted[0];\n        else if (mid ==\
    \ 1)\n            return sorted[n/2];\n        else {\n            var left =\
    \ sorted.Take(mid);\n            var right = sorted.Skip(mid);\n            float\
    \ m = left[left.Count / 2] / 2;\n            return m + Median(right);\n     \
    \   }", "        if (l.Count % 2 != 0) return (float)(((l.GetValueAtOrDefault(l.Count\
    \ / 2) - l.GetValueAtOrDefault(l.Count / 2 - 1)) + l.GetValueAtOrDefault(l.Count\
    \ / 2)) / 2.0f);\n        else return (float)((l.GetValueAtOrDefault(l.Count /\
    \ 2) - l.GetValueAtOrDefault(l.Count / 2 - 1)) / 2.0f);", '        return l.Sort().Skip(l.Count
    / 2).First();', "        l.Sort();\n        return l[l.Count / 2];", "       \
    \ long median;\n        bool swapped;\n        float medianValue = (float)int.MaxValue;\n\
    \        long.TryParse((l.ElementAt(l.Count / 2) as string).Trim(), out median);\n\
    \        if (median == (long)int.MinValue) {\n            l.Sort();\n        \
    \    swapped= true;\n        }\n        else {\n            l.Sort();\n      \
    \      swapped= false;\n        }\n        medianValue = (float)l.ElementAt(l.Count\
    \ / 2) as float;\n        if (l.Count % 2 == 0) {\n            return medianValue;\n\
    \        }\n        else if (!swapped) {\n            return (median + l.ElementAt(l.Count\
    \ / 2 - 1) as float) / 2.0f;\n        }\n        else {\n            return (median\
    \ + l.ElementAt(l.Count / 2) as float) / 2.0f;\n        }", '        return l.Sort().Skip((l.Count
    / 2)).Take(1).Last();', "        var array = l.ToArray();\n        if (array.Length\
    \ % 2 == 1)\n            return array[array.Length / 2];\n        return (array[array.Length\
    \ / 2] + array[array.Length / 2 - 1]) / 2f;", "        int count = l.Count;\n\
    \        if (count == 0) throw new ArgumentException(\"List is empty.\");\n  \
    \      // Count even: take average of first two and last two.\n        // Count\
    \ odd: average of first two, first one, last two, and last one.\n        float\
    \ mid = count % 2 == 0 ? l.ElementAt(count / 2) - .5f : ((l.ElementAt(count /\
    \ 2) + l.ElementAt(count / 2 - 1)) / 2);\n        // If list is even, we must\
    \ take the average of middle two elements.\n        // Else we must average middle\
    \ two and middle one,\n        // so two middle elements.\n        if (count %\
    \ 2 == 0) return (count / 2) * mid + l.ElementAt(count / 2);\n        else return\
    \ mid + l.ElementAt(count / 2 - 1);", '        return l.OrderBy(x => x).Skip(l.Count
    / 2).Take(l.Count / 2).Average();', "        float num = (float)0;\n        float\
    \ den = (float)0;\n        foreach (var item in l) {\n            num += item;\n\
    \            den++;\n        }\n        if (den == 0) {\n            return num;\n\
    \        }\n        float result = num / den;\n        return result;", "    \
    \    var nums = l.ToArray();\n        if (nums.Length % 2 == 1) {\n          \
    \  nums = new long[nums.Length / 2];\n            for (int i = 0; i < nums.Length\
    \ / 2; i++) {\n                nums[i] = nums[(i + nums.Length / 2) % nums.Length];\n\
    \            }\n        }\n        // Sort the list, putting any equal values\
    \ together.\n        Array.Sort(nums);\n\n        var low = nums[nums.Length /\
    \ 2];\n        var high = nums[nums.Length / 2 - 1];\n        var middle = nums[nums.Length\
    \ / 4];\n\n        return low;", "        if (l.Count % 2 == 0)\n            return\
    \ (l.First() + l.Last()) / 2.0f;\n        else\n            return (float)(l.Skip((l.Count\
    \ - 1) / 2).Take(2).Sum() / (l.Count / 2));", "        ArrayList a = new ArrayList();\n\
    \        foreach (long i in l) a.Add(i);\n        int mid = a.Count / 2;\n   \
    \     if (a.Count % 2 == 1) return (float)a[mid];\n        float m1 = (float)a[mid\
    \ - 1];\n        float m2 = (float)a[mid];\n        return Math.Round((m1 + m2)\
    \ / 2, MidpointRounding.AwayFromZero);", '        return l.Select(a => (float)(a)).OrderBy(a
    => a).Skip(1).First();', "        if (l.Count % 2 == 0) {\n            return\
    \ l[l.Count / 2] / (float)2;\n        }\n\n        List<long> even = new List<long>(l.Count);\n\
    \        List<long> odd = new List<long>(l.Count);\n        foreach (long i in\
    \ l)\n            if (i % 2 == 0) even.Add(i);\n            else odd.Add(i);\n\
    \        even.Add(odd.Count / 2);\n\n        return Median(even);", "        int\
    \ n = l.Count;\n        if (n == 0)\n            return 0;\n        if (n == 1)\n\
    \            return l[0];\n        long[] arr = l.ToArray();\n        float mid\
    \ = arr[n / 2];\n        int half = (int)(n / 2) - 1;\n        float left;\n \
    \       float right;\n        if (n % 2 == 1) {\n            left = arr[half -\
    \ 1];\n            right = arr[half];\n        }\n        else {\n           \
    \ left = arr[half - 2];\n            right = arr[half-1];\n        }\n       \
    \ return (left + right) / 2.0f;", "        // Sort array using quicksort\n   \
    \     Array.Sort(l);\n        float median = 0;\n        long pos = 0;\n     \
    \   long stop = 0;\n        int count = l.Count;\n        if (count % 2 == 0)\
    \ {\n            int middle = (count / 2) + 1;\n            stop = middle; //\
    \ position of median\n            pos = middle - 1; // left index\n          \
    \  median = l[pos];\n            for (pos = pos + 1; pos < count; pos++) {\n \
    \               if (l[pos] < median) {\n                    median = l[pos];\n\
    \                    stop = pos;\n                }\n            }\n        }\
    \ else {\n            pos = count / 2;\n            median = l[pos];\n       \
    \     stop = (count / 2) - 1;\n        }\n        float leftsum = 0;\n       \
    \ float rightsum = 0;\n        float leftmedian = 0;\n        float rightmedian\
    \ = 0;\n        for (int i = pos; i < stop; i++) {\n            leftsum += l[i];\n\
    \        }\n        for (int i = pos + 1; i < stop; i++) {\n            rightsum\
    \ += l[i];\n        }\n        leftmedian = (float)leftsum / count;\n        rightmedian\
    \ = (float)rightsum / count;\n        if (leftmedian < rightmedian) {\n      \
    \      return leftmedian;\n        }\n        return rightmedian;", "        if\
    \ (l.Count == 0) return 0f;\n        long middle = l.Count / 2;\n        long[]\
    \ left = new long[middle];\n        long[] right = new long[middle - 1];\n\n \
    \       for (int i = 0; i < left.Count; i++) {\n            left[i] = l[i];\n\
    \        }\n\n        for (int i = left.Count; i > 0; i--) {\n            right[i\
    \ - 1] = l[i - 1];\n        }\n\n        left = left.Take(left.Count / 2).ToArray();\n\
    \        right = right.Skip(right.Count / 2).ToArray();\n\n        int leftCount\
    \ = 0;\n        int rightCount = 0;\n\n        float median;\n        if (left.Count\
    \ == 0) {\n            median = 0;\n        } else if (right.Count == 0) {\n \
    \           median = left[0];\n        } else {\n            median = left.Average()\
    \ + right.Average();\n        }\n\n        leftCount = left.Count;\n        rightCount\
    \ = right.Count;\n\n        double total = 0;\n        int n = 0;\n\n        while\
    \ (n > 0 && n * (n - 1) < left.Count && n <= right.Count) {\n            double\
    \ sum = left.Sum(x => Math.Abs(x - median));\n            total += sum;\n    \
    \        n++;\n        }\n\n        if (n == 0)\n            return 0;\n     \
    \   else if (n == 1)\n            return median;\n        else {\n           \
    \ return float.Parse(total / n);\n        }", "        int size = l.Count;\n \
    \       long[] data = l.ToArray();\n        Array.Sort(data);\n        if (size\
    \ == 0) return 0.0f;\n        float mid = data[size / 2];\n        int low = 0;\n\
    \        int high = size / 2;\n        while (high - low > 1) {\n            int\
    \ m = (high + low) / 2;\n            if (data[m] < mid) low = m;\n           \
    \ else high = m;\n        }\n        return mid;", "        long largest = l.Max();\n\
    \        long smallest = l.Min();\n        if (largest == smallest) {\n      \
    \      return float.MaxValue;\n        }\n        if (largest == 0) {\n      \
    \      return 0.0f;\n        }\n        if (smallest == 0) {\n            return\
    \ float.MinValue;\n        }\n\n        return ((float)largest + smallest) / 2.0f;",
  "        int[] median = new int[l.Count];\n        int n = l.Count;\n        int\
    \ mIndex = 0;\n        int mValue = int.MaxValue;\n        for (int i = 1; i <\
    \ n; i++) {\n            int mCount = 0;\n            long mid = Convert.ToInt64(Math.Round(l[i]\
    \ + (l[i - 1]) / 2));\n            mCount++;\n            int cIndex = 0;\n  \
    \          for (int j = i; j < n; j++) {\n                long cValue = Convert.ToInt64(Math.Round(l[j]));\n\
    \                if (mValue < cValue) {\n                    mValue = cValue;\n\
    \                    mCount = mCount + 1;\n                    mIndex = j;\n \
    \               }\n                cIndex++;\n            }\n            if (mCount\
    \ > median[mIndex])\n                median[mIndex] = mCount;\n        }\n\n \
    \       float xMedian;\n        if (median[0] > median[n - 1]) {\n           \
    \ xMedian = (float)median[n - 1];\n        } else {\n            xMedian = (float)median[0];\n\
    \        }\n        return xMedian;", "        if (l.Count == 0) throw new ArgumentException(\"\
    List must be non-empty.\");\n        var sortedList = l.OrderBy(x => x);\n   \
    \     var middleElement = sortedList.Skip(l.Count / 2).First();\n        return\
    \ ((float)middleElement);", "        Array.Sort(l);\n        var count = l.Count;\n\
    \        if (count == 0)\n            return 0;\n        return count == 1 ? l.First()\
    \ : ((l.First() + l.Last()) / 2);", "        if (l.Count == 0) return 0f;\n  \
    \      l.Sort();\n        long mid = l.Count / 2;\n        return (float)(l[mid]\
    \ + l[mid-1]) / 2f;", "        int[] arr = l.ToArray();\n        Array.Sort(arr);\n\
    \        int half = arr.Length / 2;\n        return half%2 == 0 ? arr[half/2]\
    \ : (float)(arr.Length - arr.Length % 2 == 0 ? arr[half/2+1] : arr[half/2-1]);",
  "        l.Sort();\n        float lmedian = (float) l.Skip(l.Count / 2).First();\n\
    \        foreach (long elt in l.Skip(l.Count / 2)) {\n            if (elt != lmedian)\
    \ {\n                lmedian = (float) elt;\n            }\n        }\n      \
    \  return lmedian;", "        if (l.Count <= 1)\n            return l[0];\n\n\
    \        double m = l.Sum() / l.Count;\n        return l.IndexOf(Math.Round(m))\
    \ - 1;", "        if (l.Count % 2 == 1)\n            return l[l.Count / 2];\n\
    \        else\n            return (l.Skip(l.Count / 2).Take(1).Sum() / 2);", " \
    \       if (l.Count == 0) {\n            // There are no elements, just return\
    \ zero.\n            return 0;\n        }\n        \n        // If the list is\
    \ empty, return zero.\n        if (l.Count == 1)\n            return l[0];\n \
    \       \n        // Find the middle index.\n        int mid = (int)l.Count /\
    \ 2; // int.Parse avoids overflow\n        \n        // Find the median of the\
    \ two halves recursively.\n        float midVal = Median(l.Take(mid));\n     \
    \   float leftVal = Median(l.Skip(mid).Take(l.Count - mid));\n        \n     \
    \   // Return the average of the middle value and the two halves.\n        return\
    \ midVal + (leftVal / 2);", "        l.Sort();\n        return (float)l[l.Count\
    \ / 2];", "        var x = l.OrderBy(x => x).Select(x => new {Value = x}).ToList();\n\
    \        if (x.Count % 2 == 0) {\n            return (float)(x[x.Count / 2 - 1].Value\
    \ + x[x.Count / 2].Value) / 2.0f;\n        }\n        else {\n            return\
    \ x[x.Count / 2].Value;\n        }", "        Array.Sort(l);\n        return l[l.Count/2];",
  '        return l.GroupBy(x => (x / 2)).Select(x => x.OrderByDescending(y => y).First()).Select(x
    => (float)x).DefaultIfEmpty(0).Sum() / l.Count;', "        if (l == null || l.Count\
    \ == 0) {\n            throw new ArgumentException(\"List must be non-empty.\"\
    );\n        }\n        long median = 0;\n        int lsize = l.Count;\n      \
    \  float m1 = (float)median;\n        if (lsize % 2 == 0) {\n            median\
    \ = (l[lsize/2] + (l[lsize/2] - m1))/2.0;\n        }\n        else {\n       \
    \     median = ((l[lsize/2-1] + l[lsize/2]) / 2.0);\n        }\n        return\
    \ median;", "        // If list length is odd, ignore the last element.\n    \
    \    if (l.Count % 2 == 1) {\n            l.RemoveAt(l.Count - 1);\n        }\n\
    \        long l = l.Count;\n        // If the list has even length, find the average\
    \ of the two middle elements.\n        if (l % 2 == 0) {\n            return (float)((l\
    \ * (l.Count() / 2))) + (l.Count()/2);\n        }\n        // The list has odd\
    \ length, find the median of the two middle elements.\n        float half = l.Count()/2;\n\
    \        long median = l.FindIndex(i => ((long)i) <= half).Count > half ? l :\
    \ (l.FindIndex(i => ((long)i) >= half).Count > half ? l.FindIndex(i => ((long)i)\
    \ <= half).Count : l.FindIndex(i => ((long)i) >= half).Count );\n        return\
    \ median;", "        var list = l.OrderBy(x => x).ToList();\n        if (list.Count\
    \ % 2 == 0) {\n            return list[list.Count / 2];\n        } else {\n  \
    \          list.RemoveAt(list.Count / 2);\n            return (float)list.Sum(x\
    \ => (float)x) / (float)list.Count;\n        }", "        // Return median of\
    \ list\n        float m = 0.0f;\n        long n = (long)l.Count;\n        long\
    \ mid = n / 2;\n        if (n < 3) {\n            foreach (var item in l) {\n\
    \                m = Math.Max(item, m);\n            }\n            return m;\n\
    \        }\n        if (n == 2) {\n            foreach (var item in l) {\n   \
    \             m = Math.Max(item, m);\n            }\n            return m;\n \
    \       }\n        if (n < 5) {\n            int count = 0;\n            long\
    \ biggest = l.First();\n            foreach (var item in l) {\n              \
    \  count = count + 1;\n                biggest = Math.Max(biggest, item);\n  \
    \          }\n            return (l.Count % 2 == 1) ? ((float)((biggest + l.Last())\
    \ / 2.0f)) : (float)biggest;\n        }\n        if (n > 5) {\n            int\
    \ count = 0;\n            long biggest = l.First();\n            foreach (var\
    \ item in l) {\n                count = count + 1;\n                biggest =\
    \ Math.Max(biggest, item);\n            }\n            return (l.Count % 2 ==\
    \ 1) ? ((float)((biggest + l.Last()) / 2.0f)) : (float)biggest;\n        }\n \
    \       if (n % 2 == 1) {\n            int count = 0;\n            long biggest\
    \ = l.First();\n            foreach (var item in l) {\n                count =\
    \ count + 1;\n                biggest = Math.Max(biggest, item);\n           \
    \ }\n            double median = Convert.ToDouble(l.Count % 2 == 1) ? ((double)(biggest\
    \ + l.Last()) / 2.0d) : (double)biggest;\n            double x = Convert.ToDouble(l.Count\
    \ % 2 == 1) ? biggest : ((biggest + l.Last()) / 2.0d);\n            double s =\
    \ Math.Sqrt(Convert.ToDouble(l.Count % 2 == 1) ? (2 * median * median - x * (x\
    \ - x)) : (2 * biggest * biggest - x * (x - x)));\n            return (Math.Round(s\
    \ / Math.Sqrt(count), 4) * 10.0f);\n        }\n        double median;\n      \
    \  long biggest = l.First();\n        foreach (var item in l) {\n            biggest\
    \ = Math.Max(biggest, item);\n        }\n        median = Convert.ToDouble(biggest);\n\
    \        double x = Convert.ToDouble(biggest);\n        double s = Math.Sqrt(Convert.ToDouble(l.Count\
    \ % 2 == 1) ? (2 * median * median - x * (x - x)) : (2 * biggest * biggest - x\
    \ * (x - x)));\n        return (Math.Round(s / Math.Sqrt(l.Count), 4) * 10.0f);",
  "        l.Sort();\n        long l = l.Count;\n        if (l % 2 == 1) return l[l/2];\
    \ // odd: return middle value\n        else return (long)((l+1)/2);", "      \
    \  l.Sort();\n        if (l.Count % 2 == 1) return l[(l.Count / 2) - 1];\n   \
    \     if (l.Count % 2 == 0) return (float)(l.Count / 2);\n        int x = l.Count\
    \ / 2, y = l.Count / 2;\n        while (x < y) {\n            if (l[x] > l[y])\
    \ {\n                y = y + 1;\n            }\n            else if (l[x] < l[y])\
    \ {\n                x = x + 1;\n            }\n            else {\n         \
    \       break;\n            }\n        }\n        return l[y];", '        return
    l.Sort((x, y) => y - x).Skip(l.Count / 2).Take(1).DefaultIfEmpty(long.MaxValue).First();',
  "        long medianElement = l.OrderByDescending(x => x).First();\n        long\
    \ sumOfElements = l.Sum();\n        float average = (float)sumOfElements / l.Count;\n\
    \        float newMedian = average;\n\n        if (l.Count() % 2 == 0) {\n   \
    \         float even = l.Skip(1).Take(l.Count() / 2).Select(x => x).Sum();\n \
    \           newMedian = (float)even / 2;\n        }\n        return newMedian;",
  "        float sum = 0;\n        l.Sort();\n        foreach (var i in l) {\n   \
    \         sum += i;\n        }\n        return (float)Math.Round(sum / l.Count);",
  "        if (l == null || l.Count == 0)\n            throw new ArgumentException(\"\
    l is null or empty\");\n        if (l.Count % 2 == 0) {\n            float mid\
    \ = l[l.Count / 2];\n            return mid;\n        }\n        l.Sort();\n \
    \       int mid = l.Count / 2;\n        int leftIndex = 0, rightIndex = 0, index\
    \ = 0;\n        while (leftIndex < l.Count / 2 && rightIndex < l.Count) {\n  \
    \          if (l[leftIndex] <= l[rightIndex])\n                leftIndex++;\n\
    \            else\n                rightIndex++;\n        }\n        if (leftIndex\
    \ < l.Count / 2)\n            return l[leftIndex];\n        if (rightIndex < l.Count)\n\
    \            return l[rightIndex];\n        return l[index];", "        // Sort\
    \ the list.\n        l.Sort();\n        int middle = l.Count / 2;\n        if\
    \ (middle == 0) return (float)l[middle];\n        else return (float)Median(l,\
    \ (middle - 1), middle);", "        ArrayList sortedL = new ArrayList(l);\n  \
    \      sortedL.Sort();\n        int size = sortedL.Count;\n        if (size %\
    \ 2 == 1) {\n            return (sortedL[(size / 2) - 1] + sortedL[(size / 2)])\
    \ / 2.0f;\n        } else {\n            return (sortedL[(size / 2)]) / 2.0f;\n\
    \        }", "        long[] values = l.ToArray();\n        if (values.Length\
    \ % 2 == 0) {\n            long midpoint = values.Length / 2;\n            float\
    \ a = values[midpoint];\n            float b = values[midpoint + 1];\n       \
    \     return 0.5f * (a + b);\n        }\n        else {\n            int midpoint\
    \ = values.Length / 2;\n            float a = values[midpoint];\n            float\
    \ b = values[midpoint - 1];\n            return 0.5f * (a + b);\n        }", " \
    \       if (l.Count <= 1) return l[0];\n        long mid = l.Count / 2;\n    \
    \    float a = (float)l.Sort()[mid];\n        float b = (float)l.Sort().Skip(mid).First();\n\
    \        if (a == b) return a;\n        if (a > b) return Median(l.Skip(mid));\n\
    \        return Median(l.Take(mid).Concat(new List<long>() { b }).ToList());",
  '        return l.OrderBy(x => x).Skip(l.Count / 2).Select(x => (float)x).Skip(l.Count
    / 2).First();', "        if (l.Count == 0) return (float)0.0;\n\n        // Get\
    \ middle element\n        int middle = l.Count / 2;\n        long mid = l[middle];\n\
    \n        // Sort list\n        l.Sort();\n\n        // If mid is even then\n\
    \        // return mid - middle + 1\n        if (mid % 2 == 0) {\n           \
    \ return mid - middle + 1.0f;\n        } else {\n            // If mid is odd\
    \ then\n            // return middle - mid\n            return middle - mid;\n\
    \        }", "        var minCount = l.Count;\n        var maxCount = l.Count;\n\
    \        var medianCount = 0;\n        var median = 0;\n        l.Sort();\n\n\
    \        if (minCount % 2 == 0) {\n            minCount--;\n            medianCount++;\n\
    \        }\n\n        if (maxCount % 2 == 0) {\n            maxCount--;\n    \
    \        medianCount++;\n        }\n\n        if (maxCount < minCount) {\n   \
    \         medianCount++;\n        }\n\n        int middleCount = (minCount + maxCount)\
    \ / 2;\n        long medianValue = l[middleCount / 2];\n\n        foreach (long\
    \ i in l) {\n            if (medianValue < i) {\n                medianCount--;\n\
    \            }\n\n            if (medianCount < medianCount) {\n             \
    \   medianCount++;\n            }\n\n            if (medianCount == middleCount)\
    \ {\n                median = i;\n            }\n        }\n\n        return (float)median;",
  "        // Sort the list if it's not already sorted.\n        bool notSorted =\
    \ !(l.Sort(\n            (l, i, j) =>\n                l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) < 0\n                ? -1\n                : l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) > 0\n                ? 1\n                : 0\n            ));\n     \
    \   if (notSorted) {\n            l.Sort((l, i, j) =>\n                l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) < 0\n                    ? -1\n                    : l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) > 0\n                    ? 1\n                    : 0\n            );\n\
    \        }\n        int size = l.Count;\n        // If there are no elements,\
    \ just return the element.\n        if (size == 0)\n            return (float)l.ElementAt(0);\n\
    \        // If the list is sorted, return the middle element.\n        if (size\
    \ == 1)\n            return (float)l.ElementAt(1);\n        float middle = (size\
    \ + 1) >> 1;\n        int count = (int)(size / 2);\n        int median = middle;\
    \ // int is more accurate than float for median\n        // Split the list into\
    \ two, return the median of them.\n        List<float> left = new List<float>(count\
    \ + 1);\n        List<float> right = new List<float>(count + 1);\n        for\
    \ (int i = 0; i < count; i++)\n            left.Add(l.ElementAt(2 * i));\n   \
    \     for (int i = 0; i < count; i++)\n            right.Add(l.ElementAt(2 * i\
    \ + 1));\n        left.Sort(\n            (l, i, j) =>\n                l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) < 0\n                    ? -1\n                    : l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) > 0\n                    ? 1\n                    : 0\n        );\n  \
    \      right.Sort(\n            (l, i, j) =>\n                l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) < 0\n                    ? -1\n                    : l.ElementAt(j).CompareTo(l.ElementAt(j\
    \ + 1)) > 0\n                    ? 1\n                    : 0\n        );\n  \
    \      float leftMiddle = left[middle];\n        float rightMiddle = right[middle];\n\
    \        float medianLeft = (float)leftMiddle;\n        float medianRight = (float)rightMiddle;\n\
    \        // If there are an odd number of elements, return the middle element.\n\
    \        if (count & 1)\n            return (float)l.ElementAt(middle);\n    \
    \    // If the two middle elements are equal, return that element.\n        if\
    \ (leftMiddle == rightMiddle)\n            return (float)l.ElementAt(middle);\n\
    \        // If there are an even number of elements, return the average of the\
    \ two middle elements.\n        // This ensures that median([]) == ", "      \
    \  long m1 = l[0];\n        long m2 = l[0];\n        foreach (long n in l.Skip(1))\n\
    \        {\n            if (n > m1)\n                m2 = m1;\n            else\n\
    \                m2 = n;\n        }\n        return (float)m2;", "        float[]\
    \ sortedArr = l.ToArray();\n        Array.Sort(sortedArr);\n        if (sortedArr.Length\
    \ % 2 == 1) {\n            return (float)sortedArr[sortedArr.Length / 2];\n  \
    \      } else {\n            return (float)sortedArr[(sortedArr.Length / 2) -\
    \ 1] + (float)sortedArr[(sortedArr.Length / 2)];\n        }", "        Array.Sort(l);\n\
    \        Debug.Assert(l.Count >= 2);\n        return l.Skip(l.Count / 2).First();",
  "        int median = 0;\n        if (l.Count % 2 == 0) {\n            median =\
    \ (int)Math.Ceiling((double)l.Count / 2.0f);\n        }\n        else {\n    \
    \        median = (int)l.Count / 2.0f;\n        }\n        return l.OrderBy(x\
    \ => x).Skip(median).Take(1).DefaultIfEmpty().First();", '        return l.OrderBy(x
    => x).Skip(l.Count / 2).First();']
stop_tokens:
- "\n    }\n"
