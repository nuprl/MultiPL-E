name: HumanEval_24_largest_divisor
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // For a given number n, find the largest number that divides n\
  \ evenly, smaller than n\n    // >>> LargestDivisor((15L))\n    // (5L)\n    public\
  \ static long LargestDivisor(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestDivisor((3L))\
  \ == (1L));\n    Debug.Assert(LargestDivisor((7L)) == (1L));\n    Debug.Assert(LargestDivisor((10L))\
  \ == (5L));\n    Debug.Assert(LargestDivisor((100L)) == (50L));\n    Debug.Assert(LargestDivisor((49L))\
  \ == (7L));\n    }\n\n}\n"
completions: ["        if (n == 1)\n            return 1L;\n        if (n % 2 == 0\
    \ || n == 1)\n            return n;\n        long largest_divisor = n.ToUInt64().Divide(2).Max();\n\
    \        if (n % largest_divisor == 0)\n            return largest_divisor;\n\
    \        else\n            return LargestDivisor(largest_divisor);", "       \
    \ long a = 0, b = 1, c = 1;\n        for (int i = 1; i < 1000000000; i++) {\n\
    \            a = Math.Min(b, c);\n            if (n % a != 0) {\n            \
    \    b = c;\n                c = a;\n            } else {\n                c =\
    \ a + 1;\n            }\n        }\n        return a;", "        int result =\
    \ 0;\n        while (true) {\n            if (n % 2 == 0) {\n                result\
    \ = Math.Max(result, n/2);\n            }\n            if (n % 4 == 0) {\n   \
    \             result = Math.Max(result, n / 4);\n            }\n            if\
    \ (n % 6 == 0) {\n                result = Math.Max(result, n / 6);\n        \
    \    }\n            if (n % 8 == 0) {\n                result = Math.Max(result,\
    \ n / 8);\n            }\n            if (n % 10 == 0) {\n                result\
    \ = Math.Max(result, n / 10);\n            }\n            if (n % 12 == 0) {\n\
    \                result = Math.Max(result, n / 12);\n            }\n         \
    \   if (n % 14 == 0) {\n                result = Math.Max(result, n / 14);\n \
    \           }\n            n /= 2;\n            if (n == 0) {\n              \
    \  break;\n            }\n        }\n        return result;", "        long divisor;\n\
    \        for (divisor = 2; divisor < n; divisor += 2) {\n            if (n % divisor\
    \ == 0) {\n                break;\n            }\n        }\n        return divisor;",
  "        long largest = 0;\n        for (long i = 1; i <= n; i++) {\n          \
    \  if (n % i == 0) {\n                largest = i;\n                break;\n \
    \           }\n        }\n        return largest;", "        long maxDivisor =\
    \ n;\n        long lastDivisor = n; // we know our divisor is evenly divisible\
    \ by n\n        for (long i = 1; i < n; i++) {\n            if (lastDivisor %\
    \ 2 == 0) // we know our previous divisor is even\n            {\n           \
    \     long divisor = lastDivisor;\n                while (divisor < n && n % divisor\
    \ != 0) divisor++;\n                if (divisor > maxDivisor)\n              \
    \      maxDivisor = divisor;\n            }\n            lastDivisor = i;\n  \
    \      }\n        return maxDivisor;", "        long[] divisors = new long[] {\
    \ 1L };\n        // Divisors that are larger than n are ignored\n        for (long\
    \ divisor = 2L; divisor < n; divisor++) {\n            if (n % divisor == 0) {\n\
    \                divisors[divisors] = divisor;\n                divisors[divisors\
    \ * divisor] = divisor;\n                divisors[divisors * divisor + 1] = divisor;\n\
    \            }\n        }\n        long largestDivisor = 1;\n        int i = 0;\n\
    \        for (long divisor in divisors) {\n            largestDivisor = divisor;\n\
    \            if (divisors[i] == 0) {\n                i++;\n            }\n  \
    \      }\n        return largestDivisor;", "        long maxDivisor = 1;\n   \
    \     long currentDivisor = 1;\n        while (currentDivisor <= n) {\n      \
    \      if (n % currentDivisor == 0) {\n                currentDivisor++;\n   \
    \         } else {\n                maxDivisor = currentDivisor;\n           \
    \     currentDivisor = 1;\n            }\n        }\n        return maxDivisor;",
  "        long max = 1L;\n        long divisible = 1L;\n        while (n > 1) {\n\
    \            if (n % 2 == 0) {\n                divisible = divisible * 2;\n \
    \           }\n            n = n / 2;\n        }\n        return divisible ==\
    \ 1 ? divisible : max;", "        // The largest divisor is always 1\n       \
    \ // return 1 if we already know it, or \n        // return n if the divisor doesn't\
    \ divide evenly\n        if (n <= 0) return 1;\n        if (n < 2) return n;\n\
    \        if (n % 2 == 0) return n;\n        if (n % 3 == 0) return 3;\n      \
    \  // If n is a multiple of 3, return 3\n        int div = 3;\n        while (div\
    \ <= n / 3) {\n            if (n % div == 0) return div;\n            div += 3;\n\
    \        }\n        return 3;", "        if (n<2)\n            return 0;\n   \
    \     var largestDivisor = Divisors(n, true);\n        var largest = largestDivisor.Max();\n\
    \        return largest;", "        // Find all factors of n\n        long[] factors\
    \ = new long[n];\n        for (int i = 0; i < n; i++)\n            if (n%i ==\
    \ 0) {\n                factors[i] = i;\n                break;\n            }\n\
    \        // Find smallest factor smaller than n\n        Array.Sort(factors);\n\
    \        long minFactor = factors[0];\n        for (int i = 0; i < factors.Length;\
    \ i++) {\n            if (minFactor == factors[i]) {\n                minFactor\
    \ = factors[i - 1];\n            }\n        }\n        return minFactor;", " \
    \       long largestDivisor = n;\n        long currentDivisor = 1;\n        while\
    \ (currentDivisor < n) {\n            if (n % currentDivisor == 0) {\n       \
    \         largestDivisor = currentDivisor;\n            }\n            currentDivisor++;\n\
    \        }\n        return largestDivisor;", "        // Largest divisor is 0\
    \ because n % 0 = 0\n        // Largest divisor is 1 because n % 1 = 1\n     \
    \   // Largest divisor is n / 2 because n / 2 = n / 2\n        // Largest divisor\
    \ is n / 3 because n / 3 = n / 3\n        // Largest divisor is n / 4 because\
    \ n / 4 = n / 4\n        // Largest divisor is n / 5 because n / 5 = n / 5\n \
    \       // Largest divisor is n / 6 because n / 6 = n / 6\n        // Largest\
    \ divisor is n / 7 because n / 7 = n / 7\n        // Largest divisor is n / 8\
    \ because n / 8 = n / 8\n        // Largest divisor is n / 9 because n / 9 = n\
    \ / 9\n        // Largest divisor is n / 10 because n / 10 = n / 10\n        //\
    \ Largest divisor is n / 11 because n / 11 = n / 11\n        // Largest divisor\
    \ is n / 12 because n / 12 = n / 12\n        // Largest divisor is n / 13 because\
    \ n / 13 = n / 13\n        // Largest divisor is n / 14 because n / 14 = n / 14\n\
    \        // Largest divisor is n / 15 because n / 15 = n / 15\n        long maxDivisor\
    \ = 0;\n        long divisor = 1;\n\n        while (n > 0) {\n            divisor\
    \ = divisor > n / divisor ? divisor : n / divisor;\n\n            if (divisor\
    \ > maxDivisor) {\n                maxDivisor = divisor;\n            }\n    \
    \        n--;\n        }\n\n        return maxDivisor;", "        long highestDivisor\
    \ = 1;\n        long divisor = 1;\n        while (divisor <= n) {\n          \
    \  divisor *= 2L;\n            if (n % divisor == 0) {\n                highestDivisor\
    \ = divisor;\n            }\n            divisor++;\n        }\n        return\
    \ highestDivisor;", "        long ans = 1;\n        long max = 2;\n        long\
    \ min = 0;\n        while (min <= n) {\n            long m = max;\n          \
    \  if (max % 2 == 0) {\n                while (m <= n) {\n                   \
    \ m *= 2;\n                    if (m > n)\n                        break;\n  \
    \              }\n            } else {\n                while (m >= n) {\n   \
    \                 m /= 2;\n                    if (m < n)\n                  \
    \      break;\n                }\n            }\n            ans = Math.Max(ans,\
    \ m);\n            if (n == m)\n                break;\n            max = m;\n\
    \            min++;\n        }\n        return ans;", "        if (n < 0)\n  \
    \          throw new ArgumentOutOfRangeException(\"n\");\n        var nums = new\
    \ List<long>();\n        long smallest = 1;\n        while (n >= 1) {\n      \
    \      if (n % 2 == 0)\n                nums.Add(smallest);\n            n = n\
    \ / 2;\n            smallest *= 2;\n        }\n        return nums.Max();", " \
    \       long largestDivisor = 0;\n        for (long divisor = 1; divisor <= n;\
    \ divisor++) {\n            while (n % divisor) {\n                largestDivisor\
    \ = divisor;\n                n = n / divisor;\n            }\n        }\n   \
    \     return largestDivisor;", "        long[] div = Enumerable.Range(0, n).ToArray();\n\
    \        div[0] = n;\n        var max = 1;\n        for(int i = 1; i < div.Length;\
    \ i++)\n            for(int j = 0; j < i; j++)\n                if(div[j] % div[i]\
    \ == 0) {\n                    max = Math.Max(div[i], max);\n                \
    \    div[i] = 0;\n                    break;\n                }\n        return\
    \ max;", "        long d = 1;\n        long maxDivisor = 1;\n        while (maxDivisor\
    \ < n) {\n            d += 1;\n            while (d <= n && n % d == 0) {\n  \
    \              d += 1;\n            }\n            maxDivisor = d;\n        }\n\
    \        return maxDivisor;", "        long largest = 0;\n        long currentDivisor\
    \ = 1;\n        long divisor = 1;\n        while (true) {\n            if (currentDivisor\
    \ % 2 == 0) {\n                currentDivisor++;\n            } else {\n     \
    \           currentDivisor--;\n            }\n            divisor++;\n       \
    \     if (divisor > n) {\n                break;\n            }\n            if\
    \ (currentDivisor > largest) {\n                largest = currentDivisor;\n  \
    \          }\n        }\n        return largest;", "        long maxDivisor =\
    \ 1;\n        for (int i = 2; i <= Math.Sqrt(n); i++) {\n            if (n % i\
    \ == 0) {\n                maxDivisor = i;\n            }\n        }\n       \
    \ return maxDivisor;", "        long maxFactor = 1;\n        for (long i = 1;\
    \ i < n; i++)\n            maxFactor *= i;\n        for (long i = 2; i <= maxFactor;\
    \ i++) {\n            if (n % i == 0)\n                return i;\n        }\n\
    \        return -1;", "        var t = 1;\n        var x = n;\n        var largestDivisor\
    \ = 0;\n        while (n > 0) {\n            x = (x % t) + ((x % t == 0) ? 1 :\
    \ 0);\n            largestDivisor = (largestDivisor < x) ? x : largestDivisor;\n\
    \            t = t * 10;\n        }\n        return largestDivisor;", "      \
    \  // First sort the numbers less than n into ascending order\n        List<long>\
    \ nums = Enumerable.Range(1, n).ToList();\n        nums.Sort();\n\n        //\
    \ If the largest divisor is <= n, then return it\n        if (nums.Max() <= n)\
    \ return nums.Max();\n\n        // For each number in nums, find the largest number\
    \ that divides n evenly\n        long largestDivisor = -1;\n        foreach (long\
    \ num in nums)\n            if (num % 2 == 0)\n                largestDivisor\
    \ = Math.Max(largestDivisor, num);\n\n        // If n is divisible by largest\
    \ divisor, return it (this handles the case when n = largest divisor)\n      \
    \  return n == largestDivisor ? n : -1;", "        long maxDivisor = 1;\n    \
    \    long m = n;\n        while (maxDivisor < n / m) {\n            maxDivisor\
    \ = m * m;\n            m += 1;\n        }\n        return maxDivisor;", "   \
    \     long maxValue = 1;\n        long divValue = 1;\n        do {\n         \
    \   maxValue = divValue;\n            long newDivValue = 1;\n            while\
    \ (divValue < n) {\n                newDivValue = newDivValue * divValue;\n  \
    \          }\n            if (newDivValue > maxValue) {\n                maxValue\
    \ = newDivValue;\n            }\n            divValue += 1;\n        } while (divValue\
    \ < n);\n        return maxValue;", "        var result = n;\n        while (true)\
    \ {\n            long divisor = 1;\n            if (n % divisor == 0) return result;\n\
    \            for (int i = 1; i < n; i++) {\n                if (n % i == 0) {\n\
    \                    divisor = i;\n                    break;\n              \
    \  }\n            }\n            result = divisor;\n        }", "        long\
    \ largestDivisor = 0;\n        long nDivisor = 0;\n        while (n > 1) {\n \
    \           long next = n / 2;\n            nDivisor += 1;\n            if (nDivisor\
    \ % 2 == 0) largestDivisor = next;\n            n = next;\n        }\n       \
    \ return largestDivisor;", "        long largestDivisor = 0;\n        foreach\
    \ (long divisor in new long[] {3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31}) {\n  \
    \          if (divisor == 1) continue;\n            long d = (n - 1) / (divisor);\n\
    \            if (d == (long)(Math.Round(d))) {\n                largestDivisor\
    \ = divisor;\n            }\n        }\n        return largestDivisor;", "   \
    \     long largestDivisor = 1;\n        long currentDivisor = 1;\n        long\
    \ dividend = n;\n        while (dividend > 1) {\n            long test = dividend\
    \ / currentDivisor;\n            if (test == dividend) {\n                currentDivisor++;\n\
    \            }\n            dividend = test;\n            currentDivisor = 1;\n\
    \        }\n        while (currentDivisor <= n) {\n            long test = currentDivisor\
    \ / n;\n            if (test == currentDivisor) {\n                currentDivisor++;\n\
    \            }\n            currentDivisor = 1;\n        }\n        long result\
    \ = currentDivisor;\n        while (result*currentDivisor < n) {\n           \
    \ currentDivisor++;\n        }\n        return result;", "        long LDivisor\
    \ = 1;\n        long HDivisor = 1;\n        long Divisor = 0;\n        long DivResult\
    \ = 1;\n        bool IsDivided = true;\n\n        while (DivResult > 0 || Divisor\
    \ != 0) {\n            if (DivResult > LDivisor) {\n                DivResult\
    \ = LDivisor;\n                LDivisor = Divisor;\n            } else {\n   \
    \             DivResult = HDivisor;\n                HDivisor = Divisor;\n   \
    \         }\n            Divisor = DivResult * DivResult + DivResult;\n      \
    \  }\n\n        if (LDivisor != 0 && Divisor == 0) {\n            Divisor = LDivisor;\n\
    \            Divisor = LDivisor;\n        }\n\n        if (Divisor == 0) {\n \
    \           return 0;\n        } else {\n            return Divisor;\n       \
    \ }", "        var divisors = Enumerable.Range(1, long.MaxValue).Where(x => (n\
    \ % x) == 0);\n        var res = divisors.Max();\n        Console.WriteLine(\"\
    Divisors of {0:L}: {1}\", n, String.Join(\",\", divisors));\n        return res;",
  "        long largest;\n        long divisor = 1;\n        while (divisor < n) {\n\
    \            if (n % divisor == 0) {\n                largest = divisor;\n   \
    \         }\n            divisor++;\n        }\n        if (divisor == n) {\n\
    \            largest = n;\n        }\n        return largest;", "        List<long>\
    \ divisors = new List<long>();\n        long divisor = 1;\n        long n = Math.Abs(n);\n\
    \        while (n > 1) {\n            divisor = n;\n            for (long d =\
    \ 2; d < Math.Sqrt(n); d++) {\n                if (n % d == 0) {\n           \
    \         divisor = d;\n                    break;\n                }\n      \
    \      }\n            if (divisors.Contains(divisor)) {\n                continue;\n\
    \            }\n            divisors.Add(divisor);\n            n = n / divisor;\n\
    \        }\n        divisors.Reverse();\n        return divisors.Last();", " \
    \       long maxDivisor = 0;\n        long largestDivisor = 0;\n        for (long\
    \ divisor = 1; divisor <= n; divisor++) {\n            if (n % divisor == 0) {\n\
    \                largestDivisor = divisor;\n                maxDivisor = divisor;\n\
    \            }\n            if (divisor > largestDivisor) {\n                largestDivisor\
    \ = divisor;\n            }\n        }\n        return maxDivisor;", "       \
    \ long maxDivider = 0;\n        for (long i = 2; i <= Math.Sqrt(n); i++) {\n \
    \           if (n % i == 0) {\n                long divider = i;\n           \
    \     while (n % divider == 0) {\n                    divider += 1;\n        \
    \        }\n                if (divider > maxDivider) {\n                    maxDivider\
    \ = divider;\n                }\n            }\n        }\n        return maxDivider;",
  "        Debug.Assert(n > 0);\n        long max = n;\n        long divisor = 1;\n\
    \        while (divisor * divisor <= n) {\n            divisor++;\n          \
    \  if (n % divisor == 0) {\n                max = divisor;\n            }\n  \
    \      }\n        return max;", "        List<long> divisors = new List<long>();\n\
    \        // First find divisors of all numbers, less than n, so that\n       \
    \ // the sum of the divisors equals n.\n        long maxDivisor = 1;\n       \
    \ while (n > maxDivisor) {\n            divisors.Add(maxDivisor);\n          \
    \  maxDivisor++;\n        }\n        // Now find all divisors, that are exactly\
    \ divisble by n.\n        for (long divisor = divisors.Count - 1; divisor > 0;\
    \ divisor--) {\n            if (divisors.Count(x => x % divisor == 0) == divisor)\
    \ {\n                divisors.RemoveAt(divisor);\n            }\n        }\n \
    \       // Now the divisors are all < n, so we can just take the largest.\n  \
    \      return divisors.Max();", "        long max = long.MinValue;\n        for(long\
    \ i = 2; i <= n; i++) {\n            if (n % i == 0) {\n                max =\
    \ Math.Max(max, i);\n            }\n        }\n        return max;", "       \
    \ long largestDivisor = n;\n        while (n > largestDivisor) {\n           \
    \ if (n % largestDivisor == 0)\n                break;\n            largestDivisor++;\n\
    \        }\n        return largestDivisor;", "        // If no factors can be\
    \ found, this will return 0.\n        if (n < 2)\n            return 0L;\n   \
    \     // Since we need to use multiple for loops to generate and check all factors,\
    \ \n        // we will be using BigInteger since we need to use it's modPow function.\
    \ \n        // A BigInteger is a large integer (64 bits), just like a normal long\
    \ integer \n        // except it is signed and can only hold numbers up to 2^63\
    \ - 1. The BigInteger \n        // class has a constructor which takes a long\
    \ value and returns a BigInteger. \n        BigInteger largestDivisor = new BigInteger(\"\
    2\");\n        // Find all factors (divisors) of n\n        for (int i = 1; i\
    \ < BigInteger.DivRem(new BigInteger(n.ToString()), largestDivisor); i++) {\n\
    \            // If the current divisor, n, divides evenly into i, then add the\
    \ current \n            // divisor to the largest divisor so far, i.\n       \
    \     if ((largestDivisor.Divide(new BigInteger(i.ToString()))).Equals(new BigInteger(n)))\n\
    \                largestDivisor = largestDivisor.Add(i);\n        }\n        //\
    \ Return the largest divisor that divides evenly into n\n        return largestDivisor;",
  "        // Initialize an array to store the divisors of a number\n        var divisors\
    \ = new long[n + 1];\n        // Initialize an int to store the current divisor\
    \ of the current number\n        long currentDiv = 0;\n        // Initialize a\
    \ long value to store the largest divisor found so far\n        long maxDiv =\
    \ 0;\n\n        // Set the current divisor of the current number to 1\n      \
    \  currentDiv = 1;\n        // Set the first divisor's index to 1\n        divisors[0]\
    \ = 1;\n        // Set the last divisor's index to n\n        divisors[n] = n;\n\
    \        // For each index from 1 to n\n        for (int i = 1; i < divisors.Length;\
    \ i++) {\n            // If the current number divides the current divisor evenly,\
    \ increment the divisor and set its index\n            if (n % divisors[i] ==\
    \ 0) {\n                currentDiv += divisors[i];\n                divisors[i]\
    \ = currentDiv;\n                // If the current number is equal to the largest\
    \ divisor found so far, update it\n                if (currentDiv > maxDiv) {\n\
    \                    maxDiv = currentDiv;\n                }\n            }\n\
    \        }\n\n        return maxDiv;", "        long result = 1;\n        for\
    \ (long i = 1; i < n; i++) {\n            long d = n - i;\n            if (d %\
    \ 2 == 0) {\n                result = Math.Max(d, result);\n            }\n  \
    \      }\n        return result;", "        if (n < 1)\n            return -1;\n\
    \        var d = 1;\n        var q = Math.Floor(n);\n        var p = q;\n    \
    \    \n        while (p != 1) {\n            var t = Math.Sqrt(p);\n         \
    \   if (t % 2 == 0)\n                p /= 2;\n            else\n             \
    \   p /= t;\n            \n            if (n % p == 0)\n                d = Math.Max(d,\
    \ p);\n            \n            if (p < q)\n                q = p;\n        }\n\
    \        return d;", "        // Find smallest divisor of n\n        long d =\
    \ 1;\n        while (n % d == 0) {\n            d = d << 1;\n        }\n     \
    \   if (d == 1) {\n            return n;\n        }\n        return LargestDivisor(d);",
  "        long largest_divisor = 0;\n        long smallest_divisor = 1;\n\n     \
    \   for(long d = smallest_divisor; d <= n; d += smallest_divisor) {\n        \
    \    long a = n%d;\n            if(a==0) {\n                largest_divisor =\
    \ d;\n            }\n            else {\n                smallest_divisor = d\
    \ + 1;\n            }\n        }\n\n        return largest_divisor;", "      \
    \  if (n < 2)\n            return 0;\n        long maxDivisor = 1;\n        long\
    \ currentDivisor = 1;\n        for (long i = 1; i <= n; i++) {\n            if\
    \ (n % i == 0) {\n                currentDivisor++;\n                if (currentDivisor\
    \ > maxDivisor) {\n                    maxDivisor = currentDivisor;\n        \
    \        }\n            }\n        }\n        return maxDivisor;", "        //\
    \ Find the largest divisor of n\n        // >>> LargestDivisor(15L)\n        //\
    \ 7L\n        long div = n;\n        while (true) {\n            div = div / 2L;\n\
    \            if (n % div != 0)\n                break;\n        }\n        return\
    \ div;", "        long maxDivisor = n;\n        long temp;\n        while (n !=\
    \ 0) {\n            temp = n;\n            n /= 2;\n            if (temp % 2 ==\
    \ 0) {\n                maxDivisor = temp;\n                break;\n         \
    \   }\n        }\n        return maxDivisor;", "        long max = 0;\n      \
    \  long counter = 0;\n        foreach (long div in divisors(n))\n        {\n \
    \           if (div > max)\n            {\n                max = div;\n      \
    \          counter = 0;\n            }\n            else\n            {\n    \
    \            counter++;\n            }\n        }\n        if (counter == 0)\n\
    \        {\n            max = n;\n        }\n        return max;", "        //\
    \ We are going to keep track of largest divisor seen so far\n        long largestDivisor\
    \ = 0;\n\n        // We are going to keep track of largest divisor seen so far\
    \ that divides n evenly\n        long largest_divisor = 0;\n\n        // We are\
    \ going to keep track of largest divisor seen so far that divides n evenly\n \
    \       long largest_divisor2 = 0;\n\n        // Keep looping until we find a\
    \ divisor that is smaller than n\n        for (long i = 1; i < n; i++) {\n   \
    \         // If n is divided by i, then divide n by i\n            if (n % i ==\
    \ 0) {\n                // If n is divisible by i, then it is the largest divisor\
    \ so far that divides n evenly\n                largestDivisor = i;\n\n      \
    \          // If n is divisible by i, and is not the largest divisor so far that\
    \ divides n evenly\n                if (i != largestDivisor) {\n             \
    \       // We update largest divisor seen so far that divides n evenly\n     \
    \               largest_divisor2 = largestDivisor;\n\n                    // We\
    \ update largest divisor seen so far that divides n evenly\n                 \
    \   largest_divisor = i;\n                }\n            }\n        }\n\n    \
    \    // If n has no divisors, then n is the largest divisor so far that divides\
    \ n evenly\n        // If n is divided by largest divisor, then n is the largest\
    \ divisor so far that divides n evenly\n        // If largest divisor is 1, then\
    \ n is the largest divisor so far that divides n evenly\n        // If largest\
    \ divisor is 2, then n is the largest divisor so far that divides n evenly\n \
    \       // If largest divisor is 3, then n is the largest divisor so far that\
    \ divides n evenly\n        // If largest divisor is 4, then n is the largest\
    \ divisor so far that divides n evenly\n        // If largest divisor is 5, then\
    \ n is the largest divisor so far that divides n evenly\n        // If largest\
    \ divisor is 6, then n is the largest divisor so far that divides n evenly\n \
    \       // If largest divisor is 7, then n is the largest divisor so far that\
    \ divides n evenly\n        // If largest divisor is 8, then n is the largest\
    \ divisor so far that divides n evenly\n        // If largest divisor is 9, then\
    \ n is the largest divisor so far that divides n evenly\n        // If largest\
    \ divisor is 10, then n is the largest divisor so far that divides n evenly\n\
    \        // If largest divisor is 11, then n is the largest divisor so far that\
    \ divides n ", "        long maxN = 0;\n        long largestN = 0;\n        while\
    \ (n >= 2) {\n            while (n % 2 == 0) {\n                largestN += 1;\n\
    \                n /= 2;\n            }\n            largestN = largestN * 2 +\
    \ 1;\n            n /= 2;\n            maxN = largestN;\n        }\n        return\
    \ maxN;", "        long factor = 1;\n        while (factor < n) {\n          \
    \  if (n % factor == 0)\n                factor++;\n            else\n       \
    \         break;\n        }\n        return factor;", "        // Keep a sorted\
    \ list of all divisors, largest first\n        long[] divisors = new long[n];\n\
    \n        // Keep track of biggest divisor seen so far\n        long maxDivisor\
    \ = n;\n\n        // If n is even, skip it and add 2\n        if (n % 2 == 0)\n\
    \            divisors[2] = 2;\n        else\n            divisors[1] = n;\n\n\
    \        // Check divisors until we find one that is smaller than n\n        for\
    \ (long d = 2; d * d <= n; d++) {\n            if (n % d == 0) {\n           \
    \     divisors[d] = d;\n                if (d > maxDivisor)\n                \
    \    maxDivisor = d;\n            }\n        }\n\n        // Return biggest divisor\
    \ seen\n        return maxDivisor;", "        long largestDivisor = 0;\n     \
    \   long d = 2;\n        while (d < n) {\n            long test = (d * d) % n;\n\
    \            if (test != 0) {\n                if (test * d > largestDivisor)\
    \ {\n                    largestDivisor = test;\n                }\n         \
    \   }\n            d++;\n        }\n        return largestDivisor;", "       \
    \ if (n == 0 || n == 1L)\n            return n;\n        long maxDivisor = n;\
    \ // n might be divisible by another number greater than n\n        long[] numbers\
    \ = new long[] { 1L };\n        while (true) {\n            if (n % maxDivisor\
    \ == 0L)\n                return maxDivisor;\n            long nextDivisor = maxDivisor\
    \ + 1L;\n            if (n % nextDivisor == 0L) {\n                maxDivisor\
    \ = nextDivisor;\n                numbers.Add(nextDivisor);\n            }\n \
    \       }", "        long maxDivisor = 1;\n        for (long i = 1; i <= n; i++)\n\
    \            if (n % i == 0)\n                maxDivisor = i;\n        return\
    \ maxDivisor;", "        long max = n, maxDivisor = 1;\n        while (max % 2\
    \ == 0) {\n            max /= 2;\n            maxDivisor *= 2;\n        }\n  \
    \      while (max != 1) {\n            long newMax = max;\n            long newMaxDivisor\
    \ = maxDivisor;\n            while (newMax % newMaxDivisor != 0) {\n         \
    \       newMax++;\n                newMaxDivisor *= 2;\n            }\n      \
    \      max = newMax;\n            maxDivisor = newMaxDivisor;\n        }\n   \
    \     return maxDivisor;", "        long largestDivisor = 1;\n        long currentDivisor\
    \ = 2;\n        while (currentDivisor <= n && largestDivisor < n) {\n        \
    \    while (n % currentDivisor == 0) {\n                n = n / currentDivisor;\n\
    \                largestDivisor = currentDivisor;\n            }\n           \
    \ currentDivisor++;\n        }\n        return largestDivisor;", "        List<long>\
    \ divisors = new List<long>();\n        long remainder = n;\n        while (n\
    \ != 0) {\n            if (remainder % 2 == 0) {\n                divisors.Add(remainder);\n\
    \            }\n            n = n / 2;\n            remainder = n % 2;\n     \
    \   }\n\n        if (divisors.Count == 0) {\n            return 0L;\n        }\n\
    \        return divisors.OrderByDescending(d => ((long)d) / n).First();", "  \
    \      long largestDivisor = n; //initialize smallest divisor to n\n        long\
    \ nextDivisor = n;\n\n        for(int i = 1; i < int.MaxValue; i++) {\n      \
    \      nextDivisor = nextDivisor + i;\n            long test = nextDivisor / n;\n\
    \            if(test % 2 == 0) {\n                largestDivisor = test;\n   \
    \         }\n        }\n\n        return largestDivisor;", "        // The largest\
    \ divisor is n\n        long result = n;\n        // Set a running sum to zero\n\
    \        long runningSum = 0;\n        // Keep going until we get to zero\n  \
    \      while (result > 0) {\n            // Add the current result to the running\
    \ sum\n            runningSum += result;\n            // Find the next value that\
    \ divides n evenly\n            long nextDivider = runningSum % n;\n         \
    \   // If the next value is too big, set it to the current value\n           \
    \ if (nextDivider > n) {\n                result = nextDivider;\n            }\n\
    \        }\n        // Return the result\n        return result;", "        long\
    \ largestDivisor = -1;\n        long[] divisors = Enumerable.Range(0, 100000000\
    \ / n).ToArray();\n        \n        double n = n.ToString().Length < 4 ? Math.Round(n,\
    \ 4) : n;\n        \n        long remainder = Convert.ToInt64(n) - 1;\n      \
    \  long currentDivisor = 0;\n        long maxDivisor = 0;\n        long minDivisor\
    \ = 0;\n        \n        long maxNum = Convert.ToInt64(n) - 1;\n        long\
    \ minNum = Convert.ToInt64(n) - 1;\n        long testNum = Convert.ToInt64(n)\
    \ - 1;\n        \n        long num;\n        \n        for (int i = 0; i < 100;\
    \ i++) {\n            currentDivisor = divisors[i];\n            \n          \
    \  while (n > 0) {\n                if (currentDivisor == 0) {\n             \
    \       break;\n                }\n                \n                long test\
    \ = currentDivisor * testNum;\n                \n                if (test > largestDivisor)\
    \ {\n                    largestDivisor = test;\n                }\n         \
    \       \n                if (test < minDivisor) {\n                    minDivisor\
    \ = test;\n                }\n                \n                n -= test;\n \
    \               \n                testNum = Convert.ToInt64(n) - 1;\n        \
    \        currentDivisor--;\n            }\n            \n            if (testNum\
    \ > largestDivisor) {\n                largestDivisor = testNum;\n           \
    \ }\n            \n            if (testNum < minDivisor) {\n                minDivisor\
    \ = testNum;\n            }\n        }\n        \n        largestDivisor = Math.Abs(largestDivisor);\n\
    \        \n        if (largestDivisor > maxNum) {\n            maxNum = largestDivisor;\n\
    \        }\n        \n        if (minDivisor > maxNum) {\n            maxNum =\
    \ minDivisor;\n        }\n        \n        return maxNum;", "        var factors\
    \ = new List<long>();\n        while (true) {\n            long current = n;\n\
    \            if (current % 2 == 0) {\n                if (n != 1) {\n        \
    \            factors.Add(current);\n                }\n                break;\n\
    \            }\n            for (long factor = 2; factor <= current / 2; factor++)\
    \ {\n                if (current % factor == 0) {\n                    factors.Add(factor);\n\
    \                    break;\n                }\n            }\n            n =\
    \ current;\n        }\n        factors.Reverse();\n        long largest = factors.Last();\n\
    \        for (int i = 0; i < factors.Count; i++) {\n            if (factors[i]\
    \ == largest) {\n                break;\n            }\n        }\n        return\
    \ largest;", "        long max = 0;\n        long divisibleByAll = 1;\n      \
    \  while (divisibleByAll < n) {\n            divisibleByAll = divisibleByAll *\
    \ 2;\n            if (n % divisibleByAll == 0) {\n                max = Math.Max(max,\
    \ divisibleByAll);\n            }\n        }\n        return max;", "        long\
    \ largest = n;\n        bool test = true;\n        while (test) {\n          \
    \  test = false;\n            BigInteger b = new BigInteger(n.ToString());\n \
    \           List<BigInteger> divisors = new List<BigInteger>();\n            for\
    \ (long i = 1; i < b.ToString(10).Length; i++) {\n                if (b.Divide(i).Equals(BigInteger.Zero))\
    \ {\n                    divisors.Add(i);\n                    test = true;\n\
    \                }\n            }\n            BigInteger divisor = divisors.Max();\n\
    \            if (divisor == BigInteger.Zero) {\n                divisor = divisors.Min();\n\
    \            }\n            if (divisor > largest) {\n                largest\
    \ = divisor;\n            }\n            n = BigInteger.Multiply(n, BigInteger.Pow(10,\
    \ (b.ToString(10).Length - divisors.Count)));\n        }\n        return largest;",
  "        if (n == 0) {\n            return 0;\n        }\n        long largestDivisor\
    \ = 0;\n        long largeDivisor;\n        long currentDivisor;\n        long\
    \ divisor;\n        long lastDivisor;\n        long nextDivisor;\n        long\
    \ lastNum = 1;\n        long currentNum;\n        bool isDivided = false;\n  \
    \      for(long i = 1L; i <= n; i++) {\n            currentDivisor = i;\n    \
    \        while(currentDivisor != 0) {\n                divisor = currentDivisor\
    \ % 2;\n                if(divisor > 0) {\n                    currentDivisor\
    \ = divisor;\n                    lastDivisor = currentDivisor;\n            \
    \    }\n                else {\n                    divisor = lastDivisor % 2;\n\
    \                    if(divisor > 0) {\n                        currentDivisor\
    \ = divisor;\n                        nextDivisor = lastDivisor + 2;\n       \
    \                 lastDivisor = nextDivisor;\n                    }\n        \
    \            else {\n                        divisor = nextDivisor % 2;\n    \
    \                    if(divisor > 0) {\n                            currentDivisor\
    \ = divisor;\n                            lastDivisor = nextDivisor;\n       \
    \                     nextDivisor = lastDivisor + 2;\n                       \
    \ }\n                    }\n                }\n            }\n            if(!isDivided)\
    \ {\n                if(currentDivisor > 0) {\n                    largestDivisor\
    \ = currentDivisor;\n                }\n            }\n            else {\n  \
    \              if(currentDivisor > largestDivisor) {\n                    largestDivisor\
    \ = currentDivisor;\n                }\n            }\n        }\n        return\
    \ largestDivisor;", "        long largestDivisor = 0L;\n        long largestDivisorBase\
    \ = 1L;\n        long largestDivisorPower = 0L;\n        long largestDivisorPowBase\
    \ = 1L;\n\n        long divisor;\n\n        do {\n            divisor = largestDivisorBase;\n\
    \            largestDivisorPower = largestDivisorPowBase;\n            largestDivisorBase\
    \ += 1;\n            largestDivisorPowBase += 1;\n\n            while (divisor\
    \ < n) {\n                divisor *= largestDivisorBase;\n                largestDivisorPower\
    \ += largestDivisorPowBase;\n                largestDivisorBase += 1;\n      \
    \          largestDivisorPowBase += 1;\n            }\n\n            if (divisor\
    \ > n)\n                break;\n\n            largestDivisor = divisor;\n    \
    \        largestDivisorBase = largestDivisorBase;\n            largestDivisorPower\
    \ = largestDivisorPower;\n            largestDivisorPowBase = largestDivisorPowBase;\n\
    \        } while (true);\n\n        return largestDivisor;", "        long max\
    \ = 1;\n        long lastDivisor = 1;\n        long currentDivisor = 1;\n    \
    \    while (currentDivisor < n) {\n            if (currentDivisor % 2 == 0) {\n\
    \                lastDivisor = currentDivisor;\n                currentDivisor\
    \ *= 2;\n            } else {\n                currentDivisor /= 2;\n        \
    \    }\n            if (currentDivisor > max) {\n                max = currentDivisor;\n\
    \            }\n        }\n        return lastDivisor;", "        long l = 1;\n\
    \        long m = 2;\n        while (l <= n/m) {\n            m = m*2;\n     \
    \       if (m > n) {\n                m = n;\n            }\n            l = l*2;\n\
    \            if (l > n) {\n                l = n;\n            }\n        }\n\
    \        return m;", "        long result = 0;\n        for (long i = 2; i <=\
    \ n; i += 2) {\n            if (n % i == 0)\n                result = i;\n   \
    \     }\n        return result;", "        long max = 0;\n        int nFactors\
    \ = (int)Math.Floor(Math.Log(n, 2));\n        for(int i = 0; i < nFactors; ++i)\
    \ {\n            int pow = Math.Pow(2, i);\n            long newN = n  / pow;\n\
    \            if (Math.Floor(newN / 2) == Math.Floor(n)) {\n                max\
    \ = Math.Max(max, pow);\n            }\n        }\n        return max;", "   \
    \     long largestDivisor = n;\n        while (largestDivisor > 1) {\n       \
    \     long r = n % largestDivisor;\n            if (r == 0) {\n              \
    \  return largestDivisor;\n            }\n            largestDivisor = r;\n  \
    \      }\n        return largestDivisor;", "        if (n < 2) {\n           \
    \ return 0;\n        }\n\n        var results = new List<long>();\n        var\
    \ currentDivisor = 1;\n        do {\n            currentDivisor++;\n         \
    \   results.Add(currentDivisor);\n            currentDivisor = currentDivisor\
    \ % n;\n        } while (currentDivisor > 0);\n\n        if (currentDivisor >\
    \ n) {\n            return 0;\n        }\n\n        if (currentDivisor % n ==\
    \ 0) {\n            return currentDivisor;\n        }\n\n        var max = results.Max();\n\
    \        var smallestDivisor = results.First();\n\n        if (currentDivisor\
    \ <= n / smallestDivisor) {\n            while (n / smallestDivisor >= currentDivisor)\
    \ {\n                results.RemoveAt(0);\n                smallestDivisor = results.First();\n\
    \                currentDivisor++;\n            }\n            return smallestDivisor;\n\
    \        }\n        return 0;", "        // Largest divisor is 0, or 1 if the\
    \ number is even\n        long maxDivisor = 0;\n        long divisor = 0;\n  \
    \      // Start with n = 2^31 - 1\n        for (long i = 31; i >= 1; i--) {\n\
    \            divisor = n >> i;\n            // If divisor divides n evenly, it\
    \ is the largest divisor so far\n            if (divisor % 2 == 0)\n         \
    \       maxDivisor = divisor;\n        }\n        // For odd n, there is no divisor\n\
    \        if (divisor != 0) {\n            // If divisor > maxDivisor, increase\
    \ maxDivisor\n            if (divisor > maxDivisor)\n                maxDivisor\
    \ = divisor;\n        }\n        // Return maxDivisor\n        return maxDivisor;",
  "        long max = 1;\n        long d = 1;\n        long last = 2;\n        long\
    \ current = 1;\n        long x = 2;\n        while (n != 0) {\n            while\
    \ (n % x == 0) {\n                d = current + last;\n                last =\
    \ current;\n                current = d;\n                x ++;\n            }\n\
    \            max = Math.Max(max, current);\n            n = n / x;\n        }\n\
    \        return max;", "        List<long> result = new List<long>();\n      \
    \  for (long i=1;;i++) {\n            long k = i*i;\n            if (k%n == 0)\
    \ {\n                result.Add(k);\n                if (k > n) {\n          \
    \          n = k;\n                }\n            } else if (result.Count>0) {\n\
    \                if (result[0] != k) {\n                    result.Clear();\n\
    \                    result.Add(k);\n                }\n                break;\n\
    \            }\n        }\n        long result = result.Max();\n        if (result\
    \ == n) {\n            Debug.WriteLine(\"result is {0}\", result);\n        }\
    \ else {\n            Debug.WriteLine(\"result not {0}, n is {1}, result is {2}\"\
    , n, result, n);\n        }\n        return result;", "        if (n == 0) {\n\
    \            return 0;\n        }\n        long largestDivisor = n; // start with\
    \ n\n        long remainder = n; // start with a remainder of n\n        bool\
    \ isDivisor = true; // initially assume n is a divisor\n        while (isDivisor)\
    \ { // loop as long as we still have numbers to test\n            while (isDivisor\
    \ && remainder % 2 == 0) { // loop while remainder evenly divides n\n        \
    \        largestDivisor *= 2; // double the largest divisor we found\n       \
    \         remainder /= 2;\n                isDivisor = false;\n            }\n\
    \            if (isDivisor) { // loop again as long as remainder does not divide\
    \ n\n                largestDivisor++;\n                remainder += 2;\n    \
    \            isDivisor = false;\n            }\n        }\n        return largestDivisor;",
  "        // Find the smallest number > that divides n evenly, so that n < LargestDivisor(n\
    \ < number) <= n\n        // Since n = LargestDivisor(number) >= number, number/LargestDivisor(number)\
    \ = number % LargestDivisor(number) = number % number\n        long smallestDivisor\
    \ = Long.MinValue;\n        for (long number = n; number % 2 == 0 && number >\
    \ smallestDivisor; number /= 2)\n            smallestDivisor = number;\n     \
    \   // Now, since n <= smallestDivisor, smallestDivisor >= n, so n <= smallestDivisor\
    \ <= n\n        for (long number = n; number % smallestDivisor == 0; number /=\
    \ smallestDivisor)\n            smallestDivisor = number;\n        // Now smallestDivisor\
    \ <= n <= sqrt(n)\n        // The largest divisor is sqrt(n)\n        for (long\
    \ number = n; number % smallestDivisor != 0; number /= smallestDivisor)\n    \
    \        smallestDivisor = number;\n        // Now smallestDivisor <= n <= n\n\
    \        return smallestDivisor;", "        long largest = 0;\n        for (long\
    \ current = 2; current <= n; current++)\n            if (n % current == 0)\n \
    \               largest = current;\n\n        return largest;", "        var divisors\
    \ = Enumerable.Range(1, n).Where(i => n % i == 0).ToList();\n        var max =\
    \ divisors.OrderByDescending(d => d).First();\n        long maxNum;\n        if\
    \ (divisors.Any(d => d == max)) {\n            maxNum = max;\n        } else {\n\
    \            maxNum = n + 1;\n        }\n        long minNum = divisors.First();\n\
    \        var minDivisor = divisors.Where(d => d <= maxNum).OrderBy(d => d).First();\n\
    \        if (minDivisor == maxNum) {\n            if (maxNum == n) {\n       \
    \         return n;\n            } else {\n                return maxNum;\n  \
    \          }\n        }\n        var divisorFactors = divisors.Where(d => d >\
    \ minNum && d <= maxNum).ToArray();\n        var divisors = divisorFactors.Select(d\
    \ => (long)Math.Sqrt(n * d)).ToList();\n        while (divisors.Count == 1) {\n\
    \            if (divisors[0] >= minNum) {\n                break;\n          \
    \  }\n            divisors.RemoveAt(0);\n        }\n        long largestDivisor\
    \ = divisors.Last();\n        long smallestDivisor = divisors.First();\n     \
    \   long remainder = n / largestDivisor;\n        long newMinNum = smallestDivisor;\n\
    \        List<long> divisorsBefore = new List<long>(divisors);\n        divisorsBefore.Insert(0,\
    \ n);\n        while (remainder > 0) {\n            divisorsBefore.RemoveAt(0);\n\
    \            divisorsBefore.Insert(0, n);\n            remainder %= divisorsBefore.Last();\n\
    \        }\n        divisorsBefore.RemoveAt(0);\n        divisorsBefore.Insert(0,\
    \ n);\n        while (divisorsBefore.Count > 0) {\n            if (divisorsBefore.Count\
    \ < 2) {\n                break;\n            }\n            divisors.RemoveAt(0);\n\
    \        }\n        if (divisors.Count > 0) {\n            divisors.Insert(0,\
    \ n);\n            while (divisors.Count > 0) {\n                if (divisors.Count\
    \ < 2) {\n                    break;\n                }\n                divisors.RemoveAt(0);\n\
    \            }\n        }\n        divisors.Insert(0, n);\n        while (divisors.Count\
    \ > 0) {\n            if (divisors.Count < 2) {\n                break;\n    \
    \        }\n            divisors.RemoveAt(0);\n        }\n        if (divisors.Count\
    \ > 0) {\n            divisors.Insert(0, n);\n            while (divisors.Count\
    \ > 0) {\n                if (divisors.Count < 2) {\n                    break;\n\
    \                }\n                divisors.RemoveAt(0);\n            }\n   \
    \     }\n        divisors.Insert(0, n);\n        List<long> divisorsAfter = new\
    \ List<", "        // First we create an array that will hold the numbers that\
    \ divide n evenly\n        long[] divs = new long[(int)(Math.Floor(Math.Sqrt(n)\
    \ / 2.0) + 1)];\n        // First we create the array for easy access\n      \
    \  for (int i = 0; i < divs.Length; i++) {\n            // We use Math.Ceiling\
    \ since this gives the largest number that\n            // divides n evenly in\
    \ increments of 1 from that number\n            divs[i] = Math.Ceiling(n / Math.Pow(2,\
    \ i));\n        }\n        // Now we get the number that is evenly divisible by\
    \ each number in the\n        // array starting from 1, stopping at the number\
    \ that divides n\n        // evenly\n        long largestDivisor = 1;\n      \
    \  for (int i = 1; i < divs.Length; i++) {\n            if (divs[i] > largestDivisor)\
    \ {\n                largestDivisor = divs[i];\n            }\n        }\n   \
    \     return largestDivisor;", "        long max = 1;\n        for (int i = 1;\
    \ i < n; i = i * 2 + 1)\n            if (n % i == 0)\n                max = Math.Max(max,\
    \ i);\n        return max;", "        long largest_div = 0;\n        long largest_divisor\
    \ = 0;\n        long largest = n;\n        long remainder;\n        long divisor;\n\
    \        while (n > 0) {\n            divisor = n % 2;\n            remainder\
    \ = n % divisor;\n            if (remainder == 0)\n                largest_divisor\
    \ = divisor;\n            largest_div = Math.Max(largest_div, divisor);\n    \
    \        if (largest_div == n) {\n                largest = n;\n            }\
    \ else {\n                n = remainder;\n            }\n        }\n        return\
    \ (largest);", "        long nDivisors = 0;\n        long current = n;\n     \
    \   while (current != 1) {\n            current = current / 2;\n            nDivisors++;\n\
    \        }\n        long maxDivisor = n % 2;\n        for (int i = 0; i < nDivisors;\
    \ i++) {\n            if (n % i == 0) {\n                maxDivisor = i;\n   \
    \             break;\n            }\n        }\n        return maxDivisor;", " \
    \       long[] divisors = new long[n];\n        long largestDivisor = divisors[0];\n\
    \        for (int divisor = 1; divisor <= n; divisor++) {\n            if (n %\
    \ divisor == 0) {\n                divisors[divisor] = divisors[divisor - 1];\n\
    \            } else {\n                divisors[divisor] = divisor;\n        \
    \    }\n        }\n        long largestValue = divisors.Max();\n        if (largestValue\
    \ < largestDivisor) {\n            largestDivisor = largestValue;\n        }\n\
    \        return largestDivisor;", "        long largestDivisor = 1L;\n       \
    \ long smallestDivisor = n;\n        long curDivisor = 1L;\n        while (curDivisor\
    \ < n) {\n            curDivisor = smallestDivisor;\n            while (curDivisor\
    \ < n) {\n                curDivisor += curDivisor;\n                if (curDivisor\
    \ % n == 0)\n                    return curDivisor;\n            }\n         \
    \   smallestDivisor--;\n        }\n        return largestDivisor;", "        long\
    \ maxDivisor = n;\n        for (long divisor = 2; divisor < n; divisor++) {\n\
    \            if (n % divisor == 0) {\n                maxDivisor = divisor;\n\
    \            }\n        }\n        return maxDivisor;", "        long max = 0;\n\
    \        long divisor = 1;\n        while(true) {\n            divisor++;\n  \
    \          if(n%divisor == 0) {\n                max = divisor;\n            \
    \    break;\n            }\n            divisor--;\n        }\n        return\
    \ max;", "        long divisor = 0;\n        long i = 1;\n        long remainder\
    \ = 0;\n\n        while (remainder == 0) {\n            divisor++;\n         \
    \   remainder = n / i;\n            i++;\n        }\n        return divisor;",
  "        BigInteger a = BigInteger.Pow(n, 2);\n        // Reuse an iterator over\
    \ the bigger number\n        var b = new BigInteger(n, b);\n        do {\n   \
    \         BigInteger c = b;\n            while (!c.Equals(BigInteger.Zero)) {\n\
    \                if (c.TestDivisorEvenness(BigInteger.One) == BigInteger.Zero)\
    \ {\n                    // The number must be divisible by c\n              \
    \      return c;\n                }\n                c = c.Multiply(a);\n    \
    \        }\n            b = b.Add(BigInteger.One);\n        } while (b.CompareTo(a)\
    \ >= 0);\n        return a.Add(BigInteger.One);", "        long result = n; //\
    \ start with n as the only divisor.\n        long currentDivisor = 1; // start\
    \ with 1 as the only divisor of the number.\n        while (currentDivisor < n)\
    \ {\n            result = currentDivisor;\n            currentDivisor *= currentDivisor;\n\
    \        }\n        return result;", "        var candidates = Enumerable.Range(1,\
    \ long.MaxValue).Where(i => n % i == 0);\n        var largest = candidates.Max();\n\
    \        foreach (var item in candidates.Where(i => i > largest)) {\n        \
    \    if (item > largest) {\n                largest = item;\n            }\n \
    \       }\n        return largest;", "        BigInteger n = BigInteger.Parse(n.ToString());\n\
    \        if (n.Equals(BigInteger.One))\n            return n.ToString();\n   \
    \     BigInteger maxDivisor = BigInteger.One;\n        foreach (BigInteger i in\
    \ Divisors(n)) {\n            BigInteger div = BigInteger.Divide(i, n);\n    \
    \        if (BigInteger.Divide(div, n).Equals(BigInteger.Zero))\n            \
    \    continue;\n            if (BigInteger.Divide(div, n).CompareTo(maxDivisor)\
    \ < 0)\n                maxDivisor = div;\n        }\n        return maxDivisor.ToString();",
  "        bool even = true;\n        long max = 0;\n        long tmp = 0;\n     \
    \   while (even && tmp < n) {\n            tmp = Convert.ToInt64(Math.Floor(n/2));\n\
    \            even = (n % 2) == 0;\n            if (tmp > max) {\n            \
    \    max = tmp;\n            }\n        }\n        return max;", "        long\
    \ LargestDivisor = Long.MinValue;\n        int i = 1;\n        while (n > 1) {\n\
    \            if (n % i == 0) {\n                if (i % 2 == 0) {\n          \
    \          LargestDivisor = i;\n                }\n                else {\n  \
    \                  LargestDivisor = i;\n                }\n            }\n   \
    \         i += 2;\n        }\n        return LargestDivisor;", "        long[]\
    \ divs = new long[] { 1L};\n        while (n != 0) {\n            if (n % divs[divs.Length-1]\
    \ == 0) {\n                divs[divs.Length-1]++;\n            }\n           \
    \ else {\n                divs[divs.Length-1] = 1;\n            }\n          \
    \  n /= divs[divs.Length-1];\n        }\n        return divs[divs.Length-1];",
  "        long maxDivisor = n; // start with largest divisor\n        long currentNumber\
    \ = n;\n        while (currentNumber > 1) {\n            long currentDivisor =\
    \ currentNumber;\n            while (currentDivisor % 2 == 0)\n              \
    \  currentDivisor = currentDivisor / 2;\n            if (currentDivisor > maxDivisor)\n\
    \                maxDivisor = currentDivisor;\n            currentNumber--;\n\
    \        }\n        return maxDivisor;", "        long largestDivisor = -1;\n\
    \        long largestRemainder = 0;\n        long div = 1;\n        bool isEven\
    \ = false;\n        long largestDivisorNum = 0;\n        // We use long here because\
    \ long will overflow on calculating \n        // the largest remainder\n     \
    \   while ((n % div) != 0) {\n            isEven = !isEven;\n            ++largestDivisorNum;\n\
    \            div *= 2;\n        }\n        if (isEven) {\n            largestDivisorNum\
    \ += 1;\n        }\n        for (long i = 1; i <= largestDivisorNum; ++i) {\n\
    \            long remainder = n % div;\n            if (remainder == 0) {\n  \
    \              largestDivisor = div;\n                largestRemainder = i;\n\
    \                break;\n            }\n            div *= 2;\n        }\n   \
    \     if (largestDivisor < n) {\n            largestDivisor = n;\n        }\n\
    \        return (largestDivisor);", "        long largest = n;\n        long largestFactor\
    \ = 0;\n        for (long divisor = 2; divisor <= n; divisor++) {\n          \
    \  if (n % divisor == 0) {\n                long factor = (n/divisor);\n     \
    \           if (factor > largestFactor) {\n                    largestFactor =\
    \ factor;\n                    largest = divisor;\n                }\n       \
    \     }\n        }\n        return largest;", "        var minDivisor = Int64.MaxValue;\n\
    \        long divisor = Int64.MinValue;\n        for (long i = 2; i <= n; i++)\
    \ {\n            if (i % 2 == 0) {\n                divisor = i;\n           \
    \     if (minDivisor > divisor)\n                    minDivisor = divisor;\n \
    \           }\n            else {\n                divisor = divisor + i;\n  \
    \          }\n        }\n        return minDivisor;", "        long maxDivisor\
    \ = 1L;\n        long[] divisors = new long[n];\n        long max = n + 1L;\n\
    \        long temp;\n        while (max >= 2L) {\n            divisors[max--]\
    \ = 0;\n            temp = max;\n            while (temp != 0L) {\n          \
    \      if (temp % 2 == 0) {\n                    divisors[temp--] = 0;\n     \
    \           } else {\n                    divisors[temp--] = max;\n          \
    \      }\n            }\n            temp = max / 2;\n            while (temp\
    \ != 1L) {\n                if (divisors[temp] != 1L) {\n                    maxDivisor\
    \ = divisors[temp];\n                } else {\n                    temp--;\n \
    \               }\n            }\n        }\n        return maxDivisor;", "  \
    \      long highest = 1;\n        for (long i = 1; i <= n; i++) {\n          \
    \  if (n % i == 0) {\n                highest = i;\n            }\n        }\n\
    \        return highest;", "        long largest = 0;\n        long[] factors\
    \ = new long[32];\n        while (n > 1) {\n            factors[n % 32]++;\n \
    \           n /= 32;\n        }\n        Array.Sort(factors);\n        for (int\
    \ i = factors.Length - 1; i >= 0; i--) {\n            if (factors[i] == 1)\n \
    \               largest = i;\n            if (largest == 0)\n                return\
    \ n;\n        }\n        return largest;", "        long[] factors = new long[10000];\n\
    \n        for (int i = 2; i <= n; i++) {\n            long current = i;\n\n  \
    \          while (current % 2 == 0) {\n                current /= 2;\n       \
    \     }\n\n            while (current % 3 == 0) {\n                current /=\
    \ 3;\n            }\n\n            while (current % 4 == 0) {\n              \
    \  current /= 4;\n            }\n\n            while (current % 5 == 0) {\n  \
    \              current /= 5;\n            }\n\n            while (current % 6\
    \ == 0) {\n                current /= 6;\n            }\n\n            while (current\
    \ % 7 == 0) {\n                current /= 7;\n            }\n\n            while\
    \ (current % 8 == 0) {\n                current /= 8;\n            }\n\n     \
    \       while (current % 9 == 0) {\n                current /= 9;\n          \
    \  }\n\n            while (current % 10 == 0) {\n                current /= 10;\n\
    \            }\n\n            while (current % 11 == 0) {\n                current\
    \ /= 11;\n            }\n\n            while (current % 12 == 0) {\n         \
    \       current /= 12;\n            }\n\n            while (current % 13 == 0)\
    \ {\n                current /= 13;\n            }\n\n            while (current\
    \ % 14 == 0) {\n                current /= 14;\n            }\n\n            while\
    \ (current % 15 == 0) {\n                current /= 15;\n            }\n\n   \
    \         while (current % 16 == 0) {\n                current /= 16;\n      \
    \      }\n\n            while (current % 17 == 0) {\n                current /=\
    \ 17;\n            }\n\n            while (current % 18 == 0) {\n            \
    \    current /= 18;\n            }\n\n            while (current % 19 == 0) {\n\
    \                current /= 19;\n            }\n\n            while (current %\
    \ 20 == 0) {\n                current /= 20;\n            }\n\n            while\
    \ (current % 21 == 0) {\n                current /= 21;\n            }\n\n   \
    \         while (current % 22 == 0) {\n                current /= 22;\n      \
    \      }\n\n            while (current % 23 == 0) {\n                current /=\
    \ 23;\n            }\n\n            while (current % 24 == 0) {\n            \
    \    current /= 24;\n            }\n\n            while (current % 25 == 0) {\n\
    \                current /= 25;\n            }\n\n            while (current %\
    \ 26 == 0) {\n                current /= 26;\n            }\n\n            while\
    \ (current % 27 == 0) {\n                current /= 27;\n            }\n\n   \
    \         while (current % 28 == 0) {\n                current /= 28;\n      \
    \      }\n\n            while (current % 29 == 0) {\n                current /=\
    \ 29;\n            }\n\n            while (current % 30 == 0) {\n            \
    \    current /= 30;\n            }\n\n            while (current % 31 == 0) {\n\
    \                current /= 31;\n            }\n\n            while (current %\
    \ 32 == 0) {\n                current /= 32;\n            }\n\n            while\
    \ (current % 33 == 0) {\n                current /= 33;\n            }\n\n   \
    \         while (current % 34 == 0) {\n                current /= 34;\n      \
    \      }\n\n            while (current % 35 == 0) {\n                current /=\
    \ 35", "        var result = 1;\n        while (!(n%result)) {\n            result++;\n\
    \        }\n        return result;", "        long maxDivisor = 1;\n        long\
    \ divisor = 1;\n        long currentDivisor = 1;\n        while (divisor <= n)\
    \ {\n            currentDivisor *= divisor;\n            if (currentDivisor >\
    \ maxDivisor) {\n                maxDivisor = currentDivisor;\n            }\n\
    \            divisor++;\n        }\n        return maxDivisor;", "        var\
    \ maxDivisor = n;\n        for (int i = 2; i <= n; i++) {\n            if (n %\
    \ i == 0) {\n                maxDivisor = i;\n            }\n        }\n     \
    \   return maxDivisor;", "        long max = (long) (Math.Sqrt(n));\n        var\
    \ factors = Enumerable.Range(1, (int) Math.Floor(Math.Log(max, 2L))).Select(i\
    \ => (long) Math.Pow(2, i)).ToArray();\n        var divisors = factors.Where(p\
    \ => (p % n == 0L)).ToArray();\n        foreach (var divisor in divisors) {\n\
    \            if (divisor > max) {\n                max = divisor;\n          \
    \  }\n        }\n        return max;", "        long d = 1;\n        for (long\
    \ x = n; x > 1; x /= 2) {\n            if (n % x == 0) {\n                long\
    \ t = d / x;\n                d = x;\n                while (n % t == 0) {\n \
    \                   n /= t;\n                }\n            }\n        }\n   \
    \     return n;", "        long d = n;\n        while (n%2 == 0)\n           \
    \ n /= 2;\n        while (n%2 == 1)\n            n /= 2;\n        while (n%2 ==\
    \ 1)\n            n /= 2;\n        while (n != 1) {\n            while (n % 2\
    \ == 0)\n                n /= 2;\n            while (n % 2 == 1)\n           \
    \     n /= 2;\n            while (n % 2 == 1)\n                n /= 2;\n     \
    \   }\n        return d;", "        long biggest = n;\n        long divisor =\
    \ 1;\n        long remainder = 0;\n\n        while (remainder != 0) {\n      \
    \      remainder = n % divisor;\n            divisor++;\n            if (remainder\
    \ == 0) {\n                if (divisor < BiggestDivisor(divisor)) {\n        \
    \            biggest = divisor;\n                }\n                divisor =\
    \ 1;\n            }\n        }\n        return biggest;", "        if (n % 2 ==\
    \ 0) {\n            while (n % 2 == 0) {\n                n = n / 2;\n       \
    \     }\n            while (n % 2 != 0) {\n                n = n / 2;\n      \
    \      }\n            return n;\n        }\n        long max = n;\n        while\
    \ (max % 3 != 0) {\n            max = max / 3;\n        }\n        while (max\
    \ % 3 != 0) {\n            max = max / 3;\n        }\n        while (max % 5 !=\
    \ 0) {\n            max = max / 5;\n        }\n        while (max % 5 != 0) {\n\
    \            max = max / 5;\n        }\n        while (max % 7 != 0) {\n     \
    \       max = max / 7;\n        }\n        while (max % 7 != 0) {\n          \
    \  max = max / 7;\n        }\n        return max;", "        if (n < 2) return\
    \ n;\n        if (n % 2 == 0) return LargestDivisor(n - 1); // special case: even\
    \ numbers always divide evenly\n        if (n < 4) return n; // special case:\
    \ even numbers always divide evenly\n        if (n % 4 == 0) return LargestDivisor(n\
    \ - 4); // special case: 4 divides evenly\n        if (n < 9) return LargestDivisor(n\
    \ - 9);\n        if (n % 9 == 0) return LargestDivisor(n - 9);\n        if (n\
    \ < 16) return LargestDivisor(n - 16);\n        return LargestDivisor(n - 16);",
  "        long biggest = 1;\n        long testDivisor = 1;\n        while (testDivisor\
    \ < n) {\n            if (n % testDivisor == 0) {\n                biggest = testDivisor;\n\
    \                biggest = biggest * testDivisor;\n            }\n           \
    \ testDivisor = testDivisor + 1;\n        }\n        return biggest;", "     \
    \   int result = 0;\n        int divisor = 1;\n        while (n / divisor != 0)\
    \ {\n            result += divisor;\n            divisor *= 10;\n        }\n \
    \       n -= result * divisor;\n        while (n / divisor != 0) {\n         \
    \   divisor *= 10;\n        }\n        return result;", "        if (n == 0) return\
    \ 0;\n        long[] divisors = new long[n];\n        long maxDivisor = n;\n \
    \       for (int i = 1; i < n; i++)\n            divisors[i] = i;\n        for\
    \ (;;) {\n            long current = maxDivisor / 2;\n            if (current\
    \ > maxDivisor) break;\n            if (divisors[current] != current) break;\n\
    \            maxDivisor = current;\n        }\n        return maxDivisor;", " \
    \       var factors = new List<long>();\n        while (n != 0) {\n          \
    \  factors.Add(n%10);\n            n /= 10;\n        }\n        return factors.OrderByDescending(n\
    \ => n).First();", "        if (n == 0)\n            return (1L);\n        long\
    \ max_divisor = 1L;\n        long min_divisor = 1L;\n        long curr_divisor\
    \ = 1L;\n        while (curr_divisor <= n)\n        {\n            max_divisor\
    \ = curr_divisor;\n            min_divisor = curr_divisor;\n            curr_divisor\
    \ = n;\n            while (curr_divisor >= min_divisor)\n            {\n     \
    \           if (n % curr_divisor == 0)\n                    break;\n         \
    \       curr_divisor++;\n            }\n            if (curr_divisor <= n)\n \
    \               max_divisor = curr_divisor;\n        }\n        return (max_divisor);",
  "        long largestDivisor = -1;\n        long largestDivisorPower = 0;\n    \
    \    long testDivisor = n - 1;\n        while(testDivisor > 0) {\n           \
    \ long testPowerDivisor = testDivisor - 1;\n            long result = Math.Abs(testDivisor)\
    \ / Math.Abs(testPowerDivisor);\n            if(result > largestDivisor) {\n \
    \               largestDivisor = result;\n                largestDivisorPower\
    \ = testPowerDivisor;\n            }\n            testDivisor = testPowerDivisor;\n\
    \        }\n        return largestDivisor;", "        long maxDivisor = (long)\
    \ Math.Pow(2, (long)Math.Log(n)/2);\n        long largestDivisor;\n        do\
    \ {\n            largestDivisor = maxDivisor;\n            for (int i = 1; i <\
    \ maxDivisor; ++i) {\n                if (n % i == 0) {\n                    largestDivisor\
    \ = i;\n                    break;\n                }\n            }\n       \
    \     n /= largestDivisor;\n        } while (n != 0);\n        return largestDivisor;",
  "        long max = 0;\n        for (int i = 2; i <= Math.Floor((double)Math.Sqrt(n));\
    \ i++) {\n            if (n % i == 0) {\n                max = Math.Max(max, i);\n\
    \            }\n        }\n        return max;", "        Debug.WriteLine(\"LargestDivisor:\
    \ n=\" + n.ToString());\n        long max = 0;\n        for (long i = 1; i <=\
    \ n; i++) {\n            if ((n % i) == 0) {\n                if (i > max)\n \
    \                   max = i;\n            }\n        }\n        Debug.WriteLine(\"\
    LargestDivisor: max=\" + max.ToString());\n        return max;", "        long\
    \ res = 1L;\n        for (int i = 2; i <= n / 2; i++) {\n            if (n % i\
    \ == 0) {\n                if (res < n) res = i;\n            }\n        }\n \
    \       return res;", "        // If n is divisible by 4, then it's evenly divisible\
    \ by 2 as well\n        if (n & 1L == 0)\n            return n ;\n        // If\
    \ n is divisible by 2, then it's evenly divisible by 1 as well\n        if (n\
    \ & 2L == 0)\n            return n ;\n        // The answer is either the largest\
    \ divisor less than or equal to n, or\n        // the largest divisor equal to\
    \ n if n is prime\n        long maxDivisor = n;\n        while (!IsPrime(maxDivisor))\
    \ {\n            maxDivisor++;\n        }\n        return maxDivisor;", "    \
    \    if (n % 2 == 0)\n            return 2;\n        if (n % 3 == 0)\n       \
    \     return 3;\n        int maxDivisor = 2;\n        int currentDivisor = 3;\n\
    \        while (currentDivisor < n) {\n            if (n % currentDivisor == 0)\
    \ {\n                if (currentDivisor == 2)\n                    return n;\n\
    \                currentDivisor += 2;\n            }\n            else {\n   \
    \             currentDivisor++;\n            }\n            if (currentDivisor\
    \ > maxDivisor) {\n                maxDivisor = currentDivisor;\n            }\n\
    \        }\n        return maxDivisor;", "        long d = n - 1;\n        bool\
    \ even = true;\n        bool isPrime = true;\n        long largest = 0;\n    \
    \    long sqrt_n = Math.Sqrt(n);\n        while (true) {\n            while (true)\
    \ {\n                d = d * 2 + 1;\n                isPrime = true;\n       \
    \         for (long i = 2; i <= sqrt_n; i += 2) {\n                    if (n %\
    \ i == 0) {\n                        isPrime = false;\n                    }\n\
    \                    if (isPrime) {\n                        largest = i;\n  \
    \                      break;\n                    }\n                }\n    \
    \            if (isPrime) {\n                    break;\n                }\n \
    \           }\n            d /= 2;\n            if (d == 2) {\n              \
    \  return largest;\n            }\n            if (d > n) {\n                return\
    \ 0;\n            }\n        }", "        long smallestEvenDivisor = n;\n    \
    \    long greatestDivisor = n;\n        long div = 2;\n\n        while (true)\
    \ {\n            long next = n / div;\n            if (n % div == 0) {\n     \
    \           smallestEvenDivisor = next;\n            }\n            else if (next\
    \ % div == 0) {\n                greatestDivisor = next;\n            }\n    \
    \        else {\n                smallestEvenDivisor = next;\n               \
    \ greatestDivisor = div;\n            }\n            div += 2;\n            if\
    \ (div > 2000000000)\n                break;\n        }\n        return greatestDivisor;",
  "        long i = 1;\n        while (i <= n) {\n            if (n % i == 0) {\n\
    \                long divisor = i;\n                while ((n / divisor) > divisor)\
    \ {\n                    divisor *= 2;\n                }\n                return\
    \ divisor;\n            }\n            i++;\n        }\n        return n;", " \
    \       long divisor = 0;\n        long maxDivisor = 0;\n        for (int i =\
    \ 2; i <= n; i++) {\n            if (n % i == 0) {\n                if (divisor\
    \ > maxDivisor) {\n                    maxDivisor = divisor;\n               \
    \ }\n                divisor = i;\n            }\n        }\n        if (divisor\
    \ > maxDivisor) {\n            maxDivisor = divisor;\n        }\n        return\
    \ maxDivisor;", "        long maxDivisor = 0;\n        for (long i = 1; i <n;\
    \ i++)\n            if (n % i == 0)\n                maxDivisor = Math.Max(maxDivisor,\
    \ i);\n        return maxDivisor;", "        long largestDivisor = n;\n      \
    \  for (long i = 2; i <= Math.Floor(Math.Sqrt(n) + 1); i++)\n            if (n\
    \ % i == 0)\n                largestDivisor = i;\n        return largestDivisor;",
  "        long highest = Long.MinValue;\n        for (long d = 1; d <= n; d++) {\n\
    \            if ((n % d) == 0) continue;\n            long tmp = Math.Sqrt(d);\n\
    \            while (tmp * d <= n) {\n                if (tmp * d > highest) highest\
    \ = tmp * d;\n                tmp++;\n            }\n        }\n        return\
    \ highest;", "        bool noDivisors = true;\n        long result = 0;\n    \
    \    for (long i = 1; i < n / 2; i++) {\n            if (n % i == 0) {\n     \
    \           noDivisors = false;\n                result = i;\n               \
    \ break;\n            }\n        }\n        if (noDivisors) return n;\n      \
    \  if (result > n) return n;\n        return (result) + 1;", "        ulong q\
    \ = (ulong) n;\n        long largestDivisor = 0;\n        bool check = true;\n\
    \n        while (check) {\n            ulong r = q / 2;\n            long r =\
    \ Convert.ToInt64(r);\n\n            if ((r % 2) == 0) {\n                check\
    \ = false;\n            }\n            else {\n                largestDivisor\
    \ = largestDivisor + (r / 2);\n                q = q - r;\n            }\n   \
    \     }\n        return largestDivisor;", "        if (n < 2)\n            return\
    \ n;\n        long largest = n + 1;\n        long i = 2;\n        long lastDivide\
    \ = -1;\n        do {\n            if (largest%i == 0) {\n                if (lastDivide\
    \ == -1) {\n                    lastDivide = i;\n                }\n         \
    \       else {\n                    if (lastDivide != i) {\n                 \
    \       return largest;\n                    }\n                }\n          \
    \  }\n            i++;\n        } while (i <= n);\n        return largest;", " \
    \       var primes = Primes(n);\n        bool isPrime = true;\n        var largestDivisor\
    \ = long.MinValue;\n        foreach (long prime in primes) {\n            if (n\
    \ % prime == 0) {\n                isPrime = false;\n                break;\n\
    \            }\n        }\n        if (!isPrime) {\n            return largestDivisor;\n\
    \        }\n        for (long i = long.MinValue; i <= n; i = i + 1) {\n      \
    \      bool isDivisor = true;\n            foreach (long prime in primes) {\n\
    \                if (i % prime != 0) {\n                    isDivisor = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isDivisor) {\n                largestDivisor = i;\n            }\n        }\n\
    \        return largestDivisor;", "        long result = 1;\n        for (long\
    \ i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                result\
    \ = i;\n                break;\n            }\n        }\n        return result;",
  "        var c = new BigInteger(\"2\");\n        var max = c;\n        foreach (var\
    \ x in Enumerable.Range(0, n).Where(x => n % x == 0)) {\n            max = max\
    \ * x;\n        }\n        return max;", "        long max;\n        long div;\n\
    \        int i;\n        long primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        for (i\
    \ = 0; i != primes.Length; ++i) {\n            div = (long) Math.Pow((double)\
    \ primes[i], (double) (i+1));\n            if (n > div && div % 2 != 0) {\n  \
    \              max = div;\n                break;\n            }\n        }\n\
    \        return max;", "        long res = 0;\n        for (long i = 1; i < n;\
    \ ++i) {\n            if (n % i == 0)\n                res = i;\n        }\n \
    \       return res;", "        long maxDivisor = 1;\n        for (int i = 1; i\
    \ <= Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                maxDivisor\
    \ = i;\n            }\n        }\n        return maxDivisor;", "        long[]\
    \ primes = PrimeGenerator().ToArray();\n        long max = (long)Math.Sqrt(n);\n\
    \        long res = -1;\n        foreach (var prime in primes) {\n           \
    \ for (int i = 2; i <= max; i++) {\n                if (prime * i == n) {\n  \
    \                  res = prime;\n                    break;\n                }\n\
    \            }\n            if (res >= 0)\n                break;\n        }\n\
    \        return res;", "        long largest = n;\n        long div = 2;\n   \
    \     while (div <= n) {\n            if (n % div == 0) {\n                largest\
    \ = div;\n            }\n            div++;\n        }\n        return largest;",
  "        long largest = -1;\n        while (n != 0) {\n            long divisor\
    \ = n%10;\n            if (divisor==0) {\n                largest = divisor;\n\
    \                break;\n            }\n            n/=10;\n        }\n      \
    \  return largest;", "        long maxDivisor = 1;\n        long currentDivisor\
    \ = 1;\n        while (currentDivisor < n) {\n            currentDivisor++;\n\
    \            maxDivisor++;\n        }\n        return maxDivisor;", "        //\
    \ If n is odd, return n because n is a divisor\n        if ((n % 2) == 1) {\n\
    \            return n;\n        }\n\n        // Scan the list of possible divisors\n\
    \        List<long> divisors = divisors();\n\n        // Scan the list of possible\
    \ divisors, looking for ones that divide n evenly\n        foreach (long divisor\
    \ in divisors) {\n            if (n % divisor == 0) {\n                return\
    \ divisor;\n            }\n        }\n\n        // No divisor divides n evenly,\
    \ so n is a divisor\n        return n;", "        long largest = 0;\n        for\
    \ (long i = 2; i <= n; i += 2)\n            if (n % i == 0) {\n              \
    \  largest = i;\n                break;\n            }\n        return largest;",
  "        long d = 0;\n        for (long i = 2; i <= n / 2; i++) {\n            d\
    \ += i * i;\n        }\n        return d;", "        long result = 1;\n      \
    \  while (n > 0) {\n            if (n % 2 == 0) result *= n;\n            n =\
    \ n / 2;\n        }\n        return result;", "        // TODO: Optimize (use\
    \ bitwise operators for example)\n        int maxDivisor = 0;\n        long divisor\
    \ = 1;\n        while (divisor <= n) {\n            long remainder = n % divisor;\n\
    \            if (remainder == 0) {\n                maxDivisor = divisor;\n  \
    \          }\n            divisor++;\n        }\n        return maxDivisor;",
  "        // Create a boolean array to mark which numbers are divisible\n       \
    \ bool[] divided = new bool[100];\n        // Create an array of all numbers from\
    \ 1 through n\n        long[] divisors = new long[101];\n        divisors[1] =\
    \ 1;\n        divisors[2] = 2;\n        divisors[3] = 3;\n        // Set all divisible\
    \ numbers to true\n        foreach (long d in divisors) {\n            divided[d]\
    \ = true;\n        }\n        // Traverse the array, dividing numbers as they\
    \ are found\n        foreach (long d in divisors) {\n            if (divided[d])\
    \ {\n                divided[d] = false;\n                long next = d + 1;\n\
    \                while (next < n) {\n                    divided[next] = true;\n\
    \                    next = next + 1;\n                }\n            }\n    \
    \    }\n        // The largest number divisible by all numbers from 1 to n\n \
    \       long largest = 0;\n        foreach (long d in divisors) {\n          \
    \  if (d == n) return n;\n            if (d > largest) {\n                largest\
    \ = d;\n            }\n        }\n        return largest;", "        long largestDivisor\
    \ = -1;\n        long d = 1;\n        for (int i = 1; i <= n; i++) {\n       \
    \     if (n % i == 0) {\n                d = i * d;\n                while (n\
    \ % d == 0) {\n                    d *= d;\n                }\n              \
    \  if (d > largestDivisor) {\n                    largestDivisor = d;\n      \
    \          }\n            }\n        }\n        return largestDivisor;", "   \
    \     long res = 0;\n        long sqrt = (long)Math.Sqrt(n); // this calculates\
    \ the sqrt of n\n        while (n % 2 == 0) { // until we find one that is divisible\
    \ by 2\n            if (sqrt == 0 || sqrt % 2 == 0)\n                return 0;\n\
    \            sqrt /= 2;\n        }\n        while (sqrt != 0) { // until we find\
    \ one that divides evenly\n            if (n % sqrt == 0)\n                res\
    \ = sqrt;\n            sqrt /= 2;\n        }\n        return res;", "        var\
    \ nums = Enumerable.Range(1, n).Where((x) => n % x == 0).ToList();\n        return\
    \ nums.Where((x) => x <= n).Max();", "        // The divisors of n are 0, 1, 2,\
    \ 4, 8, 16, 25, 35, ...\n        // The largest divisor is one that divides n\
    \ evenly, smaller than n\n        long maxDivisor = long.MaxValue;\n        long\
    \ divisor = 0;\n        while (divisor < maxDivisor) {\n            if (n % divisor\
    \ == 0) {\n                long d = n / divisor;\n                if (d > maxDivisor)\
    \ {\n                    maxDivisor = d;\n                }\n            }\n \
    \           divisor++;\n        }\n        return maxDivisor;", "        long\
    \ mostDivisor = n;\n        while (mostDivisor > 0) {\n            if (n % mostDivisor\
    \ == 0) {\n                return mostDivisor;\n            }\n            mostDivisor\
    \ /= 2;\n        }\n        // This line is never reached.\n        return n;",
  "        long maxDivisor = n;\n        long divisor = 2;\n        while (divisor\
    \ < n && divisor < maxDivisor) {\n            maxDivisor = divisor + 1;\n    \
    \        divisor += 2;\n        }\n        return maxDivisor;", "        long\
    \ maxDivisor = 0;\n        long largestDivisor = 0;\n        long remainder =\
    \ 0;\n        long divisor = 1;\n\n        // Find the largest divisor smaller\
    \ than n\n        while (n / divisor > maxDivisor) {\n            remainder =\
    \ n % divisor;\n            if (remainder > 0) {\n                maxDivisor =\
    \ divisor;\n            }\n            divisor++;\n        }\n\n        // Find\
    \ the remainder of the divisor\n        if (remainder > 0) {\n            maxDivisor\
    \ = divisor;\n        }\n\n        return maxDivisor;", "        long biggest\
    \ = 1;\n        long lastDivisor = n;\n        while (lastDivisor != 0) {\n  \
    \          long currentDivisor = lastDivisor % 2;\n            if (currentDivisor\
    \ == 1) {\n                if (lastDivisor != 1)\n                    biggest\
    \ = lastDivisor;\n            } else {\n                if (currentDivisor > biggest)\n\
    \                    biggest = currentDivisor;\n            }\n            lastDivisor\
    \ = currentDivisor;\n        }\n        return biggest;", "        if (n == 1)\
    \ return 0;\n        if (n % 2 == 0) return LargestDivisor(n / 2L) + 1;\n    \
    \    if (n % 3 == 0) return LargestDivisor(n / 3L) + 3;\n        if (n % 5 ==\
    \ 0) return LargestDivisor(n / 5L) + 5;\n        return LargestDivisor(n / 7L)\
    \ + 7;", "        long largestDivisor = 0;\n        long tempDivisor = 1;\n\n\
    \        for (long divisor = 2; divisor <= n; divisor++) {\n            if (n\
    \ % divisor == 0) {\n                tempDivisor = divisor;\n            }\n \
    \           if (tempDivisor > largestDivisor) {\n                largestDivisor\
    \ = tempDivisor;\n            }\n        }\n        return largestDivisor;", " \
    \       long maxDivisor = n;\n        long maxDividend = n;\n        bool isPrime\
    \ = false;\n        long divisor = n;\n        long dividend = n;\n\n        do\
    \ {\n            divisor = Divisor(divisor);\n            dividend = Dividend(dividend);\n\
    \n            isPrime = Divisor(divisor) == 1;\n            if (isPrime && dividend\
    \ % divisor == 0)\n            {\n                maxDivisor = divisor;\n    \
    \            maxDividend = dividend;\n            }\n        } while (divisor\
    \ <= maxDivisor);\n        return maxDividend;", "        long d = 2;\n      \
    \  while (d < n) {\n            if (n % d == 0) {\n                return d;\n\
    \            }\n            d += 2;\n        }\n        return n;", "        long\
    \ maxDivisor = n; //set max to n\n        for (long i = 2; i <= n / 2; i++) {\n\
    \            if (n % i == 0) {\n                maxDivisor = i;\n            }\n\
    \        }\n        return maxDivisor;", "        long max = 0;\n        for(long\
    \ divisor = 2; divisor < n; divisor++) {\n            if (n % divisor == 0) {\n\
    \                if (max < divisor) {\n                    max = divisor;\n  \
    \              }\n            }\n        }\n        return max;", "        long\
    \ max = 1;\n        for (long i = 1; i <= n; i++) {\n            if (n % i ==\
    \ 0) {\n                max = Math.Max(max, i);\n            }\n        }\n  \
    \      return max;", "        long max = 0;\n        long current = 1;\n     \
    \   while (current * current <= n) {\n            if (n % current == 0) {\n  \
    \              current = current + 1;\n            } else {\n                current\
    \ = 1;\n            }\n            if (current > max) {\n                max =\
    \ current;\n            }\n        }\n        return max;", "        long largest\
    \ = 1;\n        long a = 1;\n        long b = 2;\n        while (b <= n / 2) {\n\
    \            largest = a;\n            a = b;\n            b = a * (long) Math.Pow(b,\
    \ (long) n);\n        }\n        if (n > 1 && a % 2 == 0) {\n            largest\
    \ = a;\n        }\n        return largest;", "        return n == 2? n : Math.Min(\n\
    \                LargestDivisor(n / 2),\n                LargestDivisor(n / 3)\n\
    \            );", "        // Find the highest power of 2 that divides n evenly\
    \ (using bitwise operators)\n        // >>> PowerOfTwo(5L)\n        // 8\n   \
    \     long pow2 = 1L << (long)Math.Log(n);\n        long mask = n - pow2;\n  \
    \      // Bitwise OR operation: set all bits that correspond to 1 in mask to 1\n\
    \        // >>> PowerOfTwo(5L)\n        // 8\n        // >>> BitwiseOr(8, 7L)\n\
    \        // 16\n        return n | mask;", "        long maxDivisor = 1;\n   \
    \     long largestDivisor = 0;\n        long nToUse = n;\n        while (nToUse\
    \ > 0) {\n            long nDivisor = n % nToUse;\n            largestDivisor\
    \ = largestDivisor > nDivisor ? largestDivisor : nDivisor;\n            maxDivisor\
    \ = maxDivisor > nDivisor ? maxDivisor : nDivisor;\n            nToUse = nToUse\
    \ / nDivisor;\n        }\n        return largestDivisor;", "        if (n < 0)\n\
    \            return 0;\n\n        long largestDivisor = 1L;\n        for (long\
    \ d = 1L; d <= n; d++) {\n            if ((n / d) % 2 == 0)\n                largestDivisor\
    \ = d;\n        }\n        return largestDivisor;", "        var divisors = new\
    \ List<long>();\n        for (var i = 1; i < n; i++) {\n            if (n % i\
    \ == 0) {\n                divisors.Add(i);\n            }\n        }\n      \
    \  if (divisors.Count == 0) {\n            return n;\n        }\n        var largestDivisor\
    \ = divisors[0];\n        for (var i = 1; i < divisors.Count; i++) {\n       \
    \     if (divisors[i] > largestDivisor) {\n                largestDivisor = divisors[i];\n\
    \            }\n        }\n        return largestDivisor;", "        HashSet<long>\
    \ Divisors = new HashSet<long>();\n        long largest_divisor = n;\n       \
    \ \n        // Try every number less than n\n        for (long divisor = n + 1;\
    \ ; divisor++) {\n            if (n % divisor == 0) {\n                Divisors.Add(divisor);\n\
    \                if (divisor > largest_divisor) {\n                    largest_divisor\
    \ = divisor;\n                }\n            }\n        }\n\n        // Return\
    \ the largest divisor less than n that divides n evenly\n        if (Divisors.Count\
    \ > 0) {\n            return largest_divisor;\n        } else {\n            return\
    \ -1;\n        }", "        bool evenDivide = true;\n        long largestDivisor\
    \ = 0;\n        long divisor = 0;\n        while (evenDivide) {\n            if\
    \ (n % divisor == 0) {\n                evenDivide = false;\n                largestDivisor\
    \ = divisor;\n                divisor = divisor + 1;\n            } else {\n \
    \               divisor = divisor + 1;\n            }\n        }\n        return\
    \ largestDivisor;", "        long largest = n;\n        long maxDivisor = n;\n\
    \        while ((maxDivisor % 2) == 0) {\n            maxDivisor = maxDivisor\
    \ / 2;\n        }\n        for (long i = 3; i <= maxDivisor; i = i * 2) {\n  \
    \          if (n % i == 0) {\n                largest = i;\n                break;\n\
    \            }\n        }\n        return largest;", "        long divisor = n;\n\
    \        for (long d = 2; d < n; d++) {\n            if (n % d == 0) {\n     \
    \           divisor = d;\n            }\n        }\n        return divisor;",
  "        long maxDivisor = n;\n        long maxDivisorSoFar = n;\n        long divisor\
    \ = 1;\n        while (divisor <= maxDivisorSoFar) {\n            maxDivisorSoFar\
    \ /= divisor;\n            if (maxDivisorSoFar % 2 == 0) {\n                maxDivisor\
    \ = maxDivisorSoFar;\n                divisor = 2;\n            }\n          \
    \  else if (maxDivisorSoFar % 2 != 0) {\n                divisor++;\n        \
    \    }\n        }\n        return maxDivisor;", "        List<long> divisors =\
    \ new List<long>();\n        while (n != 1) {\n            if (n % 2 == 0) {\n\
    \                divisors.Add(2);\n                n /= 2;\n            } else\
    \ {\n                divisors.Add(n);\n            }\n        }\n        divisors.Reverse();\n\
    \        return divisors.Max();", "        var div = Enumerable.Range(0, long.MaxValue\
    \ / 2).Where(x => n % x == 0).ToList();\n        if (div.Count > 0) {\n      \
    \      return div[0];\n        }\n        div = Enumerable.Range(0, long.MaxValue\
    \ / 2).Where(x => n % x == 0).ToList();\n        if (div.Count > 0) {\n      \
    \      return div[0];\n        }\n        return n;", "        long m = 2;\n \
    \       while (m <= n / 2) {\n            if (n % m == 0) {\n                return\
    \ m;\n            }\n            m += 1;\n        }\n        return n;", "   \
    \     // Sort the numbers first by greatest to least\n        List<long> result\
    \ = new List<long>();\n        long biggest = n;\n        foreach (long i in Enumerable.Range(0,\
    \ long.MaxValue)) {\n            long lower = i;\n            long upper = i;\n\
    \            while (true) {\n                upper = upper / 2;\n            \
    \    if (upper < lower) {\n                    break;\n                }\n   \
    \             if (n % lower == 0) {\n                    result.Add(lower);\n\
    \                    break;\n                }\n            }\n            if\
    \ (result.Count != 0) {\n                if (result.Max() > biggest) {\n     \
    \               biggest = result.Max();\n                }\n            }\n  \
    \      }\n        return biggest;", "        long maxDivisor = n;\n        long\
    \ divisor = 1;\n        while (n != 1) {\n            divisor++;\n           \
    \ while (n % divisor != 0) {\n                divisor++;\n            }\n    \
    \        if (divisor > maxDivisor) {\n                maxDivisor = divisor;\n\
    \            }\n            n /= divisor;\n        }\n        return maxDivisor;",
  "        long result = n;\n        long remainder;\n        while (remainder = n\
    \ % result) {\n            n /= result;\n            result = remainder;\n   \
    \     }\n        return result;", "        // Create a list to store all divisors\
    \ of n\n        List<long> divisors = new List<long>();\n        long n = n;\n\
    \        long result = n;\n        while (n > 1) {\n            while (n % 2 ==\
    \ 0) {\n                divisors.Add(2);\n                n = n / 2;\n       \
    \     }\n            while (n % 3 == 0) {\n                divisors.Add(3);\n\
    \                n = n / 3;\n            }\n            while (n % 5 == 0) {\n\
    \                divisors.Add(5);\n                n = n / 5;\n            }\n\
    \            while (n % 7 == 0) {\n                divisors.Add(7);\n        \
    \        n = n / 7;\n            }\n            while (n % 11 == 0) {\n      \
    \          divisors.Add(11);\n                n = n / 11;\n            }\n   \
    \         while (n % 13 == 0) {\n                divisors.Add(13);\n         \
    \       n = n / 13;\n            }\n            while (n % 17 == 0) {\n      \
    \          divisors.Add(17);\n                n = n / 17;\n            }\n   \
    \         while (n % 19 == 0) {\n                divisors.Add(19);\n         \
    \       n = n / 19;\n            }\n            while (n % 23 == 0) {\n      \
    \          divisors.Add(23);\n                n = n / 23;\n            }\n   \
    \         while (n % 29 == 0) {\n                divisors.Add(29);\n         \
    \       n = n / 29;\n            }\n            while (n % 37 == 0) {\n      \
    \          divisors.Add(37);\n                n = n / 37;\n            }\n   \
    \         while (n % 41 == 0) {\n                divisors.Add(41);\n         \
    \       n = n / 41;\n            }\n            while (n % 43 == 0) {\n      \
    \          divisors.Add(43);\n                n = n / 43;\n            }\n   \
    \         while (n % 47 == 0) {\n                divisors.Add(47);\n         \
    \       n = n / 47;\n            }\n            while (n % 51 == 0) {\n      \
    \          divisors.Add(51);\n                n = n / 51;\n            }\n   \
    \         while (n % 59 == 0) {\n                divisors.Add(59);\n         \
    \       n = n / 59;\n            }\n            while (n % 63 == 0) {\n      \
    \          divisors.Add(63);\n                n = n / 63;\n            }\n   \
    \         while (n % 67 == 0) {\n                divisors.Add(67);\n         \
    \       n = n / 67;\n            }\n            while (n % 71 == 0) {\n      \
    \          divisors.Add(71);\n                n = n / 71;\n            }\n   \
    \         while (n % 73 == 0) {\n                divisors.Add(73);\n         \
    \       n = n / 73;\n            }\n            while (n % 79 == 0) {\n      \
    \          divisors.Add(79);\n                n = n / 79;\n            }\n   \
    \         while (n % 83 == 0) {\n                divisors.Add(83);\n         \
    \       n = n / 83;\n            }\n            while (n % 89 == 0) {", "    \
    \    long maxN = 0;\n        long maxDif = -1;\n        for (int i = 1; i < n;\
    \ i++) {\n            long d = Divisor(i);\n            if (d == 0) {\n      \
    \          maxN = 0;\n            } else {\n                if (maxDif < d ||\
    \ maxDif == -1) {\n                    maxN = d;\n                    maxDif =\
    \ d;\n                }\n            }\n        }\n        return maxN;", "  \
    \      long largestDivisor = n;\n        for(long i = 2; i <= largestDivisor;\
    \ i++) {\n            if(n % i == 0) {\n                long x = n / i;\n    \
    \            if(x > largestDivisor)\n                    largestDivisor = x;\n\
    \            }\n        }\n        return largestDivisor;", "        long maxDivisor\
    \ = n;\n        long x = n++;\n        do {\n            long y = x;\n       \
    \     while (x % 2 == 0) {\n                y /= 2;\n            }\n         \
    \   if (y != maxDivisor) {\n                maxDivisor = y;\n            }\n \
    \           x ++;\n        } while (x < n);\n        return maxDivisor;", "  \
    \      long largestDivisor = 0L;\n        for (long divisor = 1; divisor <= n;\
    \ divisor++) {\n            long divisorRemaining = n % divisor;\n           \
    \ if (divisorRemaining == 0L) {\n                long newLargestDivisor = divisor;\n\
    \                if (newLargestDivisor > largestDivisor) {\n                 \
    \   largestDivisor = newLargestDivisor;\n                }\n            }\n  \
    \      }\n        return largestDivisor;", "        var list = new List<long>();\n\
    \        long largestFactor = 0;\n        long maxFactor = 0;\n        while (n\
    \ > 2) {\n            long testedFactor = 0;\n            while (n % 2 == 0) {\n\
    \                testedFactor *= 2;\n                n /= 2;\n            }\n\
    \            largestFactor = Math.Max(testedFactor, largestFactor);\n        \
    \    list.Add(testedFactor);\n            maxFactor = Math.Max(testedFactor, maxFactor);\n\
    \        }\n        largestFactor = Math.Max(largestFactor, maxFactor);\n    \
    \    return largestFactor;", "        long largest = n;\n        long dividend\
    \ = n;\n        while (dividend > 0) {\n            dividend = dividend % 2 ==\
    \ 0 ? dividend : dividend - 1;\n            if (dividend > largest) {\n      \
    \          largest = dividend;\n            }\n        }\n        return largest;",
  "        long LargestDivisor = 1;\n        long numDivisor = 1;\n        long currentDivisor\
    \ = 1;\n        while (n != 0) {\n            long tester = numDivisor * (numDivisor\
    \ + 1);\n            if (n % tester == 0) {\n                currentDivisor++;\n\
    \            }\n            else {\n                numDivisor = currentDivisor;\n\
    \            }\n            currentDivisor = 1;\n        }\n        LargestDivisor\
    \ = numDivisor * (numDivisor + 1);\n        return LargestDivisor;", "       \
    \ if (n <= 1) return 1;\n        long largest = 1;\n        for (int i = 1; i\
    \ <= n; i++) {\n            long temp = 1;\n            for (int j = 1; j <= i;\
    \ j++) {\n                if (i % j == 0) temp *= j;\n            }\n        \
    \    if (temp > largest) largest = temp;\n        }\n        return largest;",
  "        if (n == 0)\n            return 0;\n        long largestDivisor = n; long\
    \ currentDivisor = n; long nextDivisor = n;\n        // keep going until we find\
    \ one that's smaller than n\n        while (nextDivisor % 2 == 0) { currentDivisor\
    \ = nextDivisor; nextDivisor = nextDivisor * 2; }\n        while ((currentDivisor\
    \ % 2) == 0) {\n            currentDivisor = currentDivisor * 2; // get next divisor\n\
    \            largestDivisor = currentDivisor; // keep track of largest divisor\
    \ so far\n        }\n        return largestDivisor;", "        long biggest =\
    \ n;\n        for (long div = 2; div <= n; div++) {\n            if (n % div ==\
    \ 0) {\n                long divN = div * div;\n                if (divN > biggest)\
    \ {\n                    biggest = divN;\n                }\n            }\n \
    \       }\n        return biggest;", "        long d = 0;\n        while (n >\
    \ 1) {\n            d += 1;\n            n /= 2;\n        }\n        return d;",
  "        if (n == 1)\n            return 1;\n        long r = 1;\n        while\
    \ (n%2 == 0) {\n            n /= 2;\n            r *= 2;\n        }\n        while\
    \ (n % 2 != 0) {\n            n /= 2;\n            r *= 2;\n        }\n      \
    \  return r;", "        // This is O(sqrt(n)) time but O(n) space\n        var\
    \ remainder = n;\n        var largestDivisor = n;\n        while (remainder >\
    \ 1) {\n            // If this divisor is larger than the largest divisor, update\
    \ it\n            if (remainder % 2 == 0) {\n                largestDivisor =\
    \ largestDivisor / 2;\n            }\n            else {\n                // Otherwise\
    \ just move down the divisor\n                largestDivisor = largestDivisor\
    \ * 3 + 1;\n            }\n            remainder = remainder / 2;\n        }\n\
    \        return largestDivisor;"]
stop_tokens:
- "\n    }\n"
