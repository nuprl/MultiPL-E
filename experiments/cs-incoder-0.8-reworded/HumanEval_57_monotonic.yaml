name: HumanEval_57_monotonic
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return true is list elements are monotonically increasing or\
  \ decreasing.\n    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)4L, (long)20L})))\n    // (true)\n    // >>> Monotonic((new List<long>(new\
  \ long[]{(long)1L, (long)20L, (long)4L, (long)10L})))\n    // (false)\n    // >>>\
  \ Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))\n\
  \    // (true)\n    public static bool Monotonic(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Monotonic((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));\n\
  \    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,\
  \ (long)20L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L,\
  \ (long)20L, (long)4L, (long)10L}))) == (false));\n    Debug.Assert(Monotonic((new\
  \ List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));\n\
  \    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L,\
  \ (long)0L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));\n    Debug.Assert(Monotonic((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L})))\
  \ == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L,\
  \ (long)9L, (long)9L}))) == (true));\n    }\n\n}\n"
completions: ["        bool isIncreasing = true;\n        if (l.Count < 2) {\n   \
    \         return true;\n        }\n        if (l.Count == 2) {\n            if\
    \ (l.Min() >= l.Max()) {\n                return true;\n            }\n      \
    \      return false;\n        }\n        bool isDecreasing = true;\n        List<long>\
    \ lastElements = l.Take(l.Count - 1).ToList();\n        foreach (var element in\
    \ l.Skip(1).ToList()) {\n            if (element > lastElements.Max()) {\n   \
    \             isDecreasing = false;\n                break;\n            }\n \
    \           lastElements.Add(element);\n        }\n        if (isDecreasing &&\
    \ isIncreasing) {\n            return true;\n        }\n        if (isDecreasing\
    \ && !isIncreasing) {\n            return true;\n        }\n        if (!isDecreasing\
    \ && isIncreasing) {\n            return true;\n        }\n        return false;",
  "        long first = l.First();\n        long last = l.Last();\n\n        if (first\
    \ == last)\n            return true;\n\n        double span = last - first;\n\
    \        if (span < 1)\n            return false;\n\n        double lastGap =\
    \ last - l.LastOrDefault();\n        double gap = l.FirstOrDefault() - first;\n\
    \n        return Math.Abs(gap - lastGap) < double.Epsilon;", "        if (l.Count\
    \ < 2) return true;\n        long x = l[0], y = l[1];\n        for (int i = 2;\
    \ i < l.Count; i++) {\n            if (x <= l[i-1] && y <= l[i])\n           \
    \     return false;\n            if (x > l[i-1] && y < l[i])\n               \
    \ return false;\n            x = l[i];\n            y = l[i-1];\n        }\n \
    \       return true;", "        if (l.Count < 2) {\n            return true;\n\
    \        }\n        long largest = l[0];\n        long smallest = l[0];\n    \
    \    foreach (long number in l.Skip(1)) {\n            if (number > largest) {\n\
    \                largest = number;\n            }\n            if (number < smallest)\
    \ {\n                smallest = number;\n            }\n        }\n        return\
    \ largest >= smallest;", "        long a = 0;\n        long b = 0;\n        foreach\
    \ (var element in l) {\n            a = a + element;\n            b = b + element;\n\
    \        }\n        bool increasing = (a > b);\n        if (increasing) {\n  \
    \          Debug.WriteLine(\"increasing\");\n        }\n        else {\n     \
    \       Debug.WriteLine(\"decreasing\");\n        }\n        return increasing;",
  "        long min = l.Min();\n        long max = l.Max();\n        if (min > max)\n\
    \            return false;\n        if (min == max)\n            return true;\n\
    \        long i = 1;\n        while ((i < l.Count) && (l.ElementAt(i) == min))\
    \ {\n            i++;\n        }\n        if (i < l.Count) {\n            long\
    \ j = 1;\n            while ((j < l.Count) && (l.ElementAt(j) == max)) {\n   \
    \             j++;\n            }\n            if (j < l.Count) {\n          \
    \      long mid = i;\n                while (j < l.Count) {\n                \
    \    if (l.ElementAt(j) < l.ElementAt(mid)) {\n                        mid = j;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                    j++;\n                }\n                if (mid\
    \ == l.Count - 1) {\n                    return false;\n                } else\
    \ {\n                    i = mid + 1;\n                }\n            } else {\n\
    \                long mid = i;\n                while (i < l.Count) {\n      \
    \              if (l.ElementAt(i) < l.ElementAt(mid)) {\n                    \
    \    mid = i;\n                    } else {\n                        break;\n\
    \                    }\n                    i++;\n                }\n        \
    \        if (mid == l.Count - 1) {\n                    return true;\n       \
    \         } else {\n                    j = mid;\n                }\n        \
    \    }\n        }\n        return true;", "        Debug.Assert(!l.Contains(0L));\n\
    \        Debug.Assert(!l.Contains(1L));\n        Debug.Assert(!l.Contains(2L));\n\
    \        Debug.Assert(!l.Contains(3L));\n        Debug.Assert(!l.Contains(4L));\n\
    \        Debug.Assert(!l.Contains(5L));\n        Debug.Assert(!l.Contains(6L));\n\
    \        Debug.Assert(!l.Contains(7L));\n        Debug.Assert(!l.Contains(8L));\n\
    \        Debug.Assert(!l.Contains(9L));\n        Debug.Assert(!l.Contains(10L));\n\
    \        Debug.Assert(!l.Contains(11L));\n        Debug.Assert(!l.Contains(12L));\n\
    \        Debug.Assert(!l.Contains(13L));\n        Debug.Assert(!l.Contains(14L));\n\
    \        Debug.Assert(!l.Contains(15L));\n        Debug.Assert(!l.Contains(16L));\n\
    \        Debug.Assert(!l.Contains(17L));\n        Debug.Assert(!l.Contains(18L));\n\
    \        Debug.Assert(!l.Contains(19L));\n        Debug.Assert(!l.Contains(20L));\n\
    \        Debug.Assert(!l.Contains(21L));\n        Debug.Assert(!l.Contains(22L));\n\
    \        Debug.Assert(!l.Contains(23L));\n        Debug.Assert(!l.Contains(24L));\n\
    \        Debug.Assert(!l.Contains(25L));\n        Debug.Assert(!l.Contains(26L));\n\
    \        Debug.Assert(!l.Contains(27L));\n        Debug.Assert(!l.Contains(28L));\n\
    \        Debug.Assert(!l.Contains(29L));\n        Debug.Assert(!l.Contains(30L));\n\
    \        Debug.Assert(!l.Contains(31L));\n        Debug.Assert(!l.Contains(32L));\n\
    \        Debug.Assert(!l.Contains(33L));\n        Debug.Assert(!l.Contains(34L));\n\
    \        Debug.Assert(!l.Contains(35L));\n        Debug.Assert(!l.", "       \
    \ var x = l[0];\n        if (x.Equals(0))\n            return true;\n        for\
    \ (int i = 1; i < l.Count; i++) {\n            var y = l[i];\n            if (x\
    \ == y)\n                return false;\n            if (x < y || x == y)\n   \
    \             return false;\n            x = y;\n        }\n        return true;",
  "        long first = l.First();\n        long last = l.Last();\n        bool reversed\
    \ = false;\n\n        if (first <= last) {\n            // reverse the list\n\
    \            l.Reverse();\n            reversed = true;\n        }\n\n       \
    \ bool ok = true;\n        for (int i = 0; i < l.Count - 1; i++) {\n         \
    \   long test = l.ElementAt(i);\n            long next = l.ElementAt(i + 1);\n\
    \n            if (next <= test) {\n                ok = false;\n             \
    \   break;\n            }\n        }\n        if (reversed) {\n            l.Reverse();\n\
    \        }\n\n        return ok;", "        if (l.Count < 2) return true;\n  \
    \      var first = l.First();\n        var last = l.Last();\n        for (var\
    \ i = 1; i < l.Count; ++i) {\n            var nextVal = l[i];\n            var\
    \ prevVal = l[i - 1];\n            if (nextVal < first) return false;\n      \
    \      if (prevVal < first) return false;\n        }\n        return true;", " \
    \       int last = l.Count - 1;\n        bool decreasing = l[last] < l[last -\
    \ 1];\n        long current = l[last];\n        long next = l[last - 1];\n   \
    \     if (current == 0) {\n            return true;\n        }\n        while\
    \ (true) {\n            if ((next < current) == decreasing) {\n              \
    \  return true;\n            }\n            if (next == current) {\n         \
    \       return false;\n            }\n            current = (long)Math.Ceiling(current\
    \ / next);\n            next = (long)Math.Floor(next / next);\n        }", " \
    \       if (l.Count < 2)\n            return false;\n        var firstValue =\
    \ l[0];\n        Debug.Assert(firstValue > 0);\n        Debug.Assert(l.Count >\
    \ 1);\n        var secondValue = l[1];\n        Debug.Assert(secondValue > 0);\n\
    \        for (int i = 2; i < l.Count; i++)\n        {\n            var currentValue\
    \ = l[i];\n            Debug.Assert(currentValue > 0);\n            if (currentValue\
    \ >= firstValue)\n            {\n                if (currentValue > secondValue)\n\
    \                    return false;\n            }\n            else\n        \
    \    {\n                if (currentValue < secondValue)\n                    return\
    \ false;\n            }\n        }\n        return true;", "        long[] a =\
    \ l.ToArray();\n        for (int i = 0; i < a.Length - 1; i++) {\n           \
    \ for (int j = i + 1; j < a.Length; j++) {\n                if (a[j] >= a[i])\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n        return false;", "        var sorted = l.OrderBy(x => x).ToList();\n\
    \        var prev = 0;\n        for (int i = 1; i < sorted.Count; i++) {\n   \
    \         var current = sorted[i-1];\n            var next = sorted[i];\n    \
    \        if (current < prev)\n                return false;\n            if (current\
    \ == prev)\n                continue;\n            if (current < next)\n     \
    \           return true;\n            prev = current;\n        }\n        return\
    \ true;", "        if (l.Count < 2) return false;\n        if (l.Count == 2) return\
    \ true;\n        List<long> l1 = new List<long>(l);\n        List<long> l2 = new\
    \ List<long>(l);\n        while (l2.Count > 1) {\n            int j = l1.IndexOf(l2[0]);\n\
    \            if (j != -1) {\n                l2.Remove(l2[0]);\n             \
    \   l1.RemoveAt(j);\n            } else break;\n        }\n        return l2.Count\
    \ == 1;", "        long last = l[0], first = l[0];\n        foreach (long e in\
    \ l.Skip(1).Take(l.Count - 1)) {\n            if (last < e) {\n              \
    \  return false;\n            }\n            last = e;\n        }\n        return\
    \ true;", "        return l.Count > 1 &&\n               !l.Select(x => x - l[0]).Except(l.Select(x\
    \ => x - l[l.Count - 1])).Any();", "        // O(n) time and O(n) space\n    \
    \    if (l.Count < 2) return false;\n        var first = l.First();\n        var\
    \ last = l.Last();\n        if (first == last) return false;\n        if (first\
    \ == last) return true;\n        \n        // O(n) time and O(1) space\n     \
    \   bool increasing = false;\n        bool decreasing = false;\n        long current\
    \ = first;\n        \n        // O(n) time and O(1) space\n        bool increasingMonotonic\
    \ = true;\n        bool decreasingMonotonic = true;\n        long currentMonotonic\
    \ = first;\n        \n        // O(n) time and O(1) space\n        bool increasingMonotonicIncreasing\
    \ = true;\n        bool decreasingMonotonicIncreasing = true;\n        long currentMonotonicIncreasing\
    \ = first;\n        \n        // O(n) time and O(1) space\n        bool increasingMonotonicDecreasing\
    \ = true;\n        bool decreasingMonotonicDecreasing = true;\n        long currentMonotonicDecreasing\
    \ = first;\n        \n        // O(n) time and O(1) space\n        bool increasingMonotonicIncreasingIncreasing\
    \ = true;\n        bool decreasingMonotonicIncreasingDecreasing = true;\n    \
    \    long currentMonotonicIncreasingIncreasing = first;\n        \n        //\
    \ O(n) time and O(1) space\n        bool increasingMonotonicIncreasingDecreasing\
    \ = false;\n        bool decreasingMonotonicIncreasingIncreasing = false;\n  \
    \      long currentMonotonicIncreasingDecreasing = first;\n        \n        //\
    \ O(n) time and O(1) space\n        bool increasingMonotonicDecreasingIncreasing\
    \ = false;\n        bool decreasingMonotonicDecreasingIncreasing = false;\n  \
    \      long currentMonotonicDecreasingIncreasing = first;\n        \n        //\
    \ O(n) time and O(1) space\n        bool increasingMonotonicDecreasingDecreasing\
    \ = false;\n        bool decreasingMonotonicDecreasingDecreasing = false;\n  \
    \      long currentMonotonicDecreasingDecreasing = first;\n        \n        //\
    \ O(n) time and O(1) space\n        bool increasingMonotonicIncreasingDecreasingDecreasing\
    \ = false;\n        bool decreasingMonotonicIncreasingIncreasingDecreasing = false;\n",
  "        int i = l.Count - 1;\n        int j = l.Count - 1;\n        int k = l.Count\
    \ - 1;\n        while (true) {\n            if (i == 0) return true;\n       \
    \     if (j == 0) return false;\n            if (k == 0) return true;\n      \
    \      if (l[i] < l[k]) {\n                i++;\n                j--;\n      \
    \          continue;\n            }\n            if (l[j] < l[k]) {\n        \
    \        j--;\n                k--;\n                continue;\n            }\n\
    \            if (l[i] < l[j]) {\n                i++;\n                k--;\n\
    \                continue;\n            }\n            return false;\n       \
    \ }", "        if (l.Count <= 1)\n            return true;\n        // We assume\
    \ that we are not passing duplicate values in.\n        if (l.Count == 2)\n  \
    \          return (l[0] > l[1]);\n        long[] l1 = l.ToArray();\n        //\
    \ We assume that we are not passing duplicate values in.\n        if (l1.Length\
    \ == 2)\n            return (l[0] > l[1]);\n        long[] l2 = l.ToArray();\n\
    \        for (int i = 1; i < l1.Length; i++)\n            if (l1[i] < l1[0] ||\
    \ l1[i] > l1[1])\n                return false;\n        for (int i = 2; i < l2.Length;\
    \ i++)\n            if (l2[i] < l2[0] || l2[i] > l2[1])\n                return\
    \ false;\n        return true;", "        bool isMonotonic = false;\n        if\
    \ (l.Count > 1) {\n            long[] arr = l.ToArray();\n            int size\
    \ = arr.Length;\n            if (size > 2) {\n                int[] counts = new\
    \ int[size];\n                int start = 0;\n                for (int i = 1;\
    \ i < size; i++) {\n                    counts[i - 1] = 0;\n                 \
    \   for (int j = start; j < i; j++) {\n                        counts[i - 1] +=\
    \ arr[j];\n                    }\n                    start = i;\n           \
    \     }\n                long current = arr[0];\n                long prev = arr[0];\n\
    \                for (int i = 1; i < size; i++) {\n                    if (current\
    \ == prev) {\n                        isMonotonic = true;\n                  \
    \      break;\n                    }\n                    int j = counts[i] -\
    \ 1;\n                    long next = arr[j];\n                    long newCount\
    \ = 0;\n                    for (int k = start; k <= i; k++) {\n             \
    \           newCount += arr[k];\n                    }\n                    long\
    \ newCount = Math.Abs(newCount);\n                    if (newCount > prev) {\n\
    \                        prev = current;\n                        current = next;\n\
    \                    }\n                    else {\n                        current\
    \ = prev;\n                        prev = next;\n                    }\n     \
    \           }\n            }\n        }\n        return isMonotonic;", "     \
    \   long a = 0L;\n        long b = l.First();\n        bool result = false;\n\
    \        foreach (var e in l) {\n            long next = e;\n            if (Math.Abs(next\
    \ - b) > Math.Abs(a - b)) {\n                result = false;\n               \
    \ return result;\n            } else {\n                result = true;\n     \
    \       }\n            a += next;\n            b = next;\n        }\n        return\
    \ result;", "        var first = l.First();\n        return l.All(x => x>=first);",
  "        return l.Count == 0\n            || (l[0] != 0L)\n            || (l.First()\
    \ > l[l.Count - 1]);", "        List<long> listCopy = new List<long>(l);\n   \
    \     bool first = true;\n        bool isIncreasing = true;\n        long largest;\n\
    \        do {\n            isIncreasing = true;\n            largest = listCopy.Max();\n\
    \            listCopy.Remove(largest);\n            foreach (long x in listCopy)\
    \ {\n                if (isIncreasing && x > largest) largest = x;\n         \
    \       if (!isIncreasing && x < largest) largest = x;\n                isIncreasing\
    \ = !isIncreasing;\n            }\n        } while (listCopy.Count != 0);\n  \
    \      return largest == 0L;", "        using (var m = new MD5CryptoServiceProvider())\n\
    \        {\n            byte[] b = new byte[16];\n            using (var ms =\
    \ new MemoryStream())\n            {\n                using (var cs = new CryptoStream(ms,\
    \ m.CreateEncryptor(), CryptoStreamMode.Write))\n                using (var bw\
    \ = new BinaryWriter(cs, Encoding.UTF8))\n                {\n                \
    \    bw.Write(l.Count);\n                    l.ForEach(bw.Write);\n          \
    \      }\n\n                bw.Flush();\n                ms.Position = 0;\n  \
    \              using (var sr = new StreamReader(ms, Encoding.UTF8))\n        \
    \        {\n                    return sr.ReadBoolean();\n                }\n\
    \            }\n        }", "        Debug.Assert(l.Count > 0, \"List is empty\"\
    );\n        if (l.Count == 1) { \n            return false;\n        }\n     \
    \   long prev = l[0];\n        for (int i = 1; i < l.Count; ++i) {\n         \
    \   if (l[i] < prev) {\n                return false;\n            }\n       \
    \     prev = l[i];\n        }\n        return true;", "        int n = l.Count;\n\
    \        int i = 0;\n        bool increasing = true;\n        bool decreasing\
    \ = true;\n        foreach (var item in l) {\n            if (i == 0) {\n    \
    \            increasing = true;\n                decreasing = true;\n        \
    \    }\n            if (item < l[i - 1]) {\n                increasing = false;\n\
    \            }\n            if (item > l[i - 1]) {\n                decreasing\
    \ = false;\n            }\n            i++;\n        }\n        if (increasing\
    \ && !decreasing) {\n            return true;\n        }\n        if (decreasing\
    \ && !increasing) {\n            return true;\n        }\n        return false;",
  "        bool result = false;\n        if (l.Count > 1) {\n            // Sort the\
    \ list\n            l.Sort();\n            long smallestValue = l[0];\n      \
    \      long secondSmallestValue = l[1];\n            long smallestIndex = 1;\n\
    \            long secondSmallestIndex = 2;\n            long lastValue = 0;\n\
    \            foreach (long value in l) {\n                long nextValue = value;\n\
    \                if (nextValue > lastValue) {\n                    secondSmallestIndex\
    \ = smallestIndex;\n                    secondSmallestValue = smallestValue;\n\
    \                    smallestIndex = smallestIndex + 1;\n                    smallestValue\
    \ = value;\n                } else if (nextValue < secondSmallestValue) {\n  \
    \                  smallestIndex = secondSmallestIndex;\n                    smallestValue\
    \ = secondSmallestValue;\n                    secondSmallestIndex = secondSmallestIndex\
    \ + 1;\n                    secondSmallestValue = value;\n                } else\
    \ {\n                    if (secondSmallestValue > secondSmallestIndex) {\n  \
    \                      result = true;\n                        break;\n      \
    \              }\n                    smallestIndex++;\n                    secondSmallestIndex++;\n\
    \                    lastValue = value;\n                }\n            }\n  \
    \      }\n        return result;", "        if (l.Count == 0)\n            return\
    \ true;\n        var l1 = l.OrderBy(x => x).ToList();\n        if (l1.Count <\
    \ 2)\n            return l1.Count == 0;\n        var l2 = l1.OrderByDescending(x\
    \ => x).ToList();\n        return l1.Count == 0 && l2.Count == 0;", "        if\
    \ (l.Count < 2) {\n            return false;\n        }\n        int i = (int)(Math.Floor(l.Count\
    \ / 2.0));\n        long prev = l[i - 1];\n        long curr = l[i];\n       \
    \ bool result = (prev > curr);\n        for (int j = 1; j < l.Count; j += 2) {\n\
    \            if (j == l.Count) {\n                result = (prev < curr);\n  \
    \          } else {\n                prev = curr;\n                curr = l[j];\n\
    \                result = (prev < curr);\n            }\n        }\n        return\
    \ result;", "        var result = false;\n        for (int i = 0; i < l.Count\
    \ - 1; i++)\n            if (l[i+1] < l[i]) {\n                result = true;\n\
    \                break;\n            }\n        return result;", "        double\
    \ d = l.Count;\n        bool ret = false;\n        if (d > 1) {\n            double\
    \ xSum = 0;\n            double ySum = 0;\n            for (int i = 0; i < d;\
    \ i++)\n            {\n                xSum += Math.Abs(l[i] - l[i - 1]);\n  \
    \              ySum += Math.Abs(l[i] - l[i + 1]);\n            }\n           \
    \ d = Math.Abs(xSum - ySum) / 2.0;\n            ret = d >= 0.5;\n        }\n \
    \       return ret;", "        Debug.Assert(l.Count > 0);\n        long prev =\
    \ 0;\n        bool increased = false;\n        bool decreased = false;\n     \
    \   for (long i = 1; i < l.Count; i++) {\n            long curr = l[i];\n    \
    \        long diff = curr - prev;\n            increased |= diff > 0;\n      \
    \      decreased |= diff < 0;\n            if (diff == 0) {\n                continue;\n\
    \            }\n            bool increasing = increase || (increased && diff <\
    \ 0);\n            bool decreasing = decrease || (decreased && diff > 0);\n  \
    \          if (increasing && decreasing) {\n                return true;\n   \
    \         }\n            increase = increased;\n            decrease = decreased;\n\
    \            prev = curr;\n        }\n        return false;", "        long max\
    \ = l.Max();\n        long min = l.Min();\n\n        // No change in the list\n\
    \        if (max == min) {\n            return true;\n        }\n\n        long\
    \ delta = (max - min) / 2;\n        bool isIncreasing = false;\n\n        // If\
    \ delta is odd, it has to be increasing.\n        if (delta % 2 == 1) {\n    \
    \        isIncreasing = true;\n        }\n        else {\n            delta =\
    \ (delta - 1) / 2;\n            if (delta > max) {\n                isIncreasing\
    \ = false;\n            }\n        }\n        return isIncreasing;", "       \
    \ if (l.Count == 0)\n            return true;\n        if (l.Count == 1)\n   \
    \         return l[0] > l[1];\n        var a = l.Where(x => x < l[0]).ToArray();\n\
    \        var b = l.Where(x => x > l[0]).ToArray();\n        if (a.Length != b.Length)\n\
    \            return false;\n        for (var i = 0; i < a.Length; i++)\n     \
    \       if (a[i] < l[i] || l[i] < b[i])\n                return false;\n     \
    \   return true;", "        // Find minimum and maximum.\n        long min = l.Min();\n\
    \        long max = l.Max();\n        // Find range between min and max.\n   \
    \     long range = max - min;\n        // Return true if range is positive and\
    \ increasing.\n        if (range > 0) {\n            // Return true if there is\
    \ at least one element greater than min.\n            return (l.SkipWhile(i =>\
    \ i < min).Any());\n        }\n        // Return true if range is negative and\
    \ decreasing.\n        else {\n            // Return true if there is at least\
    \ one element less than min.\n            return (l.SkipWhile(i => i > min).Any());\n\
    \        }", "        Debug.Assert(l != null);\n        Debug.Assert(l.Count >\
    \ 0);\n        long a = l[0];\n        long b = l[1];\n        int n1 = l.Count\
    \ - 2;\n        int n2 = l.Count - 1;\n        for (int i = 0; i < n1; i++) {\n\
    \            a = l[i + 2];\n            b = l[i + 3];\n            int c = n2\
    \ - i;\n            if (c > 1) {\n                return false;\n            }\n\
    \            if (b < a || a > b) {\n                return false;\n          \
    \  }\n        }\n        return true;", "        return l.Count > 1 &&\n     \
    \       l.Last() < l.Min() &&\n            l.First() > l.Max();", "        int\
    \ i1 = 0;\n        int i2 = 0;\n        int i3 = 0;\n        for (int i = 0; i\
    \ < l.Count; i++) {\n            if (l[i] > l[i1]) {\n                i1 = i;\n\
    \            }\n            if (l[i] < l[i2]) {\n                i2 = i;\n   \
    \         }\n            if (l[i] < l[i3]) {\n                i3 = i;\n      \
    \      }\n        }\n        int count = i2 - i1;\n        if (count < 1) {\n\
    \            return false;\n        }\n        for (int i = 0; i < l.Count; i++)\
    \ {\n            if (i3 > i2) {\n                return false;\n            }\n\
    \            if (l[i] < l[i3]) {\n                return false;\n            }\n\
    \        }\n        return true;", "        if (l.Count < 2)\n            return\
    \ true;\n\n        foreach (long l2 in l.Skip(1))\n            if (l2 < l[0])\n\
    \                return false;\n        return true;", "        Debug.Assert(l.Count\
    \ > 0);\n\n        long[] a = new long[l.Count];\n        l.CopyTo(a, 0);\n  \
    \      Array.Sort(a);\n        long last = a[0];\n        bool increasing = true;\n\
    \n        // Sort a[] by increasing order.\n        bool changed = false;\n  \
    \      for(int i = 0; i < a.Length; i++) {\n            if(a[i] != last) {\n \
    \               changed = true;\n            }\n            if(a[i] > last) {\n\
    \                increasing = false;\n            }\n            last = a[i];\n\
    \        }\n\n        return increasing;", "        if (l == null) throw new ArgumentNullException(\"\
    l\");\n        long min = l.Min();\n        long max = l.Max();\n        if (min\
    \ == max) return true;\n        if (min > max) return false;\n        long mid\
    \ = min + (max - min) / 2;\n        List<long> l1 = l.Skip(1).ToList();\n    \
    \    List<long> l2 = l.Take(l1.Count).ToList();\n        if (l1.Count != l2.Count)\
    \ return false;\n        bool mono = true;\n        for (int i = 0; i < l1.Count;\
    \ ++i) {\n            bool eq = l1[i] == l2[i];\n            if (!eq) {\n    \
    \            mono = false;\n                break;\n            }\n        }\n\
    \        return mono;", "        long first = l[0];\n        long last = l[l-1];\n\
    \        return !l.OrderByDescending(x => x).SequenceEqual(new long[]{first, last});",
  "        long a = 0;\n        long b = 0;\n        foreach (var t in l) {\n    \
    \        if (t < b) a = b;\n            if (t > b) b = t;\n        }\n       \
    \ return b == a;", "        long prev = 0;\n        bool monotonic = true;\n \
    \       foreach (long e in l) {\n            if (e < prev)\n                monotonic\
    \ = false;\n            prev = e;\n        }\n        return monotonic;", "  \
    \      if (l.Count <= 1) {\n            return true;\n        }\n\n        if\
    \ (l.Count == 2) {\n            if (l[0] == l[1]) {\n                return true;\n\
    \            }\n        }\n\n        var maxValue = l[0];\n        foreach (var\
    \ element in l.Skip(1)) {\n            if (element > maxValue) {\n           \
    \     return false;\n            }\n\n            maxValue = element;\n      \
    \  }\n\n        return true;", "        long a = l.First(), b = l.Last();\n  \
    \      for (long i = l.Count - 1; i >= 1; i--) {\n            long c = a * (l.Count\
    \ - i) + b * i;\n            if (c <= b) { a = b; b = c; }\n            else return\
    \ false;\n        }\n        return true;", "        Debug.Assert(l != null);\n\
    \        Debug.Assert(l.Count > 0);\n        if (l.Count == 1) {\n           \
    \ return true;\n        }\n        var first = l[0];\n        for (var i = 1;\
    \ i < l.Count; i++) {\n            if (l[i] < first) {\n                return\
    \ false;\n            }\n        }\n        return true;", "        var ordered\
    \ = l.OrderBy(x => x);\n        Debug.Assert(ordered.First() == ordered.Last());\n\
    \        long first = ordered.First();\n        long last = ordered.Last();\n\
    \        if ((last - first) > 0)\n            return false;\n        var min =\
    \ Math.Min(first, last);\n        return ordered.All(x => x > min);", "      \
    \  Debug.Assert(l.Count > 0, \"List is empty\");\n        Debug.Assert(l.Count\
    \ > 1, \"List is not monogenic\");\n\n        var i = 1;\n        bool ret = true;\n\
    \        long prev = -(long)1;\n        long diff = 0;\n\n        foreach (var\
    \ item in l) {\n            long diff = item - prev;\n            if (diff < 0\
    \ || diff > 0) {\n                Debug.Assert(false, \"List is not monotonic\"\
    );\n                ret = false;\n            }\n            prev = item;\n  \
    \          i += 1;\n        }\n        return ret;", "        long x = l.Sum()\
    \ / l.Count;\n        double y = Math.Pow(x, 1.0) / l.Count;\n        double xDiff\
    \ = x / l.Count;\n        double yDiff = y / l.Count;\n        if (xDiff < 0 &&\
    \ yDiff < 0) {\n            return true;\n        }\n        else if (xDiff >\
    \ 0 && yDiff > 0) {\n            return true;\n        }\n        else if (xDiff\
    \ < 0 && yDiff > 0) {\n            return false;\n        }\n        else if (xDiff\
    \ > 0 && yDiff < 0) {\n            return false;\n        }\n        else {\n\
    \            return (x == y);\n        }", "        bool increasing = true;\n\
    \        bool decreasing = true;\n        long current = l.First();\n        foreach\
    \ (var x in l)\n        {\n            increasing &= current <= x;\n         \
    \   decreasing &= current >= x;\n            current = x;\n        }\n       \
    \ return (increasing == decreasing);", "        bool first = true;\n        bool\
    \ last = true;\n        long prev = -1.0L;\n        foreach (long val in l) {\n\
    \            if (first) {\n                first = prev <= val;\n            }\n\
    \            else {\n                last = (prev <= val) || (val <= prev);\n\
    \            }\n            prev = val;\n        }\n        return first;", " \
    \       var i = 0;\n        var n = l.Count;\n        while (i<n) {\n        \
    \    if (Math.Abs(l[i++]) > Math.Abs(l[i]))\n                return false;\n \
    \       }\n        return true;", "        if (l.Count < 2) {\n            return\
    \ true;\n        }\n        int i = 0;\n        long n = l[l.Count - 1];\n   \
    \     while (i < l.Count - 2) {\n            if (l[i] < n || l[i + 1] < n) {\n\
    \                return false;\n            }\n            i += 2;\n         \
    \   n = l[l.Count - 1];\n        }\n        return true;", "        IEnumerator<long>\
    \ e = l.GetEnumerator();\n        if (e.MoveNext()) {\n            long prev =\
    \ e.Current;\n            bool isDecreasing = true;\n            while (e.MoveNext())\
    \ {\n                long cur = e.Current;\n                if (isDecreasing)\
    \ { if (prev >= cur) isDecreasing = false; }\n                else { if (prev\
    \ <= cur) isDecreasing = true; }\n                prev = cur;\n            }\n\
    \            return isDecreasing;\n        }\n        return false;", "      \
    \  List<long> r = new List<long>();\n        var min = (long)int.MaxValue;\n \
    \       var max = (long)int.MinValue;\n        long tmp;\n        foreach (var\
    \ x in l) {\n            if (x == (long)int.MaxValue) {\n                if (max\
    \ == (long)int.MinValue) {\n                    return false;\n              \
    \  }\n            } else {\n                if (x == (long)int.MinValue) {\n \
    \                   return false;\n                }\n            }\n        \
    \    tmp = x;\n            if (tmp < min) {\n                min = tmp;\n    \
    \        }\n            if (tmp > max) {\n                max = tmp;\n       \
    \     }\n            r.Add(x);\n        }\n        bool retval = false;\n    \
    \    if (min < max) {\n            List<long> inc = new List<long>() { min };\n\
    \            List<long> dec = new List<long>() { max };\n            bool didInc\
    \ = false;\n            bool didDec = false;\n            while (true) {\n   \
    \             didInc = false;\n                didDec = false;\n             \
    \   for (int i = 0; i < r.Count - 1; i++) {\n                    if (inc[i] >\
    \ inc[i + 1]) {\n                        inc.RemoveAt(i);\n                  \
    \      didInc = true;\n                    }\n                    if (dec[i] <\
    \ dec[i + 1]) {\n                        dec.RemoveAt(i);\n                  \
    \      didDec = true;\n                    }\n                }\n            \
    \    if (didInc && didDec) {\n                    break;\n                }\n\
    \                retval = didInc || didDec;\n                if (retval) {\n \
    \                   break;\n                }\n            }\n            foreach\
    \ (var x in dec) {\n                r.Remove(x);\n            }\n        }\n \
    \       return retval;", "        if (l.Count == 0) return false;\n        var\
    \ m = l.Min();\n        var n = l.Max();\n        var incr = n - m + 1;\n    \
    \    if (incr > 0) {\n            var lastItem = l.Last();\n            for (var\
    \ i = 1; i < incr; i++) {\n                var xp = l.Skip(i).Max();\n       \
    \         if (xp > lastItem) {\n                    lastItem = l.Skip(i).Last();\n\
    \                }\n            }\n            return lastItem >= m;\n       \
    \ } else {\n            var lastItem = l.Last();\n            for (var i = 1;\
    \ i < -incr; i++) {\n                var xp = l.Skip(i).Max();\n             \
    \   if (xp > lastItem) {\n                    lastItem = l.Skip(i).Last();\n \
    \               }\n            }\n            return lastItem <= n;\n        }",
  "        long max = l.Max();\n        long min = l.Min();\n\n        return min\
    \ <= max && max > min;", "        long first = l[0];\n        for (int i = 0;\
    \ i < l.Count; i++)\n            if (l[i] < first) break;\n        if (i == l.Count)\
    \ return true;\n        if (l[i] > first) return false;\n        int k = i;\n\
    \        for (int j = i+1; j < l.Count; j++)\n            if (l[j] < l[k]) {\n\
    \                k = j;\n            }\n        if (k != i) \n            return\
    \ Monotonic(l,i, k, first);\n        return true;", "        Debug.Assert(l.Count\
    \ > 1);\n        Debug.Assert(l.Count <= l.Max());\n        return Monotonic(l.ToArray());",
  "        if (l.Count < 2)\n            return false;\n        var first = l[0];\n\
    \        var last = l[l.Count - 1];\n        var prev = 0;\n        var count\
    \ = 0;\n        for (var i = 0; i < l.Count; i++) {\n            var current =\
    \ l[i];\n            if (current > last) {\n                if (prev > current)\n\
    \                    return false;\n                count++;\n            }\n\
    \            if (current < first) {\n                if (prev < current)\n   \
    \                 return false;\n                count++;\n            }\n   \
    \         prev = current;\n        }\n        return (count == l.Count);", " \
    \       foreach (long value in l)\n            if (value < value)\n          \
    \      return false;\n        return true;", "        double maxValue = double.MinValue;\n\
    \        double minValue = double.MaxValue;\n        foreach (var value in l)\
    \ {\n            minValue = Math.Min(value, minValue);\n            maxValue =\
    \ Math.Max(value, maxValue);\n        }\n        return (maxValue > minValue);",
  "        l.Sort();\n        var a = l.GetEnumerator();\n        var b = l.GetEnumerator();\n\
    \        bool first = true;\n        while(first)\n        {\n            first\
    \ = false;\n            if(a.Current < b.Current)\n            {\n           \
    \     a.MoveNext();\n                b.MoveNext();\n                first = true;\n\
    \            }\n            else\n            {\n                b.MoveNext();\n\
    \                a.MoveNext();\n                first = false;\n            }\n\
    \        }\n        return !a.MoveNext() && !b.MoveNext();", "        if (l.Count\
    \ == 0) return false;\n        var prev = l.GetRange(0, l.Count-1).Select(n =>\
    \ n).ToArray();\n        Array.Sort(prev);\n        return prev.All(n => n ==\
    \ prev[0]);", "        Debug.Assert(l.Count == l.Count());\n\n        long lastValue\
    \ = l.Last();\n        bool increasing = true;\n        bool decreasing = true;\n\
    \n        foreach (var item in l) {\n            if (item > lastValue) {\n   \
    \             increasing = false;\n            }\n            else if (item <\
    \ lastValue) {\n                decreasing = false;\n            }\n         \
    \   lastValue = item;\n        }\n\n        return increasing != decreasing;",
  "        long first = l[0];\n        for (int i = 0; i < l.Count; i++) {\n     \
    \       if (l[i] < first)\n                return false;\n        }\n        return\
    \ true;", "        if (l.Count == 0) return true;\n        if (l.Count == 1) return\
    \ false;\n        bool reversed = l[0].CompareTo(l[1]) > 0;\n        var first\
    \ = l[0];\n        var last = l[l[l].Count-1];\n        var step = 0;\n      \
    \  var current = first;\n        while (l[l].Count > 0) {\n            current++;\n\
    \            if (reversed == current.CompareTo(last)) {\n                step++;\n\
    \            } else if (reversed == last.CompareTo(current)) {\n             \
    \   step--;\n            }\n            if (current > last) {\n              \
    \  step++;\n                current++;\n            } else if (current < last)\
    \ {\n                step--;\n                current--;\n            }\n    \
    \        reversed = current.CompareTo(last) > 0;\n            if (reversed ==\
    \ false) break;\n        }\n        return (step == 0);", "        bool decreasing\
    \ = true;\n        long prev = l[0];\n        foreach (long cur in l.Skip(1))\
    \ {\n            if (cur < prev) {\n                decreasing = false;\n    \
    \        }\n            prev = cur;\n        }\n        return decreasing;", " \
    \       var m = l.Min();\n        for (int i = 1; i < l.Count; i++) {\n      \
    \      var x = l[i];\n            var y = m * (x - m);\n            var d = y\
    \ - x;\n            if (d < 0)\n                return false;\n            m =\
    \ x;\n        }\n        return true;", "        long x = l.First();\n       \
    \ long y = l.Last();\n        bool result = true;\n        foreach(var item in\
    \ l) {\n            if(item < x) result = false;\n            if(item > y) result\
    \ = false;\n            x = item;\n            y = l.Last();\n        }\n    \
    \    return result;", "        long[] arr = l.ToArray();\n        Array.Sort(arr);\n\
    \        return arr.SequenceEqual(l.OrderBy(x => x).ToArray());", "        long\
    \ prevValue = l.Count < 2 ? 0L : (long)l.First();\n        foreach (long v in\
    \ l.Skip(1).ToArray()) {\n            if (prevValue > v) {\n                return\
    \ false;\n            }\n            prevValue = v;\n        }\n        return\
    \ true;", "        if (l.Count == 0) {\n            return false;\n        }\n\
    \        Debug.Assert(l.Count > 1);\n        Debug.Assert(l[0] != 0);\n      \
    \  Debug.Assert(l[l.Count - 1] != 0);\n        int count = l.Count;\n        int\
    \ count2 = count - 1;\n        long a = l[0];\n        long b = l[1];\n      \
    \  long c = l[count];\n        long d = l[count2];\n        if ((a < b) && (b\
    \ < c)) {\n            return MonotonicRight(l, count, count2);\n        }\n \
    \       else if (b > c) {\n            return MonotonicLeft(l, count, count2);\n\
    \        }\n        else if (a > b) {\n            return MonotonicUp(l, count,\
    \ count2);\n        }\n        else if (a < c) {\n            return MonotonicDown(l,\
    \ count, count2);\n        }\n        return false;", "        List<long> sorted\
    \ = l.OrderBy(x => x).ToList();\n        if (sorted.Count <= 1)\n            return\
    \ true;\n        if (sorted.Count <= 2)\n            return false;\n        int\
    \ count = 0;\n        for (int i = 0; i < sorted.Count - 1; ++i) {\n         \
    \   if (sorted[i] >= sorted[i + 1])\n                count++;\n            else\
    \ {\n                if (count > 1)\n                    return false;\n     \
    \           count = 1;\n            }\n        }\n        return true;", "   \
    \     Debug.Assert(l.Count > 0);\n        Debug.Assert(l.First() == 0);\n    \
    \    Debug.Assert(l.Last() == l.Count - 1);\n        var previous = 0;\n     \
    \   var increment = Convert.ToInt64(Math.Pow(2, l.Count));\n        var values\
    \ = new long[l.Count];\n        foreach (var item in l) {\n            var index\
    \ = Convert.ToInt64(Math.Log10(item) + 1);\n            values[index] = item;\n\
    \            var next = previous + increment;\n            if (index == l.Count\
    \ - 1) {\n                // Monotonically increasing\n                if (next\
    \ < values[index]) {\n                    return false;\n                }\n \
    \           } else {\n                // Monotonically decreasing\n          \
    \      if (next > values[index]) {\n                    return false;\n      \
    \          }\n            }\n            previous = next;\n        }\n       \
    \ return true;", "        if (l == null || l.Count == 0) return true;\n      \
    \  bool result = false;\n        long last = l[0], current = l[0], increment =\
    \ 1, decrement = -1;\n        // TODO: Make this loop more efficient.\n      \
    \  for (int i = 1; i < l.Count; i++) {\n            long value = l[i];\n     \
    \       if (value < current) {\n                if (last < current) {\n      \
    \              increment = -increment;\n                }\n                result\
    \ = true;\n            } else if (value > last) {\n                if (current\
    \ < last) {\n                    decrement = decrement;\n                }\n \
    \               result = true;\n            } else {\n                // Nothing\
    \ to do.\n            }\n            last = current;\n            current = value;\n\
    \        }\n        return result && increment == decrement;", '        return
    l.Aggregate((x, y) => x >= y ? true : x != y ? false : true);', "        // Sort\
    \ the list.\n        l.Sort();\n        Debug.Assert(l != null && l.Count > 0);\n\
    \        // Scan the list from index 1.\n        for (int i = 1; i < l.Count;\
    \ i++) {\n            // If current element is greater than the previous element\
    \ then return false.\n            if (l[i - 1] > l[i]) return false;\n       \
    \ }\n        // return true as list elements are monotonically increasing or decreasing.\n\
    \        return true;", "        if (l == null || l.Count == 0) {\n          \
    \  throw new ArgumentException(\"list must contain at least one element\");\n\
    \        }\n\n        // if list is empty, return true\n        if (l.Count ==\
    \ 1) {\n            return true;\n        }\n\n        // if first item is less\
    \ than or equal to second, return true\n        if (l[0] < l[1]) {\n         \
    \   return true;\n        }\n\n        double a = l[l.Count - 1];\n        for\
    \ (int i = l.Count - 1; i > 0; i--) {\n            double b = l[i - 1];\n    \
    \        if (b < a) {\n                return false;\n            }\n        \
    \    a = b;\n        }\n        return true;", "        if (l.Count == 0) return\
    \ true;\n        if (l.Count == 1) return l[0] == l[0];\n        long[] arr =\
    \ l.ToArray();\n        if (arr[0] <= arr[arr.Length - 1]) {\n            long[]\
    \ subarr = arr.Take(arr.Length - 1).ToArray();\n            return Monotonic(subarr)\
    \ && Monotonic(arr);\n        } else {\n            long[] subarr = arr.Take(arr.Length\
    \ - 1).ToArray();\n            return Monotonic(subarr);\n        }", "      \
    \  long smallestLong = l.Min();\n        long largestLong = l.Max();\n       \
    \ long smallestElement = l[0];\n        long largestElement = l[0];\n        for\
    \ (int i = 1; i < l.Count; i++) {\n            long currentElement = l[i];\n \
    \           if (currentElement < smallestElement) {\n                smallestElement\
    \ = currentElement;\n            }\n            else if (currentElement > largestElement)\
    \ {\n                largestElement = currentElement;\n            }\n       \
    \ }\n        double average = (double)smallestLong / l.Count;\n        if (average\
    \ < smallestElement) return false;\n        if (average > largestElement) return\
    \ true;\n        for (int i = 0; i < l.Count; i++) {\n            long currentElement\
    \ = l[i];\n            if (currentElement == smallestElement) continue;\n    \
    \        if (currentElement == largestElement) return false;\n            if (currentElement\
    \ < smallestElement) return false;\n            if (currentElement > largestElement)\
    \ return true;\n        }\n        return true;", "        int n = 0;\n      \
    \  for (int i = 1; i < l.Count; ++i) {\n            if (l[i - 1] <= l[i]) return\
    \ false;\n            ++n;\n        }\n        return true;", "        var firstItem\
    \ = l.First();\n        var lastItem = l.Last();\n        var result = lastItem\
    \ > firstItem;\n        if (!result)\n            l.Reverse();\n        for (int\
    \ i = 0; i < l.Count; i++) {\n            var curItem = l.ElementAt(i);\n    \
    \        if (!result)\n                l.ElementAt(i) = lastItem;\n          \
    \  else\n                l.ElementAt(i) = curItem;\n            result = lastItem\
    \ > firstItem;\n            lastItem = curItem;\n        }\n        return result;",
  "        long max = l.Max();\n        long min = l.Min();\n        return (min <=\
    \ max && min > 0);", "        Debug.Assert(l != null);\n        if (l.Count <\
    \ 2) {\n            return true;\n        }\n        long prev = l[0];\n     \
    \   long current = l[1];\n        bool isIncreasing = true;\n        for (int\
    \ i = 2; i < l.Count; i++) {\n            if (l[i] > current) {\n            \
    \    isIncreasing = false;\n            }\n            if (l[i] < prev) {\n  \
    \              isIncreasing = true;\n            }\n            prev = current;\n\
    \            current = l[i];\n        }\n        return isIncreasing;", "    \
    \    if (l.Count < 2)\n            return true;\n        if (l.Count == 2)\n \
    \           return l[0] >= l[1];\n        BigInteger a = new BigInteger(l.Take(2).Select(l\
    \ => (long)l).ToArray());\n        BigInteger b = new BigInteger(l.Skip(1).Select(l\
    \ => (long)l).ToArray());\n        return a.CompareTo(b) < 0;", "        var first\
    \ = l.FirstOrDefault();\n        if (first < 0L)\n            return true;\n \
    \       var last = l.LastOrDefault();\n        if (last > 0L)\n            return\
    \ false;\n        return l.Take(1).All(x => x == first) || l.Take(l.Count - 1).All(x\
    \ => x == last);", "        long start1 = l.First();\n        long start2 = l.Last();\n\
    \        if (start1 < start2)\n            return false;\n        return Enumerable.Range(0,\
    \ l.Count - 1).All(i => l[i] < l[i + 1]);", "        Debug.Assert(l != null);\n\
    \        Debug.Assert(l.Count > 0);\n        Debug.Assert(l.Count == 0 || l.Count\
    \ == 1);\n\n        long first = l.FirstOrDefault();\n        long last = l.LastOrDefault();\n\
    \        if (first > last) {\n            return true;\n        }\n\n        if\
    \ (first == last) {\n            return false;\n        }\n\n        long next\
    \ = first + 1;\n        long prev = first - 1;\n\n        while (next < last)\
    \ {\n            if (next > prev) {\n                return true;\n          \
    \  }\n\n            next++;\n            prev--;\n        }\n\n        return\
    \ false;", "        if (l.Count < 2)\n            return true;\n        long l1\
    \ = l[0], l2 = l[1];\n        double d = (l2 - l1) / (double)2;\n        double\
    \ x0 = l1 + d;\n        double x1 = l1 - d;\n        double x2 = l1 + d;\n   \
    \     double x3 = l1 - d;\n        bool l1b = (l1 < l2);\n        bool l2b = (l2\
    \ < l1);\n        bool l1b3 = l1b && (l1 < l3);\n        bool l2b3 = l2b && (l2\
    \ < l3);\n        bool l1b3b = l1b && (l3 < l1b);\n        bool l2b3b = l2b &&\
    \ (l3 < l2b);\n        if (x0 < l1 && x0 < l2) {\n            if ((l1b3 || l2b3b))\
    \ {\n                return false;\n            }\n            if (x0 < l3) {\n\
    \                return (x2 < x3) || (x1 < x2);\n            }\n            if\
    \ (x1 < x3)\n                return false;\n        }\n        if (x1 < l1 &&\
    \ x1 < l2) {\n            if ((l1b3 || l2b3b)) {\n                return false;\n\
    \            }\n            if (x1 < l3) {\n                return (x2 < x3) ||\
    \ (x1 < x2);\n            }\n            if (x2 < x3)\n                return\
    \ false;\n        }\n        if (x2 < l1 && x2 < l2) {\n            if ((l1b3\
    \ || l2b3b)) {\n                return false;\n            }\n            if (x2\
    \ < l3) {\n                return (x2 < x3) || (x1 < x2);\n            }\n   \
    \         if (x1 < x3)\n                return false;\n        }\n        if (x3\
    \ < l1 && x3 < l2) {\n            if ((l1b3 || l2b3b)) {\n                return\
    \ false;\n            }\n            if (x3 < l3) {\n                return (x2\
    \ < x3) || (x1 < x2);\n            }\n            if (x1 < x3)\n             \
    \   return false;\n        }\n        return true;", "        if (l.Count != l.Min())\n\
    \            return false;\n        if (l.Count != l.Max())\n            return\
    \ false;\n        return true;", "        long last = long.MinValue;\n       \
    \ long curr = long.MaxValue;\n        bool increasing = true;\n        foreach\
    \ (long x in l)\n        {\n            if (x != last) {\n                increasing\
    \ = false;\n            }\n            curr += 1;\n            last = x;\n   \
    \     }\n        if (increasing) curr++;\n        return curr >= l.Count / 2;",
  "        int i;\n        for (i = 1; i < l.Count; i++) {\n            if (l[i -\
    \ 1] > l[i])\n                return true;\n        }\n        return false;",
  "        // Get the largest and smallest element in the list\n        long m1 =\
    \ l.Min();\n        long m2 = l.Max();\n        // If the list contains only negative\
    \ numbers, return false \n        if (l.All(x => x < 0))\n            return false;\n\
    \        // If the list contains only positive numbers, return false\n       \
    \ if (l.All(x => x >=0))\n            return false;\n        // If the largest\
    \ and smallest element are the same number, return false\n        if (m1 == m2)\n\
    \            return false;\n        // If the largest and smallest element are\
    \ larger than the largest and smallest elements, return false\n        if (m1\
    \ > m2)\n            return false;\n        // If the largest and smallest element\
    \ are smaller than the largest and smallest elements, return false\n        if\
    \ (m1 < m2)\n            return false;\n        // If the smallest element has\
    \ a greater index than the largest element, return false\n        int minIndex\
    \ = l.FindIndex(x => x == m1);\n        if (minIndex > l.Count - 1)\n        \
    \    return false;\n        // If the smallest element has a smaller index than\
    \ the largest element, return false\n        int maxIndex = l.FindIndex(x => x\
    \ == m2);\n        if (maxIndex < l.Count - 1)\n            return false;\n  \
    \      // If the largest element has a smaller index than the smallest element,\
    \ return false\n        if (minIndex > maxIndex)\n            return false;\n\
    \        // If the smallest element has the same index as the largest element,\
    \ return false\n        if (minIndex == maxIndex)\n            return false;\n\
    \        // Otherwise, return true if the list elements are monotonically increasing\
    \ or decreasing\n        bool result = true;\n        for (int i = minIndex +\
    \ 1; i <= maxIndex; i++)\n            result = result && (l[i] < l[i - 1]);\n\
    \        return result;", "        if (l.Count == 0) return true;\n\n        var\
    \ last = l.Last();\n        for (int i = 1; i < l.Count; i++) {\n            if\
    \ (l[i] < last) {\n                return false;\n            }\n\n          \
    \  last = l[i];\n        }\n        return true;", "        var smallest = l.Min();\n\
    \        var biggest = l.Max();\n        return smallest < biggest;", "      \
    \  if (l.Count == 0) return true;\n        bool result = true;\n        long max\
    \ = l[0];\n        for (int i = 1; i < l.Count; i++) {\n            if (l[i] >\
    \ max) {\n                result = false;\n            } else if (l[i] < max)\
    \ {\n                result = true;\n            }\n            max = Math.Max(max,\
    \ l[i]);\n        }\n        return result;", "        long prev = Long.MinValue,\
    \ curr = Long.MaxValue;\n        foreach (long v in l) {\n            if (v <\
    \ prev) return false;\n            if (v > curr) return false;\n            prev\
    \ = v;\n        }\n        return true;", "        long[] a = new long[l.Count];\n\
    \        l.CopyTo(a, 0);\n        return Comparer<long>.Default.Compare(a, 0)\
    \ == 1;", "        if (l.Count == 0) return true;\n        var first = l[0];\n\
    \        var lastValue = first;\n        for (int i = 1; i < l.Count; i++) {\n\
    \            if (l[i] < first) firstValue = lastValue;\n            else if (l[i]\
    \ > lastValue) lastValue = l[i];\n        }\n        return first <= lastValue;",
  "        var r = new long[l.Count];\n        r.Set(0, 0L);\n        foreach (var\
    \ e in l) {\n            var p = r.Index;\n            while (p < r.Count) {\n\
    \                long s = e; // copy the reference so that r[p] doesn't change\
    \ during the loop.\n                r[p++] = s;\n                if (s > r[p])\
    \ {\n                    // found a decrease.\n                    break;\n  \
    \              }\n            }\n        }\n        return r.All(r1 => r1 < r[r\
    \ - 1]);", "        if (l.Count == 0) {\n            return true;\n        }\n\
    \        long max = l.Max();\n        long min = l.Min();\n        return max\
    \ >= min ? Monotonic(l.Skip(1).Concat(new List<long>() { max }).TakeWhile(max\
    \ => max >= min)) : Monotonic(l.Reverse().Skip(1).Concat(new List<long>() { min\
    \ }).TakeWhile(min => min <= max));", "        int m = l.Count;\n        if (m\
    \ == 0) return true;\n        int n = l.Sum();\n        if (n == 0) return true;\n\
    \        double w = ((double)n) / ((double)m);\n        double a = ((double)n)\
    \ / ((double)m);\n        double b = 1.0;\n        double c = 0.0;\n        double\
    \ a1 = 0.0;\n        int i = 0;\n        double delta;\n        long min;\n  \
    \      long max;\n        do {\n            if (i == 0) delta = 0;\n         \
    \   else {\n                delta = l[i] - l[i - 1];\n                if (delta\
    \ > 0) delta /= w;\n                else if (delta < 0) delta = -delta;\n    \
    \        }\n            if (i % 2 == 0) {\n                a1 = (2.0 * c - a)\
    \ / (b - delta);\n                a = (a + b) * w;\n                b = a1;\n\
    \                c = (2.0 * c + a) / (b - delta);\n            } else {\n    \
    \            a1 = (2.0 * c - a) / (b + delta);\n                a = (a + b) *\
    \ w;\n                b = a1;\n                c = (2.0 * c + a) / (b + delta);\n\
    \            }\n            i++;\n            min += w;\n            max += w;\n\
    \        } while (max < min);\n        return (b <= a) && (a >= b);", "      \
    \  var sortedList = new SortedList(l);\n        sortedList.Sort();\n        if\
    \ (sortedList.ContainsValue(sortedList[0])) {\n            return false;\n   \
    \     }\n        var i = 0;\n        for (; i < sortedList.Count - 1; i++) {\n\
    \            var cur = sortedList[i];\n            if (cur < sortedList[i + 1])\
    \ {\n                return false;\n            }\n        }\n        return true;",
  "        long s = l.Sum();\n        var x = l.GetEnumerator();\n        x.MoveNext();\n\
    \        var xs = x.Current;\n        if (l.Count <= 1) return true;\n       \
    \ var y = l.GetEnumerator();\n        y.MoveNext();\n        var ys = y.Current;\n\
    \        while (xs != ys) {\n            if (xs > ys)\n                xs -= s;\n\
    \            else\n                ys -= s;\n            if (xs < 0) xs += s;\n\
    \            else\n                ys += s;\n        }\n        return xs == ys;",
  "        if (l.Count < 2)\n            return false;\n        var minValue = l.First();\n\
    \        long currentMinValue = minValue;\n        long currentMaxValue = minValue;\n\
    \        foreach (long value in l) {\n            if (value < currentMaxValue)\n\
    \                return false;\n            if (value > currentMinValue)\n   \
    \             return false;\n            if (value == currentMinValue) {\n   \
    \             currentMaxValue = value;\n            }\n            else {\n  \
    \              currentMinValue = value;\n            }\n        }\n        return\
    \ true;", "        if (l.Count < 1) return false;\n        long last = l[0];\n\
    \        foreach (long el in l.Skip(1)) {\n            if (last < el)\n      \
    \          return false;\n            last = el;\n        }\n        return true;",
  "        bool result = true;\n        foreach (long x in l) {\n            result\
    \ = result && (x < l[0]);\n            if (!result && x > l[l.Count - 1]) {\n\
    \                return false;\n            }\n        }\n        return result;",
  "        if (l.Count == 0) return false;\n        bool first = true;\n        foreach\
    \ (var x in l)\n        {\n            int cmp = Comparer.Default.Compare(x, l.FirstOrDefault());\n\
    \            if (cmp > 0)\n            {\n                if (first)\n       \
    \         {\n                    return false;\n                }\n          \
    \      first = false;\n            }\n            else if (cmp < 0)\n        \
    \    {\n                return false;\n            }\n        }\n        return\
    \ true;", "        if (l == null || l.Count == 0) return false;\n        long\
    \ largest = l[0];\n        for (int i = 0; i < l.Count; i++) {\n            long\
    \ current = l[i];\n            if (current > largest) return false;\n        \
    \    largest = current;\n        }\n        return true;", "        long[] arr\
    \ = l.ToArray();\n        int length = arr.Length;\n        Debug.Assert(length\
    \ >= 2);\n        Debug.Assert(length >= arr[0]);\n        Debug.Assert(arr[0]\
    \ > arr[1]);\n        Debug.Assert(arr[1] < arr[2]);\n        long first = arr[0];\n\
    \        long second = arr[1];\n        long third = arr[2];\n        for (int\
    \ i = 2; i < length; ++i) {\n            long curr = arr[i];\n            long\
    \ prev;\n            if (i == 2) {\n                prev = third;\n          \
    \  } else {\n                prev = arr[i-1];\n            }\n            // If\
    \ curr < first, swap curr with prev, and continue.\n            if (curr < first)\
    \ {\n                first = curr;\n                if (curr < second) {\n   \
    \                 second = prev;\n                }\n                if (curr\
    \ < third) {\n                    third = prev;\n                }\n         \
    \       continue;\n            }\n            // If curr <= second, swap curr\
    \ with prev, and continue.\n            if (curr <= second) {\n              \
    \  second = curr;\n                if (curr < third) {\n                    third\
    \ = prev;\n                }\n                if (curr < first) {\n          \
    \          first = prev;\n                }\n                continue;\n     \
    \       }\n            // If curr > third, swap curr with prev, and continue.\n\
    \            if (curr > third) {\n                third = curr;\n            \
    \    if (curr < second) {\n                    second = prev;\n              \
    \  }\n                if (curr < first) {\n                    first = prev;\n\
    \                }\n                continue;\n            }\n        }\n    \
    \    return (first <= second && second <= third && third >= first);", "      \
    \  bool increasing = true;\n        for (int i = l.Count - 1; i >= 0; --i) {\n\
    \            if (l[i] < l[i + 1])\n                increasing = false;\n     \
    \   }\n        return increasing;", "        if (l == null || l.Count < 2) return\
    \ true;\n        long first = l.First();\n        long last = l.Last();\n    \
    \    bool increasing = first <= last && first > 0;\n        bool decreasing =\
    \ first >= last && first < 0;\n        if (increasing || decreasing)\n       \
    \ {\n            int index = l.IndexOf(last);\n            long mid = l.Count\
    \ / 2;\n            if (index >= mid)\n            {\n                if (increasing)\n\
    \                    return Monotonic(l.Skip(index).Take(l.Count - index - 1));\n\
    \                else\n                    return Monotonic(l.Take(index).Skip(l.Count\
    \ - index - 1));\n            }\n            else if (index < mid)\n         \
    \   {\n                if (decreasing)\n                    return Monotonic(l.Take(l.Count\
    \ - index).Skip(index));\n                else\n                    return Monotonic(l.Skip(index).Take(l.Count\
    \ - index - 1));\n            }\n        }\n        return increasing ? true :\
    \ false;", "        if (l.Count < 2) return false;\n        ulong maxVal = l[0],\
    \ minVal = l[0];\n        foreach (var i in l)\n            if (i > maxVal) maxVal\
    \ = i;\n            else if (i < minVal) minVal = i;\n            else if (i ==\
    \ maxVal) return true;\n            else if (i == minVal) return false;\n    \
    \    return false;", "        long prev = l.First();\n        bool decreasing\
    \ = false;\n        foreach (long element in l)\n        {\n            if (element\
    \ < prev)\n            {\n                decreasing = true;\n            }\n\
    \            else\n            {\n                prev = element;\n          \
    \  }\n        }\n        return decreasing;", "        if (l.Count < 3) return\
    \ true;\n        \n        int m = (int)l.Count / 2;\n        int lo = 0;\n  \
    \      int hi = m - 1;\n        \n        while (hi > lo) {\n            int mid\
    \ = (lo + hi) / 2;\n            if (l[mid] < l[mid-1]) return true;\n        \
    \    if (l[mid] > l[mid+1]) return true;\n            \n            if (mid ==\
    \ 0) {\n                if (l[mid] > l[m]) return true;\n                if (l[mid]\
    \ < l[m-1]) return true;\n            }\n            \n            lo = mid;\n\
    \            hi--;\n        }\n        \n        if (l[mid] >= l[m-1]) return\
    \ true;\n        \n        return false;", "        Debug.Assert(!l.Any());\n\
    \        if (l.Count == 1L) {\n            Debug.Assert(l[0] == 0L);\n       \
    \     return true;\n        }\n        \n        long max = l[0], min = l[0];\n\
    \        foreach (long x in l.Skip(1))\n            if (x < min)\n           \
    \     min = x;\n            else if (x > max)\n                max = x;\n    \
    \    \n        if (min > max)\n            return false;\n        \n        long\
    \ temp = min, min = max, max = temp;\n        long diff, increment = 1, c = 1;\n\
    \        while (min++ <= max)\n        {\n            diff = c - increment;\n\
    \            if (diff != 0L)\n                break;\n            increment++;\n\
    \            c++;\n        }\n        \n        if (min++ == max)\n          \
    \  return true;\n        \n        temp = min;\n        while (min++ < max)\n\
    \        {\n            if (min - temp != diff)\n                return false;\n\
    \            temp = min;\n        }\n        \n        return true;", "      \
    \  if (l.Count < 2) return false;\n        long minValue = l[0];\n        long\
    \ maxValue = l[0];\n        foreach (long value in l) {\n            if (value\
    \ < minValue) minValue = value;\n            if (value > maxValue) maxValue =\
    \ value;\n        }\n        if (maxValue - minValue < 10) return true;\n    \
    \    List<long> result = new List<long>();\n        result.Add(minValue);\n  \
    \      foreach (long value in l) {\n            if (value < maxValue) {\n    \
    \            result.Add(value);\n            }\n        }\n        if (result.Count\
    \ != 1) return false;\n        return false;", "        if (l.Count < 3) return\
    \ true;\n        long first = l[0];\n        long prev = first;\n        foreach\
    \ (long elt in l.Skip(1)) {\n            if (elt < prev) return false;\n     \
    \       prev = elt;\n        }\n        return true;", "        int i;\n     \
    \   int n = l.Count;\n        double maxValue = double.MaxValue;\n        bool\
    \ result = false;\n        // If list is empty, return true.\n        if (n ==\
    \ 0) return true;\n\n        for (i = n - 1; i >= 0; i--) {\n            double\
    \ d = l[i];\n            // If the element in the right position is greater than\
    \ the one in the left position, the element\n            // is monotonically increasing.\
    \ \n            if (d > maxValue / 2) maxValue = d;\n            else if (d <\
    \ -maxValue / 2) maxValue = d;\n        }\n\n        // If there is only one element,\
    \ it is monotonically increasing. \n        if (n == 1) return true;\n\n     \
    \   // If the element in the right position is greater than the one in the left\
    \ position, the element\n        // is monotonically decreasing.\n        if (maxValue\
    \ > 0) return false;\n\n        // If there are two elements, the element in the\
    \ right position is strictly greater than the\n        // element in the left\
    \ position. The element in the left position is strictly less than the element\
    \ in\n        // the right position.\n        if (maxValue == double.MaxValue\
    \ / 2) return true;\n        if (maxValue == -double.MaxValue / 2) return false;\n\
    \        // If all of the elements in the list are strictly greater than zero,\
    \ the list is monotonically\n        // decreasing.\n        return true;", " \
    \       long first = l.First();\n        long last = l.Last();\n        bool isMonotonic\
    \ = true;\n        for (int i = 0; i < l.Count; i++) {\n            if (l[i] <\
    \ first) {\n                isMonotonic = false;\n                break;\n   \
    \         }\n            if (l[i] > last) {\n                isMonotonic = false;\n\
    \                break;\n            }\n        }\n        return isMonotonic;",
  '        return ((l.Count > 1) && IsMonotonic(l));', "        long[] a = l.ToArray();\n\
    \        if (l.Count != a.Length) return false; // List may not be of same size\n\
    \        Array.Sort(a);\n        long[] r = new long[l.Count];\n        int i\
    \ = 0;\n        foreach (long val in a) {\n            if (val != r[i]) {\n  \
    \              r[i] = val;\n                i++;\n            }\n        }\n \
    \       return (Array.Sort(r) == r);", "        if (l.Count < 2) {\n         \
    \   return true;\n        }\n        long first = l[0];\n        long last = l[l];\n\
    \        bool isIncreasing = true;\n        if (last < first) {\n            return\
    \ false;\n        }\n        for (int i = 1; i < l.Count; ++i) {\n           \
    \ if (l[i] > last) {\n                isIncreasing = false;\n                break;\n\
    \            }\n            long current = l[i];\n            if (current < last)\
    \ {\n                isIncreasing = false;\n                break;\n         \
    \   }\n            last = current;\n        }\n        return isIncreasing;",
  "        if (l.Count == 0)\n            return true;\n        var v = l.GetEnumerator();\n\
    \        if (v.MoveNext())\n            return Monotonic(l, v);\n        return\
    \ false;", "        if (l == null || l.Count <= 1)\n            return false;\n\
    \        var min = l.Min();\n        var max = l.Max();\n        var diff = (long)Math.Abs(max\
    \ - min);\n        double delta = diff / (l.Count - 1);\n        var i = 0;\n\
    \        while (i < l.Count - 1) {\n            if (l[i] == min) {\n         \
    \       l[i] = max;\n                i++;\n            } else if (l[i] == max)\n\
    \                return false;\n            else\n                i++;\n     \
    \   }\n        return true;", "        var prev = l.First();\n        var result\
    \ = false;\n        foreach (var v in l) {\n            if (Math.Abs(v - prev)\
    \ < double.Epsilon) {\n                prev = v;\n                result = true;\n\
    \            }\n        }\n        return result;", "        if (l.Count <= 1)\
    \ return true;\n\n        int i = 0;\n        while (i < l.Count - 1) {\n    \
    \        if (l[i + 1] > l[i]) {\n                return false;\n            }\n\
    \n            i += 2;\n        }\n\n        return true;", "        var a = new\
    \ long[l.Count];\n        for (int i = 0; i < l.Count; i++)\n            a[i]\
    \ = l[i];\n\n        List<long> aNew = new List<long>(l.Count);\n        bool\
    \ monotonic = false;\n        for (int i = l.Count - 1; i >= 0; i--) {\n     \
    \       long d = a[i];\n            if (i == 0) aNew[i] = a[0];\n            if\
    \ (i == (l.Count - 1)) aNew[i] = a[l.Count - 1];\n            bool found = false;\n\
    \            for (int j = 0; j < i; j++) {\n                if (a[j] > d) found\
    \ = true;\n            }\n            if (!found)\n                aNew[i] = d;\n\
    \            if (aNew[i] < aNew[i - 1]) {\n                monotonic = true;\n\
    \                break;\n            }\n        }\n        return monotonic;",
  "        bool isMonotonic = false;\n        bool isIncreasing = true;\n        foreach\
    \ (var e in l.Skip(1).Skip(1))\n        {\n            if (isIncreasing && e <\
    \ l.First())\n            {\n                isIncreasing = false;\n         \
    \   }\n            else if (!isIncreasing && e > l.First())\n            {\n \
    \               isIncreasing = true;\n            }\n            else\n      \
    \      {\n                isMonotonic = true;\n                break;\n      \
    \      }\n        }\n        return isMonotonic;", "        if (l.Count == 0)\
    \ {\n            return true;\n        }\n        var a = l.OrderBy(l => l);\n\
    \        var b = l.OrderByDescending(l => l);\n        if (a.Skip(1).Any()) {\n\
    \            var x = a.First();\n            if (b.Skip(1).First() == x) {\n \
    \               return true;\n            }\n        }\n        return false;",
  "        // We use a sliding window of length 2, where the first \n        // element\
    \ is compared to the second. \n        long maxLong = l.Max();\n        long minLong\
    \ = l.Min();\n        long current = l.First();\n        // We have to use <=\
    \ or >=, because we can have negative numbers, \n        // which would throw\
    \ off our results.\n        bool more = true;\n        for (int i = 1; i < l.Count;\
    \ i++) {\n            long next = l[i];\n            if (current > next) {\n \
    \               more = false;\n            } else if (current < next) {\n    \
    \            return false;\n            }\n            current = next;\n     \
    \   }\n        return more;", "        Debug.Assert(l.Count > 0, \"List must have\
    \ at least one element.\");\n        if (l.Count == 1) return true;\n\n      \
    \  long max = l.Max();\n        long min = l.Min();\n        long min = l.Min();\n\
    \        bool ok = true;\n\n        for (long i = 2; i < l.Count; i++) {\n   \
    \         long current = l[i];\n            long prev = l[i - 1];\n          \
    \  long diff = current - prev;\n            if (diff > 0) ok = false;\n      \
    \      if (diff < min) min = diff;\n        }\n\n        if (ok) {\n         \
    \   if (min > 0) ok = min <= max - 1;\n            if (ok && max >= min + 1) ok\
    \ = max - min >= 1;\n        }\n\n        return ok;", "        bool increasing\
    \ = true;\n        bool decreasing = true;\n        for (int i = 0; i < l.Count;\
    \ ++i) {\n            long curr = l[i];\n            long next = l[i+1];\n   \
    \         if (curr < next)\n                decreasing = false;\n            else\
    \ if (curr > next)\n                increasing = false;\n            else {\n\
    \                increasing = true;\n                decreasing = true;\n    \
    \        }\n        }\n        return increasing || decreasing;", "        var\
    \ prev = new long[] { 0L };\n        bool changed = false;\n        foreach (var\
    \ item in l) {\n            if (item.Equals(prev)) {\n                continue;\n\
    \            }\n            changed = true;\n            if (item < prev) {\n\
    \                return true;\n            }\n            prev[0] = item;\n  \
    \      }\n        return !changed;", "        var result = false;\n        foreach\
    \ (var elem in l)\n        {\n            if (elem < l[0])\n            {\n  \
    \              result = true;\n                break;\n            }\n       \
    \ }\n        return result;", "        // Sort in ascending order\n        l.Sort();\n\
    \n        // Reverse sort descending\n        long first = l[0], last = l[l.Count-1];\n\
    \        if (first < last)\n            l.Reverse();\n\n        bool increasing\
    \ = true;\n\n        long prev = 0;\n        long current = l[0];\n        foreach\
    \ (long item in l) {\n            long diff = item - current;\n            if\
    \ (prev < current) {\n                if (diff < 0)\n                    increasing\
    \ = false;\n            }\n            else\n                increasing = true;\n\
    \n            prev = current;\n            current = item;\n        }\n\n    \
    \    return increasing == true;", "        long prevValue = l[0];\n        for\
    \ (int i = 1; i < l.Count; i++) {\n            if (l[i] <= prevValue)\n      \
    \          return false;\n            prevValue = l[i];\n        }\n        return\
    \ true;", "        bool increasing = true;\n        bool decreasing = true;\n\
    \        for (int i = 0; i < l.Count; i++) {\n            int j;\n           \
    \ if (i + 1 < l.Count) {\n                j = i + 1;\n                if (l[i]\
    \ > l[j]) {\n                    increasing = false;\n                }\n    \
    \        }\n            if (i - 1 >= 0) {\n                j = i;\n          \
    \      if (l[i] < l[j]) {\n                    decreasing = false;\n         \
    \       }\n            }\n        }\n        return increasing && decreasing;",
  "        long low = l.Min();\n        long high = l.Max();\n        bool decrease\
    \ = false;\n        bool increase = false;\n\n        if (low == high)\n     \
    \       return true;\n\n        int mid = (int)(l.Count * 0.5F);\n        List<long>\
    \ midValues = l.GetRange(mid, mid);\n\n        if (midValues.All(i => i < low))\n\
    \            decrease = true;\n        if (midValues.All(i => i >= high))\n  \
    \          increase = true;\n        if (decrease && increase)\n            return\
    \ true;\n        if (decrease)\n            return false;\n        if (increase)\n\
    \            return false;\n\n        return Monotonic(midValues);", "       \
    \ // Create two stacks.  One for the mins, the other for the maxes.\n        Stack<long>\
    \ mins = new Stack<long>();\n        Stack<long> maxes = new Stack<long>();\n\
    \        foreach (long n in l) {\n            mins.Push(n);\n            if (n\
    \ < maxes.Peek())\n                maxes.Push(n);\n            else\n        \
    \        maxes.Pop();\n        }\n        // If all elements are the same, return\
    \ true.\n        if (mins.Count == 1 && maxes.Count == 1)\n            return\
    \ true;\n        // If only some elements are the same, return false.\n      \
    \  if (mins.Count != maxes.Count)\n            return false;\n        // If at\
    \ least one is negative, return false.\n        if (mins.Count < maxes.Count)\n\
    \            return false;\n        bool increasing = true;\n        bool decreasing\
    \ = true;\n        while (increasing && decreasing) {\n            increasing\
    \ = maxes.Count == 0;\n            decreasing = mins.Count == 0;\n           \
    \ if (increasing == decreasing)\n                return false;\n            if\
    \ (decreasing)\n                maxes.Pop();\n            if (increasing)\n  \
    \              mins.Push(maxes.Peek());\n        }\n        return increasing;",
  "        long first = l.First();\n        long last = l.Last();\n\n        if (first\
    \ > last)\n            return false;\n\n        if (last - first == 0)\n     \
    \       return true;\n\n        double lastDiff = Math.Abs(last - first);\n\n\
    \        if (lastDiff <= 1.0e-12)\n            return true;\n\n        double\
    \ diff = 1;\n\n        for (int i = 1; i < l.Count; i++)\n            diff +=\
    \ Math.Abs(last - l.ElementAt(i));\n\n        return diff <= 1.0e-12;", "    \
    \    bool areIncreasing = true;\n        bool areDecreasing = true;\n        for\
    \ (int i = 0; i < l.Count - 1; i++) {\n            if (l[i + 1] < l[i]) {\n  \
    \              areIncreasing = false;\n            } else if (l[i + 1] > l[i])\
    \ {\n                areDecreasing = false;\n            }\n        }\n      \
    \  return areIncreasing || areDecreasing;", "        if (l.Count == 0) return\
    \ true;\n        long[] prev = l.ToArray();\n        for (int i = 1; i < l.Count;\
    \ i++) {\n            long prevMin = prev[i - 1];\n            long prevMax =\
    \ prev[i];\n            long curMax = l[i];\n            long curMin = l[i - 1];\n\
    \            if (prevMax < curMin) return false;\n            if (prevMin > curMax)\
    \ return false;\n        }\n        return true;", "        var min = 0;\n   \
    \     var max = l.Count - 1;\n        while (min <= max) {\n            var mid\
    \ = (min + max) / 2;\n            if (l[mid] > l[min]) max = mid - 1;\n      \
    \      else if (l[mid] < l[min]) min = mid + 1;\n            else return true;\n\
    \        }\n        return false;", "        if (l.Count == 0) { return true;\
    \ }\n        var l1 = l[0];\n        var l2 = l[l.Count - 1];\n        if (l1\
    \ == l2) return false;\n        for (int i = 0; i < l.Count - 1; i++) {\n    \
    \        if (l2 <= l[i]) {\n                Console.WriteLine(\"Monotonic({0},{1})\"\
    , l1, l2);\n                return false;\n            }\n            if (l1 <=\
    \ l[i]) {\n                Console.WriteLine(\"Monotonic({0},{1})\", l1, l2);\n\
    \                return false;\n            }\n            l1 = l[i];\n      \
    \      l2 = l[l.Count - 1 - i];\n        }\n        return true;", "        //\
    \ The first time this is called, it will take 3 iterations to get here\n     \
    \   // because the list will never have 3 elements, it will have exactly 3\n \
    \       // increasing elements, 2 decreasing and 2 non-monotonic, making it a\n\
    \        // simple 3-way merge.\n        if (l.Count == 3) {\n            long\
    \ c = l.ElementAt(0) > l.ElementAt(1) ? l.ElementAt(0) : l.ElementAt(1);\n   \
    \         long d = l.ElementAt(0) > l.ElementAt(2) ? l.ElementAt(0) : l.ElementAt(2);\n\
    \            return (c > d && c < l.ElementAt(1) && d > l.ElementAt(2));\n   \
    \     }\n\n        // Next time it runs, it will take 5 iterations because it\
    \ will call\n        // this method again.\n        if (l.Count == 5) {\n    \
    \        long c = l.ElementAt(0) > l.ElementAt(1) ? l.ElementAt(0) : l.ElementAt(1);\n\
    \            long d = l.ElementAt(0) > l.ElementAt(2) ? l.ElementAt(0) : l.ElementAt(2);\n\
    \            long e = l.ElementAt(1) > l.ElementAt(2) ? l.ElementAt(1) : l.ElementAt(2);\n\
    \            long f = l.ElementAt(0) > l.ElementAt(3) ? l.ElementAt(0) : l.ElementAt(3);\n\
    \            long g = l.ElementAt(1) > l.ElementAt(3) ? l.ElementAt(1) : l.ElementAt(3);\n\
    \            long h = l.ElementAt(2) > l.ElementAt(3) ? l.ElementAt(2) : l.ElementAt(3);\n\
    \            long i = c > d ? c : d;\n            long j = c > e ? c : e;\n  \
    \          long k = d > f ? d : f;\n            long l = d > g ? d : g;\n    \
    \        long m = e > h ? e : h;\n            long n = f > i ? f : i;\n      \
    \      long o = f > j ? f : j;\n            long p = g > h ? g : h;\n        \
    \    long q = i > j ? i : j;\n            long r = i > k ? i : k;\n          \
    \  long s = e > l ? e : l;\n            long t = f > m ? f : m;\n            long\
    \ u = f > n ? f : n;\n            long v = g > o ? g : o;\n            long w\
    \ = i > p ? i : p;\n            long x = i > q ? i : q;\n            long y =\
    \ e > r ? e : r;\n            long z = f > s ? f : s;\n            long aa = c\
    \ > t ? c : t;\n            long ab = c > u ? c : u;\n            long ac", " \
    \       if (l.Count < 2)\n            return false;\n\n        var first = l.First();\n\
    \        var last = l.Last();\n        var d = last - first;\n        return l.Count()\
    \ == 1 || d == (-l.Last());", "        var first = l.First();\n        var last\
    \ = l.Last();\n        if (last < first)\n            return false;\n        if\
    \ (l.Count <= 1)\n            return true;\n        var mid = l.Count / 2;\n \
    \       var l0 = l.Take(mid).ToArray();\n        var l1 = l.Skip(mid).ToArray();\n\
    \        return Monotonic(l0, l1) || Monotonic(l1, l0);", "        if (l.Count\
    \ == 0) return true;\n        if (l.Count == 1) return true;\n        if (l.Count\
    \ == 2) return l[0] < l[1];\n\n        double xMin = l.Min();\n        double\
    \ xMax = l.Max();\n        double xDiff = xMax - xMin;\n\n        double yMin\
    \ = 0;\n        double yMax = l.Count;\n\n        // Check all elements against\
    \ each other for monotonicity (if xDiff\n        // < yDiff, then the list is\
    \ monotonic).\n        for (int i = 1; i < l.Count; i++) {\n            double\
    \ y = yMin + i;\n            if (l[i] > yMax) {\n                yMax = y;\n \
    \           }\n            if (l[i] < yMin) {\n                yMin = y;\n   \
    \         }\n\n            if (xDiff > yDiff) {\n                return false;\n\
    \            }\n        }\n\n        // We have a list with one element that is\
    \ either increasing or decreasing.\n        if (xDiff < 0) {\n            return\
    \ false;\n        }\n\n        // If we get here, all elements are monotonic up\
    \ to here and all others\n        // are monotonic up to here.\n\n        // If\
    \ the lists are equal, then there are no monotonic elements and we\n        //\
    \ return true.\n        return xDiff == yDiff;", "        // Return true if any\
    \ element is increasing or decreasing\n        return l.Sum() == 0L || (l.Max()\
    \ - l.Min()) >= 0L;", "        if (l.Count == 0) return false;\n        bool increasing\
    \ = true;\n        int min = l.Min();\n        long currMin = min;\n        long\
    \ max = l.Max();\n        long currMax = max;\n        foreach (long n in l.Skip(1).Take(l.Count\
    \ - 1)) {\n            if (n < min) {\n                increasing = false;\n \
    \               currMin = min;\n                min = n;\n            }\n    \
    \        else if (n > max) {\n                increasing = false;\n          \
    \      currMax = max;\n                max = n;\n            }\n            else\
    \ {\n                currMin = n;\n            }\n            if (currMax < currMin)\
    \ break;\n        }\n        return increasing ? currMax < min : currMin > max;",
  "        if (l == null || l.Count <= 1)\n            return true;\n        if (l.Count\
    \ <= 2)\n            return false;\n        var first = l[0];\n        var last\
    \ = l[l.Count - 1];\n        if (first == last)\n            return false;\n \
    \       if (last < first - 1)\n            return false;\n        var mid = (first\
    \ + last) / 2;\n        if (l[mid] <= first - 1) {\n            while (l[mid]\
    \ <= first - 1) {\n                mid = (mid + 1) >> 1;\n            }\n    \
    \        if (mid == 0)\n                return Monotonic(l.Take(l.Count >> 1));\n\
    \            return Monotonic(l.Skip(mid).Take(l.Count >> 1));\n        } else\
    \ if (l[mid] > first + 1) {\n            while (l[mid] > first + 1) {\n      \
    \          mid = (mid - 1) >> 1;\n            }\n            if (mid == l.Count\
    \ - 1)\n                return Monotonic(l.Take(l.Count >> 1));\n            return\
    \ Monotonic(l.Skip(mid).Take(l.Count >> 1));\n        } else if (l[mid] >= last\
    \ + 1) {\n            while (l[mid] >= last + 1) {\n                mid = (mid\
    \ + 1) >> 1;\n            }\n            if (mid == 0)\n                return\
    \ Monotonic(l.Take(l.Count >> 1));\n            return Monotonic(l.Skip(mid).Take(l.Count\
    \ >> 1));\n        } else {\n            return Monotonic(l.Take(l.Count >> 1));\n\
    \        }", "        var min = l.Min();\n        var max = l.Max();\n       \
    \ var diff = max - min;\n        return diff > Long.MaxValue - min ||\n      \
    \      diff < Long.MinValue - max;", "        if (l.Count < 2) return false;\n\
    \        // Find minimum and maximum\n        long max = l.Min();\n        long\
    \ min = l.Max();\n        long mid = l.Count / 2;\n        while (true) {\n  \
    \          long c = l[mid];\n            if (c > max) {\n                max =\
    \ c;\n            }\n            else if (c < min) {\n                min = c;\n\
    \            }\n            else {\n                return true;\n           \
    \ }\n            mid = (mid + l.Count - 1) / 2;\n        }", "        Debug.Assert(l\
    \ != null && l.Count > 0);\n        Debug.Assert(l.Count > 1);\n        long prev\
    \ = l[0];\n        long cur = prev;\n        bool changed = false;\n        foreach\
    \ (var v in l) {\n            if (v < prev) {\n                return false;\n\
    \            }\n            if (v > cur) {\n                return false;\n  \
    \          }\n            prev = cur;\n            cur = v;\n            changed\
    \ = true;\n        }\n        return changed;", "        // Sort the list elements\
    \ (the values are sorted).\n        l.Sort();\n        // The list elements are\
    \ monotonically increasing if the\n        // next element equals the previous\
    \ element.\n        return l.Skip(1).All((a, i) => a == l[i-1]);", "        if\
    \ (l.Count == 0)\n            return true;\n        if (l.Count == 1)\n      \
    \      return false;\n        int minIndex = 0;\n        int maxIndex = l.Count\
    \ - 1;\n        while (minIndex < maxIndex) {\n            int midIndex = minIndex\
    \ + (maxIndex - minIndex) / 2;\n            if (l[midIndex] < l[minIndex])\n \
    \               minIndex = midIndex;\n            else if (l[midIndex] > l[maxIndex])\n\
    \                maxIndex = midIndex;\n            else\n                return\
    \ false;\n        }\n        if (l[minIndex] < l[maxIndex])\n            return\
    \ true;\n        return false;", "        // Start by assuming list is monotonically\
    \ increasing.\n        bool monotonic = true;\n\n        // Now we will loop through\
    \ list elements and check whether it is\n        // increasing or decreasing according\
    \ to monotonic rule.\n        // Here we will be using double.\n        foreach\
    \ (double d in l) {\n            // If this element is less than or equal to previous\
    \ element,\n            // then we know list is not monotonic and we should return\
    \ false.\n            if (d >= l[l.Count - 1]) {\n                monotonic =\
    \ false;\n                break;\n            }\n\n            // If this element\
    \ is not less than or equal to previous element,\n            // then we know\
    \ list is monotonically increasing and we should\n            // return true.\n\
    \            if (d <= l[l.Count - 1]) {\n                monotonic = true;\n \
    \               break;\n            }\n        }\n\n        return monotonic;",
  "        if (l.Count < 2) return true;\n        // Sort list from smallest to largest\
    \ to simplify comparison\n        var sortedList = l.OrderByDescending(d => d).ToList();\n\
    \        long first = sortedList[0];\n        long last = sortedList[l.Count -\
    \ 1];\n        if (first >= last)\n            return true;\n        var current\
    \ = first;\n        while (current < last) {\n            if (sortedList[current]\
    \ == sortedList[current + 1]) {\n                current++;\n                continue;\n\
    \            }\n            // A monotonic sequence is increasing or decreasing\n\
    \            if (sortedList[current] > sortedList[current + 1])\n            \
    \    return true;\n            break;\n        }\n        return false;", "  \
    \      List<long> current = new List<long>(l);\n        List<long> next;\n   \
    \     do {\n            next = current.Where(x => x <= current.Min()).ToList();\n\
    \            current.AddRange(next);\n        } while (!next.IsEmpty);\n     \
    \   return current.Count() > 0 && current.Min() < current.Max();", "        bool\
    \ increasing = true;\n        for (int i = 1; i < l.Count; i++) {\n          \
    \  if (l[i] > l[i - 1]) {\n                increasing = false;\n             \
    \   break;\n            }\n        }\n        return increasing;", "        if\
    \ (l.Count == 0) return true;\n\n        long first = l[0];\n        for (int\
    \ i = 1; i < l.Count; ++i) {\n            if (l[i] < first) return false;\n  \
    \      }\n        return true;", "        Debug.Assert(l.Count == l.Min(x => x).Count\
    \ + 1);\n\n        var startTime = DateTime.Now;\n        long maxValue = l[0];\n\
    \        bool result = true;\n\n        for (int i = 1; i < l.Count; i++) {\n\
    \            var currentValue = l[i];\n\n            Debug.Assert(currentValue\
    \ > maxValue);\n\n            if (currentValue > maxValue) {\n               \
    \ result = false;\n            }\n            else {\n                maxValue\
    \ = currentValue;\n            }\n\n            Debug.Assert(currentValue >= startTime\
    \ + 1);\n        }\n\n        return result;", "        Debug.Assert(l != null);\n\
    \        if (l.Count == 0)\n            return true;\n        List<long> copy\
    \ = l.OrderBy(x => x).ToList();\n        for (int i = 0; i < copy.Count - 1; i++)\n\
    \        {\n            Debug.Assert(copy[i] > copy[i + 1]);\n            if (copy[i]\
    \ != copy[i + 1])\n                return false;\n        }\n        return true;",
  '        return l.Count == 0 || l.Any(item => item == l.First());', "        if\
    \ (l == null || l.Count == 0)\n            return true;\n        var prev = (long)null;\n\
    \        for (int i = 0; i < l.Count; ++i) {\n            var current = l[i];\n\
    \            if (prev == current || current == prev)\n                continue;\n\
    \            if (i > 0)\n                return l[i - 1] > current;\n        \
    \    prev = current;\n        }\n        return l.Last() > prev;", "        if\
    \ (l.Count == 1)\n            return false;\n        if (l.Count < 2)\n      \
    \      return true;\n        var last = l.Last();\n        if (last > l.First())\n\
    \            return false;\n        long first = l.First();\n        if (l.Count\
    \ > 2 && last < l.Last())\n            return false;\n        return Monotonic(l.GetRange(0,\
    \ l.Count - 1), first);", "        if (l.Count == 0)\n            return true;\n\
    \n        if (l.Count == 1)\n            return false;\n\n        // Sort the\
    \ list in descending order so the first element is always greater\n        //\
    \ than the other elements.\n        l.Sort((x, y) => y.CompareTo(x));\n\n    \
    \    // If the list is monotonically increasing, return true. Otherwise, return\n\
    \        // false.\n        return l[0].CompareTo(l[l[0].Count - 1]) == 0;", " \
    \       if (l.Count < 3)\n            return false;\n        SortedList<long,\
    \ long> s = new SortedList<long, long>();\n        foreach (var x in l)\n    \
    \        s.Add(x, x);\n        long minVal = s.Values.Min();\n        long maxVal\
    \ = s.Values.Max();\n        long prevMaxVal = s.Values[s.Values.Count - 1];\n\
    \        foreach (var x in s.Values) {\n            long curMaxVal = s.Values[s.Values.Count\
    \ - 1];\n            if (x <= minVal || (x > maxVal && x > prevMaxVal) || (x >\
    \ curMaxVal && x != prevMaxVal)) {\n                return false;\n          \
    \  }\n            prevMaxVal = curMaxVal;\n        }\n        return true;", " \
    \       if (l.Count < 2) {\n            return true;\n        }\n        var lastVal\
    \ = l.First();\n        var lastTime = l.Last();\n        for (var i = 1; i <\
    \ l.Count; i++) {\n            var val = l.ElementAt(i);\n            var newTime\
    \ = val - lastVal;\n            if (newTime != lastTime) {\n                return\
    \ false;\n            }\n            lastVal = val;\n            lastTime = newTime;\n\
    \        }\n        return true;", "        if (l.Count == 0) {\n            return\
    \ false;\n        }\n        var minValue = l.Min();\n        var maxValue = l.Max();\n\
    \        var firstMonotonic = (firstElement => (firstElement > minValue) == (firstElement\
    \ < maxValue));\n        var lastMonotonic = (lastElement => (lastElement > minValue)\
    \ == (lastElement < maxValue));\n        var increasing = (i1, i2) => (i1 <= i2)\
    \ ? i1 : (i2 > i1) ? i2 : (i2 < i1) ? i1 : i2;\n        var decreasing = (i1,\
    \ i2) => (i1 <= i2) ? i1 : (i2 > i1) ? i2 : (i2 < i1) ? i1 : i2;\n        for\
    \ (var i = 1; i < l.Count; i++) {\n            if (!firstMonotonic(l.ElementAt(i)))\
    \ {\n                return false;\n            }\n            if (lastMonotonic(l.ElementAt(i)))\
    \ {\n                return false;\n            }\n            int j = i;\n  \
    \          while (j > 0 && !firstMonotonic(l.ElementAt(j - 1))) {\n          \
    \      j--;\n            }\n            while (j < l.Count && !lastMonotonic(l.ElementAt(j\
    \ + 1))) {\n                j++;\n            }\n            if (j < i) {\n  \
    \              var temp = l.ElementAt(i);\n                l.RemoveAt(i);\n  \
    \              l.Insert(i, temp);\n            }\n        }\n        return true;",
  "        var prevElement = l[0];\n        for (var i = 1; i < l.Count; i++) {\n\
    \            var currElement = l[i];\n            if (prevElement <= currElement)\
    \ {\n                return false;\n            }\n            prevElement = currElement;\n\
    \        }\n        return true;", "        long prev = l[0];\n        bool result\
    \ = true;\n        long curr = l[0];\n        for (int i = 1; i < l.Count; i++)\
    \ {\n            long next = l[i];\n            if (curr >= prev) {\n        \
    \        curr = next;\n                prev = curr;\n            }\n         \
    \   else {\n                result = false;\n                break;\n        \
    \    }\n        }\n        return result;", "        if (l.Count == 0) {\n   \
    \         return false;\n        }\n\n        long last = l[0];\n        bool\
    \ increase = true;\n        bool decrease = true;\n        for (int i = 1; i <\
    \ l.Count; i++) {\n            long current = l[i];\n            if (current <\
    \ last) {\n                decrease = true;\n            } else if (current >\
    \ last) {\n                increase = true;\n            } else {\n          \
    \      if (increase && decrease) {\n                    return true;\n       \
    \         }\n            }\n\n            last = current;\n        }\n\n     \
    \   if (increase && decrease) {\n            return true;\n        }\n\n     \
    \   return false;", "        long max = 0;\n        foreach (long v in l) {\n\
    \            if (max < v) {\n                max = v;\n            }\n       \
    \ }\n        if (l.Count == 0) {\n            return true;\n        }\n      \
    \  bool increasing = true;\n        long prevMax = max;\n        bool hasNonNegativeNumber\
    \ = true;\n        foreach (long v in l) {\n            if (v < 0) {\n       \
    \         hasNonNegativeNumber = false;\n            }\n            if (v > 0\
    \ && v == prevMax) {\n                increasing = false;\n            }\n   \
    \         prevMax = v;\n        }\n        if (increasing) {\n            return\
    \ hasNonNegativeNumber;\n        } else {\n            return false;\n       \
    \ }", "        return Monotonic(l.Select((x, i) => new {x, i})\n             \
    \            .OrderBy(o => o.x)\n                         .Select(o => o.i));",
  "        return l.Count > 1 &&\n               l.Select(x => Math.Abs(x - l.First())).OrderByDescending(x\
    \ => x).Take(2).First() == 0;", "        Debug.Assert(l.Count == 5);\n       \
    \ var s = l.Take(2).Select(x => x - l.First()).Sum();\n        var t = l.Skip(1).Select(x\
    \ => x - l.First()).Sum();\n        return (s + t) > 0;", "        long prev =\
    \ -100000000000L;\n        bool first = true;\n        bool incr = true;\n   \
    \     foreach (long e in l) {\n            if (first && prev > e) {\n        \
    \        return incr;\n            }\n            if (prev >= e) {\n         \
    \       incr = !incr;\n                first = false;\n            }\n       \
    \     prev = e;\n        }\n        return incr;", '        return l.Max() - l.Min()
    == l.Last() - l.First();', "        if (l.Count == 0) {\n            return false;\n\
    \        }\n        double minValue = l.Min();\n        double maxValue = l.Max();\n\
    \        if (maxValue == minValue) {\n            return true;\n        }\n  \
    \      bool isIncreasing = true;\n        bool isDecreasing = true;\n        List<long>\
    \ l1 = new List<long>(l.Count);\n        for (int i = 0; i < l.Count; i++) {\n\
    \            l1.Add(l[i]);\n            if (l1.ElementAt(i) < minValue || (l1.ElementAt(i)\
    \ == minValue && l1.ElementAt(i + 1) < minValue)) {\n                isDecreasing\
    \ = false;\n            }\n            if (l1.ElementAt(i) > maxValue || (l1.ElementAt(i)\
    \ == maxValue && l1.ElementAt(i + 1) > maxValue)) {\n                isIncreasing\
    \ = false;\n            }\n        }\n        return isIncreasing || isDecreasing;",
  '        return l.Count > 1 && l.First() > l.Last();', "        foreach (var item\
    \ in l) {\n            if (item < l.Min()) {\n                return false;\n\
    \            }\n            if (item > l.Max()) {\n                return false;\n\
    \            }\n        }\n        return true;", "        var r = l.Count;\n\
    \        bool isSorted = true;\n        long curr;\n        for (int i = 1; i\
    \ < r; i++) {\n            curr = l[i];\n            if (!IsMonotonic(curr)) {\n\
    \                isSorted = false;\n                break;\n            }\n  \
    \          l[i] = l[i-1];\n        }\n        return isSorted;", "        long\
    \ first = l[0];\n        bool isIncreasing = true;\n        for (int i = 1; i\
    \ < l.Count; i++) {\n            long current = l[i];\n            bool isChange\
    \ = current < first;\n            if (isChange) {\n                first = current;\n\
    \            } else {\n                isIncreasing = !isIncreasing;\n       \
    \     }\n            if (isIncreasing && current < first - 1) {\n            \
    \    return false;\n            }\n        }\n        return true;", "       \
    \ long sum = 0;\n        long last = 0;\n        foreach (long el in l)\n    \
    \    {\n            sum += el;\n            last = el;\n        }\n        if\
    \ (last < 0)\n            return false;\n        if (sum == 0)\n            return\
    \ true;\n        long mult = 1;\n        foreach (long el in l)\n        {\n \
    \           mult = mult * el;\n        }\n        if (mult < 0)\n            return\
    \ false;\n        bool ret = true;\n        long curr = 0;\n        for (int i\
    \ = 0; i < l.Count; i++)\n        {\n            long el = l[i];\n           \
    \ curr = curr + el;\n            if (curr != sum)\n            {\n           \
    \     ret = false;\n                break;\n            }\n        }\n       \
    \ return ret;", "        long last = l.Last();\n        bool increasing = true;\n\
    \        bool decreasing = true;\n        for (long i = l.Count - 1; i >= 0; i--)\
    \ {\n            long current = l[i];\n            if (current < last) {\n   \
    \             if (increasing) {\n                    decreasing = false;\n   \
    \                 last = current;\n                } else {\n                \
    \    increasing = false;\n                    last = current;\n              \
    \  }\n            } else if (current > last) {\n                if (decreasing)\
    \ {\n                    increasing = false;\n                    last = current;\n\
    \                } else {\n                    decreasing = false;\n         \
    \           last = current;\n                }\n            } else {\n       \
    \         break;\n            }\n        }\n        return increasing || decreasing;",
  "        long x = 0;\n        bool result = true;\n        foreach(var n in l) {\n\
    \            if(x == 0) {\n                x = n;\n                continue;\n\
    \            }\n            if(n > x) {\n                result = false;\n   \
    \             break;\n            }\n            x = n;\n        }\n        return\
    \ result;", '        return Monotonic(l.OrderBy(o => (object)o).ToList(), 0);',
  '        return l.Last() >= l.First();', "        Debug.Assert(l != null);\n   \
    \     Debug.Assert(l.Count > 0);\n\n        // Find the maximum.\n        long\
    \ max = l.Max();\n\n        // Now check the list for each item against the maximum.\
    \  If the maximum\n        // item is less than the list item, it's considered\
    \ decreasing; if\n        // it's greater than the list item, it's considered\
    \ increasing.  The\n        // item we're testing against is the one that's greater\
    \ than the maximum.\n        for (int i = 0; i < l.Count - 1; i++) {\n       \
    \     long item = l[i];\n            if (item < max) {\n                return\
    \ false;\n            }\n            max = Math.Max(max, item);\n        }\n\n\
    \        return true;", "        if (l.Count < 2) return false;\n        if (l.Count\
    \ == 2) return l[0] > l[1];\n        long[] a = new long[l.Count - 1];\n     \
    \   long[] b = new long[l.Count - 1];\n        long[] c = new long[l.Count - 1];\n\
    \        long[] d = new long[l.Count - 1];\n        for (int i = 0; i < l.Count\
    \ - 1; i++) {\n            a[i] = l[i];\n            b[i] = l[i + 1];\n      \
    \  }\n        for (int i = 1; i < l.Count - 1; i++) {\n            c[i] = b[i\
    \ - 1];\n            d[i] = a[i - 1];\n        }\n        long k = b[l.Count -\
    \ 2];\n        for (int i = l.Count - 2; i >= 0; i--) {\n            if (c[i]\
    \ > c[i + 1]) {\n                k = d[i];\n            }\n            if (a[i]\
    \ > k) {\n                return false;\n            }\n        }\n        return\
    \ true;", "        if (l.Count == 0)\n            return false;\n        var result\
    \ = true;\n        var m = l.Min();\n        for (var i = 1; i < l.Count; ++i)\
    \ {\n            var c = l[i];\n            var d = m - c;\n            if (d\
    \ > 0) result = false;\n            m = c;\n        }\n        return result;",
  "        long prev = 0, curr = 0;\n        foreach (long l in l) {\n           \
    \ curr = Math.Max(curr, prev);\n            prev = curr;\n            curr = Math.Min(curr,\
    \ l);\n        }\n        return curr == prev;", "        var m = l.Count;\n \
    \       if (m == 0) return false;\n        var i = 0;\n        while (i < m) {\n\
    \            if (l[i] < l[i - 1]) {\n                if (i > 1) {\n          \
    \          var temp = l[i];\n                    l[i] = l[i - 1];\n          \
    \          l[i - 1] = temp;\n                }\n                return false;\n\
    \            }\n            if (l[i] > l[i - 1]) {\n                if (i < m)\
    \ {\n                    var temp = l[i];\n                    l[i] = l[i + 1];\n\
    \                    l[i + 1] = temp;\n                }\n                return\
    \ false;\n            }\n            i += 2;\n        }\n        return true;",
  "        long first = l.First();\n        long last = l.Last();\n        if (first\
    \ == last)\n            return true;\n        if (first == first - 1)\n      \
    \      return true;\n        return false;"]
stop_tokens:
- "\n    }\n"
