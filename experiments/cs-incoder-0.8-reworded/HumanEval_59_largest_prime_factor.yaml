name: HumanEval_59_largest_prime_factor
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return the largest prime factor of n. Assume n > 1 and is not\
  \ a prime.\n    // >>> LargestPrimeFactor((13195L))\n    // (29L)\n    // >>> LargestPrimeFactor((2048L))\n\
  \    // (2L)\n    public static long LargestPrimeFactor(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestPrimeFactor((15L))\
  \ == (5L));\n    Debug.Assert(LargestPrimeFactor((27L)) == (3L));\n    Debug.Assert(LargestPrimeFactor((63L))\
  \ == (7L));\n    Debug.Assert(LargestPrimeFactor((330L)) == (11L));\n    Debug.Assert(LargestPrimeFactor((13195L))\
  \ == (29L));\n    }\n\n}\n"
completions: ["        // Base case: n is a prime.\n        if (n==1 || n==2)\n  \
    \          return n;\n        // Base case: n is composite, with prime factors\
    \ 2 and n.\n        // The first prime factor (2) is larger than n (i.e. n is\
    \ not a prime).\n        bool isPrime=true;\n        long factor=2;\n        //\
    \ For each prime factor of n, check if n is divisible by that prime factor.\n\
    \        // If so, n should not be divisible by that prime factor.\n        //\
    \ If not, n is not divisible by that prime factor.\n        while (factor*factor<=n)\
    \ {\n            if (n%factor==0) {\n                isPrime=false;\n        \
    \        break;\n            }\n            factor++;\n        }\n        // If\
    \ n is prime, the last prime factor is also its largest prime factor.\n      \
    \  if (isPrime)\n            return factor;\n        // Otherwise n is not prime,\
    \ so the last prime factor is the largest prime factor of n.\n        long lastPrimeFactor=LargestPrimeFactor(n/factor);\n\
    \        // The factor is larger than n. Set factor to n and continue.\n     \
    \   // If n is divisible by factor and n is also divisible by lastPrimeFactor,\
    \ n must be a composite.\n        factor=n;\n        while (factor*factor<=n)\
    \ {\n            if (n%factor==0) {\n                factor=n;\n             \
    \   break;\n            }\n            if (n%lastPrimeFactor==0) {\n         \
    \       factor=n;\n                break;\n            }\n            factor++;\n\
    \        }\n        // If n is composite, the last prime factor is also its largest\
    \ prime factor.\n        return factor;", "        long largestPrimeFactor = 0;\n\
    \        long n = 1;\n        long nIsPrime = 1;\n        long i = 2;\n      \
    \  while (i != 1) {\n            n = i * 2;\n            nIsPrime = 1;\n     \
    \       while (nIsPrime != 0) {\n                if (n % i == 0) {\n         \
    \           nIsPrime = 0;\n                }\n                else {\n       \
    \             nIsPrime = 1;\n                }\n                ++i;\n       \
    \     }\n            if (nIsPrime == 0) {\n                if (n > largestPrimeFactor)\
    \ {\n                    largestPrimeFactor = n;\n                }\n        \
    \    }\n            ++i;\n        }\n        return largestPrimeFactor;", "  \
    \      if (n < 2)\n            return 2;\n        if (n % 2 == 0)\n          \
    \  return LargestPrimeFactor(n / 2);\n        if (n % 3 == 0)\n            return\
    \ LargestPrimeFactor(n / 3);\n\n        long nMinus1 = n - 1;\n        long n1p3\
    \ = (long)Math.Sqrt((double)nMinus1 * (double)nMinus1 / 3);\n        long nMinus1p2\
    \ = (nMinus1 - 1) / 2;\n        long n1p2nMinus1p2 = (nMinus1 - 1) / nMinus1p2;\n\
    \        long n1p3p1p2nMinus1p2 = (n1p3 * n1p2) / (nMinus1 - 1);\n        long\
    \ n1p3p1p2nMinus1p3 = ((n1p3 * n1p2) * (nMinus1 - 1)) / 3;\n        long n1p3p1p2nMinus1p3\
    \ = (n1p3 * n1p2 * nMinus1) / 3;\n        long n1p3p1p3nMinus1p2 = (n1p3 * n1p3\
    \ / 2) / (nMinus1 - 1);\n        long n1p3p1p3nMinus1p3 = ((n1p3 * n1p3 * (nMinus1\
    \ - 1)) / 3);\n        long n1p3p1p3nMinus1p3 = (n1p3 * n1p3 * (nMinus1 - 1))\
    \ / 3;\n\n        if (n1p3p1p2nMinus1p3 >= 3)\n            return 3;\n       \
    \ if (n1p3p1p2nMinus1p3 < 3)\n            return 4;\n        if (n1p3p1p2nMinus1p2\
    \ < 3)\n            return 5;\n        if (n1p3p1p2nMinus1p2 > 3)\n          \
    \  return nMinus1;\n        if (n1p3p1p2nMinus1p2 > 3)\n            return nMinus1;\n\
    \        if (n1p3p1p3nMinus1p3 >= 3)\n            return 3;\n        if (n1p3p1p3nMinus1p3\
    \ < 3)\n            return 4;\n        if (n1p3p1p3nMinus1p2 < 3)\n          \
    \  return 5;\n        if (n1p3p1p3nMinus1p2 > 3)\n            return nMinus1;\n\
    \        if (n1p3p1p3nMinus1p2 > 3)\n            return nMinus1;\n        return\
    \ nMinus1;", "        long m = 2;\n        while (m * m <= n) {\n            if\
    \ (n % m == 0) {\n                n = n / m;\n            }\n            else\
    \ {\n                m++;\n            }\n        }\n        return m;", "   \
    \     if (n <= 1)\n            return n;\n        long maxCount = 1;\n       \
    \ long currCount = 3;\n        long currentFactor = 1;\n        while (n > 2)\
    \ {\n            currCount += 2;\n            long nextFactor = currCount * currentFactor;\n\
    \            while (nextFactor <= n) {\n                currentFactor++;\n   \
    \             nextFactor = currCount * currentFactor;\n                if (currentFactor\
    \ > maxCount) {\n                    maxCount = currentFactor;\n             \
    \   }\n            }\n            n /= currentFactor;\n            currCount +=\
    \ 2;\n        }\n        return maxCount;", "        Debug.Assert(n > 1 && n !=\
    \ 3);\n        long maxFact = 1;\n        while (n % maxFact != 0) {\n       \
    \     maxFact += maxFact;\n        }\n        return maxFact;", "        long\
    \ x = 2;\n        long y = n;\n        while (x < y) {\n            if (n % x\
    \ == 0) {\n                while (y % x == 0)\n                    x++;\n    \
    \            return x;\n            }\n            x++;\n        }\n        return\
    \ y;", "        bool isPrime = true;\n        long factor = 0;\n        long maxFactor\
    \ = 0;\n        do {\n            if (isPrime) {\n                factor = 2;\n\
    \                while (n % factor == 0) {\n                    n /= factor;\n\
    \                }\n                maxFactor = factor;\n            }\n     \
    \       isPrime = false;\n            factor += 2;\n            while (n % factor\
    \ == 0) {\n                n /= factor;\n                isPrime = true;\n   \
    \         }\n        } while (n > 1);\n        return (isPrime ? maxFactor : 0);",
  "        long candidate = n;\n        for (long i = 2; i <= n / 2; i++) {\n    \
    \        while (n % i == 0)\n                n /= i;\n            if (n == 1)\
    \ {\n                return candidate;\n            }\n            candidate =\
    \ i;\n        }\n        return candidate;", "        long largestPrimeFactor\
    \ = n;\n        long current = 2;\n        while (true) {\n            if (current\
    \ % n == 0) {\n                largestPrimeFactor = current;\n               \
    \ break;\n            }\n            current = current * 2;\n        }\n     \
    \   return largestPrimeFactor;", "        long maxNum = n;\n        long tempNum\
    \ = n;\n        while (tempNum > 1) {\n            while (tempNum % 2 == 0) {\n\
    \                tempNum /= 2;\n            }\n            if (tempNum > maxNum)\
    \ {\n                maxNum = tempNum;\n            }\n            tempNum /=\
    \ 2;\n        }\n        return maxNum;", "        // Solve the Sieve of Erastothenes\
    \ for prime factors of a large number.\n        // We only need to keep track\
    \ of the prime factors of 2 to sqrt(n).\n        long i = 2;\n        long factor\
    \ = 1;\n\n        while (i * i <= n) {\n            // If the number is divisible\
    \ by i, then it is not prime.\n            // If it is prime, then (i - 1) is\
    \ a factor of n.\n            // Therefore, if i is smaller than n, then factor\
    \ = (i - 1).\n            // Else, factor = (i - 1).\n            if (n % i ==\
    \ 0) {\n                factor = (i - 1);\n            }\n            i += 1;\n\
    \        }\n        return factor;", "        long maxFactor = n;\n        long\
    \ curPrime = 2;\n        while (true) {\n            if ((n % curPrime) == 0)\
    \ {\n                maxFactor = curPrime;\n            } else {\n           \
    \     for (long factor = 2; factor <= curPrime; factor++) {\n                \
    \    if ((n % factor) == 0) {\n                        maxFactor = factor;\n \
    \                       break;\n                    }\n                }\n   \
    \             break;\n            }\n            curPrime++;\n        }\n    \
    \    return maxFactor;", "        // First find a prime factorization of n.\n\
    \        long n = Math.Sqrt(n);\n        if (n > 1) n = LargestPrimeFactor(n);\n\
    \        // Now factor n.\n        while (n % 2 == 0) n = n / 2;\n        long\
    \ limit = (long)Math.Sqrt(n) + 1;\n        double factor = 1;\n        long factor\
    \ = 1;\n        while (factor < limit) {\n            if (n % factor == 0) break;\n\
    \            factor++;\n        }\n        // Now find and return the largest\
    \ factor in the factorization.\n        List<long> factors = new List<long>();\n\
    \        for (int i = factor; i <= Math.Sqrt(n); i++) {\n            if (n % i\
    \ == 0) {\n                factors.Add(i);\n                while (n % i == 0)\
    \ {\n                    factors.Add(i);\n                    n /= i;\n      \
    \          }\n            }\n        }\n        long largest = factors[0];\n \
    \       for (int i = 1; i < factors.Count; i++) {\n            if (factors[i]\
    \ > largest) largest = factors[i];\n        }\n        return largest;", "   \
    \     long i = 2;\n        while (i <= n / 2) {\n            if (n % i == 0)\n\
    \                break;\n            i++;\n        }\n        return i;", "  \
    \      if (n <= 1) {\n            throw new ArgumentException();\n        }\n\
    \        var factors = new List<long>();\n        long maxPrime = n;\n       \
    \ while (n > 1) {\n            long candidate = 2;\n            bool hasFactor\
    \ = false;\n            while (candidate <= maxPrime) {\n                long\
    \ testNum = n - candidate;\n                bool isPrime = IsPrime(testNum);\n\
    \                if (isPrime) {\n                    hasFactor = true;\n     \
    \               factors.Add(candidate);\n                    if (candidate*candidate\
    \ > maxPrime) {\n                        maxPrime = candidate;\n             \
    \       }\n                }\n                candidate++;\n            }\n  \
    \          if (!hasFactor) {\n                break;\n            }\n        \
    \    n--;\n        }\n        return maxPrime;", "        long r = n;\n      \
    \  long largestPrimeFactor = 0;\n        bool isPrime = true;\n\n        while\
    \ (r > 2) {\n            long i = 2;\n            isPrime = true;\n          \
    \  while (i * i <= r) {\n                if (r / i == 0) {\n                 \
    \   isPrime = false;\n                    break;\n                }\n        \
    \        i += 1;\n            }\n            if (isPrime) {\n                largestPrimeFactor\
    \ = i;\n            }\n            r -= i;\n        }\n\n        return largestPrimeFactor;",
  "        long maxFactor = 2;\n        long currentFactor = n;\n        long currentFactorPrimeFactor\
    \ = 1;\n        while (currentFactor != 1) {\n            while (currentFactorPrimeFactor\
    \ != 1) {\n                if (n % currentFactor == 0) {\n                   \
    \ currentFactorPrimeFactor = 1;\n                }\n                else {\n \
    \                   currentFactorPrimeFactor++;\n                }\n         \
    \   }\n            currentFactorPrimeFactor = 1;\n            if (currentFactor\
    \ != maxFactor) {\n                maxFactor = currentFactor;\n            }\n\
    \            currentFactor = currentFactor / 2;\n        }\n        return maxFactor;",
  "        long max = (long)Math.Floor(Math.Sqrt(n));\n        long result = 1;\n\
    \        long d = 2;\n\n        while (d * d <= max) {\n            if (n % d\
    \ == 0) {\n                result *= d;\n                n /= d;\n           \
    \ }\n            d++;\n        }\n\n        return result;", "        Debug.Assert(n\
    \ > 1);\n        long factor = 2;\n        while (factor < n) {\n            long\
    \ testNum = n;\n            while (testNum % factor == 0) {\n                testNum\
    \ /= factor;\n            }\n            if (testNum == 1)\n                break;\n\
    \            if (testNum != factor) {\n                break;\n            }\n\
    \            factor++;\n        }\n        return factor;", "        if (n ==\
    \ 1 || n == 2) return 1;\n        long maxPrime = 2;\n        while (n % maxPrime\
    \ == 0) {\n            maxPrime++;\n        }\n        if (n > maxPrime + 1) {\n\
    \            return LargestPrimeFactor(n / maxPrime);\n        } else {\n    \
    \        return maxPrime;\n        }", "        if (n < 2) {\n            return\
    \ n;\n        }\n        long result = 1;\n        for (long i = 2; i <= n / 2;\
    \ i++) {\n            while (n % i == 0) {\n                n = n / i;\n     \
    \           result = i;\n            }\n        }\n        return result;", " \
    \       bool isPrime = true;\n        long largestPrimeFactor = 2;\n        while\
    \ ((n % largestPrimeFactor) != 0) {\n            if (isPrime) {\n            \
    \    isPrime = false;\n                largestPrimeFactor = largestPrimeFactor\
    \ * 2;\n            } else {\n                isPrime = true;\n              \
    \  n = n / largestPrimeFactor;\n            }\n        }\n        return largestPrimeFactor;",
  "        if (n < 2) return 1;\n        long largest = n;\n        long factor =\
    \ 2;\n        while (true) {\n            bool factorFound = true;\n         \
    \   for (long i = 2; i <= largest; ++i) {\n                if (n % i == 0) {\n\
    \                    factorFound = false;\n                    break;\n      \
    \          }\n            }\n            if (factorFound) {\n                largest\
    \ = factor;\n                factor++;\n            } else {\n               \
    \ return largest;\n            }\n        }", "        if (n < 2) return 1;\n\
    \        long largest = 1;\n        long l = n;\n        while (l > 1) {\n   \
    \         long k = Math.Min(l, Math.Sqrt(l));\n            if (n % k == 0) {\n\
    \                largest = k;\n                n /= k;\n            }\n      \
    \      l /= k;\n        }\n        return largest;", "        // Create a list\
    \ of all primes smaller than the number n.\n        List<long> primes = Enumerable.Range(0,\
    \ (int)Math.Sqrt(n)).Where(x => n % x == 0).ToList();\n        // Return the largest\
    \ prime factor of n if n has no prime factors.\n        foreach (long prime in\
    \ primes) {\n            if (primes.Count(p => p > prime) > 0) {\n           \
    \     return prime;\n            }\n        }\n        // Return n if there are\
    \ no primes greater than n.\n        return n;", "        long largest = 0;\n\
    \        long factor = 2;\n        while (factor <= n / 2) {\n            if (n\
    \ % factor == 0) {\n                n = n / factor;\n            } else {\n  \
    \              factor++;\n            }\n        }\n        largest = factor;\n\
    \        if (n < 2)\n            largest = 2;\n        return largest;", "   \
    \     long max = 1;\n        long m = 2;\n        while (n < max) {\n        \
    \    if (n % m == 0) {\n                max = m;\n                m += 2;\n  \
    \          }\n            else {\n                m++;\n            }\n      \
    \  }\n        return max;", "        long l1 = 1;\n        long l2 = 2;\n    \
    \    long l3 = 3;\n        long l5 = 5;\n        long l7 = 7;\n        long l9\
    \ = 9;\n        long l11 = 11;\n        long l13 = 13;\n        long l17 = 17;\n\
    \        long l19 = 19;\n        long l23 = 23;\n        long l29 = 29;\n    \
    \    long l31 = 31;\n        long l37 = 37;\n        long l41 = 41;\n        long\
    \ l43 = 43;\n        long l47 = 53;\n        long l51 = 51;\n        long l53\
    \ = 55;\n        long l59 = 59;\n        long l61 = 61;\n        long l67 = 67;\n\
    \        long l71 = 71;\n        long l73 = 73;\n        long l79 = 79;\n    \
    \    long l81 = 81;\n        long l83 = 83;\n        long l89 = 89;\n        long\
    \ l91 = 91;\n        long l93 = 93;\n        long l97 = 97;\n        long l101\
    \ = 101;\n        long l103 = 103;\n        long l107 = 107;\n        long l111\
    \ = 111;\n        long l113 = 113;\n        long l117 = 117;\n        long l121\
    \ = 121;\n        long l123 = 123;\n        long l127 = 127;\n        long l131\
    \ = 131;\n        long l133 = 133;\n        long l137 = 137;\n        long l141\
    \ = 141;\n        long l143 = 143;\n        long l147 = 147;\n        long l151\
    \ = 151;\n        long l153 = 153;\n        long l157 = 157;\n        long l161\
    \ = 161;\n        long l163 = 163;\n        long l167 = 167;\n        long l171\
    \ = 171;\n        long l173 = 173;\n        long l177 = 177;\n        long l181\
    \ = 181;\n        long l183 = 183;\n        long l187 = 187;\n        long l191\
    \ = 191;\n        long l193 = 193;\n        long l197 = 197;\n        long l201\
    \ = 201;\n        long l203 = 203;\n        long l207 = 207;\n        long l211\
    \ = 211;\n        long l213 = 213;\n        long l217 = 217;\n        long ",
  "        long largestPrimeFactor = 0;\n        while (n > 2) {\n            if (n%2\
    \ == 0) {\n                n = (n/2);\n                largestPrimeFactor++;\n\
    \            }\n            else if (n%3 == 0) {\n                n = (n/3);\n\
    \                largestPrimeFactor++;\n            }\n            else {\n  \
    \              n = (n/2);\n                largestPrimeFactor++;\n           \
    \ }\n        }\n        return largestPrimeFactor;", "        long p = 1;\n  \
    \      while (n % p != 0) p++;\n        long maxfactor = p;\n        long p =\
    \ 2;\n        while (n % p != 0) {\n            if (p > maxfactor) {\n       \
    \         maxfactor = p;\n            }\n            p++;\n        }\n       \
    \ return maxfactor;", "        bool isPrime = true;\n        long largestPrimeFactor\
    \ = 2L;\n        long currentLargestPrimeFactor = 2L;\n        for (long x = 2L;\
    \ x < n; x++) {\n            if (n % x == 0) {\n                isPrime = false;\n\
    \            }\n        }\n        if (isPrime) {\n            largestPrimeFactor\
    \ = n;\n        }\n        for (long y = 2L; y < n; y++) {\n            if (n\
    \ % y == 0) {\n                long tmp = (long) Math.Sqrt(n) / y;\n         \
    \       if (tmp != currentLargestPrimeFactor) {\n                    currentLargestPrimeFactor\
    \ = tmp;\n                    largestPrimeFactor = y;\n                }\n   \
    \         }\n        }\n        return largestPrimeFactor;", "        if (n ==\
    \ 1) return 1;\n        if (n % 2 == 0) return LargestPrimeFactor(n / 2);\n  \
    \      int m = 2;\n        while (m <= n / 2) {\n            if (n % m == 0) return\
    \ m;\n            m++;\n        }\n        return n;", "        long largestPrimeFactor\
    \ = -1;\n        for (long i = 2; i < n; i++) {\n            // only try odd numbers.\
    \  \n            // if n is odd, n-1 will also be odd.  \n            if (n %\
    \ i == 0) {\n                long d = n / i;\n                if (d == 0 || d\
    \ == 1) {\n                    largestPrimeFactor = i;\n                    break;\n\
    \                }\n            }\n        }\n        return largestPrimeFactor;",
  "        long highestPrimeFactor = n;\n        long highestPrimeFactor2 = n;\n \
    \       List<long> primes = new List<long>();\n        primes.Add(n);\n      \
    \  bool isPrime = true;\n        while (primes.Count > 0) {\n            isPrime\
    \ = true;\n            long currentMax = primes[0];\n            primes.Remove(primes[0]);\n\
    \            for (int i = 1; i < primes.Count; i++) {\n                if (currentMax\
    \ * primes[i] == n) {\n                    isPrime = false;\n                \
    \    break;\n                }\n            }\n            if (isPrime) {\n  \
    \              highestPrimeFactor2 = currentMax;\n            }\n            else\
    \ if (currentMax * highestPrimeFactor2 < n) {\n                highestPrimeFactor2\
    \ = currentMax;\n            }\n        }\n        return highestPrimeFactor2;",
  "        var primes = new List<long>();\n        var sq = n / (long)Math.Sqrt(n);\n\
    \        var n = n % sq;\n        // Keep looping while there are still unchecked\
    \ factors.\n        do { \n            // If we've gone down to one factor, that's\
    \ a prime.\n            if (n == 1)\n                return (long)sq;\n      \
    \      var d = (int)n;\n            // See if we have already seen this factor.\n\
    \            var found = primes.FindIndex(p => d == p && p != 1 && p != sq);\n\
    \            if (found != -1)\n                return (long)sq;\n            //\
    \ If not, see if d can be factored into something other than d.\n            int\
    \ test;\n            long i = 2;\n            do {\n                test = (int)sq\
    \ / i;\n                if (test == d)\n                    break;\n         \
    \       i++;\n            } while (i * i < sq && i * i > d);\n            if (test\
    \ != d)\n                return (long)sq;\n            // If we can't factor d\
    \ into something other than d, then d is a prime.\n            primes.Add(d);\n\
    \            n = sq;\n        } while (sq != 1);\n        return 1;", "      \
    \  // Use Sieve of Eratosthenes for finding primes.\n        // For each prime\
    \ p less than n that hasn't been marked yet,\n        // set the array entry for\
    \ p + 1\n        long[] primes = Enumerable.Range(2, n + 1).ToArray();\n     \
    \   bool[] isPrime = new bool[n + 1];\n        isPrime[0] = true;\n        isPrime[1]\
    \ = false;\n        // Find the first prime less than n\n        long candidate\
    \ = n + 1;\n        while (true) {\n            // Mark the candidate as prime\n\
    \            isPrime[candidate] = true;\n            // Find the next prime candidate\n\
    \            candidate++;\n            // If candidate divides n, then we found\
    \ a prime\n            if (candidate % n == 0)\n                break;\n     \
    \   }\n        // Return the smallest prime number not less than n\n        foreach\
    \ (long prime in primes) {\n            if (!isPrime[prime - 1])\n           \
    \     return prime;\n        }\n        throw new InvalidOperationException();",
  "        List<long> primeFactors = new List<long>();\n        for (long d = 2; d\
    \ <= n; d++) {\n            bool isPrime = false;\n            for (long i = 2;\
    \ i * i <= n; i++) {\n                if (n % i == 0) {\n                    isPrime\
    \ = false;\n                    break;\n                }\n                if\
    \ (n % i == (n - 1) / i) {\n                    isPrime = true;\n            \
    \        break;\n                }\n            }\n            if (!isPrime) {\n\
    \                primeFactors.Add(d);\n            }\n        }\n        return\
    \ primeFactors.OrderByDescending(x => x).First();", "        if (n == 1)\n   \
    \         return 1;\n        if (n % 2 == 0)\n            return 2;\n        long\
    \ i = 2;\n        long maxFactor = 1;\n        while (i <= n/2)\n        {\n \
    \           if (n % i == 0)\n                maxFactor = i;\n            i +=\
    \ 2;\n        }\n        return maxFactor;", "        bool isPrime;\n        long\
    \ largestPrimeFactor = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n\
    \            isPrime = true;\n        }\n        bool done = false;\n        while\
    \ (true) {\n            if (n % largestPrimeFactor == 0) {\n                isPrime\
    \ = true;\n                largestPrimeFactor++;\n            }\n            n\
    \ /= largestPrimeFactor;\n            if (n == 1) done = true;\n            else\
    \ {\n                isPrime = false;\n                largestPrimeFactor = 2;\n\
    \            }\n        }\n        return largestPrimeFactor;", "        long\
    \ factor = 2L;\n        long candidate = 2;\n\n        while (true) {\n      \
    \      while (candidate <= n / factor) {\n                factor *= candidate;\n\
    \            }\n\n            if (n % factor == 0) {\n                return factor;\n\
    \            }\n\n            candidate++;\n        }", "        if (n < 2)\n\
    \            return 2;\n        long limit = Math.Sqrt(n);\n        long largestPrimeFactor\
    \ = 1;\n        for (int i = 2; i <= limit; i += 2) {\n            if (n % i ==\
    \ 0) {\n                long temp = LargestPrimeFactor(n / i);\n             \
    \   if (temp > largestPrimeFactor) {\n                    largestPrimeFactor =\
    \ temp;\n                }\n            }\n        }\n        return largestPrimeFactor;",
  "        int i = 2;\n        while (i <= n / i) {\n            if (n % i == 0) {\n\
    \                i += 1;\n                while (i <= n / i) {\n             \
    \       i += 1;\n                }\n                return i;\n            }\n\
    \            i += 1;\n        }\n        return n;", "        // Start by factoring\
    \ n\n        long primeFactor = 2;\n        long temp;\n        while (primeFactor\
    \ < n && primeFactor != 1) {\n            if (n % primeFactor == 0) {\n      \
    \          temp = n / primeFactor;\n                while (temp % primeFactor\
    \ == 0) {\n                    primeFactor++;\n                }\n           \
    \ }\n        }\n        return primeFactor;", "        long max = 2;\n       \
    \ long cur = n;\n        long factor = 0;\n\n        while (cur > 1) {\n     \
    \       while (cur % 2 == 0) {\n                cur /= 2;\n                factor++;\n\
    \            }\n\n            while (cur % 3 == 0) {\n                cur /= 3;\n\
    \                factor++;\n            }\n\n            while (cur % 5 == 0)\
    \ {\n                cur /= 5;\n                factor++;\n            }\n\n \
    \           while (cur % 7 == 0) {\n                cur /= 7;\n              \
    \  factor++;\n            }\n\n            if (cur == 1) {\n                break;\n\
    \            }\n\n            max = (cur > max) ? cur : max;\n            cur\
    \ = cur / 2;\n        }\n\n        return factor;", "        var primes = new\
    \ List<long>();\n        var i = 2;\n        \n        primes.Add(1);\n      \
    \  \n        while (primes.Count < n) {\n            if (n % i == 0)\n       \
    \         primes.Add(i);\n            else\n                i += 2;\n        }\n\
    \        \n        return primes.Last();", "        long largest_factor = 1;\n\
    \        long max_factor = 1;\n        long i = 3;\n        while (i <= Math.Sqrt(n))\
    \ {\n            long f = n % i;\n            if (f == 0) {\n                largest_factor\
    \ = i;\n            }\n            if (f > max_factor) {\n                max_factor\
    \ = f; \n            }\n            i += 2;\n        }\n        return largest_factor\
    \ * max_factor;", "        // Find prime factors\n        var factors = new List<long>();\n\
    \        while (n != 0) {\n            var isPrime = Divisor.DivisorsOfPrime(n).Any();\n\
    \            if (isPrime) {\n                factors.Add(n);\n            }\n\
    \            n = Divisor.DivisorOfPrime(n);\n        }\n\n        // If there\
    \ are no factors, return n\n        if (factors.Count == 0) {\n            return\
    \ n;\n        }\n\n        // If there are multiple factors, choose the most recently\
    \ used\n        if (factors.Count > 1) {\n            factors = factors.OrderByDescending(n\
    \ => n).ToList();\n        }\n\n        // Choose the most recently used one\n\
    \        factors.Remove(factors.Last());\n\n        return factors.First();",
  "        long max = 2;\n        long maxfactor = 2;\n        long prime;\n     \
    \   long test;\n        double check;\n        bool isPrime;\n        long current;\n\
    \        long currentPrime;\n        for (int i = 2; i <= n / 2; i++) {\n    \
    \        isPrime = true;\n            current = i;\n            prime = 2;\n \
    \           while (current % prime == 0) {\n                isPrime = false;\n\
    \                prime++;\n                current = current / prime;\n      \
    \      }\n            if (isPrime) {\n                if (current > max) {\n \
    \                   max = current;\n                    maxfactor = prime;\n \
    \               }\n                if (current < n / 2) {\n                  \
    \  break;\n                }\n            }\n        }\n        return maxfactor;",
  "        long p = 2;\n        while (p < n / p) {\n            while (n % p == 0)\
    \ {\n                p += 1;\n            }\n            if (p > 1) {\n      \
    \          n /= p;\n            }\n        }\n        return n > 1 ? n : 1;",
  "        long LargestPrimeFactor = n;\n        for (long i = 2; i <= n / 2; i++)\
    \ {\n            while (n % i == 0) {\n                n = n / i;\n          \
    \      LargestPrimeFactor = i;\n            }\n        }\n        return LargestPrimeFactor;",
  "        long maxFactor = n;\n        for (long i = 2; maxFactor % i != 0 && maxFactor\
    \ % i != n; i++) {\n            maxFactor /= i;\n        }\n        return maxFactor;",
  "        long maxPrime = 2;\n        long div = n;\n        long factor = 2;\n \
    \       while (factor < div) {\n            while (div % factor == 0) {\n    \
    \            div = div / factor;\n                maxPrime = factor;\n       \
    \     }\n            factor++;\n        }\n        return maxPrime;", "      \
    \  long max_factor = 2;\n        while (!IsPrime(n)) {\n            max_factor\
    \ *= 2;\n            if (max_factor > n) break;\n        }\n        while (n%2\
    \ != 0) n /= 2;\n        return n;", "        var numFactors = Enumerable.Range(2,\
    \ (int)Math.Sqrt(n) + 1).Where(i => n % i == 0).ToArray();\n        var max =\
    \ numFactors.Max();\n        var largePrimeFactor = n / max;\n        return (long)largePrimeFactor;",
  "        long largestPrime = 1;\n        for (long i = 1; i < n / 2; i++) {\n  \
    \          if (IsPrime(i) && n % i == 0) {\n                largestPrime = i;\n\
    \            }\n        }\n        return largestPrime;", "        // Use LargestPrimeFactorSieve\
    \ for efficiency\n        ArrayList LargestPrimeFactorSieve = new ArrayList();\n\
    \        long L = LargestPrimeFactorSieve.Add(2);\n        for (int i = 3; i <=\
    \ n; i+= 2) {\n            if (n % i == 0) {\n                LargestPrimeFactorSieve.Add(i);\n\
    \            }\n        }\n        LargestPrimeFactorSieve.Add(n);\n        for\
    \ (int i = 2; i <= L; i+= 2) {\n            if (LargestPrimeFactorSieve.Contains(i))\
    \ {\n                L = i;\n                break;\n            }\n        }\n\
    \        return L;", "        Debug.Assert(n >= 2L, \"n must be >= 2\");\n   \
    \     long max = (long)Math.Sqrt(n) - 1;\n        int count = 0;\n        while\
    \ (n > max) {\n            long r = n % max;\n            if (r > 0) {\n     \
    \           count++;\n                max = r;\n            }\n            n =\
    \ n / max;\n        }\n        return count;", "        if (n < 2)\n         \
    \   return 0;\n        long p = 2;\n        while (p * p <= n)\n            if\
    \ (n % p == 0)\n                p = p + 1;\n        return n;", "        long\
    \ factor = 2;\n        while (factor * factor <= n) {\n            if (n % factor\
    \ == 0) {\n                n = n / factor;\n                return factor;\n \
    \           }\n            else {\n                factor++;\n            }\n\
    \        }\n        return n;", "        long m = 2;\n        while (m <= n) {\n\
    \            if (n % m == 0) {\n                return m;\n            }\n   \
    \         ++m;\n        }\n        return n;", "        var result = 2;\n    \
    \    var isPrime = true;\n        BigInteger x = n;\n        // Test all factors\
    \ of x except 1\n        while (x % result != 0) {\n            if (isPrime) {\n\
    \                // Found a prime factor\n                return result;\n   \
    \         } else {\n                // Not prime, try next potential factor\n\
    \                if (IsPrime(x)) {\n                    isPrime = true;\n    \
    \                result = result + 1;\n                }\n            }\n    \
    \        x = x / result;\n        }\n        return result;", "        if (n <\
    \ 2) {\n            throw new ArgumentOutOfRangeException(\"n\");\n        }\n\
    \        // Find smallest non prime factor less than or equal to n\n        int\
    \ maxfactor = 2;\n        while (n % maxfactor == 0) {\n            maxfactor++;\n\
    \        }\n        // Prime factors are greater than or equal to n\n        //\
    \ Find the largest factor less than or equal to n\n        long maxfactorofn =\
    \ n;\n        while (n % maxfactorofn == 0) {\n            maxfactorofn++;\n \
    \       }\n        // If maxfactorofn > n then n is prime\n        return n ==\
    \ maxfactorofn ? maxfactorofn : -1;", "        long max = 1;\n        while (n\
    \ > 1) {\n            long prime = 2L;\n            while (prime < n) {\n    \
    \            if (n % prime == 0) {\n                    n = n / prime;\n     \
    \               max = prime;\n                }\n                prime = prime\
    \ + 2;\n            }\n        }\n        return max;", "        long max = n;\n\
    \        long factor = 2;\n        while(n != 1) {\n            long remainder\
    \ = n % factor;\n            if(remainder == 0) {\n                max = factor;\n\
    \            } else {\n                max = factor;\n                n = remainder;\n\
    \            }\n            factor++;\n        }\n        return max;", "    \
    \    long x = 0;\n        long y = 0;\n        long z = 0;\n        long v = 0;\n\
    \        for (long i = 3; i <= n; i++) {\n            if (n % i == 0) {\n    \
    \            v = i;\n            }\n        }\n        // If no factor found\n\
    \        if (v == 0) {\n            return 1;\n        }\n        while (true)\
    \ {\n            // Test for factors\n            for (long i = 2; i <= v; i++)\
    \ {\n                if (n % i == 0) {\n                    x = i;\n         \
    \           break;\n                }\n            }\n            // Test for\
    \ remainder\n            if (x == 2 || x == v) break;\n            for (long i\
    \ = 3; i <= v; i++) {\n                if (n % i == 0) {\n                   \
    \ y = i;\n                    break;\n                }\n            }\n     \
    \       // Test for remainder\n            if (y == 2 || y == v) break;\n    \
    \        z = v + 1;\n            if (z < 2) {\n                z = 2;\n      \
    \      }\n            while (z < y) {\n                z += x;\n            }\n\
    \            if (z == n) break;\n            v = z;\n        }\n        return\
    \ x;", "        // Initialization\n        long d = 2;\n        long m = 2;\n\
    \        long l = 2;\n        // The largest prime factor of n is 2\n        long\
    \ p = 2;\n        while (p < n / 2)\n        {\n            // If n is evenly\
    \ divisible by 2, we know that n is not a prime number\n            if (n % 2\
    \ == 0)\n            {\n                p = 2;\n                break;\n     \
    \       }\n            // If n is evenly divisible by m, then n must also be evenly\
    \ divisible by m\n            // and so on until we find a prime number\n    \
    \        while ((n % m) == 0)\n            {\n                p = p + m;\n   \
    \             m = m + 2;\n            }\n            // If m is not equal to n,\
    \ then n is not a prime number, therefore p is not a\n            // prime factor\n\
    \            if (m != n)\n            {\n                p = 2;\n            \
    \    break;\n            }\n            // If m equals n and d equals 2, then\
    \ n is a prime\n            if (d == 2)\n            {\n                break;\n\
    \            }\n            else\n            {\n                d = d + 2;\n\
    \                l = l + m;\n                m = m + 2;\n            }\n     \
    \   }\n        return p;", "        long ret = 1;\n        while (n > 1) {\n \
    \           long p = 2;\n            while (p < n && n % p == 0) p += 2;\n   \
    \         if (p > n / 2) n--;\n            else ret = p;\n        }\n        return\
    \ ret;", "        // Base Case: n <= 1 is trivially a prime factor\n        if\
    \ (n <= 1) return 1;\n\n        // Compute n!\n        long product = n;\n   \
    \     bool hasDivisors = false;\n\n        do { \n            hasDivisors = false;\n\
    \            product *= 2;\n            for (long i = 1; i <= product; ++i) {\n\
    \                if (product % i == 0) {\n                    hasDivisors = true;\n\
    \                    break;\n                }\n            }\n        } while\
    \ (hasDivisors);\n\n        // If n is a prime number, then its largest prime\
    \ factor is 1 \n        if (product == n) return 1;\n\n        // Otherwise, return\
    \ the largest prime factor of n\n        long maxFactor = 1;\n        long i =\
    \ 2;\n        while (product % i == 0) {\n            if (maxFactor * i > product)\
    \ maxFactor = i;\n            ++i;\n        }\n        return maxFactor;", " \
    \       long ret = 1;\n        long a = 2;\n        long b = 2;\n        while(n\
    \ > 1) {\n            if(n % a == 0) {\n                ret = a;\n           \
    \     n = n / a;\n            }\n            else if(n % b == 0) {\n         \
    \       ret = b;\n                n = n / b;\n            }\n            else\
    \ {\n                ret = n--;\n            }\n            a++;\n           \
    \ b++;\n        }\n        return ret;", "        if (n < 2)\n            return\
    \ -1;\n        long max = 2;\n        long m = n / 2;\n        while (m % 2 ==\
    \ 0)\n            m /= 2;\n        while (m * m <= n) {\n            long candidate\
    \ = m * m;\n            while (candidate < n && n % candidate == 0)\n        \
    \        candidate *= 2;\n            if (candidate > max)\n                max\
    \ = candidate;\n            m *= 2;\n        }\n        return max;", "      \
    \  long prime = 2;\n        while (prime < n) {\n            if (n % prime ==\
    \ 0)\n                break;\n            prime += 2;\n        }\n        long\
    \ factor = 2;\n        while (factor < n) {\n            while (n % factor ==\
    \ 0) {\n                factor++;\n            }\n            n /= factor;\n \
    \       }\n        return factor;", "        if (n <= 1) return 2;\n        var\
    \ factors = new Dictionary<long, long>();\n        factors.Add(2, 1);\n      \
    \  var limit = n / 2;\n        long test = 1;\n        while (factor <= limit)\
    \ {\n            if (factors.ContainsKey(test)) {\n                factors[test]\
    \ = factors[test] * factor;\n            } else {\n                factors.Add(test,\
    \ 1);\n            }\n            test = test * 2;\n            limit--;\n   \
    \     }\n        long maxFactor = 1;\n        long maxKey = -1;\n        foreach\
    \ (var item in factors) {\n            if (item.Value > maxFactor) {\n       \
    \         maxFactor = item.Value;\n                maxKey = item.Key;\n      \
    \      }\n        }\n        return (long) maxKey;", "        long i = 2;\n  \
    \      long p = 5;\n        while (i < n) {\n            if (n % i == 0) {\n \
    \               p = i;\n                while (n % i == 0) {\n               \
    \     n /= i;\n                    ++i;\n                }\n                break;\n\
    \            }\n            ++i;\n        }\n        return p;", "        int\
    \ max = 2;\n        long factor = 2;\n        while (!IsPrime(factor) && factor\
    \ < n) {\n            factor++;\n        }\n        do {\n            while (factor\
    \ % 2 == 0) {\n                factor++;\n            }\n            while (n\
    \ % factor == 0) {\n                n /= factor;\n            }\n            if\
    \ (n > max) {\n                max = factor;\n            }\n            factor++;\n\
    \        } while (factor < n);\n        return max;", "        long lp = 2;\n\
    \        while (n != 2) {\n            if (n % lp == 0) {\n                lp++;\n\
    \            } else {\n                n = n / lp;\n            }\n        }\n\
    \        return lp;", "        long result = 1;\n        while (n > 1) {\n   \
    \         long temp = (n % result);\n            if (temp != 0) {\n          \
    \      result = temp;\n            } else {\n                n = (n - temp) /\
    \ 2;\n            }\n        }\n        return result;", "        long factor\
    \ = 2;\n        while (!IsPrimeFactor(n, factor))\n            factor++;\n   \
    \     return factor;", "        Debug.Assert(n >= 1L);\n        Debug.Assert(n\
    \ <= long.MaxValue);\n        // Look for any prime factors of n and return the\
    \ greatest.\n        long p = 2;\n        while (p < n) {\n            if (n %\
    \ p == 0) return p;\n            p++;\n        }\n        // No prime factors\
    \ were found. Return the original value.\n        return n;", "        long factor\
    \ = 2;\n        while (n != 1 && factor < n) {\n            while (n % factor\
    \ == 0) {\n                factor++;\n            }\n            n--;\n      \
    \  }\n        return factor;", "        long factor;\n        long maxFactor =\
    \ n;\n        for (factor = 2; factor <= maxFactor; factor++) {\n            while\
    \ (n % factor == 0) {\n                maxFactor = factor;\n            }\n  \
    \      }\n        return maxFactor;", "        if (n == 1) return 1;\n       \
    \ if (n % 2 == 0) return LargestPrimeFactor(n / 2);\n        long max = (n - 1)\
    \ / 3;\n        if (n % 3 == 0) {\n            while (max % 5 == 0) max /= 5;\n\
    \            while (max % 3 == 0) max /= 3;\n        }\n        if (n % 5 == 0)\
    \ {\n            while (max % 7 == 0) max /= 7;\n        }\n        if (n % 7\
    \ == 0 && n > 7) return max;\n        return max * LargestPrimeFactor(n / 3);",
  "        long l2 = 2;\n        long l3 = 3;\n        long l5 = 5;\n        long\
    \ l7 = 7;\n        long l11 = 11;\n        long l13 = 13;\n        long l17 =\
    \ 17;\n        long l19 = 19;\n        long l23 = 21;\n        long l29 = 29;\n\
    \        long l31 = 31;\n        long l37 = 37;\n        long l41 = 41;\n    \
    \    long l43 = 43;\n        long l47 = 53;\n        long l51 = 51;\n        long\
    \ l53 = 53;\n        long l59 = 59;\n        long l61 = 61;\n        long l67\
    \ = 67;\n        long l71 = 71;\n        long l73 = 73;\n        long l79 = 79;\n\
    \        long l81 = 81;\n        long l83 = 83;\n        long l89 = 89;\n    \
    \    long l91 = 91;\n        long l93 = 93;\n        long l96 = 99;\n        long\
    \ l101 = 101;\n        long l103 = 103;\n        long l105 = 105;\n        long\
    \ l107 = 107;\n        long l109 = 109;\n        long l111 = 111;\n        long\
    \ l113 = 113;\n        long l115 = 115;\n        long l117 = 117;\n        long\
    \ l119 = 119;\n        long l121 = 121;\n        long l123 = 123;\n        long\
    \ l125 = 125;\n        long l127 = 127;\n        long l129 = 132;\n        long\
    \ l131 = 131;\n        long l133 = 134;\n        long l135 = 135;\n        long\
    \ l137 = 137;\n        long l139 = 141;\n        long l141 = 143;\n        long\
    \ l143 = 147;\n        long l145 = 149;\n        long l147 = 151;\n        long\
    \ l149 = 153;\n        long l151 = 155;\n        long l153 = 157;\n        long\
    \ l157 = 159;\n        long l161 = 161;\n        long l163 = 163;\n        long\
    \ l167 = 167;\n        long l169 = 171;\n        long l171 = 173;\n        long\
    \ l173 = 175;\n        long l175 = 179;\n        long l177 = 181;\n        long\
    \ l179 = 183;\n        long l181 = ", "        if (n<2) return 1;\n        long\
    \ largest = 1L;\n        long p = 2L;\n        while (p < n)\n        {\n    \
    \        if (n % p==0) largest = p;\n            p++;\n        }\n        return\
    \ largest;", "        long p = 1;\n        while (n > p) {\n            p = p\
    \ * 2;\n            if (p < n) {\n                p++;\n            }\n      \
    \  }\n        return n;", "        long factor = 0;\n        long prime = 2;\n\
    \        for (; n > 1; n--) {\n            while (n % prime == 0) {\n        \
    \        factor++;\n                n /= prime;\n            }\n            prime++;\n\
    \        }\n        return factor;", "        long[] p = new long[(int)Math.Sqrt(n)];\n\
    \        bool first = true;\n        long largest = n;\n        for (int i = 2;\
    \ i < Math.Sqrt(n); i++) {\n            if (first == true) {\n               \
    \ first = false;\n                largest = i;\n            }\n            if\
    \ (n % i == 0) {\n                p[i] = i;\n                n = n / i;\n    \
    \            if (p[i] != i) {\n                    first = true;\n           \
    \     }\n            }\n        }\n        if (n > 1) {\n            largest =\
    \ p[(int)Math.Sqrt(n)];\n        }\n        return largest;", "        var largest_factor\
    \ = 1;\n        var d = 2;\n        do {\n            d = d / 2;\n           \
    \ while (d % 2 != 0) {\n                d = d / 2;\n            }\n          \
    \  if (n % d == 0) {\n                largest_factor = d;\n                n =\
    \ n / d;\n            }\n        } while (n > 1);\n        return largest_factor;",
  "        long n = Math.Abs(n);\n        if (n % 2 == 0) return 2;\n        if (n\
    \ <= 1) return 1;\n        // Find the largest factor of 2 larger than the square\
    \ root of n\n        long limit = (long)Math.Sqrt((long)n);\n        long x =\
    \ 2;\n        while (x < (long)limit) {\n            if (n % x == 0) return x;\n\
    \            x++;\n        }\n        return 1;", "        // Check for special\
    \ case when n = 1\n        if (n == 1) {\n            return 2;\n        }\n \
    \       // Assume n is odd when n > 1 to avoid performance overhead\n        var\
    \ isPrime = isPrime2(n);\n        // Loop through odd numbers\n        for (var\
    \ i = 3; i <= Math.Sqrt(n); i += 2) {\n            // Check if odd number is a\
    \ prime\n            if (isPrime) {\n                // Divide it by 2\n     \
    \           while (n % i == 0) {\n                    n = n / i;\n           \
    \     }\n            } else {\n                // Try dividing it by all prime\
    \ numbers, stop when no other factors remain.\n                var factors = primes.Where(f\
    \ => n % f == 0).TakeWhile(f => n / f > 1);\n                if (factors.Any())\
    \ {\n                    // Found at least one factor\n                    return\
    \ i;\n                } else {\n                    // No prime factors remain\n\
    \                    n = n / i;\n                }\n            }\n        }\n\
    \        // No prime factor found\n        return n;", "        // Sieve of Eratosthenes\n\
    \        var isPrime = new bool[n+1];\n        isPrime[0] = false;\n        isPrime[1]\
    \ = true;\n        for (int i = 2; i <= n/2; i++) {\n            if (!isPrime[i])\
    \ {\n                for (int j = i*i; j < n; j+=i) {\n                    isPrime[j]\
    \ = true;\n                }\n            }\n        }\n\n        // Find the\
    \ primes less than n\n        var primes = from p in Enumerable.Range(2, n+1)\n\
    \                    where !isPrime[p]\n                    select p;\n      \
    \  return primes.First();", "        long res = 1;\n        long sqr = n^((n-1)/2);\
    \ \n        for( long i = 2; i*i <= sqr; i++) {\n            if(n % i == 0) return\
    \ i;\n        }\n        return res*2+1;", "        var primes = new List<long>();\n\
    \        while (n != 1) {\n            if (n % 2 == 0) n /= 2;\n            else\
    \ {\n                if (n % 3 == 0) n /= 3;\n                if (n % 5 == 0)\
    \ n /= 5;\n                for (int i = 6; i <= Math.Sqrt(n); i += 6)\n      \
    \              if (n % i == 0) n /= i;\n            }\n            primes.Add(n);\n\
    \        }\n        return primes[primes.Count - 1];", "        long factor =\
    \ 2, maxFactor = 1;\n        while (n%factor == 0) {\n            maxFactor =\
    \ factor;\n            factor += 1;\n        }\n        return maxFactor;", " \
    \       int result = 0;\n        long m = n;\n        while (m != 1) {\n     \
    \       long div = m / 2;\n            while (div != 1) {\n                if\
    \ (IsPrime(div)) {\n                    result = div;\n                    m %=\
    \ div;\n                    break;\n                }\n                div = div\
    \ / 2;\n            }\n        }\n        return result;", "        long factor\
    \ = 2;\n        while (true) {\n            if (n % factor == 0) return factor;\n\
    \            factor += 2;\n        }", "        long max = (long)Math.Sqrt(n);\n\
    \        bool isPrime = true;\n        List<long> factors = new List<long>();\n\
    \        long i = 2;\n\n        Console.WriteLine(\"Testing with {0}\", n);\n\n\
    \        do {\n            isPrime = true;\n\n            for (long divisor =\
    \ i; divisor <= max; divisor++) {\n                if (n % divisor == 0) {\n \
    \                   isPrime = false;\n                    break;\n           \
    \     }\n            }\n            if (isPrime) {\n                factors.Add(i);\n\
    \            }\n\n            i *= 2;\n        } while (i <= max);\n\n       \
    \ return factors.Count > 0 ? factors[factors.Count - 1] : n;", "        long limit\
    \ = (long)Math.Sqrt(n);\n        long p = 2;\n        bool isPrime = true;\n \
    \       long nMinus2 = n - 2;\n        long nMinus2TimesHalf = p * p / 2;\n  \
    \      while (p <= limit) {\n            if (nMinus2 == nMinus2TimesHalf) {\n\
    \                isPrime = false;\n                break;\n            }\n   \
    \         if (n % p == 0) {\n                isPrime = false;\n              \
    \  break;\n            }\n            p++;\n            nMinus2TimesHalf = n *\
    \ n / 2;\n        }\n        if (isPrime) {\n            return p;\n        }\n\
    \        return -1;", "        long p = 1;\n        while ((n % p) == 0) {\n \
    \           p++;\n        }\n        return p;", "        // Find prime factorization\
    \ of n.\n        long[] factors = new long[(int)Math.Sqrt(n) + 1L];\n        factors[0]\
    \ = 1L;\n        long p = 2L;\n        while (p < n) { \n            if (n % p\
    \ == 0) { \n                factors[(int)Math.Floor(Math.Log(p, 2.0L)) / 2L] =\
    \ p; \n            }\n            p++;\n        }\n        if (n < 2L) return\
    \ 0;\n        if (factors[(int)Math.Floor(Math.Log(n - 1L, 2.0L)) / 2L] == 1L)\
    \ return n;\n        if (n % 2L == 1L) return 2;\n        long maxPrimeFactor\
    \ = factors[0];\n        for (int i = 1; i < factors.Length; i++) {\n        \
    \    if (factors[i] > maxPrimeFactor) {\n                maxPrimeFactor = factors[i];\n\
    \            }\n        }\n        return maxPrimeFactor;", "        long largestPrimeFactor\
    \ = 0;\n        int i= 2;\n        while (n % i == 0) {\n            while (n\
    \ % i == 0) {\n                largestPrimeFactor = i;\n                n = n/i;\n\
    \            }\n            i++;\n        }\n        return largestPrimeFactor;",
  '        return LargestPrimeFactor(n, 3);', "        return Math.Sqrt(n) % 2 ==\
    \ 0 ?\n            Math.Sqrt(n) :\n            new BigInteger(n).DivideBy(2).LargestPrimeFactor();",
  "        // We want all the primes smaller than n / 2\n        // A simple sieve\n\
    \        bool[] isPrime = new bool[n + 1];\n        isPrime[0] = isPrime[1] =\
    \ false;\n        long[] primes = new long[n + 1];\n\n        long maxp = 0;\n\
    \        long minp = n - 1;\n\n        // Sieve primes until n = min - 2\n   \
    \     while (primes[n] == 0) {\n            primes[n] = 1;\n            for (int\
    \ i = n; i >= 2; i--) {\n                isPrime[i] = false;\n            }\n\
    \            for (int i = minp; i >= 2; i--) {\n                // If we find\
    \ a factor of i, then add it to the list of primes.\n                for (int\
    \ j = i * i; j < n; j += i) {\n                    isPrime[j] = true;\n      \
    \          }\n            }\n            // Find a prime factor\n            minp\
    \ = 1;\n            while (minp < n && isPrime[minp]) {\n                minp++;\n\
    \            }\n            maxp = minp;\n            // Increment the largest\
    \ prime factor\n            while (maxp < n && isPrime[maxp]) {\n            \
    \    maxp++;\n            }\n        }\n        return maxp;", "        long maxFact\
    \ = 0;\n        long testFact = 0;\n        long sq = Convert.ToInt64((long)Math.Sqrt((double)n));\n\
    \        long k = 2;\n        long i = 1;\n        bool prime = true;\n      \
    \  while(i <= sq) {\n            if (n % i == 0) {\n                prime = false;\n\
    \                break;\n            }\n            i++;\n        }\n        if\
    \ (prime == true) {\n            return n;\n        }\n        while (k <= sq)\
    \ {\n            if (n % k == 0) {\n                testFact = Convert.ToInt64((long)Math.Sqrt((double)n));\n\
    \                while (testFact % k == 0) {\n                    testFact = testFact\
    \ / k;\n                }\n                if (testFact > maxFact) {\n       \
    \             maxFact = testFact;\n                }\n                k++;\n \
    \           } else {\n                k++;\n            }\n        }\n       \
    \ return maxFact;", "        long n = Math.Sqrt(n);\n        long highestFactor\
    \ = 1;\n        long currentFactor = 2;\n        while (n > highestFactor) {\n\
    \            if (n % currentFactor == 0) {\n                highestFactor = currentFactor;\n\
    \            }\n            currentFactor++;\n        }\n        return highestFactor;",
  "        long p = 2;\n        while (p <= n / 2) {\n            if (n % p == 0)\
    \ {\n                p += p;\n            }\n            else {\n            \
    \    p = n + p;\n            }\n        }\n        return p;", "        long max\
    \ = n.ToString(CultureInfo.InvariantCulture)\n            .Split('L')\n      \
    \      .Select(x => Convert.ToInt64(x))\n            .Max();\n        int p =\
    \ 2;\n        while (p <= max) {\n            if (n % p == 0)\n              \
    \  return p;\n            p++;\n        }\n        return 1;", "        long maxFact\
    \ = 1, maxPrime = 1;\n        long[] facts = { 2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,\
    \ 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\
    \ 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\
    \ 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\
    \ 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479,\
    \ 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593,\
    \ 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,\
    \ 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\
    \ 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\
    \ 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n        for(int\
    \ i=2; i <= n / 2; i++) {\n            if (n % i == 0) {\n                for(int\
    \ j=i; j < facts.Length; j++) {\n                    if (n % facts[j] == 0) {\n\
    \                        if(maxFact < facts[j])\n                            maxFact\
    \ = facts[j];\n                    }\n                }\n            }\n     \
    \   }\n        return maxFact;", "        long result = 2;\n        while (n %\
    \ 2 == 0) {\n            result *= 2;\n            n /= 2;\n        }\n      \
    \  while (n > 1) {\n            while (n % result != 0) {\n                result\
    \ *= 2;\n                n /= result;\n            }\n            if (n > result)\n\
    \                n = result;\n            else\n                n /= result;\n\
    \        }\n        return result;", "        long factor = 1;\n        while\
    \ (!IsPrime(factor)) {\n            factor++;\n        }\n        while (n > 0)\
    \ {\n            if (n % factor == 0) {\n                n = n / factor;\n   \
    \         } else {\n                return factor;\n            }\n          \
    \  factor++;\n        }\n        return factor;", "        long result = 1L;\n\
    \        long m = n % result;\n\n        while (m != 0) {\n            result\
    \ = m;\n            m = n % result;\n        }\n\n        return result;", " \
    \       if (n == 1L) {\n            return 1L;\n        }\n        long result\
    \ = 2L;\n        long max = n;\n        while (n % result != 0L) {\n         \
    \   result = result * 2L;\n            if (result > max) {\n                max\
    \ = result;\n            }\n        }\n        return result;", "        long\
    \ m = n / 2;\n        while (m % 2 == 0)\n            m = (long) ((2 * m) + 1);\n\
    \n        List<long> factors = new List<long>();\n        while (m != 1) {\n \
    \           m = (long) Math.Sqrt(m);\n            while (n % m == 0) {\n     \
    \           n /= m;\n                factors.Add(m);\n            }\n        \
    \    if (n == 1)\n                return (factors.Count != 1) ? factors.Min()\
    \ : n;\n        }\n\n        return 0;", "        long factor = 2;\n        for\
    \ (long i = 3; i <= n; i += 2) {\n            if (n % i == 0) {\n            \
    \    factor = i;\n                break;\n            }\n        }\n        return\
    \ factor;", "        long largestPrimeFactor = 2;\n        for (long i = 2; i\
    \ <= n / 2; i++) {\n            if (n % i == 0) {\n                while (n %\
    \ i == 0) {\n                    n = n / i;\n                    largestPrimeFactor\
    \ = i;\n                }\n            }\n        }\n        return largestPrimeFactor;",
  "        long x = 2;\n        while (n > 1) {\n            long next = n%x;\n  \
    \          if (next == 0) {\n                return x;\n            }\n      \
    \      x = next;\n            n /= x;\n        }\n        return x;", "      \
    \  long x = 2;\n        while (n%x == 0) {\n            n = n / x;\n         \
    \   x++;\n        }\n        return n;", "        long maxPFactor = n;\n     \
    \   for (long i = 3; i * i <= n; i = i + 2) {\n            while (n % i == 0)\
    \ {\n                maxPFactor = i;\n                n = n / i;\n           \
    \ }\n        }\n        return maxPFactor;", "        long maxFactor = 1;\n  \
    \      while (n % maxFactor != 0) {\n            maxFactor++;\n        }\n   \
    \     if (maxFactor > Math.Sqrt(n)) {\n            maxFactor = Math.Sqrt(n);\n\
    \        }\n        return maxFactor;", "        // Test if n is prime by testing\
    \ if n is a prime\n        if (n <= 1) { return 1L; }\n\n        long p = 2L;\n\
    \        while (p < n) {\n            // If n is divisible by p, then no prime\
    \ factors exist below p. \n            if (n % p == 0) { return p; }\n       \
    \     p = p * 2L;\n        }\n\n        // If n is not divisible by any prime\
    \ factor in the range [2,n-1], then\n        // n is a prime number.\n       \
    \ return n;", "        // Check factorization condition\n        if (n == 1) return\
    \ 1;\n        if (n % 2 == 0 || n == 2) return 2;\n        if (n % 3 == 0) return\
    \ 3;\n        if (n % 5 == 0) return 5;\n        if (n % 7 == 0) return 7;\n \
    \       if (n % 11 == 0) return 11;\n        if (n % 13 == 0) return 13;\n   \
    \     if (n % 17 == 0) return 17;\n        if (n % 19 == 0) return 19;\n     \
    \   if (n % 23 == 0) return 23;\n        // Initialize variables\n        long\
    \ maxFactor = 1;\n        long nextPrime = 3;\n        long currentPrime = 2;\n\
    \        // Loop until factor exceeds threshold\n        while (maxFactor <= n\
    \ / 2) {\n            // Find the largest factor <= n\n            while (n %\
    \ currentPrime != 0) {\n                nextPrime = currentPrime + 1;\n      \
    \      }\n            // If next prime > n / 2, then no factor found\n       \
    \     if (nextPrime > n / 2) {\n                break;\n            }\n      \
    \      currentPrime = nextPrime;\n            maxFactor = maxFactor + 1;\n   \
    \     }\n        // Return the largest factor\n        return maxFactor;", " \
    \       if (n < 2)\n            return 0;\n        int k = 1, j = 2;\n       \
    \ while (k <= n / j)\n            if (n % j == 0)\n                j++;\n    \
    \        else {\n                if (j > k)\n                    break;\n    \
    \            j = 2;\n                k++;\n            }\n        return j;",
  "        var primes = Enumerable.Range(2, Int32.MaxValue).Where(i => n%i == 0).ToArray();\n\
    \        var factors = Enumerable.Range(2, Int32.MaxValue).Where(i => primes.Contains(n%i)).ToArray();\n\
    \        return factors.Aggregate((i, j) => Math.Max(i, j));", "        List<long>\
    \ factors = new List<long>();\n        long a = 2, b = 2, c = 2, d = 2;\n    \
    \    long maxFactor = 0;\n        long temp;\n        while (n > 2) {\n      \
    \      if (n % a == 0) {\n                factors.Add(a);\n                n =\
    \ n / a;\n            }\n            if (n % b == 0) {\n                factors.Add(b);\n\
    \                n = n / b;\n            }\n            if (n % c == 0) {\n  \
    \              factors.Add(c);\n                n = n / c;\n            }\n  \
    \          if (n % d == 0) {\n                factors.Add(d);\n              \
    \  n = n / d;\n            }\n        }\n        factors.Reverse();\n        foreach\
    \ (long f in factors) {\n            temp = a;\n            a = b;\n         \
    \   b = c;\n            c = d;\n            d = temp;\n            maxFactor =\
    \ f*maxFactor;\n        }\n        return maxFactor;", "        long result =\
    \ 2;\n        while (n > 1) {\n            while (n % result == 0) {\n       \
    \         result++;\n            }\n            n = (long) (Math.Sqrt(n) / result);\n\
    \        }\n        return result;", "        // TODO: return 0 if n is less than\
    \ 2, and throw an exception if n == 0\n        // TODO: make use of the Sieve\
    \ of Eratosthenes\n\n        // TODO: make this more efficient\n        List<long>\
    \ factors = new List<long>();\n        // TODO: make this more efficient\n   \
    \     long max = 0;\n\n        for (int x = 2; x <= Math.Sqrt(n); x++) {\n   \
    \         if (n % x == 0) {\n                factors.Add(x);\n               \
    \ max += x;\n            }\n        }\n\n        if (max > 1)\n            return\
    \ max;\n\n        factors.Reverse();\n        long maxFactor = factors.Last();\n\
    \n        return maxFactor;", "        long p = (long)Math.Floor(n);\n       \
    \ long i = 2;\n        while (p % 2 == 0) {\n            p = p * 2;\n        \
    \    i += 1;\n        }\n        for (long j = 3; j <= Math.Sqrt(n); j+=2) {\n\
    \            if (n % j == 0) {\n                p = p * 2;\n                while\
    \ ((n % j) == 0) {\n                    n = n / j;\n                }\n      \
    \          if (n > p) {\n                    p = n;\n                }\n     \
    \       }\n        }\n        return p;", "        long largestPrimeFactor = n;\n\
    \        int p = 2;\n        long maxPrime = 2;\n        long minPrime = 3;\n\
    \        while (p * p < largestPrimeFactor) {\n            while (largestPrimeFactor\
    \ % p == 0) {\n                largestPrimeFactor = largestPrimeFactor / p;\n\
    \            }\n            p++;\n            if (p * p > largestPrimeFactor)\
    \ {\n                maxPrime = p;\n                break;\n            }\n  \
    \          while ((largestPrimeFactor % p) == 0) {\n                largestPrimeFactor\
    \ = largestPrimeFactor / p;\n            }\n        }\n        if (largestPrimeFactor\
    \ != n) throw new Exception(\"not a prime factor\");\n        return maxPrime;",
  "        long limit = (long)Math.Sqrt(n);\n        int prime = 2;\n        while\
    \ (prime < limit) {\n            if (n % prime == 0) {\n                return\
    \ prime;\n            }\n            prime += 2;\n        }\n        return n;",
  "        // n is a prime\n        if (n < 1) return 0;\n        // find largest\
    \ prime factor for n\n        for (long i = 2; i <= n / 2; i++) {\n          \
    \  if (n % i == 0) return i;\n        }\n        // n is not prime\n        return\
    \ 1;", "        long largest = 0;\n        for (int i = 2; i <= n / i; i++) {\n\
    \            if (n % i == 0) {\n                largest = i;\n            }\n\
    \        }\n        return largest;", "        long largest_factor = 1L;\n   \
    \     for (int i = 2; i <= n; ++i) {\n            long factor = n / i;\n     \
    \       if (factor > largest_factor) {\n                largest_factor = factor;\n\
    \            }\n        }\n        return largest_factor;", "        List<long>\
    \ factors = new List<long>();\n        long i = 2;\n        long j = 1;\n    \
    \    while (true) {\n            if (n % i == 0) {\n                factors.Add(i);\n\
    \                while (n % i == 0) {\n                    n = n / i;\n      \
    \              i++;\n                }\n            }\n            else {\n  \
    \              break;\n            }\n            if (j > factors.Count) {\n \
    \               j = 1;\n            }\n        }\n        return factors.Max();",
  "        long result = 1;\n        long factor = 2;\n        while (factor <= n)\
    \ {\n            if (n % factor == 0) {\n                result *= factor;\n \
    \           }\n            factor++;\n        }\n        return result;", "  \
    \      long maxFactor = n, maxFactorPrime = 1;\n        // Loop invariant: maxFactor\
    \ >= 2 and maxFactorPrime >= 2\n        // maxFactor = n/maxFactorPrime < maxFactorPrime\n\
    \        // so if n/maxFactorPrime < maxFactorPrime and n is not prime\n     \
    \   // then maxFactor = n/maxFactorPrime = maxFactorPrime\n        for (long factor\
    \ = 2; factor < maxFactorPrime; factor++) {\n            long newFactorPrime =\
    \ n / factor;\n            if (newFactorPrime < maxFactorPrime) {\n          \
    \      // This factor is prime; so check if it is larger than maxFactor\n    \
    \            if (factor > maxFactor) {\n                    // It exceeds maxFactor,\
    \ so make it equal to maxFactor\n                    maxFactor = factor;\n   \
    \             }\n            } else if (newFactorPrime == maxFactorPrime) {\n\
    \                // It is not prime; so check if it is not larger than maxFactor\n\
    \                if (factor > maxFactor) {\n                    // It exceeds\
    \ maxFactor, so make it equal to maxFactor\n                    maxFactor = factor;\n\
    \                }\n            }\n        }\n        return maxFactor;", "  \
    \      Debug.Assert(n > 1L);\n        Debug.Assert(n != 2L);\n        long p =\
    \ n;\n        while (n > 2L) {\n            if (n % p == 0 || n == p)\n      \
    \          return p;\n            p++;\n        }\n        return p;", "     \
    \   BigInteger b = new BigInteger(n+\"\");\n        BigInteger p = b.TestBits(1)\
    \ ? 1 : b.Div(b+1).Mod(BigInteger.Two);\n        long res = BigInteger.Two;\n\
    \        while(p != 1) {\n            p = p.Div(b+1).Mod(BigInteger.Two);\n  \
    \          res = p.CompareTo(res) > 0 ? p.Value : res;\n        }\n        return\
    \ res;", "        long largestPrimeFactor = 2, curlargestPrimeFactor = 2;\n  \
    \      // Test only odd numbers\n        if (n % 2 == 0)\n            n = n /\
    \ 2;\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n\
    \ % i == 0) {\n                // Found a factor\n                if (n > curlargestPrimeFactor)\n\
    \                    largestPrimeFactor = curlargestPrimeFactor;\n           \
    \     curlargestPrimeFactor = i;\n            }\n        }\n        if (largestPrimeFactor\
    \ == 2)\n            return 2;\n        else\n            return largestPrimeFactor;",
  '        return n.ToString().Length > 1 ? LargestPrimeFactor(GetFactorsOf(n).Max())
    : n;', "        long n = 1;\n        long k = 1;\n        int j;\n        long\
    \ maxp = 0;\n        for (int i = 2; i <= n; i++) {\n            for (j = 0; j\
    \ < i; j++) {\n                if (n % i == 0) {\n                    k = i;\n\
    \                    break;\n                }\n            }\n            if\
    \ (k > maxp) {\n                maxp = k;\n                n = k;\n          \
    \  }\n        }\n        return maxp;", "        bool prime = true;\n        long\
    \ factor = 2;\n        while (prime && factor <= n) {\n            prime = false;\n\
    \            for (int i = 3; i <= Math.Sqrt(factor); i += 2) {\n             \
    \   if (n % i == 0) {\n                    prime = true;\n                }\n\
    \            }\n            factor++;\n        }\n        return factor;", " \
    \       var factors = new List<long>();\n        for (var p = 2; p < n / p; ++p)\
    \ {\n            if (n % p == 0) factors.Add(p);\n        }\n        return factors.Count\
    \ == 0 ? 1 : factors.Max();", "        if (n == 1)\n            return 1;\n  \
    \      long result = n;\n        while (n > 1) {\n            n = n / 2;\n   \
    \         if (n % 2 == 0)\n                n--;\n            if (n % 3 == 0)\n\
    \                n--;\n            if (n % 5 == 0)\n                n--;\n   \
    \         if (n % 7 == 0)\n                n--;\n            if (n % 11 == 0)\n\
    \                n--;\n            if (n % 13 == 0)\n                n--;\n  \
    \          if (n % 17 == 0)\n                n--;\n            if (n % 19 == 0)\n\
    \                n--;\n            if (n % 23 == 0)\n                n--;\n  \
    \          if (n % 29 == 0)\n                n--;\n        }\n        return result;",
  "        // We do not need to check for factors greater than 2 because\n       \
    \ // any factor greater than 2 will be factors of 2, 3, 5,\n        // or 7.\n\
    \        if (n == 2) return 2;\n        bool hasPrimeFactor = CheckPrimeFactor(n);\n\
    \        long maxFactor;\n        if (hasPrimeFactor) {\n            maxFactor\
    \ = 3;\n            while (n/maxFactor > 1) maxFactor++;\n        } else {\n \
    \           maxFactor = 2;\n            while (n/maxFactor > 1) maxFactor++;\n\
    \        }\n        return maxFactor;", "        long p = 2;\n        for (long\
    \ i = 3; i <= n; i += 2) {\n            while (n % i == 0) {\n               \
    \ p = i;\n                n /= i;\n            }\n        }\n        return p;",
  "        long res = n;\n        long a = 2, b = 2;\n        while (b <= Math.Sqrt(n))\
    \ {\n            if (n % a == 0) {\n                a = a + 1;\n             \
    \   if (n % a == 0) {\n                    res = Math.Max(res, b);\n         \
    \           b = b + 1;\n                } else {\n                    b = b +\
    \ 1;\n                }\n            } else {\n                b = b + 1;\n  \
    \          }\n        }\n        return res;", "        long largest = 2;\n  \
    \      for (long i = 2; i <= n / 2; i++) {\n            if (n % i == 0) {\n  \
    \              largest = i;\n                break;\n            }\n        }\n\
    \        return largest;", "        long largestPrimeFactor = n;\n        long\
    \ prime = 2;\n        while (prime <= largestPrimeFactor) {\n            if (n\
    \ % prime == 0) {\n                largestPrimeFactor = prime;\n             \
    \   break;\n            }\n            prime++;\n        }\n        return largestPrimeFactor;",
  "        var f = new List<long>();\n        long k = 2;\n        while (n >= k)\
    \ {\n            if (n % k == 0) {\n                f.Add(k);\n              \
    \  n = n / k;\n            }\n            else {\n                k++;\n     \
    \       }\n        }\n        long maxFactor = f.Max();\n        if (n != 0) {\n\
    \            f.Add(n);\n        }\n        return maxFactor;", "        var result\
    \ = 2;\n        while (n % result == 0)\n            result++;\n        // now\
    \ we're sure that result > 1\n        while (n % result == 0)\n            result\
    \ /= 2;\n        return result;", "        // Sieve of Erastothenes on n and store\
    \ in primes[]\n        long[] primes = new long[n];\n        primes[0] = 2L;\n\
    \        primes[1] = 2L;\n        primes[2] = 2L;\n        primes[3] = 1L;\n \
    \       primes[4] = 1L;\n        primes[5] = 6L;\n        primes[6] = 2L;\n  \
    \      primes[7] = 2L;\n        primes[8] = 1L;\n        primes[9] = 2L;\n   \
    \     primes[10] = 2L;\n        primes[11] = 1L;\n        primes[12] = 2L;\n \
    \       primes[13] = 8L;\n        primes[14] = 1L;\n        primes[15] = 1L;\n\
    \        primes[16] = 2L;\n        primes[17] = 2L;\n        primes[18] = 1L;\n\
    \        primes[19] = 4L;\n        primes[20] = 3L;\n        primes[21] = 3L;\n\
    \        primes[22] = 7L;\n        primes[23] = 2L;\n        primes[24] = 1L;\n\
    \        primes[25] = 1L;\n        primes[26] = 1L;\n        primes[27] = 1L;\n\
    \        primes[28] = 5L;\n        primes[29] = 2L;\n        // Sieve of Eratosthenes\
    \ on the first prime in the list\n        int p = 0;\n        long firstPrime\
    \ = primes[p];\n        while (p < primes.Length) {\n            for (int i =\
    \ p * 2; i <= primes.Length && primes[i] < firstPrime; i++) {\n              \
    \  primes[i] = primes[i + 1];\n            }\n            p++;\n        }\n  \
    \      // Real sieve to find first prime > n\n        long firstPrimeReal = firstPrime;\n\
    \        while (firstPrimeReal <= n) {\n            firstPrimeReal += primes[firstPrimeReal];\n\
    \        }\n        return firstPrimeReal;", "        long factor = 2;\n     \
    \   while (factor <= n) {\n            // Try every even number starting with\
    \ 2\n            while (n % factor == 0) {\n                factor++;\n      \
    \      }\n            if (factor <= n) {\n                n = n / factor;\n  \
    \          }\n        }\n        return factor;", "        long factor = 2;\n\
    \        long largestPrimeFactor = 2;\n        while (n > 1) {\n            while\
    \ (n % factor == 0) {\n                if (factor * factor > n) {\n          \
    \          break;\n                }\n                n /= factor;\n         \
    \       largestPrimeFactor++;\n            }\n            factor++;\n        }\n\
    \        return largestPrimeFactor;", "        if (n < 2) return 1;\n        //\
    \ Use Sieve to find the prime factors of n.\n        var factors = new List<long>();\n\
    \        factors.Add(2);\n        foreach (var p in GetPrimeFactors(n)) {\n  \
    \          if (factors.Contains(p)) continue;\n            factors.Add(p);\n \
    \       }\n        return factors.Max();", "        long largestPrimeFactor =\
    \ 1, p = 2;\n        while (n > 1) {\n            if (n % p == 0) return n;\n\
    \            p = p * 2;\n        }\n        while (p <= n / 2) {\n           \
    \ largestPrimeFactor = p;\n            p *= 2;\n            if (p > n) return\
    \ largestPrimeFactor;\n        }\n        return largestPrimeFactor;", "     \
    \   var largestPrimeFactor = 0;\n        var maxFactor = 2;\n        while (n\
    \ % maxFactor != 0) {\n            while (n % maxFactor != 0) {\n            \
    \    if (maxFactor % 2 == 0 && maxFactor != 2) {\n                    largestPrimeFactor\
    \ = maxFactor;\n                    break;\n                }\n              \
    \  maxFactor++;\n            }\n            maxFactor++;\n        }\n        return\
    \ largestPrimeFactor;", "        if (n % 2 == 0) {\n            return 2;\n  \
    \      }\n        int max = 3;\n        while (n % max == 0 && max < Math.Sqrt(n))\
    \ {\n            max += 2;\n        }\n        if (max == Math.Sqrt(n)) {\n  \
    \          return n;\n        }\n        var result = 2;\n        while (result\
    \ < n) {\n            if (n % result == 0) {\n                result = max;\n\
    \            } else {\n                max += 2;\n            }\n        }\n \
    \       return result;", "        if (n < 2) {\n            return 1;\n      \
    \  }\n        long result = 2;\n        while (n % result != 0) {\n          \
    \  result++;\n        }\n        return result;", "        var m = 1L;\n     \
    \   var d = 2L;\n        var result = 1L;\n        long limit = long.MaxValue;\n\
    \        bool isPrime = true;\n        while (limit < n) {\n            var q\
    \ = m / d;\n            var r = n % d;\n            var s = d * r;\n         \
    \   if (s == long.MaxValue) {\n                Console.WriteLine(\"n={0}\", n);\n\
    \                Console.WriteLine(\"m={0}\", m);\n                Console.WriteLine(\"\
    d={0}\", d);\n                Console.WriteLine(\"limit={0}\", limit);\n     \
    \           Console.WriteLine(\"m={0}\", m);\n                Console.WriteLine(\"\
    d={0}\", d);\n                Console.WriteLine(\"limit={0}\", limit);\n     \
    \           Console.WriteLine(\"q={0}\", q);\n                Console.WriteLine(\"\
    r={0}\", r);\n                Console.WriteLine(\"q*d={0}\", q * d);\n       \
    \         Console.WriteLine(\"r*d={0}\", r * d);\n                Console.WriteLine(\"\
    q*d+r*d={0}\", (q * d) + r * d);\n                Console.WriteLine(\"{0}\", isPrime);\n\
    \                isPrime = true;\n                if (q*d <= limit) {\n      \
    \              limit = q*d;\n                    result = r;\n               \
    \ }\n            }\n            else {\n                if (q*d == n) {\n    \
    \                limit = r*d;\n                    result = s;\n             \
    \       isPrime = false;\n                }\n                else {\n        \
    \            m *= d;\n                    if (q*d > limit) {\n               \
    \         limit = q*d;\n                        result = r;\n                \
    \        isPrime = false;\n                    }\n                    else {\n\
    \                        d *= d;\n                        isPrime = true;\n  \
    \                  }\n                }\n            }\n        }\n        return\
    \ result;", "        if (n == 1) return 1;\n        if (n % 2 == 0) return 2;\n\
    \        long[] primes = new long[] { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,\
    \ 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\
    \ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\
    \ 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\
    \ 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\
    \ 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\
    \ 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,\
    \ 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\
    \ 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n        for (int i = 2;\
    \ i < n; i++) {\n            long candidate = i;\n            bool isPrime = true;\n\
    \            long sqrtOfI = Convert.ToInt64(Math.Sqrt(i));\n            while\
    \ (true) {\n                bool isCandidatePrime = true;\n                for\
    \ (int j = 0; j < primes.Length; j++) {\n                    if (candidate%primes[j]\
    \ == 0) isCandidatePrime = false;\n                }\n                if (isCandidatePrime)\
    \ break;\n                if (candidate < sqrtOfI) candidate++;\n            \
    \    else {\n                    if (isPrime) isPrime = false;\n             \
    \       break;\n                }\n            }\n            if (isPrime) return\
    \ candidate;\n        }\n        return n;", "        // Return largest prime\
    \ factor\n        long i = 2;\n        while (n % i == 0) {\n            if (i\
    \ * i > n) {\n                break;\n            }\n            i++;\n      \
    \  }\n        return i;", "        long maxDivisor = long.MinValue;\n        while\
    \ (n % 2 == 0) {\n            maxDivisor *= 2;\n            n /= 2;\n        }\n\
    \        long lastFactor = 1;\n        while (n % lastFactor == 0) {\n       \
    \     maxDivisor *= lastFactor;\n            n /= lastFactor;\n            lastFactor++;\n\
    \        }\n        return maxDivisor;", "        long largestPrimeFactor = n;\n\
    \        for (long i = 2; i < n; i++) {\n            while (n % i == 0) {\n  \
    \              largestPrimeFactor = i;\n                n /= i;\n            }\n\
    \        }\n        return largestPrimeFactor;", '        return Factorization(n).Max();',
  "        // Find largest factor of n\n        long factor = 1;\n        while (n\
    \ > factor) {\n            factor += 2;\n        }\n        while (n >= 2) {\n\
    \            if (n % factor == 0) {\n                break;\n            }\n \
    \           factor += 2;\n            n /= factor;\n        }\n        return\
    \ factor;", "        long i = 2;\n        while (i <= Math.Sqrt(n)) {\n      \
    \      bool isPrime = true;\n            long prime = 2;\n            while (i\
    \ <= Math.Sqrt(n)) {\n                bool isPrimeDivisor = false;\n         \
    \       if (i % prime == 0) {\n                    isPrimeDivisor = true;\n  \
    \              }\n                if (isPrimeDivisor == true) {\n            \
    \        isPrime = false;\n                    break;\n                }\n   \
    \             prime++;\n                i++;\n            }\n            if (isPrime\
    \ == true) {\n                return prime;\n            }\n            i++;\n\
    \        }\n        return -1;", "        long result = 1;\n        long max =\
    \ n;\n        while (n > result) {\n            long m = n / result;\n       \
    \     result = m;\n            if (m < max) {\n                max = m;\n    \
    \        }\n        }\n        return result;", "        if (n < 2) return 1;\n\
    \        long i = 2;\n        while (i <= sqrt(n)) {\n            if (n % i ==\
    \ 0) {\n                i += 2;\n                while (n % i == 0) {\n      \
    \              i += 2;\n                }\n                return i;\n       \
    \     }\n            i += 2;\n        }\n        return n;", "        long factor\
    \ = 2;\n        while (true) {\n            if (IsPrime(factor * factor)) break;\n\
    \            if (IsPrime(factor)) factor++;\n        }\n        return factor;",
  "        if (n < 2) throw new ArgumentOutOfRangeException(\"n\");\n        long\
    \ factor = 2L;\n        long maxFactor = n;\n        while (factor <= maxFactor)\
    \ {\n            if (n % factor == 0) {\n                maxFactor = n / factor;\n\
    \                break;\n            }\n            factor++;\n        }\n   \
    \     return maxFactor;", "        long largestPrime = 0;\n        long largestFactor\
    \ = 1;\n        for (int i = 2; i <= Math.Sqrt(n); ++i) {\n            long divisor\
    \ = n / i;\n            if (divisor > largestFactor) {\n                largestFactor\
    \ = divisor;\n                largestPrime = i;\n            }\n        }\n  \
    \      return largestPrime;", "        List<long> factors = new List<long>();\n\
    \        for (long i = 2; i <= Math.Sqrt(n); i++) {\n            if (n % i ==\
    \ 0)\n                break;\n            factors.Add(i);\n        }\n       \
    \ if (n > 1) {\n            while (true) {\n                long product = 1;\n\
    \                foreach (long factor in factors) {\n                    product\
    \ *= factor;\n                }\n                if (product > n) {\n        \
    \            factors.Remove(factors.First());\n                }\n           \
    \     else {\n                    break;\n                }\n            }\n \
    \       }\n        return factors.First();", "        if (n % 2 == 0) {\n    \
    \        return 2;\n        }\n        long maxPrime = 0;\n        int sqrtN =\
    \ Convert.ToInt32(Math.Sqrt(n));\n        long maxPrimeFactor = Convert.ToInt64(Math.Pow(System.Environment.TickCount,\
    \ 2));\n        while (sqrtN > 2) {\n            long sqrtN = Convert.ToInt32(Math.Sqrt(n));\n\
    \            while (sqrtN > 2) {\n                long sqrtN = Convert.ToInt32(Math.Sqrt(n));\n\
    \                if (n % sqrtN == 0) {\n                    long m = Convert.ToInt64(Math.Sqrt(n));\n\
    \                    long x = Convert.ToInt32(Math.Sqrt(n));\n               \
    \     if (m % x == 0) {\n                        long y = Convert.ToInt32(Math.Sqrt(n));\n\
    \                        if (y % x == 0) {\n                            long t\
    \ = Convert.ToInt32(Math.Sqrt(n));\n                            if (t % x == 0)\
    \ {\n                                long u = Convert.ToInt64(Math.Sqrt(n));\n\
    \                                long m = Convert.ToInt32(Math.Sqrt(n));\n   \
    \                             if (m % x == 0) {\n                            \
    \        maxPrimeFactor = y;\n                                    maxPrimeFactor\
    \ = x;\n                                    maxPrime = m;\n                  \
    \                  break;\n                                }\n               \
    \             }\n                        }\n                    }\n          \
    \      }\n                n = n;\n                sqrtN = sqrtN / 2;\n       \
    \     }\n            maxPrime = maxPrime + 2;\n            n = n * 3;\n      \
    \  }\n        if (maxPrime < Convert.ToInt64(Math.Pow(System.Environment.TickCount,\
    \ 2))) {\n            maxPrimeFactor = Convert.ToInt64(Math.Pow(System.Environment.TickCount,\
    \ 2));\n        }\n        return (long)(maxPrimeFactor * Math.Pow(System.Environment.TickCount,\
    \ 2));", "        long maxFactor = 2;\n        long test = 2;\n        while (test\
    \ < n) {\n            long testMultiple = (2 * test);\n            while (testMultiple\
    \ < n) {\n                if (n % testMultiple == 0) {\n                    maxFactor\
    \ = test;\n                    n = n / testMultiple;\n                    break;\n\
    \                }\n                testMultiple++;\n            }\n         \
    \   test++;\n        }\n        return maxFactor;", "        long result = 1;\n\
    \        bool isPrime = true;\n        while (n > 1) {\n            long factor\
    \ = 2;\n            while (factor <= Math.Floor(Math.Sqrt(n))) {\n           \
    \     if (n % factor == 0) {\n                    n /= factor;\n             \
    \   } else {\n                    isPrime = false;\n                    break;\n\
    \                }\n                factor++;\n            }\n            if (isPrime)\
    \ {\n                result = Math.Max(result, factor);\n            }\n     \
    \   }\n        return result;", "        long largestPrimeFactor = 2;\n      \
    \  while (n >= 2) {\n            long i = 2;\n            while (i < n && n %\
    \ i == 0) {\n                i += 2;\n            }\n            if (i > largestPrimeFactor)\
    \ {\n                largestPrimeFactor = i;\n            }\n            n /=\
    \ largestPrimeFactor;\n        }\n        return largestPrimeFactor;", "     \
    \   if (n < 2) {\n            return n;\n        }\n\n        long largestPrimeFactor\
    \ = 2;\n        long sqrtN = (long)Math.Sqrt(n);\n\n        while (sqrtN > 1)\
    \ {\n            long factorOfN = (long)Math.Sqrt(n);\n            bool isPrime\
    \ = true;\n\n            for (int i = 3; i <= factorOfN; i += 2) {\n         \
    \       if (n % i == 0) {\n                    isPrime = false;\n            \
    \        break;\n                }\n            }\n\n            if (isPrime)\
    \ {\n                largestPrimeFactor = factorOfN;\n                break;\n\
    \            }\n            n /= largestPrimeFactor;\n        }\n        return\
    \ largestPrimeFactor;", "        if (n < 1)\n            return 0;\n\n       \
    \ long pf = n;\n        while (n > 1) {\n            long p = (long) Math.Floor(Math.Sqrt(n));\n\
    \            if (n % p == 0)\n                n = p << 1;\n            else {\n\
    \                while (n % p == 0)\n                    n /= p;\n           \
    \     pf = p;\n            }\n        }\n\n        return pf;", "        // If\
    \ n is greater than 1 million then return -1 and tell the user.\n        if (n\
    \ > 10000000) return -1;\n        // Use Sieve of Eratosthenes method to eliminate\
    \ all primes less than n.\n        long[] primes = { 2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,\
    \ 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,\
    \ 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277,\
    \ 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\
    \ 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,\
    \ 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,\
    \ 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677,\
    \ 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\
    \ 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907,\
    \ 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n        if\
    \ (n < 2) return 2;\n        long[] sqr = new long[n];\n        // Divide each\
    \ number in primes by all numbers in sqr\n        for (int i = 0; i < primes.Length;\
    \ i++) {\n            for (int j = 0; j < primes.Length; j++) {\n            \
    \    sqr[i] = sqr[i] + primes[j] * primes[i];\n            }\n        }\n    \
    \    // Find all factors of n by eliminating each number in sqr except for one.\n\
    \        for (int i = 0; i < sqr.length; i++) {\n            if (sqr[i] == n)\
    \ return sqr[i];\n        }\n        return -1;", "        long x = 3L;\n    \
    \    long result = 1;\n        long remainder = n;\n\n        while (result <=\
    \ x) {\n            if (n % result != 0) {\n                result += 1;\n   \
    \         }\n            while (n % result == 0) {\n                n /= result;\n\
    \                result += 1;\n            }\n        }\n\n        if (n > 2)\
    \ {\n            result += 1;\n        }\n        return result;", "        long\
    \ p = 1;\n        long q = 1;\n        while (p <= n/p) {\n            q = (p\
    \ * q) % n;\n            p = q;\n        }\n        return p * (n - p);", "  \
    \      List<long> primeFactors = new List<long>();\n        long n = n;\n    \
    \    long largestPrimeFactor = 1;\n        long currentMax = 2;\n\n        while\
    \ (n > 1) {\n            while (n % currentMax == 0) {\n                primeFactors.Add(currentMax);\n\
    \                currentMax++;\n            }\n            n = n / currentMax;\n\
    \        }\n        if (currentMax > 2) {\n            primeFactors.Add(currentMax);\n\
    \        }\n        primeFactors.Sort();\n\n        return primeFactors[0];",
  "        long factor = 2;\n        while (n > 1) {\n            // Test for factors\
    \ up to n.\n            if (n % factor == 0) {\n                long newFactor\
    \ = factor;\n                while (n / factor > factor) {\n                 \
    \   newFactor++;\n                }\n                n = n / newFactor;\n    \
    \            factor = newFactor;\n            } else {\n                factor++;\n\
    \            }\n        }\n        return factor;", "        long d = 2;\n   \
    \     while ((n % d) != 0) {\n            d = d << 1;\n        }\n        while\
    \ (d <= n) {\n            if (n % d == 0) {\n                return d;\n     \
    \       }\n            d = d + 1;\n        }\n        return n;", "        long\
    \ max_prime = 1;\n        long next_prime = 2;\n        while (next_prime < n)\
    \ {\n            if (n % next_prime == 0) {\n                max_prime = next_prime;\n\
    \            }\n            next_prime += 2;\n        }\n        return max_prime;",
  "        long p = 2;\n        long q = 3;\n        while (p < n) {\n           \
    \ while (q * p < n) {\n                if (n % q == 0) {\n                   \
    \ return q;\n                }\n                q++;\n            }\n        \
    \    p++;\n        }\n        return n;", "        // Prime factors\n        int[]\
    \ factors = new int[n];\n        factors[0] = 2;\n        factors[1] = (long)Math.Sqrt((double)n);\n\
    \        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i\
    \ == 0) {\n                factors[2] = (long)i;\n                for (int j =\
    \ 3; i*j <= n; j++)\n                    if (n % j == 0)\n                   \
    \     factors[(long)j] = (long)i;\n                break;\n            }\n   \
    \     }\n        // Max prime factor\n        long max = 1;\n        for (int\
    \ i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (factors[i] != 1)\n  \
    \              max = Math.Max(max, factors[i]);\n        }\n        return max;",
  "        long maxFactor = 1;\n        long factor = 2;\n        while (factor <\
    \ n) {\n            if (n % factor == 0) {\n                maxFactor = factor;\n\
    \                while (n % factor == 0) {\n                    n = n / factor;\n\
    \                }\n            }\n            factor++;\n        }\n        return\
    \ maxFactor;", "        long p = 2;\n        while (p < n) {\n            if (n\
    \ % p == 0) {\n                // If n is not a prime factor of p \n         \
    \       // or n is a prime factor of p, n is largest.\n                return\
    \ n;\n            }\n            else {\n                long q = (p + 1) >> 1;\n\
    \                if (n % q == 0) {\n                    p = q;\n             \
    \   }\n                else {\n                    p = p + 2;\n              \
    \  }\n            }\n        }\n        return n;", "        // Find prime factors\
    \ of n to limit the search range\n        List<int> factors = new List<int>();\n\
    \        BigInteger divisor = new BigInteger(\"2\");\n        for (long i = 1;\
    \ i <= n; i++)\n        {\n            BigInteger temp = new BigInteger(i.ToString());\n\
    \            BigInteger d = new BigInteger(\"1\");\n            while (temp.Divide(d).CompareTo(divisor)\
    \ > 0)\n            {\n                divisor = divisor.Divide(temp);\n     \
    \       }\n            factors.Add(i);\n        }\n        long res = factors.Max();\n\
    \        for (long i : factors)\n        {\n            if (n % i == 0)\n    \
    \        {\n                res = i;\n                break;\n            }\n\
    \        }\n        return res;", "        // Start with 2\n        long i = 2;\n\
    \n        // While n is not prime...\n        while ((n % i) != 0) {\n       \
    \     // Increment i until it is prime.\n            while (n % i == 0)\n    \
    \            i++;\n\n            // If n is divisible by i, then n is a prime\
    \ number.\n            if (i == n)\n                return i;\n        }\n\n \
    \       // Return n if n is not a prime number.\n        return n;", "       \
    \ // Test for prime first\n        if (n == 1) return n;\n        // If n is prime,\
    \ then the largest prime factor is 2\n        if (IsPrime(n)) return 2;\n\n  \
    \      // Set up a list to hold factors\n        List<long> factors = new List<long>();\n\
    \n        // Start with 2 factors, then try odd numbers first, then even numbers\n\
    \        for (int i = 2; i <= n / 2; i++) {\n            // If a factor of n is\
    \ found, return the factor\n            if (n % i == 0) {\n                return\
    \ i;\n            }\n            // If a factor is not found (n % i == 0), then\
    \ divide n by i and try again\n            while (n % i == 0) {\n            \
    \    factors.Add(i);\n                n /= i;\n            }\n        }\n\n  \
    \      // If n is prime, then return the largest factor\n        if (IsPrime(n))\
    \ return factors.Last();\n\n        // We should never get here\n        throw\
    \ new Exception(\"n \" + n + \" is composite\");", "        // Only need to test\
    \ odd numbers.\n        if (n & 1 == 0) {\n            long i = 2;\n         \
    \   long max = 2;\n            while (i <= n / i) {\n                long temp\
    \ = (i + 1) % n;\n                if (temp > max) {\n                    max =\
    \ temp;\n                }\n                i += 2;\n            }\n         \
    \   return max;\n        } else {\n            long max = 2;\n            long\
    \ min = (n - 1) >> 1;\n            while (max < (min << 1)) {\n              \
    \  long temp = n;\n                while (temp % max == 0) {\n               \
    \     temp /= max;\n                }\n                if (temp > min) {\n   \
    \                 max = temp;\n                }\n            }\n            return\
    \ max;\n        }", "        long x = 2;\n        while (n > 1) {\n          \
    \  long y = x;\n            long z = 1;\n            while (y <= n) {\n      \
    \          if (n % y == 0) {\n                    z = z * y;\n               \
    \     while (n / y != 0) {\n                        y++;\n                   \
    \ }\n                    y -= 1;\n                } else {\n                 \
    \   y++;\n                }\n            }\n            if (z == x) {\n      \
    \          x = z;\n            }\n            n--;\n        }\n        return\
    \ x;", "        long max = 2L;\n        while (n % max != 0) {\n            max++;\n\
    \        }\n        while (n > max) {\n            if (n % max == 0) {\n     \
    \           return max;\n            }\n            max++;\n        }\n      \
    \  return n;", "        if (n < 2) {\n            return 1;\n        }\n     \
    \   // Sieve of Eratosthenes\n        // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        List<long> primes = new List<long>();\n        primes.Add(2);\n     \
    \   primes.Add(3);\n        primes.Add(5);\n\n        for (int p = 2; p <= n;\
    \ p++) {\n            // Check all odd factors\n            bool isPrime = true;\n\
    \            for (int i = 3; i * i <= p; i += 2) {\n                if (p % i\
    \ == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            // If not prime, add to list\n\
    \            if (!isPrime) {\n                primes.Add(p);\n            }\n\
    \        }\n        return primes[primes.Count - 1];", "        long num = (long)Math.Sqrt(n);\n\
    \        long factor = 1;\n        while (n / factor != 0) {\n            ++factor;\n\
    \        }\n        if (num < factor) {\n            return factor;\n        }\n\
    \        return -1;", "        // We start with a large prime number to help us\
    \ avoid\n        // needing to test for divisibility by anything less than 2\n\
    \        long maxPrime = long.MaxValue;\n        // Prime numbers less than this\
    \ are not considered\n        long minPrime = long.MinValue;\n        // The first\
    \ prime we try dividing by is 2\n        long prime = 2;\n        // Divide n\
    \ by every prime less than maxPrime to find the\n        // largest prime factor\n\
    \        while (n != 1) {\n            // If a number greater than maxPrime divides\
    \ n, then n\n            // is not prime\n            if (n % prime == 0) {\n\
    \                n = n / prime;\n                if (n > maxPrime) {\n       \
    \             maxPrime = prime;\n                }\n            }\n          \
    \  // If a number is divisible by a prime number, then n\n            // is not\
    \ a prime number.\n            else {\n                minPrime = prime;\n   \
    \             prime = prime + 1;\n            }\n        }\n        // The largest\
    \ prime factor is maxPrime + 1\n        return maxPrime + 1;", "        long largestPrimeFactor\
    \ = Long.MaxValue;\n        long currentPrime = 2L;\n        while (true) {\n\
    \            long temp = Math.Sqrt(currentPrime);\n            if (n % temp ==\
    \ 0) return temp;\n            if (temp * temp > n) currentPrime += temp;\n  \
    \          else break;\n        }\n        return largestPrimeFactor;"]
stop_tokens:
- "\n    }\n"
