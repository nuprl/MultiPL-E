language: cs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var strings = paren_string.Split(' ');\n        var\
    \ stack = new Stack<long>();\n        var list = new List<long>();\n        long\
    \ nesting = 0;\n        foreach (string s in strings) {\n            int open\
    \ = s.IndexOf('(');\n            int close = s.IndexOf(')');\n            if (open\
    \ != -1 && close != -1 && open > close) {\n                string left_s = s.Substring(0,\
    \ open);\n                string right_s = s.Substring(close + 1);\n         \
    \       list.Add(new long[] { ParseNestedParens(left_s)[0].Max() + 1, ParseNestedParens(right_s)[0].Max()\
    \ + 1 });\n                nesting = Math.Max(nesting, ParseNestedParens(left_s)[0].Max()\
    \ + 1, ParseNestedParens(right_s)[0].Max() + 1);\n            } else if(open !=\
    \ -1 && close != -1) {\n                string s = s;\n                list.Add(new\
    \ long[] { ParseNestedParens(s)[0].Max() + 1, ParseNestedParens(s)[0].Max() +\
    \ 1 });\n                nesting = Math.Max(nesting, ParseNestedParens(s)[0].Max()\
    \ + 1, ParseNestedParens(s)[0].Max() + 1);\n            } else if(open != -1)\
    \ {\n                string left_s = s;\n                list.Add(new long[] {\
    \ ParseNestedParens(left_s)[0].Max() + 1, ParseNestedParens(s)[0].Max() + 1 });\n\
    \                nesting = Math.Max(nesting, ParseNestedParens(left_s)[0].Max()\
    \ + 1, ParseNestedParens(s)[0].Max() + 1);\n            } else if(close != -1)\
    \ {\n                string right_s = s;\n                list.Add(new long[]\
    \ { ParseNestedParens(s)[0].Max() + 1, ParseNestedParens(right_s)[0].Max() + 1\
    \ });\n                nesting = Math.Max(nesting, ParseNestedParens(s)[0].Max()\
    \ + 1, ParseNestedParens(right_s)[0].Max() + 1);\n            } else {\n     \
    \           string s = s;\n                list.Add(new long[] { ParseNestedParens(s)[0].Max()\
    \ + 1, ParseNestedParens(s)[0].Max() + 1 });\n                nesting = Math.Max(nesting,\
    \ ParseNestedParens(s)[0].Max() + 1, ParseNestedParens(s)[0].Max() + 1);\n   \
    \         }\n        }\n        list.Add(new long[] { nesting, nesting });\n \
    \       return new List<long>(list);\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnyhju8ed.cs(25,39): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(25,79): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(26,45): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(26,85): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(28,24): error CS0136: A local or parameter named ''s'' cannot
    be declared in this scope because that name is used in an enclosing local scope
    to define a local or parameter

    /tmp/tmpnyhju8ed.cs(29,39): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(29,74): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(30,45): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpnyhju8ed.cs(30,80): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    req'
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Start with root node containing depth 1\n      \
    \  var root = new Node(1L);\n        // Go through each character in string\n\
    \        for (int i = 0; i < paren_string.Length; i++) {\n            // If current\
    \ character is a left paren, add a new node with depth equal to current node depth\
    \ + 1\n            if (paren_string[i] == '(') {\n                root.Children.Add(new\
    \ Node(root.Depth + 1));\n            }\n            // If current character is\
    \ a right paren, add a new node with depth equal to current node depth - 1\n \
    \           else if (paren_string[i] == ')') {\n                var node = root.Children[root.Depth\
    \ - 1];\n                if (node.Depth > 1) {\n                    node.Children.Add(new\
    \ Node(node.Depth - 1));\n                }\n            }\n            // If\
    \ current character is a space, ignore it and increase the depth by 1\n      \
    \      else if (paren_string[i] == ' ') {\n                root.Depth++;\n   \
    \         }\n            // If current character is not an opening parentheses,\
    \ increase the depth by 1\n            else {\n                root.Depth++;\n\
    \            }\n        }\n        // If the root node has multiple children,\
    \ recursively find the deepest level of nesting and output the maximum value.\n\
    \        // If there is only a single child, simply output the maximum value of\
    \ the root node.\n        var deepest_level = root.Children.Max(n => n.Children.Max(c\
    \ => c.Depth));\n        if (root.Children.Count > 1) {\n            return ParseNestedParens(paren_string,\
    \ deepest_level);\n        }\n        return deepest_level;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpehyl2n5v.cs(16,24): error CS0246: The type or namespace name ''Node''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpehyl2n5v.cs(21,39): error CS0246: The type or namespace name ''Node''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpehyl2n5v.cs(27,43): error CS0246: The type or namespace name ''Node''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> level_nesting = new List<long>();\n    \
    \    Stack<long> level_stack = new Stack<long>();\n        char[] paren_stack\
    \ = new char[paren_string.Length];\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            paren_stack[i] = paren_string[i];\n        }\n        long\
    \ level = 0;\n        bool has_rightmost = false;\n        string token;\n   \
    \     bool is_opening_bracket = false;\n        bool is_closing_bracket = false;\n\
    \        bool has_right_brace = false;\n        bool has_right_curly = false;\n\
    \        int right_curly_count = 0;\n        bool has_right_paren = false;\n \
    \       bool has_right_brace_or_curly = false;\n        while (true) {\n     \
    \       if (has_right_paren && right_curly_count == 0 && paren_stack[0] == '('\
    \ && paren_stack[paren_stack.Length - 1] == ')') {\n                has_right_paren\
    \ = false;\n            }\n            if (!level_nesting.Contains(level)) {\n\
    \                level_nesting.Add(level);\n            }\n            if (!level_stack.Contains(level))\
    \ {\n                level_stack.Push(level);\n            }\n            if (paren_stack[0]\
    \ == '(') {\n                if (!is_closing_bracket) {\n                    token\
    \ = paren_stack[0];\n                    if (token.Equals(\"(\")) {\n        \
    \                is_opening_bracket = true;\n                        level_stack.Push(level);\n\
    \                    } else if (token.Equals(\")\")) {\n                     \
    \   if (has_right_paren && has_right_brace && !is_closing_brace) {\n         \
    \                   if (paren_stack[paren_stack.Length - 1] == '(') {\n      \
    \                          level_nesting.Add(level_nesting.Count + 1);\n     \
    \                       } else {\n                                level_nesting.Add(level_nesting.Count\
    \ - 1);\n                            }\n                            if (level_nesting.Count\
    \ == 0) {\n                                return level_nesting;\n           \
    \                 }\n                            level++;\n                  \
    \      }\n                    } else if (token.Equals(\"{\")) {\n            \
    \            if (has_right_paren && has_right_brace && !is_closing_brace) {\n\
    \                            if (paren_stack[paren_stack.Length - 1] == '(') {\n\
    \                                level_nesting.Add(level_nesting.Count + 1);\n\
    \                            } else {\n                                level_nesting.Add(level_nesting.Count\
    \ - 1);\n                            }\n                            if (level_nesting.Count\
    \ == 0) {\n                                return level_nesting;\n           \
    \                 }\n                            level++;\n                  \
    \      }\n                    } else if (token.Equals(\"}\")) {\n            \
    \            if (has_right_paren && has_right_brace) {\n                     \
    \       if (paren_stack[paren_stack.Length - 1] == '(') {\n                  \
    \              level_nesting.Add(level_nesting.Count - 1);\n                 \
    \           } else {\n                                level_nesting.Add(level_nesting.Count\
    \ + 1);\n                            }\n                            if (level_nesting.Count\
    \ == \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptbidqi1o.cs(78,55): error CS1525: Invalid expression term ''}''

    /tmp/tmptbidqi1o.cs(78,55): error CS1026: ) expected

    /tmp/tmptbidqi1o.cs(78,55): error CS1002: ; expected

    /tmp/tmptbidqi1o.cs(80,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmptbidqi1o.cs(86,2): error CS1513: } expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // initialize counts\n        long num_left = 0;\n\
    \        long num_right = 0;\n\n        // initialize stack\n        Stack<long>\
    \ stack = new Stack<long>();\n        // initialize strings to process\n     \
    \   string str_left = paren_string.Substring(0, paren_string.Length - paren_string.Replace(\"\
    )\", string.Empty).Length);\n        string str_right = paren_string.Substring(0,\
    \ paren_string.Length - paren_string.Replace(\"(\", string.Empty).Length);\n\n\
    \        // process and count string pairs\n        for (long idx = 0; idx < str_left.Length;\
    \ idx++) {\n            if (str_left[idx] == '(') {\n                num_left++;\n\
    \            }\n            if (str_left[idx] == ')') {\n                num_right--;\n\
    \            }\n            long max_depth = 0;\n            if (num_left > num_right)\
    \ {\n                max_depth = (long)Math.Max(num_left, num_right);\n      \
    \      } else {\n                max_depth = (long)Math.Max(num_right, num_left);\n\
    \            }\n            while (stack.Count > 0) {\n                if (max_depth\
    \ == (long)stack.Pop()) {\n                    break;\n                }\n   \
    \         }\n            stack.Push(max_depth);\n        }\n\n        // remove\
    \ unnecesary items\n        while (stack.Count > 0) {\n            stack.Pop();\n\
    \        }\n\n        // return the result\n        return new List<long>(stack);\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2l7nthr1.cs(27,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp2l7nthr1.cs(30,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var paren_stack = new Stack<List<long>>();\n      \
    \  var stack = new List<long>();\n        foreach (char c in paren_string) {\n\
    \            if(c == '(') {\n                if (paren_stack.Count > 0) {\n  \
    \                  paren_stack.RemoveAt(paren_stack.Count - 1);\n            \
    \    }\n                stack.Add(stack.Count);\n                paren_stack.Add(stack);\n\
    \            }\n            else if(c == ')') {\n                stack = paren_stack[paren_stack.Count\
    \ - 1];\n            }\n            else if(c == ' ') {\n                if (paren_stack.Count\
    \ > 0) {\n                    paren_stack[paren_stack.Count - 1] = new List<long>(stack.Count\
    \ + 1);\n                }\n                else {\n                    paren_stack\
    \ = new Stack<List<long>>() { stack };\n                }\n            }\n   \
    \     }\n        if (paren_stack.Count > 0) {\n            throw new Exception(\"\
    Unexpected character\");\n        }\n        var list = new List<long>();\n  \
    \      list.Add(stack.Count);\n        while (list.Count > 0) {\n            list.RemoveAt(0);\n\
    \            list.Add(list.Last());\n        }\n        return list;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpfo6iyua2.cs(20,33): error CS1061: ''Stack<List<long>>'' does not contain
    a definition for ''RemoveAt'' and no accessible extension method ''RemoveAt''
    accepting a first argument of type ''Stack<List<long>>'' could be found (are you
    missing a using directive or an assembly reference?)

    /tmp/tmpfo6iyua2.cs(23,29): error CS1061: ''Stack<List<long>>'' does not contain
    a definition for ''Add'' and no accessible extension method ''Add'' accepting
    a first argument of type ''Stack<List<long>>'' could be found (are you missing
    a using directive or an assembly reference?)

    /tmp/tmpfo6iyua2.cs(26,25): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<List<long>>''

    /tmp/tmpfo6iyua2.cs(30,21): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<List<long>>''

    /tmp/tmpfo6iyua2.cs(33,61): error CS1061: ''Stack<List<long>>'' does not contain
    a definition for ''Add'' and no accessible extension method ''Add'' accepting
    a first argument of type ''Stack<List<long>>'' could be found (are you missing
    a using directive or an assembly reference?)

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>(new long[]{1L});\n\
    \        Stack<long> levelsStack = new Stack<long>();\n        bool first = true;\n\
    \        string text = paren_string;\n        foreach (char c in text) {\n   \
    \         string text = paren_string;\n            int index = text.IndexOf(c);\n\
    \            if (index != -1) {\n                string next_text = text.Substring(index\
    \ + 1);\n                string next_text = next_text.Trim();\n              \
    \  if (next_text.Length == 0) {\n                    if (levelsStack.Count > 0)\
    \ {\n                        levels.Add(levelsStack.Pop());\n                \
    \    }\n                } else {\n                    string last_text = text.Substring(0,\
    \ index);\n                    string last_text = last_text.Trim();\n        \
    \            bool is_nested = false;\n                    if (last_text.Length\
    \ > 0) {\n                        if (last_text[0] == '(' && last_text[last_text.Length\
    \ - 1] == ')') {\n                            levels.Add(1);\n               \
    \             levelsStack.Push(levels.Count - 1);\n                          \
    \  is_nested = true;\n                        } else if (last_text[0] == '(')\
    \ {\n                            levelsStack.Push(levels.Count - 1);\n       \
    \                     is_nested = true;\n                        } else if (last_text[0]\
    \ == '[' && last_text[last_text.Length - 1] == ']') {\n                      \
    \      levels.Add(1);\n                            levelsStack.Push(levels.Count\
    \ - 1);\n                            is_nested = true;\n                     \
    \   } else if (last_text[0] == '[') {\n                            levelsStack.Push(levels.Count\
    \ - 1);\n                            is_nested = true;\n                     \
    \   } else if (last_text[0] == '{' && last_text[last_text.Length - 1] == '}')\
    \ {\n                            levels.Add(1);\n                            levelsStack.Push(levels.Count\
    \ - 1);\n                            is_nested = true;\n                     \
    \   } else if (last_text[0] == '{') {\n                            levelsStack.Push(levels.Count\
    \ - 1);\n                            is_nested = true;\n                     \
    \   }\n                    }\n                    if (is_nested) {\n         \
    \               string next_text = text.Substring(index + 1);\n              \
    \          string next_text = next_text.Trim();\n                        if (next_text.Length\
    \ == 0) {\n                            if (levelsStack.Count > 0) {\n        \
    \                        levels.Add(levelsStack.Pop());\n                    \
    \        }\n                        } else {\n                            levels.Add(1);\n\
    \                            levelsStack.Push(levels.Count - 1);\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        return levels;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy1vl1xze.cs(20,20): error CS0136: A local or parameter named ''text''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmpy1vl1xze.cs(24,24): error CS0128: A local variable or function named ''next_text''
    is already defined in this scope

    /tmp/tmpy1vl1xze.cs(31,28): error CS0128: A local variable or function named ''last_text''
    is already defined in this scope

    /tmp/tmpy1vl1xze.cs(58,32): error CS0136: A local or parameter named ''next_text''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmpy1vl1xze.cs(59,32): error CS0128: A local variable or function named ''next_text''
    is already defined in this scope

    /tmp/tmpy1vl1xze.cs(17,14): warning CS0219: The variable ''first'' is assigned
    but its value is never used

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        StringBuilder sb = new StringBuilder();\n        //\
    \ The string represents the nested parenthesis group and is separated by spaces\n\
    \        // \"(()()) \" -> [(), (), ()]\n        // \"((()))\" -> [(()), ()]\n\
    \        // \"(()) ((()))\" -> [(), (), (()), ()]\n        // \"(()())\" -> [(),\
    \ (), ()]\n        // \"(())()()\" -> [(), (), ()]\n        string[] group_strings\
    \ = paren_string.Split(' ');\n        for (int i = 0; i < group_strings.Length;\
    \ i++) {\n            // The string to store the final string representation of\
    \ parenthesis group\n            string temp_str = \"\";\n            // Get the\
    \ string representation of parenthesis group which has depth i\n            string\
    \ temp_str_i = group_strings[i];\n            // For all groups with depth greater\
    \ than i get their length and sum them\n            for (int j = 0; j < i; j++)\n\
    \                temp_str += temp_str_i;\n            temp_str += temp_str_i;\n\
    \            // If depth i is equal to length of the input string, that means\
    \ that we are at deepest level of nesting of parenthesis\n            if (i ==\
    \ group_strings.Length - 1)\n                sb.Append(temp_str);\n          \
    \  else {\n                // For each group which has depth greater than i get\
    \ the string representation of their deepest level of nesting \n             \
    \   // and append it to temp_str\n                for (int j = 0; j < i; j++)\n\
    \                    temp_str += temp_str_i;\n                temp_str += \"(\"\
    ;\n                // append the string representation of that level of nesting\
    \ to the string which is already in temp_str\n                sb.Append(temp_str);\n\
    \            }\n        }\n        // The string represents the deepest level\
    \ of parenthesis group in the whole string\n        return sb.ToString().Split('(').Select(s\
    \ => new long(s.Length)).ToList();\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2q_rmldj.cs(46,57): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string s = paren_string;\n        List<long> results\
    \ = new List<long>();\n\n        for (int i = 0; i < s.Length; i++) {\n      \
    \      if (char.IsWhiteSpace(s[i])) continue;\n            if (s[i] == '(') {\n\
    \                if (i == 0) continue;\n                if (s[i - 1] == '(') {\n\
    \                    results.Add(ParseNestingLevel(s, i));\n                 \
    \   continue;\n                }\n            }\n            if (s[i] == '(')\
    \ {\n                if (i == s.Length - 1) continue;\n                if (s[s.Length\
    \ - 1] == ')') {\n                    results.Add(ParseNestingLevel(s, i));\n\
    \                    continue;\n                }\n            }\n\n         \
    \   results.Add(ParseNestingLevel(s, i));\n        }\n\n        return results;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpr_hlh8v1.cs(23,33): error CS0103: The name ''ParseNestingLevel'' does
    not exist in the current context

    /tmp/tmpr_hlh8v1.cs(30,33): error CS0103: The name ''ParseNestingLevel'' does
    not exist in the current context

    /tmp/tmpr_hlh8v1.cs(35,25): error CS0103: The name ''ParseNestingLevel'' does
    not exist in the current context

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length <= 1)\n            return new\
    \ List<long>();\n        var stack = new Stack<long>();\n        var depths =\
    \ new List<long>();\n        foreach (var c in paren_string) {\n            if\
    \ (c == '(' || c == '[' || c == '{') {\n                stack.Push(c);\n     \
    \       }\n            else if (c == ')' || c == ']' || c == '}') {\n        \
    \        while (!stack.IsEmpty() && stack.Peek() != '(') {\n                 \
    \   stack.Pop();\n                }\n                if (stack.IsEmpty())\n  \
    \                  break;\n                var depth = (int)stack.Pop();\n   \
    \             if (depths.Any())\n                    depths.Remove(depth);\n \
    \               depths.Add(depth);\n            }\n        }\n        return depths.ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7reqq15e.cs(24,31): error CS1061: ''Stack<long>'' does not contain a definition
    for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmp7reqq15e.cs(27,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> deepest_level_list = new List<long>();\n\
    \n        // Find the deepest level of nesting for each set of parentheses.\n\
    \        // For each set of parentheses, find the deepest level of nesting by\
    \ finding the number of opening parentheses.\n        // Keep track of the deepest\
    \ level of nesting for each set of parentheses separately.\n        // Then output\
    \ the deepest level of nesting for each set of parentheses separately.\n     \
    \   // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \        // The expected output is\n        // >>> new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L})\n        string str_paren = paren_string;\n \
    \       Stack<bool> stack = new Stack<bool>();\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            char c = str_paren[i];\n            if ((c == '(')) {\n\
    \                stack.Add(true);\n            } else if ((c == ')')) {\n    \
    \            bool is_open = stack.Pop();\n                deepest_level_list.Add(is_open\
    \ ? 1L : 0L);\n            } else if ((c == ' ') && stack.Peek()) {\n        \
    \        // If c is space and stack is open, push a '(', or ')'\n            \
    \    // If c is space and stack is closed, pop a '(', or ')'\n               \
    \ stack.Pop();\n            } else {\n                // If c is space, push a\
    \ '(', or ')'\n                stack.Add(c == '(');\n            }\n        }\n\
    \        return deepest_level_list;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8ceyoq9j.cs(29,23): error CS1061: ''Stack<bool>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<bool>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp8ceyoq9j.cs(39,23): error CS1061: ''Stack<bool>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<bool>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> level = new List<long>();\n        bool\
    \ in_inf = false;\n        bool in_inf_2 = false;\n        for (int i = 0; i <\
    \ paren_string.Length; i++) {\n            bool in_neg = false;\n            bool\
    \ in_neg_2 = false;\n            bool in_neg_3 = false;\n            char c =\
    \ paren_string[i];\n\n            // Keep track of the previous char.\n      \
    \      char prev_c = ' ';\n\n            switch (c) {\n                case '(':\n\
    \                    level.Add(1L);\n                    break;\n            \
    \    case ')':\n                    level.RemoveAt(level.Count - 1);\n       \
    \             break;\n                case '-':\n                    in_neg =\
    \ true;\n                    prev_c = '-';\n                    break;\n     \
    \           case '/':\n                    in_neg_2 = true;\n                \
    \    prev_c = '/';\n                    break;\n                case '\\\\':\n\
    \                    in_neg_3 = true;\n                    prev_c = '\\\\';\n\
    \                    break;\n            }\n\n            // Keep track of the\
    \ current char.\n            char current_c = c;\n\n            if (c == '-')\
    \ {\n                if (level.Count < 3) {\n                    level.Add((long)\
    \ level[level.Count - 1]);\n                }\n                level.RemoveAt(level.Count\
    \ - 1);\n            } else if (c == '/') {\n                if (level.Count <\
    \ 2) {\n                    level.Add((long) level[level.Count - 1]);\n      \
    \          }\n                level.RemoveAt(level.Count - 1);\n            }\
    \ else if (c == '\\\\') {\n                if (level.Count < 2) {\n          \
    \          level.Add((long) level[level.Count - 1]);\n                }\n    \
    \            level.RemoveAt(level.Count - 1);\n            } else {\n        \
    \        if (level.Count < 2) {\n                    level.Add((long) level[level.Count\
    \ - 1]);\n                }\n            }\n\n            // If we're in a negative\
    \ number or negative division\n            // number, we'll treat this as a single\
    \ number.\n            if ((in_neg || in_neg_2 || in_neg_3) &&\n             \
    \   (level.Count < 2 ||\n                 c == '(' || c == '-' || c == '/' ||\n\
    \                 c == '\\\\')) {\n                level.Add((long) level[level.Count\
    \ - 1]);\n            }\n\n            // If the previous char is negative, we'll\
    \ keep track of\n            // the previous number.\n            if (in_neg &&\
    \ prev_c == '-') {\n                in_neg = false;\n                level.Add((long)\
    \ level[level.Count - 1]);\n            }\n\n            // If the previous char\
    \ is negative 2, we'll\n            // keep track of previous 2.\n           \
    \ if (in_neg_2 && prev_c == '/') {\n                in_neg_2 = false;\n      \
    \          level.Add((long) level[level.Count - 1]);\n            }\n\n      \
    \      // If the previous char is negative 3, we'll\n            // keep track\
    \ of previous 3.\n            if (in_neg_3 && prev_\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpb8ivr2du.cs(97,34): error CS1026: ) expected

    /tmp/tmpb8ivr2du.cs(97,34): error CS1525: Invalid expression term ''}''

    /tmp/tmpb8ivr2du.cs(97,34): error CS1002: ; expected

    /tmp/tmpb8ivr2du.cs(99,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpb8ivr2du.cs(105,2): error CS1513: } expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> out = new List<long>();\n        List<char>\
    \ chars = paren_string.ToCharArray();\n        int prev_level = 0;\n        bool\
    \ in_paren = false;\n        for (int i = 0; i < chars.Length; i++) {\n      \
    \      if (chars[i] == '(') {\n                if (in_paren) {\n             \
    \       prev_level = i - 1;\n                } else {\n                    in_paren\
    \ = true;\n                }\n            }\n            if (chars[i] == ')' &&\
    \ in_paren) {\n                in_paren = false;\n                out.Add(prev_level);\n\
    \                prev_level = i - 1;\n            }\n            if (chars[i]\
    \ == ')') {\n                in_paren = false;\n            }\n        }\n   \
    \     return out;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp__nn1_95.cs(15,20): error CS1002: ; expected

    /tmp/tmp__nn1_95.cs(15,20): error CS1513: } expected

    /tmp/tmp__nn1_95.cs(15,24): error CS1525: Invalid expression term ''=''

    /tmp/tmp__nn1_95.cs(28,34): error CS1513: } expected

    /tmp/tmp__nn1_95.cs(36,16): error CS1525: Invalid expression term ''out''

    /tmp/tmp__nn1_95.cs(36,16): error CS1002: ; expected

    /tmp/tmp__nn1_95.cs(36,16): error CS1513: } expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) return new List<long>();\n\
    \        var depths = new List<long>();\n        var cur_level = -1;\n       \
    \ var levels = new List<long>(new long[] { 0L });\n        char c;\n        for\
    \ (int i = 0; i < paren_string.Length; i++) {\n            c = paren_string[i];\n\
    \            depths.Add(cur_level);\n            if (c == '(') {\n           \
    \     levels[cur_level]++;\n            } else if (c == ')') {\n             \
    \   if (cur_level >= 0) {\n                    levels[cur_level]--;\n        \
    \        }\n            }\n        }\n        cur_level = depths.Max();\n    \
    \    if (cur_level == 0) cur_level = 1;\n        List<long> answer = new List<long>();\n\
    \        for (int i = 0; i < depths.Count; i++) {\n            int j = i;\n  \
    \          while (j > 0 && levels[j - 1] == 0) {\n                j--;\n     \
    \       }\n            if (j < depths.Count - 1) answer.Add(levels[j] + 1);\n\
    \        }\n        return answer;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1e7pahyv.cs(31,21): error CS0266: Cannot implicitly convert type ''long''
    to ''int''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659976351
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var result = new List<long>(new long[] {(long)0L});\n\
    \        bool inside_group = false;\n        foreach (var c in paren_string) {\n\
    \            if (inside_group) {\n                inside_group = false;\n    \
    \            result.Add((long)(c == '(' ? 1L : 0L));\n            }\n        \
    \    if (c == '(')\n                inside_group = true;\n            else\n \
    \               result.Add((long)(c == ')' ? -1L : 0L));\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <81176d908143488494f5ba0eac58f01d>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <81176d908143488494f5ba0eac58f01d>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Create an empty stack to store the level of nesting\
    \ for each paren.\n        Stack<long> level = new Stack<long>();\n        Stack<long>\
    \ results = new Stack<long>();\n        \n        Stack<long> temp_level = new\
    \ Stack<long>();\n        bool opening_left_paren = false, opening_right_paren\
    \ = false;\n        \n        // Traverse through the input string recursively.\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             opening_left_paren = true;\n                temp_level.Clear();\n\
    \            }\n            if (c == '(') {\n                temp_level.Clear();\n\
    \                temp_level.push(level.Count);\n            }\n            if\
    \ (c == ')') {\n                opening_right_paren = true;\n            }\n \
    \           \n            if (opening_left_paren) {\n                if (c ==\
    \ ')') {\n                    opening_left_paren = false;\n                }\n\
    \                else if (c == '(') {\n                    temp_level.Clear();\n\
    \                    temp_level.push(level.Count);\n                }\n      \
    \          level.push(level.Count);\n            }\n            \n           \
    \ if (opening_right_paren) {\n                if (c == '(') {\n              \
    \      opening_right_paren = false;\n                }\n                else if\
    \ (c == ')') {\n                    temp_level.Clear();\n                    temp_level.push(level.Count);\n\
    \                }\n                level.push(level.Count);\n            }\n\
    \        }\n        \n        // Return the deepest level of nesting for each\
    \ paren.\n        bool is_empty = temp_level.Count == 0;\n        foreach (long\
    \ l in level) {\n            if (l > results.Count) results.Clear();\n       \
    \     if (is_empty || l != results.Count) {\n                results.Clear();\n\
    \                results.Add(l);\n            }\n        }\n        return results;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyb_3nn5y.cs(30,28): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(42,32): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(44,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(53,32): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(55,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(65,25): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyb_3nn5y.cs(68,16): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.Stack<long>''
    to ''System.Collections.Generic.List<long>''

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var levels = new List<long>();\n\n        // Keep a\
    \ running total of the levels\n        var total = 0;\n\n        // Loop through\
    \ each character in the string\n        // The first character is the opening\
    \ '('\n        // The last character is the first closing ')'\n        // So for\
    \ these characters, increment the running total\n        for (int i = 1; i < paren_string.Length;\
    \ i++) {\n            // Get the character at this position\n            var c\
    \ = paren_string[i];\n            // If the opening '('\n            if (c ==\
    \ '(') {\n                total++;\n            // If the closing ')'\n      \
    \      } else if (c == ')') {\n                total--;\n            }\n\n   \
    \         // If the total has reached the minimum level of nesting required\n\
    \            if (total >= levels[levels.Count - 1]) {\n                // Add\
    \ one to each level and output the list with the deepest level\n             \
    \   levels.Add(total + 1);\n            }\n        }\n\n        // Return a list\
    \ with the deepest level of nesting for each group\n        return levels;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00043] in <70f5749246d544d28469fb450e5401ef>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <70f5749246d544d28469fb450e5401ef>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00043] in <70f5749246d544d28469fb450e5401ef>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <70f5749246d544d28469fb450e5401ef>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976351
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var stack = new List<long>();\n        var opening\
    \ = paren_string.IndexOf('(');\n        if (opening < 0) {\n            throw\
    \ new ArgumentException(\"Can't parse string: \\\"\" + paren_string + \"\\\"\"\
    );\n        }\n        var closing = paren_string.IndexOf(')');\n        if (closing\
    \ < 0) {\n            throw new ArgumentException(\"Can't parse string: \\\"\"\
    \ + paren_string + \"\\\"\");\n        }\n        for (var i = opening; i < closing;\
    \ i++) {\n            int level_of_nesting = paren_string.Substring(i).Count(x\
    \ => x == '(') - paren_string.Substring(i).Count(x => x == ')') - 1;\n       \
    \     if (level_of_nesting > stack.Count - 1) {\n                throw new ArgumentException(\"\
    Can't parse string: \\\"\" + paren_string + \"\\\"\");\n            }\n      \
    \      stack.Add(level_of_nesting);\n        }\n        return new List<long>(stack);\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <aa1b7e9b83e143ef880bdc156b633e30>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <aa1b7e9b83e143ef880bdc156b633e30>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Regex nested_regex = new Regex(@\"\\(|\\)\");\n   \
    \     List<long> results = new List<long>();\n        Stack<long> nesting_stack\
    \ = new Stack<long>();\n        StringBuilder nested_str_builder = new StringBuilder();\n\
    \        MatchCollection nested_matches = nested_regex.Matches(paren_string);\n\
    \        int counter = 1;\n        foreach (Match nested_match in nested_matches)\
    \ {\n            if (nested_match.Value == \"(\") {\n                nesting_stack.Push(counter);\n\
    \                nested_str_builder.Append(nested_match.Value);\n            }\n\
    \            else if (nested_match.Value == \")\") {\n                if (nesting_stack.Count\
    \ > 0 && nesting_stack.Peek() == counter) {\n                    nesting_stack.Pop();\n\
    \                    nested_str_builder.Append(nested_match.Value);\n        \
    \            results.Add(new long(nested_str_builder.Length));\n             \
    \   }\n            }\n            else {\n                if (nesting_stack.Count\
    \ > 0 && nesting_stack.Peek() == counter) {\n                    nesting_stack.Pop();\n\
    \                    nested_str_builder.Append(nested_match.Value);\n        \
    \        }\n            }\n            counter++;\n        }\n        return results;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnkqju52r.cs(15,9): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpnkqju52r.cs(15,34): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpnkqju52r.cs(19,9): error CS0246: The type or namespace name ''MatchCollection''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpnkqju52r.cs(21,18): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpnkqju52r.cs(30,37): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null || paren_string.Length ==\
    \ 0) return null;\n        Stack<long> stk = new Stack<long>();\n        bool\
    \ seen_open_brace = false;\n        bool seen_close_brace = false;\n        foreach\
    \ (char c in paren_string.ToCharArray()) {\n            if (c == '(') {\n    \
    \            if (!seen_open_brace) stk.Push(1);\n                seen_open_brace\
    \ = true;\n            } else if (c == ')') {\n                if (seen_open_brace)\
    \ {\n                    int nesting_level = stk.Pop();\n                    stk.Push(nesting_level\
    \ + 1);\n                } else {\n                    return null;\n        \
    \        }\n                seen_close_brace = true;\n            } else if (c\
    \ == '[' || c == ']') {\n                if (!seen_open_brace || seen_close_brace)\
    \ {\n                    return null;\n                }\n                Stack<int>\
    \ tmp = new Stack<int>();\n                int next_level = 0;\n             \
    \   if (c == '[') {\n                    int nesting_level = 1;\n            \
    \        tmp.Push(nesting_level);\n                    next_level = 2;\n     \
    \           } else {\n                    nesting_level = stk.Pop();\n       \
    \             next_level = nesting_level;\n                }\n               \
    \ while (tmp.Count > 0) {\n                    nesting_level = tmp.Pop();\n  \
    \                  if (nesting_level > next_level) {\n                       \
    \ next_level = nesting_level;\n                    }\n                    next_level++;\n\
    \                }\n                stk.Push(next_level);\n            }\n   \
    \     }\n        return new List<long>(stk.Reverse());\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqpvdgao4.cs(25,41): error CS0266: Cannot implicitly convert type ''long''
    to ''int''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpqpvdgao4.cs(42,21): error CS0103: The name ''nesting_level'' does not
    exist in the current context

    /tmp/tmpqpvdgao4.cs(43,34): error CS0103: The name ''nesting_level'' does not
    exist in the current context

    /tmp/tmpqpvdgao4.cs(46,21): error CS0103: The name ''nesting_level'' does not
    exist in the current context

    /tmp/tmpqpvdgao4.cs(47,25): error CS0103: The name ''nesting_level'' does not
    exist in the current context

    /tmp/tmpqpvdgao4.cs(48,38): error CS0103: The name ''nesting_level'' does not
    exist in the current context

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> results = new List<long>();\n        Stack<string>\
    \ parens = new Stack<string>();\n        StringBuilder sb = new StringBuilder();\n\
    \        long counter = 1;\n        int paren_level = 0;\n        foreach (char\
    \ c in paren_string) {\n            bool in_paren = parens.Count > 0;\n      \
    \      bool in_sb = sb.Length > 0;\n            if (c == '(') {\n            \
    \    parens.Push(c);\n                sb.Append(c);\n                counter++;\n\
    \            }\n            if (c == ')' && parens.Count > 0 && parens.Peek()\
    \ != '(') {\n                string val = parens.Pop();\n                sb.Append(c);\n\
    \                counter--;\n                if (val == \"(\") {\n           \
    \         counter++;\n                }\n                if (val == \")\") {\n\
    \                    counter--;\n                }\n            }\n          \
    \  if (!in_paren && !in_sb) {\n                results.Add(counter);\n       \
    \     }\n        }\n        return results;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpaf4eo9t4.cs(24,29): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmpaf4eo9t4.cs(28,49): error CS0019: Operator ''!='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpaf4eo9t4.cs(19,13): warning CS0219: The variable ''paren_level'' is assigned
    but its value is never used

    '
  timestamp: 1659976351
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nesting = new List<long>();\n        List<long>\
    \ stack = new List<long>();\n        List<long> stack2 = new List<long>();\n \
    \       for (int i = 0; i < paren_string.Length; i++) {\n            if (paren_string[i]\
    \ != '(') {\n                stack.Add(paren_string[i]);\n            } else {\n\
    \                stack2.Add(paren_string[i]);\n            }\n            if (paren_string[i]\
    \ == ')') {\n                if (stack.Count != 0) {\n                    nesting.Add(stack.Last());\n\
    \                    stack.RemoveAt(stack.Count - 1);\n                }\n   \
    \             if (stack2.Count != 0) {\n                    nesting.Add(stack2.Last());\n\
    \                    stack2.RemoveAt(stack2.Count - 1);\n                }\n \
    \           }\n        }\n        if (stack.Count != 0) {\n            nesting.Add(stack.Last());\n\
    \        }\n        if (stack2.Count != 0) {\n            nesting.Add(stack2.Last());\n\
    \        }\n        if (nesting.Count != 0) {\n            nesting.RemoveAt(nesting.Count\
    \ - 1);\n        }\n        return nesting;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <67c5733f65b648c7b10c58f8fe02598e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <67c5733f65b648c7b10c58f8fe02598e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nesting = new List<long>();\n        List<long>\
    \ currentGroup = new List<long>();\n        string lastGroup = \"\";\n       \
    \ for (int index = 0; index < paren_string.Length; index++) {\n            char\
    \ c = paren_string[index];\n            if (c == '(') {\n                if (lastGroup\
    \ != \"\") {\n                    currentGroup.Add(0);\n                }\n  \
    \              nesting.Add(currentGroup.Count);\n                currentGroup.Add(0);\n\
    \                lastGroup = \"\";\n            }\n            if (c == ')') {\n\
    \                if (lastGroup == \"\") {\n                    throw new ArgumentException(\"\
    Invalid parenthesis in string \\\"\" + paren_string + \"\\\"\");\n           \
    \     }\n                currentGroup.Add(0);\n                nesting.Add(currentGroup.Count);\n\
    \                lastGroup = \"\";\n            }\n            if (lastGroup !=\
    \ \"\") {\n                currentGroup.Add(0);\n            }\n            if\
    \ (c == '(') {\n                currentGroup.Add(0);\n            }\n        \
    \    lastGroup = c;\n        }\n        return nesting;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1j9qsc4w.cs(42,25): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    '
  timestamp: 1659976351
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) return new List<long>(new\
    \ long[0]);\n        List<long> levels = new List<long>();\n        // Get position\
    \ of first open paren\n        int opening_paren_pos = paren_string.IndexOf('(');\n\
    \        while (opening_paren_pos < 0) {\n            opening_paren_pos = paren_string.LastIndexOf('(');\n\
    \        }\n        // Keep track of how many open paren we have\n        int\
    \ num_open_paren = 0;\n        // Move through all the characters in paren_string\
    \ and record the level of nesting\n        while (opening_paren_pos < paren_string.Length)\
    \ {\n            if (paren_string[opening_paren_pos] == '(') {\n             \
    \   ++num_open_paren;\n            }\n            else if (paren_string[opening_paren_pos]\
    \ == ')') {\n                if (num_open_paren > 0) {\n                    levels.Add(num_open_paren);\n\
    \                }\n                num_open_paren--;\n            }\n       \
    \     opening_paren_pos++;\n        }\n        // Add back the open paren we had\
    \ before the last closing paren\n        if (num_open_paren > 0) {\n         \
    \   levels.Add(num_open_paren);\n        }\n        return levels;\n    }\n  \
    \  public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f33ec4902930477a9623237c13d712af>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f33ec4902930477a9623237c13d712af>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var max_levels = new List<long>();\n        // Split\
    \ the string by groups of parentheses.\n        var paren_groups = paren_string.Split(new\
    \ char[] { '(', ')' }, StringSplitOptions.RemoveEmptyEntries);\n        // Iterate\
    \ through each group of parentheses.\n        for (int i = 1; i < paren_groups.Length;\
    \ i++) {\n            // If the current group's level is greater than the max\
    \ level of nesting, store it.\n            var current_level = i;\n          \
    \  // Keep incrementing by one until we find an empty string.\n            while\
    \ (paren_groups[current_level].Length > 0) {\n                current_level++;\n\
    \            }\n            // If the current group's level is equal to the max\
    \ level of nesting, output it.\n            if (current_level == paren_groups.Length\
    \ - 1) {\n                max_levels.Add(i);\n            }\n        }\n     \
    \   // Return the deepest level of nesting.\n        return max_levels;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x0002e] in <78cef9de81a3455589b76eeaeb3fa89b>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <78cef9de81a3455589b76eeaeb3fa89b>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x0002e]\
    \ in <78cef9de81a3455589b76eeaeb3fa89b>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <78cef9de81a3455589b76eeaeb3fa89b>:0 \n"
  stdout: ''
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        foreach (char c in paren_string) {\n   \
    \         switch (c) {\n                case '(':\n                    stack.Add(0);\n\
    \                    break;\n                case ')':\n                    while\
    \ (stack.Count > 0) {\n                        long level = stack.Pop();\n   \
    \                     levels.Add(level);\n                    }\n            \
    \        break;\n                case '(':\n                case ')':\n      \
    \              stack.Add(1);\n                    break;\n                default:\n\
    \                    break;\n            }\n        }\n        return levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy0hy7hz2.cs(20,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpy0hy7hz2.cs(30,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpy0hy7hz2.cs(28,17): error CS0152: The switch statement contains multiple
    cases with the label value ''(''

    /tmp/tmpy0hy7hz2.cs(29,17): error CS0152: The switch statement contains multiple
    cases with the label value '')''

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var result = new List<long>();\n        var stack =\
    \ new Stack<long>();\n        foreach (var c in paren_string) {\n            switch\
    \ (c) {\n                case '(':\n                    stack.Add(1L);\n     \
    \               break;\n                case ')':\n                    result.Add(stack.Pop());\n\
    \                    break;\n                case ')':\n                    if\
    \ (stack.Peek() != 0L)\n                        result.Add(stack.Pop());\n   \
    \                 break;\n            }\n        }\n        return result;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpf2legt4z.cs(20,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpf2legt4z.cs(25,17): error CS0152: The switch statement contains multiple
    cases with the label value '')''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Stack<long> stack = new Stack<long>();\n        List<long>\
    \ list = new List<long>();\n        string temp_str = string.Empty;\n        int\
    \ start = 0;\n\n        for (int i = 0; i < paren_string.Length; i++) {\n    \
    \        temp_str = paren_string.Substring(start, i - start);\n            if\
    \ (temp_str != \"\") {\n                if (temp_str[0] == '(') {\n          \
    \          stack.Enqueue((long)1);\n                } else if (temp_str[0] ==\
    \ ')') {\n                    long level = (long)stack.Pop();\n              \
    \      list.Add(level);\n                } else {\n                    long level\
    \ = (long)stack.Pop();\n                    while (temp_str[0] != ')' && temp_str[0]\
    \ != '(') {\n                        level++;\n                        stack.Enqueue((long)level);\n\
    \                        temp_str = temp_str.Substring(1, temp_str.Length - 1);\n\
    \                    }\n                }\n                start = i + 1;\n  \
    \          }\n        }\n        temp_str = paren_string.Substring(start);\n \
    \       while (temp_str != \"\") {\n            long level = 1;\n            while\
    \ (temp_str[0] != ')' && temp_str[0] != '(') {\n                level++;\n   \
    \             temp_str = temp_str.Substring(1, temp_str.Length - 1);\n       \
    \     }\n            list.Add(level);\n            temp_str = temp_str.Substring(1,\
    \ temp_str.Length - 1);\n        }\n        return list;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1v9h665h.cs(24,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Enqueue'' and no accessible extension method ''Enqueue'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmp1v9h665h.cs(32,31): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Enqueue'' and no accessible extension method ''Enqueue'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) {\n            return\
    \ new List<long>();\n        }\n        List<string> groups = paren_string.Split(new\
    \ char[] {' '}, StringSplitOptions.RemoveEmptyEntries).Select(a => a.Trim()).ToList();\n\
    \        List<long> results = new List<long>();\n        int stack = 0;\n    \
    \    long current_level = 1;\n        foreach (string group in groups) {\n   \
    \         bool contains_paren = group.Contains(\"(\");\n            bool contains_double_paren\
    \ = group.Contains(\")\");\n            bool contains_curly_bracket = group.Contains(\"\
    {\");\n            bool contains_curly_bracket = group.Contains(\"}\");\n    \
    \        bool contains_unpaired_curly_bracket = group.Contains(\"}{\") || group.Contains(\"\
    }{\");\n            bool contains_unpaired_curly_bracket = group.Contains(\"}{\"\
    ) || group.Contains(\"}{\");\n            if (contains_curly_bracket) {\n    \
    \            if (contains_unpaired_curly_bracket) {\n                    stack--;\n\
    \                } else if (stack.Contains(-1)) {\n                    stack++;\n\
    \                } else {\n                    stack++;\n                }\n \
    \           } else if (contains_curly_bracket) {\n                if (contains_unpaired_curly_bracket)\
    \ {\n                    stack++;\n                } else {\n                \
    \    stack--;\n                }\n            } else if (contains_unpaired_curly_bracket)\
    \ {\n                if (contains_curly_bracket) {\n                    stack++;\n\
    \                } else {\n                    stack--;\n                }\n \
    \           } else if (contains_paren) {\n                if (stack.Contains(-1))\
    \ {\n                    stack--;\n                } else {\n                \
    \    stack++;\n                }\n            } else {\n                if (stack.Contains(-1))\
    \ {\n                    stack++;\n                } else {\n                \
    \    stack--;\n                }\n            }\n            stack++;\n      \
    \      if (contains_paren) {\n                results.Add(current_level);\n  \
    \          }\n        }\n        results.Add(current_level);\n        return results;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpd_rxzmag.cs(26,18): error CS0128: A local variable or function named ''contains_curly_bracket''
    is already defined in this scope

    /tmp/tmpd_rxzmag.cs(28,18): error CS0128: A local variable or function named ''contains_unpaired_curly_bracket''
    is already defined in this scope

    /tmp/tmpd_rxzmag.cs(32,28): error CS1929: ''int'' does not contain a definition
    for ''Contains'' and the best extension method overload ''ParallelEnumerable.Contains<int>(ParallelQuery<int>,
    int)'' requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpd_rxzmag.cs(50,21): error CS1929: ''int'' does not contain a definition
    for ''Contains'' and the best extension method overload ''ParallelEnumerable.Contains<int>(ParallelQuery<int>,
    int)'' requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpd_rxzmag.cs(56,21): error CS1929: ''int'' does not contain a definition
    for ''Contains'' and the best extension method overload ''ParallelEnumerable.Contains<int>(ParallelQuery<int>,
    int)'' requires a receiver of type ''ParallelQuery<int>''

    '
  timestamp: 1659976352
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var paren_levels = new List<long>();\n        var prev_paren_level\
    \ = -1;\n        foreach (var ch in paren_string) {\n            if (ch == '(')\
    \ {\n                paren_levels.Add(prev_paren_level);\n                prev_paren_level++;\n\
    \            } else if (ch == ')') {\n                prev_paren_level--;\n  \
    \          }\n        }\n        if (paren_levels.Count > 0) {\n            //\
    \ At least one more closing parenthesis is needed\n            paren_levels.Add(paren_levels.Count);\n\
    \        }\n        return paren_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <5584b2312ee74fbe8ef5764117f861ae>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <5584b2312ee74fbe8ef5764117f861ae>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Pre-compute factorials up to the number you are\
    \ interested in.\n        Dictionary<long, long> factorials = new Dictionary<long,\
    \ long>();\n        long factor = 1;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            factorials[factor++] = i;\n        }\n        Debug.Assert(paren_string.Length\
    \ > 0);\n\n        List<long> res = new List<long>();\n        char open = paren_string[0];\n\
    \        char last = paren_string[paren_string.Length - 1];\n        for (int\
    \ i = 1; i <= paren_string.Length; i++) {\n            if (paren_string[i] ==\
    \ last)\n                res.Add(i);\n            else\n            {\n      \
    \          bool match = false;\n                for (long k in factorials.Keys)\n\
    \                {\n                    if (paren_string[i] == open && (paren_string[i\
    \ - k] == last))\n                    {\n                        res.Add(i);\n\
    \                        match = true;\n                        break;\n     \
    \               }\n                }\n                if (!match)\n          \
    \          throw new ArgumentException(\"Invalid parentheses string.\");\n   \
    \         }\n        }\n        return res;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv1hhocva.cs(32,17): error CS1003: Syntax error, ''foreach'' expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // First, generate a string with all opening parentheses\
    \ and all closing parentheses removed.\n        string all_parens = paren_string.Replace(\"\
    (\", \"\").Replace(\")\", \"\").Replace(\" \", \"\");\n\n        // Second, we\
    \ convert the string to a list of characters.\n        List<char> all_chars =\
    \ all_parens.ToCharArray();\n\n        // Third, we convert that list to an array.\n\
    \        char[] all_char_array = all_chars.ToArray();\n\n        // Fourth, we\
    \ recursively call itself until we reach the base case.\n        List<long> result\
    \ = new List<long>();\n        bool in_paren_stack = false;\n        bool in_paren_stack_at_least_one\
    \ = false;\n        long curr_level = 0;\n        bool first = true;\n       \
    \ foreach (char c in all_char_array) {\n            if (c == '(') {\n        \
    \        result.Add(curr_level);\n                if (!in_paren_stack) {\n   \
    \                 in_paren_stack = true;\n                    in_paren_stack_at_least_one\
    \ = false;\n                }\n            }\n            else if (c == ')') {\n\
    \                curr_level--;\n                if (in_paren_stack && in_paren_stack_at_least_one)\
    \ {\n                    in_paren_stack = false;\n                    in_paren_stack_at_least_one\
    \ = false;\n                }\n            }\n            else if (c == '(') {\n\
    \                in_paren_stack_at_least_one = true;\n            }\n        \
    \    else if (c == ')') {\n                in_paren_stack_at_least_one = false;\n\
    \            }\n            if (in_paren_stack && in_paren_stack_at_least_one)\
    \ {\n                curr_level++;\n            }\n            else if (in_paren_stack)\
    \ {\n                in_paren_stack = false;\n                in_paren_stack_at_least_one\
    \ = false;\n            }\n            first = false;\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7dtldmq.cs(19,32): error CS0029: Cannot implicitly convert type ''char[]''
    to ''System.Collections.Generic.List<char>''

    /tmp/tmpc7dtldmq.cs(29,14): warning CS0219: The variable ''first'' is assigned
    but its value is never used

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        List<int>\
    \ level_stack = new List<int>();\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = 0; i < paren_string.Length; ++i) {\n            char ch\
    \ = paren_string[i];\n            if (ch == '(' || ch == '[') {\n            \
    \    if (sb.Length > 0)\n                    levels.Add(ParseLevel(sb.ToString()));\n\
    \                sb.Clear();\n                level_stack.Add(0);\n          \
    \      levels[level_stack.Count - 1] = level_stack[level_stack.Count - 1] + 1;\n\
    \            } else if (ch == ')' || ch == ']') {\n                if (level_stack[level_stack.Count\
    \ - 1] > 0) {\n                    levels[level_stack.Count - 1] = levels[level_stack.Count\
    \ - 1] - 1;\n                    sb.Append(ch);\n                } else\n    \
    \                levels[level_stack.Count - 1] = 0;\n            }\n        }\n\
    \        if (sb.Length > 0)\n            levels.Add(ParseLevel(sb.ToString()));\n\
    \        return levels;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcfd0ozn5.cs(22,32): error CS0103: The name ''ParseLevel'' does not exist
    in the current context

    /tmp/tmpcfd0ozn5.cs(35,24): error CS0103: The name ''ParseLevel'' does not exist
    in the current context

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string parens = \"(){}[]\";\n        var parens_array\
    \ = parens.ToArray();\n        var opening_parens = new List<long>();\n      \
    \  var closings_parens = new List<long>();\n        Stack<long> stack = new Stack<long>();\n\
    \        List<long> list = new List<long>();\n        var count_parens = 0;\n\
    \        foreach(var c in paren_string) {\n            if (parens_array.Contains(c))\
    \ {\n                opening_parens.Add(count_parens);\n                closings_parens.Add(count_parens);\n\
    \                count_parens++;\n            }\n            else if (c == ')')\
    \ {\n                var max_closing = closings_parens.Max();\n              \
    \  if (max_closing > 0 && closings_parens.Count > max_closing) {\n           \
    \         list.Add(opening_parens[max_closing]);\n                }\n        \
    \        opening_parens.RemoveAt(opening_parens.Count - 1);\n                closings_parens.RemoveAt(closings_parens.Count\
    \ - 1);\n            }\n        }\n        if (closings_parens.Count > 1) {\n\
    \            list.Add(opening_parens[closings_parens.Count - 2]);\n        }\n\
    \        return list;\n    }\n    public static void Main(string[] args) {\n \
    \   Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphklo9o4m.cs(31,45): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // This stores the number of opening parentheses in\
    \ the string so far.\n        // This is used to determine when to output a comma\
    \ and a space between consecutive parentheses.\n        // It is also used to\
    \ output a comma after the first closing parenthesis.\n        int num_opening_parenthesis\
    \ = 0;\n        string str = paren_string;\n        List<long> list = new List<long>();\n\
    \        Stack<char> parens = new Stack<char>();\n        Stack<long> nums = new\
    \ Stack<long>();\n        char opening_brace = ')';\n\n        // Step 1: Iterate\
    \ through string one character at a time.\n        // Every time you see a closing\
    \ parenthesis, push it on to the stack parens.\n        // Every time you see\
    \ an opening parenthesis, push it on to the stack parens.\n        // Every time\
    \ you see a digit, push it on to the stack nums.\n        // Whenever you see\
    \ a closing brace, push it on to the stack and set opening_brace to ')'.\n   \
    \     foreach (char ch in str) {\n            if (ch == '(') {\n             \
    \   parens.Push(ch);\n                num_opening_parenthesis++;\n           \
    \ } else if (ch == ')') {\n                parens.Push(ch);\n                num_opening_parenthesis--;\n\
    \            } else if (char.IsDigit(ch)) {\n                nums.Push(long.Parse(ch.ToString()));\n\
    \            } else if (ch == '{') {\n                list.Add(nums.Pop());\n\
    \                parens.Push(ch);\n                num_opening_parenthesis++;\n\
    \                opening_brace = ch;\n            } else if (ch == '}') {\n  \
    \              list.Add(nums.Pop());\n                parens.Push(ch);\n     \
    \           num_opening_parenthesis--;\n                if (num_opening_parenthesis\
    \ == 0) {\n                    list.Add(long.Parse(opening_brace.ToString()));\n\
    \                    list.Add(nums.Pop());\n                }\n              \
    \  opening_brace = ')';\n            }\n        }\n\n        // Step 2: Iterate\
    \ through stack until you find an opening parenthesis.\n        // Every time\
    \ you see an opening parenthesis, pop 2 items off the stack (one from the stack\
    \ parens,\n        // and one from nums).\n        // If the second item from\
    \ nums matches the number of opening parenthesis (indicated by the value of the\n\
    \        // variable num_opening_parenthesis), then output the string in parentheses\
    \ with a comma between the\n        // pairs of parentheses.\n        // Otherwise,\
    \ output the string in parentheses with a space between the pairs of parentheses.\n\
    \        foreach (char ch in parens) {\n            if (ch == '(') {\n       \
    \         int num_parens = parens.Pop() - 1;\n                bool is_last_num\
    \ = (nums.Pop() == num_opening_paren\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkjrb0gsp.cs(66,68): error CS1026: ) expected

    /tmp/tmpkjrb0gsp.cs(66,68): error CS1002: ; expected

    /tmp/tmpkjrb0gsp.cs(68,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpkjrb0gsp.cs(74,2): error CS1513: } expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var paren_array = paren_string.Split(' ');\n      \
    \  var nesting_levels = paren_array.Select(p => new {\n            Parent = p,\n\
    \            Index = paren_array.IndexOf(p)\n        }).Where(x => x.Parent.Length\
    \ > x.Index).Select(x => x.Parent.Length - x.Index).ToArray();\n        var max_levels\
    \ = nesting_levels.Max();\n        return nesting_levels.Select(l => (long)Math.Ceiling(Math.Log(max_levels,\
    \ l))).ToList();\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuxjg2pf6.cs(18,33): error CS1501: No overload for method ''IndexOf'' takes
    1 arguments

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ List<long> stack = new List<long>();\n        bool stack_is_empty = true;\n\
    \        Stack<long> stack_top = new Stack<long>();\n        foreach (char c in\
    \ paren_string) {\n            if (c == '(') {\n                stack_top.Push(stack.Count);\n\
    \                stack_is_empty = false;\n                stack.Push(-1);\n  \
    \          } else if (c == ')') {\n                if (stack_is_empty) {\n   \
    \                 stack_top.Pop();\n                } else {\n               \
    \     stack_is_empty = true;\n                }\n                stack.Pop();\n\
    \            } else if (c == ' ') {\n                if (stack_is_empty) {\n \
    \                   stack_top.Pop();\n                } else {\n             \
    \       stack_is_empty = true;\n                }\n                stack.Pop();\n\
    \            } else {\n                stack.Push(c);\n                stack_is_empty\
    \ = true;\n            }\n            if (stack_is_empty) {\n                max_levels.Add(stack.Count);\n\
    \                stack_is_empty = true;\n            }\n        }\n        return\
    \ max_levels;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpie4ipkzx.cs(23,23): error CS1061: ''List<long>'' does not contain a definition
    for ''Push'' and no accessible extension method ''Push'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpie4ipkzx.cs(30,23): error CS1061: ''List<long>'' does not contain a definition
    for ''Pop'' and no accessible extension method ''Pop'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpie4ipkzx.cs(37,23): error CS1061: ''List<long>'' does not contain a definition
    for ''Pop'' and no accessible extension method ''Pop'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpie4ipkzx.cs(39,23): error CS1061: ''List<long>'' does not contain a definition
    for ''Push'' and no accessible extension method ''Push'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        char[] parens = paren_string.ToCharArray();\n     \
    \   Stack<char> nested_parens = new Stack<char>();\n        bool in_parens = false;\n\
    \        bool in_nested_parens = false;\n        long max_nesting_level = 0;\n\
    \        long nesting_level = 0;\n        foreach (char c in parens) {\n     \
    \       switch (c) {\n                case ')':\n                case ')(':\n\
    \                case ')(': nesting_level--;\n                    break;\n   \
    \             case '(':\n                case '(':\n                case '(':\
    \ nesting_level++;\n                    break;\n                case '(':\n  \
    \                  if (!in_nested_parens) {\n                        in_nested_parens\
    \ = true;\n                    }\n                    if (!in_parens && nested_parens.Count\
    \ == 0) {\n                        max_nesting_level = nesting_level;\n      \
    \              }\n                    break;\n                case ')':\n    \
    \                if (in_nested_parens && !in_parens) {\n                     \
    \   max_nesting_level--;\n                    }\n                    break;\n\
    \            }\n            nested_parens.Push(c);\n        }\n        List<long>\
    \ results = new List<long>();\n        for (int i = 0; i <= max_nesting_level;\
    \ i++) {\n            if (nested_parens.Count == 0) {\n                break;\n\
    \            }\n            char top = nested_parens.Peek();\n            if (top\
    \ != '(') {\n                continue;\n            }\n            results.Add(nesting_level);\n\
    \            nested_parens.Pop();\n        }\n        return results;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7nkgp_1e.cs(24,22): error CS1012: Too many characters in character literal

    /tmp/tmp7nkgp_1e.cs(25,22): error CS1012: Too many characters in character literal

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var result_list = new List<long>();\n        var stack\
    \ = new Stack<long>();\n\n        // Iterate through all the characters in the\
    \ string.\n        for (int i = 0; i < paren_string.Length; i++) {\n         \
    \   var current_char = paren_string[i];\n\n            // If the character is\
    \ '(' and stack is not empty,\n            // then add the current character to\
    \ the stack and decrement the result count.\n            if (current_char == '('\
    \ && !stack.Count == 0) {\n                var result_count = result_list.Count;\n\
    \                result_list.Add(stack.Count);\n                stack.Count--;\n\
    \            }\n            // If the character is ')' and stack is not empty,\n\
    \            // then add the result count to the stack and decrement the result\
    \ count.\n            else if (current_char == ')' && stack.Count != 0) {\n  \
    \              var result_count = result_list.Count;\n                result_list.Add(stack.Count);\n\
    \                stack.Count--;\n            }\n            // If the current\
    \ character is ')' and stack is empty,\n            // then add the result count\
    \ to the stack.\n            else if (current_char == ')' && stack.Count == 0)\
    \ {\n                result_list.Add(stack.Count);\n                stack.Count--;\n\
    \            }\n            // If the current character is '(' and stack is not\
    \ empty,\n            // then add the current character to the stack and increment\
    \ the result count.\n            else if (current_char == '(' && !stack.Count\
    \ == 0) {\n                result_list.Add(stack.Count);\n                stack.Count++;\n\
    \            }\n            // If the current character is ')' and stack is empty,\n\
    \            // then add the result count to the stack.\n            else if (current_char\
    \ == ')' && stack.Count == 0) {\n                result_list.Add(stack.Count);\n\
    \                stack.Count++;\n            }\n            // If the current\
    \ character is ')' and stack is not empty and result count > 0,\n            //\
    \ then output the result list.\n            else if (current_char == ')' && stack.Count\
    \ != 0 && result_list.Count > 0) {\n                Debug.Assert(result_list.Count\
    \ > 0, \"Invalid result list\");\n                result_list.Reverse();\n   \
    \             var result_count = result_list.Count;\n                result_list.RemoveAt(0);\n\
    \                for (int j = 0; j < result_count; j++) {\n                  \
    \  Debug.Assert(result_list.Count > j, \"Invalid result list\");\n           \
    \         result_list.RemoveAt(j);\n                }\n                var result_string\
    \ = new StringBuilder(new String());\n                foreach (var item in result_list)\n\
    \                    result_string.Append(item + \", \");\n                Debug.Assert(result_string.Length\
    \ > 0, \"Invalid result list\");\n                result_string.Remove(result_string.Length\
    \ - 2, 2);\n                return new List<long> { (long)Convert.ToInt64(result_string.ToString())\
    \ };\n            }\n            // If the current character is ')', then add\
    \ the current character to the stack.\n            else if (current_char == ')')\
    \ {\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnt91srbp.cs(75,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpnt91srbp.cs(81,2): error CS1513: } expected

    '
  timestamp: 1659976351
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) {\n            return\
    \ new List<long>();\n        }\n        var result = new List<long>();\n     \
    \   string last_group_open = null;\n        long max_level_open = 0;\n       \
    \ long max_level = 0;\n        bool group_is_empty = true;\n        foreach (char\
    \ ch in paren_string) {\n            switch (ch) {\n                case '(':\n\
    \                    if (!group_is_empty) {\n                        // We've\
    \ already found a group, so the level is 1 greater than the one just opened\n\
    \                        result.Add(max_level_open);\n                    }\n\
    \                    last_group_open = ch;\n                    group_is_empty\
    \ = false;\n                    break;\n                case ')':\n          \
    \          if (last_group_open == '(') {\n                        // We found\
    \ a group that is empty at the current level, so we only care about the group\
    \ at the current level\n                        result.Add(max_level_open);\n\
    \                    }\n                    break;\n                default:\n\
    \                    if (last_group_open != null && last_group_open == ch) {\n\
    \                        // The current group is empty at the current level, so\
    \ we only care about the group\n                        result.Add(max_level_open);\n\
    \                    }\n                    result.Add((long)max_level);\n   \
    \                 result.Add((long)max_level_open);\n                    max_level++;\n\
    \                    last_group_open = ch;\n                    max_level_open++;\n\
    \                    group_is_empty = true;\n                    break;\n    \
    \        }\n        }\n        if (max_level_open == 0) {\n            return\
    \ new List<long>();\n        }\n        return result;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpg0wxcoum.cs(30,39): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    /tmp/tmpg0wxcoum.cs(34,25): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpg0wxcoum.cs(40,52): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpg0wxcoum.cs(47,39): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n\n        var groups = paren_string.Split(' ');\n\
    \        foreach(var group in groups) {\n            var chars = group.ToCharArray();\n\
    \            var nesting = chars.Count() - 1;\n            if(nesting == 0)\n\
    \                nesting = 1;\n\n            for(int i = 0; i < nesting; i++)\
    \ {\n                stack.Add(chars[i]);\n            }\n\n            while\
    \ (stack.Count > 0 && chars[stack.Count - 1] == '(') {\n                stack.RemoveAt(stack.Count\
    \ - 1);\n                result.Add(stack.Count);\n            }\n\n         \
    \   while(stack.Count > 0) {\n                result.Add(stack.Count);\n     \
    \           stack.Pop();\n            }\n        }\n\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp65zm7a24.cs(26,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp65zm7a24.cs(30,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''RemoveAt'' and no accessible extension method ''RemoveAt'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string s = paren_string.Trim();\n        List<long>\
    \ max_level = new List<long>();\n        Stack<long> level = new Stack<long>();\n\
    \        int paren_count = 0;\n        for(int i = 0; i < s.Length; i++) {\n \
    \           if(s[i] == '(') {\n                paren_count++;\n              \
    \  level.Push(paren_count);\n                Console.WriteLine(level.Pop());\n\
    \            } else if(s[i] == ')') {\n                paren_count--;\n      \
    \          level.RemoveAt(level.Count - 1);\n                Console.WriteLine(level.Pop());\n\
    \                if(!level.Any()) {\n                    max_level.Add(paren_count);\n\
    \                }\n            }\n        }\n        return max_level;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmppokugt9n.cs(26,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''RemoveAt'' and no accessible extension method ''RemoveAt'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        StringBuilder\
    \ sb = new StringBuilder(paren_string);\n        while (true) {\n            sb.Replace(\"\
    ()\", \"(1)\", 1);\n            sb.Replace(\"()\", \"(1)(1)\", 2);\n         \
    \   sb.Replace(\"()\", \"(1)(1)(1)\", 3);\n            levels.Add(new long(sb.ToString().Trim().Length));\n\
    \            if (!sb.ToString().EndsWith(\"()\")) {\n                sb.Append(\"\
    )\");\n                break;\n            }\n            sb.Remove(sb.Length\
    \ - 1, 1);\n        }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqhyp3vh2.cs(18,16): error CS1501: No overload for method ''Replace'' takes
    3 arguments

    /tmp/tmpqhyp3vh2.cs(19,16): error CS1501: No overload for method ''Replace'' takes
    3 arguments

    /tmp/tmpqhyp3vh2.cs(20,16): error CS1501: No overload for method ''Replace'' takes
    3 arguments

    /tmp/tmpqhyp3vh2.cs(21,28): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> results = new List<long>();\n        Stack<long>\
    \ levels = new Stack<long>();\n        bool inParentheses = false;\n        foreach\
    \ (char c in paren_string) {\n            if ((c == '(') && (inParentheses ==\
    \ false)) {\n                inParentheses = true;\n                levels.Push(1);\n\
    \            }\n            if ((c == ')') && (inParentheses)) {\n           \
    \     inParentheses = false;\n                long level = levels[levels.Count\
    \ - 1];\n                while (level > 0) {\n                    level--;\n \
    \                   results.Add(level);\n                }\n            }\n  \
    \          if ((c == '(') && (inParentheses)) {\n                inParentheses\
    \ = true;\n                levels.Push(1);\n            }\n            if ((c\
    \ == ')') && (inParentheses)) {\n                inParentheses = false;\n    \
    \            levels.Pop();\n            }\n        }\n        return results;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj9v5lq4s.cs(25,30): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int open_count = 0;\n        int close_count = 0;\n\
    \        int depth = 0;\n        int nested_level = 0;\n        bool ingroup =\
    \ false;\n        List<long> list = new List<long>();\n        char[] chars =\
    \ paren_string.ToCharArray();\n        for (int i = 0; i < chars.Length; i++)\
    \ {\n            if (chars[i] == '(') open_count++;\n            if (chars[i]\
    \ == ')') close_count++;\n            if (chars[i] == ' ') {\n               \
    \ if (close_count == 0) {\n                    list.Add(new long[]{(long)nested_level,\
    \ (long)depth});\n                    nested_level++;\n                    depth++;\n\
    \                    close_count = 0;\n                    ingroup = true;\n \
    \               } else {\n                    nested_level--;\n              \
    \      close_count--;\n                }\n            }\n            if (open_count\
    \ > close_count && !ingroup) {\n                depth--;\n                open_count\
    \ = 0;\n            }\n        }\n        return list;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp03m0gg_r.cs(27,30): error CS1503: Argument 1: cannot convert from ''long[]''
    to ''long''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nesting_levels = new List<long>();\n   \
    \     // We are going to parse each group in the string in reverse order.\n  \
    \      string group_str = paren_string;\n        for (int i = group_str.Length\
    \ - 1; i >= 0; i--) {\n            // For each parenthesis in the group, find\
    \ the deepest parenthesis level.\n            if (group_str[i] == '(') {\n   \
    \             nesting_levels.Add(0);\n            } else if (group_str[i] == '(')\
    \ {\n                nesting_levels.Add(1);\n            } else if (group_str[i]\
    \ == ')') {\n                nesting_levels.RemoveAt(nesting_levels.Count - 1);\n\
    \            }\n            group_str = group_str.Remove(i, 1);\n        }\n \
    \       return nesting_levels;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00068] in <d12bf0babe694f32a510bc4e2fbc99c7>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <d12bf0babe694f32a510bc4e2fbc99c7>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00068] in <d12bf0babe694f32a510bc4e2fbc99c7>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <d12bf0babe694f32a510bc4e2fbc99c7>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested_levels = new List<long>();\n    \
    \    long deepest_nesting_level = 0;\n        Stack<long> paren_stack = new Stack<long>();\n\
    \        foreach (char c in paren_string.ToCharArray()) {\n            if (c ==\
    \ '(') {\n                if (paren_stack.Count == 0)\n                    deepest_nesting_level++;\n\
    \                else\n                    deepest_nesting_level = paren_stack.Pop();\n\
    \                nested_levels.Add(deepest_nesting_level);\n                paren_stack.Push(deepest_nesting_level);\n\
    \            }\n            else if (c == ')') {\n                if (paren_stack.Count\
    \ > 0) {\n                    deepest_nesting_level = paren_stack.Pop();\n   \
    \                 nested_levels.Add(deepest_nesting_level);\n                }\n\
    \                else\n                    throw new Exception(\"Mismatched closing\
    \ parentheses.\");\n            }\n            else if (c == ' ') {\n        \
    \        // Do not add to nested levels.\n            }\n            else if (c\
    \ == ',') {\n                // Ignore trailing comma.\n            }\n      \
    \      else\n                throw new Exception(\"Character is not permitted\
    \ inside parentheses: \" + c);\n        }\n        return nested_levels;\n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.Exception: Mismatched closing parentheses.\n\
    \  at Problem.ParseNestedParens (System.String paren_string) [0x00093] in <9cf6fe3661b145f7bf863d7da50576e4>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <9cf6fe3661b145f7bf863d7da50576e4>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.Exception: Mismatched closing parentheses.\n\
    \  at Problem.ParseNestedParens (System.String paren_string) [0x00093] in <9cf6fe3661b145f7bf863d7da50576e4>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <9cf6fe3661b145f7bf863d7da50576e4>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nest_levels = new List<long>();\n      \
    \  string parenthesis = \"()\";\n        int nest_level = 1;\n        bool inside_parenthesis\
    \ = false;\n        List<string> nested_strings = new List<string>();\n      \
    \  foreach (char ch in paren_string) {\n            if (parenthesis.Contains(ch))\
    \ {\n                if (inside_parenthesis == false) {\n                    inside_parenthesis\
    \ = true;\n                    nested_strings.Add(ch);\n                }\n  \
    \              else if (nested_strings.Count > 0) {\n                    nested_strings.RemoveAt(nested_strings.Count\
    \ - 1);\n                    nest_levels.Add(nest_level);\n                  \
    \  inside_parenthesis = false;\n                }\n            }\n           \
    \ else {\n                if (inside_parenthesis == true) {\n                \
    \    nested_strings.Add(ch);\n                }\n            }\n        }\n  \
    \      nest_levels.Add(nest_level);\n        return nest_levels;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyio2lcbj.cs(24,40): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmpyio2lcbj.cs(34,40): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        char[] delimiters = { ')' };\n        var stack = new\
    \ Stack<long>();\n        var max_count = new long();\n        int i = paren_string.IndexOf('(');\n\
    \        while (i != -1) {\n            long count = 1;\n            var j = paren_string.IndexOf('(',\
    \ i + 1);\n            if (j == -1) {\n                j = paren_string.Length;\n\
    \            }\n            while (paren_string[j] != ')') {\n               \
    \ count++;\n                j++;\n            }\n            stack.Add(count);\n\
    \            i = paren_string.IndexOf('(', j + 1);\n        }\n        while (!stack.IsEmpty())\
    \ {\n            max_count = stack.Pop();\n            for (int j = 0; j < stack.Count;\
    \ j++) {\n                if (max_count < stack[j]) {\n                    max_count\
    \ = stack[j];\n                }\n            }\n        }\n        var nested\
    \ = new List<long>();\n        while (stack.Count > 0) {\n            nested.Add(stack.Pop());\n\
    \        }\n        return nested;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsoohqal9.cs(29,19): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpsoohqal9.cs(32,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpsoohqal9.cs(35,33): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    /tmp/tmpsoohqal9.cs(36,33): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_level = new List<long>();\n        Stack<long>\
    \ level = new Stack<long>();\n        bool has_level = true;\n        bool is_paranthesis_open\
    \ = false;\n        long level_value = 1;\n\n        // Parse the input string\
    \ and find the starting character for each of the parenthesis\n        List<char>\
    \ parenthesis_start_chars = new List<char>();\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == '(') {\n                parenthesis_start_chars.Add(paren_string[i]);\n\
    \                is_paranthesis_open = true;\n            }\n            if (parenthesis_start_chars.Count\
    \ == parenthesis_start_chars.Count - 1 && paren_string[i] == ')') {\n        \
    \        is_paranthesis_open = false;\n                level_value++;\n      \
    \          level.push(level_value);\n                has_level = true;\n     \
    \       }\n            if (parenthesis_start_chars.Count == parenthesis_start_chars.Count\
    \ - 1 && paren_string[i] == ')') {\n                is_paranthesis_open = false;\n\
    \                level.push(level_value);\n                has_level = true;\n\
    \            }\n        }\n\n        // Find the maximum level of parenthesis\n\
    \        for (int i = 0; i < level.Count; i++) {\n            if (max_level.Count\
    \ <= level[i]) {\n                max_level.Add(level[i]);\n            }\n  \
    \          if (level[i] < max_level.Count) {\n                has_level = false;\n\
    \            }\n        }\n        if (max_level.Count > 0) {\n            return\
    \ max_level;\n        } else {\n            return null;\n        }\n    }\n \
    \   public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyc4ac2eu.cs(31,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyc4ac2eu.cs(36,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpyc4ac2eu.cs(43,36): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    /tmp/tmpyc4ac2eu.cs(44,31): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    /tmp/tmpyc4ac2eu.cs(46,17): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    /tmp/tmpyc4ac2eu.cs(17,14): warning CS0219: The variable ''has_level'' is assigned
    but its value is never used

    /tmp/tmpyc4ac2eu.cs(18,14): warning CS0219: The variable ''is_paranthesis_open''
    is assigned but its value is never used

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int count = 0;\n        int open_brackets = 0;\n  \
    \      List<long> nesting = new List<long>();\n        Stack<long> stack = new\
    \ Stack<long>();\n        foreach (char c in paren_string) {\n            if (c\
    \ == '(') {\n                open_brackets += 1;\n                stack.Add(0);\n\
    \            } else if (c == ')') {\n                open_brackets -= 1;\n   \
    \             long top = stack.Pop();\n                if (top == 0 && open_brackets\
    \ == 0) {\n                    nesting.Add(count);\n                }\n      \
    \          count += 1;\n            }\n        }\n        return nesting;\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmprd8vz64f.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int depth = 0;\n        int i = paren_string.IndexOf('(',\
    \ 0);\n        while (i != -1) {\n            depth++;\n            i = paren_string.IndexOf('(',\
    \ i + 1);\n        }\n\n        // count the amount of nesting\n        int count\
    \ = new Regex(@\"\\((.*?)\\)\").Matches(paren_string).Count;\n\n        List<long>\
    \ result = new List<long>();\n        result.Add(depth);\n        for (int j =\
    \ 0; j < count; j++) {\n            depth = 0;\n            i = paren_string.IndexOf('(',\
    \ 0);\n            while (i != -1) {\n                depth++;\n             \
    \   i = paren_string.IndexOf('(', i + 1);\n            }\n\n            result.Add(depth);\n\
    \        }\n\n        // Find the highest nesting level\n        long deepest_nesting\
    \ = 0;\n        foreach (long l in result) {\n            if (deepest_nesting\
    \ < l) {\n                deepest_nesting = l;\n            }\n        }\n\n \
    \       return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkdkg0867.cs(23,25): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Keep track of how many open/close parentheses we\
    \ have seen\n        // and what those are currently being closed by.\n      \
    \  List<long> open = new List<long>();\n        List<long> closed = new List<long>();\n\
    \        // How many levels of nesting are we currently at?\n        int level\
    \ = 0;\n        foreach(var i in paren_string) {\n            // Open the bracket\
    \ if it's not the first time we're seeing this one\n            if (!open.Contains(i))\
    \ {\n                open.Add(i);\n            }\n            // Close the bracket\
    \ if we have gone all the way through it\n            if (open.Count > 0 && i\
    \ == closed[closed.Count - 1]) {\n                open.RemoveAt(open.Count - 1);\n\
    \                closed.Add(i);\n            }\n            // Increase the level\
    \ of nesting if we see a bracket\n            if (i == ')') {\n              \
    \  level++;\n            }\n            if (i == '(') {\n                level--;\n\
    \            }\n        }\n        // The deepest level of nesting is what we\
    \ need\n        return new List<long> {level};\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00056] in <5826b74fbbd740e5857673d7caa285bf>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <5826b74fbbd740e5857673d7caa285bf>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00056] in <5826b74fbbd740e5857673d7caa285bf>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <5826b74fbbd740e5857673d7caa285bf>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var results = new List<long>();\n        var groups\
    \ = new List<List<long>>();\n        var curr = new List<long>();\n        var\
    \ next_paren_level = 0;\n        for (var i = 0; i < paren_string.Length; i++)\
    \ {\n            var ch = paren_string[i];\n            switch (ch) {\n      \
    \          case '(':\n                    if (next_paren_level < groups.Count)\
    \ {\n                        var level = next_paren_level;\n                 \
    \       next_paren_level++;\n                        curr.Add(level);\n      \
    \              } else {\n                        results.Add(curr.Last());\n \
    \                       curr.Clear();\n                        groups = new List<List<long>>();\n\
    \                        next_paren_level = 0;\n                    }\n      \
    \              break;\n                case ')':\n                    if (next_paren_level\
    \ > 0) {\n                        var level = curr.Last();\n                 \
    \       results.Add(level);\n                        curr.RemoveAt(curr.Count\
    \ - 1);\n                        groups[curr.Last()].RemoveAt(groups[curr.Last()].Count\
    \ - 1);\n                        next_paren_level--;\n                    } else\
    \ {\n                        results.Add(curr.Last());\n                     \
    \   curr.Clear();\n                        groups = new List<List<long>>();\n\
    \                        next_paren_level = 0;\n                    }\n      \
    \              break;\n                default:\n                    if (groups[curr.Last()].Count\
    \ > 0) {\n                        groups[curr.Last()].Add(i);\n              \
    \      } else {\n                        curr.Add(i);\n                    }\n\
    \                    break;\n            }\n        }\n        results.Add(curr.Last());\n\
    \        return results;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpncd55_vw.cs(39,32): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmpncd55_vw.cs(39,61): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmpncd55_vw.cs(49,32): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmpncd55_vw.cs(50,32): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        StringBuilder nested_paren_string = new StringBuilder();\n\
    \n        // This variable keeps track of how many nested parentheses\n      \
    \  // are present in the string. We start by assuming no nested parentheses.\n\
    \        long number_of_nested_parentheses = 0;\n\n        foreach (char paren\
    \ in paren_string) {\n            // If the current char is a parenthesis, increment\
    \ the number of parentheses\n            // present in the string\n          \
    \  if (paren == '(') {\n                number_of_nested_parentheses++;\n    \
    \        }\n            // If the current char is a parenthesis, decrement the\
    \ number of parentheses\n            // present in the string\n            else\
    \ if (paren == ')') {\n                number_of_nested_parentheses--;\n     \
    \       }\n\n            // If the number of nested parentheses equals the number\
    \ of nested parentheses in the string\n            // then we can add this string\
    \ to the result list.\n            if (number_of_nested_parentheses == 0) {\n\
    \                nested_paren_string.Append(paren);\n            }\n\n       \
    \     // Otherwise, if the number of nested parentheses in the string is greater\
    \ than 0\n            // but less than the total number of nested parentheses\
    \ in the string\n            else if (number_of_nested_parentheses > 0 && number_of_nested_parentheses\
    \ < nested_paren_string.Length) {\n                // Then we append a space to\
    \ the string\n                nested_paren_string.Append(\" \");\n           \
    \ }\n        }\n\n        // If the number of nested parentheses is greater than\
    \ the length of the string\n        // then we append a space to the string\n\
    \        if (number_of_nested_parentheses > nested_paren_string.Length) {\n  \
    \          nested_paren_string.Append(\" \");\n        }\n\n        // Split the\
    \ string at the spaces and remove the last item from the list\n        // since\
    \ we already appended a space at the beginning.\n        nested_paren_string.Remove(nested_paren_string.Length\
    \ - 1, 1);\n\n        // Convert string list to long list\n        return new\
    \ List<long>(nested_paren_string.ToString().Split(' ').Select(s => long.Parse(s)));\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in\
    \ a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean\
    \ overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles\
    \ styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<ParseNestedParens>b__0_0 (System.String s) [0x00000] in\
    \ <67057387f3154208a99a03c0203ff594>:0 \n  at System.Linq.Enumerable+SelectArrayIterator`2[TSource,TResult].MoveNext\
    \ () [0x0003a] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable\
    \ (System.Collections.Generic.IEnumerable`1[T] enumerable) [0x00059] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Collections.Generic.List`1[T]..ctor (System.Collections.Generic.IEnumerable`1[T]\
    \ collection) [0x00062] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x000ef] in <67057387f3154208a99a03c0203ff594>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <67057387f3154208a99a03c0203ff594>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was\
    \ not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException\
    \ (System.Boolean overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles\
    \ styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<ParseNestedParens>b__0_0 (System.String s) [0x00000] in\
    \ <67057387f3154208a99a03c0203ff594>:0 \n  at System.Linq.Enumerable+SelectArrayIterator`2[TSource,TResult].MoveN"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<char> group = new List<char>();\n        List<long>\
    \ max = new List<long>();\n        foreach (char ch in paren_string) {\n     \
    \       group.Add(ch);\n        }\n        while (group.Count > 0) {\n       \
    \     if (group.Count % 2 == 0) {\n                long n = Convert.ToInt64(group.Take(group.Count\
    \ / 2).ToList());\n                max.Add(n);\n                for (int i = 0;\
    \ i < group.Count / 2; i++) {\n                    group.RemoveAt(0);\n      \
    \          }\n            }\n            else {\n                long n = Convert.ToInt64(group.Take(group.Count\
    \ / 2).ToList());\n                max.Add(n);\n                for (int i = 0;\
    \ i < group.Count / 2; i++) {\n                    group.RemoveAt(0);\n      \
    \          }\n            }\n        }\n        return max;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidCastException: Specified cast is\
    \ not valid.\n  at System.Convert.ToInt64 (System.Object value) [0x00003] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x000ae] in <dfc43454bbf0433fb7d715fb4e3b26f2>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <dfc43454bbf0433fb7d715fb4e3b26f2>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidCastException: Specified\
    \ cast is not valid.\n  at System.Convert.ToInt64 (System.Object value) [0x00003]\
    \ in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens (System.String\
    \ paren_string) [0x000ae] in <dfc43454bbf0433fb7d715fb4e3b26f2>:0 \n  at Problem.Main\
    \ (System.String[] args) [0x00001] in <dfc43454bbf0433fb7d715fb4e3b26f2>:0 \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> output = new List<long>();\n        string\
    \ cur_level = \"\";\n        for(int i=0; i<paren_string.Length; i++) {\n    \
    \        if((paren_string[i] == '(') && (cur_level.Length == 0)) {\n         \
    \       output.Add((long) (i+1));\n            }\n            else if((paren_string[i]\
    \ == ')') && (cur_level.Length > 0)) {\n                output.Add((long) (cur_level.Length\
    \ - 1));\n            }\n            cur_level += paren_string[i];\n        }\n\
    \        return output;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <38d4bc75d6dc4bbbac024f9be42b74c6>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <38d4bc75d6dc4bbbac024f9be42b74c6>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) return new List<long>();\n\
    \n        List<long> levels = new List<long>();\n\n        // Add initial parentheses.\n\
    \        List<long> parens = new List<long>(new long[] {(long)0L});\n        foreach\
    \ (var x in paren_string.ToCharArray()) {\n            List<long> temp_levels\
    \ = new List<long>();\n            if (x == '(') temp_levels.Add((long)1L);\n\
    \            else if (x == ')') temp_levels.Add((long)1L);\n            else if\
    \ (x == '[') temp_levels.Add((long)2L);\n            else if (x == ']') temp_levels.Add((long)2L);\n\
    \            else if (x == '{')\n                temp_levels.Add(new long { (long)3L\
    \ });\n            else if (x == '}')\n                temp_levels.Add(new long\
    \ { (long)3L });\n            else temp_levels.Add((long)0L);\n\n            if\
    \ (parens.Count == 0) {\n                parens.AddRange(x);\n               \
    \ levels.AddRange(temp_levels);\n                continue;\n            }\n\n\
    \            // Recursively parse any more parenthesis and remove from paren stack.\n\
    \            List<long> parsed_levels = ParseNestedParens(x.ToString());\n   \
    \         if (parsed_levels.Count > 0) {\n                parens.RemoveRange(0,\
    \ parens.Count);\n                temp_levels.RemoveRange(0, temp_levels.Count);\n\
    \                levels.AddRange(temp_levels.Union(parsed_levels));\n        \
    \    } else {\n                // If no more nested parentheses, just add it to\
    \ the level.\n                levels.AddRange(temp_levels);\n            }\n \
    \       }\n\n        return levels.OrderByDescending(x=>x).ToList();\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwvbvd3_5.cs(28,42): error CS1922: Cannot initialize type ''long'' with
    a collection initializer because it does not implement ''System.Collections.IEnumerable''

    /tmp/tmpwvbvd3_5.cs(30,42): error CS1922: Cannot initialize type ''long'' with
    a collection initializer because it does not implement ''System.Collections.IEnumerable''

    /tmp/tmpwvbvd3_5.cs(34,33): error CS1503: Argument 1: cannot convert from ''char''
    to ''System.Collections.Generic.IEnumerable<long>''

    '
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Parse string\n        var groups = paren_string.Split(new\
    \ char[] { '(', ')', ' ' });\n\n        // Find deepest level of nesting for each\
    \ of the group\n        var max_level = new List<long>(new long[] {0L, 0L});\n\
    \        for (int i = 0; i < groups.Length; i++) {\n            var current_level_nesting\
    \ = new List<long>(new long[] {0L, 0L});\n            int group_index = 0;\n \
    \           for (int j = i; j < groups.Length; j++) {\n                if (groups[j].Equals('('))\
    \ {\n                    current_level_nesting.Add(max_level.Last());\n      \
    \              max_level = new List<long>(new long[] {current_level_nesting.Last()\
    \ + 1L, 0L});\n                    group_index++;\n                }\n       \
    \         else if (groups[j].Equals(')')) {\n                    if (current_level_nesting.Last()\
    \ <= max_level[group_index]) {\n                        max_level[group_index]\
    \ = current_level_nesting.Last();\n                    }\n                   \
    \ else {\n                        group_index++;\n                        max_level[group_index]\
    \ = max_level[group_index - 1];\n                    }\n                }\n  \
    \              else {\n                    current_level_nesting.Add(max_level.Last());\n\
    \                }\n            }\n        }\n\n        // Output\n        return\
    \ max_level;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <b0dadfca383f498795ffb5fb2bee4af4>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <b0dadfca383f498795ffb5fb2bee4af4>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var parens_level = ParseParenthesesLevels(paren_string);\n\
    \n        // Convert parens_level to parens_level which has the deepest level\
    \ of nesting \n        var parens_level2 = parens_level.Select(x => parens_level.Max()).ToList();\n\
    \        // Sum all levels of nesting up to deepest level \n        var max_level\
    \ = parens_level2.Max();\n\n        return parens_level2.ToList();\n    }\n  \
    \  public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8b5fmyok.cs(15,28): error CS0103: The name ''ParseParenthesesLevels''
    does not exist in the current context

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int open = 0;\n        int closed = 0;\n        int\
    \ depth = 0;\n        int level_of_nesting = 0;\n        var depths = new List<long>();\n\
    \        var pairs = new List<Tuple<long, long>>();\n\n        paren_string =\
    \ paren_string.Replace(\" \", \"\");\n        paren_string = paren_string.TrimEnd(')');\n\
    \        paren_string = paren_string.TrimEnd('(');\n\n        for (int i = 0;\
    \ i < paren_string.Length; i++) {\n            char c = paren_string[i];\n\n \
    \           if (c == '(') {\n                open++;\n                depth++;\n\
    \            }\n            if (c == ')') {\n                closed++;\n     \
    \           depth--;\n            }\n\n            if (open > closed && depth\
    \ > 0 && closed > 0)\n                depths.Add(depth);\n\n            string\
    \ new_pair = string.Format(\"({0})\", depth);\n\n            if (i > 0)\n    \
    \            new_pair += ',';\n\n            new_pair += new_pair;\n\n       \
    \     if (level_of_nesting > 0 && level_of_nesting < depth) {\n              \
    \  level_of_nesting = 0;\n            }\n            if (level_of_nesting == depth)\
    \ {\n                level_of_nesting++;\n                pairs.Add(Tuple.Create(open,\
    \ closed));\n            }\n        }\n\n        var list = new List<long>();\n\
    \        foreach (var pair in pairs) {\n            list.Add(pair.Item1);\n  \
    \          list.Add(pair.Item2);\n        }\n\n        return list;\n    }\n \
    \   public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxbyq0x_l.cs(53,27): error CS1503: Argument 1: cannot convert from ''System.Tuple<int,
    int>'' to ''System.Tuple<long, long>''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Parsing the input\n        Regex regex = new Regex(\"\
    \\\\(|\\\\)\");\n        List<List<long>> levels = new List<List<long>>();\n \
    \       foreach (Match m in regex.Matches(paren_string)) {\n            // Add\
    \ the index to all the elements of the level list\n            levels.Add(m.Value.ToCharArray().ToList().Select((s,\
    \ i) => i).ToList());\n        }\n        // Find the deepest level of nesting\
    \ for each index\n        for (int i = 0; i < levels.Count - 1; i++) {\n     \
    \       for (int j = i + 1; j < levels.Count; j++) {\n                if (levels[i].All(l\
    \ => levels[j].Contains(l))) {\n                    // A matching pair of levels\
    \ was found\n                    return levels[j].ToList();\n                }\n\
    \            }\n        }\n        // A matching pair was not found for the deepest\
    \ level of nesting\n        return null;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpk3xo05n0.cs(16,9): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpk3xo05n0.cs(16,27): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpk3xo05n0.cs(18,18): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // If string does not contain at least three left parenthesis\
    \ then return a List<long> with the value 0\n        if (paren_string == null\
    \ || !paren_string.Contains(\"(\")) {\n            return new List<long>(new long[]{0L});\n\
    \        }\n        // Keep track of last found left parenthesis\n        long\
    \ left_paren = 0;\n        // Keep track of levels of nesting\n        long level\
    \ = 1;\n        // Keep track of levels of nesting for each group\n        List<long>\
    \ groups = new List<long>();\n        // Use regex to match multiple groups of\
    \ parenthesis\n        var matches = Regex.Matches(paren_string, @\"\\((?<group>\\\
    ()|(?<group>\\))\");\n        foreach (Match match in matches) {\n           \
    \ if (match.Groups[\"group\"].Value.Contains(\")\")) {\n                // Add\
    \ a new group of parentheses to the groups list\n                groups.add(level);\n\
    \                // Increment level of nesting\n                level++;\n   \
    \         } else {\n                // Remove the last group of parentheses from\
    \ the groups list\n                if (groups.Count > 0 && groups[groups.Count\
    \ - 1] == level) {\n                    groups.RemoveAt(groups.Count - 1);\n \
    \               }\n                // Decrement level of nesting\n           \
    \     level--;\n            }\n            // Update the left parenthesis\n  \
    \          if (match.Groups[\"group\"].Value.Contains(\"(\")) {\n            \
    \    left_paren++;\n            } else {\n                left_paren--;\n    \
    \        }\n        }\n        // Return the groups list\n        return new List<long>(groups);\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptd0jfrd0.cs(26,23): error CS0103: The name ''Regex'' does not exist in
    the current context

    /tmp/tmptd0jfrd0.cs(27,18): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmptd0jfrd0.cs(30,24): error CS1061: ''List<long>'' does not contain a definition
    for ''add'' and no accessible extension method ''add'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> deepest_level_list = new List<long>();\n\
    \        StringBuilder temp = new StringBuilder();\n        for (int i = 0; i\
    \ < paren_string.Length; i++) {\n            char ch = paren_string[i];\n    \
    \        if (ch == '(') temp.Append(ch);\n            else if (ch == ')') {\n\
    \                if (temp.Length > 0) {\n                    deepest_level_list.Add(new\
    \ long() { value = int.Parse(temp.ToString()) });\n                }\n       \
    \         temp.Clear();\n            }\n            else if (ch == ' ') {\n  \
    \              temp.Append(ch);\n            }\n        }\n        if (temp.Length\
    \ > 0) {\n            deepest_level_list.Add(new long() { value = int.Parse(temp.ToString())\
    \ });\n        }\n        return deepest_level_list;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpg82o21_e.cs(22,57): error CS0117: ''long'' does not contain a definition
    for ''value''

    /tmp/tmpg82o21_e.cs(31,49): error CS0117: ''long'' does not contain a definition
    for ''value''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Debug.Assert(paren_string != null);\n        List<long>\
    \ levels = new List<long>();\n        Stack<long> current_level = new Stack<long>();\n\
    \        foreach(char c in paren_string.ToCharArray()) {\n            if(c ==\
    \ '(') {\n                current_level.Push(levels.Count);\n            } else\
    \ if(c == ')') {\n                int current_level_count = current_level.Count;\n\
    \                while(current_level_count > 0) {\n                    levels[current_level_count]\
    \ = Math.Max(levels[current_level_count], current_level.Pop());\n            \
    \        current_level_count--;\n                }\n            }\n        }\n\
    \        return levels;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0005f] in <c071181a26d84849af19f65ff87364d2>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <c071181a26d84849af19f65ff87364d2>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0005f] in <c071181a26d84849af19f65ff87364d2>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <c071181a26d84849af19f65ff87364d2>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var nested_parens = new List<long>();\n        var\
    \ nested_parens_count = new List<long>();\n        // Nested parens are only counted\
    \ when they are balanced and at zero length.\n        bool in_balance;\n     \
    \   var level_stack = new Stack<long>();\n        var nested_parens_stack = new\
    \ Stack<long>();\n        foreach (var ch in paren_string) {\n            if (ch\
    \ == '(') {\n                in_balance = true;\n                nested_parens_stack.Clear();\n\
    \                level_stack.Clear();\n                nested_parens.Clear();\n\
    \                nested_parens.Add(0L);\n                nested_parens_count.Clear();\n\
    \                level_stack.Push(0L);\n            } else if (ch == ')') {\n\
    \                in_balance = in_balance && (nested_parens_stack.Count == 0);\n\
    \                level_stack.Pop();\n                nested_parens_count.Add(nested_parens.Last());\n\
    \            } else if (ch == ' ') {\n                continue;\n            }\
    \ else if (ch == '(' || ch == ')') {\n                nested_parens_stack.Clear();\n\
    \            } else if (in_balance && (nested_parens_stack.Count == 0) && (ch\
    \ == ')')) {\n                nested_parens.Add(level_stack.Last());\n       \
    \         nested_parens_count.Add(level_stack.Last());\n                level_stack.Pop();\n\
    \            } else if (in_balance && (nested_parens_stack.Count > 0) && ch ==\
    \ '(') {\n                nested_parens_stack.Push(level_stack.Last());\n    \
    \            level_stack.Push(nested_parens.Last());\n            } else if (in_balance\
    \ && (nested_parens_stack.Count > 0) && ch == ')') {\n                nested_parens_stack.Pop();\n\
    \                level_stack.Pop();\n            }\n        }\n        if (nested_parens_stack.Count\
    \ != nested_parens.Count) {\n            return null;\n        }\n        var\
    \ nested_parens_range = nested_parens_stack.Zip(nested_parens.Skip(nested_parens_stack.Count),\
    \ Tuple.Create).ToList();\n        var nested_parens_count_range = nested_parens_count.Zip(nested_parens.Skip(nested_parens_count.Count),\
    \ Tuple.Create).ToList();\n        // Find the first pair of parentheses which\
    \ do not have the same length in the first and second halves of the range.\n \
    \       // These are nested in the wrong order.\n        var mismatch = nested_parens_range.FindAll((item1,\
    \ item2) => item2.Item1 != item1.Item2);\n        if (mismatch.Count == 0) {\n\
    \            return null;\n        }\n        // Re-order the nesting ranges such\
    \ that the nested pair with the longer length is at the start.\n        var nested_parens_range_sorted\
    \ = nested_parens_range.OrderBy((item1, item2) => nested_parens_count_range.First(i\
    \ => nested_parens_count_range[i] == item2.\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpod5__8zk.cs(62,163): error CS1001: Identifier expected

    /tmp/tmpod5__8zk.cs(62,163): error CS1026: ) expected

    /tmp/tmpod5__8zk.cs(62,163): error CS1002: ; expected

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException(nameof(paren_string));\n\
    \        // This implementation uses the DFS approach with Stack and Queue\n \
    \       // as explained in https://www.geeksforgeeks.org/maximum-depth-of-nested-parenthesis/\n\
    \        Stack<long> stack = new Stack<long>();\n        Queue<long> queue = new\
    \ Queue<long>();\n        foreach (char ch in paren_string) {\n            if\
    \ (ch == '(') {\n                // Add this opening paren to the stack\n    \
    \            stack.Enqueue(1);\n            } else if (ch == ')') {\n        \
    \        // Remove the element from the stack\n                if (stack.Count\
    \ > 0) {\n                    long depth = stack.Dequeue();\n                \
    \    while (stack.Count > 0) {\n                        long current_depth = stack.Dequeue();\n\
    \                        if (current_depth > depth)\n                        \
    \    depth = current_depth;\n                    }\n                    if (depth\
    \ > queue.Count)\n                        queue.Enqueue(depth);\n            \
    \    }\n            } else if (char.IsWhiteSpace(ch)) {\n                // Skip\
    \ white spaces\n                continue;\n            } else {\n            \
    \    // Add this character to the queue\n                queue.Enqueue(Convert.ToInt64(ch));\n\
    \            }\n        }\n        // Return the deepest level of nesting of parenthesis\n\
    \        return queue.ToList();\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpn7jdbbya.cs(24,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Enqueue'' and no accessible extension method ''Enqueue'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpn7jdbbya.cs(28,40): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Dequeue'' and no accessible extension method ''Dequeue'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpn7jdbbya.cs(30,52): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Dequeue'' and no accessible extension method ''Dequeue'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> level_of_nesting = new List<long>();\n \
    \       StringBuilder builder = new StringBuilder();\n        HashSet<long> open_paren\
    \ = new HashSet<long>();\n        HashSet<long> open_paren2 = new HashSet<long>();\n\
    \        string opening_char = null;\n        long paren_counter = 0;\n      \
    \  bool is_opening = true;\n        long temp;\n        string current_char =\
    \ null;\n        char current_char2 = null;\n        string current_group = \"\
    \";\n        foreach (char c in paren_string) {\n            if (c == '(') is_opening\
    \ = true;\n            if (c == '(') is_opening = true;\n            if (c ==\
    \ ')' && is_opening) {\n                is_opening = false;\n                paren_counter++;\n\
    \                if (paren_counter == 1) {\n                    level_of_nesting.Add(1L);\n\
    \                    level_of_nesting.Add(0L);\n                } else {\n   \
    \                 level_of_nesting.Add(1L);\n                }\n            }\n\
    \            if (c == ')' && is_opening) {\n                is_opening = false;\n\
    \                paren_counter--;\n                if (paren_counter == 0) {\n\
    \                    level_of_nesting.Add(0L);\n                } else {\n   \
    \                 level_of_nesting.Add(0L);\n                }\n            }\n\
    \            if (c == ' ' && is_opening) {\n                current_group += c;\n\
    \            }\n            if (c == '(') {\n                open_paren.Add(paren_counter);\n\
    \                builder.Append(c);\n                paren_counter++;\n      \
    \      }\n            if (c == ')') {\n                if (open_paren.Contains(paren_counter))\
    \ {\n                    temp = open_paren.Remove(paren_counter);\n          \
    \          if (open_paren2.Contains(temp)) {\n                        level_of_nesting.Add(1L);\n\
    \                    } else if (open_paren.Count == 1) {\n                   \
    \     level_of_nesting.Add(1L);\n                    } else if (open_paren.Count\
    \ == 2) {\n                        level_of_nesting.Add(0L);\n               \
    \     } else {\n                        level_of_nesting.Add(0L);\n          \
    \          }\n                    open_paren2.Add(temp);\n                }\n\
    \            }\n            if (c == '(') {\n                open_paren2.Add(paren_counter);\n\
    \                builder.Append(c);\n                paren_counter++;\n      \
    \      }\n        }\n        builder.Replace(\")(\", \")\");\n        string output\
    \ = builder.ToString();\n        int count_open = 0;\n        foreach (char c\
    \ in output) {\n            if (c == '(') count_open++;\n            if (c ==\
    \ '(') count_open--;\n            if (count_open == 0 && c == '(') {\n       \
    \         count_open++;\n            }\n            if (count_open == 0 && c ==\
    \ ')') {\n                count_open++;\n            }\n            if (count_open\
    \ == \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxr549jjb.cs(89,30): error CS1525: Invalid expression term ''}''

    /tmp/tmpxr549jjb.cs(89,30): error CS1026: ) expected

    /tmp/tmpxr549jjb.cs(89,30): error CS1002: ; expected

    /tmp/tmpxr549jjb.cs(91,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpxr549jjb.cs(97,2): error CS1513: } expected

    '
  timestamp: 1659976352
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialise variables.\n        int parenthesis_level\
    \ = 0;\n        List<long> nesting_levels = new List<long>();\n        \n    \
    \    // Go through each of the group \n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            // If the character is a left parenthesis then increase\
    \ its level\n            if (paren_string[i] == '(') {\n                parenthesis_level++;\n\
    \                // If the level of parenthesis is greater than current deepest\
    \ level then store its level\n                if (parenthesis_level > nesting_levels.Last())\
    \ {\n                    nesting_levels.Add(parenthesis_level);\n            \
    \    }\n            }\n            // If the character is a right parenthesis\
    \ then decrease its level\n            else if (paren_string[i] == ')') {\n  \
    \              parenthesis_level--;\n            }\n        }\n        \n    \
    \    // Add deepest level of nesting to list of nesting levels\n        nesting_levels.Add(parenthesis_level);\n\
    \        \n        // Return the list of deepest level of nesting\n        return\
    \ nesting_levels;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidOperationException: Sequence contains\
    \ no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00022] in <b29ef03a1d5c467c97e8d365666613b6>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <b29ef03a1d5c467c97e8d365666613b6>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidOperationException: Sequence\
    \ contains no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00022] in <b29ef03a1d5c467c97e8d365666613b6>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <b29ef03a1d5c467c97e8d365666613b6>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Your code goes here\n        var ret = new List<long>();\n\
    \        bool is_first_open = false;\n        bool is_first_close = false;\n \
    \       for (int i = 0; i < paren_string.Length; ++i) {\n            string cur_char\
    \ = paren_string[i];\n            if (cur_char.Equals('(')) {\n              \
    \  if (is_first_open) {\n                    is_first_open = false;\n        \
    \            ret.Add(1L);\n                } else {\n                    is_first_open\
    \ = true;\n                    ret.Add(0L);\n                }\n            }\n\
    \            if (cur_char.Equals(')')) {\n                if (is_first_close)\
    \ {\n                    is_first_close = false;\n                    ret.Add(-1L);\n\
    \                } else {\n                    is_first_close = true;\n      \
    \              ret.Add(0L);\n                }\n            }\n        }\n   \
    \     return ret;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz6dud9gt.cs(20,31): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    '
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<char>\
    \ s = new Stack<char>();\n        bool first = true;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                s.Push(c);\n\
    \                if (first) {\n                    result.Add((long)0);\n    \
    \                first = false;\n                }\n                else {\n \
    \                   long l = s.Count - 1;\n                    if (l >= 0)\n \
    \                       result.Add((long)l);\n                }\n            }\n\
    \            if (c == ')') {\n                long l = s.Pop();\n            \
    \    result.Add((long)l);\n            }\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f4644e846cce4dfb931c0a42672e7999>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <f4644e846cce4dfb931c0a42672e7999>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976353
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Debug.WriteLine(paren_string);\n        var groups\
    \ = new List<long>();\n        foreach (var group in paren_string.Split(' '))\n\
    \            groups.AddRange(ParseNestedParens(group));\n        return groups;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: '(()()) ((())) () ((())()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()())

    (()('
  stdout: None
  timestamp: 1659976358
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) return new List<long>();\n\
    \        List<long> levels = new List<long>();\n        bool need_new_level =\
    \ false;\n        for (int i = 0; i < paren_string.Length; ++i) {\n          \
    \  char current = paren_string[i];\n            if (need_new_level) {\n      \
    \          // New level started\n                if (current == ')' && paren_string[i\
    \ + 1] == '(') {\n                    need_new_level = false;\n              \
    \      levels.Add(0L);\n                } else {\n                    levels[levels.Count\
    \ - 1]++;\n                }\n                continue;\n            }\n     \
    \       if (current == ')') need_new_level = true;\n        }\n        return\
    \ new List<long>(levels);\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0006d] in <302f0f4b37a14667909cd934226f6402>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <302f0f4b37a14667909cd934226f6402>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0006d] in <302f0f4b37a14667909cd934226f6402>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <302f0f4b37a14667909cd934226f6402>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Convert string into chars so we can work with them\n\
    \        string s = paren_string;\n        char[] chars = s.ToCharArray();\n \
    \       StringBuilder new_string = new StringBuilder(paren_string);\n\n      \
    \  // Iterate through string and find max length of groups\n        for (int i\
    \ = 0; i < chars.Length; i++) {\n            char c = chars[i];\n            //\
    \ Look for closing parenthesis\n            if (c == ')') {\n                //\
    \ If closing parenthesis is found then increment count and check count against\
    \ max group count\n                if (++i == chars.Length) {\n              \
    \      int max_count = paren_string.Length;\n                    // Keep track\
    \ of last paren group and check count against max count\n                    int\
    \ last_count = 0;\n                    for (int j = 0; j < chars.Length; j++)\
    \ {\n                        if (chars[j] == ')') {\n                        \
    \    // If next group is a closing parenthesis then decrement count\n        \
    \                    if (j + 1 == chars.Length) {\n                          \
    \      --max_count;\n                            }\n                         \
    \   // Check count against max count\n                            if (max_count\
    \ < j + 1 - last_count) {\n                                max_count = j + 1 -\
    \ last_count;\n                            }\n                            // If\
    \ next group is not a closing parenthesis then reset count\n                 \
    \           else {\n                                --max_count;\n           \
    \                 }\n                        }\n                    }\n      \
    \              new_string.Remove(i, 1);\n                    new_string.Insert(i,\
    \ new String('(', max_count));\n                }\n            }\n        }\n\
    \        return new_string.ToString().Split('(', ')').Select(x => long.Parse(x)).ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in\
    \ a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean\
    \ overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles\
    \ styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<ParseNestedParens>b__0_0 (System.String x) [0x00000] in\
    \ <f586aa59ffeb410e9c118b20ac4e0f54>:0 \n  at System.Linq.Enumerable+SelectArrayIterator`2[TSource,TResult].ToList\
    \ () [0x00014] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.Enumerable.ToList[TSource]\
    \ (System.Collections.Generic.IEnumerable`1[T] source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00123] in <f586aa59ffeb410e9c118b20ac4e0f54>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <f586aa59ffeb410e9c118b20ac4e0f54>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was\
    \ not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException\
    \ (System.Boolean overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles\
    \ styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<ParseNestedParens>b__0_0 (System.String x) [0x00000] in\
    \ <f586aa59ffeb410e9c118b20ac4e0f54>:0 \n  at System.Linq.Enumerable+SelectArrayIterator`2[TSource,TResult].ToList\
    \ () [0x00014] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.Enumerable.ToList[TSource]\
    \ (System.Collections.Generic.IEnumerable`1[T] source) [0x0001f] in <e540098"
  stdout: ''
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var depths = new List<long>();\n        var paren_counter\
    \ = 0;\n        var nesting_level = 1;\n        var bracket_level = 0;\n     \
    \   foreach (char c in paren_string) {\n            switch (c) {\n           \
    \     case '(':\n                    depths.Add(nesting_level);\n            \
    \        paren_counter++;\n                    nesting_level++;\n            \
    \        break;\n                case ')':\n                    depths.Add(nesting_level);\n\
    \                    nesting_level--;\n                    break;\n          \
    \      case '[':\n                    bracket_level++;\n                    break;\n\
    \                case ']':\n                    bracket_level--;\n           \
    \         break;\n                case '{':\n                    depths.Add(bracket_level);\n\
    \                    bracket_level++;\n                    break;\n          \
    \      case '}':\n                    depths.Add(bracket_level);\n           \
    \         bracket_level--;\n                    break;\n            }\n      \
    \  }\n        return depths;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <880e5e5a9e694bfbac1ebbbb8cf3e6d2>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <880e5e5a9e694bfbac1ebbbb8cf3e6d2>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int num_levels = 0;\n        int num_opens = 0;\n \
    \       int num_closes = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            char c = paren_string[i];\n            if (c == '(') {\n\
    \                num_opens++;\n                num_levels++;\n            } else\
    \ if (c == ')') {\n                num_closes++;\n                num_levels--;\n\
    \            } else if (c == '(' && num_opens > 0) {\n                num_opens--;\n\
    \            } else if (c == ')' && num_closes > 0) {\n                num_closes--;\n\
    \            }\n        }\n\n        if (num_opens > num_closes)\n           \
    \ return new List<long>();\n        else if (num_opens < num_closes)\n       \
    \     return ParseNestedParens(paren_string);\n\n        return new List<long>()\
    \ { num_levels };\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <c2123a7c0cb24b0e888575cd136a81b8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <c2123a7c0cb24b0e888575cd136a81b8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        List<string>\
    \ pars = new List<string>();\n        foreach (char c in paren_string.ToCharArray())\
    \ {\n            if (c == '(') pars.Add(\"\");\n            else if (c == ')')\
    \ {\n                if (pars.Count > 0) {\n                    result.Add(result.Sum());\n\
    \                    result.Clear();\n                }\n            } else if\
    \ (pars.Count > 0) {\n                pars[pars.Count - 1] += c;\n           \
    \ } else {\n                pars.Add(c);\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy8nf0g6e.cs(27,26): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>(new long[] {0L});\n\
    \        Stack<long> opening_paren = new Stack<long>();\n        bool found =\
    \ false;\n        foreach (string paren in paren_string.Split(new char[] {' '},\
    \ StringSplitOptions.RemoveEmptyEntries)) {\n            if (paren.Length == 0)\n\
    \                continue;\n            foreach (char c in paren) {\n        \
    \        if (c == '(') {\n                    if (opening_paren.Count == 0) {\n\
    \                        opening_paren.Push((long)levels[levels.Count - 1]);\n\
    \                    }\n                    levels[levels.Count - 1]++;\n    \
    \            } else if (c == ')') {\n                    levels[levels.Count -\
    \ 1]--;\n                    if (opening_paren.Count > 0) {\n                \
    \        opening_paren.Pop();\n                    }\n                    if (opening_paren.Count\
    \ == 0) {\n                        levels.RemoveAt(levels.Count - 1);\n      \
    \              }\n                }\n            }\n        }\n        foreach\
    \ (long l in levels) {\n            if (l == 0)\n                levels.RemoveAt(levels.Count\
    \ - 1);\n        }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0008b] in <664bee0e49ea4f6b9307dcbe2e1cb3ab>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <664bee0e49ea4f6b9307dcbe2e1cb3ab>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0008b] in <664bee0e49ea4f6b9307dcbe2e1cb3ab>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <664bee0e49ea4f6b9307dcbe2e1cb3ab>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        long\
    \ max = 0;\n        bool has_paren = false;\n        foreach(char c in paren_string)\
    \ {\n            if(c == '(') {\n                if(!has_paren) result.Add(1);\n\
    \                has_paren = true;\n                max++;\n            } else\
    \ if(c == ')') {\n                max--;\n                result.RemoveAt(result.Count\
    \ - 1);\n                has_paren = false;\n            } else if(c == ' ') continue;\n\
    \            else {\n                max--;\n                result.Add(max);\n\
    \                has_paren = false;\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00065] in <ee476e60efec4f9b91ec5603e1c66337>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <ee476e60efec4f9b91ec5603e1c66337>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00065] in <ee476e60efec4f9b91ec5603e1c66337>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <ee476e60efec4f9b91ec5603e1c66337>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Recursively parse groups of nested parentheses,\
    \ and output the maximum nesting level for each group\n        if (paren_string.Length\
    \ == 0) {\n            return new List<long>();\n        }\n        var groups\
    \ = new List<List<long>>();\n        var paren_stack = new Stack<char>();\n  \
    \      var paren_counter = 0;\n        var in_group = false;\n        for (int\
    \ i = 0; i < paren_string.Length; i++) {\n            var c = paren_string[i];\n\
    \            if (c == '(') {\n                if (paren_stack.Count == 0) {\n\
    \                    throw new ArgumentException(\"Invalid parentheses. \" + paren_string);\n\
    \                }\n                paren_stack.Push(c);\n                in_group\
    \ = true;\n            } else if (c == ')' && paren_stack.Count != 0) {\n    \
    \            paren_stack.Pop();\n                in_group = false;\n         \
    \   } else if (c == ')') {\n                if (paren_stack.Count == 0) {\n  \
    \                  throw new ArgumentException(\"Invalid parentheses. \" + paren_string);\n\
    \                }\n                groups.Add(new List<long>());\n          \
    \      groups.Last().Add(paren_counter);\n                paren_counter = 0;\n\
    \            }\n            if (in_group) {\n                paren_counter++;\n\
    \            }\n        }\n        if (in_group) {\n            throw new ArgumentException(\"\
    Invalid parentheses. \" + paren_string);\n        }\n        return groups;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjtr_e2l6.cs(49,16): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.List<System.Collections.Generic.List<long>>''
    to ''System.Collections.Generic.List<long>''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var levels = new List<long>();\n        var group_counter\
    \ = 0;\n        var group = new List<long>();\n        foreach (var chara in paren_string)\
    \ {\n            if (chara == \"(\") {\n                if (group[group_counter]\
    \ == 0) {\n                    group.Add(0);\n                }\n            \
    \    group[group_counter]++;\n                levels.add(group[group_counter]);\n\
    \                group_counter++;\n            } else if (chara == \")\") {\n\
    \                group[group_counter]--;\n                levels.add(group[group_counter]);\n\
    \                group_counter++;\n            }\n        }\n        return levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpphzpy32f.cs(19,17): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''char'' and ''string''

    /tmp/tmpphzpy32f.cs(24,24): error CS1061: ''List<long>'' does not contain a definition
    for ''add'' and no accessible extension method ''add'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpphzpy32f.cs(26,24): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''char'' and ''string''

    /tmp/tmpphzpy32f.cs(28,24): error CS1061: ''List<long>'' does not contain a definition
    for ''add'' and no accessible extension method ''add'' accepting a first argument
    of type ''List<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder buffer = new StringBuilder();\n\
    \        char[] chars = paren_string.ToCharArray();\n        int depth = 0;\n\
    \        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] ==\
    \ '(') {\n                buffer.Append(chars[i]);\n                stack.Add(0);\n\
    \            } else if (chars[i] == ')') {\n                long num_levels_stack\
    \ = stack.Pop();\n                while (num_levels_stack > depth) {\n       \
    \             result.Add(stack.Pop());\n                }\n                buffer.Append(chars[i]);\n\
    \                stack.Push(depth);\n                depth++;\n            } else\
    \ if (chars[i] == ' ') {\n                if (buffer.Length > 0) {\n         \
    \           long num_levels_stack = stack.Pop();\n                    while (num_levels_stack\
    \ > depth) {\n                        result.Add(stack.Pop());\n             \
    \       }\n                    stack.Push(depth);\n                }\n       \
    \         buffer.Clear();\n            } else {\n                buffer.Append(chars[i]);\n\
    \            }\n        }\n        while (buffer.Length > 0) {\n            result.Add(stack.Pop());\n\
    \        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy8xdpnol.cs(20,35): error CS1061: ''char[]'' does not contain a definition
    for ''length'' and no accessible extension method ''length'' accepting a first
    argument of type ''char[]'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpy8xdpnol.cs(23,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        List<char>\
    \ chars = paren_string.ToCharArray();\n        int level = 0;\n        for (int\
    \ i = 0; i < chars.Length; i++) {\n            if (chars[i] == '(') {\n      \
    \          level++;\n            }\n            if (chars[i] == ')') {\n     \
    \           level--;\n            }\n            if (level > 0) {\n          \
    \      result.Add(level);\n            }\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkqe7fqxl.cs(16,28): error CS0029: Cannot implicitly convert type ''char[]''
    to ''System.Collections.Generic.List<char>''

    /tmp/tmpkqe7fqxl.cs(18,35): error CS1061: ''List<char>'' does not contain a definition
    for ''Length'' and no accessible extension method ''Length'' accepting a first
    argument of type ''List<char>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var levels = new List<long>();\n        var levels_stack\
    \ = new Stack<long>();\n\n        var level = new long();\n        \n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                levels_stack.Add(level);\n\
    \                level = new long();\n            } else if ((c == '(' && level\
    \ > 0) || (c == ')' && level > 0)) {\n                level++;\n            }\
    \ else if ((c == ')' && level > 0) || (c == '(' && level == 0)) {\n          \
    \      levels_stack.Pop();\n                level--;\n            }\n        \
    \    levels.Add(level);\n        }\n        levels_stack.Pop();\n\n        return\
    \ levels;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdjm52922.cs(22,30): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Use recursion to implement the algorithm.\n    \
    \    List<long> result = new List<long>();\n        ParseNestedParens(paren_string,\
    \ new long[0], result);\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp97zejgg_.cs(17,9): error CS1501: No overload for method ''ParseNestedParens''
    takes 3 arguments

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Preprocessing:\n        // Convert the parenthesis\
    \ into a string. \n        // Start from left and move right to right to check\
    \ whether any parenthesis has been found so far.\n        // When a parenthesis\
    \ is found, the string will be split at that position and recombined to form the\
    \ final string.\n        // Example: \"(()())\" -> \"((())\")\n        string\
    \ s = paren_string.TrimStart();\n        int length = s.Length;\n        StringBuilder\
    \ sb = new StringBuilder();\n        int open_parentheses_index = 0;\n       \
    \ for (int i = 1; i <= length; i++) {\n            char c = s[i];\n          \
    \  switch (c) {\n                case '(':\n                    sb.Append(c);\n\
    \                    open_parentheses_index++;\n                    break;\n \
    \               case ')':\n                    sb.Append(c);\n               \
    \     open_parentheses_index--;\n                    break;\n            }\n \
    \           if (open_parentheses_index == 0) {\n                sb.Append(c);\n\
    \            }\n        }\n        s = sb.ToString();\n\n        // Parsing:\n\
    \        // Convert each character into a number and store it in an array.\n \
    \       // The array will be used to calculate the maximum level of nesting.\n\
    \        // The level of nesting will be determined by comparing the number of\
    \ the highest value in the array with the length of array minus 1.\n        //\
    \ If the level of nesting reaches the max value, it will mean that the string\
    \ has reached the maximum level of nesting.\n        List<long> array = new List<long>(new\
    \ long[s.Length]);\n        for (int i = 0; i < s.Length; i++) {\n           \
    \ long x = long.Parse(s.Substring(i, 1));\n            if (array.Any(a => a ==\
    \ x)) {\n                continue;\n            }\n            array.Add(x);\n\
    \        }\n        long max_index = array.Count - 1;\n        long max_value\
    \ = array[max_index];\n        long max_level = 0;\n        for (int i = 1; i\
    \ < array.Count; i++) {\n            long value = array[i];\n            if (value\
    \ == max_value) {\n                if (i > max_level) {\n                    max_level\
    \ = i - 1;\n                }\n            } else if (value > max_value) {\n \
    \               max_value = value;\n                max_level = i;\n         \
    \   }\n        }\n        // Return an array of maximum levels.\n        // The\
    \ length of the array will be the maximum level of nesting.\n        // The last\
    \ value in the array will represent the maximum level of nesting in the original\
    \ string.\n        List<long> result = new List<long>(new long[max_level + 1]);\n\
    \        result[max_level] = max_level;\n        for (int i = 0; i < result.Count;\
    \ i++) {\n            result[i] = array[max_level - result[i]];\n        }\n \
    \       return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0yce1bzz.cs(56,32): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp0yce1bzz.cs(73,16): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp0yce1bzz.cs(75,31): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var parens = new Stack<Stack<long>>();\n        var\
    \ current_level = 0;\n        var new_level = 0;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                parens.Push(current_level);\n\
    \                ++new_level;\n            } else if (c == ')') {\n          \
    \      while (parens.Count > 0) {\n                    var current_level_of_parens\
    \ = parens.Pop();\n                    if (current_level_of_parens == current_level)\n\
    \                        break;\n                    else\n                  \
    \      --current_level;\n                }\n                if (current_level\
    \ == 0) {\n                    break;\n                } else {\n            \
    \        ++new_level;\n                }\n            } else if (c == ' ') {\n\
    \                ++current_level;\n            }\n        }\n        return parens.Count\
    \ == 0 ? new List<long>() : (new List<long>(parens.Select(x => x + new_level)));\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9qf53k2g.cs(20,29): error CS1503: Argument 1: cannot convert from ''int''
    to ''System.Collections.Generic.Stack<long>''

    /tmp/tmp9qf53k2g.cs(25,25): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''Stack<long>'' and ''int''

    /tmp/tmp9qf53k2g.cs(39,90): error CS0019: Operator ''+'' cannot be applied to
    operands of type ''Stack<long>'' and ''int''

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int open_parens = 0, open_parantheses = 0, open_parentheses\
    \ = 0;\n        int close_parantheses = 0, open_parens_levels = 0, close_parantheses_levels\
    \ = 0;\n        int parentheses_levels = 0;\n        int char_count = 0;\n   \
    \     List<long> levels = new List<long>();\n        bool in_parentheses = false;\n\
    \        bool in_parentheses_group = false;\n        bool in_parentheses_group_in_parentheses_group\
    \ = false;\n        bool in_parentheses_group_in_parentheses_group_in_parentheses_group\
    \ = false;\n        bool in_parentheses_group_in_parentheses_group_in_parentheses_group_in_parentheses_group\
    \ = false;\n        bool in_parentheses_group_in_parentheses_group_in_parentheses_group_in_parentheses_group_in_parentheses_group\
    \ = false;\n        StringBuilder sb = new StringBuilder();\n        foreach (char\
    \ c in paren_string) {\n            char_count++;\n            if (c == '(') {\n\
    \                open_parens++;\n                if (open_parens <= open_parentheses\
    \ ||\n                    (open_parens == open_parentheses && open_parentheses_levels\
    \ > levels[0])) {\n                    levels.Add(1);\n                    open_parentheses_levels\
    \ = levels.Last();\n                }\n                else if (open_parens ==\
    \ open_parentheses && open_parentheses_levels < levels.Last()) {\n           \
    \         levels[levels.Last()] += 1;\n                }\n                open_parens_levels\
    \ += 1;\n            }\n            else if (c == '(') {\n                open_parens++;\n\
    \                if (open_parens == open_parentheses &&\n                    (open_parens_levels\
    \ > open_parentheses || open_parens_levels == open_parentheses && open_parentheses_levels\
    \ == levels.Last())) {\n                    levels.Add(1);\n                 \
    \   open_parentheses_levels = levels.Last();\n                }\n            \
    \    open_parens_levels += 1;\n            }\n            else if (c == ')') {\n\
    \                open_parens--;\n                if (open_parens == open_parentheses\
    \ &&\n                    (open_parens_levels > open_parentheses || open_parens_levels\
    \ == open_parentheses && open_parentheses_levels == levels.Last())) {\n      \
    \              levels[open_parentheses_levels]--;\n                }\n       \
    \     }\n            else if (c == ')') {\n                open_parens--;\n  \
    \              if (open_parens == open_parentheses &&\n                    (open_parens_levels\
    \ > open_parentheses || open_parens_levels == open_parentheses && open_parentheses_levels\
    \ == levels.Last())) {\n                    levels[open_parentheses_levels]--;\n\
    \                }\n            }\n            else if (c == '(' && in_parentheses_group)\
    \ {\n                open_parentheses_levels += 1;\n                if (open_parentheses_levels\
    \ == open_parentheses) {\n                    open_parantheses += 1;\n       \
    \             in_parentheses_group = false;\n                }\n            }\n\
    \            else if (c == '('\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5uv9xp34.cs(71,30): error CS1026: ) expected

    /tmp/tmp5uv9xp34.cs(71,30): error CS1525: Invalid expression term ''}''

    /tmp/tmp5uv9xp34.cs(71,30): error CS1002: ; expected

    /tmp/tmp5uv9xp34.cs(73,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp5uv9xp34.cs(79,2): error CS1513: } expected

    '
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var strings = paren_string.Split(new char[] {'(', ')'},\
    \ StringSplitOptions.RemoveEmptyEntries);\n        var result = new List<long>();\n\
    \        foreach (var item in strings) {\n            var paren_level = item.Count(c\
    \ => c == '(') - item.Count(c => c == ')');\n            result.Add(paren_level);\n\
    \        }\n        return result.OrderByDescending(x => x).ToList();\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fd2c36d3a66348c6a78f4a29eff580dd>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fd2c36d3a66348c6a78f4a29eff580dd>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string group;\n        List<long> results = new List<long>();\n\
    \        int paren_level = 1;\n        int prev_paren_level = 1;\n        int\
    \ open_paren_paren_level = 0;\n        int open_paren_open_paren_level = 0;\n\
    \        int open_paren_close_paren_level = 0;\n        while (true) {\n     \
    \       if (paren_level == 0) {\n                if (group == \"(\") {\n     \
    \               results.Add(0);\n                    open_paren_paren_level++;\n\
    \                }\n                else if (group == \")\") {\n             \
    \       open_paren_close_paren_level++;\n                }\n                else\
    \ if (group == \")(\") {\n                    open_paren_open_paren_level++;\n\
    \                }\n                else if (group == \"()\") {\n            \
    \        results.Add(0);\n                    open_paren_paren_level++;\n    \
    \            }\n                else if (group == \"()(\") {\n               \
    \     open_paren_open_paren_level++;\n                }\n                else\
    \ if (group == \")()\") {\n                    open_paren_close_paren_level++;\n\
    \                }\n                else if (group == \"()()\") {\n          \
    \          results.Add(0);\n                    open_paren_paren_level++;\n  \
    \              }\n                else if (group == \"((\") {\n              \
    \      results.Add(0);\n                    open_paren_open_paren_level++;\n \
    \               }\n                else if (group == \")(\") {\n             \
    \       open_paren_close_paren_level++;\n                }\n                else\
    \ if (group == \")(\") {\n                    open_paren_open_paren_level++;\n\
    \                }\n                else if (group == \")(\") {\n            \
    \        open_paren_close_paren_level++;\n                }\n                else\
    \ if (group == \"()()\") {\n                    results.Add(0);\n            \
    \        open_paren_open_paren_level++;\n                }\n                else\
    \ if (group == \"((\") {\n                    results.Add(0);\n              \
    \      open_paren_open_paren_level++;\n                }\n                else\
    \ if (group == \")(\") {\n                    open_paren_close_paren_level++;\n\
    \                }\n                else if (group == \")(\") {\n            \
    \        open_paren_open_paren_level++;\n                }\n                else\
    \ if (group == \")(\") {\n                    open_paren_close_paren_level++;\n\
    \                }\n                else if (group == \"()()\") {\n          \
    \          results.Add(0);\n                    open_paren_open_paren_level++;\n\
    \                }\n                else if (group == \"((\") {\n            \
    \        results.Add(0);\n                    open_paren_open_paren_level++;\n\
    \                }\n                else if (group == \")(\") {\n            \
    \        open_paren_close_paren_level++;\n                }\n                else\
    \ if (group == \")(\") {\n                    open_paren_open_paren_level++;\n\
    \                }\n                else if (group == \")(\") {\n            \
    \        open_paren_close_\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpamu035fe.cs(93,38): error CS1002: ; expected

    /tmp/tmpamu035fe.cs(95,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpamu035fe.cs(101,2): error CS1513: } expected

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Get all possible opening/closing pairs.\n      \
    \  HashSet<Pair> openings_and_closings = new HashSet<Pair>();\n        foreach\
    \ (string opening in new[] {\")\", \"(\"}) {\n            foreach (string closing\
    \ in new[] {\")\", \"(\"}) {\n                openings_and_closings.Add(new Pair(opening,\
    \ closing));\n            }\n        }\n        // Iterate over all possible groups\
    \ of parentheses.\n        List<long> nesting_counts = new List<long>();\n   \
    \     int max_depth = 0;\n        string current_group = \"\";\n        for (int\
    \ i = 0; i < paren_string.Length; ++i) {\n            char c = paren_string[i];\n\
    \            if (c == '(') {\n                current_group += c;\n          \
    \  } else if (c == ')') {\n                if (nesting_counts.Count > max_depth)\
    \ {\n                    nesting_counts = nesting_counts.Take(nesting_counts.Count\
    \ - max_depth).ToList();\n                }\n                nesting_counts.Add(current_group.Length);\n\
    \                current_group = \"\";\n            } else if (c == '(') {\n \
    \               openings_and_closings.Remove(new Pair(current_group, \"\"));\n\
    \                current_group = \"\";\n            } else if (c == ')') {\n \
    \               openings_and_closings.Remove(new Pair(\"\", current_group));\n\
    \                current_group = \"\";\n            }\n            if (openings_and_closings.Count\
    \ == 0) {\n                nesting_counts.Add(current_group.Length);\n       \
    \     }\n        }\n        if (nesting_counts.Count > max_depth) {\n        \
    \    nesting_counts = nesting_counts.Take(nesting_counts.Count - max_depth).ToList();\n\
    \        }\n        return nesting_counts;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgr4r9ddt.cs(16,17): error CS0246: The type or namespace name ''Pair''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpgr4r9ddt.cs(16,59): error CS0246: The type or namespace name ''Pair''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpgr4r9ddt.cs(19,47): error CS0246: The type or namespace name ''Pair''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpgr4r9ddt.cs(37,50): error CS0246: The type or namespace name ''Pair''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpgr4r9ddt.cs(40,50): error CS0246: The type or namespace name ''Pair''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        if (paren_string.Length\
    \ == 0)\n            return result;\n\n        string left = paren_string.Substring(0,\
    \ paren_string.IndexOf(\"(\"));\n        string right = paren_string.Substring(paren_string.IndexOf(\"\
    (\") + 1, paren_string.Length - paren_string.IndexOf(\"(\") - 1);\n        //\
    \ System.out.println(\"Left \" + left + \", right \" + right);\n        List<long>\
    \ left_nesting = ParseNestedParens(left);\n        // System.out.println(\"Left\
    \ nesting \" + left_nesting);\n        List<long> right_nesting = ParseNestedParens(right);\n\
    \        // System.out.println(\"Right nesting \" + right_nesting);\n\n      \
    \  int left_level_nesting = left_nesting.Count;\n        int right_level_nesting\
    \ = right_nesting.Count;\n        while (left_level_nesting + right_level_nesting\
    \ > result.Count)\n            result.Add(0);\n\n        // System.out.println(\"\
    Resulting \" + result.Count + \" after \" + right_nesting + \" \" + left_nesting);\n\
    \        if (left_level_nesting > right_level_nesting) {\n            int index\
    \ = left_nesting.Count;\n            while (index > 0)\n                --index;\n\
    \            // System.out.println(\"Adding \" + index);\n            while (index\
    \ >= left_level_nesting)\n                result.Add(0);\n            int index2\
    \ = right_nesting.Count;\n            while (index2 >= left_level_nesting)\n \
    \               --index2;\n            while (index2 >= index)\n             \
    \   result[index] += result[index2];\n        } else {\n            int index\
    \ = right_nesting.Count;\n            while (index > 0)\n                --index;\n\
    \            // System.out.println(\"Adding \" + index);\n            while (index\
    \ >= right_level_nesting)\n                result.Add(0);\n            int index2\
    \ = left_nesting.Count;\n            while (index2 >= right_level_nesting)\n \
    \               --index2;\n            while (index2 >= index)\n             \
    \   result[index] += result[index2];\n        }\n        // System.out.println(\"\
    Resulting \" + result.Count + \" after \" + right_nesting + \" \" + left_nesting);\n\
    \        return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Length cannot\
    \ be less than zero.\nParameter name: length\n  at System.String.Substring (System.Int32\
    \ startIndex, System.Int32 length) [0x00031] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x0002b] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00059] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00060] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00060] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Length\
    \ cannot be less than zero.\nParameter name: length\n  at System.String.Substring\
    \ (System.Int32 startIndex, System.Int32 length) [0x00031] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x0002b] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00059] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00060] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00060] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <17d3ace0ab024d5b8a5b234bb7dea982>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException(\"\
    paren_string\");\n\n        // Keep track of how many groupings are being made\n\
    \        int groupings_made = 0;\n        int nested_count = 0;\n\n        //\
    \ Keep track of the deepest level of nesting for each group\n        List<long>\
    \ deepest_nesting = new List<long>();\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                // Start a new group\n     \
    \           if (groupings_made > 0)\n                    deepest_nesting.Add(nested_count);\n\
    \                nested_count = 1;\n                groupings_made++;\n      \
    \      } else if (c == ')') {\n                // End a group\n              \
    \  groupings_made--;\n                if (groupings_made == 0)\n             \
    \       nested_count++;\n            } else {\n                // Increment the\
    \ count for the group\n                nested_count++;\n            }\n      \
    \  }\n\n        // Add an extra grouping if we encounter the final group\n   \
    \     if (groupings_made > 0)\n            deepest_nesting.Add(nested_count);\n\
    \        return deepest_nesting;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1148bcfbfc2a46c5b10b795cae58cded>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1148bcfbfc2a46c5b10b795cae58cded>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // The output is the maximum level of nesting in the\
    \ string.\n        List<long> max_level = new List<long>();\n        // The level\
    \ at which the string starts.\n        long start_level = 0;\n        // The level\
    \ of the current nesting.\n        long level = 0;\n        // The current parenthesis\
    \ level.\n        long paren_level = 0;\n        // Iterate through the string.\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             // Increment the level and parenthesis level.\n                paren_level++;\n\
    \                level++;\n            } else if (c == ')') {\n              \
    \  // If the level is the same as parenthesis level, it's the level of nesting.\n\
    \                if (level == paren_level) {\n                    // Increase\
    \ the level and parenthesis level.\n                    paren_level--;\n     \
    \               level--;\n                } else {\n                    // If\
    \ the level is greater than the parenthesis level, it's a new level of nesting.\n\
    \                    level++;\n                }\n            } else if (c ==\
    \ ' ') {\n                // If the level is greater than the parenthesis level,\
    \ it's the level of nesting.\n                if (level > paren_level) {\n   \
    \                 level++;\n                }\n            }\n            // If\
    \ the level is greater than the parenthesis level, it's the level of nesting.\n\
    \            if (level > paren_level) {\n                max_level.Add(level);\n\
    \            }\n        }\n        return max_level;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <9bb56a502ac5444db773a05fbd409004>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <9bb56a502ac5444db773a05fbd409004>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Create a string builder to hold the results.\n \
    \       StringBuilder output = new StringBuilder();\n        // Keep track of\
    \ the maximum level encountered so far.\n        long current_max_level = 0;\n\
    \        // Iterate through each of the groups in the input string.\n        foreach\
    \ (string group in paren_string.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries))\
    \ {\n            // Iterate through each character in the input string.\n    \
    \        foreach (char character in group) {\n                // If the character\
    \ is ')', then increase the level by 1.\n                if (character == ')')\
    \ {\n                    current_max_level++;\n                }\n           \
    \     // If the character is '(', decrease the level by 1 and append the level\
    \ to output\n                // if level > current_max_level.\n              \
    \  if (character == '(') {\n                    current_max_level--;\n       \
    \             if (current_max_level > output.Length) {\n                     \
    \   output.Append(long.MaxValue);\n                        break;\n          \
    \          }\n                    output.Append(current_max_level);\n        \
    \        }\n            }\n        }\n        // Return the list of levels as\
    \ a long[] array if there are no errors.\n        if (output.Length == 0) return\
    \ null;\n        return new List<long>(output.ToArray());\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw62svedn.cs(41,38): error CS1061: ''StringBuilder'' does not contain a
    definition for ''ToArray'' and no accessible extension method ''ToArray'' accepting
    a first argument of type ''StringBuilder'' could be found (are you missing a using
    directive or an assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> output_list = new List<long>();\n      \
    \  string[] groups = paren_string.Split(new char[] { '(', ')' }); // Split groups\
    \ into array\n        for (int g = 0; g < groups.Length; g++) {\n            string\
    \ group = groups[g];\n            int level = 0;\n            int levels = group.IndexOf('(')\
    \ - g; // Get the number of levels including this group\n            // If no\
    \ nested parenthesis, return an empty list\n            if (levels == 0)\n   \
    \             output_list.Add(0);\n            else {\n                string\
    \ last_group = \"\";\n                for (int i = (levels + 1); i < groups.Length;\
    \ i++) { // Loop through the groups\n                    string current_group\
    \ = groups[i];\n                    if (current_group == \"(\") {\n          \
    \              if (last_group != \"\" && last_group != \"(\")\n              \
    \              level++;\n                    }\n                    else if (current_group\
    \ == \")\") {\n                        if (last_group != \"\" && last_group !=\
    \ \")\")\n                            level--;\n                    }\n      \
    \              last_group = current_group;\n                }\n              \
    \  output_list.Add(level);\n            }\n        }\n        return output_list;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x00066] in <5763546da92141eaaca6ba10bed46274>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <5763546da92141eaaca6ba10bed46274>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x00066]\
    \ in <5763546da92141eaaca6ba10bed46274>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <5763546da92141eaaca6ba10bed46274>:0 \n"
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Stack<long> stack_of_level = new Stack<long>();\n \
    \       foreach (char c in paren_string) {\n            if (c == '(') {\n    \
    \            stack_of_level.Push(1L);\n            } else if (c == ')') {\n  \
    \              stack_of_level.Pop();\n            }\n            else if (stack_of_level.Count\
    \ == 0) {\n                stack_of_level.Add(1L);\n            }\n        }\n\
    \        List<long> levels = new List<long>();\n        long level_of_nesting\
    \ = 1L;\n        while (level_of_nesting != 0) {\n            levels.Add(level_of_nesting);\n\
    \            level_of_nesting = stack_of_level.Pop();\n        }\n        return\
    \ levels;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpk3o6v4sa.cs(23,32): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Split the string using parenthesis symbol () as\
    \ a delimiter\n        var paren_list = paren_string.Split('(').Select(n => n.Trim()).ToArray();\n\
    \        if (paren_list.Length == 0) return new List<long>();\n        // Get\
    \ the last parenthesis symbol to know the number of nested parentheses.\n    \
    \    // For example, (()) is 1 level of nesting and ((())) is 2 levels.\n    \
    \    int last_parentheses = paren_list[paren_list.Length - 1].Length;\n\n    \
    \    // Calculate the sum of all the remaining parentheses and add it to the previous\
    \ sum\n        var total_parentheses = paren_list.Sum(p => p.Length);\n\n    \
    \    // Create a list of long values by dividing the number of nested parentheses\
    \ by each nested parentheses.\n        // For example, (()) is 1 level of nesting\
    \ and ((())) is 2 levels.\n        var level_of_nesting = total_parentheses /\
    \ last_parentheses;\n\n        var list = new List<long>();\n        for (var\
    \ i = 0; i < level_of_nesting; i++) {\n            list.Add(i);\n        }\n \
    \       return list;\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8c9a97be183a458cacee7fcf3ab6cb98>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <8c9a97be183a458cacee7fcf3ab6cb98>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string str = paren_string;\n        if (str.Length\
    \ == 0) {\n            return new List<long>(new long[]{0});\n        }\n    \
    \    // Scan string recursively\n        List<long> levels = new List<long>();\n\
    \        ScanStr(ref levels, str.Substring(0, 1), 0);\n        string remainder\
    \ = str.Substring(1);\n        List<long> level_level_diff = new List<long>();\n\
    \        List<long> level_level_diff_next = new List<long>();\n        // Find\
    \ all the unique non-nesting depths in remaining string\n        for (int i =\
    \ 1; i < remainder.Length; i++) {\n            if (remainder[i] == '(') {\n  \
    \              level_level_diff_next.Add(levels[i - 1] + 1);\n            }\n\
    \            if (remainder[i] == ')') {\n                level_level_diff.Add(levels[i\
    \ - 1] - level_level_diff_next[i - 1]);\n            }\n        }\n        //\
    \ Find out maximum depth recursively\n        long max_level = levels.Max();\n\
    \        List<long> max_level_level_diff = new List<long>();\n        for (int\
    \ i = 0; i < level_level_diff_next.Count; i++) {\n            max_level_level_diff.Add(max_level\
    \ - level_level_diff_next[i]);\n        }\n        // Find deepest level of nesting\n\
    \        long max_level_level_diff_max_level = max_level_level_diff.Max();\n \
    \       levels.Clear();\n        for (int i = 0; i < level_level_diff_next.Count;\
    \ i++) {\n            levels.Add(level_level_diff_next[i]);\n            if (level_level_diff_next[i]\
    \ == max_level_level_diff_max_level) {\n                return levels;\n     \
    \       }\n        }\n        // Failed at all levels\n        return null;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxi_ybvdd.cs(21,9): error CS0103: The name ''ScanStr'' does not exist in
    the current context

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> output_list = new List<long>();\n      \
    \  if (paren_string.Length < 1) {\n            return output_list;\n        }\n\
    \        // Iterate through the string and maintain a stack of parens.\n     \
    \   bool in_string = false;\n        Stack<long> stack_of_parens = new Stack<long>();\n\
    \        string first_char_of_string = paren_string[0];\n        for (int i =\
    \ 0; i < paren_string.Length; i++) {\n            char ch = paren_string[i];\n\
    \            // If a paren is found at the beginning of the string, then \n  \
    \          // it's a new level of nesting and we should push the previous level\n\
    \            // of nesting onto the stack.\n            if (ch == ')') {\n   \
    \             // If the last char of string is a paren, add its nesting level.\n\
    \                if (in_string) {\n                    stack_of_parens.Push(output_list[output_list.Count\
    \ - 1] + 1);\n                }\n                // Reset the stack.\n       \
    \         stack_of_parens.Clear();\n                in_string = false;\n     \
    \       }\n            // If the character is the first character of the string,\
    \ then it's\n            // the starting of another string. Start a new string\
    \ nesting.\n            if (ch == '(') {\n                stack_of_parens.Push(1);\n\
    \                in_string = true;\n            }\n            // If the character\
    \ is anything other than the first character of the string\n            // and\
    \ the first character of the string, then it's a nested paren. \n            if\
    \ (ch != '(' && first_char_of_string == ch) {\n                stack_of_parens.Push(stack_of_parens.Peek()\
    \ + 1);\n            }\n            // If we reach the end of the string, then\
    \ we only need to add the final level\n            // of nesting if it matches\
    \ the top level on the stack.\n            if (i == paren_string.Length - 1) {\n\
    \                if (stack_of_parens.Peek() == stack_of_parens.Peek() + 1) {\n\
    \                    output_list.Add(stack_of_parens.Peek());\n              \
    \  }\n            }\n            // If the current character is a paren, add its\
    \ nesting level to the stack.\n            if (ch == '(') {\n                stack_of_parens.Push(stack_of_parens.Peek()\
    \ + 1);\n            }\n        }\n        return output_list;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1ev0zu8l.cs(22,39): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    /tmp/tmp1ev0zu8l.cs(45,30): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Create a stack object to hold all the group of parentheses.\n\
    \        Stack<Tuple<List<long>, long>> stack = new Stack<Tuple<List<long>, long>>();\n\
    \        // Create a string builder to append the group of parentheses.\n    \
    \    StringBuilder str = new StringBuilder();\n        bool group_open = false;\n\
    \        // Loop through all the parentheses.\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            // If the parentheses is open then push it into the stack.\n\
    \            if (paren_string[i] == '(') {\n                // Check if there\
    \ is another group of parentheses.\n                if (paren_string[i + 1] !=\
    \ ')') {\n                    str.Append(paren_string[i]);\n                }\n\
    \                else {\n                    // This is the closing of the group\
    \ of parentheses.\n                    // Get the value from the stack.\n    \
    \                Tuple<List<long>, long> tuple = stack.Pop();\n              \
    \      // Add the length of the group into the list.\n                    List<long>\
    \ group = new List<long>();\n                    group.Add(tuple.Item2);\n   \
    \                 // Reverse the order of the group list.\n                  \
    \  group.Reverse();\n                    // Create a new list from the group list.\n\
    \                    List<long> new_group = new List<long>(group);\n         \
    \           // Pop the values from new_group into the stack.\n               \
    \     stack.Push(Tuple.Create(new_group, tuple.Item2));\n                }\n \
    \           }\n            else if (paren_string[i] == ')') {\n              \
    \  // If the parentheses is closed, then pop the group from the stack and\n  \
    \              // append the values to the str object.\n                if (group_open)\
    \ {\n                    Tuple<List<long>, long> tuple = stack.Pop();\n      \
    \              // Append the length of the group to str object.\n            \
    \        str.Append(tuple.Item2);\n                    // Reverse the order of\
    \ the group list.\n                    List<long> new_group = new List<long>(tuple.Item1);\n\
    \                    new_group.Reverse();\n                    // Create a new\
    \ list from the group list.\n                    List<long> group = new List<long>(new_group);\n\
    \                    // Pop the values from group list into the stack.\n     \
    \               stack.Push(Tuple.Create(group, tuple.Item2));\n              \
    \  }\n                // Check if the parentheses are still open.\n          \
    \      group_open = paren_string[i + 1] != ')';\n            }\n            else\
    \ {\n                // If the parentheses is not open then append it to the str\
    \ object.\n                if (!group_open) {\n                    str.Append(paren_string[i]);\n\
    \                }\n            }\n        }\n        List<long> groups = new\
    \ List<long>();\n        // Loop through all the group of parentheses in the str\
    \ object.\n        foreach (char c in str.ToString()) {\n            // If the\
    \ character is not equal to open parenthesis then it is a group of\n         \
    \   // parentheses.\n            if (c != '(' && c != ')') {\n               \
    \ groups.Add(long.Parse(c.ToString()));\n            }\n        }\n        //\
    \ Return the list of longs.\n\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpl0vrpejf.cs(14,30): error CS0161: ''Problem.ParseNestedParens(string)'':
    not all code paths return a value

    '
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException(\"\
    paren_string\");\n        int curLevel = 1;\n        int depth = 0;\n        bool\
    \ inQuote = false;\n        List<long> resultList = new List<long>();\n      \
    \  foreach (char ch in paren_string) {\n            switch (ch) {\n          \
    \      case '(':\n                    depth++;\n                    break;\n \
    \               case ')':\n                    depth--;\n                    break;\n\
    \                case '\\'':\n                    inQuote = !inQuote;\n      \
    \              break;\n                case ' ':\n                    if (inQuote)\n\
    \                        break;\n                    else\n                  \
    \      resultList.Add(curLevel);\n                    break;\n               \
    \ default:\n                    throw new ArgumentException(\"Expected \\\")\\\
    \", \\\")\\\", \\\"(\\\", or \\\" at index \" + paren_string.IndexOf(ch) + \"\
    : \" + ch);\n            }\n            if (depth == 0)\n                curLevel++;\n\
    \        }\n        return resultList;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fda67132163341b99852488c6930d8aa>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fda67132163341b99852488c6930d8aa>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) return null;\n        if\
    \ (paren_string.Length <= 1) return null;\n        List<long> results = new List<long>();\n\
    \        List<string> parens = paren_string.Split(' ');\n        int opening_paren\
    \ = 0;\n        bool inside_paren = false;\n        bool inside_double_bracket\
    \ = false;\n        foreach (string paren in parens) {\n            if (paren.Length\
    \ > 1) {\n                if (!inside_paren) inside_paren = true;\n          \
    \      if (paren == '(') opening_paren++;\n                else if (paren == ')')\
    \ opening_paren--;\n            }\n            else {\n                if (inside_paren)\
    \ results.Add(opening_paren);\n                inside_paren = false;\n       \
    \     }\n        }\n        return results.Count > 0 ? results : null;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpt4dyiplu.cs(18,31): error CS0029: Cannot implicitly convert type ''string[]''
    to ''System.Collections.Generic.List<string>''

    /tmp/tmpt4dyiplu.cs(25,21): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpt4dyiplu.cs(26,26): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpt4dyiplu.cs(21,14): warning CS0219: The variable ''inside_double_bracket''
    is assigned but its value is never used

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var paren_groups = new List<List<long>>();\n      \
    \  var paren_levels = new List<int>();\n        int paren_level = 0;\n       \
    \ var current_group = new List<long>();\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                current_group.Add(paren_level);\n\
    \                paren_levels.Add(paren_level);\n                paren_groups.Add(current_group);\n\
    \                paren_level++;\n            }\n            else if (c == ')')\
    \ {\n                paren_level = Math.Max(paren_levels[paren_groups.Count -\
    \ 1], paren_level + 1);\n                paren_groups.Add(current_group);\n  \
    \              current_group = new List<long>();\n            }\n            else\
    \ {\n                current_group.Add(c);\n            }\n        }\n       \
    \ if (paren_groups.Count > 0) {\n            paren_levels.Add(paren_level);\n\
    \        }\n        return new List<long>(paren_groups);\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1px_hjn_.cs(38,31): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.List<System.Collections.Generic.List<long>>''
    to ''int''

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Step 1: \n        // Convert the string to a list\
    \ of strings where each string represents the group of\n        // parentheses\
    \ separated by spaces. \n        List<string> nested_strings = paren_string.Split('\
    \ ');\n\n        // Step 2: \n        // For each of the strings in the list,\
    \ calculate the length of each string and \n        // create a list with the\
    \ same length as the original list. \n        // The length of each string is\
    \ obtained by counting how many of \n        // the parentheses (\"(\" and \"\
    )\") are there. The number of parentheses (\"(\") \n        // is counted by incrementing\
    \ a counter variable. \n        // The length of each string is then subtracted\
    \ by 1 since \n        // the character \"(\" always has length 1 and the character\
    \ \")\" always has length 1.\n        // The counter variable is incremented by\
    \ 1 for each \")\" that occurs.\n        // We add one to the counter because\
    \ we also want to count the empty string \n        // at the beginning and end\
    \ of a string.\n        List<long> deepest_level = new List<long>();\n       \
    \ for (int i = 0; i < nested_strings.Count; i++) {\n            int parentheses_count\
    \ = nested_strings[i].Count(x => x == '(') - nested_strings[i].Count(x => x ==\
    \ ')');\n            deepest_level.Add(parentheses_count + 1);\n        }\n\n\
    \        // Step 3: \n        // For each of the strings in the original list,\
    \ we create a copy of it in the list \n        // with the same index as the original\
    \ list. If the original string has more \n        // parentheses than its copy,\
    \ then we add the original string to the original list. \n        // If the original\
    \ string has fewer parentheses than its copy, then we subtract \n        // the\
    \ string from the original list and remove the parentheses from the string.\n\
    \        List<string> nested_strings_copy = nested_strings.ToList();\n       \
    \ for (int i = 0; i < nested_strings.Count; i++) {\n            int parentheses_count\
    \ = nested_strings[i].Count(x => x == '(') - nested_strings[i].Count(x => x ==\
    \ ')');\n            if (parentheses_count > nested_strings_copy[i].Count()) {\n\
    \                nested_strings_copy[i] = nested_strings[i];\n            } else\
    \ if (parentheses_count < nested_strings_copy[i].Count()) {\n                nested_strings_copy[i]\
    \ = nested_strings[i].Remove(nested_strings[i].Count(x => x == ')'));\n      \
    \      }\n        }\n\n        // Step 4: \n        // We will add the lengths\
    \ of the strings in the original list to the deepest level \n        // list if\
    \ they are equal and we will subtract the lengths of the strings in the \n   \
    \     // original list from the deepest level list if they are less than. \n \
    \       for (int i = 0; i < nested_strings_copy.Count; i++) {\n            int\
    \ current_deepest_level = deepest_level[i].ToString().Length;\n            int\
    \ next_deepest_level = nested_strings_copy[i].ToString().Length\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy61ltrxn.cs(59,78): error CS1002: ; expected

    /tmp/tmpy61ltrxn.cs(61,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpy61ltrxn.cs(67,2): error CS1513: } expected

    '
  timestamp: 1659976353
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var openParen_stack = new Stack<long>();\n        var\
    \ openParen_count = new Stack<long>();\n        var closeParen_stack = new Stack<long>();\n\
    \        var closeParen_count = new Stack<long>();\n        var results = new\
    \ List<long>();\n        for (int i = 0; i < paren_string.Length; i++) {\n   \
    \         var ch = paren_string[i];\n            if (ch == '(') {\n          \
    \      openParen_count.Push(1);\n                openParen_stack.Push(i);\n  \
    \          } else if (ch == ')') {\n                openParen_count.Pop();\n \
    \               if (openParen_count.Peek() == 0)\n                    throw new\
    \ InvalidDataException(\"Unbalanced parentheses. No matching closing parentheses.\"\
    );\n                closeParen_count.Push(openParen_count.Pop());\n          \
    \  } else if (openParen_count.Peek() > 0 && ch == ' ') { // Ignore spaces inside\
    \ open parens\n                openParen_count.Pop();\n            }\n       \
    \     if (ch == ')') {\n                closeParen_count.Pop();\n            \
    \    if (closeParen_count.Peek() == 0)\n                    throw new InvalidDataException(\"\
    Unbalanced parentheses. No matching opening parentheses.\");\n               \
    \ openParen_stack.Push(closeParen_count.Pop());\n            } else if (openParen_count.Peek()\
    \ > 0 && ch == ' ') {\n                openParen_count.Pop();\n            }\n\
    \        }\n        while (openParen_stack.Count > 0 || closeParen_stack.Count\
    \ > 0) {\n            if (openParen_stack.Count > 0) {\n                var max_open\
    \ = openParen_stack.Pop();\n                if (max_open - closeParen_count.Peek()\
    \ > results.Count)\n                    results.Add(max_open - closeParen_count.Peek());\n\
    \            }\n            if (closeParen_stack.Count > 0) {\n              \
    \  var max_close = closeParen_count.Pop();\n                if (max_close - openParen_stack.Count\
    \ > results.Count)\n                    results.Add(max_close - openParen_stack.Count);\n\
    \            }\n        }\n        return results;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkowoarrv.cs(28,31): error CS0246: The type or namespace name ''InvalidDataException''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpkowoarrv.cs(36,31): error CS0246: The type or namespace name ''InvalidDataException''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> results = new List<long>();\n        foreach\
    \ (string group in paren_string.TrimEnd('()').Split(' '))\n            if (group.StartsWith(\"\
    (\")) {\n                results.Add(ParseNestedParens(group));\n            }\
    \ else {\n                results.Add(new long[] { 0 });\n            }\n    \
    \    return results;\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpui5e23_5.cs(16,55): error CS1012: Too many characters in character literal

    '
  timestamp: 1659976353
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        HashSet<long> paren_stack = new HashSet<long>();\n\
    \        var pars = paren_string.Split(' ');\n        foreach (var par in pars)\
    \ {\n            var p = par.Trim();\n            if (p.StartsWith(\"(\")) {\n\
    \                paren_stack.Add(0L);\n            } else if (p.EndsWith(\")\"\
    )) {\n                var level = paren_stack.Count - 1;\n                if (!paren_stack.Contains(level))\
    \ {\n                    throw new Exception(\"Invalid parentheses string\");\n\
    \                }\n                paren_stack = paren_stack.Except(new long[]\
    \ { level }).ToHashSet();\n            } else {\n                long level;\n\
    \                if (paren_stack.TryGetValue(p.Length, out level)) {\n       \
    \             level++;\n                }\n                paren_stack.Add(level);\n\
    \            }\n        }\n        List<long> result = new List<long>();\n   \
    \     foreach (var paren_level in paren_stack) {\n            result.Add(paren_level);\n\
    \        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <af246f322dc2434d9576888205afe621>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <af246f322dc2434d9576888205afe621>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var paren_level = new List<long>();\n        foreach\
    \ (var s in paren_string.Split(' '))\n        {\n            var new_level = 0;\n\
    \            var open_p = paren_level.LastOrDefault();\n            if (open_p\
    \ != null)\n            {\n                new_level = open_p.Value + 1;\n   \
    \         }\n            paren_level.Add(new long(new_level));\n            var\
    \ close_parentheses = false;\n            foreach (var c in s)\n            {\n\
    \                if (c == '(')\n                {\n                    close_parentheses\
    \ = true;\n                }\n                if (c == ')')\n                {\n\
    \                    close_parentheses = false;\n                }\n         \
    \       if (close_parentheses)\n                {\n                    var last_p\
    \ = paren_level.LastOrDefault();\n                    if (last_p != null)\n  \
    \                  {\n                        last_p.Value++;\n              \
    \      }\n                }\n            }\n        }\n        return paren_level;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyt0452ni.cs(22,36): error CS1061: ''long'' does not contain a definition
    for ''Value'' and no accessible extension method ''Value'' accepting a first argument
    of type ''long'' could be found (are you missing a using directive or an assembly
    reference?)

    /tmp/tmpyt0452ni.cs(24,33): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    /tmp/tmpyt0452ni.cs(41,32): error CS1061: ''long'' does not contain a definition
    for ''Value'' and no accessible extension method ''Value'' accepting a first argument
    of type ''long'' could be found (are you missing a using directive or an assembly
    reference?)

    /tmp/tmpyt0452ni.cs(20,17): warning CS0472: The result of the expression is always
    ''true'' since a value of type ''long'' is never equal to ''null'' of type ''long?''

    /tmp/tmpyt0452ni.cs(39,25): warning CS0472: The result of the expression is always
    ''true'' since a value of type ''long'' is never equal to ''null'' of type ''long?''

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) return null;\n        var\
    \ groups = paren_string.Split(' ');\n        var results = new List<long>();\n\
    \        var stack = new Stack<long>();\n        foreach (var group in groups)\
    \ {\n            long level = 0;\n            while (stack.Count > level) {\n\
    \                results.Add(stack[stack.Count - 1]);\n                stack.Pop();\n\
    \            }\n            if (group.Length > 0) {\n                stack.Add(long.Parse(group));\n\
    \            } else {\n                // We hit a group without anything in it.\
    \ That means we hit the last one in the string\n                // and that's\
    \ what we want.\n                results.Add(stack[stack.Count - 1]);\n      \
    \      }\n        }\n        return results;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp34y03ke7.cs(22,29): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    /tmp/tmp34y03ke7.cs(26,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp34y03ke7.cs(30,29): error CS0021: Cannot apply indexing with [] to an
    expression of type ''Stack<long>''

    '
  timestamp: 1659976354
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        bool needs_parentheses = true;\n        List<long>\
    \ paren_levels = new List<long>();\n        for (long level = 0; paren_string\
    \ != string.Empty; level++) {\n            paren_levels.Add(level);\n        \
    \    if (needs_parentheses) {\n                if (paren_string.Contains(\"(\"\
    )) {\n                    paren_string = paren_string.Replace(\"(\", string.Empty);\n\
    \                    needs_parentheses = false;\n                } else if (paren_string.Contains(\"\
    )\")) {\n                    paren_string = paren_string.Replace(\")\", string.Empty);\n\
    \                    needs_parentheses = true;\n                }\n          \
    \  }\n        }\n        return paren_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659976360
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        HashSet<long>\
    \ level_stack = new HashSet<long>();\n        foreach (char c in paren_string)\n\
    \        {\n            if (c == '(')\n            {\n                if (!level_stack.Any())\n\
    \                {\n                    levels.Add(0L);\n                }\n \
    \               else\n                {\n                    level_stack.Add(levels[levels.Count\
    \ - 1]);\n                }\n            }\n            if (c == ')')\n      \
    \      {\n                levels[levels.Count - 1] = level_stack.Remove(levels[levels.Count\
    \ - 1]);\n                levels.RemoveAt(levels.Count - 1);\n            }\n\
    \        }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmisu9i9q.cs(32,44): error CS0029: Cannot implicitly convert type ''bool''
    to ''long''

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string output = paren_string.Replace(\"(\", string.Empty).Replace(\"\
    )\", string.Empty).Replace(\")(\", string.Empty);\n        string[] nested = new\
    \ string[] {\n            \"(\",\n            \"()\",\n            \"(())\",\n\
    \            \"()(\",\n            \"(()())\",\n            \"(()())()\",\n  \
    \          \"(())()()\",\n            \"()()()\",\n            \"()()()()\",\n\
    \            \"((()))\",\n            \"((())())\",\n            \"((())())()\"\
    ,\n            \"(((()))\",\n            \"(((()))())\",\n            \"(((()))())()\"\
    ,\n            \"(((()()))\",\n            \"(((()()))())\",\n            \"(((()()))())()\"\
    ,\n            \"((()()))()\",\n            \"((()()))()()\",\n            \"\
    ((()()))()()()\",\n            \"()()()()\",\n            \"()()()()()\",\n  \
    \          \"()()()()()()\",\n            \"((()))()\",\n            \"((())())()\"\
    ,\n            \"((())())()()\",\n            \"(((()))()\",\n            \"(((()))())()\"\
    ,\n            \"(((()))())()()\",\n            \"(((()()))()\",\n           \
    \ \"(((()()))())()\",\n            \"(((()()))())()()\",\n            \"((()()))()()\"\
    ,\n            \"((()()))()()()\",\n            \"((()()))()()()()\",\n      \
    \      \"()()()()()()\",\n            \"()()()()()()()\",\n            \"()()()()()()()()\"\
    ,\n            \"((()))()()\",\n            \"((())())()()\",\n            \"\
    ((())())()()()\",\n            \"(((()))()()\",\n            \"(((()))())()()\"\
    ,\n            \"(((()))())()()()\",\n            \"(((()()))()()\",\n       \
    \     \"(((()()))())()()\",\n            \"(((()()))())()()()\",\n           \
    \ \"((()()))()()()\",\n            \"((()()))()()()()\",\n            \"((()()))()()()()()\"\
    ,\n            \"()()()()()()()()\",\n            \"()()()()()()()()()\",\n  \
    \          \"()()()()()()()()()\",\n        };\n        return nested.SelectMany(s\
    \ => ParseNesting(output)).ToList();\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdwm56h3i.cs(72,39): error CS0103: The name ''ParseNesting'' does not exist
    in the current context

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var nestings = new List<long>();\n        nestings.AddRange(ParseNestings(paren_string));\n\
    \n        // Scan over the parentheses and keep track of the maximum nesting level.\n\
    \        for (int i = 0; i < paren_string.Length; i++) {\n            if (paren_string[i]\
    \ == '(' && paren_string[i - 1] != ')') {\n                nestings.Add(i);\n\
    \            }\n            if (paren_string[i] == ')' && paren_string[i + 1]\
    \ != ')') {\n                if (nestings.Count > 0) {\n                    nestings.RemoveAt(nestings.Count\
    \ - 1);\n                } else {\n                    nestings.Add(i);\n    \
    \            }\n            }\n        }\n        return nestings;\n    }\n  \
    \  public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj4qgb0i9.cs(16,27): error CS0103: The name ''ParseNestings'' does not
    exist in the current context

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_nested_level = new List<long>();\n \
    \       List<char> group_chars = new List<char>();\n        List<List<char>> grouped_chars\
    \ = new List<List<char>>();\n        int i = 0;\n        while (i < paren_string.Length)\
    \ {\n            if (paren_string[i] == '(') {\n                group_chars.Add(paren_string[i]);\n\
    \                grouped_chars.Add(group_chars);\n                group_chars\
    \ = new List<char>();\n            } else if (paren_string[i] == ')') {\n    \
    \            long level = 0;\n                for (int j = 0; j < grouped_chars.Count\
    \ - 1; j++) {\n                    if (grouped_chars[j].Last() == paren_string[i])\
    \ {\n                        level++;\n                    } else {\n        \
    \                break;\n                    }\n                }\n          \
    \      max_nested_level.Add(level);\n                grouped_chars.RemoveAt(grouped_chars.Count\
    \ - 1);\n                group_chars.RemoveAt(group_chars.Count - 1);\n      \
    \      } else {\n                group_chars.Add(paren_string[i]);\n         \
    \   }\n            i++;\n        }\n        return max_nested_level;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x000cd] in <fff9b27704664af9b239f251c81b5fde>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <fff9b27704664af9b239f251c81b5fde>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].RemoveAt (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x000cd] in <fff9b27704664af9b239f251c81b5fde>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <fff9b27704664af9b239f251c81b5fde>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> res = new List<long>();\n        Stack<Tuple<long,\
    \ long>> parens = new Stack<Tuple<long, long>>();\n        StringBuilder sb =\
    \ new StringBuilder();\n        string s = paren_string;\n        foreach(char\
    \ c in s) {\n            if(char.IsWhiteSpace(c)) continue;\n            if(char.IsLetterOrDigit(c))\
    \ {\n                sb.Append(c);\n            }\n            else {\n      \
    \          if (sb.Length > 0) {\n                    res.Add(new BigInteger(sb.ToString()));\n\
    \                    res.Add(0L);\n                    parens.Push(new Tuple<long,\
    \ long>(new BigInteger(sb.ToString()), 0L));\n                    sb.Length =\
    \ 0;\n                }\n                else {\n                    throw new\
    \ ArgumentException(\"The input string \" + paren_string + \" has invalid character!\"\
    );\n                }\n            }\n        }\n        if(sb.Length > 0) res.Add(new\
    \ BigInteger(sb.ToString()));\n        if(sb.Length > 0) throw new ArgumentException(\"\
    The input string \" + paren_string + \" has invalid character!\");\n        while\
    \ (!parens.IsEmpty()) {\n            Tuple<long, long> tp = parens.Pop();\n  \
    \          BigInteger cur = tp.Item1;\n            long l = tp.Item2;\n      \
    \      for(int i = 0; i < l; i++) {\n                BigInteger next_ = cur.Subtract(BigInteger.One);\n\
    \                if(next_.Equals(BigInteger.One)) {\n                    res.RemoveAt(res.Count\
    \ - 1);\n                }\n                else {\n                    res.Add(cur.Value);\n\
    \                }\n                cur = next_;\n            }\n        }\n \
    \       return res;\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp11ammwo9.cs(26,44): error CS1503: Argument 1: cannot convert from ''string''
    to ''int''

    /tmp/tmp11ammwo9.cs(28,70): error CS1503: Argument 1: cannot convert from ''string''
    to ''int''

    /tmp/tmp11ammwo9.cs(36,50): error CS1503: Argument 1: cannot convert from ''string''
    to ''int''

    /tmp/tmp11ammwo9.cs(38,24): error CS1061: ''Stack<Tuple<long, long>>'' does not
    contain a definition for ''IsEmpty'' and no accessible extension method ''IsEmpty''
    accepting a first argument of type ''Stack<Tuple<long, long>>'' could be found
    (are you missing a using directive or an assembly reference?)

    /tmp/tmp11ammwo9.cs(43,40): error CS7036: There is no argument given that corresponds
    to the required formal parameter ''right'' of ''BigInteger.Subtract(BigInteger,
    BigInteger)''

    /tmp/tmp11ammwo9.cs(48,33): error CS1061: ''BigInteger'' does not contain a definition
    for ''Value'' and no accessible extension method ''Value'' accepting a first argument
    of type ''BigInteger'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Part 1: Count opening parantheses.\n        int\
    \ num_opening_parantheses = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            char c = paren_string[i];\n            if (c == '(') {\n\
    \                num_opening_parantheses += 1;\n            }\n            if\
    \ (c == ')') {\n                num_opening_parantheses -= 1;\n            }\n\
    \        }\n        // Part 2: Calculate depth of nested parentheses.\n      \
    \  long[] stack = new long[num_opening_parantheses];\n        stack[0] = 0L;\n\
    \        int num_opening_parantheses_at_current_level = 1;\n        int i = 0;\n\
    \        while (i < paren_string.Length) {\n            char c = paren_string[i];\n\
    \            if (c == '(') {\n                stack[num_opening_parantheses_at_current_level\
    \ - 1] += 1;\n                num_opening_parantheses_at_current_level += 1;\n\
    \                i += 1;\n            }\n            if (c == ')') {\n       \
    \         num_opening_parantheses_at_current_level -= 1;\n                if (num_opening_parantheses_at_current_level\
    \ == 0) {\n                    stack[num_opening_parantheses_at_current_level\
    \ - 1] += 1;\n                }\n                i += 1;\n            }\n    \
    \    }\n        // Part 3: Calculate the deepest level of nesting.\n        List<long>\
    \ deepest_level = new List<long>();\n        for (int i = 1; i < num_opening_parantheses;\
    \ i++) {\n            deepest_level.Add(stack[i - 1]);\n        }\n        return\
    \ deepest_level;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcqqjopgc.cs(17,18): error CS0136: A local or parameter named ''i'' cannot
    be declared in this scope because that name is used in an enclosing local scope
    to define a local or parameter

    /tmp/tmpcqqjopgc.cs(48,18): error CS0136: A local or parameter named ''i'' cannot
    be declared in this scope because that name is used in an enclosing local scope
    to define a local or parameter

    '
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested_paren = new List<long>();\n\n   \
    \     // Create a stack to hold the opening and closing parentheses.\n       \
    \ // The parentheses are popped in reverse order when exiting the function.\n\
    \        Stack<string> paren_stack = new Stack<string>();\n\n        foreach (var\
    \ item in paren_string.Split(\" \")) {\n            if (paren_stack.Count == 0)\
    \ {\n                paren_stack.Push(item);\n            }\n            else\
    \ if (paren_stack.Count == 1) {\n                if (item == \"(\") {\n      \
    \              nested_paren.Add(0);\n                }\n                else if\
    \ (item == \")\") {\n                    nested_paren.Add(nested_paren[nested_paren.Count\
    \ - 1] + 1);\n                }\n            }\n            else {\n         \
    \       if (item == \"(\") {\n                    nested_paren.Add(0);\n     \
    \           }\n                else if (item == \")\") {\n                   \
    \ nested_paren.Add(nested_paren[nested_paren.Count - 1] + 1);\n              \
    \  }\n                else {\n                    if (item.Equals(\"(\")) {\n\
    \                        nested_paren.Add(nested_paren[nested_paren.Count - 1]\
    \ + 1);\n                    }\n                    else {\n                 \
    \       nested_paren.Add(nested_paren[nested_paren.Count - 1]);\n            \
    \        }\n                }\n            }\n            while (paren_stack.Count\
    \ > 0 && item.Equals(\"(\")) {\n                paren_stack.Pop();\n         \
    \   }\n            while (paren_stack.Count > 0 && item.Equals(\")\")) {\n   \
    \             paren_stack.Pop();\n            }\n            while (paren_stack.Count\
    \ > 0) {\n                paren_stack.Pop();\n            }\n        }\n\n   \
    \     return nested_paren;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <c042b17a86d6496bb4c6301914971849>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <c042b17a86d6496bb4c6301914971849>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        char[] chars = paren_string.ToCharArray();\n      \
    \  Stack<long> stack = new Stack<long>();\n        List<long> result = new List<long>();\n\
    \        bool has_open = false;\n        bool has_closed = false;\n        int\
    \ i = 0;\n        for (i = 0; i < (chars.Length - 1); i++) {\n            if (chars[i]\
    \ == '(') {\n                if (stack.Count == 0) {\n                    has_open\
    \ = true;\n                }\n                else if (stack.Count == 1 && has_open\
    \ && has_closed) {\n                    result.Add(stack.Pop());\n           \
    \         stack.Clear();\n                    has_open = false;\n            \
    \        has_closed = false;\n                }\n                else if (stack.Count\
    \ > 0 && has_open && !has_closed) {\n                    stack.Clear();\n    \
    \                has_open = false;\n                }\n                else if\
    \ (stack.Count > 0 && has_open && has_closed) {\n                    stack.Clear();\n\
    \                    has_open = false;\n                    has_closed = false;\n\
    \                }\n                else if (stack.Count > 0 && !has_open && !has_closed)\
    \ {\n                    stack.Clear();\n                    has_open = false;\n\
    \                }\n                else if (stack.Count == 1 && has_open && !has_closed)\
    \ {\n                    stack.Pop();\n                    has_open = false;\n\
    \                    has_closed = false;\n                }\n                else\
    \ if (stack.Count > 0 && has_open && has_closed) {\n                    stack.Pop();\n\
    \                    has_open = false;\n                    has_closed = false;\n\
    \                }\n            }\n            else if (chars[i] == ')') {\n \
    \               if (stack.Count == 0) {\n                    has_closed = true;\n\
    \                }\n                else if (stack.Count == 1 && has_open && has_closed)\
    \ {\n                    result.Add(stack.Pop());\n                    stack.Clear();\n\
    \                    has_open = false;\n                    has_closed = false;\n\
    \                }\n                else if (stack.Count > 0 && has_open && !has_closed)\
    \ {\n                    stack.Clear();\n                    has_open = false;\n\
    \                }\n                else if (stack.Count > 0 && has_open && has_closed)\
    \ {\n                    stack.Clear();\n                    has_open = false;\n\
    \                    has_closed = false;\n                }\n                else\
    \ if (stack.Count > 0 && !has_open && !has_closed) {\n                    stack.Clear();\n\
    \                    has_open = false;\n                }\n                else\
    \ if (stack.Count == 1 && has_open && !has_closed) {\n                    stack.Pop();\n\
    \                    has_open = false;\n                    has_closed = false;\n\
    \                }\n                else if (stack.Count > 0 && has_open && has_closed)\
    \ {\n                    stack.Pop();\n                    has_open = false;\n\
    \                    has_closed = false;\n                }\n            }\n \
    \           else if (!has_open && !has_closed) {\n                stack.Push(long.Parse(string.Join(\"\
    \", chars.Take(i + 1))));\n                has_open = true;\n                has_closed\
    \ = false;\n            }\n        }\n\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyxo03f4h.cs(14,30): error CS0161: ''Problem.ParseNestedParens(string)'':
    not all code paths return a value

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string parens_str = string.Empty;\n        List<char>\
    \ paren_chars = new List<char>();\n        foreach (char c in paren_string) {\n\
    \            if ((c == '(') || (c == '[') || (c == '{')) {\n                paren_chars.Add(c);\n\
    \            }\n            else if (c == ')') {\n                if (paren_chars.Count\
    \ == 0) {\n                    throw new ApplicationException(\"Cannot find closing\
    \ parenthesis\");\n                }\n                else if (paren_chars.Last()\
    \ == '(') {\n                    paren_chars.RemoveAt(paren_chars.Count - 1);\n\
    \                    parens_str += paren_chars.Last().ToString();\n          \
    \      }\n                else {\n                    parens_str += paren_chars[paren_chars.Count\
    \ - 1].ToString();\n                }\n                paren_chars.RemoveAt(paren_chars.Count\
    \ - 1);\n            }\n            else if (c == ']') {\n                if (paren_chars.Count\
    \ == 0) {\n                    throw new ApplicationException(\"Cannot find closing\
    \ bracket\");\n                }\n                else if (paren_chars.Last()\
    \ == '[') {\n                    paren_chars.RemoveAt(paren_chars.Count - 1);\n\
    \                    parens_str += paren_chars.Last().ToString();\n          \
    \      }\n                else {\n                    parens_str += paren_chars[paren_chars.Count\
    \ - 1].ToString();\n                }\n                paren_chars.RemoveAt(paren_chars.Count\
    \ - 1);\n            }\n            else if (c == '}') {\n                if (paren_chars.Count\
    \ == 0) {\n                    throw new ApplicationException(\"Cannot find closing\
    \ bracket\");\n                }\n                else if (paren_chars.Last()\
    \ == '{') {\n                    paren_chars.RemoveAt(paren_chars.Count - 1);\n\
    \                    parens_str += paren_chars.Last().ToString();\n          \
    \      }\n                else {\n                    parens_str += paren_chars[paren_chars.Count\
    \ - 1].ToString();\n                }\n                paren_chars.RemoveAt(paren_chars.Count\
    \ - 1);\n            }\n            else {\n                parens_str += c.ToString();\n\
    \            }\n        }\n        if (paren_chars.Count > 0) {\n            throw\
    \ new ApplicationException(\"Cannot find closing bracket\");\n        }\n    \
    \    return new List<long>(new long[] {1L, 1L, parens_str.Length + 1L});\n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidOperationException: Sequence contains\
    \ no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00097] in <a798a5204f614bc592454ec968236c7f>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <a798a5204f614bc592454ec968236c7f>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidOperationException: Sequence\
    \ contains no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00097] in <a798a5204f614bc592454ec968236c7f>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <a798a5204f614bc592454ec968236c7f>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        StringBuilder buffer = new StringBuilder(paren_string);\n\
    \        int opening_count = 0, nesting_level = 0;\n        bool has_opening_parentheses\
    \ = false;\n        while (!buffer.IsEmpty) {\n            char c = buffer.CharAt(0);\n\
    \            switch (c) {\n            case '(':\n                if (buffer.Length\
    \ > 1 && !buffer.Substring(1, 1).Equals(')')) {\n                    has_opening_parentheses\
    \ = true;\n                }\n                nesting_level++;\n             \
    \   break;\n            case ')':\n                nesting_level--;\n        \
    \        break;\n            case '{':\n                opening_count++;\n   \
    \             break;\n            case '}':\n                opening_count--;\n\
    \                break;\n            }\n            if (nesting_level == 0 &&\
    \ opening_count == 0) {\n                has_opening_parentheses = true;\n   \
    \             nesting_level = 1;\n            }\n            buffer.Remove(0,\
    \ 1);\n        }\n        List<long> max_levels = new List<long>(new long[]{nesting_level});\n\
    \        if (has_opening_parentheses) {\n            while (nesting_level > 0)\
    \ {\n                nesting_level--;\n                while (nesting_level ==\
    \ 0) {\n                    max_levels.RemoveAt(max_levels.Count - 1);\n     \
    \           }\n            }\n        }\n        return max_levels;\n    }\n \
    \   public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwnw794i2.cs(18,24): error CS1061: ''StringBuilder'' does not contain a
    definition for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting
    a first argument of type ''StringBuilder'' could be found (are you missing a using
    directive or an assembly reference?)

    /tmp/tmpwnw794i2.cs(19,29): error CS1061: ''StringBuilder'' does not contain a
    definition for ''CharAt'' and no accessible extension method ''CharAt'' accepting
    a first argument of type ''StringBuilder'' could be found (are you missing a using
    directive or an assembly reference?)

    /tmp/tmpwnw794i2.cs(22,50): error CS1061: ''StringBuilder'' does not contain a
    definition for ''Substring'' and no accessible extension method ''Substring''
    accepting a first argument of type ''StringBuilder'' could be found (are you missing
    a using directive or an assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var stack = new Stack<long>();\n        foreach (var\
    \ paren in paren_string.Replace(\" \", string.Empty).Reverse().Split('(')) {\n\
    \            var count = stack.Peek() + 1;\n            stack.Push(count);\n \
    \           if (paren == \"(\") {\n                ++count;\n            }\n \
    \           else if (paren == \")\") {\n                if (stack.Count > 0) {\n\
    \                    var top = stack.Pop();\n                    --count;\n  \
    \                  stack.Push(top);\n                }\n            }\n      \
    \      if (paren != \"(\" && paren != \")\") {\n                throw new ArgumentException();\n\
    \            }\n        }\n        return new List<long>(stack);\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp15tkshm_.cs(16,81): error CS1061: ''IEnumerable<char>'' does not contain
    a definition for ''Split'' and no accessible extension method ''Split'' accepting
    a first argument of type ''IEnumerable<char>'' could be found (are you missing
    a using directive or an assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        // Using\
    \ a stack to keep track of the parenthesis level and only process\n        //\
    \ the deepest one. Also, keep track of the previous character which is\n     \
    \   // either a left parenthesis character or a right parenthesis character to\n\
    \        // distinguish between the opening and closing ones.\n        Stack<long>\
    \ stack = new Stack<long>();\n        // Keeping track of whether a right or left\
    \ parenthesis character is encountered.\n        bool is_left = false;\n\n   \
    \     // For each character in the string.\n        foreach (char c in paren_string)\
    \ {\n            // If the current character is a left parenthesis character then\
    \ add the level\n            // to the stack and reset the flag.\n           \
    \ if (c == '(') {\n                is_left = true;\n                stack.Add(0L);\n\
    \            }\n            // If the current character is a right parenthesis\
    \ character then decrement\n            // the level and reset the flag.\n   \
    \         if (c == ')') {\n                is_left = false;\n                long\
    \ last_level = stack.Pop();\n                result.Add(last_level);\n       \
    \     }\n            // If the current character is a space then add the level\
    \ to the stack.\n            if (c == ' ') {\n                stack.Add(0L);\n\
    \            }\n            // If the current character is an opening parenthesis\
    \ character then increment\n            // the level by one.\n            if (c\
    \ == '(') {\n                stack.Add(1L);\n            }\n            // If\
    \ the current character is a closing parenthesis character then decrement\n  \
    \          // the level by one.\n            if (c == ')') {\n               \
    \ stack.Pop();\n            }\n        }\n\n        // If the stack is empty then\
    \ all parentheses have the same level of nesting.\n        if (stack.Count !=\
    \ 0) {\n            throw new Exception(\"Unbalanced parentheses in input\");\n\
    \        }\n\n        // If the stack is empty then all parentheses have the same\
    \ level of nesting.\n        if (result.Count != 0) {\n            return result;\n\
    \        }\n\n        // If all parentheses have the same level of nesting then\
    \ there is no maximum level.\n        return new List<long>();\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz54fr8m_.cs(30,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpz54fr8m_.cs(41,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpz54fr8m_.cs(46,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpz54fr8m_.cs(22,14): warning CS0219: The variable ''is_left'' is assigned
    but its value is never used

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int num_paren = 0;\n        char[] charArray = paren_string.ToCharArray();\n\
    \        List<long> nested_list = new List<long>(new long[charArray.Length]);\n\
    \        bool open_paren = false;\n        bool close_paren = false;\n       \
    \ Stack<long> stack = new Stack<long>();\n        long level = 1;\n        char[]\
    \ current_char = new char[charArray.Length];\n        for (int i = 0; i < charArray.Length;\
    \ i++) {\n            current_char[i] = charArray[i];\n            if (current_char[i]\
    \ == '(') {\n                open_paren = true;\n                stack.Add(level);\n\
    \                num_paren++;\n            } else if (current_char[i] == ')')\
    \ {\n                close_paren = true;\n                level -= stack.Pop();\n\
    \                nested_list.Add(level);\n                open_paren = false;\n\
    \            } else if (open_paren) {\n                level++;\n            }\
    \ else if (close_paren) {\n                level--;\n            }\n        }\n\
    \        return nested_list;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5jsi88y2.cs(27,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976354
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Stack<long> stack = new Stack<long>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        foreach (char ch in paren_string) {\n   \
    \         if (ch == '(') {\n                stack.Push(long.MaxValue);\n     \
    \       }\n            else if (ch == ')') {\n                long top = stack.Pop();\n\
    \                if (top > long.MaxValue) {\n                    throw new ArgumentException(\"\
    The string has invalid nested parentheses\", \"paren_string\");\n            \
    \    }\n                sb.Append(top);\n            }\n            else if (char.IsWhiteSpace(ch))\
    \ {\n                continue;\n            }\n            else {\n          \
    \      sb.Append(ch);\n            }\n        }\n        long total_count = sb.Length;\n\
    \        List<long> return_list = new List<long>();\n        for (int i = 0; i\
    \ < total_count; i++) {\n            return_list.Add(stack.Count - 1);\n     \
    \   }\n        return return_list;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <41a22aa306754fadbe6be9f9e5d07cc8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <41a22aa306754fadbe6be9f9e5d07cc8>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested_levels = new List<long>();\n    \
    \    Stack<string> parens = new Stack<string>();\n        parens.Push(\"\");\n\
    \        string s = paren_string;\n        string current_level = \"\";\n    \
    \    long level = 0;\n        foreach (char c in s) {\n            if (c == '(')\
    \ {\n                if (!string.IsNullOrEmpty(current_level)) {\n           \
    \         nested_levels.Add(level);\n                }\n                level++;\n\
    \                parens.Push(\"\");\n                current_level = string.Empty;\n\
    \            } else if (c == ')') {\n                if (!string.IsNullOrEmpty(current_level))\
    \ {\n                    nested_levels.Add(level);\n                }\n      \
    \          level--;\n                string popped_level = parens.Pop();\n   \
    \             if (string.IsNullOrEmpty(popped_level)) {\n                    throw\
    \ new Exception(\"Invalid Parenthesis String\");\n                }\n        \
    \        nested_levels.Add(popped_level);\n                current_level = string.Empty;\n\
    \            }\n            else {\n                current_level = current_level\
    \ + c;\n            }\n        }\n        if (!string.IsNullOrEmpty(current_level))\
    \ {\n            nested_levels.Add(level);\n        }\n        return nested_levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9lyapyor.cs(38,35): error CS1503: Argument 1: cannot convert from ''string''
    to ''long''

    '
  timestamp: 1659976354
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var nested_paren_string = paren_string.Replace(\"(\"\
    , \"{\"); // To ensure the correct order of nested parentheses.\n        nested_paren_string\
    \ = nested_paren_string.Replace(\")\", \"}\");\n        var parsed_list = ParseParentheses(nested_paren_string);\n\
    \        var count_of_parentheses = parsed_list.Count;\n        parsed_list =\
    \ ParseParentheses(paren_string);\n        var highest_count_of_parentheses =\
    \ parsed_list.Count;\n        var return_array = new List<long>();\n        if\
    \ (count_of_parentheses == highest_count_of_parentheses)\n            return return_array;\n\
    \        else {\n            for (int i = 0; i < count_of_parentheses; i++) {\n\
    \                return_array.Add(parsed_list[i]);\n                parsed_list.RemoveAt(0);\n\
    \            }\n        }\n        return return_array;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6668jp5p.cs(17,27): error CS0103: The name ''ParseParentheses'' does not
    exist in the current context

    /tmp/tmp6668jp5p.cs(18,13): error CS0815: Cannot assign method group to an implicitly-typed
    variable

    /tmp/tmp6668jp5p.cs(19,23): error CS0103: The name ''ParseParentheses'' does not
    exist in the current context

    /tmp/tmp6668jp5p.cs(20,13): error CS0815: Cannot assign method group to an implicitly-typed
    variable

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> level_of_nesting = new List<long>();\n\n\
    \        // We use a stack to store opening parenthesis, because we can't know\
    \ how many closing parenthesis we can expect in a given string.\n        Stack<long>\
    \ stack = new Stack<long>();\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == '(') {\n                stack.Add(i);\n\
    \            } else if (paren_string[i] == ')') {\n                level_of_nesting.Add(level_of_nesting.Count\
    \ - stack.Pop());\n            }\n        }\n        return level_of_nesting;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc2_lhn7c.cs(21,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976355
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var groups = new List<long>();\n        var group =\
    \ new List<long>();\n        var depth = 0;\n        foreach (var ch in paren_string)\
    \ {\n            group.Add(ch);\n            depth++;\n            if (ch == '(')\
    \ {\n                if (depth == 0) {\n                    groups.Add(group.Count);\n\
    \                    group.Clear();\n                }\n                depth++;\n\
    \            }\n            else if (ch == ')') {\n                depth--;\n\
    \                if (depth == 0) {\n                    groups.Add(group.Count);\n\
    \                    group.Clear();\n                }\n            }\n      \
    \  }\n        if (depth > 0) {\n            groups.Add(group.Count);\n       \
    \ }\n        return new List<long>(groups);\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fb17775b6c5a4e4bb1dcf95901e901d6>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fb17775b6c5a4e4bb1dcf95901e901d6>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var groups = new List<long>();\n\n        Stack<long>\
    \ nesting;\n        nesting = new Stack<long>();\n\n        var current_group_level\
    \ = 0;\n        long current_group_count = 0;\n        foreach (char c in paren_string)\
    \ {\n            if (nesting.Count == current_group_level) {\n               \
    \ nesting.Push(current_group_count);\n                current_group_count = 1;\n\
    \                current_group_level++;\n            }\n            else if (nesting.Count\
    \ == current_group_level) {\n                nesting.Pop();\n                current_group_count++;\n\
    \            }\n\n            if (c == '(') {\n                current_group_count++;\n\
    \            }\n            else if (c == ')') {\n                current_group_count--;\n\
    \            }\n\n            current_group_count++;\n            groups = groups.Union(nesting).ToList();\n\
    \        }\n        return groups;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fb965186145948b0a5d14b79fa244aa3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fb965186145948b0a5d14b79fa244aa3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var chars_to_ignore = new HashSet<char>() { '(', ')'\
    \ };\n\n        // Create stack of chars\n        var stack = new Stack<char>();\n\
    \n        // Create list of levels of nesting for each char\n        var level_of_nesting\
    \ = new List<long>();\n\n        // Initialize list\n        level_of_nesting.Add(0L);\n\
    \n        foreach (var c in paren_string) {\n            bool push_stack = false;\n\
    \            if (chars_to_ignore.Contains(c)) {\n                push_stack =\
    \ true;\n            } else {\n                if (stack.Count == 0) {\n     \
    \               // This char has no nested level\n                    push_stack\
    \ = true;\n                } else {\n                    long level_of_c = level_of_nesting[stack.Count\
    \ - 1];\n\n                    if (c == ')') {\n                        // This\
    \ char has one more level of nesting\n                        if (level_of_nesting.Contains(level_of_c))\
    \ {\n                            push_stack = true;\n                        }\n\
    \                    } else if (c == '(') {\n                        // This char\
    \ has one less level of nesting\n                        if (level_of_nesting.Contains(level_of_c\
    \ - 1)) {\n                            push_stack = true;\n                  \
    \      }\n                    }\n                }\n            }\n\n        \
    \    if (push_stack) {\n                level_of_nesting.Add(level_of_nesting.Last()\
    \ + 1);\n            } else {\n                level_of_nesting.RemoveAt(level_of_nesting.Count\
    \ - 1);\n            }\n\n            stack.Push(c);\n        }\n\n        Debug.Assert(paren_string.Length\
    \ == level_of_nesting.Count);\n        Debug.Assert(level_of_nesting.Count ==\
    \ level_of_nesting[0]);\n        return new List<long>(level_of_nesting);\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0007b] in <7f87f2731e5c418992c998edd52b1e92>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <7f87f2731e5c418992c998edd52b1e92>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x0007b] in <7f87f2731e5c418992c998edd52b1e92>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <7f87f2731e5c418992c998edd52b1e92>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length == 0) {\n            return\
    \ new List<long>(0);\n        }\n        List<long> l = new List<long>(0);\n \
    \       string str = \"\";\n        int i = 0;\n        for (; (i < paren_string.Length);\
    \ i++) {\n            char c = paren_string[i];\n            if (c == '(') {\n\
    \                str = paren_string.Substring(0, i);\n                l.Add(ParseNestedParens(str).Max());\n\
    \            } else {\n                str += c;\n            }\n        }\n \
    \       return l;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidOperationException: Sequence contains\
    \ no elements\n  at System.Linq.Enumerable.Max (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00022] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00051] in <23bcc18f4f1941309b2a623ebea1d9d0>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <23bcc18f4f1941309b2a623ebea1d9d0>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidOperationException: Sequence\
    \ contains no elements\n  at System.Linq.Enumerable.Max (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00022] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00051] in <23bcc18f4f1941309b2a623ebea1d9d0>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <23bcc18f4f1941309b2a623ebea1d9d0>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Debug.WriteLine(\"ParseNestedParens \" + paren_string);\n\
    \        var parens = paren_string.Split(new char[] { '(', ')' }, StringSplitOptions.RemoveEmptyEntries);\n\
    \        long result = 0;\n        foreach (var p in parens) {\n            Debug.WriteLine(\"\
    \\tp \" + p);\n            result = Math.Max(result,ParseNestedParens(p));\n \
    \       }\n        return new List<long>(new long[]{result});\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp341dpjse.cs(20,31): error CS1503: Argument 1: cannot convert from ''long''
    to ''byte''

    /tmp/tmp341dpjse.cs(20,38): error CS1503: Argument 2: cannot convert from ''System.Collections.Generic.List<long>''
    to ''byte''

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException(\"\
    paren_string\");\n        List<long> max_nested_level = GetMaxNestingLevel(paren_string);\n\
    \        return max_nested_level;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4qxr3kz4.cs(17,39): error CS0103: The name ''GetMaxNestingLevel'' does
    not exist in the current context

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) throw new ArgumentNullException(\"\
    paren_string\");\n        var depths = new List<long>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        bool inparen = false;\n        bool inbrace\
    \ = false;\n        foreach (var ch in paren_string) {\n            if (inparen)\
    \ {\n                inparen = false;\n                if (ch == '(') depths.Add(sb.Length);\n\
    \                else if (ch == ')') {\n                    if (sb.Length > 0)\
    \ {\n                        var n = sb.Length - 1;\n                        while\
    \ (n >= 0 && depths[sb.Length - n] == depths[sb.Length - n + 1]) {\n         \
    \                   --n;\n                        }\n                        if\
    \ (n > 0) depths.Add(sb.Length - n);\n                        else\n         \
    \               {\n                            sb.Remove(sb.Length - 1, 1);\n\
    \                            --depths.Count;\n                        }\n    \
    \                }\n                }\n            }\n            else if (ch\
    \ == '(') inparen = true;\n            else if (ch == ')') inparen = false;\n\
    \            else if (ch == '{') inbrace = true;\n            else if (ch == '}')\
    \ inbrace = false;\n            else {\n                sb.Append(ch);\n     \
    \       }\n        }\n        if (sb.Length != 0) throw new ArgumentException(\"\
    The string is not well formatted.\");\n        return depths;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphho_0f3b.cs(34,31): error CS0200: Property or indexer ''List<long>.Count''
    cannot be assigned to -- it is read only

    /tmp/tmphho_0f3b.cs(19,14): warning CS0219: The variable ''inbrace'' is assigned
    but its value is never used

    '
  timestamp: 1659976355
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialize result list to hold the deepest level\
    \ of nesting for each group\n        List<long> max_level = new List<long>();\n\
    \        // Keep track of the number of opening and closing parentheses in the\
    \ group\n        int n_open = 0, n_close = 0;\n        // Iterate over each character\
    \ in the string and update n_open and n_close based on them\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                // Increase\
    \ the number of openings\n                n_open++;\n            } else if (c\
    \ == ')') {\n                // Decrease the number of closings\n            \
    \    n_close--;\n            } else if (c == '[') {\n                // Keep a\
    \ count of how many opening brackets are already in the group\n              \
    \  int open_count = 0;\n                // Iterate over each character in the\
    \ string and update open_count based on them\n                foreach (char open\
    \ in paren_string) {\n                    if (open == '(') {\n               \
    \         open_count++;\n                    }\n                    if (open_count\
    \ == n_open) {\n                        // A matching closing bracket is found\
    \ so update open_count and break out of the loop\n                        open_count\
    \ = 0;\n                        break;\n                    }\n              \
    \  }\n                n_open = open_count;\n            } else if (c == ']') {\n\
    \                // Keep a count of how many closing brackets are already in the\
    \ group\n                int close_count = 0;\n                // Iterate over\
    \ each character in the string and update close_count based on them\n        \
    \        foreach (char close in paren_string) {\n                    if (close\
    \ == ')') {\n                        close_count++;\n                    }\n \
    \                   if (close_count == n_close) {\n                        //\
    \ A matching opening bracket is found so update close_count and break out of the\
    \ loop\n                        close_count = 0;\n                        break;\n\
    \                    }\n                }\n                n_close = close_count;\n\
    \            }\n            if (n_close == n_open + 1) {\n                // The\
    \ group is complete, update max_level and break out of the loop\n            \
    \    max_level.Add(n_open);\n                break;\n            }\n        }\n\
    \        // Return the deepest level of nesting\n        return max_level;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d88b89065757446eba4b0c3275fcc8bb>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d88b89065757446eba4b0c3275fcc8bb>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<char> char_list = paren_string.ToCharArray();\n\
    \        List<int> results = new List<int>();\n        for (int i = 0, j = char_list.Count;\
    \ i < j; i++) {\n            // find starting position of the group\n        \
    \    int start = i;\n            while (char_list[start] == '(') {\n         \
    \       start++;\n            }\n            // find the ending position of the\
    \ group\n            int end = i;\n            while (char_list[end] == ')') {\n\
    \                end++;\n            }\n            // calculate size of group\n\
    \            int size = end - start;\n            // add this group to results\n\
    \            results.Add(size);\n            // swap the groups with the next\
    \ one to process next group\n            int tmp = char_list[start];\n       \
    \     char_list[start] = char_list[end];\n            char_list[end] = tmp;\n\
    \        }\n        return results.OrderByDescending(s => s).ToList();\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwbrin125.cs(15,32): error CS0029: Cannot implicitly convert type ''char[]''
    to ''System.Collections.Generic.List<char>''

    /tmp/tmpwbrin125.cs(35,30): error CS0266: Cannot implicitly convert type ''int''
    to ''char''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpwbrin125.cs(37,16): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.List<int>''
    to ''System.Collections.Generic.List<long>''

    '
  timestamp: 1659976355
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        Stack<char> stack = new Stack<char>();\n        List<long>\
    \ nesting = new List<long>();\n        List<long> level = new List<long>();\n\
    \        foreach (char c in paren_string) {\n            stack.Push(c);\n    \
    \        char topmost = stack.Pop();\n            if (c == '(') {\n          \
    \      level.Add((long)0);\n            } else if (c == ')') {\n             \
    \   int index = level.IndexOf(topmost);\n                if (index > -1) {\n \
    \                   level.RemoveAt(index);\n                    level.Insert(index,\
    \ level.Count + 1);\n                }\n                if (level.Count > 0) {\n\
    \                    nesting.Add((long)level.Count);\n                }\n    \
    \        }\n        }\n        return nesting;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <ee9d967a4a634f76b3b636c33b82717e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <ee9d967a4a634f76b3b636c33b82717e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976355
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        HashSet<long> hs = new HashSet<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        List<long> res = new List<long>();\n   \
    \     foreach (string s in paren_string.Split(new char[]{'(', ')', ' '}, StringSplitOptions.RemoveEmptyEntries))\
    \ {\n            if (s.Trim().Length == 0) {\n                res.Add(0);\n  \
    \          } else {\n                stack.Push(0L);\n                foreach\
    \ (char c in s) {\n                    switch (c) {\n                        case\
    \ '(':\n                            stack.Push(stack.Count + 1L);\n          \
    \                  break;\n                        case ')':\n               \
    \             if (stack.Count > 0) {\n                                res.Add(stack.Pop()\
    \ + 1L);\n                            }\n                            break;\n\
    \                        case ' ':\n                        default:\n       \
    \                     res.Add(stack.Pop() + 1L);\n                           \
    \ break;\n                    }\n                }\n            }\n        }\n\
    \        while (stack.Count > 0) {\n            hs.Add(stack.Pop() + 1L);\n  \
    \      }\n        HashSet<long> new_hs = hs.ToHashSet();\n        List<long> ret\
    \ = new List<long>();\n        foreach (long n in hs) {\n            if (new_hs.Contains(n))\
    \ {\n                ret.Add(n);\n            }\n        }\n        return ret;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d9b2efb7eca246a9b991aa1b32ea8d36>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d9b2efb7eca246a9b991aa1b32ea8d36>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException(\"\
    paren_string\");\n        List<long> nested_level = new List<long>();\n      \
    \  char opening_parenthesis = paren_string[0];\n        bool is_first = true;\n\
    \        char closing_brace = paren_string[paren_string.Length - 1];\n       \
    \ for (int i = 0; i < paren_string.Length; ++i) {\n            char current =\
    \ paren_string[i];\n            if (current == opening_parenthesis) {\n      \
    \          if (is_first) {\n                    nested_level.Add(0L);\n      \
    \              is_first = false;\n                } else {\n                 \
    \   int current_nested_level = nested_level.Count - 1;\n                    nested_level[current_nested_level]\
    \ = nested_level[current_nested_level] + 1L;\n                }\n            }\n\
    \            if (current == closing_brace) {\n                nested_level.RemoveAt(nested_level.Count\
    \ - 1);\n            }\n        }\n        return nested_level;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00072] in <01cee083bd0a413fbc80490c05499a93>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <01cee083bd0a413fbc80490c05499a93>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00072] in <01cee083bd0a413fbc80490c05499a93>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <01cee083bd0a413fbc80490c05499a93>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ levels_stack = new Stack<long>();\n        foreach (string paren in paren_string.Split('\
    \ '))\n        {\n            if (paren.StartsWith(\"(\"))\n            {\n  \
    \              levels_stack.Push(levels[levels.Count - 1] + 1);\n            }\n\
    \            else if (paren.EndsWith(\")\"))\n            {\n                if\
    \ (levels_stack.Count > 0)\n                {\n                    long last_level\
    \ = levels_stack.Pop();\n                    if (last_level > levels[levels.Count\
    \ - 1])\n                    {\n                        levels.Add(last_level);\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ (levels.Count > 0)\n        {\n            levels.Add(levels[levels.Count -\
    \ 1]);\n        }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00040] in <8a0b6487a1074d6abb3af0eb48cf9b69>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <8a0b6487a1074d6abb3af0eb48cf9b69>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00040] in <8a0b6487a1074d6abb3af0eb48cf9b69>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <8a0b6487a1074d6abb3af0eb48cf9b69>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Convert input string into char[] array\n       \
    \ var input_chars = paren_string.ToCharArray();\n        int num_parens = paren_string.Length;\n\
    \n        // A stack for parens\n        var stack = new Stack<char>();\n\n  \
    \      // A stack for nesting\n        var nesting = new Stack<long>();\n\n  \
    \      // A queue of indices of open parens\n        var open_indexes = new Queue<int>();\n\
    \        // To be used for determining whether an open parens has already been\
    \ encountered\n        bool seen_paren = false;\n\n        // Iterate through\
    \ input array and determine nesting levels\n        for (int i = 0; i < num_parens;\
    \ i++) {\n            char c = input_chars[i];\n\n            // If this char\
    \ is an open paren\n            if (c == '(') {\n                // Push open\
    \ paren to the stack\n                stack.push(c);\n\n                // If\
    \ this open paren has already been seen then pop an open paren from the stack\n\
    \                if (!seen_paren) {\n                    open_indexes.push(i);\n\
    \                } else {\n                    // Otherwise, keep this open paren\
    \ on the stack until it closes the group\n                    while (stack.Peek()\
    \ != '(' && stack.Peek() != ')') {\n                        nesting.Push(nesting.Pop());\n\
    \                    }\n                }\n\n                seen_paren = true;\n\
    \            }\n            // If this char is a close paren\n            else\
    \ if (c == ')') {\n                // If stack is empty, we're done with the current\
    \ group\n                if (stack.Count == 0) {\n                    // Pop open\
    \ paren and add it to nesting\n                    nesting.Push(nesting.Pop());\n\
    \n                    // If open_indexes queue is empty, we're done with the current\
    \ group\n                    if (open_indexes.Count == 0) {\n                \
    \        // Pop all open parens\n                        nesting.Clear();\n  \
    \                      open_indexes.Clear();\n                    } else {\n \
    \                       // Pop the open paren at the top of the open indexes queue\n\
    \                        int open_index = open_indexes.Pop();\n\n            \
    \            // Remove this open paren from the stack\n                      \
    \  stack.pop();\n                    }\n\n                    // If this group\
    \ has zero nesting level, we're done with the current group\n                \
    \    if (nesting.Count == 0) {\n                        // If this group is empty,\
    \ we're done with the parens group\n                        if (open_indexes.Count\
    \ == 0) {\n                            nesting.Clear();\n                    \
    \        open_indexes.Clear();\n                        } else {\n           \
    \                 open_indexes.Clear();\n                        }\n         \
    \           }\n                }\n                // Otherwise we are done with\
    \ the current group\n                else {\n                    // Pop this close\
    \ paren from the stack\n                    nesting.Pop();\n                }\n\
    \n                // If this close paren has already been seen, pop an open paren\
    \ from the stack\n                if (!seen_paren) {\n                    open_indexes.push(i);\n\
    \                } else {\n                    // \n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmplzmwvjmo.cs(94,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmplzmwvjmo.cs(100,2): error CS1513: } expected

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var stack = new Stack<long>();\n        var result\
    \ = new List<long>();\n        foreach (var ch in paren_string) {\n          \
    \  switch (ch) {\n                case '(':\n                    stack.Push(1L);\n\
    \                    break;\n                case ')':\n                    while\
    \ (stack.Peek() >= 0) {\n                        if (stack.Peek() == -1L) {\n\
    \                            throw new Exception(\"Invalid parentheses.\");\n\
    \                        }\n                        result.Add(stack.Pop());\n\
    \                    }\n                    stack.Pop();\n                   \
    \ break;\n                case '{':\n                    stack.Push(-1L);\n  \
    \                  break;\n                case '}':\n                    while\
    \ (stack.Peek() >= 0) {\n                        if (stack.Peek() == 1L) {\n \
    \                           throw new Exception(\"Invalid parentheses.\");\n \
    \                       }\n                        result.Add(stack.Pop());\n\
    \                    }\n                    stack.Pop();\n                   \
    \ break;\n                default:\n                    stack.Push(-1L);\n   \
    \                 break;\n            }\n        }\n        return result;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidOperationException: Stack empty.\n\
    \  at System.Collections.Generic.Stack`1[T].Peek () [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00090] in <d1df80f33e7c4219bf644ceafc49c606>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <d1df80f33e7c4219bf644ceafc49c606>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidOperationException: Stack\
    \ empty.\n  at System.Collections.Generic.Stack`1[T].Peek () [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem.ParseNestedParens (System.String paren_string) [0x00090] in <d1df80f33e7c4219bf644ceafc49c606>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <d1df80f33e7c4219bf644ceafc49c606>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) return null;\n        List<long>\
    \ max_level = new List<long>(paren_string.Length);\n        for (int i = 0; i\
    \ < paren_string.Length; i++) {\n            if (paren_string[i] == '(') {\n \
    \               max_level.Add(0);\n            } else if (paren_string[i] == ')')\
    \ {\n                long max_level = max_level.Max();\n                for (int\
    \ j = 0; j < max_level; j++) {\n                    if (paren_string[i + j + 1]\
    \ == '(') {\n                        max_level.Add(j + 1);\n                 \
    \   } else if (paren_string[i + j + 1] == ')') {\n                        max_level\
    \ = max_level.Max();\n                        break;\n                    }\n\
    \                }\n                for (int j = 0; j < max_level; j++) {\n  \
    \                  max_level.RemoveAt(j + 1);\n                }\n           \
    \ }\n        }\n        return max_level;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuj76h18a.cs(21,22): error CS0136: A local or parameter named ''max_level''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmpuj76h18a.cs(21,34): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpuj76h18a.cs(24,35): error CS1061: ''long'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''long'' could be found (are you missing a using directive or an assembly
    reference?)

    /tmp/tmpuj76h18a.cs(26,37): error CS1929: ''long'' does not contain a definition
    for ''Max'' and the best extension method overload ''ParallelEnumerable.Max(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    /tmp/tmpuj76h18a.cs(31,31): error CS1061: ''long'' does not contain a definition
    for ''RemoveAt'' and no accessible extension method ''RemoveAt'' accepting a first
    argument of type ''long'' could be found (are you missing a using directive or
    an assembly reference?)

    /tmp/tmpuj76h18a.cs(21,34): error CS0165: Use of unassigned local variable ''max_level''

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        int group = 0;\n        List<long> levels = new List<long>();\n\
    \        List<string> groups = new List<string>();\n        bool first = true;\n\
    \        long level = 0;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                if (first) {\n                    first\
    \ = false;\n                    level++;\n                    groups.Add(paren_string.Substring(0,\
    \ group));\n                    groups.Add(\"\");\n                } else {\n\
    \                    level++;\n                }\n            } else if (c ==\
    \ ')') {\n                level--;\n                groups.Add(levels[level]);\n\
    \                levels.RemoveAt(level);\n            } else if (char.IsWhiteSpace(c))\
    \ {\n                level++;\n                groups.Add(levels[level]);\n  \
    \              levels.RemoveAt(level);\n            } else {\n               \
    \ levels.RemoveAt(level);\n                groups.Add(paren_string.Substring(group,\
    \ (group - 1)));\n                group++;\n            }\n        }\n       \
    \ // Add the last group\n        groups.Add(levels[level]);\n        return groups;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7_vls83z.cs(32,35): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(33,33): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(36,35): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(37,33): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(39,33): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(45,27): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp7_vls83z.cs(46,16): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.List<string>''
    to ''System.Collections.Generic.List<long>''

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> list_of_levels = new List<long>();\n   \
    \     // Get the group of parentheses in the string\n        MatchCollection matches\
    \ = Regex.Matches(paren_string, \"\\\\(([^()]*)\\\\)\");\n        foreach (Match\
    \ match in matches) {\n            // Convert it to a long array and get the max\
    \ level of nesting for each group\n            List<long> group = Regex.Matches(match.Groups[1].Value,\
    \ @\"\\(.*?\\)\").Cast<Match>().Select(m => long.Parse(m.Groups[1].Value)).ToList();\n\
    \            long max_level = group.Max();\n            list_of_levels.Add(max_level);\n\
    \        }\n        return list_of_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8lz955n9.cs(17,9): error CS0246: The type or namespace name ''MatchCollection''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp8lz955n9.cs(17,35): error CS0103: The name ''Regex'' does not exist in
    the current context

    /tmp/tmp8lz955n9.cs(18,18): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp8lz955n9.cs(20,32): error CS0103: The name ''Regex'' does not exist in
    the current context

    /tmp/tmp8lz955n9.cs(20,86): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialize result list\n        var result = new\
    \ List<long>();\n        // Add all characters to list\n        List<char> temp_list\
    \ = new List<char>();\n        temp_list.AddRange(paren_string.ToCharArray());\n\
    \        bool in_parens = false;\n        long level = 0;\n        int i = 0;\n\
    \        // Process string and increment level if start in parentheses.\n    \
    \    while (i < temp_list.Count) {\n            if (in_parens) {\n           \
    \     level++;\n            }\n            switch (temp_list[i]) {\n         \
    \       case '(':\n                    in_parens = true;\n                   \
    \ break;\n                case ')':\n                    in_parens = false;\n\
    \                    break;\n                case ' ':\n                    //\
    \ Do nothing (white space)\n                    in_parens = false;\n         \
    \           break;\n                case ',':\n                    result.Add(level);\n\
    \                    level = 1;\n                    break;\n                default:\n\
    \                    in_parens = false;\n                    level++;\n      \
    \              break;\n            }\n            i++;\n        }\n        //\
    \ If last character is a comma add it.\n        if (temp_list[i] != ',')\n   \
    \         level++;\n        result.Add(level);\n        return result;\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x000a2] in <7187b82a495743df8e365be6460426e6>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <7187b82a495743df8e365be6460426e6>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x000a2] in <7187b82a495743df8e365be6460426e6>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <7187b82a495743df8e365be6460426e6>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        char[] opening_paren = new char[]{'('};\n        char[]\
    \ closing_paren = new char[]{')'};\n        long[] results = new long[0];\n  \
    \      int count_opening_parens = 0;\n        int count_closing_parens = 0;\n\
    \        foreach (char opening_bracket in paren_string) {\n            count_opening_parens++;\n\
    \            if (opening_bracket == opening_paren[count_opening_parens - 1]) {\n\
    \                count_opening_parens--;\n            }\n            else if (opening_bracket\
    \ == closing_paren[count_closing_parens - 1]) {\n                count_closing_parens--;\n\
    \            }\n            else {\n                break;\n            }\n  \
    \      }\n        if (count_opening_parens == count_closing_parens + 1) {\n  \
    \          results = new long[]{1L};\n        }\n        else {\n            results\
    \ = new long[count_opening_parens+1];\n            for (int i = 0; i <= count_opening_parens;\
    \ i++) {\n                results[i] = 0L;\n            }\n            int count\
    \ = 1;\n            for (int i = 0; i <= count_closing_parens; i++) {\n      \
    \          if (opening_paren[i] == closing_paren[i]) {\n                    count++;\n\
    \                }\n                else {\n                    break;\n     \
    \           }\n            }\n            for (int i = 0; i < count_opening_parens;\
    \ i++) {\n                long current_val = results[i];\n                results[i]\
    \ = Math.Max(current_val, count * (long)i);\n            }\n        }\n      \
    \  return new List<long>(results);\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x00055] in <7891b8bd6c104ba69e38aa05ed9a9775>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <7891b8bd6c104ba69e38aa05ed9a9775>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x00055]\
    \ in <7891b8bd6c104ba69e38aa05ed9a9775>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <7891b8bd6c104ba69e38aa05ed9a9775>:0 \n"
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Your code goes here\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_lusl9x6.cs(14,30): error CS0161: ''Problem.ParseNestedParens(string)'':
    not all code paths return a value

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) {\n            throw new\
    \ ArgumentNullException(\"paren_string\", \"Null argument to ParseNestedParens\"\
    );\n        }\n\n        var groups = new Stack<string>();\n\n        foreach\
    \ (char c in paren_string) {\n            switch (c) {\n                case '(':\n\
    \                    // Found a new group\n                    groups.Push(string.Empty);\n\
    \                    break;\n                case ')':\n                    //\
    \ Pop the previous group\n                    var current_group = groups.Count\
    \ > 0 ? groups.Pop() : null;\n                    // If this group has any content,\
    \ add to the count\n                    if (current_group != null && !string.IsNullOrEmpty(current_group))\
    \ {\n                        groups.Push(string.Join(\"\", Enumerable.Repeat(current_group,\
    \ 1)));\n                    }\n                    break;\n                case\
    \ ' ':\n                    // Push this group to the stack\n                \
    \    groups.Push(string.Empty);\n                    break;\n                default:\n\
    \                    // If this char is a new letter\n                    groups.Push(c);\n\
    \                    break;\n            }\n        }\n\n        // If no groups\
    \ were found, return an empty list\n        if (groups.Count <= 0) {\n       \
    \     return new List<long>();\n        }\n\n        // Get the deepest count\
    \ from the stack\n        var max_count = groups.Pop();\n\n        // If the last\
    \ group on the stack is a single char, then remove it\n        // since it's not\
    \ counting any levels of nesting.\n        if (max_count == string.Empty) {\n\
    \            max_count = null;\n        }\n\n        // Return the group count\n\
    \        return new List<long>(Enumerable.Repeat(max_count, 1));\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpu2pv3gfh.cs(41,33): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmpu2pv3gfh.cs(61,31): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.IEnumerable<string>''
    to ''int''

    '
  timestamp: 1659976355
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> list_of_longs = new List<long>();\n    \
    \    string text = paren_string;\n        bool has_opened_paren = false;\n   \
    \     char open_char = '(';\n        int number_of_open = 0;\n        while (true)\
    \ {\n            int next_open_char = text.IndexOf(open_char, 0);\n          \
    \  if (next_open_char < 0) {\n                list_of_longs.Add(0);\n        \
    \        break;\n            }\n            char open_char = open_char;\n    \
    \        open_char = text[next_open_char];\n            number_of_open++;\n  \
    \          text = text.Remove(next_open_char + 1);\n            bool has_closing_char\
    \ = false;\n            int next_closing_char = text.IndexOf(')');\n         \
    \   if (next_closing_char > 0) {\n                has_closing_char = true;\n \
    \               open_char = text[next_closing_char];\n            }\n        \
    \    text = text.Remove(next_closing_char + 1);\n            long open_long_val\
    \ = 0;\n            long close_long_val = 0;\n            try {\n            \
    \    if (open_char == ')') {\n                    if (has_closing_char) {\n  \
    \                      close_long_val = text.ToInt64();\n                    \
    \    text = text.Remove(0, close_long_val.ToString().Length);\n              \
    \      } else {\n                        open_long_val = text.ToInt64();\n   \
    \                     text = text.Remove(0, open_long_val.ToString().Length);\n\
    \                    }\n                }\n            } catch (OverflowException)\
    \ {\n                // TODO: Handle this case appropriately\n            }\n\
    \            list_of_longs.Add(open_long_val);\n            if (!has_closing_char)\
    \ {\n                list_of_longs.Add(number_of_open);\n            }\n     \
    \   }\n        long max_number_of_open = list_of_longs.Max();\n        list_of_longs.Remove(max_number_of_open);\n\
    \        return list_of_longs;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxyqavhk5.cs(21,47): error CS0841: Cannot use local variable ''open_char''
    before it is declared

    /tmp/tmpxyqavhk5.cs(26,18): error CS0136: A local or parameter named ''open_char''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmpxyqavhk5.cs(42,47): error CS1061: ''string'' does not contain a definition
    for ''ToInt64'' and no accessible extension method ''ToInt64'' accepting a first
    argument of type ''string'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpxyqavhk5.cs(45,46): error CS1061: ''string'' does not contain a definition
    for ''ToInt64'' and no accessible extension method ''ToInt64'' accepting a first
    argument of type ''string'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpxyqavhk5.cs(17,14): warning CS0219: The variable ''has_opened_paren''
    is assigned but its value is never used

    /tmp/tmpxyqavhk5.cs(18,14): warning CS0219: The variable ''open_char'' is assigned
    but its value is never used

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string token_string = paren_string;\n        List<long>\
    \ nested_level = new List<long>();\n        List<long> current_level_with_parens\
    \ = new List<long>();\n        string token_with_parens = string.Empty;\n    \
    \    bool open_paren = false;\n        bool close_paren = false;\n        bool\
    \ opening_parantheses = false;\n        bool opening_square_braces = false;\n\
    \        int i = 0;\n        while (i < token_string.Length) {\n            char\
    \ token = token_string[i];\n            if (token == '(') {\n                if\
    \ (!opening_parantheses) {\n                    nested_level.Add(1L);\n      \
    \          }\n                if (open_paren) {\n                    nested_level[nested_level.Count\
    \ - 2] += 1;\n                } else {\n                    nested_level.Add(1L);\n\
    \                }\n                opening_parantheses = true;\n            \
    \    open_paren = true;\n            } else if (token == ')') {\n            \
    \    if (!opening_square_braces) {\n                    nested_level.Add(1L);\n\
    \                }\n                if (open_paren) {\n                    nested_level[nested_level.Count\
    \ - 2] += 1;\n                } else {\n                    nested_level.Add(1L);\n\
    \                }\n                opening_square_braces = true;\n          \
    \      open_paren = false;\n            } else if (token == '[') {\n         \
    \       token_with_parens += '[';\n            } else if (token == ']') {\n  \
    \              token_with_parens += ']';\n            } else if (token == '{')\
    \ {\n                token_with_parens += '{';\n            } else if (token ==\
    \ '}') {\n                token_with_parens += '}';\n            }\n         \
    \   i++;\n        }\n        if (nested_level.Count > 0) {\n            nested_level\
    \ = nested_level.OrderByDescending(x => x).ToList();\n        }\n        return\
    \ nested_level;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <84f8ee09180548d58bccc0b7832be106>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <84f8ee09180548d58bccc0b7832be106>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Recursion base case\n        if (paren_string.Length\
    \ == 1) {\n            return new List<long>(new long[] {0});\n        }\n\n \
    \       // Recursion step for odd number of characters\n        int n_groups =\
    \ paren_string.Length / 2; // number of characters in each group\n        List<long>\
    \ current_group = new List<long>(new long[n_groups]); // array of longs (each\
    \ of length n_groups)\n        List<long> current_group_remainder = new List<long>(new\
    \ long[n_groups]); // array of longs (each of length n_groups)\n        int n_current_group\
    \ = n_groups; int n_current_group_remainder = n_groups;\n        for (int i =\
    \ 0; i < n_groups; i++) {\n            // get character from both sides of each\
    \ group\n            int left = paren_string[n_current_group * 2 - i]; // characters\
    \ in group i\n            int right = paren_string[n_current_group * 2 - i + 1];\
    \ // characters in group i + 1\n\n            // get the characters one by one\
    \ from current group until we hit left or right closing brackets\n           \
    \ bool left_found = false;\n            while (left != '(' && left != ')') {\n\
    \                left += paren_string[n_current_group * 2 - n_current_group_remainder\
    \ * 2 - i];\n                n_current_group_remainder++;\n                left_found\
    \ = true;\n            }\n            bool right_found = false;\n            while\
    \ (right != '(' && right != ')') {\n                right -= paren_string[n_current_group\
    \ * 2 - n_current_group_remainder * 2 - i + 1];\n                n_current_group_remainder--;\n\
    \                right_found = true;\n            }\n            current_group[i]\
    \ = left_found ? left - '(' : right - ')';\n            current_group_remainder[i]\
    \ = left_found ? right - ')' : left - '(';\n        }\n\n        List<long> deepest_level\
    \ = new List<long>(new long[n_groups]);\n        for (int i = 0; i < n_groups;\
    \ i++) {\n            deepest_level[i] = Math.Max(deepest_level[i - 1] + current_group_remainder[i],\
    \ current_group[i]);\n        }\n\n        return deepest_level;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x00060] in <682a1b685ca5490daf7b48fb0b0810d8>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <682a1b685ca5490daf7b48fb0b0810d8>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x00060]\
    \ in <682a1b685ca5490daf7b48fb0b0810d8>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <682a1b685ca5490daf7b48fb0b0810d8>:0 \n"
  stdout: ''
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var parsed_result = new List<long>();\n        // \"\
    The deepest level of nesting of parentheses is \"\n        var max_depth = 0;\n\
    \        foreach (var group in paren_string.Split(' '))\n        {\n         \
    \   var depth = 0;\n            bool nested_group = false;\n            foreach\
    \ (var c in group)\n            {\n                if (c == '(')\n           \
    \     {\n                    nested_group = true;\n                    depth++;\n\
    \                }\n                else if (c == ')')\n                {\n  \
    \                  nested_group = false;\n                    depth--;\n     \
    \           }\n                if (nested_group == true)\n                {\n\
    \                    depth++;\n                }\n            }\n            if\
    \ (depth > max_depth)\n            {\n                max_depth = depth;\n   \
    \             parsed_result.Add(depth);\n            }\n        }\n        return\
    \ parsed_result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <4733ee2c7ac84bb0b7b38e0eefba12d3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <4733ee2c7ac84bb0b7b38e0eefba12d3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // The stack of open parens\n        Stack<long> parenStack\
    \ = new Stack<long>();\n        // The stack of closes parens\n        Stack<long>\
    \ closedParenStack = new Stack<long>();\n        // The index of the deepest open\
    \ parens\n        long openParenIndex = 0;\n        // The index of the deepest\
    \ close parens\n        long closeParenIndex = 0;\n        // The deepest level\
    \ of nesting\n        long maxNesting = 0;\n        // Iterate through parens\n\
    \        for (int i = 0; i < paren_string.Length; i++) {\n            // A paren\
    \ can either open or close\n            long parenStatus = paren_string[i] ==\
    \ '(' ? 1 : 0;\n            // Add this index to the stack\n            parenStack.Push(i);\n\
    \            // If we are in an open paren, keep track of its index\n        \
    \    if (parenStatus == 1) {\n                openParenIndex = i;\n          \
    \      // If this is a close paren, add it to the stack\n                if (paren_string[i]\
    \ == ')') {\n                    closedParenStack.Push(i);\n                }\n\
    \            }\n            // If we are in a close paren, keep track of its index\n\
    \            else if (parenStatus == 0) {\n                closeParenIndex = i;\n\
    \                // If this is an open paren, add it to the stack\n          \
    \      if (paren_string[i] == '(') {\n                    openParenIndex = i;\n\
    \                    // The stack will always be empty when this happens, because\
    \ a closed paren is always an open paren\n                    maxNesting = Math.Max(maxNesting,\
    \ openParenIndex - closedParenIndex + 1);\n                }\n            }\n\
    \            // If the index is unchanged or we've reached the end of the paren\
    \ string then this is a nested paren\n            else if (i == paren_string.Length\
    \ - 1) {\n                maxNesting = Math.Max(maxNesting, openParenIndex - closedParenIndex);\n\
    \            }\n        }\n        // Return the deepest level of nesting\n  \
    \      return new List<long>(new long[] { maxNesting });\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3twf3jqm.cs(46,72): error CS0103: The name ''closedParenIndex'' does not
    exist in the current context

    /tmp/tmp3twf3jqm.cs(51,68): error CS0103: The name ''closedParenIndex'' does not
    exist in the current context

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == \"\") return new List<long>(new\
    \ long[]{0L});\n        int index = 0;\n        List<long> levels = new List<long>(new\
    \ long[paren_string.Length]);\n        bool has_braces = false;\n        bool\
    \ has_closing_brace = false;\n        int level = 0;\n        while (index < paren_string.Length)\
    \ {\n            if (paren_string[index] == '(') {\n                level++;\n\
    \            }\n            if (paren_string[index] == ')') {\n              \
    \  level--;\n            }\n            if (level == 0) {\n                levels[index]\
    \ = level;\n                index++;\n            }\n            if (level > 0)\
    \ {\n                levels[index] = level;\n                index++;\n      \
    \      }\n            if (paren_string[index] == '(') {\n                has_braces\
    \ = true;\n                index++;\n            }\n            if (paren_string[index]\
    \ == ')') {\n                has_closing_brace = true;\n                index++;\n\
    \            }\n            if (paren_string[index] == ' ' && has_braces && has_closing_brace)\
    \ {\n                index++;\n            }\n            if (paren_string[index]\
    \ == ' ' && !has_braces && !has_closing_brace) {\n                index++;\n \
    \           }\n        }\n        return levels;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x000ae] in <e27777150d80499199c386ed148e7c0f>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <e27777150d80499199c386ed148e7c0f>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x000ae]\
    \ in <e27777150d80499199c386ed148e7c0f>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <e27777150d80499199c386ed148e7c0f>:0 \n"
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string str = paren_string;\n\n        char[] char_array\
    \ = new char[str.Length];\n        for (int i = 0; i < str.Length; i++) {\n  \
    \          char_array[i] = str[i];\n        }\n\n        List<long> list = new\
    \ List<long>();\n        // Use stack to parse parenthesis.\n        Stack<char>\
    \ stack = new Stack<char>();\n\n        // Push left parenthesis\n        stack.push('(');\n\
    \n        // Add level of nesting when encountered left parenthesis.\n       \
    \ list.Add(0L);\n        while (stack.Count > 0) {\n            char curr = char_array[stack.Count\
    \ - 1];\n            if (curr == ')') {\n                list = (from p in list\
    \ select p.Value * -1L).ToList();\n                list.Add(list.Last());\n  \
    \              break;\n            } else if (curr == '(') {\n               \
    \ // Add the previous level of nesting.\n                list.Add(list.Last());\n\
    \                list.RemoveAt(list.Count - 1);\n                // Decrease the\
    \ level of nesting.\n                stack.Pop();\n            } else {\n    \
    \            stack.Pop();\n            }\n        }\n        return list;\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5guw7w1s.cs(27,15): error CS1061: ''Stack<char>'' does not contain a definition
    for ''push'' and no accessible extension method ''push'' accepting a first argument
    of type ''Stack<char>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp5guw7w1s.cs(34,49): error CS1061: ''long'' does not contain a definition
    for ''Value'' and no accessible extension method ''Value'' accepting a first argument
    of type ''long'' could be found (are you missing a using directive or an assembly
    reference?)

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested_levels = new List<long>();\n    \
    \    List<long> current_level = new List<long>();\n        long prev_depth = -1;\n\
    \n        foreach (string paren in paren_string.Split(new char[] { '(', ')' },\
    \ StringSplitOptions.RemoveEmptyEntries)) {\n            if (paren.StartsWith(\"\
    (\")) {\n                current_level.Add(0);\n            }\n            else\
    \ {\n                current_level[current_level.Count - 1] += 1;\n          \
    \  }\n            if (current_level[current_level.Count - 1] == prev_depth + 1)\
    \ {\n                prev_depth = current_level.Count - 1;\n            }\n  \
    \          prev_depth = current_level.Count - 1;\n            if (current_level.Count\
    \ > nested_levels.Count) {\n                nested_levels = current_level;\n \
    \           }\n        }\n        return nested_levels;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Index was out\
    \ of range. Must be non-negative and less than the size of the collection.\nParameter\
    \ name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00065] in <55c0c8d068c242ada38bb8abee0d8c29>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <55c0c8d068c242ada38bb8abee0d8c29>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Index\
    \ was out of range. Must be non-negative and less than the size of the collection.\n\
    Parameter name: index\n  at System.Collections.Generic.List`1[T].get_Item (System.Int32\
    \ index) [0x00009] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00065] in <55c0c8d068c242ada38bb8abee0d8c29>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <55c0c8d068c242ada38bb8abee0d8c29>:0\
    \ \n"
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string temp = \"\";\n        List<long> res = new List<long>();\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <\
    \ paren_string.Length; i++) {\n            if (paren_string[i] == '(') {\n   \
    \             sb.Append(\"(\");\n                temp = \"\";\n              \
    \  while (paren_string[i] != ')') {\n                    sb.Append(paren_string[i]);\n\
    \                    i++;\n                }\n                i++;\n         \
    \       temp += \")\";\n                res.Add(GetDepth(sb.ToString()));\n  \
    \              sb.Clear();\n            }\n            else {\n              \
    \  temp += paren_string[i];\n            }\n        }\n        return res;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwg576cvc.cs(28,25): error CS0103: The name ''GetDepth'' does not exist
    in the current context

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        HashSet<Character> opening_set = new HashSet<Character>();\n\
    \        HashSet<Character> closing_set = new HashSet<Character>();\n        List<long>\
    \ levels = new List<long>();\n        List<long> nested_levels = new List<long>();\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             opening_set.Add(c);\n            } else if (c == ')') {\n      \
    \          closing_set.Add(c);\n            } else {\n                nested_levels.Add(ParseNestedParens(paren_string.Substring(0,\
    \ paren_string.IndexOf(c) + 1)));\n            }\n        }\n        foreach (char\
    \ c in opening_set) {\n            if (nested_levels.Count == 0) {\n         \
    \       levels.Add(1L);\n            } else {\n                levels.Add(nested_levels.Max()\
    \ + 1L);\n            }\n        }\n        foreach (char c in closing_set) {\n\
    \            if (nested_levels.Count == 0) {\n                levels.Add(-1L);\n\
    \            } else {\n                levels.Remove(nested_levels.Last());\n\
    \            }\n        }\n        return new List<long>(levels);\n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0_k510i8.cs(15,17): error CS0246: The type or namespace name ''Character''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp0_k510i8.cs(15,54): error CS0246: The type or namespace name ''Character''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp0_k510i8.cs(16,17): error CS0246: The type or namespace name ''Character''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp0_k510i8.cs(16,54): error CS0246: The type or namespace name ''Character''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmp0_k510i8.cs(21,33): error CS1503: Argument 1: cannot convert from ''char''
    to ''Character''

    /tmp/tmp0_k510i8.cs(23,33): error CS1503: Argument 1: cannot convert from ''char''
    to ''Character''

    /tmp/tmp0_k510i8.cs(25,35): error CS1503: Argument 1: cannot convert from ''System.Collections.Generic.List<long>''
    to ''long''

    /tmp/tmp0_k510i8.cs(28,9): error CS0030: Cannot convert type ''Character'' to
    ''char''

    /tmp/tmp0_k510i8.cs(35,9): error CS0030: Cannot convert type ''Character'' to
    ''char''

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialize a new char array to store the string\n\
    \        char[] charArray = paren_string.ToCharArray();\n\n        // Initialize\
    \ a new list to store result\n        List<long> result = new List<long>();\n\n\
    \        // Initialize a stack variable for storing deepest level of nesting.\n\
    \        long stack = 0;\n\n        // Iterate through the string\n        for\
    \ (int i = 0; i < charArray.Length; i++) {\n            // If the current character\
    \ is a left parenthesis '('\n            if (charArray[i] == '(') {\n        \
    \        // If the stack is 0 then just increment the stack and store it.\n  \
    \              if (stack == 0) {\n                    stack++;\n             \
    \       result.Add(stack); // add the current stack to result list\n         \
    \           continue;\n                }\n                // If the stack is 1\
    \ then pop the top stack value and subtract 1 from it.\n                else if\
    \ (stack == 1) {\n                    stack--;\n                    continue;\n\
    \                }\n                // If the stack is 2 then pop the top stack\
    \ value and subtract 1 from it and add the value to result.\n                else\
    \ if (stack == 2) {\n                    stack -= 2;\n                    result.Add(stack);\n\
    \                    continue;\n                }\n                // If the stack\
    \ is 3 then pop the top stack value, subtract 1 from it, subtract the stack value,\
    \ and add it to result.\n                else if (stack == 3) {\n            \
    \        stack -= 3;\n                    result.Add(stack);\n               \
    \     continue;\n                }\n                // If the stack is 4 then\
    \ pop the top stack value, subtract 1 from it, subtract the stack value, subtract\
    \ the stack value, and add it to result.\n                else if (stack == 4)\
    \ {\n                    stack -= 4;\n                    result.Add(stack);\n\
    \                    continue;\n                }\n                // If the stack\
    \ is 5 then pop the top stack value, subtract 1 from it, subtract the stack value,\
    \ subtract the stack value, subtract the stack value, and add it to result.\n\
    \                else if (stack == 5) {\n                    stack -= 5;\n   \
    \                 result.Add(stack);\n                    continue;\n        \
    \        }\n                // If the stack is 6 then pop the top stack value,\
    \ subtract 1 from it, subtract the stack value, subtract the stack value, subtract\
    \ the stack value, subtract the stack value, and add it to result.\n         \
    \       else if (stack == 6) {\n                    stack -= 6;\n            \
    \        result.Add(stack);\n                    continue;\n                }\n\
    \                // If the stack is 7 then pop the top stack value, subtract 1\
    \ from it, subtract the stack value, subtract the stack value, subtract the stack\
    \ value, subtract the stack value, subtract the stack value, and add it to result.\n\
    \                else if (stack == 7) {\n                    stack -= 7;\n   \
    \                 result.Add(stack);\n                    continue;\n        \
    \        }\n                // If the stack is 8 then pop the top stack value,\
    \ subtract 1 from it, subtract the stack value, subtract the stack value, subtract\
    \ the stack value, subtract the stack value, subtract the stack value, subtract\
    \ the \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzf740yev.cs(77,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpzf740yev.cs(83,2): error CS1513: } expected

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null)\n            throw new ArgumentNullException();\n\
    \        List<long> result = new List<long>();\n        Stack<long> stack = new\
    \ Stack<long>();\n        Stack<char> stackChar = new Stack<char>();\n       \
    \ for (int i = 0; i < paren_string.Length; i++) {\n            char c = paren_string[i];\n\
    \            if (c == '(') {\n                stackChar.Push(c);\n           \
    \     stack.Push(0);\n            } else if (c == ')') {\n                if (!stackChar.IsEmpty)\
    \ {\n                    long new_top = stack.Pop();\n                    if (new_top\
    \ == 0)\n                        throw new FormatException(\"Mismatched parenthesis\"\
    );\n                    stack.Add(new_top);\n                } else {\n      \
    \              throw new FormatException(\"Unbalanced parenthesis\");\n      \
    \          }\n            } else if (c == ' ') {\n                if (stackChar.Count\
    \ > 0 && !stackChar.Peek() == '(') {\n                    result.Add(stack.Pop());\n\
    \                } else if (stack.Count > 0) {\n                    result.Add(stack.Pop());\n\
    \                } else {\n                    result.Add(0);\n              \
    \  }\n                stackChar.Clear();\n            } else {\n             \
    \   if (stackChar.Count > 0) {\n                    stackChar.Push(c);\n     \
    \           } else {\n                    stack.Push(c);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxaalsyvd.cs(26,32): error CS1061: ''Stack<char>'' does not contain a definition
    for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting a first
    argument of type ''Stack<char>'' could be found (are you missing a using directive
    or an assembly reference?)

    /tmp/tmpxaalsyvd.cs(30,27): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpxaalsyvd.cs(35,44): error CS0023: Operator ''!'' cannot be applied to
    operand of type ''char''

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var stack = new Stack<long>();\n        foreach (var\
    \ paren in paren_string.Split(' '))\n        {\n            Debug.WriteLine(\"\
    paranthesis: \" + paren);\n            if (paren == \"(\")\n            {\n  \
    \              stack.Push(1);\n            }\n            else if (paren == \"\
    )\")\n            {\n                var popped = stack.Pop();\n             \
    \   Debug.WriteLine(\"pop size: \" + stack.Pop());\n                Debug.WriteLine(\"\
    pop value: \" + popped);\n                stack.Push(popped + 1);\n          \
    \  }\n            else if (paren == \"(\")\n            {\n                stack.Push(1);\n\
    \            }\n            else if (paren == \")\")\n            {\n        \
    \        var popped = stack.Pop();\n                Debug.WriteLine(\"pop size:\
    \ \" + stack.Pop());\n                Debug.WriteLine(\"pop value: \" + popped);\n\
    \                stack.Push(popped + 1);\n            }\n            else if (paren\
    \ == \"{\")\n            {\n                stack.Push(1L);\n            }\n \
    \           else if (paren == \"}\")\n            {\n                var popped\
    \ = stack.Pop();\n                Debug.WriteLine(\"pop size: \" + stack.Pop());\n\
    \                Debug.WriteLine(\"pop value: \" + popped);\n                stack.Push(popped\
    \ + 1);\n            }\n            else if (paren == \"[\")\n            {\n\
    \                stack.Push(1L);\n            }\n            else if (paren ==\
    \ \"]\")\n            {\n                var popped = stack.Pop();\n         \
    \       Debug.WriteLine(\"pop size: \" + stack.Pop());\n                Debug.WriteLine(\"\
    pop value: \" + popped);\n                stack.Push(popped + 1);\n          \
    \  }\n            else if (paren == \"[\")\n            {\n                stack.Push(1L);\n\
    \            }\n            else if (paren == \"]\")\n            {\n        \
    \        var popped = stack.Pop();\n                Debug.WriteLine(\"pop size:\
    \ \" + stack.Pop());\n                Debug.WriteLine(\"pop value: \" + popped);\n\
    \                stack.Push(popped + 1);\n            }\n            else\n  \
    \          {\n                Debug.WriteLine(\"else: \" + paren);\n         \
    \       stack.Push(1);\n            }\n        }\n        return stack.Peek().ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw4z4iqrp.cs(80,29): error CS1061: ''long'' does not contain a definition
    for ''ToList'' and no accessible extension method ''ToList'' accepting a first
    argument of type ''long'' could be found (are you missing a using directive or
    an assembly reference?)

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // The most parentheses level encountered so far.\n\
    \        // -1 is a sentinel value as -1 is not a valid parenthesis level.\n \
    \       long max_level = (long) -1;\n        // A stack to keep track of open\
    \ parentheses levels.\n        Stack<long> parentheses_levels = new Stack<long>();\n\
    \        // A string buffer for storing substrings, for which parentheses levels\
    \ are calculated. \n        StringBuilder stringBuilder = new StringBuilder();\n\
    \        // A string to represent the input string. \n        string input_string\
    \ = null;\n        // An integer to keep track of the count of consecutive parentheses\
    \ in the input string.\n        long consecutive_parentheses_count = 0;\n    \
    \    // An integer to keep track of consecutive parentheses in the input string.\n\
    \        long consecutive_parentheses = 0;\n        foreach (char character in\
    \ paren_string) {\n            // Keep track of consecutive parentheses in the\
    \ input string by counting them.\n            // The parentheses_count is initialized\
    \ to 0 at the beginning, because it might be incremented \n            // by an\
    \ open parentheses level later in the code.\n            consecutive_parentheses_count\
    \ += character == '(' ? 1 : 0;\n            // If the parentheses_count is equal\
    \ to the consecutive_parentheses_count, then we encounter a \n            // parentheses\
    \ level here.\n            // If the parentheses_count is less than the consecutive_parentheses_count,\
    \ then we encounter a \n            // nested parentheses level here.\n      \
    \      if (consecutive_parentheses_count == consecutive_parentheses) {\n     \
    \           parentheses_levels.Push(max_level);\n                consecutive_parentheses\
    \ = 0;\n            }\n            // If the character is a closing parentheses\
    \ characters, then we pop out the stack until we reach a \n            // open\
    \ parentheses level. \n            // The parentheses level is then set to the\
    \ maximum level of parentheses encountered so far.\n            // We reset the\
    \ parentheses_levels to an empty stack. \n            if (character == ')') {\n\
    \                while (parentheses_levels.Count > 0) {\n                    max_level\
    \ = parentheses_levels[parentheses_levels.Count - 1];\n                    parentheses_levels.RemoveAt(parentheses_levels.Count\
    \ - 1);\n                }\n                parentheses_levels = new Stack<long>();\n\
    \            }\n            // If the character is space, then we append it to\
    \ stringBuilder and continue parsing the input \n            // string.\n    \
    \        if (character == ' ') {\n                stringBuilder.Append(character);\n\
    \                continue;\n            }\n            // Otherwise, we append\
    \ the character to the string buffer.\n            stringBuilder.Append(character);\n\
    \            // Add the character to the consecutive_parentheses counter\n   \
    \         consecutive_parentheses += character == '(' ? 1 : 0;\n        }\n  \
    \      // The input_string is the string representing the input string with spaces\
    \ appended to the end \n        // to represent empty parentheses levels. \n \
    \       input_string = stringBuilder.\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesq81oow.cs(65,38): error CS1001: Identifier expected

    /tmp/tmpesq81oow.cs(65,38): error CS1002: ; expected

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var nested_parens = new List<long>();\n        var\
    \ nesting_levels = new List<long>();\n        var nesting_level = 0;\n       \
    \ var paren_length = 0;\n        foreach (var c in paren_string) {\n         \
    \   if (c == '(') {\n                paren_length++;\n                nesting_level++;\n\
    \            }\n            if (c == ')') {\n                nesting_level--;\n\
    \                if (nesting_level == 0) {\n                    nested_parens.Add(paren_length);\n\
    \                }\n            }\n            if (nesting_level == 0 && paren_length\
    \ == 0) {\n                nested_parens.Add(0);\n            }\n        }\n \
    \       return new List<long>(nested_parens);\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d2d0f2e92057426280c0b8dd5364d8bf>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d2d0f2e92057426280c0b8dd5364d8bf>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var stringBuilder = new StringBuilder();\n        using\
    \ (var stream = GenerateStream(paren_string)) {\n            while (!stream.EndOfStream)\
    \ {\n                var ch = stream.Read();\n                if (ch == '(') {\n\
    \                    if (stringBuilder.Length > 0) {\n                       \
    \ stringBuilder.Append(')');\n                        yield return new long[]\
    \ {long.Parse(stringBuilder.ToString())};\n                    }\n           \
    \     }\n                else if (ch == ')') {\n                    if (stringBuilder.Length\
    \ > 0) {\n                        stringBuilder.Append('(');\n               \
    \         yield return new long[] {long.Parse(stringBuilder.ToString())};\n  \
    \                  }\n                }\n                else {\n            \
    \        stringBuilder.Append(ch);\n                }\n            }\n       \
    \ }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp76vai5ae.cs(14,30): error CS1624: The body of ''Problem.ParseNestedParens(string)''
    cannot be an iterator block because ''List<long>'' is not an iterator interface
    type

    /tmp/tmp76vai5ae.cs(16,29): error CS0103: The name ''GenerateStream'' does not
    exist in the current context

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null || paren_string.Length ==\
    \ 0) {\n            return new List<long>();\n        }\n        var stack = new\
    \ Stack<long>();\n        List<long> depths = new List<long>();\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                stack.Push(1);\n\
    \            } else if (c == ')') {\n                var depth = stack.Pop();\n\
    \                stack.Push(depth + 1);\n                depths.Add(depth);\n\
    \            } else {\n                stack.Pop();\n            }\n        }\n\
    \        return new List<long>(depths);\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d534d061d81d45ccbc82623c341b7cf5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <d534d061d81d45ccbc82623c341b7cf5>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Create a set of all unique chars.\n        HashSet<char>\
    \ unique_chars = new HashSet<char>();\n        foreach (char c in paren_string)\
    \ {\n            if (!unique_chars.Contains(c)) {\n                unique_chars.Add(c);\n\
    \            }\n        }\n        Debug.Assert(unique_chars.Count == paren_string.Length);\n\
    \        // Now create the list of possible parens\n        List<long> levels_of_nesting\
    \ = new List<long>();\n        levels_of_nesting.Add(0);\n        foreach (char\
    \ c in unique_chars) {\n            levels_of_nesting.Add(1);\n            foreach\
    \ (char c1 in unique_chars) {\n                if (c == c1) {\n              \
    \      levels_of_nesting.Add(1);\n                    foreach (char c2 in unique_chars)\
    \ {\n                        if (c == c2 && c1 == c2) {\n                    \
    \        levels_of_nesting.Add(1);\n                            foreach (char\
    \ c3 in unique_chars) {\n                                if (c == c3 && c1 ==\
    \ c2 && c2 == c3) {\n                                    levels_of_nesting.Add(1);\n\
    \                                    foreach (char c4 in unique_chars) {\n   \
    \                                     if (c == c4 && c1 == c2 && c2 == c3 && c3\
    \ == c4) {\n                                            levels_of_nesting.Add(1);\n\
    \                                        }\n                                 \
    \   }\n                                }\n                            }\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n        Debug.Assert(unique_chars.Count == levels_of_nesting.Count);\n\
    \        return levels_of_nesting;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.ParseNestedParens (System.String\
    \ paren_string) [0x00000] in <1df676da5ae043939ce444f2e3a390b7>:0 \n  at Problem.Main\
    \ (System.String[] args) [0x00000] in <1df676da5ae043939ce444f2e3a390b7>:0 \n\
    Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,\
    \ System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.ParseNestedParens (System.String\
    \ paren_string) [0x00000] in <1df676da5ae043939ce444f2e3a390b7>:0 \n  at Problem.Main\
    \ (System.String[] args) [0x00000] in <1df676da5ae043939ce444f2e3a390b7>:0 \n\
    Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,\
    \ System.String detailMessage) [0x00000] in"
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested_levels = new List<long>();\n    \
    \    string stack_string;\n        int stack_level;\n        for (int i = 0; i\
    \ < paren_string.Length; i++) {\n            if (paren_string[i] == '(') {\n \
    \               if (stack_string == null) {\n                    stack_string\
    \ = paren_string;\n                    stack_level = 1;\n                } else\
    \ {\n                    if (stack_level > 1) {\n                        nested_levels.Add(stack_level);\n\
    \                    }\n                    stack_level++;\n                }\n\
    \            } else if (paren_string[i] == ')') {\n                if (stack_string\
    \ != null && stack_level > 0) {\n                    stack_level--;\n        \
    \        } else {\n                    stack_string = null;\n                \
    \    stack_level = 1;\n                }\n            }\n        }\n        if\
    \ (stack_string != null && stack_level > 0) {\n            nested_levels.Add(stack_level);\n\
    \        }\n        return nested_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_ekix4ox.cs(20,21): error CS0165: Use of unassigned local variable ''stack_string''

    /tmp/tmp_ekix4ox.cs(24,25): error CS0165: Use of unassigned local variable ''stack_level''

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        long max_level = 0;\n        List<long> levels = new\
    \ List<long>();\n        List<string> groups = new List<string>();\n        List<long>\
    \ group_sizes = new List<long>();\n        long group_level = 0;\n        long\
    \ group_index = 0;\n        string temp_group = \"\";\n        // Split the string\
    \ into groups of parentheses\n        // e.g. \"((()))\" => \"(()) ()\"\n    \
    \    string[] strings = paren_string.Split(new char[] { '(', ')', '{', '}' },\
    \ StringSplitOptions.RemoveEmptyEntries);\n        foreach (string s in strings)\
    \ {\n            // If we're at the end of a group of parentheses, increment the\
    \ group level\n            if (group_index == groups.Count && temp_group != \"\
    \") {\n                group_level++;\n                group_levels.Add(group_level);\n\
    \            }\n            temp_group = s;\n            // If the group is empty,\
    \ increment the group index and continue\n            if (s == \"\") {\n     \
    \           group_index++;\n                continue;\n            }\n       \
    \     // If the current character is the opening parenthesis, reset the group\n\
    \            if (s[0] == '(') {\n                group_index = 0;\n          \
    \      group_level = 0;\n            }\n            // If the current character\
    \ is the closing parenthesis, add the group level to the max level\n         \
    \   if (s[s.Length - 1] == ')') {\n                group_level--;\n          \
    \      group_levels.Add(group_level);\n            }\n            // If the current\
    \ character is an opening brace or closing brace, add the group to the groups\
    \ collection\n            if (s.Contains('{') || s.Contains('}')) {\n        \
    \        groups.Add(s);\n                // If the current group does not contain\
    \ any parenthesis, increment the group index and continue\n                if\
    \ (groups[group_index] == \"\") {\n                    group_index++;\n      \
    \              continue;\n                }\n                // Otherwise, check\
    \ if the current group has parentheses or is empty\n                bool has_parens\
    \ = false;\n                if (groups[group_index].Contains('(')) {\n       \
    \             has_parens = true;\n                }\n                if (groups[group_index].Contains('{')\
    \ || groups[group_index].Contains('}')) {\n                    has_parens = true;\n\
    \                }\n                // If the group contains parentheses, reset\
    \ the group index\n                if (has_parens) {\n                    group_index\
    \ = 0;\n                    continue;\n                }\n                group_sizes.Add(groups[group_index].Length);\n\
    \            }\n        }\n        \n        // Start at the last group index\n\
    \        foreach (string s in groups) {\n            // If the group contains\
    \ parentheses, reset the group index\n            if (s.Contains('(')) {\n   \
    \             group_index = 0;\n                continue;\n            }\n   \
    \         // If the current group does not contain any parenthesis, increment\
    \ the group index and continue\n            if (groups[group_index] == \"\") {\n\
    \                group\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbb5ehwx9.cs(81,22): error CS1002: ; expected

    /tmp/tmpbb5ehwx9.cs(83,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpbb5ehwx9.cs(89,2): error CS1513: } expected

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nest_counts = new List<long>();\n      \
    \  Stack<long> parentheses = new Stack<long>();\n\n        foreach (char open\
    \ in paren_string) {\n            if (open == '(') parentheses.Push(1L);\n   \
    \         else if (open == ')') {\n                while (parentheses.Count >\
    \ 0) {\n                    nest_counts.Add(parentheses.Pop());\n            \
    \    }\n            }\n            else if (parentheses.Count > 0) {\n       \
    \         nest_counts.Add(nest_counts[parentheses.Count - 1] + 1);\n         \
    \   }\n        }\n        return nest_counts;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <60ed4f642526487ba06e57d8dcb82fa0>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <60ed4f642526487ba06e57d8dcb82fa0>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var nested_depth = new List<long>();\n        StringBuilder\
    \ buf = new StringBuilder();\n        StringBuilder buffer = new StringBuilder();\n\
    \        foreach (var c in paren_string) {\n            buf.Append(c);\n     \
    \       if (buf.ToString().Contains(\"(\")) {\n                if (buffer.Length\
    \ != 0) {\n                    nested_depth.Add(nested_depth.Last() + 1);\n  \
    \              }\n                buffer.Clear();\n            } else if (buffer.Length\
    \ != 0) {\n                if (buffer.Length != 0) {\n                    nested_depth.Add(nested_depth.Last()\
    \ + 1);\n                }\n                buffer.Append(c);\n            }\n\
    \        }\n        if (buffer.Length != 0) {\n            nested_depth.Add(nested_depth.Last()\
    \ + 1);\n        }\n        return new List<long>(nested_depth);\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <80c62c201c604113aa19f8218ec018ed>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <80c62c201c604113aa19f8218ec018ed>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        string group = \"\";\n        List<long> result = new\
    \ List<long>();\n        string last = \"()\";\n        int level = 0;\n     \
    \   foreach (char c in paren_string) {\n            switch (c) {\n           \
    \     case '(':\n                    level += 1;\n                    break;\n\
    \                case ')':\n                    level -= 1;\n                \
    \    break;\n                default:\n                    group += c;\n     \
    \               break;\n            }\n            if (level > 0) {\n        \
    \        result.Add(level);\n            }\n            if (level == 0 && group\
    \ != \"\") {\n                result.Add(long.Parse(group));\n               \
    \ group = \"\";\n            }\n            group = last;\n            last =\
    \ c;\n        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw8nhca2o.cs(39,20): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null || !paren_string.Contains(\"\
    \ \"))\n            return null;\n        // We do not need to handle empty parens\
    \ ((()))\n        if (paren_string.Contains(\"(\") && !paren_string.Contains(\"\
    )\"))\n            return null;\n        if (paren_string.StartsWith(\"(\") &&\
    \ paren_string.EndsWith(\")\"))\n            return null;\n        // We do not\
    \ need to handle brackets ()\n        if (paren_string.StartsWith(\"(\") || paren_string.EndsWith(\"\
    )\")\n            return null;\n        string nested_paren_sub_string = paren_string.Replace(\"\
    \ \", \"\");\n        List<long> max_nesting = new List<long>(new long[]{0, new\
    \ long[0]});\n        for (int i = 1; i < nested_paren_sub_string.Length; i++)\
    \ {\n            int opening_parentheses = nested_paren_sub_string[i] - '(';\n\
    \            int closing_parentheses = nested_paren_sub_string[nested_paren_sub_string.Length\
    \ - i] - ')';\n            if (opening_parentheses == 0 && closing_parentheses\
    \ == 0)\n                continue;\n            List<long> level_of_nesting =\
    \ new List<long>(new long[]{opening_parentheses, new long[closing_parentheses\
    \ + 1]});\n            for (int j = opening_parentheses + 1; j < level_of_nesting.Count;\
    \ j++)\n                level_of_nesting[j] = level_of_nesting[j - 1] + 1;\n \
    \           List<long> new_max_nesting = new List<long>(new long[]{Math.Max(max_nesting[0],\
    \ Math.Max(level_of_nesting[0], level_of_nesting[1])), new long[max_nesting.Count\
    \ + 1]});\n            for (int k = max_nesting.Count; k > 0; k--)\n         \
    \       new_max_nesting[k] = Math.Max(new_max_nesting[k], level_of_nesting[k]);\n\
    \            max_nesting = new_max_nesting;\n        }\n        return max_nesting;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbqhtsr3f.cs(23,71): error CS1026: ) expected

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var result = new List<long>();\n        var groups\
    \ = paren_string.Trim().Split(new char[] { ' ' }).ToList();\n        for (int\
    \ i = 0; i < groups.Count; i++) {\n            if (groups[i].Length > 0) {\n \
    \               if (groups[i][0] == '(' && groups[i][groups[i].Length - 1] ==\
    \ ')') {\n                    result.Add(i);\n                    result.Add(i\
    \ + 1);\n                } else {\n                    result.Add(-1);\n     \
    \           }\n            }\n        }\n        return result;\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <89e94e95deef4b31bf9d922386fce811>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <89e94e95deef4b31bf9d922386fce811>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Keep track of the deepest level we encounter so\
    \ that we can add 1 to it\n        // when we encounter a new parenthesis.\n \
    \       long max_level = 1L;\n        // Keep track of the current level in the\
    \ paren string. Whenever a new level\n        // is encountered, increment the\
    \ level. When we encounter a closing parenthesis,\n        // decrement the level.\n\
    \        int level = 0;\n        // Keep track of the parenthesis we are currently\
    \ encountering so we can\n        // remove them when we encounter a new one.\n\
    \        string current_paren = \"(\";\n        // Keep track of the parenthesis\
    \ we are currently encountering so we can\n        // remove them when we encounter\
    \ a new one.\n        string next_paren = \")\";\n        bool has_opening_paren\
    \ = false;\n        bool has_closing_paren = false;\n        // Keep track of\
    \ the parenthesis we are currently encountering so we can\n        // remove them\
    \ when we encounter a new one.\n        string last_paren = \"\";\n        //\
    \ Keep track of the parenthesis we are currently encountering so we can\n    \
    \    // remove them when we encounter a new one.\n        string last_last_paren\
    \ = \"\";\n        // Keep track of the parenthesis we are currently encountering\
    \ so we can\n        // remove them when we encounter a new one.\n        string\
    \ last_next_paren = \"\";\n        List<long> levels = new List<long>();\n   \
    \     // Keep track of whether we are currently inside a set of nested parenthesis.\n\
    \        bool in_paren = false;\n        foreach (char c in paren_string) {\n\
    \            if (c == current_paren) {\n                has_opening_paren = true;\n\
    \            }\n            else if (c == next_paren) {\n                has_closing_paren\
    \ = true;\n            }\n            if (has_opening_paren) {\n             \
    \   if (c == current_paren) {\n                    current_paren = next_paren;\n\
    \                    level++;\n                }\n                else if (c ==\
    \ next_paren) {\n                    current_paren = last_paren;\n           \
    \         level--;\n                    if (level == 0) {\n                  \
    \      levels.Add(max_level);\n                    }\n                }\n    \
    \            else if (c == '(') {\n                    level++;\n            \
    \    }\n                else if (c == ')') {\n                    level--;\n \
    \                   if (level == 0) {\n                        levels.Add(max_level);\n\
    \                    }\n                }\n            }\n            if (has_closing_paren)\
    \ {\n                if (c == current_paren) {\n                    current_paren\
    \ = last_next_paren;\n                }\n                else if (c == last_paren)\
    \ {\n                    current_paren = last_last_paren;\n                }\n\
    \                else if (c == next_paren) {\n                    current_paren\
    \ = last_next_paren;\n                }\n                else if (c == '(') {\n\
    \                    level--;\n                }\n                else if (c ==\
    \ ')') {\n                    level++;\n                }\n            }\n   \
    \         if (current_paren == last_\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzjivhwe4.cs(88,39): error CS1026: ) expected

    /tmp/tmpzjivhwe4.cs(88,39): error CS1525: Invalid expression term ''}''

    /tmp/tmpzjivhwe4.cs(88,39): error CS1002: ; expected

    /tmp/tmpzjivhwe4.cs(90,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpzjivhwe4.cs(96,2): error CS1513: } expected

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialize result and current depth counter\n  \
    \      List<long> result = new List<long>();\n        int depth = 1;\n       \
    \ // Iterate through the input string chars\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            // If not open parenthesis, add to result and reset current\
    \ depth counter\n            if (paren_string[i] == '(') {\n                result.Add(depth);\n\
    \                depth = 1;\n            }\n            // If open parenthesis,\
    \ increase depth counter\n            else {\n                depth++;\n     \
    \       }\n        }\n        // If final element (depth == 0), add it to the\
    \ result\n        if (depth == 0)\n            result.Add(depth);\n        //\
    \ Return the result\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <84e28e03e9174b6b95faaec10db64ead>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <84e28e03e9174b6b95faaec10db64ead>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Use a stack to keep track of nesting levels.\n \
    \       Stack<long> stack = new Stack<long>();\n        List<long> result_list\
    \ = new List<long>();\n\n        // Add all characters to the stack and process\
    \ them.\n        foreach (char c in paren_string) {\n            // If it's a\
    \ left bracket, push it to the stack and increase nesting level.\n           \
    \ if (c == '(') {\n                stack.Push(1);\n            }\n           \
    \ // If it's a right bracket, decrease nesting level and pop if necessary.\n \
    \           else if (c == ')') {\n                if (stack.Count > 0) {\n   \
    \                 long top = stack.Pop();\n                    while (top-- >\
    \ 0) {\n                        result_list.Add(result_list.Count);\n        \
    \            }\n                }\n            }\n            // If it's a number,\
    \ add it to the list of results.\n            else if (char.IsNumber(c)) {\n \
    \               result_list.Add(result_list.Count);\n            }\n        }\n\
    \        return result_list;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fbc23e6eac2d45ceb0f5c4b13acf49ac>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <fbc23e6eac2d45ceb0f5c4b13acf49ac>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nest_levels = new List<long>();\n      \
    \  string group = \"\";\n        string current_char = \"\";\n        bool in_group\
    \ = false;\n        bool last_char_was_opening_paren = false;\n        bool last_char_was_closing_paren\
    \ = false;\n        long level = 1;\n        long num_chars = 0;\n        for\
    \ (int i = 0; i < paren_string.Length; i++) {\n            current_char = paren_string[i];\n\
    \            if (!in_group && last_char_was_opening_paren && current_char == paren_string[i])\
    \ {\n                in_group = true;\n                last_char_was_closing_paren\
    \ = false;\n                group = \"\";\n                last_char_was_opening_paren\
    \ = false;\n                level++;\n                nest_levels.Add(level);\n\
    \                level--;\n            } else if (in_group && !last_char_was_closing_paren\
    \ && current_char == paren_string[i]) {\n                in_group = false;\n \
    \               group += current_char;\n                last_char_was_opening_paren\
    \ = true;\n                last_char_was_closing_paren = false;\n            \
    \    level++;\n                nest_levels.Add(level);\n                level--;\n\
    \            } else if (in_group && last_char_was_closing_paren && current_char\
    \ == paren_string[i]) {\n                in_group = false;\n                group\
    \ += current_char;\n                last_char_was_opening_paren = false;\n   \
    \             last_char_was_closing_paren = true;\n                level--;\n\
    \                nest_levels.Add(level);\n                level++;\n         \
    \   } else if (in_group) {\n                group += current_char;\n         \
    \       last_char_was_opening_paren = true;\n                last_char_was_closing_paren\
    \ = false;\n                level++;\n                nest_levels.Add(level);\n\
    \                level--;\n            }\n        }\n        return nest_levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcmcuvpq7.cs(24,28): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    /tmp/tmpcmcuvpq7.cs(25,61): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpcmcuvpq7.cs(33,68): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpcmcuvpq7.cs(41,67): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpcmcuvpq7.cs(22,14): warning CS0219: The variable ''num_chars'' is assigned
    but its value is never used

    '
  timestamp: 1659976356
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> nested = new List<long>();\n        Stack<long>\
    \ open = new Stack<long>();\n        long[] count = new long[paren_string.Length\
    \ + 1];\n        for (int i = 0; i < paren_string.Length; i++) {\n           \
    \ if (paren_string[i] == '(') {\n                if (open.Count > 0) {\n     \
    \               nested.Add(open.Pop());\n                    count[i]++;\n   \
    \             }\n            } else {\n                open.Push(count[i]);\n\
    \            }\n        }\n        nested.Add(open.Count);\n        return nested;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <e65ece7b67444ef2b4b2e57fb5ab2f8e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <e65ece7b67444ef2b4b2e57fb5ab2f8e>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // We use stack to maintain the number of left and\
    \ right paren\n        // This allows us to get the max of left and right paren\n\
    \        Stack<long> stack_left_paren = new Stack<long>();\n        Stack<long>\
    \ stack_right_paren = new Stack<long>();\n        Stack<long> stack_level = new\
    \ Stack<long>();\n\n        // We will store max level and count of left and right\
    \ paren here.\n        long max_level = 0;\n        long left_paren_counter =\
    \ 1;\n        long right_paren_counter = 1;\n\n        string temp_str = string.Empty;\n\
    \        bool has_left_paren = false;\n\n        // For every character in input\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             // Check if we have already encountered left paren\n           \
    \     if (has_left_paren) {\n                    stack_left_paren.Push(left_paren_counter);\n\
    \                    stack_level.Push(max_level);\n                    max_level++;\n\
    \                    stack_level.Push(max_level);\n                    left_paren_counter++;\n\
    \                    stack_level.Push(max_level);\n                }\n       \
    \         has_left_paren = true;\n            } else if (c == ')') {\n       \
    \         // Check if we have already encountered right paren\n              \
    \  if (stack_right_paren.Count > 0) {\n                    stack_level.Push(stack_level.Count\
    \ + 1);\n                    stack_level.Pop();\n                    stack_right_paren.Pop();\n\
    \                    right_paren_counter--;\n                }\n             \
    \   has_left_paren = false;\n            } else if (c == ' ' && has_left_paren)\
    \ {\n                // If space and we are inside left paren, then we will store\
    \ the max level here\n                temp_str = temp_str + c.ToString();\n  \
    \              // Push the max level in the stack\n                stack_level.Push(max_level);\n\
    \            } else if (c == ' ' && stack_left_paren.Count > 0) {\n          \
    \      // If space and we are inside right paren, then we will store the max level\
    \ here\n                temp_str = temp_str + c.ToString();\n                //\
    \ Push the max level in the stack\n                stack_level.Push(max_level);\n\
    \            } else if (c == ' ') {\n                // If space then it will\
    \ just store the max level here\n                temp_str = temp_str + c.ToString();\n\
    \            }\n        }\n\n        // For every left paren, store it in the\
    \ stack\n        // If right paren is encountered, then pop out all the left paren\n\
    \        // If space is encountered, then pop out all the left paren\n       \
    \ while (stack_left_paren.Count > 0) {\n            temp_str = temp_str + stack_left_paren.Peek().ToString();\n\
    \            stack_left_paren.Pop();\n        }\n        while (stack_right_paren.Count\
    \ > 0) {\n            temp_str = temp_str + stack_right_paren.Peek().\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe7_rsc4u.cs(75,60): error CS1001: Identifier expected

    /tmp/tmpe7_rsc4u.cs(75,60): error CS1002: ; expected

    /tmp/tmpe7_rsc4u.cs(77,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpe7_rsc4u.cs(83,2): error CS1513: } expected

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Get rid of trailing spaces\n        if (paren_string.Trim().Length\
    \ == 0)\n            return new List<long>(new long[] { 0L });\n\n        var\
    \ list = new List<long>();\n        var opening_count = 0;\n        var closing_count\
    \ = 0;\n        var paren_counter = 1;\n        // Loop through the characters\
    \ and count opening and closing parenthesis\n        for (char c in paren_string)\
    \ {\n            switch (c) {\n                case '(':\n                   \
    \ opening_count++;\n                    break;\n                case ')':\n  \
    \                  closing_count++;\n                    break;\n            \
    \    default:\n                    // Count opening parentheses only\n       \
    \             if (opening_count == 0) {\n                        list.Add(paren_counter);\n\
    \                        opening_count = 1;\n                        paren_counter++;\n\
    \                    }\n                    break;\n            }\n        }\n\
    \        // Handle case when there's not enough closing parentheses\n        if\
    \ (closing_count > 0) {\n            list.Add(paren_counter);\n        }\n   \
    \     return list;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4e35eql_.cs(24,9): error CS1003: Syntax error, ''foreach'' expected

    '
  timestamp: 1659976356
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var levels = new List<long>();\n        bool inside_group\
    \ = false;\n        var group_counts = new List<long>();\n        foreach (var\
    \ c in paren_string) {\n            bool has_group = false;\n            bool\
    \ group_end = false;\n            bool group_open = false;\n            bool group_close\
    \ = false;\n            if (c == '(') {\n                if (inside_group) continue;\n\
    \                group_open = true;\n                group_close = false;\n  \
    \          }\n            if (c == ')') {\n                if (inside_group) continue;\n\
    \                group_close = true;\n                group_open = false;\n  \
    \          }\n            if (c == '(') {\n                level++;\n        \
    \    }\n            if (c == ')') {\n                level--;\n            }\n\
    \            if (c == '[') {\n                inside_group = true;\n         \
    \       has_group = true;\n                group_close = true;\n            }\n\
    \            if (c == ']') {\n                inside_group = false;\n        \
    \        has_group = false;\n            }\n            if (c == ' ') {\n    \
    \            if (!has_group) {\n                    group_count = (long)Math.Max((long)group_count,\
    \ (long)level);\n                }\n            }\n            if (c == '\\n'\
    \ || c == '\\r' || c == 0x0a) {\n                level = 0;\n                group_counts.Clear();\n\
    \                group_close = false;\n            }\n            if (group_open\
    \ && !group_close) {\n                group_count++;\n                group_counts.Add(group_count);\n\
    \            }\n            if (!group_open) {\n                group_count++;\n\
    \                group_counts.Add(group_count);\n            }\n        }\n  \
    \      return levels;\n    }\n    public static void Main(string[] args) {\n \
    \   Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpoi72bsxp.cs(34,17): error CS0103: The name ''level'' does not exist in
    the current context

    /tmp/tmpoi72bsxp.cs(37,17): error CS0103: The name ''level'' does not exist in
    the current context

    /tmp/tmpoi72bsxp.cs(50,21): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(50,56): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(50,75): error CS0103: The name ''level'' does not exist in
    the current context

    /tmp/tmpoi72bsxp.cs(54,17): error CS0103: The name ''level'' does not exist in
    the current context

    /tmp/tmpoi72bsxp.cs(59,17): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(60,34): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(63,17): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(64,34): error CS0103: The name ''group_count'' does not exist
    in the current context

    /tmp/tmpoi72bsxp.cs(20,18): warning CS0219: The variable ''group_end'' is assigned
    but its value is never used

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string.Length < 2) {\n            return\
    \ new List<long>();\n        }\n        bool seen_opening_bracket = false;\n \
    \       bool seen_closing_bracket = false;\n        long level = 0;\n        Stack<long>\
    \ stack = new Stack<long>();\n        List<long> level_stack = new List<long>();\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             if (seen_opening_bracket) {\n                    level_stack.Add(level);\n\
    \                }\n                level++;\n                stack.Add(level);\n\
    \                seen_opening_bracket = true;\n            } else if (c == ')')\
    \ {\n                if (seen_closing_bracket) {\n                    stack_length\
    \ = stack.Count;\n                    if (stack.Count < 1) {\n               \
    \         //Console.WriteLine(\"{0} level of nesting encountered while parsing\
    \ nested parentheses: {1}\", level, paren_string);\n                        return\
    \ level_stack;\n                    } else {\n                        while (stack.Count\
    \ > stack_length) {\n                            level_stack.RemoveAt(level_stack.Count\
    \ - 1);\n                        }\n                    }\n                }\n\
    \                level--;\n                stack_length = stack.Count;\n     \
    \           if (stack.Count < 1) {\n                    //Console.WriteLine(\"\
    {0} level of nesting encountered while parsing nested parentheses: {1}\", level,\
    \ paren_string);\n                    return level_stack;\n                } else\
    \ {\n                    while (stack.Count > stack_length) {\n              \
    \          level_stack.RemoveAt(level_stack.Count - 1);\n                    }\n\
    \                }\n                seen_closing_bracket = true;\n           \
    \ } else if (c == '\\0') {\n                break;\n            }\n        }\n\
    \        List<long> result = new List<long>();\n        foreach (long i in stack)\
    \ {\n            result.Add(i);\n        }\n        Debug.Assert(result.Count\
    \ > 0, \"Empty stack\");\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1wc5s334.cs(29,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp1wc5s334.cs(33,21): error CS0103: The name ''stack_length'' does not exist
    in the current context

    /tmp/tmp1wc5s334.cs(38,46): error CS0103: The name ''stack_length'' does not exist
    in the current context

    /tmp/tmp1wc5s334.cs(44,17): error CS0103: The name ''stack_length'' does not exist
    in the current context

    /tmp/tmp1wc5s334.cs(49,42): error CS0103: The name ''stack_length'' does not exist
    in the current context

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // This implementation is O(n*logn).\n        // We\
    \ maintain an internal tree to compute the level of nesting.\n        Stack<Tuple<long,\
    \ Tuple<long, long>>> stack = new Stack<Tuple<long, Tuple<long, long>>>();\n \
    \       Tuple<long, Tuple<long, long>> top = new Tuple<long, Tuple<long, long>>(0,\
    \ null);\n        bool inOpen = false;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                inOpen = !inOpen;\n        \
    \    }\n            if (!inOpen) {\n                top.Item2 = top;\n       \
    \         top.Item1 = stack.Peek().Item1 + 1;\n                stack.Push(top);\n\
    \            }\n            top = new Tuple<long, Tuple<long, long>>(top.Item1\
    \ + 1, new Tuple<long, long>(top.Item2, 0));\n        }\n        List<long> result\
    \ = new List<long>();\n        while (stack.Count > 0) {\n            result.Add(stack.Pop().Item2);\n\
    \        }\n        return result;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4pngbh2x.cs(25,17): error CS0200: Property or indexer ''Tuple<long, Tuple<long,
    long>>.Item2'' cannot be assigned to -- it is read only

    /tmp/tmp4pngbh2x.cs(26,17): error CS0200: Property or indexer ''Tuple<long, Tuple<long,
    long>>.Item1'' cannot be assigned to -- it is read only

    /tmp/tmp4pngbh2x.cs(29,91): error CS1503: Argument 1: cannot convert from ''System.Tuple<long,
    long>'' to ''long''

    /tmp/tmp4pngbh2x.cs(33,24): error CS1503: Argument 1: cannot convert from ''System.Tuple<long,
    long>'' to ''long''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // If string contains only brackets, return null\n\
    \        if (paren_string.Contains(\"()\") && paren_string.Contains(\")\")) return\
    \ null;\n\n        // Make a list of groups and add all chars except brackets\
    \ to groups\n        List<string> groups = new List<string>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        foreach (char c in paren_string) {\n    \
    \        if (c == '(') groups.Add(c);\n            else sb.Append(c);\n      \
    \  }\n\n        // If string is empty, return null\n        if (groups.Count ==\
    \ 0) return null;\n\n        // Iterate through groups and parse each group\n\
    \        int group_level = 0;\n        foreach (string group in groups) {\n  \
    \          // Increase the level of nested parentheses if there is a nested bracket\n\
    \            if (group.IndexOf('(') != -1)\n                group_level++;\n\n\
    \            // Decrease the level of nested parentheses if there is a nested\
    \ bracket\n            else if (group.IndexOf(')') != -1)\n                group_level--;\n\
    \n            // If the level is not zero, add it to the list\n            if\
    \ (group_level != 0) groups.Add(new long[]{group_level, groups.Count});\n    \
    \    }\n\n        // Sort the list by decreasing number of nested parentheses\
    \ \n        return groups.OrderByDescending(x => x.Sum()).Select(x => x.Sum()).ToList();\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpchsomlm3.cs(22,38): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmpchsomlm3.cs(41,46): error CS1503: Argument 1: cannot convert from ''long[]''
    to ''string''

    /tmp/tmpchsomlm3.cs(45,46): error CS1929: ''string'' does not contain a definition
    for ''Sum'' and the best extension method overload ''ParallelEnumerable.Sum(ParallelQuery<int>)''
    requires a receiver of type ''ParallelQuery<int>''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var results = new List<long>();\n        if (paren_string\
    \ == null) throw new ArgumentNullException(\"paren_string\");\n        if (paren_string.Length\
    \ == 0) return results;\n        paren_string = paren_string.Trim();\n       \
    \ paren_string = paren_string.Replace(\"(\", string.Empty);\n        paren_string\
    \ = paren_string.Replace(\")\", string.Empty);\n        var nested_parens = new\
    \ Stack<string>();\n        foreach (var c in paren_string) {\n            if\
    \ (c == '(') {\n                if (nested_parens.Count == 0) nested_parens.Push(c);\n\
    \                else if (nested_parens.Count > 0 && nested_parens.Peek() == '(')\
    \ {\n                    nested_parens.Push(c);\n                }\n         \
    \   } else {\n                if (nested_parens.Count > 0 && nested_parens.Peek()\
    \ == '(') {\n                    nested_parens.Pop();\n                }\n   \
    \             nested_parens.Push(c);\n            }\n        }\n        while\
    \ (nested_parens.Count > 0)\n        {\n            var current_level = nested_parens.Count\
    \ - 1;\n            var current_level_contents = nested_parens.ToList();\n   \
    \         nested_parens.Pop();\n            if (current_level_contents.Count >\
    \ 0)\n            {\n                foreach (var level_content in current_level_contents)\n\
    \                {\n                    if (level_content == '(' && current_level\
    \ > 0)\n                    {\n                        current_level--;\n    \
    \                }\n                    else if (level_content == ')' && current_level\
    \ > 0)\n                    {\n                        current_level--;\n    \
    \                }\n                }\n            }\n            results.Add(current_level);\n\
    \        }\n        return results;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp48kb5n74.cs(24,66): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmp48kb5n74.cs(25,53): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmp48kb5n74.cs(26,40): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmp48kb5n74.cs(29,48): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmp48kb5n74.cs(32,36): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmp48kb5n74.cs(44,25): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmp48kb5n74.cs(48,30): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> deepest_level_of_nesting = new List<long>();\n\
    \        List<string> paren_groups = paren_string.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n\
    \        // Count number of nested parentheses.\n        int num_paren = 0;\n\
    \        foreach (string s in paren_groups) {\n            if (s.StartsWith(\"\
    (\")) {\n                ++num_paren;\n            } else if (s.EndsWith(\")\"\
    )) {\n                --num_paren;\n            }\n        }\n        // If number\
    \ of nested parentheses equals to 0, return an empty list.\n        if (num_paren\
    \ == 0) {\n            return deepest_level_of_nesting;\n        }\n        //\
    \ For each of the groups, create a nested pair of parentheses that will be split\
    \ by recursive call.\n        // This nested pair will represent a level.\n  \
    \      // E.g. (()()) creates (()()), ((())) and ((())()) will call themselves\
    \ recursively.\n        List<string> nested_paren_groups = new List<string>();\n\
    \        foreach (string s in paren_groups) {\n            if (s.StartsWith(\"\
    (\")) {\n                nested_paren_groups.Add(s);\n            } else if (s.EndsWith(\"\
    )\")) {\n                nested_paren_groups.Add(s);\n                nested_paren_groups.Add(nested_paren_groups[0]);\n\
    \            }\n        }\n        // The deepest level of nesting will be the\
    \ longest of the deepest level at each level recursively.\n        List<long>\
    \ deepest_levels = new List<long>();\n        // For each of the nested parentheses,\
    \ create a pair of parentheses that will be split by recursive call.\n       \
    \ // This nested pair will represent a level.\n        // E.g. Creating ((()))\
    \ will call itself recursively.\n        // E.g. Creating ((())) will call itself\
    \ recursively.\n        // E.g. Creating ((())) will call itself recursively.\n\
    \        List<string> nested_pairs = new List<string>();\n        foreach (string\
    \ s in nested_paren_groups) {\n            string pair = s;\n            // Find\
    \ the deepest level of nesting.\n            long deepest_level = 0;\n       \
    \     for (int i = 0; i < (s.Length - 1); i++) {\n                if (s[i] ==\
    \ '(') {\n                    ++deepest_level;\n                } else if (s[i]\
    \ == ')') {\n                    --deepest_level;\n                }\n       \
    \     }\n            deepest_levels.Add(deepest_level);\n            // Create\
    \ a pair of parentheses that will be split by recursive call.\n            //\
    \ This nested pair will represent a level.\n            // E.g. Creating ((()))\
    \ will call itself recursively.\n            nested_pairs.Add(pair);\n       \
    \     nested_pairs.Add(pair);\n        }\n        // Merge \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2ydy15mt.cs(16,37): error CS0029: Cannot implicitly convert type ''string[]''
    to ''System.Collections.Generic.List<string>''

    /tmp/tmp2ydy15mt.cs(14,30): error CS0161: ''Problem.ParseNestedParens(string)'':
    not all code paths return a value

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) throw new ArgumentNullException(\"\
    paren_string\");\n\n        List<long> deepest_levels_of_nesting = new List<long>();\n\
    \n        // Store the count of open parentheses encountered so far.\n       \
    \ int open_count = 1;\n        // Store the count of close parentheses encountered\
    \ so far.\n        int close_count = 1;\n        // Keep track of position in\
    \ the paren_string from which we must skip parenthesis.\n        int paren_start_position\
    \ = paren_string.Length - 1;\n        // Keep track of current parentheses level\
    \ of nesting.\n        long current_deepest_levels_of_nesting = 0;\n\n       \
    \ while (true) {\n            if (paren_start_position >= 0) {\n             \
    \   // Look ahead to see if we need to skip over any extra parenthesis.\n    \
    \            char ch1 = paren_string[paren_start_position++];\n              \
    \  if (ch1 == '(')\n                    ++open_count;\n                else if\
    \ (ch1 == ')')\n                    ++close_count;\n                else\n   \
    \                 throw new Exception(\"Unexpected character found in parenthesis.\"\
    );\n            }\n\n            if (open_count == close_count)\n            \
    \    deepest_levels_of_nesting.Add(current_deepest_levels_of_nesting);\n     \
    \       else if (open_count > close_count)\n                current_deepest_levels_of_nesting\
    \ += (long)(open_count - close_count);\n            else {\n                //\
    \ Reset the current level of nesting count.\n                current_deepest_levels_of_nesting\
    \ = 0;\n                ++open_count;\n                ++close_count;\n      \
    \      }\n        }\n    }\n    public static void Main(string[] args) {\n   \
    \ Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside\
    \ the bounds of the array.\n  at Problem.ParseNestedParens (System.String paren_string)\
    \ [0x00041] in <ccea57741a61459eaf8cd886bb261f1c>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <ccea57741a61459eaf8cd886bb261f1c>:0 \n[ERROR] FATAL UNHANDLED\
    \ EXCEPTION: System.IndexOutOfRangeException: Index was outside the bounds of\
    \ the array.\n  at Problem.ParseNestedParens (System.String paren_string) [0x00041]\
    \ in <ccea57741a61459eaf8cd886bb261f1c>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00001] in <ccea57741a61459eaf8cd886bb261f1c>:0 \n"
  stdout: ''
  timestamp: 1659976357
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var max_level = 0;\n        var open_parantheses =\
    \ 0;\n        var open_parentheses = 0;\n        var level = new List<long>();\n\
    \        foreach (var c in paren_string) {\n            if (c == '(') {\n    \
    \            open_parantheses += 1;\n            }\n            if (c == '(')\
    \ {\n                open_parentheses += 1;\n            }\n            if (c\
    \ == '(') {\n                level.Add(open_parentheses - open_parantheses);\n\
    \                open_parantheses = 0;\n                open_parentheses = 0;\n\
    \            }\n            if (c == ')') {\n                open_parentheses\
    \ -= 1;\n            }\n            if (c == ')') {\n                level.Add(open_parentheses\
    \ - open_parantheses);\n            }\n            if (c == ')') {\n         \
    \       if (open_parantheses == 0) {\n                    level.Add(open_parentheses\
    \ - open_parantheses);\n                }\n                open_parantheses =\
    \ 0;\n                open_parentheses = 0;\n            }\n            if (c\
    \ == ' ') {\n                if (level.Count == 0) {\n                    max_level\
    \ = 0;\n                }\n                if (level.Count > max_level) {\n  \
    \                  max_level = level.Count;\n                }\n            }\n\
    \        }\n        return level;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <921311f97d784b12a30a33b7687041d2>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <921311f97d784b12a30a33b7687041d2>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Use a stack to maintain the levels of nesting.\n\
    \        var stack = new Stack<long>();\n        // Keep track of the highest\
    \ level of nesting.\n        var max_level_of_nesting = 0;\n        // Keep track\
    \ of the nesting level for the last item added to `stack`.\n        var last_level_of_nesting\
    \ = 0;\n        var nesting_level = 0;\n        // A stack of all items in the\
    \ input string.\n        var items = new Stack<string>();\n        foreach (var\
    \ c in paren_string) {\n            switch (c) {\n                case '(':\n\
    \                    stack.Push(nesting_level);\n                    break;\n\
    \                case ')':\n                    if (stack.Count > 0) {\n     \
    \                   // If there are more than one level of nesting, pop an item\
    \ off of the stack.\n                        nesting_level = stack.Pop();\n  \
    \                      // If this popped item was an item that belongs in the\
    \ last level of nesting, increase the nesting level.\n                       \
    \ if (last_level_of_nesting == nesting_level) {\n                            nesting_level++;\n\
    \                        }\n                    }\n                    break;\n\
    \                case ' ':\n                    // Don't add spaces to the item\
    \ stack.\n                    break;\n                default:\n             \
    \       // If an item is encountered that doesn't belong in any previous level\
    \ of nesting,\n                    // add it to the stack.\n                 \
    \   items.Push(c);\n                    break;\n            }\n            last_level_of_nesting\
    \ = nesting_level;\n        }\n        // If there aren't any items in the stack\
    \ (i.e., parentheses were only used in items), then all parentheses were balanced.\n\
    \        if (stack.Count == 0) {\n            return new List<long>(new long[]\
    \ { 0L });\n        }\n        // Return the maximum level of nesting.\n     \
    \   return new List<long>(stack.Reverse().Take(stack.Count).Reverse());\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp35acoxrp.cs(32,41): error CS0266: Cannot implicitly convert type ''long''
    to ''int''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp35acoxrp.cs(45,32): error CS1503: Argument 1: cannot convert from ''char''
    to ''string''

    /tmp/tmp35acoxrp.cs(18,13): warning CS0219: The variable ''max_level_of_nesting''
    is assigned but its value is never used

    '
  timestamp: 1659976357
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var parens = new List<long>();\n        var depth =\
    \ 1;\n        var nested_depth = new List<long>();\n        var tokens = paren_string.Split(new\
    \ char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).Select(v => v.Trim()).ToArray();\n\
    \        var token_depths = new List<long>();\n        foreach (var t in tokens)\
    \ {\n            if (t.Equals(\"(\")) {\n                if (depth > nested_depth.Count)\
    \ {\n                    nested_depth.Add(depth);\n                }\n       \
    \         depth++;\n                token_depths.Add(depth);\n            }\n\
    \            else if (t.Equals(\")\")) {\n                if (depth == nested_depth.Count)\
    \ {\n                    // If no matching pair, try the entire string.\n    \
    \                nested_depth.Add(depth);\n                    token_depths.Add(depth);\n\
    \                }\n                depth--;\n            }\n            else\
    \ {\n                if (depth == nested_depth.Count) {\n                    //\
    \ If no matching pair, try the entire string.\n                    nested_depth.Add(depth);\n\
    \                    token_depths.Add(depth);\n                }\n           \
    \ }\n        }\n\n        while (nested_depth.Count > 0 && token_depths.Count\
    \ > 0) {\n            if (nested_depth.First() > token_depths.First()) {\n   \
    \             parens.Add(nested_depth.Last());\n                nested_depth.RemoveAt(nested_depth.Count\
    \ - 1);\n                token_depths.RemoveAt(token_depths.Count - 1);\n    \
    \        }\n            else {\n                parens.Add(token_depths.First());\n\
    \                token_depths.RemoveAt(token_depths.Count - 1);\n            \
    \    nested_depth.RemoveAt(nested_depth.Count - 1);\n            }\n        }\n\
    \        return parens;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <00397968d50547a4ad70af0d2016ca78>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <00397968d50547a4ad70af0d2016ca78>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>(paren_string.Count()\
    \ + 1);\n        int open_count = 0;\n        bool inside_group = false;\n   \
    \     string character;\n        for (int i = 0; i < paren_string.Length; i++)\
    \ {\n            character = paren_string[i];\n            Debug.Assert(open_count\
    \ > 0);\n            if (inside_group) {\n                if (character == '(')\
    \ {\n                    inside_group = false;\n                    open_count++;\n\
    \                } else if (character == ')') {\n                    inside_group\
    \ = false;\n                    result.Add(new long(open_count));\n          \
    \          open_count = 0;\n                } else if (character == '[') {\n \
    \                   inside_group = true;\n                    open_count++;\n\
    \                } else if (character == ']') {\n                    inside_group\
    \ = true;\n                    result.Add(new long(open_count));\n           \
    \         open_count = 0;\n                } else {\n                    throw\
    \ new InvalidOperationException(\"Unrecognized character in input string: '\"\
    \ + character + \"'\");\n                }\n            } else if (character ==\
    \ '(') {\n                inside_group = true;\n                open_count++;\n\
    \            } else if (character == ')') {\n                inside_group = false;\n\
    \                result.Add(new long(open_count));\n                open_count\
    \ = 0;\n            } else if (character == '[') {\n                inside_group\
    \ = true;\n                open_count++;\n            } else if (character ==\
    \ ']') {\n                inside_group = true;\n                result.Add(new\
    \ long(open_count));\n                open_count = 0;\n            } else {\n\
    \                throw new InvalidOperationException(\"Unrecognized character\
    \ in input string: '\" + character + \"'\");\n            }\n        }\n     \
    \   return result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv88aianw.cs(20,25): error CS0029: Cannot implicitly convert type ''char''
    to ''string''

    /tmp/tmpv88aianw.cs(23,21): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(26,28): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(28,36): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    /tmp/tmpv88aianw.cs(30,28): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(33,28): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(35,36): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    /tmp/tmpv88aianw.cs(40,24): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(43,24): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(45,32): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    /tmp/tmpv88aianw.cs(47,24): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(50,24): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''string'' and ''char''

    /tmp/tmpv88aianw.cs(52,32): error CS1729: ''long'' does not contain a constructor
    that takes 1 arguments

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        bool is_first = true;\n        List<long> levels =\
    \ new List<long>();\n        Stack<long> stack = new Stack<long>();\n        List<long>\
    \ outside_levels = new List<long>();\n        long level = 0;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                if\
    \ (!is_first) {\n                    level++;\n                }\n           \
    \     stack.Add(level);\n            }\n            if (c == ')') {\n        \
    \        if (!is_first) {\n                    level--;\n                }\n \
    \               long new_level = stack.Pop();\n                if (new_level ==\
    \ level) {\n                    is_first = false;\n                    level =\
    \ (long)outside_levels.Count;\n                }\n                levels.Add(level);\n\
    \            }\n            if (is_first) {\n                outside_levels.Add(level);\n\
    \            }\n        }\n        return outside_levels;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1u66dv2t.cs(25,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Get the number of nested parentheses\n        int\
    \ nested_count = new Regex(@\"^\\s*\\(\\s*\\((?!\\()\").Matches(paren_string).Count;\n\
    \        List<long> deepest = new List<long>();\n\n        // Iterate through\
    \ all the string and find all the groups of nested parentheses\n        foreach\
    \ (Match paren in new Regex(@\"\\(\\s*\\((?!\\()\").Matches(paren_string)) {\n\
    \            long current_level = 1;\n            string current_paren = paren.ToString();\n\
    \            foreach (char c in paren.ToString()) {\n                if (c ==\
    \ '(') current_level++;\n                else if (c == ')') current_level--;\n\
    \            }\n            if (current_level > deepest.Count)\n             \
    \   deepest.Add((long) current_level);\n        }\n        return deepest;\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpghqxiakn.cs(16,32): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpghqxiakn.cs(20,37): error CS0246: The type or namespace name ''Regex''
    could not be found (are you missing a using directive or an assembly reference?)

    /tmp/tmpghqxiakn.cs(20,18): error CS0246: The type or namespace name ''Match''
    could not be found (are you missing a using directive or an assembly reference?)

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        if (paren_string == null) return null;\n        var\
    \ stack = new Stack<long>();\n        bool found = false;\n        foreach (char\
    \ paren in paren_string) {\n            if (paren == '(') {\n                stack.Add(0L);\n\
    \                found = true;\n            } else if (paren == ')') {\n     \
    \           if (!found) return null;\n                var popped = stack.Pop();\n\
    \                if (popped != 0L) return null;\n                found = false;\n\
    \            } else if (paren == ' ') {\n                if (!found) return null;\n\
    \                found = false;\n            } else if (paren == '-' && stack.Any())\
    \ {\n                var top = stack.Pop();\n                var next = stack.Pop();\n\
    \                if (next > top) return null;\n                stack.Add(next\
    \ + 1);\n                found = true;\n            } else {\n               \
    \ if (!found) return null;\n                found = false;\n            }\n  \
    \      }\n        return stack.ToList();\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpiza_so45.cs(20,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpiza_so45.cs(34,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659976357
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var result = new List<long>();\n        var nestingLevels\
    \ = new Dictionary<string, long>();\n        foreach (var group in paren_string.Split('\
    \ ')) { // Split string into groups of parentheses.\n            // Add current\
    \ group to dictionary as key and increase nesting level.\n            var groupString\
    \ = group;\n            if (!nestingLevels.TryGetValue(groupString, out long currentNestingLevel))\n\
    \                nestingLevels[groupString] = 1;\n            else {\n       \
    \         nestingLevels[groupString] = nestingLevels[groupString] + 1;\n     \
    \           // If current nesting level is greater than the existing max, update\
    \ it to max.\n                if (nestingLevels[groupString] > currentNestingLevel)\n\
    \                    currentNestingLevel = nestingLevels[groupString];\n     \
    \       }\n            nestingLevels[groupString] = currentNestingLevel;\n   \
    \         Debug.Assert(nestingLevels[groupString] <= nestingLevels.Count);\n \
    \           \n            // If current nesting level is equal to max nesting\
    \ level, add current group to output.\n            if (nestingLevels[groupString]\
    \ == nestingLevels.Count) {\n                result.Add(long.Parse(group));\n\
    \                continue;\n            }\n            \n            // If current\
    \ nesting level is greater than the max nesting level, just add the current group.\n\
    \            if (nestingLevels[groupString] > nestingLevels.Count)\n         \
    \       result.Add(long.Parse(group));\n        }\n        return result;\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <3103c951230a4aa4923883716ec15f32>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <3103c951230a4aa4923883716ec15f32>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659976358
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Each element in the list represents a set of parenthesis\
    \ levels separated by spaces.\n        // E.g. (\"()()\") has two levels of nesting.\n\
    \        List<List<long>> paren_groups = paren_string.Split(new char[]{'(', ')'}).ToList()\n\
    \            .SelectMany(s => s.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries).ToList(),\
    \ (s, i) => new {s, i})\n            .GroupBy(x => x.i, x => x.s)\n          \
    \  .Select(x => x.ToList())\n            .ToList();\n        // Each set of parenthesis\
    \ levels corresponds to one level.\n        // E.g. (()()) has two levels, so\
    \ return two levels as long.\n        return paren_groups.Sum(x => x.Sum(y =>\
    \ ((y.Count * 1L) + y.Count - 1L)));\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcdaq1bbv.cs(17,41): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.List<System.Collections.Generic.List<string>>''
    to ''System.Collections.Generic.List<System.Collections.Generic.List<long>>''

    /tmp/tmpcdaq1bbv.cs(24,51): error CS0019: Operator ''*'' cannot be applied to
    operands of type ''method group'' and ''long''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // We don't care how many nested parentheses there\
    \ are, we just need the deepest one\n        var stack = new Stack<long>();\n\
    \        var char_count = new Dictionary<char, int>();\n\n        // Count how\
    \ many characters we have\n        foreach (char c in paren_string) {\n      \
    \      char cur_char = (char)c;\n            if (char_count.ContainsKey(cur_char))\
    \ {\n                char_count[cur_char]++;\n            } else {\n         \
    \       char_count[cur_char] = 1;\n            }\n        }\n\n        // Process\
    \ char and count nested parentheses\n        foreach (char c in paren_string)\
    \ {\n            char cur_char = (char)c;\n            if (char_count.ContainsKey(cur_char))\
    \ {\n                stack.Push(char_count[cur_char]);\n                char_count[cur_char]\
    \ = 0;\n            } else if (stack.Count > 0) {\n                char_count[cur_char]\
    \ = stack.Pop();\n            } else {\n                char_count[cur_char] =\
    \ 0;\n            }\n        }\n\n        return new List<long>(stack.Peek());\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0vcu6tj9.cs(36,40): error CS0266: Cannot implicitly convert type ''long''
    to ''int''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp0vcu6tj9.cs(42,31): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        var list = paren_string.Split(new char[] { ' ', '(',\
    \ ')', '{', '}', '[' }).ToList();\n        list.Sort();\n        var stack = new\
    \ Stack<long>();\n        long count = 0;\n        foreach (var item in list)\
    \ {\n            if (item == \"(\") {\n                stack.Push(count++);\n\
    \            } else if (item == \")\") {\n                long pop = stack.Pop();\n\
    \                if (pop > 0) {\n                    list.Add(count - pop);\n\
    \                }\n            } else if (item == \"{\") {\n                list.Add(count\
    \ - 1);\n            } else if (item == \"}\") {\n                list.Add(count\
    \ + 1);\n            } else if (item == \"[\") {\n                list.Add(count\
    \ - 1);\n            } else if (item == \"]\") {\n                list.Add(count\
    \ + 1);\n            }\n        }\n        return list;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpo4caqeg6.cs(25,30): error CS1503: Argument 1: cannot convert from ''long''
    to ''string''

    /tmp/tmpo4caqeg6.cs(28,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''string''

    /tmp/tmpo4caqeg6.cs(30,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''string''

    /tmp/tmpo4caqeg6.cs(32,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''string''

    /tmp/tmpo4caqeg6.cs(34,26): error CS1503: Argument 1: cannot convert from ''long''
    to ''string''

    /tmp/tmpo4caqeg6.cs(37,16): error CS0029: Cannot implicitly convert type ''System.Collections.Generic.List<string>''
    to ''System.Collections.Generic.List<long>''

    '
  timestamp: 1659976357
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        return ParseNestedParens(paren_string, 0);\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2eby2wva.cs(15,16): error CS1501: No overload for method ''ParseNestedParens''
    takes 2 arguments

    '
  timestamp: 1659976357
