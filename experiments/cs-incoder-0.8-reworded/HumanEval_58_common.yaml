name: HumanEval_58_common
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return sorted unique common elements for two lists.\n    //\
  \ >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L,\
  \ (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L,\
  \ (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))\n    // (new List<long>(new\
  \ long[]{(long)1L, (long)5L, (long)653L}))\n    // >>> Common((new List<long>(new\
  \ long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L,\
  \ (long)2L})))\n    // (new List<long>(new long[]{(long)2L, (long)3L}))\n    public\
  \ static List<long> Common(List<long> l1, List<long> l2) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Common((new\
  \ List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L,\
  \ (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L,\
  \ (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L,\
  \ (long)5L, (long)653L}))));\n    Debug.Assert(Common((new List<long>(new long[]{(long)5L,\
  \ (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new\
  \ List<long>(new long[]{(long)2L, (long)3L}))));\n    Debug.Assert(Common((new List<long>(new\
  \ long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L,\
  \ (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));\n\
  \    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L,\
  \ (long)8L})), (new List<long>())).Equals((new List<long>())));\n    }\n\n}\n"
completions: ["        int minSize = Math.Min(l1.Count, l2.Count);\n        List<long>\
    \ common = new List<long>(minSize);\n        for (int i = 0; i < minSize; ++i)\
    \ {\n            if (l1.Contains(l2[i]) && l2.Contains(l1[i]))\n             \
    \   common.Add(l1[i]);\n        }\n        return common;", "        var common\
    \ = new List<long>();\n\n        foreach (var item in l1) {\n            if (l2.Contains(item))\
    \ {\n                common.Add(item);\n                l2.Remove(item);\n   \
    \         }\n        }\n\n        if (l2.Count == 0) return common;\n        return\
    \ Common(common, l2);", "        Debug.Assert(l1 != null && l2 != null && l1.Count\
    \ >= l2.Count, \"Both lists must have same length.\");\n\n        var result =\
    \ new List<long>(l1.Count);\n        var count = 0;\n        foreach (var i in\
    \ l1)\n        {\n            foreach (var j in l2)\n            {\n         \
    \       if (i == j)\n                    continue;\n                if (result.Contains(j))\n\
    \                    continue;\n                result[count++] = i;\n       \
    \     }\n        }\n        return result;", "        var l3 = new List<long>();\n\
    \        if (l1.Count < l2.Count) {\n            l2.CopyTo(l3, l2.Count);\n  \
    \      } else {\n            l1.CopyTo(l3, l1.Count);\n        }\n\n        return\
    \ l3.Distinct().ToList();", "        List<long> result = new List<long>();\n \
    \       foreach (long x in l1) {\n            bool found = false;\n          \
    \  foreach (long y in l2) {\n                if (x == y) {\n                 \
    \   found = true;\n                    break;\n                }\n           \
    \ }\n            if (!found) {\n                result.Add(x);\n            }\n\
    \        }\n        return result;", "        int n = l1.Count;\n        int m\
    \ = l2.Count;\n        if (n == 0)\n            return new List<long>();\n   \
    \     if (m == 0)\n            return new List<long>(l1);\n\n        List<long>\
    \ result = new List<long>();\n\n        Dictionary<long, bool> dict = new Dictionary<long,\
    \ bool>();\n        for (int i = 0; i < n; ++i)\n            dict.Add(l1[i], false);\n\
    \        for (int j = 0; j < m; ++j)\n            dict[l2[j]] = true;\n\n    \
    \    for (int i = 0; i < n; ++i) {\n            if (dict.ContainsKey(l2[i])) {\n\
    \                if (dict[i] == true)\n                    result.Add(l1[i]);\n\
    \                else\n                    dict[i] = false;\n            }\n \
    \       }\n        return result;", "        Debug.Assert(l1.Count == l2.Count);\n\
    \        Debug.Assert(l1.Count > 0);\n        Debug.Assert(l2.Count > 0);\n\n\
    \        var list = new List<long>();\n        var hash1 = Hash(l1);\n       \
    \ var hash2 = Hash(l2);\n\n        for (var index = 0; index < l1.Count; index++)\
    \ {\n            if (hash1.Contains(index) && hash2.Contains(index)) {\n     \
    \           list.Add(l1[index]);\n            }\n        }\n\n        return list;",
  "        var l3 = new List<long>();\n        var l1c = l1.Count;\n        var l2c\
    \ = l2.Count;\n        int i = 0;\n        while (i < l1c && i < l2c) {\n    \
    \        if (l1[i] == l2[i]) l3.Add(l1[i]);\n            else i++;\n        }\n\
    \        while (i < l1c) {\n            l3.Add(l1[i]);\n            i++;\n   \
    \     }\n        while (i < l2c) {\n            l3.Add(l2[i]);\n            i++;\n\
    \        }\n        l3.Sort();\n        return l3;", "        long common = 0;\n\
    \        long sum = 0;\n        long max = 0;\n        for (int i = 0; i < Math.Min(l1.Count,\
    \ l2.Count); i++) {\n            if (l1.Contains(i)) {\n                if (l2.Contains(i))\
    \ {\n                    common++;\n                    sum = l1.ElementAt(i)\
    \ + l2.ElementAt(i);\n                    if (sum > max) {\n                 \
    \       max = sum;\n                    }\n                }\n            }\n\
    \        }\n        return new List<long>(Enumerable.Range(Math.Max(l1.Count,\
    \ l2.Count), max - common));", "        if (l1 == null || l2 == null)\n      \
    \      return l1 == null ? l2 : l1;\n        if (l1.Count != l2.Count) {\n   \
    \         throw new ArgumentException(String.Format(\"List length mismatch: l1.Count={0},\
    \ l2.Count={1}\", l1.Count, l2.Count));\n        }\n        List<long> result\
    \ = new List<long>();\n        int i = 0;\n        while (i < l1.Count && i <\
    \ l2.Count) {\n            if (l1[i] == l2[i]) i++;\n            else if (l1[i]\
    \ < l2[i]) result.Add(l1[i]);\n            else result.Add(l2[i]);\n        }\n\
    \        if (i < l1.Count) result.AddRange(l1.Skip(i - 1));\n        if (i < l2.Count)\
    \ result.AddRange(l2.Skip(i - 1));\n        return result;", "        if (l1 ==\
    \ null || l2 == null || l1.Count != l2.Count) return null;\n        long result\
    \ = 1;\n        long smallest = l1.Min();\n        long largest = l1.Max();\n\
    \        foreach (long num in l1) {\n            if (num != smallest) result =\
    \ result * num;\n        }\n        foreach (long num in l2) {\n            if\
    \ (num != largest) result = result * num;\n        }\n        return new List<long>()\
    \ { result };", "        var result = new List<long>();\n        foreach(var a\
    \ in l1) {\n            foreach(var b in l2) {\n                if (a == b) continue;\n\
    \                if (result.Contains(b)) continue;\n                if (result.Contains(a))\
    \ continue;\n                result.Add(a);\n            }\n        }\n      \
    \  return result;", "        List<long> common = new List<long>();\n        foreach\
    \ (long i in l1)\n            foreach (long j in l2) {\n                if (i\
    \ == j)\n                    common.Add(i);\n            }\n        return common;",
  "        var result = new List<long>();\n        if (l1 == null || l2 == null ||\
    \ l1.Count != l2.Count) return result;\n        // Hash the lists using SHA256\n\
    \        SHA256 sha256Hash = new SHA256Managed();\n        var hashes1 = new byte[256\
    \ / 8];\n        var hashes2 = new byte[256 / 8];\n        l1.Select(x => { hashes1[x]\
    \ = sha256Hash.ComputeHash(x.ToByteArray()); }).ToArray();\n        l2.Select(x\
    \ => { hashes2[x] = sha256Hash.ComputeHash(x.ToByteArray()); }).ToArray();\n \
    \       // Compare hashes\n        bool foundCommon = false;\n        for (int\
    \ i = 0; i < hashes1.Length; ++i) {\n            for (int j = 0; j < hashes2.Length;\
    \ ++j) {\n                if (hashes1[i] == hashes2[j]) {\n                  \
    \  foundCommon = true;\n                    break;\n                }\n      \
    \      }\n            if (foundCommon) {\n                foundCommon = false;\n\
    \                break;\n            }\n        }\n        // Found common\n \
    \       if (foundCommon) {\n            for (int i = 0; i < hashes1.Length; ++i)\
    \ {\n                result.Add(hashes1[i]);\n            }\n        }\n     \
    \   return result;", "        List<long> result = new List<long>();\n        foreach\
    \ (var v1 in l1) {\n            foreach (var v2 in l2) {\n                if (v1\
    \ == v2)\n                {\n                    result.Add(v1);\n           \
    \     }\n            }\n        }\n        return result;", "        // Find the\
    \ smallest list that will hold the result (+1 for termination).\n        var length\
    \ = new List<long>(l1.Count + l2.Count);\n        foreach (var i in l1.Count)\
    \ {\n            length.Add(i + 1);\n        }\n        foreach (var j in l2.Count)\
    \ {\n            length.Add(j + 1);\n        }\n        // Sort the smaller list.\n\
    \        var sortedLength = length.Sort(new Comparison<long>((x, y) => x < y));\n\
    \        var result = new List<long>(sortedLength.Count * 2);\n        // Iterate\
    \ over the elements in the smaller list and add the result\n        // to the\
    \ larger list.\n        for (var i = 0; i < sortedLength.Count; ++i) {\n     \
    \       var a = l1.Count - length[i];\n            var b = l2.Count - length[i];\n\
    \            result.AddRange(l1.Take(a).Intersect(l2.Take(b)));\n        }\n \
    \       // Reverse the result to make it lexicographicaly.\n        return result.OrderByDescending(x\
    \ => x).ToList();", "        if (l1 == null || l2 == null || l1.Count != l2.Count)\n\
    \            return null;\n\n        var list = new List<long>(l1);\n        list.AddRange(l2);\n\
    \        list.RemoveAll(l1item => l2.Contains(l1item));\n        return list;",
  "        List<long> common = new List<long>(l1.Count);\n        int l1Pos = 0, l2Pos\
    \ = 0, commonPos = 0;\n        while (l1Pos < l1.Count || l2Pos < l2.Count) {\n\
    \            int i = 0;\n            if (l1Pos < l1.Count) i = l1[l1Pos++];\n\
    \            if (l2Pos < l2.Count) i = l2[l2Pos++];\n            if (i == 0) break;\n\
    \            if (commonPos == common.Count) common.Add((long)0);\n           \
    \ while (i == common[commonPos++]) {\n                if (commonPos == common.Count)\
    \ common.Add((long)0);\n            }\n            common[commonPos++] = i;\n\
    \        }\n        common.Sort();\n        return common;", "        var list\
    \ = new List<long>();\n        foreach (var item in l1) {\n            if (!l2.Contains(item))\
    \ list.Add(item);\n        }\n        return list;", "        List<long> ret =\
    \ new List<long>();\n        long[] arr1 = l1.ToArray();\n        long[] arr2\
    \ = l2.ToArray();\n        if (arr1.Length != arr2.Length) {\n            throw\
    \ new ArgumentException(\"List sizes differ.\");\n        }\n        // Sort lists\
    \ first to minimize comparisons.\n        Array.Sort(arr1);\n        Array.Sort(arr2);\n\
    \        int i = arr1.Length - 1;\n        int j = arr2.Length - 1;\n        while\
    \ (i >= 0 || j >= 0) {\n            if (arr1[i] == arr2[j]) {\n              \
    \  ret.Add(arr1[i]);\n                i--;\n                j--;\n           \
    \ } else if (arr1[i] < arr2[j]) {\n                i--;\n            } else {\n\
    \                j--;\n            }\n        }\n        if (i < 0) {\n      \
    \      throw new ArgumentException(\"List 1 contains more elements than list 2.\"\
    );\n        }\n        if (j < 0) {\n            throw new ArgumentException(\"\
    List 2 contains more elements than list 1.\");\n        }\n        return ret;",
  "        var l3 = new List<long>();\n        if (l1.Count != l2.Count) return l3;\n\
    \        foreach (var item in l1) {\n            if (l2.Contains(item)) {\n  \
    \              l3.Add(item);\n                l2.Remove(item);\n            }\n\
    \        }\n        if (l2.Count != 0) return l3;\n        return l3;", "    \
    \    var result = new List<long>();\n        foreach (var item in l1) {\n    \
    \        foreach (var item2 in l2) {\n                if (item == item2) {\n \
    \                   result.Add(item);\n                    break;\n          \
    \      }\n            }\n        }\n        return result;", "        List<long>\
    \ results = new List<long>();\n        bool l1cIsEmpty = l1.Count == 0;\n    \
    \    bool l2cIsEmpty = l2.Count == 0;\n        if (l1cIsEmpty && l2cIsEmpty)\n\
    \            return results;\n        if (l1cIsEmpty)\n            return l2;\n\
    \        if (l2cIsEmpty)\n            return l1;\n        foreach (var item in\
    \ l1) {\n            bool found = false;\n            foreach (var item2 in l2)\
    \ {\n                if (item == item2)\n                    found = true;\n \
    \           }\n            if (!found)\n                results.Add(item);\n \
    \       }\n        return results;", '        return Enumerable.SequenceEqual(l1.Intersect(l2).OrderBy(x
    => x)).Distinct().ToList();', "        List<long> common = new List<long>();\n\
    \        common.AddRange(l1.Intersect(l2));\n        common.AddRange(l2.Intersect(l1));\n\
    \        common.Sort();\n        return common;", "        int l = 0;\n      \
    \  HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long> set2 = new\
    \ HashSet<long>(l2);\n        List<long> ret = new List<long>();\n        while\
    \ (l1 < set1.Count) {\n            set1.Remove(l1);\n            if (set1.Count\
    \ == 0)\n                break;\n        }\n        while (l2 < set2.Count) {\n\
    \            set2.Remove(l2);\n            if (set2.Count == 0)\n            \
    \    break;\n        }\n        if (set1.Count == 0 && set2.Count == 0)\n    \
    \        return null;\n        if (set1.Count > 0 && set2.Count > 0)\n       \
    \     return null;\n        HashSet<long> both = set1.Intersect(set2).ToHashSet();\n\
    \        foreach (long x in both)\n            if (set.Add(x))\n             \
    \   ret.Add(x);\n        return ret;", "        if (l1 == null || l2 == null ||\
    \ l1.Count == 0 || l2.Count == 0) return new List<long>();\n        List<long>\
    \ unique = new List<long>();\n        for (int i = 0; i < l1.Count; i++) {\n \
    \           bool found = false;\n            bool inL2 = false;\n            foreach\
    \ (long l2element in l2) {\n                if (l1[i] == l2element) {\n      \
    \              found = true;\n                    inL2 = true;\n             \
    \       break;\n                }\n            }\n            if (!found) {\n\
    \                if (inL2) {\n                    unique.Add(l1[i]);\n       \
    \         }\n            }\n        }\n        return unique;", "        if (l1\
    \ == null || l2 == null)\n            return l1 == null ? l2 == null ? null :\
    \ l1.Intersect(l2) : l1.Except(l2);\n        long[] u1 = l1.Select(v => (long)v).Distinct().ToArray();\n\
    \        long[] u2 = l2.Select(v => (long)v).Distinct().ToArray();\n        u1.Sort();\n\
    \        u2.Sort();\n        List<long> res = new List<long>();\n        while\
    \ (u1.Any() && u2.Any()) {\n            long x = u1[0];\n            long y =\
    \ u2[0];\n            while (x > y)\n                u1.RemoveAt(0);\n       \
    \     while (x < y)\n                u2.RemoveAt(0);\n            if (x == y)\n\
    \                res.Add(x);\n            else\n                break;\n     \
    \   }\n        return res.Count == 1 ? res : Common(res.Except(new List<long>(res)),\
    \ new List<long>(res));", "        var set1 = new HashSet<long>(l1);\n       \
    \ var set2 = new HashSet<long>(l2);\n        var common = new List<long>(l1.Count);\n\
    \        foreach (var e in l1) {\n            if (set2.Contains(e)) {\n      \
    \          common.Add(e);\n                set1.Remove(e);\n            }\n  \
    \      }\n        foreach (var e in l2) {\n            if (!set1.Contains(e))\
    \ {\n                common.Add(e);\n                set2.Remove(e);\n       \
    \     }\n        }\n        return common;", "        if (l1 == null || l2 ==\
    \ null) {\n            return null;\n        }\n        HashSet<long> hs1 = new\
    \ HashSet<long>(l1);\n        HashSet<long> hs2 = new HashSet<long>(l2);\n   \
    \     return ls1.Except(ls2).ToList();", "        HashSet<long> h = new HashSet<long>();\n\
    \        List<long> result = new List<long>();\n\n        l1.ForEach(a => h.Add(a));\n\
    \        l2.ForEach(b => h.Add(b));\n\n        foreach(long val in h)\n      \
    \      result.Add(val);\n\n        return result;", "        List<long> res =\
    \ new List<long>();\n        HashSet<long> h1 = new HashSet<long>(l1);\n     \
    \   HashSet<long> h2 = new HashSet<long>(l2);\n        foreach (long i in h1)\n\
    \            if (h2.Contains(i)) res.Add(i);\n        return res;", "        int\
    \ n1 = l1.Count;\n        int n2 = l2.Count;\n        if (n1 > n2) return Common(l2,\
    \ l1);\n        else if (n2 > n1) return Common(l1, l2);\n        else if (n1\
    \ == n2) return new List<long>(l1);\n        List<long> common = new List<long>(n1);\n\
    \        int i, j;\n        long x;\n        for (i = 0; i < n1; i++) {\n    \
    \        x = l1[i];\n            for (j = i + 1; j < n2; j++) {\n            \
    \    if (l2[j] == x) common.Add(x);\n            }\n        }\n        return\
    \ common;", "        var lc = new List<long>();\n        foreach (var a in l1)\
    \ {\n            foreach (var b in l2) {\n                if (a == b)\n      \
    \              lc.Add(a);\n            }\n        }\n        return lc;", "  \
    \      Debug.Assert(l1 != null && l2 != null);\n        Debug.Assert(l1.Count\
    \ > 0 && l2.Count > 0);\n        if (l1 == null || l2 == null) return null;\n\
    \        Debug.Assert(l1.Count == l2.Count);\n        SortedList<long, int> l\
    \ = new SortedList<long, int>(l1.Count);\n        int index = 0;\n        int\
    \ i = 1;\n        while (i < l1.Count) {\n            long e = l1.ElementAt(i);\n\
    \            if (l2.Contains(e)) {\n                l.Add(e, 1);\n           \
    \     i++;\n            } else if (l.ContainsKey(e)) {\n                int count\
    \ = l.ElementAt(e);\n                if (count > 1) {\n                    l.Remove(e,\
    \ count);\n                } else {\n                    i++;\n              \
    \  }\n            } else {\n                i++;\n            }\n        }\n \
    \       Debug.Assert(i == l1.Count);\n        List<long> res = new List<long>();\n\
    \        foreach (KeyValuePair<long, int> el in l) {\n            if (el.Value\
    \ == 1) res.Add(el.Key);\n        }\n        return res;", "        HashSet<long>\
    \ common = new HashSet<long>();\n        foreach (var item in l1) {\n        \
    \    if (l2.Contains(item))\n                common.Add(item);\n        }\n  \
    \      return common.ToList();", "        List<long> common = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        while (i < l1.Count && j < l2.Count)\
    \ {\n            if (l1[i] == l2[j])\n                common.Add(l1[i]);\n   \
    \         else {\n                if (l1[i] < l2[j])\n                    i++;\n\
    \                else\n                    j++;\n            }\n        }\n  \
    \      while (i < l1.Count)\n            common.Add(l1[i]);\n        while (j\
    \ < l2.Count)\n            common.Add(l2[j]);\n        return common;", '        return
    l1.Intersect(l2).OrderBy(i => i).ToList();', "        Debug.Assert(l1.Count >=\
    \ l2.Count);\n\n        if (l1.Count == 0 || l2.Count == 0) {\n            return\
    \ new List<long>();\n        }\n\n        // Use a hash table to store count of\
    \ each element.\n        Dictionary<long, int> dict = new Dictionary<long, int>();\n\
    \        int commonCount = 0;\n        foreach (long item in l1) {\n         \
    \   if (!dict.ContainsKey(item)) {\n                dict[item] = 1;\n        \
    \        commonCount++;\n            } else {\n                dict[item]++;\n\
    \            }\n        }\n\n        foreach (long item in l2) {\n           \
    \ if (!dict.ContainsKey(item)) {\n                dict[item] = 1;\n          \
    \      commonCount++;\n            } else {\n                dict[item]++;\n \
    \           }\n        }\n\n        foreach (long item in dict) {\n          \
    \  if (dict[item] == commonCount) {\n                return new List<long>(dict.Keys.Where(key\
    \ => key == item).ToList());\n            }\n        }\n\n        return new List<long>();",
  "        long maxValue = long.MinValue;\n        long minValue = long.MaxValue;\n\
    \        int countValues = 0;\n        int index = 0;\n        long temp = 0;\n\
    \        foreach (long number in l1) {\n            if (number > maxValue) {\n\
    \                maxValue = number;\n            }\n        }\n        foreach\
    \ (long number in l2) {\n            if (number < minValue) {\n              \
    \  minValue = number;\n            }\n        }\n        Dictionary<long, bool>\
    \ l1Dic = new Dictionary<long, bool>();\n        Dictionary<long, bool> l2Dic\
    \ = new Dictionary<long, bool>();\n        List<long> result = new List<long>();\n\
    \        for (int i = 0; i < l1.Count; i++) {\n            l1Dic.Add(l1[i], false);\n\
    \        }\n        for (int i = 0; i < l2.Count; i++) {\n            l2Dic.Add(l2[i],\
    \ false);\n        }\n        foreach (long number in l1) {\n            countValues++;\n\
    \            l1Dic.Add(number, true);\n        }\n        foreach (long number\
    \ in l2) {\n            countValues++;\n            l2Dic.Add(number, true);\n\
    \        }\n        foreach (KeyValuePair<long, bool> pair1 in l1Dic) {\n    \
    \        if (pair1.Value) {\n                temp = pair1.Key;\n             \
    \   index = countValues;\n                while (true) {\n                   \
    \ if (!l2Dic.ContainsKey(temp)) {\n                        break;\n          \
    \          }\n                    if (l2Dic[temp]) {\n                       \
    \ result.Insert(index, temp);\n                        break;\n              \
    \      }\n                    temp = temp * 10;\n                    index++;\n\
    \                }\n            }\n        }\n        foreach (KeyValuePair<long,\
    \ bool> pair2 in l2Dic) {\n            if (pair2.Value) {\n                temp\
    \ = pair2.Key;\n                index = countValues;\n                while (true)\
    \ {\n                    if (!l1Dic.ContainsKey(temp)) {\n                   \
    \     break;\n                    }\n                    if (l1Dic[temp]) {\n\
    \                        result.Insert(index, temp);\n                       \
    \ break;\n                    }\n                    temp = temp * 10;\n     \
    \               index++;\n                }\n            }\n        }\n      \
    \  return result;", "        if (l1.Count != l2.Count) return null;\n\n      \
    \  List<long> result = new List<long>();\n        var set = new HashSet<long>(l1);\n\
    \        var iSet = new HashSet<long>(l2);\n        foreach (var item in set)\
    \ {\n            if (iSet.Contains(item)) {\n                result.Add(item);\n\
    \                iSet.Remove(item);\n            }\n        }\n\n        if (result.Count\
    \ != 0) return result;\n        return null;", "        var set = new HashSet<long>(l1);\n\
    \        l1.RemoveAll(item1 => !set.Contains(item1));\n        var ret = new List<long>();\n\
    \        foreach (var item2 in l2) {\n            if (!set.Contains(item2)) {\n\
    \                ret.Add(item2);\n            }\n        }\n        return ret;",
  "        List<long> common = new List<long>();\n        if (l1.Count != l2.Count)\
    \ {\n            return common;\n        }\n        int index = 0;\n        List<long>\
    \ hash = new List<long>(l2.Count);\n        l1.ForEach((l) => {\n            hash[index++]\
    \ = l;\n            int hashIndex = -1;\n            l2.ForEach((m) => {\n   \
    \             if (m == l) {\n                    hashIndex++;\n              \
    \  }\n            });\n            if (hashIndex >= 0) {\n                common.Add(l);\n\
    \                hash[hashIndex] = l;\n            }\n        });\n        return\
    \ common;", "        var l3 = new List<long>();\n        int i = 0;\n        while(i\
    \ < l1.Count && i < l2.Count) {\n            if(l1[i] == l2[i]) {\n          \
    \      l3.Add(l1[i]);\n                i++;\n            }\n            else if(i\
    \ == l1.Count) {\n                l3.AddRange(l2);\n                break;\n \
    \           }\n            else if(i == l2.Count) {\n                l3.AddRange(l1);\n\
    \                break;\n            }\n            else if(!l1[i].Equals(l2[i]))\
    \ {\n                break;\n            }\n            i++;\n        }\n    \
    \    return l3;", '        return l1.Intersect(l2).OrderBy(v => v).ToList();',
  "        List<long> ret = new List<long>();\n        long one = 1;\n        bool\
    \ hasCommon = false;\n        foreach (long x in l1) {\n            for (int i\
    \ = 0; i < l2.Count; i++) {\n                if (x == l2[i]) {\n             \
    \       if (hasCommon) { ret.Add(one); }\n                    ret.Add(x);\n  \
    \                  hasCommon = true;\n                }\n            }\n     \
    \       one++;\n        }\n        if (!hasCommon) { ret.Add(one); }\n       \
    \ return ret;", "        HashSet<long> common = new HashSet<long>();\n       \
    \ common.AddRange(l1);\n        common.AddRange(l2);\n        List<long> result\
    \ = new List<long>();\n        foreach (long i in common) {\n            if (!l1.Contains(i)\
    \ && !l2.Contains(i)) {\n                result.Add(i);\n            }\n     \
    \   }\n        return result.OrderBy(i => i).Distinct().ToList();", "        List<long>\
    \ result = new List<long>();\n        HashSet<long> h1 = new HashSet<long>(l1);\n\
    \        HashSet<long> h2 = new HashSet<long>(l2);\n        foreach (long x in\
    \ h1.Intersect(h2).OrderBy(x => x)) {\n            if (!h1.Contains(x) && !h2.Contains(x))\
    \ result.Add(x);\n        }\n        return result;", "        List<long> res\
    \ = new List<long>();\n\n        Dictionary<long, long> map = new Dictionary<long,\
    \ long>();\n        foreach (long i in l1) {\n            map.Add(i, 1);\n   \
    \     }\n        foreach (long i in l2) {\n            map[I] = map.ContainsKey(i)\
    \ ? map[i] : map.Count + 1;\n        }\n        foreach (KeyValuePair<long, long>\
    \ i in map) {\n            long count = i.Value;\n            while (map.ContainsKey(count))\
    \ {\n                map[i.Key] = map.ContainsKey(count) ? map[count] : map.Count\
    \ + 1;\n                count++;\n            }\n            res.Add(i.Key);\n\
    \        }\n\n        return res;", "        List<long> l3 = new List<long>();\n\
    \        foreach (long x in l1) {\n            if (l2.Contains(x))\n         \
    \       l3.Add(x);\n        }\n        return l3;", "        if (l1.Count != l2.Count)\
    \ throw new ArgumentException(\"Lists must be same size!\");\n        HashSet<long>\
    \ set = new HashSet<long>(l1);\n        foreach (long val in l2) {\n         \
    \   set.Add(val);\n        }\n        return new List<long>(set);", "        if\
    \ (l1 == null) throw new ArgumentNullException(\"l1\");\n        if (l2 == null)\
    \ throw new ArgumentNullException(\"l2\");\n        if (l1.Count < l2.Count) return\
    \ l1.Intersect(l2).ToList();\n        HashSet<long> hash1 = new HashSet<long>(l1);\n\
    \        HashSet<long> hash2 = new HashSet<long>(l2);\n        hash1.ExceptWith(hash2);\n\
    \        return hash1.ToList();", "        // Make two hash sets and insert all\
    \ the elements of the two lists into them.\n        HashSet<long> hs1 = new HashSet<long>(l1);\n\
    \        HashSet<long> hs2 = new HashSet<long>(l2);\n        // Add the elements\
    \ of one list to the other list if it isn't already there.\n        hs1.ExceptWith(hs2);\n\
    \        hs2.ExceptWith(hs1);\n        List<long> result = new List<long>();\n\
    \        // Get the elements in the same order\n        hs1.IntersectWith(hs2);\n\
    \        foreach (long e in hs1) {\n            result.Add(e);\n        }\n  \
    \      return result;", "        List<long> l3 = new List<long>();\n        foreach(var\
    \ x in l1.Union(l2)) {\n            if(!l3.Contains(x))\n                l3.Add(x);\n\
    \        }\n        return l3;", "        long l3 = new long();\n        long\
    \ l4 = 0;\n        List<long> l5 = new List<long>();\n        List<long> l6 =\
    \ new List<long>();\n        foreach (long e in l1) {\n            l3 = e;\n \
    \           bool b = false;\n            foreach (long f1 in l2) {\n         \
    \       l4 = f1;\n                if (l3 == l4)\n                    b = true;\n\
    \            }\n            if (b)\n                l5.Add(l3);\n        }\n \
    \       foreach (long e in l2) {\n            l3 = e;\n            bool b = false;\n\
    \            foreach (long f1 in l1) {\n                l4 = f1;\n           \
    \     if (l3 == l4)\n                    b = true;\n            }\n          \
    \  if (b)\n                l6.Add(l3);\n        }\n        List<long> l7 = l5.Intersect(l6);\n\
    \        return l7;", "        HashSet<long> h1 = new HashSet<long>(l1);\n   \
    \     HashSet<long> h2 = new HashSet<long>(l2);\n        return h1.Intersect(h2).ToList();",
  "        SortedDictionary<long, int> dict = new SortedDictionary<long, int>();\n\
    \        foreach (long i in l1)\n            dict.Add(i, 0);\n        foreach\
    \ (long i in l2)\n            dict[(int)i] += 1;\n        return dict.Keys.OrderBy(i\
    \ => dict[i])\n                         .Select(i => i).ToList();", "        //\
    \ First we sort the lists.\n        List<long> list1 = l1.OrderByDescending(x\
    \ => x).ToList();\n        List<long> list2 = l2.OrderByDescending(x => x).ToList();\n\
    \n        // The result is the intersection of the two lists.\n        List<long>\
    \ result = new List<long>();\n        foreach (long item in list1) {\n       \
    \     if (list2.Contains(item)) {\n                result.Add(item);\n       \
    \     }\n        }\n        return result;", "        Debug.Assert(l1.Count >\
    \ 0 && l2.Count > 0, \"List must have at least one item.\");\n        if (l1.Count\
    \ > l2.Count) return l1.Intersect(l2).ToList();\n        return l2.Intersect(l1).ToList();",
  "        if (l1.Count != l2.Count) return null;\n        var list = new List<long>();\n\
    \        foreach (long a in l1) foreach (long b in l2) {\n            if (a ==\
    \ b) list.Add(a);\n        }\n        list.Sort();\n        return list;", " \
    \       if (l1 == null || l2 == null)\n            return null;\n        HashSet<long>\
    \ h1 = new HashSet<long>(l1);\n        HashSet<long> h2 = new HashSet<long>(l2);\n\
    \        List<long> result = new List<long>();\n        foreach (long x in h1)\n\
    \            if (h2.Contains(x))\n                result.Add(x);\n        return\
    \ result;", "        var list = new List<long>();\n        foreach (var i in l1)\
    \ {\n            var found = false;\n            foreach (var j in l2) {\n   \
    \             if (i == j) {\n                    list.Add(i);\n              \
    \      found = true;\n                    break;\n                }\n        \
    \    }\n            if (!found)\n                list.Add(i);\n        }\n   \
    \     return list.Distinct().OrderBy(i => i).ToList();", "        var result =\
    \ l1.Intersect(l2).ToList();\n        return result.Count > 0 ? result.Distinct().ToList()\
    \ : null;", "        // http://blog.benhall.me.uk/post/2011/08/15/Understanding-the-How-HashSet-Works-with-Generics.aspx\n\
    \        List<long> result = new List<long>();\n\n        List<long> tmp = new\
    \ List<long>(l1.Count);\n        tmp.AddRange(l1);\n        tmp.AddRange(l2);\n\
    \        HashSet<long> hashSet = new HashSet<long>(tmp);\n\n        foreach (long\
    \ n in hashSet) {\n            if (result.Contains(n))\n                continue;\n\
    \            result.Add(n);\n        }\n        return result;", "        if (l1\
    \ == null) throw new ArgumentNullException(\"l1\");\n        if (l2 == null) throw\
    \ new ArgumentNullException(\"l2\");\n        if (l1.Count != l2.Count) throw\
    \ new ArgumentException(\"Number of lists must be the same\", \"l2\");\n     \
    \   if (l1 == l2) return l1;\n        HashSet<long> unique = new HashSet<long>(l1);\n\
    \        foreach (var item in l2) {\n            if (!unique.Contains(item)) unique.Add(item);\n\
    \        }\n        return unique.ToList();", "        List<long> ret = new List<long>();\n\
    \        HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long> set2\
    \ = new HashSet<long>(l2);\n        set1.IntersectWith(set2).CopyTo(ret, 0);\n\
    \        return ret;", "        // Use hashsets to remove duplicates\n       \
    \ HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long> set2 = new\
    \ HashSet<long>(l2);\n        // Remove items from the second list that are not\
    \ in the first\n        set2.ExceptWith(set1);\n        // Return the intersection\
    \ of the two sets\n        return set1.IntersectWith(set2).ToList();", "     \
    \   List<long> results = new List<long>(l1.Count);\n        for (int i = 0; i\
    \ < l1.Count; ++i) {\n            bool found = false;\n            for (int j\
    \ = 0; j < l2.Count; ++j) {\n                if (l1[i] == l2[j]) {\n         \
    \           found = true;\n                    break;\n                }\n   \
    \         }\n            if (!found) {\n                results.Add(l1[i]);\n\
    \            }\n        }\n        return results;", "        var l3 = new List<long>();\n\
    \        var l4 = new HashSet<long>();\n        foreach (var e in l1) {\n    \
    \        if (!l4.Contains(e)) {\n                l4.Add(e);\n                l3.Add(e);\n\
    \            }\n        }\n        foreach (var e in l2) {\n            if (!l4.Contains(e))\
    \ {\n                l4.Add(e);\n                l3.Add(e);\n            }\n \
    \       }\n        return l3.OrderBy(e => e).Distinct().ToList();", "        var\
    \ l3 = new List<long>();\n        l3.AddRange(l1);\n        l3.AddRange(l2);\n\
    \        return l3.Distinct().OrderBy(l => l).ToList();", "        if (l1 == null\
    \ || l2 == null || l1.Count < 1 || l2.Count < 1)\n            return null;\n \
    \       long[] a1 = l1.ToArray();\n        long[] a2 = l2.ToArray();\n       \
    \ List<long> res = new List<long>();\n        List<long> seen = new List<long>();\n\
    \        foreach (long x in a1) {\n            foreach (long y in a2) {\n    \
    \            if (x == y)\n                    continue;\n                if (seen.Contains(x))\n\
    \                    continue;\n                if (seen.Contains(y))\n      \
    \              continue;\n                seen.Add(x);\n                seen.Add(y);\n\
    \                res.Add(x);\n                res.Add(y);\n            }\n   \
    \     }\n        return res;", "        HashSet<long> set1 = new HashSet<long>(l1);\n\
    \        HashSet<long> set2 = new HashSet<long>(l2);\n        long[] common =\
    \ new long[set1.Count];\n        int count = 0;\n        foreach (long el1 in\
    \ set1) {\n            if (!set2.Contains(el1)) {\n                common[count++]\
    \ = el1;\n            }\n        }\n        return new List<long>(common);", " \
    \       List<long> l3 = new List<long>();\n        if (l1.Count != l2.Count) throw\
    \ new Exception(\"List lengths don't match\");\n        long l1_count = l1.Count;\n\
    \        long l2_count = l2.Count;\n        long common_count = l1.Intersect(l2).Count;\n\
    \        for (int i = 0; i < l1_count; i++) {\n            if (l2.Contains(l1[i]))\
    \ {\n                l3.Add(l1[i]);\n                l2.Remove(l1[i]);\n     \
    \           l1_count--;\n                if (l1_count == 0) break;\n         \
    \   }\n        }\n        if (common_count == l2_count) {\n            return\
    \ l3;\n        }\n        if (common_count < l2_count) throw new Exception(\"\
    List lengths don't match\");\n        for (int i = 0; i < l2_count; i++) {\n \
    \           if (l1.Contains(l2[i])) {\n                l3.Add(l2[i]);\n      \
    \          l1.Remove(l2[i]);\n                l2_count--;\n                if\
    \ (l2_count == 0) break;\n            }\n        }\n        if (common_count ==\
    \ l1_count) {\n            return l3;\n        }\n        throw new Exception(\"\
    List lengths don't match\");", "        if (l1 == null || l2 == null || l1.Count\
    \ == 0 || l2.Count == 0)\n            return null;\n        \n        long[] vals1\
    \ = l1.Select(v => (long)v).ToArray();\n        long[] vals2 = l2.Select(v =>\
    \ (long)v).ToArray();\n        Array.Sort(vals1);\n        Array.Sort(vals2);\n\
    \        \n        List<long> res = new List<long>();\n        \n        int startIndex\
    \ = 0;\n        int endIndex = vals1.Length;\n        \n        while (startIndex\
    \ < endIndex) {\n            int count = endIndex - startIndex;\n            int\
    \ pivotIndex = startIndex + (count / 2);\n            long pivot = vals1[pivotIndex];\n\
    \            long lowVal = vals1[startIndex];\n            long highVal = vals1[endIndex];\n\
    \            \n            for (int i = startIndex; i <= endIndex; i++)\n    \
    \        {\n                if (vals1[i] == pivot) {\n                    res.Add(vals1[i]);\n\
    \                    break;\n                }\n            }\n            \n\
    \            if (res.Count > 0)\n                break;\n            \n      \
    \      if (pivot == lowVal) {\n                startIndex = pivot + 1;\n     \
    \           endIndex = startIndex + count;\n            } else {\n           \
    \     startIndex = pivot - count;\n                endIndex = startIndex + 1;\n\
    \            }\n        }\n        \n        return res;", "        List<long>\
    \ common = new List<long>();\n        HashSet<long> set1 = new HashSet<long>(l1);\n\
    \        HashSet<long> set2 = new HashSet<long>(l2);\n        foreach (long i\
    \ in set1) {\n            if (set2.Contains(i)) {\n                common.Add(i);\n\
    \            }\n        }\n        return common;", "        var result = new\
    \ List<long>();\n        if (l1 == null || l2 == null) {\n            return result;\n\
    \        }\n        HashSet<long> hs1 = new HashSet<long>(l1);\n        HashSet<long>\
    \ hs2 = new HashSet<long>(l2);\n        hs1.IntersectWith(hs2);\n        hs2.IntersectWith(hs1);\n\
    \        foreach (long n in hs1) {\n            result.Add(n);\n        }\n  \
    \      foreach (long n in hs2) {\n            result.Add(n);\n        }\n    \
    \    return result;", "        if (l1 == null || l2 == null) {\n            return\
    \ null;\n        }\n\n        var list = new List<long>();\n        var set =\
    \ new HashSet<long>(l1);\n        foreach (var i in l2) {\n            if (set.Add(i))\
    \ {\n                list.Add(i);\n            }\n        }\n        return list;",
  "        HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long> set2\
    \ = new HashSet<long>(l2);\n\n        var result = new List<long>();\n       \
    \ foreach (long i in set1) {\n            if (set2.Contains(i)) {\n          \
    \      result.Add(i);\n            }\n        }\n\n        return result.OrderByDescending(x\
    \ => x).ToList();", "        List<long> ret = new List<long>();\n        bool\
    \ isAdd = true;\n        long max = 0;\n        int count = 0;\n\n        // Check\
    \ lists have same length.\n        if (l1.Count != l2.Count) {\n            return\
    \ ret;\n        }\n\n        // Check lists elements are all positive longs.\n\
    \        foreach (long item in l1) {\n            if (!Number.IsPositiveLong(item))\
    \ {\n                isAdd = false;\n                break;\n            }\n \
    \       }\n        foreach (long item in l2) {\n            if (!Number.IsPositiveLong(item))\
    \ {\n                isAdd = false;\n                break;\n            }\n \
    \       }\n        // If isAdd is true, then lists has same length and elements\
    \ are all positive longs.\n        if (isAdd) {\n            foreach (long item\
    \ in l1) {\n                max = Math.Max(item, max);\n            }\n      \
    \      foreach (long item in l2) {\n                max = Math.Max(item, max);\n\
    \            }\n        }\n        // Check lists elements are all unique longs.\n\
    \        foreach (long item in l1) {\n            if (l2.Contains(item)) {\n \
    \               ret.Add(item);\n                count++;\n            }\n    \
    \    }\n        // Check lists elements are not all unique longs.\n        foreach\
    \ (long item in l2) {\n            if (l1.Contains(item)) {\n                ret.Add(item);\n\
    \                count++;\n            }\n        }\n        // If count is bigger\
    \ than 1, then lists have same length and all elements were unique longs.\n  \
    \      if (count > 1) {\n            return ret;\n        } else {\n         \
    \   return new List<long>();\n        }", "        var l3 = new List<long>();\n\
    \        var hash1 = l1.ToHashSet(l => l);\n        var hash2 = l2.ToHashSet(l\
    \ => l);\n\n        foreach (var x in hash1) {\n            foreach (var y in\
    \ hash2) {\n                if (x == y)\n                    l3.Add(x);\n    \
    \        }\n        }\n        return l3;", "        SortedSet<long> ss = new\
    \ SortedSet<long>();\n        long commonElements = 0;\n        long minL1 = 0,\
    \ minL2 = 0;\n        if (l1.Count > l2.Count) minL2 = l1.Count; else minL1 =\
    \ l2.Count;\n        for (int i = 0; i < minL1; i++) {\n            long m1 =\
    \ l1[i];\n            long m2 = l2[i];\n            bool add = false;\n      \
    \      if (m1 < m2) {\n                add = true;\n                ss.add(m1);\n\
    \            } else {\n                add = true;\n                ss.add(m2);\n\
    \            }\n            if (add) commonElements += 1;\n        }\n       \
    \ if (commonElements == 0) return l1;\n        if (minL1 == minL2) return l1;\n\
    \        List<long> result = new List<long>();\n        for (int i = 0; i < minL2;\
    \ i++) {\n            long m1 = l1[i];\n            long m2 = l2[i];\n       \
    \     bool add = false;\n            if (m1 < m2) {\n                add = true;\n\
    \                result.Add(m1);\n            } else {\n                add =\
    \ true;\n                result.Add(m2);\n            }\n            if (add)\
    \ commonElements += 1;\n        }\n        if (commonElements == 0) return l2;\n\
    \        return result;", "        SortedDictionary<long, int> dict = new SortedDictionary<long,\
    \ int>();\n        foreach (long item in l1) {\n            if (!dict.ContainsKey(item))\
    \ {\n                dict[item] = 0;\n            }\n            dict[item] +=\
    \ 1;\n        }\n        foreach (long item in l2) {\n            if (!dict.ContainsKey(item))\
    \ {\n                dict[item] = 0;\n            }\n            dict[item] +=\
    \ 1;\n        }\n        List<long> ret = new List<long>();\n        foreach (KeyValuePair<long,\
    \ int> kvp in dict) {\n            if (kvp.Value == 1) {\n                ret.Add(kvp.Key);\n\
    \            }\n        }\n        return ret;", "        var r = new List<long>();\n\
    \        if (l1 == null || l2 == null) return r;\n        if (l1.Count > l2.Count)\
    \ {\n            var l = l1;\n            l1 = l2;\n            l2 = l;\n    \
    \    }\n        var a = l1.ToArray();\n        var b = l2.ToArray();\n       \
    \ var len = Math.Min(a.Length, b.Length);\n        for (int i = 0; i < len; i++)\
    \ {\n            if (a[i] != b[i]) r.Add(a[i]);\n        }\n        return r;",
  "        if (l1 == null || l2 == null) {\n            return l1;\n        }\n  \
    \      var unique = new List<long>();\n        unique.AddRange(l1);\n        unique.AddRange(l2);\n\
    \        unique.Sort();\n        List<long> ret = new List<long>();\n        List<long>\
    \ ret2 = new List<long>();\n        List<long> ret3 = new List<long>();\n    \
    \    List<long> ret4 = new List<long>();\n        List<long> ret5 = new List<long>();\n\
    \        foreach (var x in unique) {\n            if (l1.Contains(x)) {\n    \
    \            ret2.Add(x);\n            }\n            if (l2.Contains(x)) {\n\
    \                ret5.Add(x);\n            }\n        }\n        ret.AddRange(ret2);\n\
    \        ret.AddRange(ret5);\n        ret.Sort();\n        ret3.AddRange(ret);\n\
    \        return ret3;", "        var s = new HashSet<long>(l1);\n        foreach\
    \ (var item in l2) {\n            if (s.Contains(item)) {\n                s.Remove(item);\n\
    \            } else {\n                s.Add(item);\n            }\n        }\n\
    \        return s.ToList();", "        List<long> l3 = new List<long>(l1.Count);\n\
    \        l3.AddRange(l1);\n        l3.Sort();\n        l3.RemoveAll((x) => !l2.Contains(x));\n\
    \        Debug.Assert(l3.Count == l1.Count);\n        Debug.Assert(l3.Count ==\
    \ l2.Count);\n        return l3;", "        var l3 = (from i in l1\n         \
    \           from j in l2\n                    select ((i * 100) + j)).OrderBy(x\
    \ => x).Distinct().ToList();\n        return l3;", "        Debug.Assert(l1.Count\
    \ == l2.Count, \"Lists must be the same size\");\n\n        HashSet<long> hs =\
    \ new HashSet<long>(l1);\n        hs.ExceptWith(l2);\n        return hs.ToList();",
  "        var list = new List<long>();\n        if (l1 == null || l2 == null)\n \
    \           return list;\n        foreach (var item in l1) {\n            if (!list.Contains(item)\
    \ && l2.Contains(item))\n                list.Add(item);\n        }\n        return\
    \ list;", "        long[] a1 = l1.ToArray();\n        long[] a2 = l2.ToArray();\n\
    \        long[] b1 = new long[a1.Length];\n        long[] b2 = new long[a2.Length];\n\
    \        int i = 0;\n        int j = 0;\n        while (i < a1.Length && j < a2.Length)\
    \ {\n            if (a1[i] == a2[j]) {\n                b1[i++] = a1[i++];\n \
    \               b2[j++] = a2[j++];\n            } else if (a1[i] < a2[j]) {\n\
    \                b1[i++] = a1[i++];\n            } else {\n                b2[j++]\
    \ = a2[j++];\n            }\n        }\n        while (i < a1.Length) {\n    \
    \        b1[i++] = a1[i++];\n        }\n        while (j < a2.Length) {\n    \
    \        b2[j++] = a2[j++];\n        }\n        return new List<long>(b1.Concat(Array.AsReadOnly<long>(b2)));",
  "        long l = 0;\n        var list = new List<long>();\n        var list2 =\
    \ new List<long>();\n        if (l1 == null || l2 == null) return null;\n    \
    \    foreach (var v in l1.OrderBy(x => x)) {\n            list2.Add(v);\n    \
    \        l = v;\n        }\n        foreach (var v in l2.OrderBy(x => x)) {\n\
    \            if (list.Contains(l)) list.Remove(l);\n            list.Add(v);\n\
    \            l = v;\n        }\n        return list;", "        long n1 = l1.Count;\n\
    \        long n2 = l2.Count;\n        if (n1 < n2) {\n            int i1 = l1.IndexOfAny(l2);\n\
    \            if (i1 == -1) return l1;\n            int i2 = l2.IndexOfAny(l1);\n\
    \            return l1.GetRange(i1, i2 - i1 + 1).Distinct().ToList();\n      \
    \  }\n        if (n2 < n1) {\n            int i1 = l2.IndexOfAny(l1);\n      \
    \      if (i1 == -1) return l2;\n            int i2 = l1.IndexOfAny(l2);\n   \
    \         return l2.GetRange(i1, i2 - i1 + 1).Distinct().ToList();\n        }\n\
    \n        var result = l1.Intersect(l2).ToList();\n        if (result.Count >\
    \ 1) {\n            bool done = false;\n            int c = 0;\n            while\
    \ (done == false) {\n                done = true;\n                for (int i\
    \ = 0; i < result.Count - 1; i++) {\n                    int j = i + 1;\n    \
    \                if (result[i] == result[j]) {\n                        result\
    \ = result.Remove(j);\n                        c = c + 1;\n                  \
    \      done = false;\n                    }\n                }\n            }\n\
    \            return result.Take(c).ToList();\n        } else {\n            return\
    \ result.Distinct().ToList();\n        }", "        List<long> Common = new List<long>();\n\
    \        long Min = Math.Min(l1.Min(), l2.Min());\n        long Max = Math.Max(l1.Max(),\
    \ l2.Max());\n        for (long i = 0; i < Min; i++) {\n            for (long\
    \ j = Min; j < Max; j++) {\n                if (l1[i] == l2[j]) {\n          \
    \          if (Common.Contains(l1[i]) || Common.Contains(l2[j])) {\n         \
    \               Common.Remove(l1[i]);\n                        Common.Remove(l2[j]);\n\
    \                    } else {\n                        Common.Add(l1[i]);\n  \
    \                      Common.Add(l2[j]);\n                    }\n           \
    \     }\n            }\n        }\n        return Common;", "        List<long>\
    \ result = new List<long>();\n        foreach (var item in l1) {\n           \
    \ if (l2.Contains(item))\n                result.Add(item);\n        }\n     \
    \   return result.Distinct().OrderBy(item => item).ToList();", "        long max\
    \ = (long)Math.Max(l1.Max(), l2.Max());\n        int i = 0;\n        int j = 0;\n\
    \        List<long> result = new List<long>();\n\n        do {\n            while\
    \ (i < l1.Count && j < l2.Count && l1[i] < l2.[j]) {\n                i++;\n \
    \               j++;\n            }\n            if (i < l1.Count) {\n       \
    \         result.Add(l1[i]);\n                i++;\n            }\n          \
    \  if (j < l2.Count) {\n                result.Add(l2.[j]);\n                j++;\n\
    \            }\n        } while (i < l1.Count && j < l2.Count);\n        if (i\
    \ < l1.Count) result.AddRange(l1.Skip(i));\n        if (j < l2.Count) result.AddRange(l2.Skip(j));\n\
    \        return result.OrderBy(v => (int)(v % max)).ToList();", "        // Add\
    \ all elements from both lists.\n        var all = new List<long>();\n       \
    \ all.AddRange(l1);\n        all.AddRange(l2);\n        // Sort and remove duplicates.\n\
    \        all.Sort();\n        all.Distinct().ToList().ForEach(x => all.Remove(x));\n\
    \        // Return sorted list.\n        return all;", "        var set = new\
    \ HashSet<long>();\n        l1.ForEach(x => set.Add(x));\n        l2.ForEach(x\
    \ => set.Add(x));\n        return l1.Where(x => set.Contains(x))\n           \
    \       .Select(x => (long)x)\n                  .ToList();", "        var sortedL1\
    \ = l1.Distinct().OrderBy(e => e).ToList();\n        var sortedL2 = l2.Distinct().OrderBy(e\
    \ => e).ToList();\n        if (sortedL1.Count != sortedL2.Count) throw new ArgumentException();\n\
    \        var result = new List<long>();\n        foreach (var x in sortedL1) if\
    \ (sortedL2.Contains(x)) result.Add(x);\n        return result;", "        if\
    \ (l1.Count != l2.Count)\n            return new List<long>();\n        var result\
    \ = new List<long>();\n        for (int i = 0; i < Math.Min(l1.Count, l2.Count);\
    \ i++) {\n            if (l1.Count != l2.Count)\n                break;\n    \
    \        if (l1[i] == l2[i])\n                continue;\n            result.Add(l1[i]);\n\
    \            l2.Remove(l2[i]);\n            if (l2.Count == 0)\n             \
    \   break;\n        }\n        return result;", "        if (l1 == null || l2\
    \ == null) return null;\n        HashSet<long> set1 = new HashSet<long>(l1);\n\
    \        HashSet<long> set2 = new HashSet<long>(l2);\n        set1.ExceptWith(set2);\n\
    \        if (set1.Count == 0 || set2.Count == 0) return null;\n        List<long>\
    \ res = new List<long>();\n        for (long item : set1) {\n            bool\
    \ contains = false;\n            for (int i = 0; i < set2.Count; i++) {\n    \
    \            if (set2[i] == item) {\n                    contains = true;\n  \
    \                  break;\n                }\n            }\n            if (!contains)\
    \ res.Add(item);\n        }\n        return res;", "        List<long> result\
    \ = new List<long>();\n\n        if (l1 == null || l2 == null || l1.Count < 1\
    \ || l2.Count < 1) {\n            return result;\n        }\n\n        Array.Sort(l1);\n\
    \        Array.Sort(l2);\n\n        int i = 0, j = 0, k = 0;\n        while (i\
    \ < l1.Count && j < l2.Count) {\n            long a = l1[i];\n            long\
    \ b = l2[j];\n\n            if (a < b) {\n                i++;\n            }\
    \ else if (a > b) {\n                j++;\n            } else {\n            \
    \    // A & B are equal\n                // A & B are equal\n                result.Add(a);\n\
    \                i++;\n                j++;\n            }\n        }\n\n    \
    \    // Add the remaining elements from either list\n        while (i < l1.Count)\
    \ {\n            result.Add(l1[i]);\n            i++;\n        }\n\n        while\
    \ (j < l2.Count) {\n            result.Add(l2[j]);\n            j++;\n       \
    \ }\n\n        return result;", "        if (l1 == null || l2 == null) return\
    \ null;\n        var result = new List<long>();\n        foreach (var x in l1)\
    \ {\n            foreach (var y in l2) {\n                if (x == y) result.Add(x);\n\
    \            }\n        }\n        if (result.Count == 0) return null;\n     \
    \   return result;", "        HashSet<long> unique1 = new HashSet<long>(l1);\n\
    \        HashSet<long> unique2 = new HashSet<long>(l2);\n        List<long> common\
    \ = new List<long>();\n        foreach (long x in unique1) {\n            if (unique2.Contains(x))\
    \ {\n                common.Add(x);\n            }\n        }\n        return\
    \ common;", "        HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long>\
    \ set2 = new HashSet<long>(l2);\n        set1.IntersectWith(set2);\n        return\
    \ set1.ToList();", "        Debug.Assert(l1.Count > 0 && l2.Count > 0);\n    \
    \    var result = new List<long>();\n        foreach (var item in l1) {\n    \
    \        bool found = false;\n            foreach (var item2 in l2) {\n      \
    \          if (item2 == item) {\n                    found = true;\n         \
    \           break;\n                }\n            }\n            if (!found)\
    \ {\n                result.Add(item);\n            }\n        }\n        return\
    \ result.Distinct().ToList();", "        if (l1 == null || l2 == null || l1.Count\
    \ != l2.Count) {\n            return null;\n        }\n        var res = new List<long>();\n\
    \        foreach (var e in l1.Intersect(l2)) {\n            if (!res.Contains(e))\
    \ {\n                res.Add(e);\n            }\n        }\n        return res.OrderBy(i\
    \ => i).ToList();", "        var s = new List<long>();\n        foreach (var l\
    \ in l1)\n            s.Add(l);\n        foreach (var l in l2)\n            s.Remove(l);\n\
    \        return s.Distinct().ToList();", "        List<long> ret = new List<long>();\n\
    \        if (l1 == null) return ret;\n        if (l2 == null) return ret;\n\n\
    \        List<long> intersec = new List<long>();\n        foreach (long i in l1)\
    \ {\n            bool in = false;\n            foreach (long j in l2) {\n    \
    \            if (i == j) {\n                    in = true;\n                 \
    \   break;\n                }\n            }\n            if (!in) {\n       \
    \         intersec.Add(i);\n            }\n        }\n        foreach (long i\
    \ in intersec) {\n            ret.Add(i);\n        }\n        return ret;", " \
    \       if (l1 == null || l2 == null) return null;\n        var list = new List<long>(l1.Count);\n\
    \        foreach (var i in l1) {\n            foreach (var j in l2) {\n      \
    \          if (i == j) list.Add(j);\n            }\n        }\n        return\
    \ list;", "        var result = new List<long>();\n        long max = 0, max2\
    \ = 0;\n        foreach (long i in l1) {\n            if (l2.Contains(i))\n  \
    \              result.Add(i);\n            else\n                break;\n    \
    \    }\n        foreach (long i in l2) {\n            if (l1.Contains(i))\n  \
    \              result.Add(i);\n            else\n                break;\n    \
    \    }\n        return result.ToList();", "        // Write your code here.\n\
    \        Dictionary<long, long> aDict = new Dictionary<long, long>();\n      \
    \  foreach (var item in l1) {\n            aDict.Add(item, 0);\n        }\n  \
    \      foreach (var item in l2) {\n            if (!aDict.ContainsKey(item)) {\n\
    \                aDict.Add(item, item);\n            }\n        }\n        List<long>\
    \ aList = new List<long>();\n        foreach (var item in aDict) {\n         \
    \   if (aList.Contains(item.Value)) {\n                continue;\n           \
    \ }\n            aList.Add(item.Value);\n        }\n        aList.RemoveAll(aList.Contains);\n\
    \        return aList;", "        if (l1.Count < 1 || l2.Count < 1) return new\
    \ List<long>();\n        List<long> common = new List<long>();\n        foreach(var\
    \ a in l1) {\n            foreach(var b in l2) {\n                if (a.Equals(b))\
    \ common.Add(b);\n            }\n        }\n        return common;", "       \
    \ if (l1 == null || l2 == null) return null;\n        long max;\n        if (l1.Count\
    \ == l2.Count) {\n            max = l1.Max();\n            return l1.Where(l =>\
    \ l2 == l).Where(l => l < max).OrderBy(l => l).ToList();\n        }\n        if\
    \ (l1.Count > l2.Count) {\n            max = l2.Max();\n            return l1.Where(l\
    \ => l2 == l).Where(l => l < max).OrderBy(l => l).ToList();\n        }\n     \
    \   max = l1.Max();\n        return l2.Where(l => l1 == l).Where(l => l < max).OrderBy(l\
    \ => l).ToList();", "        long tmp = 0;\n        long result = 0;\n       \
    \ foreach (long num in l1)\n            tmp += num;\n        foreach (long num\
    \ in l2)\n            tmp -= num;\n        if (tmp == 0)\n            result =\
    \ null;\n        else\n            result = tmp;\n        List<long> ret = new\
    \ List<long>();\n        ret.Add(result);\n        return ret;", "        var\
    \ i1 = 0, i2 = 0;\n        var n1 = l1.Count;\n        var n2 = l2.Count;\n  \
    \      var res = new List<long>();\n        long n = 0;\n        while (true)\
    \ {\n            if (i1 == n1) return res;\n            if (i2 == n2) return res;\n\
    \            n = ((l1[i1] == l2[i2]) ? n1[i1] : n2[i2]);\n            if (n !=\
    \ 0) res.Add(n);\n            ++i1;\n            if (i1 == n1) break;\n      \
    \      ++i2;\n        }\n        return res;", "        if (l1 == null || l2 ==\
    \ null || l1.Count == 0 || l2.Count == 0 || l1.Count == 0 || l2.Count == 0)\n\
    \            return null;\n        List<long> res = new List<long>();\n      \
    \  int[] num1 = Enumerable.Range(0, l1.Count).ToArray();\n        int[] num2 =\
    \ Enumerable.Range(0, l2.Count).ToArray();\n        Array.Sort(num1);\n      \
    \  Array.Sort(num2);\n        long max1 = 0, max2 = 0;\n        for (int i = 0;\
    \ i < l1.Count; i++) {\n            long n = num1[i];\n            if (n < max1)\
    \ {\n                if (l2.Contains(n))\n                    res.Add(n);\n  \
    \              else {\n                    max2 = max1;\n                }\n \
    \           }\n            else {\n                if (l2.Contains(n))\n     \
    \               max2 = n;\n                else\n                    max2 = max1;\n\
    \            }\n        }\n        foreach (int x in num2) {\n            if (x\
    \ < max2)\n                res.Add(x);\n        }\n        return res;", "   \
    \     // Return sorted unique common elements for two lists.\n        long[] u1\
    \ = l1.ToArray();\n        long[] u2 = l2.ToArray();\n        List<long> cList\
    \ = new List<long>();\n        HashSet<long> hset = new HashSet<long>();\n   \
    \     foreach (long i in u1.Where(i => !hset.Add(i)).OrderBy(i => i)) {\n    \
    \        if (!u2.Contains(i)) {\n                cList.Add(i);\n            }\n\
    \        }\n        return cList;", "        // Only run this if there are at\
    \ least two elements.\n        if (l1.Count < 1 || l2.Count < 1)\n           \
    \ return new List<long>();\n\n        // Create an empty dictionary.\n       \
    \ var dict = new Dictionary<long, List<long>>();\n\n        // Add all of the\
    \ common elements to the dictionary.\n        foreach (long e in l1) {\n     \
    \       List<long> v;\n            if (!dict.TryGetValue(\n                  \
    \  e, out v)) {\n                dict.Add(e, (v = new List<long>()));\n      \
    \      }\n            v.Add(e);\n        }\n        foreach (long e in l2) {\n\
    \            List<long> v;\n            if (!dict.TryGetValue(\n             \
    \       e, out v)) {\n                dict.Add(e, (v = new List<long>()));\n \
    \           }\n            v.Add(e);\n        }\n\n        // Sort the dictionaries\
    \ by value.\n        var list = dict.OrderByDescending(pair => pair.Value.Count);\n\
    \n        // Return the top element from the list.\n        var result = list\n\
    \            .First(pair => pair.Value.Count > 1)\n            .Key;\n       \
    \ return new List<long>() { result };", "        var sorted1 = l1.OrderBy(a =>\
    \ a).ToList();\n        var sorted2 = l2.OrderBy(a => a).ToList();\n        var\
    \ result = new List<long>();\n        foreach (var item in sorted1) {\n      \
    \      var found = false;\n            foreach (var item2 in sorted2) {\n    \
    \            if (item.Equals(item2)) {\n                    found = true;\n  \
    \                  break;\n                }\n            }\n            if (found)\
    \ {\n                result.Add(item);\n            }\n        }\n        return\
    \ result;", "        if (l1.Count != l2.Count) throw new ArgumentException(\"\
    Can't compare lists with different lengths.\");\n\n        var result = new List<long>();\n\
    \        foreach (var i1 in l1)\n        {\n            foreach (var i2 in l2)\n\
    \            {\n                if (i1 == i2)\n                {\n           \
    \         result.Add(i1);\n                    l2.Remove(i2);\n              \
    \  }\n            }\n        }\n        result.AddRange(l2);\n\n        return\
    \ result;", "        if (l1 == null || l2 == null || l1.Count != l2.Count) return\
    \ new List<long>();\n        var map = new Dictionary<long, long>();\n       \
    \ foreach (var item in l1) map[item] = 1;\n        foreach (var item in l2) map[item]\
    \ = 1;\n        var result = new List<long>();\n        foreach (var key in map.Keys)\
    \ if (map.ContainsKey(key) && key.Equals(map[key]))\n            result.Add(key);\n\
    \        return result;", "        if (l1 == null || l2 == null || l1.Count !=\
    \ l2.Count) {\n            return null;\n        }\n        List<long> ret = new\
    \ List<long>();\n        HashSet<long> set = new HashSet<long>(l1);\n        foreach\
    \ (long x in l2) {\n            if (!set.Contains(x)) {\n                ret.Add(x);\n\
    \                set.Add(x);\n            }\n        }\n        return ret;",
  "        if (l1 == null) {\n            return l2;\n        }\n        if (l2 ==\
    \ null) {\n            return l1;\n        }\n        HashSet<long> hset = new\
    \ HashSet<long>();\n        foreach (long a in l1) {\n            if (!hset.Contains(a))\
    \ {\n                hset.Add(a);\n            }\n        }\n        List<long>\
    \ result = new List<long>();\n        foreach (long a in l2) {\n            if\
    \ (!hset.Contains(a)) {\n                result.Add(a);\n            }\n     \
    \   }\n        return result.OrderBy(a => a).ToList();", "        List<long> ret\
    \ = new List<long>();\n        l1.ForEach(delegate (long x) {\n            l2.Remove(x);\n\
    \            if (!ret.Contains(x)) ret.Add(x);\n        });\n        l2.ForEach(delegate\
    \ (long x) {\n            l1.Remove(x);\n            if (!ret.Contains(x)) ret.Add(x);\n\
    \        });\n        return ret;", "        var result = new List<long>();\n\
    \        if (l1 == null || l2 == null)\n            return result;\n        long\
    \ maxValue = l1.Count > l2.Count ? l1.Count : l2.Count;\n        // For all elements\
    \ in each list, if the current value is larger than the biggest value seen so\
    \ far...\n        for (var index = 0; index < maxValue; index++)\n           \
    \ if (l1[index] > l2[index]) \n                result.Add(l1[index]);\n      \
    \      else if (l2[index] > l1[index])\n                result.Add(l2[index]);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ l = new HashSet<long>();\n        foreach (var x in l1)\n            l.Add(x);\n\
    \        foreach (var x in l2) {\n            if (l.Contains(x))\n           \
    \     result.Add(x);\n        }\n        return result;", "        if (l1 == null\
    \ || l2 == null)\n            return null;\n        if (l1.Count != l2.Count)\n\
    \            return null;\n\n        List<long> ret = new List<long>();\n    \
    \    long[] arr = l1.ToArray();\n        foreach (long a in arr) {\n         \
    \   long b = l2.FirstOrDefault(x => x != a && l2.Contains(x));\n            if\
    \ (b != null)\n                ret.Add(b);\n        }\n        return ret;", " \
    \       if (l1 == null || l2 == null)\n            return l1 == null ? l2 : l1;\n\
    \        Debug.Assert(l1.Count == l2.Count, \"Two lists have different size.\"\
    );\n        int N = l1.Count;\n        var result = new List<long>();\n      \
    \  for (int i = 0; i < N; i++)\n        {\n            bool found = false;\n \
    \           for (int j = 0; j < N; j++)\n            {\n                if (l1[i]\
    \ == l2[j])\n                {\n                    found = true;\n          \
    \          break;\n                }\n            }\n            if (!found)\n\
    \            {\n                result.Add(l1[i]);\n            }\n        }\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     foreach(long n in l1) {\n            if (!l2.Contains(n)) {\n          \
    \      result.Add(n);\n            }\n        }\n        foreach(long n in l2)\
    \ {\n            if (!l1.Contains(n)) {\n                result.Add(n);\n    \
    \        }\n        }\n        return result.Distinct().OrderBy(n => n).ToList();",
  "        if (l1 == null)\n            return l2;\n        if (l2 == null)\n    \
    \        return l1;\n        List<long> result = new List<long>();\n        foreach\
    \ (long i in l1)\n            if (l2.Contains(i))\n                result.Add(i);\n\
    \        foreach (long i in l2)\n            if (l1.Contains(i))\n           \
    \     result.Add(i);\n        return result;", "        if (l1 == null || l2 ==\
    \ null) {\n            return null;\n        }\n\n        var l = new List<long>();\n\
    \n        if (l1.Count != l2.Count) {\n            return null;\n        }\n\n\
    \        // Sorted first list\n        l1 = l1.OrderBy(x => x).ToList();\n   \
    \     // Sorted second list\n        l2 = l2.OrderBy(x => x).ToList();\n\n   \
    \     for (int i = 0; i < l1.Count; ++i) {\n            if (l2.Contains(l1[i]))\
    \ {\n                l.Add(l1[i]);\n                l2.Remove(l1[i]);\n      \
    \      }\n        }\n\n        if (l2.Count > 0) {\n            return Common(l1,\
    \ l2);\n        }\n\n        return l.Distinct().ToList();", "        if (l1 ==\
    \ null || l2 == null)\n            return null;\n        HashSet<long> set1 =\
    \ new HashSet<long>(l1);\n        HashSet<long> set2 = new HashSet<long>(l2);\n\
    \        long[] common = new long[set1.Count < set2.Count ? set1.Count : set2.Count];\n\
    \        int j = 0;\n        while (j < common.Length) {\n            if (set1.Contains(set2[j]))\
    \ {\n                common[j] = set1.Contains(set2[j]) ? set1[set1.IndexOf(set2[j])]\
    \ : set2[j];\n            } else {\n                common[j] = set2[j];\n   \
    \         }\n            j++;\n        }\n        return set1.Count < set2.Count\
    \ ? new List<long>(common) : common;", "        List<long> result = new List<long>();\n\
    \        for (int i = 0; i < l1.Count && i < l2.Count; i++) {\n            if\
    \ (l1.ElementAt(i) == l2.ElementAt(i)) {\n                result.Add(l1.ElementAt(i));\n\
    \            }\n        }\n        return result;", '        return l1.Intersect(l2).Distinct().OrderBy(x
    => x).ToList();', "        List<long> ret = new List<long>();\n        foreach\
    \ (long v in l1) {\n            ret.AddRange(l2.Where(w => w == v).ToList());\n\
    \        }\n        ret.Sort();\n        return ret;", "        if (l1 == null\
    \ && l2 == null)\n            return null;\n        if (l1 == null)\n        \
    \    return l2;\n        if (l2 == null)\n            return l1;\n\n        var\
    \ l3 = new List<long>();\n        var count = 0;\n        foreach (var v in l1.Union(l2))\n\
    \            if (l3.Contains(v)) {\n                count++;\n               \
    \ continue;\n            }\n            l3.Add(v);\n            count++;\n   \
    \     // If the number of elements in l1 is greater than the number of elements\
    \ in l2, return l1.\n        if (l1.Count > l2.Count)\n            return l1;\n\
    \        // If the number of elements in l2 is greater than the number of elements\
    \ in l1, return l2.\n        if (l2.Count > l1.Count)\n            return l2;\n\
    \        if (count == 0)\n            return null;\n        return l3;", "   \
    \     long l1f;\n        long l2f;\n        long l1f2 = l1.Count * l2.Count;\n\
    \        long l2f2 = l2.Count * l1.Count;\n        long l1f3 = l1f2 - l1f;\n \
    \       long l2f3 = l2f2 - l2f;\n        if (l1f3 == 0) return l1.OrderBy(l =>\
    \ l).ToList();\n        if (l2f3 == 0) return l2.OrderBy(l => l).ToList();\n \
    \       long[] v1 = new long[l1f3];\n        long[] v2 = new long[l2f3];\n   \
    \     long k = 0;\n        for (int i = 0; i < l1f.Length; ++i) {\n          \
    \  l1f = l1[i];\n            for (int j = 0; j < l2f.Length; ++j) {\n        \
    \        l2f = l2[j];\n                for (int n = 0; n < l1f.Length; ++n) {\n\
    \                    v1[n] = v1[n] + (v1[n] - l1f) * l1f2;\n                 \
    \   v2[n] = v2[n] + (v2[n] - l2f) * l2f2;\n                    ++k;\n        \
    \        }\n            }\n        }\n        for (int i = 0; i < l2f.Length;\
    \ ++i) {\n            l2f = l2[i];\n            for (int j = 0; j < l1f.Length;\
    \ ++j) {\n                l1f = l1[j];\n                for (int n = 0; n < l2f.Length;\
    \ ++n) {\n                    v1[n] = v1[n] + (v1[n] - l2f) * l2f2;\n        \
    \            v2[n] = v2[n] + (v2[n] - l1f) * l1f2;\n                    ++k;\n\
    \                }\n            }\n        }\n        List<long> ret = new List<long>(k);\n\
    \        int j = 0;\n        for (int i = 0; i < v1[Math.Min(l1f3, l2f3)].Length;\
    \ ++i) {\n            if (v1[Math.Min(l1f3, l2f3)][i] < v2[Math.Min(l1f3, l2f3)][i])\
    \ {\n                ret.Add((long)Math.Min(l1f3, l2f3));\n                ++j;\n\
    \            } else {\n                ret.Add((long)Math.Min(l2f3, l1f3));\n\
    \                ++j;\n            }\n        }\n        return ret;", "     \
    \   if (l1 == null || l2 == null || l1.Count != l2.Count)\n            return\
    \ null;\n        long[] a = new long[l1.Count];\n        long[] b = new long[l2.Count];\n\
    \        for (int i = 0; i < a.Length; i++)\n            a[i] = l1[i];\n     \
    \   for (int i = 0; i < b.Length; i++)\n            b[i] = l2[i];\n        Array.Sort(a,\
    \ b);\n        List<long> result = new List<long>();\n        for (int i = 0;\
    \ i < b.Length; i++) {\n            if (a[i]==b[i])\n                continue;\n\
    \            if (result.Count < i)\n                result.Add(b[i]);\n      \
    \      else if (result[i] == b[i])\n                result.RemoveAt(i);\n    \
    \    }\n        return result;", "        var common = new List<long>();\n   \
    \     var l = new List<long>(l1);\n        l.AddRange(l2);\n        l.Sort();\n\
    \        foreach (var v in l) common.Add(v);\n        return common;", "     \
    \   int n = l1.Count;\n        if (l2.Count != n) {\n            throw new ArgumentException(\"\
    List sizes don't match!\");\n        }\n        int ret = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            long val1 = l1.ElementAt(i);\n           \
    \ long val2 = l2.ElementAt(i);\n            if (val1 != val2)\n              \
    \  ret++;\n        }\n        if (n == ret) {\n            List<long> ret2 = new\
    \ List<long>();\n            for (int i = 0; i < n; i++) {\n                long\
    \ val1 = l1.ElementAt(i);\n                long val2 = l2.ElementAt(i);\n    \
    \            if (val1 == val2)\n                    ret2.Add(val1);\n        \
    \    }\n            return ret2;\n        }\n        if (n == 1) {\n         \
    \   return l1;\n        }\n        List<long> ret3 = new List<long>();\n     \
    \   for (int i = 0; i < n; i++) {\n            long val1 = l1.ElementAt(i);\n\
    \            long val2 = l2.ElementAt(i);\n            if (val1 == val2)\n   \
    \             ret3.Add(val1);\n        }\n        return ret3;", "        var\
    \ d = new SortedDictionary<long, long>();\n        for (int i = 0; i < Math.Min(l1.Count,\
    \ l2.Count); i++) {\n            d.Add(l1[i], l2[i]);\n        }\n        return\
    \ d.Keys.ToList();", "        if (l1 == null || l2 == null || l1.Count == 0 ||\
    \ l2.Count == 0 || l1.Count != l2.Count) {\n            return l1;\n        }\n\
    \        long[] a = new long[l1.Count];\n        long[] b = new long[l2.Count];\n\
    \        for (int i = 0; i < a.Length; i++) {\n            a[i] = l1.ElementAt(i);\n\
    \        }\n        for (int i = 0; i < b.Length; i++) {\n            b[i] = l2.ElementAt(i);\n\
    \        }\n        Array.Sort(a);\n        Array.Sort(b);\n        int i = 0;\n\
    \        int j = 0;\n        List<long> ret = new List<long>();\n        while\
    \ (i != a.Length && j != b.Length) {\n            if (a[i] == b[j]) {\n      \
    \          ret.Add(a[i]);\n                i++;\n                j++;\n      \
    \      } else if (a[i] < b[j]) {\n                i++;\n            } else {\n\
    \                j++;\n            }\n        }\n        if (i != a.Length) {\n\
    \            foreach (var item in l1.Skip(i)) {\n                ret.Add(item);\n\
    \            }\n        }\n        if (j != b.Length) {\n            foreach (var\
    \ item in l2.Skip(j)) {\n                ret.Add(item);\n            }\n     \
    \   }\n        return ret;", "        var l3 = new List<long>();\n        bool\
    \ found = false;\n        long firstVal, l1Val, l2Val;\n        foreach (var i\
    \ in l1) {\n            firstVal = i;\n            found = false;\n          \
    \  foreach (var j in l2) {\n                l2Val = j;\n                if (l1Val\
    \ < l2Val) {\n                    found = true;\n                    break;\n\
    \                }\n            }\n            if (found) {\n                l3.Add(firstVal);\n\
    \            }\n        }\n        return l3;", "        var i1 = l1.GetEnumerator();\n\
    \        var i2 = l2.GetEnumerator();\n        while (i1.MoveNext()) {\n     \
    \       if (i2.MoveNext())\n                return i1.Current\n              \
    \      .GetIntersection(i2.Current)\n                    .ToList();\n        }\n\
    \        return i2.Current\n            .ToList();", "        var common = new\
    \ List<long>();\n        var i = 0;\n        var j = 0;\n        foreach (var\
    \ v in l1.Where(x => l2.Contains(x))) common.Add(v);\n        foreach (var v in\
    \ l2.Where(x => l1.Contains(x))) common.Add(v);\n        if (l1.Count != l2.Count)\
    \ common.AddRange(l1.Except(l2));\n        if (l2.Count != l1.Count) common.AddRange(l2.Except(l1));\n\
    \        return common;", "        HashSet<long> set1 = new HashSet<long>(l1);\n\
    \        HashSet<long> set2 = new HashSet<long>(l2);\n        foreach (long l\
    \ in set1) {\n            if (!set2.Contains(l)) {\n                set1.Remove(l);\n\
    \            } else {\n                set2.Remove(l);\n            }\n      \
    \  }\n        foreach (long l in set2) {\n            if (!set1.Contains(l)) {\n\
    \                set2.Remove(l);\n            } else {\n                set1.Remove(l);\n\
    \            }\n        }\n        return set1.Union(set2).ToList();", "     \
    \   HashSet<long> h1 = new HashSet<long>(l1);\n        HashSet<long> h2 = new\
    \ HashSet<long>(l2);\n        List<long> l31 = new List<long>(h1);\n        l31.Sort();\n\
    \        List<long> l32 = new List<long>(h2);\n        l32.Sort();\n        List<long>\
    \ l33 = new List<long>(h1.Intersect(h2).ToList());\n        l33.Sort();\n    \
    \    l33.RemoveAll(l31 != l32);\n        l33.Sort();\n        return l33;", " \
    \       if (l1 == null || l2 == null) {\n            return null;\n        }\n\
    \        if (l1.Count < l2.Count) {\n            l1 = l1.Take(l2.Count).ToList();\n\
    \        }\n        if (l2.Count < l1.Count) {\n            l2 = l2.Take(l1.Count).ToList();\n\
    \        }\n        if (l1.Count == 0) {\n            return l2;\n        }\n\
    \        if (l2.Count == 0) {\n            return l1;\n        }\n\n        if\
    \ (l1.Count == l2.Count) {\n            List<long> res = new List<long>(l1.Count);\n\
    \            for (int i = 0; i < l1.Count; i++) {\n                if (l1[i] ==\
    \ l2[i]) {\n                    res.Add(l1[i]);\n                }\n         \
    \   }\n            return res;\n        }\n\n        List<long> res = new List<long>(l2.Count);\n\
    \        for (int i = 0; i < l2.Count; i++) {\n            bool contained = false;\n\
    \            for (int j = 0; j < l1.Count; j++) {\n                if (l1[j] ==\
    \ l2[i]) {\n                    res.Add(l1[j]);\n                    contained\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if (!contained) {\n                res.Add(l2[i]);\n            }\n \
    \       }\n        return res;", "        HashSet<long> hs1 = new HashSet<long>(l1);\n\
    \        HashSet<long> hs2 = new HashSet<long>(l2);\n        List<long> result\
    \ = new List<long>();\n        foreach (long n in hs1.Intersect(hs2)) {\n    \
    \        if (hs2.Contains(n)) {\n                hs2.Remove(n);\n            }\
    \ else {\n                result.Add(n);\n            }\n        }\n        hs1.Clear();\n\
    \        hs2.Clear();\n        foreach (long n in hs1) {\n            if (!hs2.Contains(n))\
    \ {\n                result.Add(n);\n            }\n        }\n        return\
    \ result;", "        if (l1 == null || l2 == null) return null;\n        HashSet<long>\
    \ hs = new HashSet<long>(l1);\n        l1.Sort();\n        l2.Sort();\n      \
    \  bool found = false;\n        while (!found && l1.Count > 0) {\n           \
    \ found = true;\n            HashSet<long> hs2 = new HashSet<long>(l2);\n    \
    \        foreach (long value in l1) {\n                if (!hs.Contains(value))\
    \ {\n                    found = false;\n                    break;\n        \
    \        }\n                hs2.Remove(value);\n            }\n            if\
    \ (found)\n                foreach (long value in hs2)\n                    hs.Add(value);\n\
    \        }\n        l1.Sort();\n        l2.Sort();\n        List<long> ret = new\
    \ List<long>();\n        HashSet<long> hs_ret = new HashSet<long>(ret);\n    \
    \    hs.Sort();\n        foreach (long value in l1) {\n            if (hs.Contains(value))\
    \ {\n                hs_ret.Add(value);\n                l2.Remove(value);\n \
    \           }\n        }\n        hs.Sort();\n        foreach (long value in hs2)\n\
    \            hs_ret.Add(value);\n        return ret; // l1.Union(hs_ret).ToList();",
  "        Debug.Assert(l1.Count >= l2.Count);\n        SortedDictionary<long, int>\
    \ dict1 = new SortedDictionary<long, int>(l1);\n        SortedDictionary<long,\
    \ int> dict2 = new SortedDictionary<long, int>(l2);\n        List<long> ret =\
    \ new List<long>();\n        foreach (long key in dict1.Keys) {\n            if\
    \ (dict2.ContainsKey(key)) {\n                if (dict1[key] == dict2[key]) {\n\
    \                    ret.Add(key);\n                    dict1.Remove(key);\n \
    \                   dict2.Remove(key);\n                } else {\n           \
    \         ret[ret.Count - 1] = key;\n                }\n            } else {\n\
    \                ret[ret.Count - 1] = key;\n            }\n        }\n       \
    \ return ret;", "        ArrayList list = new ArrayList(l1);\n        list.Sort();\n\
    \        list = new ArrayList(l2);\n        list.Sort();\n        int i1 = 0;\n\
    \        int i2 = 0;\n        do {\n            if (l1[++i1] == l2[i2]) {\n  \
    \              list[i1] = list[i2];\n            }\n            else {\n     \
    \           i2 = i1;\n            }\n        } while (i1 < l1.Count && i2 < l2.Count);\n\
    \        return new ArrayList(list.Take(l1.Count).ToArray()).OrderBy(x => x).ToList();",
  '        return l1.Union(l2).ToList();', "        Debug.Assert(l1 != null && l2\
    \ != null && l1.Count > 0 && l2.Count > 0);\n\n        var r = new List<long>();\n\
    \        var l3 = new HashSet<long>();\n        foreach (var i in l1) {\n    \
    \        l3.Add(i);\n        }\n\n        foreach (var j in l2) {\n          \
    \  l3.Remove(j);\n        }\n        foreach (var j in l3) {\n            r.Add(j);\n\
    \        }\n        return r;", "        HashSet<long> h1 = new HashSet<long>(l1);\n\
    \        HashSet<long> h2 = new HashSet<long>(l2);\n        return h1.Intersect(h2).OrderBy(i\
    \ => i).ToList();", "        // Using a dictionary to store elements that occur\
    \ in both lists.\n        // Use a SortedDictionary with a custom IComparer to\
    \ order the\n        // dictionary by the first element of the pair.\n       \
    \ SortedDictionary<long, SortedDictionary<long, long>> lookup = new SortedDictionary<long,\
    \ SortedDictionary<long, long>>();\n\n        // For each item in the first list.\n\
    \        foreach (long item in l1) {\n            // Create a dictionary entry\
    \ with the item as key and an empty dictionary.\n            if (!lookup.ContainsKey(item))\
    \ {\n                lookup.Add(item, new SortedDictionary<long, long>());\n \
    \           }\n            // Add the item to the dictionary for the key.\n  \
    \          lookup[item].Add(item, 0);\n        }\n\n        // For each item in\
    \ the second list.\n        foreach (long item in l2) {\n            // Create\
    \ a dictionary entry with the item as key and an empty dictionary.\n         \
    \   if (!lookup.ContainsKey(item)) {\n                lookup.Add(item, new SortedDictionary<long,\
    \ long>());\n            }\n            // Add the item to the dictionary for\
    \ the key.\n            lookup[item].Add(item, 0);\n        }\n\n        // Now\
    \ go through the dictionary and see which keys have the most\n        // entries\
    \ in common with the items in the other list.\n        foreach (KeyValuePair<long,\
    \ SortedDictionary<long, long>> entry in lookup) {\n            long maxCount\
    \ = entry.Value.GetValues().Max();\n            long minCount = entry.Value.GetValues().Min();\n\
    \            if (maxCount != minCount) {\n                return entry.Value.GetValues().OrderBy(v\
    \ => v).ToList();\n            }\n        }\n\n        return new List<long>();",
  "        var result = new List<long>();\n        var dict1 = new Dictionary<long,\
    \ int>();\n        var dict2 = new Dictionary<long, int>();\n        foreach(var\
    \ x in l1) dict1[x] = dict1.ContainsKey(x) ? dict1[x]++ : 1;\n        foreach(var\
    \ x in l2) dict2[x] = dict2.ContainsKey(x) ? dict2[x]++ : 1;\n        foreach(var\
    \ x in dict1) {\n            if (dict2.ContainsKey(x) && dict2[x] == dict1[x])\n\
    \                result.Add(x);\n        }\n        return result;", "       \
    \ var common = new List<long>();\n\n        foreach (var item in l1) {\n     \
    \       if (l2.Contains(item)) {\n                common.Add(item);\n        \
    \        l1.Remove(item);\n                l2.Remove(item);\n            }\n \
    \       }\n        foreach (var item in l2) {\n            if (l1.Contains(item))\
    \ {\n                common.Add(item);\n                l1.Remove(item);\n   \
    \             l2.Remove(item);\n            }\n        }\n        return common;",
  "        var list1 = l1.OrderBy(x => x).ToArray();\n        var list2 = l2.OrderBy(x\
    \ => x).ToArray();\n\n        List<long> result = new List<long>();\n        int\
    \ minLength = Math.Min(list1.Length, list2.Length);\n\n        for (int i = 0;\
    \ i < minLength; i++) {\n            if (list1[i] == list2[i])\n             \
    \   result.Add(list1[i]);\n        }\n        return result.OrderBy(x => x).ToList();",
  "        // Sort the lists first.\n        if (l1.Count != l2.Count) {\n       \
    \     throw new ArgumentException();\n        }\n        List<long> sortedList\
    \ = new List<long>();\n        sortedList.AddRange(l1);\n        sortedList.AddRange(l2);\n\
    \        sortedList = sortedList.OrderBy(s => s).ToList();\n        long temp\
    \ = 0;\n        bool same = true;\n        while (same && (same = sortedList.RemoveAt(0)\
    \ == sortedList.RemoveAt(0))) {\n            temp = sortedList[0];\n         \
    \   long j = 1;\n            while (j < sortedList.Count && sortedList[j] == temp)\
    \ {\n                j++;\n            }\n            if (j < sortedList.Count)\
    \ {\n                same = sortedList.RemoveRange(0, j);\n            }\n   \
    \     }\n        return sortedList;", "        if (l1.Count == 0)\n          \
    \  return l2;\n        if (l2.Count == 0)\n            return l1;\n        long[]\
    \ set1 = l1.ToArray();\n        long[] set2 = l2.ToArray();\n        long[] common\
    \ = new long[set1.Length];\n        int i = 0;\n        int j = 0;\n        while\
    \ (i < set1.Length && j < set2.Length) {\n            if (set1[i] == set2[j])\n\
    \                common[i++] = set1[i++] = set2[j++];\n            else if (set1[i]\
    \ < set2[j])\n                common[i++] = set1[i++];\n            else\n   \
    \             common[j++] = set2[j++];\n        }\n        long[] ret = l1.Count\
    \ < l2.Count ? common.Take(l1.Count).ToArray() : common.Take(l2.Count).ToArray();\n\
    \        Array.Sort(ret);\n        return ret;", "        List<long> common =\
    \ new List<long>();\n        if (l1.Count > l2.Count) {\n            common =\
    \ l2;\n            l2 = l1;\n            l1 = common;\n        }\n        for\
    \ (int i = 0; i < l1.Count; i++) {\n            for (int j = 0; j < l2.Count;\
    \ j++) {\n                if (l1[i] == l2[j]) {\n                    common.Add(l1[i]);\n\
    \                    l2.Remove(j);\n                }\n            }\n       \
    \ }\n        return common;", "        // Return unique and sorted.\n        var\
    \ u1 = l1.Select(x => new {x, i = Array.IndexOf(l2, x)}).GroupBy(x => x.i).ToArray().OrderBy(x\
    \ => x.Key).Select(x => x.Select(y => y.x).ToArray()).Distinct().ToList();\n \
    \       var u2 = l2.Select(x => new {x, i = Array.IndexOf(l1, x)}).GroupBy(x =>\
    \ x.i).ToArray().OrderBy(x => x.Key).Select(x => x.Select(y => y.x).ToArray()).Distinct().ToList();\n\
    \n        // Sort unique and common elements.\n        var sortedU1 = u1.OrderBy(x\
    \ => x);\n        var sortedU2 = u2.OrderBy(x => x);\n        var common = sortedU1.Intersect(sortedU2);\n\
    \        return common.OrderBy(x => x).ToList();", "        if (l1 == null ||\
    \ l2 == null)\n            throw new ArgumentNullException();\n\n        var c\
    \ = new List<long>(new long[]{\n            l1.FirstOrDefault(x => l2.Contains(x)\
    \ == false),\n            l2.FirstOrDefault(x => l1.Contains(x) == false)\n  \
    \      });\n\n        foreach (var x in l1.Where(x => l2.Contains(x) == false))\n\
    \            c.Remove(x);\n\n        foreach (var x in l2.Where(x => l1.Contains(x)\
    \ == false))\n            c.Remove(x);\n\n        return c;", "        List<long>\
    \ result = new List<long>();\n        int len = Math.Min(l1.Count, l2.Count);\n\
    \        for (int i = 0; i < len; i++) {\n            long common = Math.Min(l1[i],\
    \ l2[i]);\n            if (result.Contains(common)) continue;\n            while\
    \ (result.Contains(common) && l1[i] != l2[i]) {\n                common = Math.Min(l1[i],\
    \ l2[i]);\n            }\n            result.Add(common);\n        }\n       \
    \ return result;", '        return l1.Intersect(l2).OrderBy(i => i).ToList();',
  "        HashSet<long> h1 = new HashSet<long>(l1);\n        HashSet<long> h2 = new\
    \ HashSet<long>(l2);\n        h1.SymmetricExceptWith(h2);\n        return new\
    \ List<long>(h1);", "        List<long> list = new List<long>();\n        HashSet<long>\
    \ set = new HashSet<long>();\n        foreach (long num in l1) {\n           \
    \ set.Add(num);\n        }\n        foreach (long num in l2) {\n            if\
    \ (!set.Contains(num)) {\n                list.Add(num);\n                set.Add(num);\n\
    \            }\n        }\n        list.Sort();\n        return list;", "    \
    \    // Create sets to store unique values found in both lists.\n        HashSet<long>\
    \ u1 = new HashSet<long>(l1);\n        HashSet<long> u2 = new HashSet<long>(l2);\n\
    \        // Iterate through unique elements of both lists, checking each one against\
    \ the other.\n        foreach (long item in u1)\n        {\n            if (!u2.Contains(item))\n\
    \            {\n                return new List<long> { item };\n            }\n\
    \        }\n        return new List<long>();", "        Debug.Assert(l1.Count\
    \ == l2.Count);\n        Debug.Assert(l1.Count == l1.FindIndex(o => o == 0L));\n\
    \        Debug.Assert(l2.Count == l2.FindIndex(o => o == 0L));\n        Debug.Assert(l1.Count\
    \ == l2.Count);\n        Debug.Assert(l1.Count == l1.FindIndex(o => o == 0L));\n\
    \        Debug.Assert(l2.Count == l2.FindIndex(o => o == 0L));\n        Debug.Assert(l1.Count\
    \ == l2.Count);\n        Debug.Assert(l1.Count == l1.FindIndex(o => o == 0L));\n\
    \        Debug.Assert(l2.Count == l2.FindIndex(o => o == 0L));\n        Debug.Assert(l1.Count\
    \ == l2.Count);\n        var common = new List<long>();\n        Debug.Assert(l1.Count\
    \ == l1.FindIndex(o => l2.IndexOf(o) != -1));\n        Debug.Assert(l2.Count ==\
    \ l2.FindIndex(o => l1.IndexOf(o) != -1));\n        int index = 0;\n        foreach\
    \ (var o in l1) {\n            if (l2.IndexOf(o) != -1) {\n                common.Add(o);\n\
    \                l2.RemoveAt(l2.IndexOf(o));\n                if (l2.Count ==\
    \ 0)\n                    break;\n            }\n            else\n          \
    \      common.Add(0L);\n            Debug.Assert(l2.Count == l2.FindIndex(o =>\
    \ o == 0L));\n            l2.RemoveAt(l2.FindIndex(o => o == 0L));\n         \
    \   if (l2.Count == 0)\n                break;\n            Debug.Assert(l2.Count\
    \ == l2.FindIndex(o => o == 0L));\n            if (index >= l2.Count || l1.IndexOf(common[index])\
    \ != -1)\n                index = -1;\n            else\n                index++;\n\
    \        }\n        return common;", "        if (l1 == null)\n            return\
    \ l2;\n        if (l2 == null)\n            return l1;\n        var list = new\
    \ List<long>(l1.Count);\n        foreach (var x in l1.Take(l1.Count))\n      \
    \      if (l2.Contains(x))\n                list.Add(x);\n            else\n \
    \               list.AddRange(l2.Where(x => x != x).Take(l2.Count - l1.Count).SelectMany(x\
    \ => new List<long> {x}));\n        return list;", "        var list = new List<long>();\n\
    \        foreach (var item in l1) {\n            list.Add(item);\n        }\n\
    \        foreach (var item in l2) {\n            if (!list.Contains(item)) {\n\
    \                list.Add(item);\n            }\n        }\n        var seen =\
    \ new HashSet<long>();\n        var sorted = list.OrderBy(x => x);\n        return\
    \ sorted.Except(seen).ToList();", "        var result = new List<long>();\n  \
    \      long minL1, minL2, minL3;\n        if (l1.Count < l2.Count) minL2 = l2.Count;\
    \ else minL1 = l1.Count;\n        if (minL1 != minL2) minL3 = minL1; else minL3\
    \ = minL2;\n        for (int i = 0; i < minL3; i++) {\n            long x = l1.ElementAt(i);\n\
    \            long y = l2.ElementAt(i);\n            if (x == y) result.Add(x);\n\
    \            else if (x < y) result.Add(x);\n            else result.Add(y);\n\
    \        }\n        return result;", "        long min = long.MaxValue;\n    \
    \    long max = long.MinValue;\n        long sum = 0;\n        long common = 0;\n\
    \        for (int i = 0; i < l1.Count && i < l2.Count; i++) {\n            long\
    \ tempSum = l1.ElementAt(i) + l2.ElementAt(i);\n            if (tempSum < min)\n\
    \                min = tempSum;\n            if (tempSum > max)\n            \
    \    max = tempSum;\n            sum += tempSum;\n            common += l1.ElementAt(i);\n\
    \        }\n        return new List<long>() { sum = sum, common = common };",
  '        return l1.Intersect(l2).ToList();', "        IComparer<long> cmp = new\
    \ CommonComparer();\n        return l1.OrderBy(x => x, cmp).Intersect(l2.OrderBy(x\
    \ => x, cmp), cmp).ToList();", "        if (l1 == null || l2 == null || l1.Count\
    \ != l2.Count) return new List<long>();\n        List<long> c = new List<long>();\n\
    \        foreach (long l in l1) {\n            c.Add(l);\n            c.Remove(l2);\n\
    \        }\n        return c;", "        if (l1 == null || l2 == null || l1.Count\
    \ == 0 || l2.Count == 0) {\n            return new List<long>();\n        }\n\
    \        List<long> result = new List<long>();\n        HashSet<long> hset = new\
    \ HashSet<long>();\n        l1.ForEach(x => hset.Add(x));\n        l2.ForEach(x\
    \ => hset.Add(x));\n        hset.Remove(l1[0]);\n        hset.Remove(l2[0]);\n\
    \        foreach (long x in hset) {\n            if (l1.Count > l2.Count && l2.Contains(x))\
    \ {\n                l1.Remove(x);\n                l2.Remove(x);\n          \
    \  }\n            if (l1.Count < l2.Count && l1.Contains(x)) {\n             \
    \   l2.Remove(x);\n                l1.Remove(x);\n            }\n            result.Add(x);\n\
    \        }\n        return result;", "        HashSet<long> hs1 = new HashSet<long>(l1);\n\
    \        HashSet<long> hs2 = new HashSet<long>(l2);\n        List<long> result\
    \ = new List<long>();\n        hs2.ForEach(hs1 => {\n            if (hs2.Contains(hs1))\
    \ {\n                result.Add(hs1);\n            }\n        });\n        return\
    \ result.Distinct().OrderBy(x => x).ToList();", "        List<long> result = new\
    \ List<long>();\n        long temp = 0;\n        if (l1 == null) l1 = new List<long>();\n\
    \        if (l2 == null) l2 = new List<long>();\n        if (l1.Count != l2.Count)\
    \ throw new ArgumentException(\"List sizes differ.\");\n        for (long i =\
    \ 0; i < l1.Count; i++) {\n            if (l1[i] == l2[i]) continue;\n       \
    \     temp = l1[i];\n            l1[i] = l2[i];\n            l2[i] = temp;\n \
    \           result.Add(temp);\n        }\n        return result;", "        HashSet<long>\
    \ h1 = new HashSet<long>(l1);\n        HashSet<long> h2 = new HashSet<long>(l2);\n\
    \        h1.IntersectWith(h2);\n        List<long> common = new List<long>(h1);\n\
    \        return common;", "        // Initialize a list to store the unique elements.\n\
    \        List<long> l3 = new List<long>();\n        // Sort the lists.\n     \
    \   l1.Sort();\n        l2.Sort();\n        // Iterate through both lists.\n \
    \       for (int i = 0; i < l1.Count; i++) {\n            // Iterate through both\
    \ lists.\n            for (int j = 0; j < l2.Count; j++) {\n                //\
    \ If the current element of the first list is the current element of the second\
    \ list\n                if (l1[i] == l2[j]) {\n                    // Add this\
    \ element to the output list.\n                    l3.Add(l1[i]);\n          \
    \          // Break from the inner loop.\n                    break;\n       \
    \         }\n            }\n        }\n        // Return the output list.\n  \
    \      return l3;", "        var common = new List<long>();\n        if (l1.Count\
    \ < l2.Count) l1Copy = l1.ToArray();\n        else l1Copy = l2.ToArray();\n  \
    \      l1Copy.Sort();\n        foreach (var elem in l1Copy) {\n            if\
    \ (l2.Contains(elem)) common.Add(elem);\n        }\n        return common;", " \
    \       var result = l1.Union(l2).OrderBy(x => x).Distinct().ToList();\n     \
    \   result.Sort();\n        return result;", "        var result = new List<long>();\n\
    \        for (int i = 0; i < l1.Count; ++i) {\n            bool flag = false;\n\
    \            for (int j = 0; j < l2.Count; ++j) {\n                if (l1[i] ==\
    \ l2[j]) {\n                    result.Add(l1[i]);\n                    flag =\
    \ true;\n                    break;\n                }\n            }\n      \
    \      if (!flag)\n                result.Add(l1[i]);\n        }\n        return\
    \ result.Distinct().OrderBy(c => c).ToList();", "        if (l1 == null || l2\
    \ == null || l1.Count == 0 || l2.Count == 0) return null;\n        var d = l1.Min()\
    \ - l2.Min();\n        if (d < 0) return null;\n        var n1 = l1.Count - 1;\n\
    \        var n2 = l2.Count - 1;\n        var m = n1 - n2;\n        if (m < 0)\
    \ return null;\n        var x = l1.Min();\n        var y = l2.Min();\n       \
    \ var z = new List<long>();\n        var a = d%n;\n        var b = d-a;\n    \
    \    if (b > m) b = m;\n        var i = 0;\n        while (i <= n1 && i <= n2)\
    \ {\n            if (x < y) { z.Add(l1[i]); x1 = y; y = l1[i]; i += 1; }\n   \
    \         else if (x < z[i]) { z.Add(z[i]); x1 = z[i]; z[i] = z[i]; z[i] += 1;\
    \ i += 1; }\n            else if (z[i] < x) { z.Add(z[i]); x1 = z[i]; z[i] = z[i];\
    \ z[i] += 1; i += 1; }\n            else if (x == y) { z.Add(x); x1 = y; y = x;\
    \ x += a; y -= b; }\n            else if (z[i] < x) { z.Add(z[i]); x1 = z[i];\
    \ z[i] = z[i]; z[i] += 1; i += 1; }\n            else { z.Add(z[i]); x1 = z[i];\
    \ z[i] = z[i]; z[i] += 1; i += 1; }\n        }\n        if (i < n1) z.AddRange(l1.SubRange(i,\
    \ n1));\n        if (i < n2) z.AddRange(l2.SubRange(i, n2));\n        return z;",
  "        SortedSet<long> common = new SortedSet<long>();\n        foreach (long\
    \ x in l1.Union(l2))\n            if (common.Contains(x))\n                common.Remove(x);\n\
    \            else\n                common.Add(x);\n        return common.ToList();",
  "        var list = new List<long>();\n        var l = new List<long>();\n     \
    \   if (l1.Count == 0) return l2;\n        if (l2.Count == 0) return l1;\n   \
    \     foreach (var n in l1.Intersect(l2))\n            if (l.Contains(n)) list.Remove(n);\n\
    \            else\n                l.Add(n);\n        return list.Count == 0 ?\
    \ l1 : list;", "        var u = new HashSet<long>();\n        u.UnionWith(l1);\n\
    \        u.UnionWith(l2);\n        return u.OrderBy(i => i).ToList();", "    \
    \    var l3 = new List<long>(l2);\n        l3.RemoveAll(l1 => l1.Equals(l2));\n\
    \        l3.Sort();\n        return l1;", "        List<long> result = new List<long>();\n\
    \        foreach (long num in l1)\n            result.AddRange(l2.Where(num =>\
    \ num == num).ToList());\n        return result.Distinct().OrderBy(num => num).ToList();",
  '        return l1.Intersect(l2).OrderBy(n => n).ToList();', "        var dict =\
    \ new SortedDictionary<long, long>();\n        foreach (var item in l1) {\n  \
    \          dict[item] = 1;\n        }\n        foreach (var item in l2) {\n  \
    \          if (dict[item] == null) {\n                dict[item] = 1;\n      \
    \      } else {\n                dict[item]++;\n            }\n        }\n   \
    \     var ret = new List<long>();\n        foreach (var item in dict) {\n    \
    \        if (item.Value == 2) {\n                ret.Add(item.Key);\n        \
    \    }\n        }\n        return ret;", '        return l1.Intersect(l2).OrderBy(x
    => x).ToList();', "        long[] common = new long[Math.Min(l1.Count, l2.Count)];\n\
    \        for (int i = 0; i < common.Length; i++)\n            common[i] = Math.Max(l1[i],\
    \ l2[i]);\n        Array.Sort(common);\n        return new List<long>(common);",
  "        if (l1 == null || l2 == null || l1.Count < 1 || l2.Count < 1) {\n     \
    \       return l1;\n        }\n        var sorted = (l1.Count > l2.Count) ? l1\
    \ : l2;\n        var common = sorted.Intersect(sorted);\n        if (common.Count\
    \ < 1) {\n            return l1;\n        } else {\n            var unique = new\
    \ List<long>();\n            for (int i = 0; i < common.Count; i++) {\n      \
    \          if (!unique.Contains(common[i])) {\n                    unique.Add(common[i]);\n\
    \                }\n            }\n            return unique;\n        }", '        return
    l1.Union(l2).OrderBy(d => d).Distinct().ToList();', "        IComparer<long> comparer\
    \ = new Comparer<long>((x, y) => x > y);\n        List<long> result = new List<long>();\n\
    \        foreach (long l in l1) if (l2.Contains(l, comparer)) result.Add(l);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     foreach(var a in l1)\n            foreach(var b in l2) {\n             \
    \   if (a == b)\n                    result.Add(a);\n                else if (a\
    \ < b)\n                    break;\n            }\n        return result;", " \
    \       List<long> l3 = new List<long>();\n        foreach (var a in l1) {\n \
    \           bool found = false;\n            foreach (var b in l2) {\n       \
    \         if (a == b) {\n                    found = true;\n                 \
    \   break;\n                }\n            }\n            if (!found) {\n    \
    \            l3.Add(a);\n            }\n        }\n        return l3;"]
stop_tokens:
- "\n    }\n"
