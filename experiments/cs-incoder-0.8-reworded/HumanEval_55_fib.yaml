name: HumanEval_55_fib
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return n-th Fibonacci number.\n    // >>> Fib((10L))\n    //\
  \ (55L)\n    // >>> Fib((1L))\n    // (1L)\n    // >>> Fib((8L))\n    // (21L)\n\
  \    public static long Fib(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fib((10L))\
  \ == (55L));\n    Debug.Assert(Fib((1L)) == (1L));\n    Debug.Assert(Fib((8L)) ==\
  \ (21L));\n    Debug.Assert(Fib((11L)) == (89L));\n    Debug.Assert(Fib((12L)) ==\
  \ (144L));\n    }\n\n}\n"
completions: ["        long first = 1;\n        long second = 1;\n        long result\
    \ = 0;\n        while (n > 0) {\n            long tmp = first;\n            first\
    \ = second;\n            second = tmp + second;\n            result += (long)Math.Pow(first,\
    \ n);\n            n--;\n        }\n        return result;", "        // Base\
    \ cases.\n        if (n == 0L || n == 1L) {\n            return n;\n        }\n\
    \n        // Recursive case.\n        if (n % 2L == 0L) {\n            return\
    \ Fib((n * 3L) + 1L);\n        }\n\n        return Fib((n * 3L) + 1L) + Fib((n\
    \ * 2L) + 1L);", "        if (n <= 0) {\n            throw new ArgumentOutOfRangeException(\"\
    n\", n, \"n must be > 0.\");\n        }\n        long f1 = 1L;\n        long f2\
    \ = 1L;\n        long fib = 1L;\n        for (long i = 3L; i <= n; i++) {\n  \
    \          fib += f1;\n            f1 = f2;\n            f2 = fib;\n        }\n\
    \        return fib;", '        return n < 2 ? n : Fib(n - 1) + Fib(n - 2);',
  "        long a = 1, b = 1;\n        while (b < n) {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return b;", "    \
    \    if (n <= 1)\n            return n;\n        return Fib(n - 2) + Fib(n - 1);",
  "        if (n < 2) return n;\n        if (n < 5) return Fib(n * 2L) + Fib(n * 3L);\n\
    \        return Fib(n * 3L) + Fib(n * 5L);", "        if (n <= 1L)\n         \
    \   return 1L;\n        else\n            return Fib(n-1L) + Fib(n-2L);", "  \
    \      if (n < 2L)\n            return n == 2L ? 1L : 2L;\n        else\n    \
    \        return Fib(n-2L) + Fib(n-1L);", "        if (n <= 2) {\n            return\
    \ n;\n        }\n        return Fib(n-1) + Fib(n-2);", "        if (n < 2) {\n\
    \            return n;\n        }\n        // Return n-th Fibonacci number.\n\
    \        // >>> Fib(10)\n        // 55\n        // >>> Fib(1)\n        // 1\n\
    \        // >>> Fib(8)\n        // 21\n        long fib1 = 1, fib2 = 2;\n    \
    \    while (fib2 < n) {\n            fib1 = fib2;\n            fib2 = fib1 + fib1;\n\
    \        }\n        return fib2;", "        // If n is 0 or 1, return n; \n  \
    \      if (n == 0) { return n; }\n        if (n == 1) { return n; }\n        //\
    \ Otherwise return n+Fib(n - 1).\n        return n + Fib(n - 1);", "        if\
    \ (n <= 2L)\n            return 1L;\n        else\n            return Fib((n -\
    \ 1L) + 2L);", "        if (n <= 2) {\n            return 1;\n        }\n    \
    \    return Fib(n-2) + Fib(n-1);", "        using (MD5 md5 = MD5.Create()) {\n\
    \            byte[] data = md5.ComputeHash(BitConverter.GetBytes(n));\n      \
    \      return BitConverter.ToInt64(md5.ComputeHash(data), 0);\n        }", " \
    \       long[] a = new long[n];\n        a[0] = 0;\n        a[1] = 1;\n      \
    \  for (int i = 2; i < n; i++) {\n            a[i] = a[i - 1] + a[i - 2];\n  \
    \      }\n        return a[n - 1];", "        // Spread the constant out to reduce\
    \ the number of arithmetic operations.\n        const long F1 = 1;\n        const\
    \ long F2 = 1;\n        // Calculate the next Fibonacci number until n is reached.\n\
    \        long result = 0;\n        for (long x = 1; x <= n; x++) {\n         \
    \   // Calculate the next Fibonacci number.\n            result = F1 + F2;\n \
    \           // If n is reached, return the result.\n            if (x == n)\n\
    \                return result;\n            // Calculate the next two Fibonacci\
    \ numbers.\n            F1 = F2;\n            F2 = result;\n        }\n      \
    \  // The loop has run out of numbers until n was reached.\n        throw new\
    \ IndexOutOfRangeException(\"No such Fibonacci number: \" + n);", "        if\
    \ (n == 0L)\n            return 0L;\n        if (n == 1L)\n            return\
    \ 1L;\n        long first = 0L;\n        long second = 1L;\n        while (true)\
    \ {\n            long temp = first;\n            first = second;\n           \
    \ second = temp + second;\n            if (second > n)\n                return\
    \ second;\n        }", "        long f0 = 1;\n        long f1 = 1;\n        for\
    \ (long i = 2; i <= n; i++) {\n            long f = f0 + f1;\n            f0 =\
    \ f1;\n            f1 = f;\n        }\n        return f0;", "        long a =\
    \ 0,\n            b = 1;\n        for (long i = 2; i <= n; i++) {\n          \
    \  long c = a + b;\n            a = b;\n            b = c;\n        }\n      \
    \  return b;", '        return Fibonacci(n);', "        if (n < 2) return n;\n\
    \        if (n == 2) return 1;\n        return Fib(n-2) + Fib(n-1);", "      \
    \  long f1 = 1;\n        long f2 = 1;\n        long sum = 0;\n        if (n >=\
    \ 2) {\n            sum = f1 + f2;\n            f1 = f2;\n            f2 = sum;\n\
    \        }\n        for (long i = 3; i <= n; i++) {\n            long f = f1;\n\
    \            f1 = f2;\n            f2 = f;\n            sum += f2;\n        }\n\
    \        return sum;", "        long prev1, prev2, result;\n        prev1 = 1;\n\
    \        prev2 = 1;\n        result = 0;\n        while(n>0) {\n            result\
    \ = prev1 + prev2;\n            prev1 = prev2;\n            prev2 = result;\n\
    \            n--;\n        }\n        return result;", "        long prev = 0,\
    \ curr = 1;\n        for (long i = 2; i <= n; i++) {\n            prev = curr;\n\
    \            curr = curr + prev;\n        }\n        return curr;", "        var\
    \ a = new long[] { 1, 1 };\n        var b = new long[] { 0, 1 };\n        for\
    \ (var i = 2; i <= n; ++i) {\n            long temp = a[i - 1] + b[i - 1];\n \
    \           a[i] = temp % 10;\n            b[i] = temp / 10;\n        }\n    \
    \    return a[n - 1];", "        long prev = 1;\n        long curr = 2;\n    \
    \    for (long i = 3; i <= n; i++) {\n            prev = prev + curr;\n      \
    \      curr = curr + prev;\n        }\n        return prev;", "        long a\
    \ = 1, b = 1;\n        for (long i = 0; i < n; i++)\n        {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ b;", "        // Initialize F(n) = F(n-1) + F(n-2)\n        long F0 = Fib(n-1);\n\
    \        long F1 = Fib(n-2);\n        long F = F0 + F1;\n        if (n >= 3)\n\
    \            F = F + F(n-1) + F(n-2) + F(n-3);\n        return F;", "        if\
    \ (n == 0) return 0L;\n        if (n == 1) return 1L;\n        long a = Fib(n/2);\n\
    \        long b = Fib(n/2+1);\n        return a + b;", "        long a = 0;\n\
    \        long b = 1;\n        for (long i = 0; i < n; i++) {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ b;", "        if (n == 0 || n == 1)\n            return n;\n        if (n ==\
    \ 2)\n            return 1;\n        return Fib(n-1) + Fib(n-2);", "        if\
    \ (n == 0L)\n            return 0L;\n        if (n == 1L)\n            return\
    \ 1L;\n        return Fib((n - 1L) + Fib((n - 2L)));", "        if (n <= 1L) return\
    \ n;\n        return Fib(n - 1) + Fib((n - 2L));", "        long i = 1;\n    \
    \    long temp;\n        long fib;\n        if (n == 1 || n == 2) {\n        \
    \    return n;\n        }\n\n        while (i < n) {\n            fib = (long)(Math.Pow(2.0,\
    \ 1.0L * i));\n            temp = i;\n            i += 1;\n            if (temp\
    \ < n) {\n                fib = fib + fib;\n            }\n        }\n\n     \
    \   return fib;", "        BigInteger num1 = new BigInteger(\"1\");\n        BigInteger\
    \ num2 = new BigInteger(\"0\");\n        BigInteger res = new BigInteger(\"0\"\
    );\n        long lastNum = new long(0);\n\n        long counter = 0;\n       \
    \ BigInteger res = num1;\n        BigInteger sum = num2;\n\n        while (n <\
    \ 1 || n >= lastNum) {\n            sum = new BigInteger(res.ToString() + num2.ToString());\n\
    \            lastNum = n;\n            counter++;\n            n = counter;\n\
    \        }\n\n        if (n == 1) {\n            res = sum;\n        }\n     \
    \   else if(sum.Equals(num2)) {\n            res = res;\n        }\n        else\
    \ {\n            res = num2;\n        }\n\n        return res;", "        ulong\
    \ a = 1L;\n        ulong b = 1L;\n        ulong x = a;\n\n        for (int i =\
    \ 0; i < n; i++) {\n            ulong c = a + b;\n            a = b;\n       \
    \     b = c;\n        }\n        return x;", "        long a = 1, b = 0, fib =\
    \ 0;\n\n        while (n-- > 0) {\n            fib = a + b;\n            a = b;\n\
    \            b = fib;\n        }\n\n        return fib;", "        if (n <= 0)\n\
    \            throw new ArgumentOutOfRangeException(\"n\");\n        if (n <= 2)\n\
    \            return n;\n        long fib = 0;\n        long temp;\n        do\
    \ {\n            temp = fib;\n            fib += (n - 2);\n            fib -=\
    \ temp;\n            n = fib;\n        } while (n != 0L);\n        return fib;",
  "        if (n <= 1L)\n            return n;\n        return Fib(n - 1) + Fib(n\
    \ - 2);", "        if (n < 3) return n;\n        long a = 1, b = 1;\n        long\
    \ result = a;\n        for (int i = 3; i <= n; i++) {\n            long tmp =\
    \ b;\n            b = a;\n            a = tmp + b;\n            result = a;\n\
    \        }\n        return result;", "        if (n <= 1) return n;\n        long\
    \ f1 = Fib(n-2);\n        long f2 = Fib(n-1);\n        return ((f1 * f2) % n)\
    \ > 1 ? f2 : f1;", "        if (n < 0)\n            throw new ArgumentOutOfRangeException();\n\
    \        long a = 0, b = 1;\n        long f = 0;\n        while (n > 1) {\n  \
    \          f += b;\n            while (f >= n) f -= n;\n            a = b;\n \
    \           b = f;\n        }\n        return b;", "        if (n == 0) return\
    \ 0;\n        if (n == 1) return 1;\n        return Fib(n-1) + Fib(n-2);", " \
    \       // The first two numbers.\n        long f0 = 1;\n        long f1 = 1;\n\
    \        long fib;\n        // The current Fibonacci number\n        // is computed\
    \ by adding the previous two\n        // numbers together.\n        while (n >\
    \ 0) {\n            // The previous two numbers\n            // are computed by\
    \ adding the first\n            // number to each other. This\n            //\
    \ is repeated until the sum is greater\n            // than or equal to the next\
    \ Fibonacci\n            // number.\n            fib += f0;\n            f0 =\
    \ f1;\n            f1 = fib;\n            fib += f0;\n            n -= 1;\n  \
    \      }\n        return fib;", "        long previous = 0;\n        long current\
    \ = 1;\n\n        while (true) {\n            long next = current + previous;\n\
    \            if (next > n) break;\n            previous = current;\n         \
    \   current = next;\n        }\n        return current;", "        long result\
    \ = 1;\n        long current = 1;\n        for (long i = 0; i < n; i++) {\n  \
    \          current = current + result;\n            result = current;\n      \
    \  }\n        return current;", "        if (n == 0)\n            return 0;\n\
    \        if (n == 1)\n            return 1;\n        return Fib(n-2) + Fib(n-1);",
  '        return n == 1L ? 1L : Fib((n - 1L) + 2L);', "        var a = 1;\n     \
    \   var b = 1;\n        for (var i = 3; i <= n; i++) {\n            var c = a\
    \ + b;\n            a = b;\n            b = c;\n        }\n        return a;",
  "        if (n < 3) return n;\n        long a = 1;\n        long b = 1;\n      \
    \  for (long i = 0; i < n; ++i) {\n            long c = a + b;\n            a\
    \ = b;\n            b = c;\n        }\n        return b;", "        long i = 1;\n\
    \        long fib;\n        // Calculate Fibonacci sequence recursively.\n   \
    \     if (n <= 1) {\n            fib = (long)Math.Pow(i, n);\n        }\n    \
    \    else {\n            fib = (long)Math.Pow((double)i, (double)n) / Math.Pow((double)i,\
    \ (double)n);\n        }\n        // Return n-th Fibonacci number.\n        return\
    \ fib;", "        long[] a = new long[] { 0, 1 }, b = new long[] { 1, 0 };\n \
    \       if (n < 2) {\n            return n;\n        }\n        long[] c = new\
    \ long[] { 0, 1 };\n        while (n-- > 0) {\n            long[] a1 = new long[]\
    \ { a[1] };\n            long[] a2 = new long[] { a[0] };\n            for (int\
    \ i = 0; i < a.Length; i++) {\n                a[i] = b[i] + c[i];\n         \
    \       b[i] = a[i] + c[i];\n                c[i] = a[i] % 10;\n            }\n\
    \            c.CopyTo(a, 1);\n            long result = a[0] % 10;\n         \
    \   return result;\n        }\n        throw new ArgumentOutOfRangeException();",
  "        long a = 0, b = 1, c = 1;\n        long result = 1;\n        // Do the\
    \ hard work until we get the number\n        // of the specified fibonacci number.\n\
    \        for (long i = 0; i <= n; i++) {\n            result = a + b + c;\n  \
    \          a = b;\n            b = c;\n            c += result;\n        }\n \
    \       // Return the answer to the requested number.\n        return c;", " \
    \       if (n < 2) return n;\n        return Fib(n / 2) + Fib(n % 2);", '        return
    n < 2 ? n : Fib(n-2) + Fib(n-1);', "        long nFib = (1L);\n        if (n ==\
    \ 1L) {\n            return 1L;\n        }\n        if (n == 2L) {\n         \
    \   return 1L;\n        }\n        if (n == 0L) {\n            return 0L;\n  \
    \      }\n        if (n > 1L) {\n            nFib += Fib((n - 1L));\n        }\n\
    \        return nFib;", "        long a = 0, b = 1;\n        if (n <= 1)\n   \
    \         return n;\n        for (long i = 0; i < n; i++)\n        {\n       \
    \     var c = a + b;\n            a = b;\n            b = c;\n        }\n    \
    \    return b;", "        if (n <= 1)\n            return n;\n        return Fib(n\
    \ - 1) + Fib(n - 2);", "        // Return n-th Fibonacci number.\n        // >>>\
    \ Fib((10L))\n        // (55L)\n        // >>> Fib((1L))\n        // (1L)\n  \
    \      // >>> Fib((8L))\n        // (21L)\n        if (n == 0)\n            return\
    \ 0L;\n        if (n == 1)\n            return 1L;\n        return Fib(n-2) +\
    \ Fib(n-1);", "        long a = 0, b = 1, sum;\n        for (int i = 0; i < n;\
    \ i++) {\n            sum = a + b;\n            a = b;\n            b = sum;\n\
    \        }\n        return sum;", "        long a = (long)Math.Pow(2.0, (double)n)\
    \ + 1;\n        long b = (long)Math.Pow(2.0, (double)n) - 1;\n        return (a-b);",
  "        if (n == 0L)\n            return 0L;\n        if (n == 1L)\n          \
    \  return 1L;\n        return Fib(n-1L) + Fib(n-2L);", "        // Use memoization\
    \ to avoid recalculating Fibonacci numbers.\n        if (n == 0) return 0;\n \
    \       if (n < 2) return 1;\n        if (fibs.ContainsKey(n)) return fibs[n];\n\
    \        // Remember Fibonacci numbers.\n        fibs[n] = Fib(n - 1) + Fib(n\
    \ - 2);\n        return fibs[n];", "        long a = 1, b = 1;\n        while\
    \ (b < n) {\n            long c = a + b;\n            a = b;\n            b =\
    \ c;\n        }\n        return b;", "        // Avoid exceeding the integer limit.\n\
    \        if (n <= 1L) throw new ArgumentOutOfRangeException(\"n\");\n\n      \
    \  // Use Sieve to avoid computing the same numbers.\n        long[] primes =\
    \ new long[(int)Math.Ceiling((long.MaxValue - 1L) / n) + 1];\n\n        // Initialize\
    \ primes to all zeros.\n        primes[0] = 0L;\n        primes[1] = 1L;\n\n \
    \       // Start with the 2nd prime and mark it as non-zero.\n        for (int\
    \ i = 2; i <= (int)Math.Ceiling((long.MaxValue - 1L) / n); ++i) {\n          \
    \  if (primes[i] != 0L) continue;\n\n            // Find the next prime in the\
    \ Fibonacci sequence.\n            long nextPrime;\n            for (long j =\
    \ 3L; j <= n; ++j) {\n                nextPrime = (primes[j - 2L] + primes[j -\
    \ 1L]) % 2L;\n                primes[j] = nextPrime;\n                if (nextPrime\
    \ != 0L) break;\n            }\n\n            // If no prime was found, then the\
    \ number cannot be even.\n            if (nextPrime == 0L) throw new ArgumentOutOfRangeException(\"\
    n\");\n        }\n\n        // Return the prime that corresponds to the given\
    \ n.\n        return primes[n];", "        // Pre-compute Fibonacci numbers.\n\
    \        static long Fib[32] = {\n            1L, 1L, 2L, 1L, 3L, 2L, 5L, 3L,\
    \ 8L, 5L, 13L, 8L, 21L,\n            34L, 55L, 89L, 144L, 233L, 377L, 610L, 987L,\
    \ 1597L, 2584L,\n            4181L, 6765L, 10946L, 17711L, 28657L, 46368L, 75025L,\
    \ 121393L,\n            196418L, 317811L, 514229L, 832041L, 1346269L, 2178309L,\
    \ 3524578L,\n            5702887L, 9227465L, 14930352L, 24157817L, 39088169L,\
    \ 63245986L,\n            102334155L, 165580141L, 267914296L, 433494437L, 701408733L,\n\
    \            1134903171L, 1836311903L, 2971215073L, 4807526976L, 7778742049L,\n\
    \            12586269025L, 20365011074L, 32951280099L, 53316291171L, 86267571213L,\n\
    \            13049695449L, 21058762046L, 3416464579L\n        };\n        // Return\
    \ the nth Fibonacci number.\n        if (n < 0 || n > 31)\n            throw new\
    \ ArgumentOutOfRangeException();\n        if (n == 1)\n            return 1;\n\
    \        if (n == 2)\n            return 1;\n        // Use F[n - 1] and F[n].\n\
    \        return (long)Fib[n - 2] + Fib[n - 1];", "        long a = 0, b = 1, tmp;\n\
    \        while (true) {\n            tmp = a + b;\n            if (tmp == 0) return\
    \ tmp;\n            if (tmp < n) a = b;\n            else b = tmp;\n        }",
  "        // Return Fibonacci number for n. \n        if (n < 0 || n <= 1) \n   \
    \         return 0;\n        else\n            long prev = 1;\n            long\
    \ next = 2;\n            for (int i = 3; i <= n; ++i) {\n                long\
    \ temp = prev;\n                prev = next;\n                next = temp + prev;\n\
    \            }\n            return next;", "        long f = 1;\n        long\
    \ g = 1;\n        long h = 1;\n        long m = 1;\n        long t = 1;\n    \
    \    long b = 1;\n        long c = 1;\n        while (b < n) {\n            h\
    \ = f*g;\n            g = f;\n            f = t;\n            t = b;\n       \
    \     b = c*g;\n            c = b;\n            g = h;\n            h = g + t;\n\
    \            m = m + b;\n        }\n        return m;", "        if (n == 0)\n\
    \            return 0;\n        if (n == 1)\n            return 1;\n        return\
    \ (Fib(n-2) + Fib(n-1));", "        long a = 1, b = 1;\n        long c = 2;\n\
    \        for (long i = 0; i < n; i++) {\n            c = (a + b) % c;\n      \
    \      long temp = a;\n            a = b;\n            b = temp;\n        }\n\
    \        return c;", "        if ((n == 0) || (n == 1)) {\n            return\
    \ 1;\n        }\n        else {\n            double x = 0;\n            double\
    \ y = 1;\n            for (int i = 0; i < n; i++) {\n                x += y;\n\
    \                y += x;\n            }\n            return x;\n        }", " \
    \       if (n <= 1) return 1L;\n        return Fib(n - 1) + Fib(n - 2);", "  \
    \      long ret = 0;\n        long temp = 0;\n        long fib = 1;\n        long\
    \ fib2 = 1;\n        for(int i = 1; i<=n; i++) {\n            fib = fib*fib;\n\
    \            fib2 = fib % fib2;\n            temp = temp + fib2;\n           \
    \ if(temp == fib2) {\n                ret = fib;\n            }\n        }\n \
    \       return ret;", "        Debug.Assert(n >= 1L && n <= 10L);\n        if\
    \ (n <= 2L) return 1L;\n        if (n <= 3L) return 1L + Fib(2L);\n        long\
    \ ret = 0L;\n        long f1 = 1L;\n        long f2 = 1L;\n        for (long i\
    \ = 3L; i <= n; i++) {\n            long g = f1 + f2;\n            ret = (long)Math.Pow((double)i,\
    \ (double)f1 / i);\n            f1 = f2;\n            f2 = g;\n        }\n   \
    \     return ret;", "        // Return fibonacci number with n-th fibonacci number\n\
    \        return n > 1L\n            ? (1L + Fib(n - 2L))\n            : (long)\
    \ Math.Pow(\n                (1L + Math.Pow(2L, n)),\n                n\n    \
    \        );", "        if (n == 0) {\n            return 0;\n        } else if\
    \ (n == 1) {\n            return 1;\n        } else if (n % 2 == 0) {\n      \
    \      return Fib(n / 2) + Fib(n / 2);\n        } else {\n            return Fib(n\
    \ / 2) + Fib(n / 2) - Fib(n / 2);\n        }", "        if (n == 0) return 0;\n\
    \        if (n == 1) return 1;\n        return Fib(n - 1) + Fib(n - 2);", "  \
    \      // Check argument.\n        if (n < 0)\n            throw new ArgumentOutOfRangeException(\"\
    n\");\n        // Initialization.\n        long a = 0, b = 1, c;\n        bool\
    \ isFirst = true;\n        while (n > 1) {\n            c = a + b;\n         \
    \   a = b;\n            b = c;\n            isFirst = !isFirst;\n            n--;\n\
    \        }\n        return isFirst ? a : b;", "        // Using BigInteger's built\
    \ in Fibonacci method.\n        // Note: Use '^' for exponentiation.\n       \
    \ return BigInteger.Pow((BigInteger.One, BigInteger.Zero),\n                 \
    \            (n-1))\n            .Mod(BigInteger.Two)\n            .LongValue();",
  '        return Fib(n, n);', '        return n < 2 ? n : Fib(n-2) + Fib(n-1);',
  "        if (n < 2) return n;\n        var cache = new Dictionary<long, long>();\n\
    \        return Fib(n, cache);", "        if (n == 0)\n            return 0;\n\
    \        if (n == 1)\n            return 1;\n        long a = Fib(n-1);\n    \
    \    long b = Fib(n-2);\n        return a + b;", "        if (n < 3) {\n     \
    \       return 1;\n        }\n        if (n == 3) {\n            return 1;\n \
    \       }\n        return Fib(n-1) + Fib(n-2);", "        if (n <= 1) return n;\n\
    \        return Fib(n-1) + Fib(n-2);", "        long fib_1st_value = 1;\n    \
    \    long fib_2nd_value = 1;\n        if (n > 1)\n            fib_2nd_value =\
    \ fib_1st_value;\n        for (int i = 1; i <= n; i++) {\n            fib_1st_value\
    \ = fib_2nd_value;\n            fib_2nd_value = fib_1st_value + fib_2nd_value;\n\
    \        }\n        return fib_2nd_value;", "        if (n < 0) {\n          \
    \  throw new ArgumentOutOfRangeException(\"n\");\n        }\n        if (n ==\
    \ 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return\
    \ 1;\n        }\n        if (n % 2 == 0) {\n            return Fib(n - 1) + Fib(n\
    \ - 2);\n        }\n        long a = Fib(n / 2);\n        long b = Fib(n / 2)\
    \ - a;\n        return a + b;", "        if (n == 0) return 0L;\n        if (n\
    \ == 1L) return 1L;\n        return Fib(n-1L) + Fib(n-2L);", "        long a =\
    \ 1;\n        long b = 1;\n        for (long i = 0; i < n; i++) {\n          \
    \  a = b;\n            b = a + b;\n        }\n        return b;", "        var\
    \ cache = new HashSet<long>();\n        if (n <= 1) return 1;\n        cache.Add(1);\n\
    \        if (n <= 2) return 1;\n        cache.Add(1);\n        if (n <= 3) return\
    \ 1;\n        cache.Add(1);\n        if (n <= 4) return 1;\n        cache.Add(1);\n\
    \        if (n <= 5) return 1;\n        cache.Add(1);\n        if (n <= 8) return\
    \ 1;\n        cache.Add(1);\n        if (n <= 13) return 1;\n        cache.Add(1);\n\
    \        if (n <= 20) return 1;\n        cache.Add(1);\n        if (n <= 40) return\
    \ 1;\n        cache.Add(1);\n        if (n <= 75) return 1;\n        cache.Add(1);\n\
    \        if (n <= 150) return 1;\n        cache.Add(1);\n        if (n <= 250)\
    \ return 1;\n        cache.Add(1);\n        if (n <= 500) return 1;\n        cache.Add(1);\n\
    \        if (n <= 1000) return 1;\n        cache.Add(1);\n        if (n <= 2000)\
    \ return 1;\n        cache.Add(1);\n        if (n <= 5000) return 1;\n       \
    \ cache.Add(1);\n        if (n <= 10000) return 1;\n        cache.Add(1);\n  \
    \      if (n <= 20000) return 1;\n        cache.Add(1);\n        if (n <= 50000)\
    \ return 1;\n        cache.Add(1);\n        if (n <= 100000) return 1;\n     \
    \   cache.Add(1);\n        if (n <= 2000000) return 1;\n        cache.Add(1);\n\
    \        if (n <= 5000000) return 1;\n        cache.Add(1);\n        if (n <=\
    \ 10000000) return 1;\n        cache.Add(1);\n        if (n <= 20000000) return\
    \ 1;\n        cache.Add(1);\n        if (n <= 50000000) return 1;\n        cache.Add(1);\n\
    \        if (n <= 100000000) return 1;\n        cache.Add(1);\n        if (n <=\
    \ 200000000) return 1;\n        cache.Add(1);\n        if (n <= 500000000) return\
    \ 1;\n        cache.Add(1);\n        if (n <= 1000000000) return 1;\n        cache.Add(1);\n\
    \        if (n <= 2000000000) return 1;\n        cache.Add(1);\n        if (n\
    \ <= 5000000000) return 1;\n        cache.Add(1);\n        if (n <= 10000000000)\
    \ return 1;\n        cache.Add(1);\n        if (n <= 20000000000) return 1;\n\
    \        cache.Add(1);\n        if (n <= 50000000000) return 1;\n        cache.Add(1);\n\
    \        if (n <= 100000000000) return 1;\n        cache.Add(1);\n        if (n\
    \ <= 200000000000) return 1;\n        cache.Add(1);\n        if (n <= 500000000000)\
    \ return 1;\n        cache.Add(1);\n        if (n <= 1000000000000) return 1;\n\
    \        cache.Add(1);\n        if (n <= 2000000000000) return 1;\n        cache.Add(1);\n\
    \        if (", "        long previous = 0;\n        long current  = 1;\n    \
    \    long sum = current;\n        \n        for (int i = 1; i <= n; ++i) {\n \
    \           previous = current;\n            current = previous + current;\n \
    \           sum += current;\n        }\n\n        return sum;", "        Debug.Assert(n\
    \ >= 0);\n        if (n == 0) {\n            return 0;\n        }\n        if\
    \ (n == 1) {\n            return 1;\n        }\n        long a = 1;\n        long\
    \ b = 1;\n        for (long i = 2; i <= n; i++) {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return b;", "    \
    \    if (n < 3) return n;\n        if (n == 3) return 1;\n        return Fib(n\
    \ - 1) + Fib(n - 2);", "        if (n == 0) {\n            return 0;\n       \
    \ }\n        if (n == 1) {\n            return 1;\n        }\n        return Fib((n\
    \ - 1)) + Fib((n - 2));", "        if ((n <= 0L) || (n == 1L))\n            return\
    \ n; // Single Fibonacci number found.\n        long[] fib = new long[n];\n  \
    \      fib[0] = 0L;\n        fib[1] = 1L;\n        for (int i = 2; i < n; i++)\
    \ {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        return\
    \ fib[n];", "        if ((n == 0) || (n == 1)) {\n            return n;\n    \
    \    }\n        long a = 0, b = 1;\n        long fib = 0;\n        // Go through\
    \ all values of n.\n        for (int i = 0; i < n; i++) {\n            long tmp\
    \ = a;\n            a = b;\n            b = tmp + b;\n            fib = fib +\
    \ a;\n        }\n        return fib;", "        if (n <= 1) return n;\n      \
    \  return Fib(n - 1) + Fib(n - 2);", "        if (n < 2)\n            return n;\n\
    \n        long a = 1;\n        long b = 2;\n        while (n > 0) {\n        \
    \    long cur = a + b;\n            a = b;\n            b = cur;\n           \
    \ n--;\n        }\n        return a;", "        double x = Math.Pow(2L, n);\n\
    \        long y = Math.Pow(5L, n) - 1;\n        double d = Math.Pow(x, 5L);\n\
    \        return (long)(Math.Round(d * Math.Sin(y))); // Return n th Fibonacci\
    \ number.", "        long a = 1;\n        long b = 1;\n        for (int i = 0;\
    \ i < n; i++) {\n            long x = a + b;\n            a = b;\n           \
    \ b = x;\n        }\n        return b;", "        long first = 1;\n        long\
    \ second = 1;\n        long fib = 0;\n        for (long i = 3; i <= n; i++) {\n\
    \            fib = first + second;\n            first = second;\n            second\
    \ = fib;\n        }\n        return fib;", "        // base cases: n < 1\n   \
    \     if (n < 2) return n;\n        // get first two numbers, then compute\n \
    \       long a = Fib((n-1));\n        long b = Fib((n-2) + 1);\n        // return\
    \ nth Fibonacci number\n        return a + b;", "        long a = 1, b = 1;\n\
    \        for (int i = 0; i < n; i++)\n        {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return a;", "    \
    \    // Return value if n is 0 or 1.\n        if (n < 2) return n;\n\n       \
    \ // Recursion base case.\n        if (n == 1) return 1;\n\n        // Recursion\
    \ step.\n        return Fib(n-2) + Fib(n-1);", "        var c = new BigInteger();\n\
    \        if (n < 0) {\n            throw new ArgumentException(\"n must be >=\
    \ 0\");\n        }\n        if (n == 0) \n            return 0;\n        if (n\
    \ == 1) \n            return 1;\n        c.SetBit(1);\n        c.SetBit(0);\n\
    \        var n2 = BigInteger.Multiply(c, c);\n        for (int i = 2; i <= n;\
    \ i++) {\n            BigInteger.Add(n2, n2);\n        }\n        BigInteger.DivRem(n2,\
    \ c, out c, out c);\n        return c;", "        if (n == 0 || n == 1) return\
    \ 1;\n        return Fib(n-1) + Fib(n-2);", "        if (n == 0) return 0;\n \
    \       if (n == 1) return 1;\n        if (n % 2 == 1) return Fib(n * 3) + Fib(n\
    \ * 3) + Fib(n * 3) + Fib(n * 3);\n        else return Fib(n * 3) + Fib(n * 3);",
  "        if (n == 0 || n == 1L) {\n            return n;\n        }\n        return\
    \ Fib(n-1L) + Fib(n-2L);", "        if (n < 2) return n;\n        return Fib(n-2)\
    \ + Fib(n-1);", "        // Base conditions.\n        if (n <= 1) return 1;\n\
    \        if (n == 2) return 2;\n        if (n % 2 == 0) return Fib(n / 2); //\
    \ Non-even Fibonacci.\n        if (n % 2 == 1) return Fib(n - 1); // Even Fibonacci.\n\
    \n        // Recursive step.\n        long a = Fib((n / 2)); // Calculate nth\
    \ Fibonacci number for n-1 / 2.\n        long b = Fib((n - 1)); // Calculate nth\
    \ Fibonacci number for n - 1.\n        return a + b;", "        if (n == 0 ||\
    \ n == 1)\n            return n;\n        else\n            return Fib(n-1) +\
    \ Fib(n-2);", "        long a = 1;\n        long b = 1;\n        if (n == 0) {\n\
    \            return 0;\n        } else if (n == 1) {\n            return 1;\n\
    \        } else {\n            for (long i = 2; i < n; i++) {\n              \
    \  long temp = a;\n                a = b;\n                b = temp + b;\n   \
    \         }\n            return b;\n        }", "        long ret = 0;\n     \
    \   if (n == 0)\n            return 0;\n        if (n == 1)\n            return\
    \ 1;\n        long first = 0;\n        long second = 1;\n        for (int i =\
    \ 3; i < n; i++) {\n            ret = first + second;\n            first = second;\n\
    \            second = ret;\n        }\n        return ret;", "        if (n <=\
    \ 0) return 0;\n        if (n <= 1) return n;\n        long a = Fib(n/2);\n  \
    \      long b = Fib(n - a/2);\n        return a + b;", "        // If n is zero,\
    \ return zero.\n        if (n == 0)\n            return 0;\n        // If n is\
    \ 1, return 1.\n        if (n == 1)\n            return 1;\n        // If n is\
    \ 2, return 2.\n        if (n == 2)\n            return 2;\n        // Otherwise\n\
    \        // Create a recursive function that computes Fibonacci numbers.\n   \
    \     long F = Fib(n - 1) + Fib(n - 2);\n        return F;", "        if (n <\
    \ 2) return 1L;\n        else\n            return Fib(n-1L) + Fib(n-2L);", " \
    \       long f = 1, g = 2, r = 3;\n        long[] arr = new long[n];\n\n     \
    \   for(int i = 0; i < n; i++){\n            arr[i] = f;\n            f += g;\n\
    \            g += r;\n            r += g;\n        }\n        return arr[n - 1];",
  "        long a = 1;\n        long b = 1;\n        while (n > 1) {\n           \
    \ long c = a + b;\n            long d = a;\n            a = b;\n            b\
    \ = c;\n            n = n - 1;\n        }\n        return b;", "        if (n\
    \ <= 1L) {\n            return 1L;\n        }\n        long last = 1L;\n     \
    \   long first = 0L;\n        while (n > 0) {\n            long next = first +\
    \ last;\n            last = first;\n            first = next;\n            n -=\
    \ 1;\n        }\n        return last;", "        long prev1 = 0, prev2 = 1;\n\
    \        long result = 0;\n\n        // Set initial value for fib(n) = fib(n-1)\
    \ + fib(n-2).\n        if (n > 2) {\n            prev1 = Fib(n - 1);\n       \
    \     prev2 = Fib(n - 2);\n        }\n\n        // Do a binary search for the\
    \ n-th Fibonacci number.\n        for (int i = 0; i < n; i++) {\n            //\
    \ Add fib(n-i)\n            result += (n - i) * prev1 + i * prev2;\n        }\n\
    \n        // Return fib(n).\n        return result;", "        // The Fibonacci\
    \ sequence begins with 1, 1, 2, 3,\n        // 5, 8, 13, ... So we start with\
    \ the second\n        // number in the sequence and work towards\n        // the\
    \ first.\n        long b = 1;\n        long c = 2;\n        long d = c;\n    \
    \    for (int i = n; i > 0; i--) {\n            long sum = b + c;\n          \
    \  // We only want to go up to n\n            if (i == 1L) {\n               \
    \ // If we're at the first number in the\n                // sequence, return\
    \ it and we're done.\n                return sum;\n            }\n           \
    \ b += d;\n            c += d;\n            d = sum;\n        }\n        // If\
    \ we get here the sequence did not complete.\n        // Return the last number\
    \ in the sequence.\n        return c;", "        if (n <= 3) return 1;\n     \
    \   if (n <= 5) return 2;\n        long x = Fib(n-2) + Fib(n-1);\n        if (x\
    \ > n) x = (long)Math.Pow((double)x, (double)n);\n        return x;", "      \
    \  if (n <= 2L) return 1L;\n        return (1L + Fib(n - 2L));", "        if (n\
    \ <= 1L) {\n            return 1L;\n        } else {\n            long a = Fib(n\
    \ + 1L);\n            long b = Fib(n + 2L);\n            return (b - a) / 2;\n\
    \        }", "        if (n <= 0) return 0;\n        if (n <= 1) return 1;\n \
    \       long a = Fib(n-2) + Fib(n-1);\n        return a;", "        long x = 0;\n\
    \        long y = 1;\n        if (n == 0)\n            return x;\n        if (n\
    \ == 1)\n            return y;\n        for (long i = 3; i <= n; i++) {\n    \
    \        long sum = x + y;\n            x = y;\n            y = sum;\n       \
    \ }\n        return y;", "        long a = 0, b = 1;\n        for (long i = 0;\
    \ i < n; i++) {\n            long c = a + b;\n            a = b;\n           \
    \ b = c;\n        }\n        return b;", "        if (n <= 1) return 1;\n    \
    \    if (n <= 3) return 2;\n        return Fib(n-2)+Fib(n-1);", "        if (n\
    \ == 0) return 0;\n        if (n == 1) return 1;\n        var result = Fib(n-1);\n\
    \        result += Fib(n-2);\n        return result;", "        if (n == 0) return\
    \ 0;\n        if (n == 1) return 1;\n        long a = Fib((n - 2));\n        long\
    \ b = Fib((n - 1));\n        return a + b;", "        // This algorithm is O(n).\n\
    \        // Calculate the nth Fibonacci number by reusing the result.\n      \
    \  long a = 1, b = 1;\n        for (long i = 0; i < n; i++) {\n            //\
    \ Add two previous numbers.\n            long c = a + b;\n            // Replace\
    \ the old number with the new\n            a = b;\n            b = c;\n      \
    \  }\n        return b;", "        long a = 1L, b = 1L;\n        for (long i =\
    \ 0; i < n; i++) {\n            long c = a;\n            a = b;\n            b\
    \ = c;\n        }\n        return b;", "        if (n < 2)\n            return\
    \ n;\n        return Fib(n-1) + Fib(n-2);", "        long a = 1;\n        long\
    \ b = 1;\n        for (long i = 0; i <= n; i++)\n        {\n            long c\
    \ = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ a;", "        long prev1 = 0, prev2 = 1, current, current, result;\n       \
    \ for (long i = 3; i < n; i += 2)\n        {\n            current = prev1 + prev2;\n\
    \            prev1 = prev2;\n            prev2 = current;\n        }\n       \
    \ result = prev1;\n        return result;", "        long a = 0, b = 1;\n    \
    \    for (long i = 0; i < n; i++) {\n            long c = a + b;\n           \
    \ a = b;\n            b = c;\n        }\n        return b;", "        if (n <=\
    \ 1) return n;\n        return Fib(n-2) + Fib(n-1);", "        long[] a = new\
    \ long[16];\n        a[0] = 1;\n        a[1] = 1;\n        a[2] = 2;\n       \
    \ long cur = a[2];\n        long temp;\n        for(int i = 0; i < n; i++) {\n\
    \            long temp = a[i - 1] + a[i];\n            a[i] = temp;\n        \
    \    cur = temp;\n        }\n        return cur;", "        if (n <= 1)\n    \
    \        return n;\n        return Fib(n-2) + Fib(n-1);", "        if (n < 0L)\
    \ throw new ArgumentOutOfRangeException(\"n\");\n        long fib1 = 0L;\n   \
    \     long fib2 = 0L;\n        long current = 0L;\n        for (long k = 0; k\
    \ <= n; k++) {\n            current = (fib1 + fib2);\n            fib1 = fib2;\n\
    \            fib2 = current;\n        }\n        return current;", "        var\
    \ f = new System.Numerics.BigInteger(\"0\");\n        var a = new System.Numerics.BigInteger(\"\
    1\");\n        for (var i = 1; i < n; i++) {\n            f.Add(a);\n        \
    \    a = f.Add(a);\n        }\n        return f.ToLong();", "        if (n ==\
    \ 0) return 0;\n        if (n == 1) return 1;\n        return Fib(n-1) + Fib(n-2);",
  "        if (n == 0)\n            return 0;\n        if (n == 1)\n            return\
    \ 1;\n        long a = Fib((n - 1L));\n        long b = Fib((n - 2L));\n     \
    \   return (a + b) % 2L;", "        long first = 0, second = 1;\n        long\
    \ result = first;\n        while (n > 1) {\n            long temp = second;\n\
    \            second = first;\n            first = temp + second;\n           \
    \ n--;\n        }\n        return result;", "        long p = 1;\n        long\
    \ q = -1;\n\n        if (n <= 0) {\n            throw new ArgumentOutOfRangeException(\"\
    n\");\n        }\n        if (n == 1) {\n            return 1;\n        }\n  \
    \      while (true) {\n            long x = p + q;\n            if (x != 0) {\n\
    \                p = q;\n                q = x;\n            }\n            else\
    \ {\n                break;\n            }\n        }\n\n        return q;", " \
    \       long[] numbers = new long[] { 0, 1 };\n\n        // Fill up the array\
    \ of numbers using the formula.\n        long sum = 0;\n        for (long i =\
    \ 0; i < n; i++) {\n            long j = numbers[i - 1] + numbers[i - 2];\n  \
    \          numbers[i] = j;\n            sum += j;\n        }\n\n        return\
    \ sum;", "        if (n <= 0)\n            throw new ArgumentOutOfRangeException(nameof(n));\n\
    \n        if (n == 1)\n            return 1;\n        if (n == 2)\n          \
    \  return 1;\n        long x = Fib(n-1) + Fib(n-2);\n        return x;", "   \
    \     if (n <= 0) {\n            throw new ArgumentOutOfRangeException(\"n\",\
    \ \"n must be greater than 0\");\n        }\n\n        long a = 1;\n        long\
    \ b = 1;\n        for (long i = 2; i <= n; i++) {\n            a = b;\n      \
    \      b = a + b;\n        }\n        return b;", "        // Special cases:\n\
    \        if (n == 0) return 0;\n        if (n == 1) return 1;\n        long a\
    \ = Fib(n-1);\n        long b = Fib(n-2);\n        return a + b;", "        long\
    \ a = 0;\n        long b = 1;\n        if (n == 0) return 0;\n        if (n ==\
    \ 1) return b;\n        for (int i = 0; i < n; i++) {\n            long temp =\
    \ a;\n            a = b;\n            b = temp + b;\n        }\n        return\
    \ b;", "        var previous = 1;\n        var current = 2;\n        long result\
    \ = 1;\n        long fib = 0;\n        // while (fib <= n) { fib = previous +\
    \ current;\n        while (fib <= n) {\n            result = current;\n      \
    \      current = previous;\n            previous = fib;\n            fib = result\
    \ + current;\n        }\n        return result;", "        long a = 0L, b = 1L,\
    \ fib;\n        fib = 0;\n        for (long k = 1; k <= n; k++)\n        {\n \
    \           fib = Math.Pow(b, k);\n            a = b;\n            b = fib;\n\
    \        }\n        return fib;", "        if (n < 1) return 1;\n        if (n\
    \ <= 2) return n;\n        return Fib(n - 1) + Fib(n - 2);", "        long a =\
    \ 1, b = 0, c;\n        for (long i = 0; i <= n; i++) {\n            c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return a;", "    \
    \    if (n == 0) return 0;\n        if (n == 1) return 1;\n        return Fib(n-1)\
    \ + Fib(n-2);", "        long previous = 0;\n        long current = 1;\n     \
    \   for (int i = 0; i < n; i++) {\n            previous = current;\n         \
    \   current = current + previous;\n        }\n        return current;", "    \
    \    if (n < 2L)\n            return 1L;\n        return Fib((n - 1L) + (n - 2L));",
  "        if (n <= 1L) {\n            return n; }\n        else { \n            return\
    \ Fib(n-2) + Fib(n-1); }", "        long a = 1L;\n        long b = 2L;\n     \
    \   long c = a + b;\n        long d = c + b;\n        long e = c + d;\n      \
    \  long f = d + e;\n        long g = e + f;\n        long h = f + g;\n       \
    \ long i = g + h;\n        long j = h + i;\n        long k = i + j;\n        long\
    \ l = j + k;\n        long m = k + l;\n        long n = l + m;\n        long o\
    \ = m + n;\n        long p = n + o;\n        long q = o + p;\n        long r =\
    \ p + q;\n        long s = q + r;\n        long t = r + s;\n        long u = s\
    \ + t;\n        long v = t + u;\n        long w = u + v;\n        long x = v +\
    \ w;\n        long y = w + x;\n        long z = x + y;\n        long a = a + z;\n\
    \        long b = b + a;\n        long c = c + b;\n        long d = d + c;\n \
    \       long e = e + d;\n        long f = f + e;\n        long g = g + f;\n  \
    \      long h = h + g;\n        long i = i + h;\n        long j = j + i;\n   \
    \     long k = k + j;\n        long l = l + k;\n        long m = m + l;\n    \
    \    long n = n + m;\n        long o = o + n;\n        long p = p + o;\n     \
    \   long q = q + p;\n        long r = r + q;\n        long s = s + r;\n      \
    \  long t = t + s;\n        long u = u + t;\n        long v = v + u;\n       \
    \ long w = w + v;\n        long x = x + w;\n        long y = y + x;\n        long\
    \ z = z + y;\n        long a = a + z;\n        long b = b + a;\n        long c\
    \ = c + b;\n        long d = d + c;\n        long e = e + d;\n        long f =\
    \ f + e;\n        long g = g + f;\n        long h = h + g;\n        long i = i\
    \ + h;\n        long j = j + i;\n        long k = k + j;\n        long l = l +\
    \ k;\n        long m = m + l;\n        long n = n + m;\n        long o = o + n;\n\
    \        long p = p + o;\n        long q = q + p;\n        long r = r + q;\n \
    \       long s = s + r;\n        long t = t + s;\n        long u = u + t;\n  \
    \      long v = v + u;\n        long w = w + v;\n        long x = x + ", "   \
    \     long a = 1, b = 0, i = 1;\n        while (i != n) {\n            long next\
    \ = b;\n            b = a + b;\n            a = next;\n            i = 1;\n  \
    \      }\n        return a;", "        long a = 0, b = 1;\n        for (long i\
    \ = 0; i < n; i++) {\n            long c = a + b;\n            a = b;\n      \
    \      b = c;\n        }\n        return a;", "        if (n == 0)\n         \
    \   return 0;\n        if (n == 1)\n            return 1;\n        long previous\
    \ = 0;\n        long current = 1;\n        long next = 1;\n        for (int i\
    \ = 0; i < n; i++) {\n            previous = current;\n            current = next;\n\
    \            next = previous + current;\n        }\n        return current;",
  "        if (n < 2) return n;\n        long result = Fib(n-1) + Fib(n-2);\n    \
    \    Console.WriteLine(string.Format(\"Fib({}): ({})\", n, result));\n       \
    \ return result;", "        var f = new List<long>();\n        f.Add(1);\n   \
    \     f.Add(1);\n        long f1 = 1;\n        long f2 = 1;\n        bool done\
    \ = false;\n        while (f.Count < n && !done) {\n            long temp = f1;\n\
    \            f1 = f2;\n            f2 = temp + f1;\n            f.Add(f2);\n \
    \       }\n        if (f.Count > n) done = true;\n        return (f.Count > 1\
    \ ? f.Last() : 0);", "        long a = 1, b = 1, ans = 1;\n        while (n >\
    \ 2) {\n            long c = a + b;\n            ans = c;\n            a = b;\n\
    \            b = c;\n            n--;\n        }\n        return ans;", "    \
    \    if (n < 0) throw new ArgumentOutOfRangeException(\"n\");\n        if (n <\
    \ 2) return n;\n        var f1 = 0, f2 = 1;\n        var t = (long) Math.Pow(2,\
    \ n) / 2;\n        while ((t) > 0) {\n            var q = f1 / f2;\n         \
    \   var r = f1 - q * f2;\n            f2 = f1;\n            f1 = r;\n        \
    \    t -= 1;\n        }\n        return f1;", "        if (n <= 2) {\n       \
    \     return n;\n        }\n        return Fib(n-1) + Fib(n-2);", "        if\
    \ (n < 2)\n            return n;\n        return Fib(n-1) + Fib(n-2);", "    \
    \    // Base cases.\n        if (n < 2) return n;\n        if (n <= 3) return\
    \ 1;\n\n        // Recursively compute Fibonacci number for smaller values of\
    \ n.\n        return Fib(n-2) + Fib(n-1);", "        long x = 0, y = 1, z = 1;\n\
    \        long r = 1;\n        for (int i = 0; i < n; i++) {\n            r = z\
    \ * (x + y);\n            x = y;\n            y = z;\n            z = r;\n   \
    \     }\n        return z;", "        if (n <= 1)\n            return n;\n\n \
    \       long a = 1;\n        long b = 1;\n        for (long i = 3; i <= n; i++)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \     }\n\n        return b;", "        long x = 0;\n        long y = 1;\n   \
    \     long z = n;\n        while (n > 0) {\n            n = n - 1;\n         \
    \   z = x + y;\n            x = y;\n            y = z;\n        }\n        return\
    \ y;", "        long first = 1, second = 0, prev = 0;\n        for (long i = 0;\
    \ i < n; ++i) {\n            long next = first + second;\n            first =\
    \ second;\n            second = next;\n            prev = prev + next;\n     \
    \   }\n        return prev;", "        if (n == 0)\n            return 0;\n  \
    \      if (n == 1)\n            return 1;\n        return Fib(n-2) + Fib(n-1);",
  "        if (n <= 0) throw new ArgumentOutOfRangeException(\"n\");\n        if (n\
    \ == 1) return 1;\n        return Fib(n - 2) + Fib(n - 1);", "        long fib\
    \ = 0;\n        long last = 1;\n        long temp = 0;\n        do {\n       \
    \     temp = last;\n            last = fib;\n            fib = last + temp;\n\
    \        } while (--n >= 0);\n        return fib;", "        long fib1 = 0, fib2\
    \ = 1;\n        while (fib1 <= n) {\n            long tmp = fib1;\n          \
    \  fib1 = fib2;\n            fib2 = tmp + fib1;\n        }\n        return fib2;",
  "        if (n <= 1) {\n            return n;\n        } else {\n            return\
    \ Fib((n - 1) + Fib(n - 2));\n        }", "        if (n == 0 || n == 1) {\n \
    \           return n;\n        }\n        if (n == 2) {\n            return 1;\n\
    \        }\n        long a = Fib((n-1L));\n        long b = Fib((n-2L));\n   \
    \     return a+b;", "        // Simplify the condition in one place instead of\
    \ three:\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n     \
    \   // Return Fib(n - 1) + Fib(n - 2):\n        return Fib(n-2) + Fib(n-1);",
  "        if (n < 0)\n            throw new ArgumentOutOfRangeException(\"n\");\n\
    \        long f1 = 1, f2 = 1;\n        long result;\n        while ((n % 2) ==\
    \ 1) {\n            f1 = f1 + f2;\n            f2 = f1;\n            n = n/2;\n\
    \        }\n        result = f1 + f2;\n        return result;", "        if (n\
    \ < 2)\n            return n;\n        long result = 0;\n        long fib1 = 1;\n\
    \        long fib2 = 1;\n        while (fib2 != n) {\n            result = fib1;\n\
    \            fib1 = fib2;\n            fib2 = result + fib2;\n        }\n    \
    \    return result;", "        if (n <= 1)\n            return n;\n        var\
    \ fib = new List<long>(3);\n        fib[0] = 0;\n        fib[1] = 1;\n       \
    \ fib[2] = 1;\n        for (int i = 2; i < n; i++) {\n            fib[0] = fib[0]\
    \ + fib[1];\n            fib[1] = fib[1];\n            fib[2] = fib[0] + fib[1];\n\
    \        }\n        return fib[(int)Math.Truncate(n) - 1];", "        // Sift\
    \ through the Fibonacci series using memoization.\n        if (fibs == null)\n\
    \            fibs = new Dictionary<long, long>();\n        \n        long curr\
    \ = 0, prev = 1;\n        long fib;\n        \n        while ((fib = fibs.ContainsKey(n))\
    \ && fib < n)\n            prev = curr, curr = fib, fib = prev + curr;\n     \
    \   \n        if (fib == n)\n            return fib;\n        \n        // Recursive\
    \ case found - return Fibonacci number. \n        if (n < 0L)\n            return\
    \ n;\n        \n        fibs.Add(n, curr);\n        \n        // Recursive case\
    \ uncovered - add Fibonacci numbers and then return the\n        // last one.\n\
    \        return Fib(n - 1) + Fib(n - 2);", "        long previous = 0, current;\n\
    \        if (n == 0 || n == 1) {\n            current = 0;\n        } else {\n\
    \            while (true) {\n                current = previous + current;\n \
    \               if (current > n) {\n                    break;\n             \
    \   }\n                previous = current;\n            }\n        }\n       \
    \ return current;", "        if (n <= 1) return 1;\n        return Fib(n-1) +\
    \ Fib(n-2);", "        // Implementation: \n        // https://en.wikipedia.org/wiki/Memoization\n\
    \        if (n == 0 || n == 1) {\n            return n;\n        }\n        long\
    \ fibo_cache;\n        long fibo_cache2 = n;\n        if (fibo_cache == null)\
    \ {\n            fibo_cache = fibo_cache2;\n        } else {\n            fibo_cache\
    \ = fibo_cache2;\n        }\n        return fibo_cache;", "        if (n <= 0)\
    \ return (long)(0);\n        if (n <= 1) return (long)(1);\n        var f0 = Fib((n-1));\n\
    \        var f1 = Fib((n-2) + 1);\n        return f0 + f1;", "        if (n ==\
    \ 0) return 0;\n        if (n == 1) return 1;\n        long a = Fib(n-2); long\
    \ b = Fib(n-1); return a+b;", "        if (n < 1) return 0;\n        if (n ==\
    \ 1) return 1;\n        if (n == 2) return 1;\n        return Fib(n - 1) + Fib(n\
    \ - 2);", "        long[] cache = new long[50];\n        if (n <= 2) {\n     \
    \       return n;\n        }\n        if (n <= 5) {\n            return cache[n];\n\
    \        }\n        if (n <= 8) {\n            return Fib(n - 1) + Fib(n - 2);\n\
    \        }\n        if (n <= 100) {\n            cache[0] = Fib(0);\n        \
    \    cache[1] = Fib(1);\n            return cache[n];\n        }\n        long[]\
    \ nums = new long[100];\n        long result = nums[0];\n        long a = nums[1];\n\
    \        for (int i = 2; i <= n; i++) {\n            nums[i - 1] = a;\n      \
    \      a = b;\n            b = nums[i - 2];\n            result *= a;\n      \
    \  }\n        return result;", "        long f = 1;\n        for (int i = 1; i\
    \ < n; i++) {\n            f += f;\n        }\n        return f;", "        if\
    \ (n == 1) return 1;\n        if (n == 2) return 2;\n        return Fib(n-1) +\
    \ Fib(n-2);", "        if (n < 1) return 0L;\n        if (n == 1L) return 1L;\n\
    \        return (Fib(n - 1) + Fib(n)) / 2L;", "        if (n < 0) throw new ArgumentOutOfRangeException(\"\
    n\");\n        long fibArray[] = new long[n + 1];\n        fibArray[0] = 0;\n\
    \        fibArray[1] = 1;\n        for (int i = 2; i <= n; i++) {\n          \
    \  long sum = fibArray[i - 1] + fibArray[i - 2];\n            fibArray[i] = sum;\n\
    \        }\n        return fibArray[n];", "        if (n < 2)\n            return\
    \ 1;\n        return Fib(n - 2) + Fib(n - 1);", "        if (n <= 2) return 1;\n\
    \        long a, b = 1, c = 1;\n        while (b < n) {\n            long d =\
    \ a + c;\n            a = c;\n            c = d;\n            b++;\n        }\n\
    \        return b;", "        if (n < 2) {\n            return n;\n        } else\
    \ {\n            return Fib(n-1) + Fib(n-2);\n        }"]
stop_tokens:
- "\n    }\n"
