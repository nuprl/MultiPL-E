name: HumanEval_160_do_algebra
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given two lists operator, and operand. The first list has basic\
  \ algebra operations, and \n    // the second list is a list of integers. Use the\
  \ two given lists to build the algebric \n    // expression and return the evaluation\
  \ of this expression.\n    // The basic algebra operations:\n    // Addition ( +\
  \ ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor division\
  \ ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
  \ '*', '-']\n    // list = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    // =>\
  \ result = 9\n    // Note:\n    // The length of operator list is equal to the length\
  \ of operand list minus one.\n    // Operand is a list of of non-negative integers.\n\
  \    // Operator list has at least one operator, and operand list has at least two\
  \ operands.\n    public static long DoAlgebra(List<string> op, List<long> operand)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(DoAlgebra((new\
  \ List<string>(new string[]{(string)\"**\", (string)\"*\", (string)\"+\"})), (new\
  \ List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));\n\
  \    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)\"+\", (string)\"\
  *\", (string)\"-\"})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L,\
  \ (long)5L}))) == (9L));\n    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)\"\
  //\", (string)\"*\"})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L})))\
  \ == (8L));\n    }\n\n}\n"
completions: ["        if (operand.Count < 2 || op.Count < 2) \n            return\
    \ 0;\n        long ret = 0;\n        foreach(string x in op) {\n            switch(x)\
    \ {\n                case \"+\": \n                    ret += operand.First();\n\
    \                    operand.RemoveAt(0);\n                    break;\n      \
    \          case \"*\": \n                    ret *= operand.First();\n       \
    \             operand.RemoveAt(0);\n                    break;\n             \
    \   case \"-\": \n                    ret -= operand.First();\n              \
    \      operand.RemoveAt(0);\n                    break;\n                case\
    \ \"/\": \n                    ret /= operand.First();\n                    operand.RemoveAt(0);\n\
    \                    break;\n                case \"//\": \n                 \
    \   ret /= operand.First();\n                    operand.RemoveAt(0);\n      \
    \              break;\n                case \"**\": \n                    ret\
    \ **= operand.First();\n                    operand.RemoveAt(0);\n           \
    \         break;\n                default:\n                    return 0;\n  \
    \          }\n        }\n        if (operand.Count > 0)\n            return ret;\n\
    \        return 0;", "        long result = 0;\n        foreach (string s in op)\n\
    \            if (s == \"+\")\n                result += operand.Last();\n    \
    \        else if (s == \"-\")\n                result -= operand.Last();\n   \
    \         else if (s == \"*\")\n                result *= operand.Last();\n  \
    \          else if (s == \"/\")\n                result /= operand.Last();\n \
    \           else if (s == \"**\")\n                result **= operand.Last();\n\
    \            else\n                throw new InvalidProgramException();\n    \
    \    return result;", "        long result = 1;\n        foreach (string op2 in\
    \ op.Take((operand.Count - 1)))\n            foreach (long val in operand.Skip(1))\n\
    \                switch (op2) {\n                    case \"+\": result += val;\n\
    \                        break;\n                    case \"-\": result -= val;\n\
    \                        break;\n                    case \"*\": result *= val;\n\
    \                        break;\n                    case \"//\": result /= val;\n\
    \                        break;\n                    case \"**\": result **= val;\n\
    \                        break;\n                    default: return -1;\n   \
    \             }\n        return result;", "        long result = 0;\n        string\
    \ operation = op.FirstOrDefault();\n\n        // Addition\n        if (operation\
    \ == \"+\") {\n            long sum = 0;\n            foreach (var a in operand)\
    \ {\n                sum += a;\n            }\n            result = sum;\n   \
    \     }\n\n        // Subtraction\n        if (operation == \"-\") {\n       \
    \     long diff = 0;\n            foreach (var a in operand) {\n             \
    \   diff += a;\n            }\n            result = diff;\n        }\n\n     \
    \   // Multiplication\n        if (operation == \"*\") {\n            long prod\
    \ = 1;\n            foreach (var a in operand) {\n                prod *= a;\n\
    \            }\n            result = prod;\n        }\n\n        // Floor division\n\
    \        if (operation == \"//\") {\n            long div = 1;\n            foreach\
    \ (var a in operand) {\n                div *= a;\n            }\n           \
    \ result = div;\n        }\n\n        // Exponentiation\n        if (operation\
    \ == \"**\") {\n            long exp = 1;\n            foreach (var a in operand)\
    \ {\n                exp *= a;\n            }\n            result = exp;\n   \
    \     }\n\n        return result;", "        if (op.Count != operand.Count - 1)\
    \ {\n            throw new Exception(\"Operator and operand list must be of the\
    \ same length.\");\n        }\n        List<string> operators = new List<string>(new\
    \ string[] {\n            \"+\", \"-\", \"*\", \"//\", \"**\"\n        });\n \
    \       long result = 1;\n        for (int i = 0; i < op.Count; i++) {\n     \
    \       if (operators.Contains(op[i])) {\n                switch (op[i]) {\n \
    \                   case \"+\":\n                        result += operand[i];\n\
    \                        break;\n                    case \"-\":\n           \
    \             result -= operand[i];\n                        break;\n        \
    \            case \"*\":\n                        result *= operand[i];\n    \
    \                    break;\n                    case \"//\":\n              \
    \          result /= operand[i];\n                        break;\n           \
    \         case \"**\":\n                        result /= operand[i];\n      \
    \                  result *= operand[i];\n                        break;\n   \
    \             }\n            } else {\n                throw new Exception(\"\
    Unsupported operator\");\n            }\n        }\n        return result;", " \
    \       // Sort by length.\n        List<string> sortedOperand = new List<string>(operand);\n\
    \        sortedOperand.Sort();\n\n        List<string> sortedOperator = new List<string>(op);\n\
    \        sortedOperator.Sort();\n\n        long result = 0;\n        string lastOperand\
    \ = \"\";\n        string lastOperator = \"\";\n\n        foreach (string oper\
    \ in sortedOperator) {\n            foreach (long operand in sortedOperand) {\n\
    \                if (oper == \"+\") {\n                    if (lastOperand.Length\
    \ > 0) {\n                        result += operand;\n                    }\n\
    \                    else {\n                        result += operand;\n    \
    \                }\n                    lastOperand = \"\";\n                }\n\
    \                else if (oper == \"-\") {\n                    if (lastOperand.Length\
    \ > 0) {\n                        result -= operand;\n                    }\n\
    \                    else {\n                        result -= operand;\n    \
    \                }\n                    lastOperand = \"\";\n                }\n\
    \                else if (oper == \"*\") {\n                    if (lastOperand.Length\
    \ > 0) {\n                        result *= operand;\n                    }\n\
    \                    else {\n                        result *= operand;\n    \
    \                }\n                    lastOperand = \"\";\n                }\n\
    \                else if (oper == \"/\") {\n                    //if (lastOperand.Length\
    \ > 0)\n                    //{\n                    //    result /= operand;\n\
    \                    //}\n                    //else\n                    //{\n\
    \                    //    result /= operand;\n                    //}\n     \
    \               //lastOperand = \"\";\n                    string s = operand.ToString();\n\
    \                    double div = Convert.ToDouble(s);\n                    double\
    \ div2 = Convert.ToDouble(lastOperand);\n                    if (div2 != 0) {\n\
    \                        result = Math.Round((result / div), 2);\n           \
    \         }\n                    else {\n                        result = Math.Round((result\
    \ / div), 2);\n                    }\n                    lastOperand = \"\";\n\
    \                }\n                else if (oper == \"**\") {\n             \
    \       if (lastOperand.Length > 0) {\n                        result *= operand;\n\
    \                    }\n                    else {\n                        result\
    \ *= operand;\n                    }\n                    lastOperand = \"\";\n\
    \                }\n            }\n        }\n        return result;", "     \
    \   long ret = 0;\n        long op1 = 0, op2 = 0, op3 = 0, op4 = 0;\n        foreach\
    \ (var x in operand) {\n            switch (op[0]) {\n                case \"\
    +\":\n                    op1 = x;\n                    break;\n             \
    \   case \"-\":\n                    op2 = x;\n                    break;\n  \
    \              case \"*\":\n                    op3 = x;\n                   \
    \ break;\n                case \"//\":\n                    op4 = x;\n       \
    \             break;\n            }\n        }\n        long op4 = op2 / op3;\n\
    \        ret = op1 + (op4 * op4);\n        return ret;", "        long result\
    \ = 0;\n        foreach (string opstr in op)\n            switch (opstr) {\n \
    \               case \"+\": result += operand.First(); break;\n              \
    \  case \"-\": result -= operand.First(); break;\n                case \"*\":\
    \ result *= operand.First(); break;\n                case \"//\": result /= operand.First();\
    \ break;\n                case \"**\": result *= operand.First(); result = Math.Pow(result,\
    \ operand.First()); break;\n            }\n        return result;", "        if\
    \ (op.Count != operand.Count - 1) {\n            throw new InvalidOperationException(\"\
    Operator list length must equal operand list length - 1\");\n        }\n\n   \
    \     Dictionary<string, Func<long, long, long>> operators = new Dictionary<string,\
    \ Func<long, long, long>>();\n        operators.Add(\"+\", (a, b) => a + b);\n\
    \        operators.Add(\"-\", (a, b) => a - b);\n        operators.Add(\"*\",\
    \ (a, b) => a * b);\n        operators.Add(\"/\", (a, b) => a / b);\n        operators.Add(\"\
    //\", (a, b) => a / b); \n\n        long result = 0;\n        foreach (string\
    \ s in op) {\n            double d = operand.ToList().ElementAtOrDefault(operand.Count\
    \ - 1).ToString();\n            result = operators[s](d);\n        }\n       \
    \ return result;", "        // TODO: Add error checking\n        long result =\
    \ 0;\n        foreach (var operation in op.Skip(1)) {\n            if (operation\
    \ == \"+\") {\n                result += operand[0];\n                operand.RemoveAt(0);\n\
    \            }\n            else if (operation == \"-\") {\n                result\
    \ -= operand[0];\n                operand.RemoveAt(0);\n            }\n      \
    \      else if (operation == \"*\") {\n                result *= operand[0];\n\
    \                operand.RemoveAt(0);\n            }\n            else if (operation\
    \ == \"//\") {\n                result = result / operand[0];\n              \
    \  operand.RemoveAt(0);\n            }\n            else if (operation == \"**\"\
    ) {\n                result = result ** operand[0];\n                operand.RemoveAt(0);\n\
    \            }\n        }\n        return result;", "        long result = 0;\n\
    \        string currentOperator = string.Empty;\n        long currentOperand =\
    \ 0;\n\n        if (op.Count > 1) {\n            int operandIndex = 0;\n     \
    \       while (operandIndex < operand.Count) {\n                string currentOperandString\
    \ = operand[operandIndex].ToString();\n                currentOperand = Convert.ToInt64(currentOperandString);\n\
    \                currentOperand = (long)MathNet.Numerics.LinearAlgebra.Vector.DenseVector.IndexOf(op,\
    \ currentOperator);\n                result = currentOperand + result;\n     \
    \           operandIndex++;\n            }\n        }\n        else if(op.Count\
    \ == 1 && operand.Count > 0)\n        {\n            string currentOperator =\
    \ op[0].ToString();\n            long currentOperand = Convert.ToInt64(operand[0].ToString());\n\
    \            result = currentOperand + result;\n        }\n        else\n    \
    \    {\n            Console.WriteLine(\"No valid operator or operand provided.\"\
    );\n        }\n        return result;", "        long result = 0;\n        switch\
    \ (op.Count) {\n            case 0: result = operand.First(); break;\n       \
    \     case 1: result = operand[0] + DoAlgebra(op.Take(1), operand.Skip(1))\n \
    \                        + (op[0] == \"+\" ? operand[0] : 0); break;\n       \
    \     case 2: result = operand[0] * DoAlgebra(op.Take(1), operand.Skip(1)) \n\
    \                         + (op[0] == \"+\" ? operand[0] : 0)\n              \
    \           + (op[1] == \"+\" ? operand[1] : 0); break;\n            case 3: result\
    \ = operand[0] * DoAlgebra(op.Take(1), operand.Skip(1)) \n                   \
    \      + (op[0] == \"+\" ? operand[0] : 0)\n                         + (op[1]\
    \ == \"+\" ? operand[1] : 0)\n                         + (op[2] == \"+\" ? operand[2]\
    \ : 0); break;\n            case 4: result = operand[0] * DoAlgebra(op.Take(1),\
    \ operand.Skip(1)) \n                         + (op[0] == \"+\" ? operand[0] :\
    \ 0)\n                         + (op[1] == \"+\" ? operand[1] : 0)\n         \
    \                + (op[2] == \"+\" ? operand[2] : 0)\n                       \
    \  + (op[3] == \"+\" ? operand[3] : 0); break;\n            case 5: result = operand[0]\
    \ * DoAlgebra(op.Take(1), operand.Skip(1)) \n                         + (op[0]\
    \ == \"+\" ? operand[0] : 0)\n                         + (op[1] == \"+\" ? operand[1]\
    \ : 0)\n                         + (op[2] == \"+\" ? operand[2] : 0)\n       \
    \                  + (op[3] == \"+\" ? operand[3] : 0)\n                     \
    \    + (op[4] == \"+\" ? operand[4] : 0); break;\n            default: throw new\
    \ InvalidOperationException(\"Invalid operators\");\n        }\n        return\
    \ result;", "        long result = 0;\n        foreach (var o in op) {\n     \
    \       var left = operand.First();\n            var right = operand.Skip(1).First();\n\
    \            switch (o) {\n                case \"+\":\n                    result\
    \ += left;\n                    break;\n                case \"-\":\n        \
    \            result -= left;\n                    break;\n                case\
    \ \"*\":\n                    result *= left;\n                    break;\n  \
    \              case \"/\":\n                    result /= left;\n            \
    \        break;\n                case \"//\":\n                    result %= left;\n\
    \                    break;\n                case \"**\":\n                  \
    \  result %= left;\n                    result *= right;\n                   \
    \ break;\n                default:\n                    throw new ArgumentOutOfRangeException(\"\
    Operator not supported\");\n            }\n        }\n        return result;",
  "        string operation = op[0];\n        long operand1 = operand[0];\n      \
    \  long operand2 = operand[1];\n        if (operation.Equals(\"+\")) {\n     \
    \       return operand1 + operand2;\n        }\n        else if (operation.Equals(\"\
    -\")) {\n            return operand1 - operand2;\n        }\n        else if (operation.Equals(\"\
    *\")) {\n            return operand1 * operand2;\n        }\n        else if (operation.Equals(\"\
    /\")) {\n            int num1 = (int)operand1;\n            int num2 = (int)operand2;\n\
    \            if (num2 == 0)\n                return num1;\n            else if\
    \ (num1 == 0)\n                return num2;\n            else\n              \
    \  return num1 / num2;\n        }\n        else if (operation.Equals(\"**\"))\
    \ {\n            int num1 = (int)operand1;\n            int num2 = (int)operand2;\n\
    \            if (num2 == 0)\n                return 1;\n            else if (num1\
    \ == 0)\n                return 0;\n            else\n                return Math.Pow(num1,\
    \ num2);\n        }\n        else\n            throw new ArgumentException(\"\
    Operator not recognized\");", "        long result = 0;\n        switch (op.Count)\
    \ {\n            case 2: //add\n                result = operand[0] + operand[1];\n\
    \                break;\n            case 3: //sub\n                result = operand[0]\
    \ - operand[1];\n                break;\n            case 4: //mul\n         \
    \       result = operand[0] * operand[1];\n                break;\n          \
    \  case 5: //floordiv\n                result = operand[0] / operand[1];\n   \
    \             break;\n            case 6: //exp\n                result = Math.Pow(operand[0],\
    \ operand[1]);\n                break;\n            default:\n               \
    \ throw new InvalidOperationException();\n        }\n        return result;",
  "        if (op.Count != operand.Count - 1)\n            throw new Exception(\"\
    Operator and operand list are of different lengths.\");\n\n        var exp = new\
    \ List<long>(op.Count);\n\n        foreach (var i in op)\n            if (i.Equals(\"\
    +\"))\n                exp.Add(operand[0] + operand[1]);\n            else if\
    \ (i.Equals(\"-\"))\n                exp.Add(operand[0] - operand[1]);\n     \
    \       else if (i.Equals(\"*\"))\n                exp.Add(operand[0] * operand[1]);\n\
    \            else if (i.Equals(\"//\"))\n                exp.Add(operand[0] /\
    \ operand[1]);\n            else if (i.Equals(\"**\"))\n                exp.Add(operand[0]\
    \ ** operand[1]);\n            else\n                throw new Exception(\"Invalid\
    \ operator: \" + i);\n\n        return exp[0];", "        var stack = new Stack<long>();\n\
    \n        foreach (var num in operand.Reverse()) {\n            stack.Push(DoOperation(num,\
    \ stack));\n        }\n\n        long result = stack.Pop();\n\n        while (op.Count\
    \ > 0) {\n            var op = op.Last();\n\n            switch (op) {\n     \
    \           case \"+\":\n                    result = stack.Pop() + result;\n\
    \                    break;\n                case \"-\":\n                   \
    \ result = stack.Pop() - result;\n                    break;\n               \
    \ case \"*\":\n                    result = stack.Pop() * result;\n          \
    \          break;\n                case \"//\":\n                    result =\
    \ stack.Pop() // result;\n                    break;\n                case \"\
    **\":\n                    result = stack.Pop() ** result;\n                 \
    \   break;\n                default:\n                    throw new InvalidOperationException(\"\
    Unknown operator: \" + op);\n            }\n\n            op.RemoveAt(op.Count\
    \ - 1);\n        }\n\n        return result;", "        // Evaluate the first\
    \ operand against each operation.\n        List<long> results = Enumerable.Range(1,\
    \ operand.Count - 1).Select(i => operand[i] - operand[i - 1]).ToList();\n    \
    \    // Do the operation against the remaining operands.\n        for (int i =\
    \ operand.Count - 2; i >= 0; i--) {\n            results[i] = operators[op.ElementAtOrDefault(i\
    \ - 1)](results[i], operand[i]);\n        }\n        return results[0];", "  \
    \      // Your code goes here\n        var result = operand[0];\n        for (int\
    \ i = 1; i < operand.Count; i++) {\n            var left = operand[i];\n     \
    \       var oper = op[i - 1];\n            long right = 0;\n            while\
    \ (true) {\n                if (oper == '*' || oper == '/') {\n              \
    \      right = left * right;\n                    left = left % right;\n     \
    \           } else if (oper == '+' || oper == '-') {\n                    right\
    \ = left + right;\n                    left = -left;\n                } else if\
    \ (oper == '**') {\n                    right = left * right;\n              \
    \      left = left % right;\n                } else {\n                    break;\n\
    \                }\n            }\n            result += right;\n        }\n \
    \       return result;", "        Dictionary<string, long> dictOperator = new\
    \ Dictionary<string, long>() {\n            { \"+\", 0 },\n            { \"-\"\
    , 0 },\n            { \"*\", 0 },\n            { \"//\", 0 },\n            { \"\
    **\", 0 }\n        };\n        Dictionary<long, long> dictOperand = new Dictionary<long,\
    \ long>() {\n            { 0, 0 },\n            { 1, 0 },\n            { 2, 0\
    \ },\n            { 3, 0 },\n            { 4, 0 },\n            { 5, 0 },\n  \
    \          { 6, 0 },\n            { 7, 0 },\n            { 8, 0 },\n         \
    \   { 9, 0 },\n            { 10, 0 },\n            { 11, 0 },\n            { 12,\
    \ 0 },\n            { 13, 0 },\n            { 14, 0 },\n            { 15, 0 },\n\
    \            { 16, 0 },\n            { 17, 0 },\n            { 18, 0 },\n    \
    \        { 19, 0 },\n            { 20, 0 },\n            { 21, 0 },\n        \
    \    { 22, 0 },\n            { 23, 0 },\n            { 24, 0 },\n            {\
    \ 25, 0 },\n            { 26, 0 },\n            { 27, 0 },\n            { 28,\
    \ 0 },\n            { 29, 0 },\n            { 30, 0 },\n            { 31, 0 },\n\
    \            { 32, 0 },\n            { 33, 0 },\n            { 34, 0 },\n    \
    \        { 35, 0 },\n            { 36, 0 },\n            { 37, 0 },\n        \
    \    { 38, 0 },\n            { 39, 0 },\n            { 40, 0 },\n            {\
    \ 41, 0 },\n            { 42, 0 },\n            { 43, 0 },\n            { 44,\
    \ 0 },\n            { 45, 0 },\n            { 46, 0 },\n            { 47, 0 },\n\
    \            { 48, 0 },\n            { 49, 0 },\n            { 50, 0 },\n    \
    \        { 51, 0 },\n            { 52, 0 },\n            { 53, 0 },\n        \
    \    { 54, 0 },\n            { 55, 0 },\n            { 56, 0 },\n            {\
    \ 57, 0 },\n            { 58, 0 },\n            { 59, 0 },\n            { 60,\
    \ 0 },\n            { 61, 0 },\n            { 62, 0 },\n            { 63, 0 },\n\
    \            { 64, 0 },\n            { 65, 0 },\n            { 66, 0 },\n    \
    \        { 67, 0 },\n            { 68, 0 },\n            { 69, 0 },\n        \
    \    { 70, 0 },\n            { 71, 0 },"]
stop_tokens:
- "\n    }\n"
