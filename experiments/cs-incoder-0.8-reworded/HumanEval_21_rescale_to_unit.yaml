name: HumanEval_21_rescale_to_unit
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given list of numbers (of at least two elements), apply a linear\
  \ transform to that list,\n    // such that the smallest number will become 0 and\
  \ the largest will become 1\n    // >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f,\
  \ (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n    // (new List<float>(new\
  \ float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\n\
  \    public static List<float> RescaleToUnit(List<float> numbers) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(RescaleToUnit((new\
  \ List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new\
  \ float[]{(float)0.0f, (float)1.0f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new\
  \ float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f,\
  \ (float)0.0f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f,\
  \ (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new\
  \ float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));\n\
  \    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f,\
  \ (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f,\
  \ (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));\n    Debug.Assert(RescaleToUnit((new\
  \ List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f,\
  \ (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f,\
  \ (float)1.0f, (float)0.5f, (float)0.75f}))));\n    }\n\n}\n"
completions: ["        float sum = 0f;\n        if (numbers.Count < 2) {\n       \
    \     return numbers;\n        }\n        float largest = numbers[0];\n      \
    \  float smallest = numbers[0];\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            sum += numbers[i];\n            if (numbers[i] > largest) {\n\
    \                largest = numbers[i];\n            } else if (numbers[i] < smallest)\
    \ {\n                smallest = numbers[i];\n            }\n        }\n      \
    \  float factor = largest / sum;\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            numbers[i] *= factor;\n        }\n        return numbers;", " \
    \       long max = numbers.Max();\n        long min = numbers.Min();\n       \
    \ if (max > min)\n            throw new Exception(\"Cannot scale/rescale list\
    \ of numbers that contains both positive and negative values\");\n        float\
    \ scale = (max - min) / numbers.Count;\n        numbers.ForEach((f) => {\n   \
    \         float value = (float)(f - min) * scale;\n            if (value != f)\n\
    \                throw new Exception(\"Cannot scale/rescale list of numbers that\
    \ contains both positive and negative values\");\n        });\n        List<float>\
    \ result = new List<float>(numbers);\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            result.RemoveAt(numbers.Count - i - 1);\n        result.ForEach((f)\
    \ => {\n            if (f < min)\n                result.Insert(0, (f - min) /\
    \ scale);\n            else if (f > max)\n                result.Add(1 - (f -\
    \ max) / scale);\n            else\n                result.Add(f);\n        });\n\
    \        return result;", "        if (numbers.Count < 2) return numbers;\n\n\
    \        float smallest = numbers[0];\n        float largest = numbers[0];\n \
    \       for (int i = 0; i < numbers.Count; i++) {\n            float n = numbers[i];\n\
    \            smallest = Mathf.Min(smallest, n);\n            largest = Mathf.Max(largest,\
    \ n);\n        }\n\n        if (smallest == 0.0f || largest == 0.0f) return numbers;\n\
    \n        float scale = 1.0f / (largest - smallest);\n        List<float> result\
    \ = new List<float>(numbers.Count);\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            float n = numbers[i];\n            result[i] = n*scale;\n\
    \        }\n\n        return result;", "        if (numbers.Count <= 1) return\
    \ numbers;\n        float unit = (float)Math.Sqrt((double)numbers.Count);\n  \
    \      if (unit == 0) { return numbers; }\n        numbers.Sort();\n        int\
    \ first = 0;\n        float last = (float)Math.Ceiling((double)numbers.Last());\n\
    \        float current = (float)Math.Ceiling((double)numbers.First());\n     \
    \   while (current < 1.0f) {\n            current = (float)Math.Ceiling((double)current\
    \ * unit);\n            numbers.Insert(0, current);\n            first += 1;\n\
    \        }\n        while (current > 0.0f) {\n            current = (float)Math.Ceiling((double)current\
    \ / unit);\n            numbers.Add(current);\n            last = current;\n \
    \       }\n        numbers.RemoveAt(numbers.Count - 1);\n        return numbers;",
  "        float scale = 1.0f;\n        // Find the smallest number in the list.\n\
    \        // If no numbers exist in the list, return 0.\n        // Otherwise,\
    \ find the largest number in the list.\n        float smallest = numbers.Min();\n\
    \        float largest = numbers.Max();\n\n        // Normalize all numbers in\
    \ list to range 0..1\n        foreach (float number in numbers) {\n          \
    \  number = (number - smallest) / (largest - smallest);\n            scale *=\
    \ 1.0f;\n        }\n        return numbers.Select(x => (x * scale)).ToList();",
  "        double min = numbers.Min();\n        double max = numbers.Max();\n\n  \
    \      if (min == max) {\n            throw new ArgumentOutOfRangeException(\"\
    The min must be less than the max \");\n        }\n\n        if (min != 0.0f)\
    \ {\n            numbers = numbers.Select(n => (n - min) / max).ToList();\n  \
    \      }\n\n        return numbers;", "        if (numbers.Count == 0) {\n   \
    \         return new List<float>();\n        }\n\n        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n\n        if (min == max) {\n            return\
    \ new List<float>();\n        }\n\n        var min = Math.Abs(min);\n        var\
    \ max = Math.Abs(max);\n\n        // If min and max are very close to each other,\
    \ we don't need to apply any transform\n        if (min < 0.001 && max < 0.001)\
    \ {\n            return new List<float>(numbers);\n        }\n\n        // If\
    \ max is very close to 0, we might want to return numbers to their original scale\n\
    \        if (max == 0.0f) {\n            return new List<float>(numbers);\n  \
    \      }\n\n        var range = max - min;\n        if (range == 0.0f) {\n   \
    \         return new List<float>(numbers);\n        }\n\n        float scale =\
    \ 1.0f / (float)range;\n\n        numbers.ForEach(n => n *= scale);\n        return\
    \ numbers;", "        if (numbers.Count < 2) {\n            return numbers;\n\
    \        }\n        // first find the smallest and largest numbers, we'll use\
    \ that to scale everything\n        var smallest = numbers.Min();\n        var\
    \ largest = numbers.Max();\n        var scaling = (largest - smallest) / (float)numbers.Count;\n\
    \n        // Now we'll go through the list and scale each item as we go along\n\
    \        var result = new List<float>();\n        foreach (var number in numbers)\
    \ {\n            // Since we're scaling by a fraction of the smallest number,\
    \ we'll only scale\n            // by that fraction of the smallest number\n \
    \           result.Add(number * scaling);\n        }\n        return result;",
  "        if (numbers.Count < 2) {\n            return numbers.ToList();\n      \
    \  }\n        Debug.Assert(numbers.Count > 1);\n        // Find the maximum value\n\
    \        float max = numbers.Max();\n        Debug.Assert(max > 0.0f);\n     \
    \   // Find the maximum deviation from the mean\n        float max = numbers.Select(n\
    \ => Math.Abs(n - max)).Max();\n        Debug.Assert(max > 0.0f);\n        //\
    \ Calculate the scale\n        float scale = 1.0f / (1.0f / max);\n        Debug.Assert(scale\
    \ > 0.0f);\n        // Apply scale (of 1.0) to all elements\n        foreach (float\
    \ number in numbers) {\n            number *= scale;\n        }\n        // Apply\
    \ the linear transform\n        List<float> transformedNumbers = new List<float>();\n\
    \        float sum = 0;\n        foreach (float number in numbers) {\n       \
    \     transformedNumbers.Add(sum + number);\n            sum += number;\n    \
    \    }\n        return transformedNumbers;", "        if (numbers.Count < 2)\n\
    \            return numbers;\n        // Take the minimum number as zero\n   \
    \     float min = numbers.Min();\n        // Take the maximum number as one\n\
    \        float max = numbers.Max();\n        // Calculate the scaling factor\n\
    \        float scale = max - min;\n        // Convert the numbers to unit scale\
    \ (0 to 1)\n        for (int i = 0; i < numbers.Count; i++)\n            numbers[i]\
    \ = (numbers[i] - min) / scale;\n        return numbers;", "        Debug.Assert(numbers\
    \ != null && numbers.Count >= 2, \"List of numbers must be of atleast two elements\"\
    );\n\n        // First apply the linear transformation\n        double[] transformed\
    \ = new double[numbers.Count];\n        double smallest = numbers.Min();\n   \
    \     double largest = numbers.Max();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            transformed[i] = ((numbers[i] - smallest) / (largest - smallest))\
    \ * 1.0f;\n        }\n\n        // Second map the transformed numbers to unit\
    \ interval\n        double[] transformedToUnit = new double[transformed.Length];\n\
    \        for (int i = 0; i < transformed.Length; i++) {\n            if (transformed[i]\
    \ >= 0 && transformed[i] <= 1) {\n                transformedToUnit[i] = transformed[i];\n\
    \            } else {\n                transformedToUnit[i] = 1.0f - transformed[i];\n\
    \            }\n        }\n\n        // Third return the list containing the result\n\
    \        return TransformToUnit(transformedToUnit);", "        double max = numbers.Min();\n\
    \        double min = numbers.Max();\n        double range = (max - min);\n\n\
    \        if (range == 0) {\n            return numbers;\n        }\n\n       \
    \ int newMin;\n        if (min == 0) {\n            // No point in going under\
    \ zero here\n            newMin = 0;\n        } else {\n            newMin = (int)((double)min\
    \ / range);\n        }\n\n        int newMax;\n        if (max == 1.0f) {\n  \
    \          // No point in going over one here\n            newMax = 1;\n     \
    \   } else {\n            newMax = (int)((double)max / range);\n        }\n\n\
    \        List<float> newNumbers = new List<float>(numbers);\n        for (int\
    \ i = numbers.Count - 1; i >= 0; i--) {\n            newNumbers.Add(numbers[i]\
    \ * (newMax - newMin) / range + newMin);\n        }\n\n        return newNumbers;",
  "        float largest = numbers.Min();\n        float smallest = numbers.Max();\n\
    \        float mid = numbers.Average();\n        float scale = (largest - smallest)\
    \ / (largest - mid);\n        List<float> result = new List<float>();\n      \
    \  for (int i = 0; i < numbers.Count; i++) {\n            result.Add(numbers[i]\
    \ * scale);\n        }\n        return result;", "        if (numbers == null\
    \ || numbers.Count == 0)\n            return null;\n        var scale = 1.0f /\
    \ numbers.Min();\n        Debug.Assert(numbers.Any(number => number > 0.0f));\n\
    \        Debug.Assert(numbers.All(number => number < 1.0f));\n        return numbers.Select(number\
    \ => number * scale).ToList();", "        float min = (float) Math.Min(numbers.Min(),\
    \ numbers.Max());\n        float max = (float) Math.Max(numbers.Min(), numbers.Max());\n\
    \        float range = max - min;\n        float scale = 1.0f / range;\n     \
    \   return numbers.Select(number => number * scale).ToList();", "        var length\
    \ = numbers.Count;\n        if (length <= 1) {\n            return numbers;\n\
    \        }\n        if (numbers.First() > numbers.Last()) {\n            throw\
    \ new ArgumentException(\"The first value must be less than the last.\");\n  \
    \      }\n\n        var range = numbers.GetRange(1, length - 1);\n        var\
    \ range = numbers.Select(n => n * range[0] + range[1]) / range[2];\n\n       \
    \ return new List<float>(range);", "        if (numbers.Count < 2)\n         \
    \   return numbers;\n\n        double smallest = numbers.Min();\n        double\
    \ largest = numbers.Max();\n\n        // TODO: Write the code here", "       \
    \ // The maximum possible number in a list is 1/2 the maximum possible number\
    \ (minus 1.0).\n        double largest = Math.Max(numbers.Min(), numbers.Last());\n\
    \        double smallest = numbers.Min();\n        // Normalize the numbers so\
    \ that their maximum is 1.0\n        List<float> normalized = new List<float>(numbers.Count);\n\
    \        for (int i = 0; i < numbers.Count; i++)\n        {\n            normalized.Add((numbers[i]\
    \ - smallest) / (largest - smallest));\n        }\n        // Make sure the largest\
    \ number is 1, and the smallest is 0.\n        normalized.Add(1.0);\n        normalized.Reverse();\n\
    \        return normalized;", "        int size = numbers.Count;\n        if (size\
    \ == 0)\n            return new List<float>();\n        if (size == 1)\n     \
    \       return numbers;\n\n        // If first and last elements are 0, then do\
    \ nothing\n        if (numbers.FirstOrDefault() == 0)\n            return RescaleToUnit(numbers.Skip(1).ToList());\n\
    \        if (numbers.LastOrDefault() == 0)\n            return RescaleToUnit(numbers.Take(numbers.Count\
    \ - 1).ToList());\n\n        // If only 1 element left, then just return the list\n\
    \        if (numbers.FirstOrDefault() == numbers[0])\n            return numbers;\n\
    \n        // Calculate average\n        float average = numbers.Average();\n \
    \       // Calculate scale factor to fit into [0, 1]\n        float scale = average\
    \ / numbers.LastOrDefault();\n        // Create new list of scaled numbers\n \
    \       List<float> result = new List<float>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            float val = numbers[i] * scale;\n            result.Add(val);\n\
    \        }\n\n        return result;", "        if (numbers.Count == 0) {\n  \
    \          return new List<float>(new float[0]);\n        }\n        float smallest\
    \ = numbers[0];\n        float largest = numbers[0];\n        int count = 0;\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ < smallest) {\n                smallest = numbers[i];\n            }\n     \
    \       if (numbers[i] > largest) {\n                largest = numbers[i];\n \
    \           }\n            count++;\n        }\n        if (count == 0) {\n  \
    \          return new List<float>(new float[0]);\n        }\n        double scale\
    \ = Convert.ToDouble(largest) / Convert.ToDouble(smallest);\n        List<float>\
    \ rescaledNumbers = new List<float>(new float[numbers.Count]);\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            rescaledNumbers[i] = numbers[i]\
    \ * scale;\n        }\n        return rescaledNumbers;", "        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n\n        // The min number is the smallest\
    \ number\n        // The max number is the largest number\n        // The range\
    \ is (max - min) / 2\n        // So the range is (max - min) / (max - min)\n \
    \       // Or (max - min) / (max - min)^2\n        var scale = (max - min) / (max\
    \ - min);\n        var scaled = new List<float>();\n\n        foreach (var number\
    \ in numbers) {\n            scaled.Add((number - min) * scale);\n        }\n\
    \        return scaled;", "        if (numbers.Count <= 1) return numbers;\n \
    \       var max = numbers.Max();\n        var min = numbers.Min();\n        if\
    \ (max == min) return numbers;\n        float factor = (float)(max - min) / numbers.Count;\n\
    \        return numbers.Select(num => (num - min) * factor + min).ToList();",
  "        float[] ranges = numbers.Select(x => x - numbers.Min()).ToArray();\n  \
    \      float sum = (float)0;\n        float min = (float)numbers.Min();\n    \
    \    float max = (float)numbers.Max();\n\n        if (numbers.Count == 0) {\n\
    \            return new List<float>();\n        }\n\n        // Find the sum of\
    \ the numbers minus all numbers in the list\n        foreach (float num in numbers)\
    \ {\n            sum += num;\n        }\n\n        // Divide the sum by all numbers\
    \ in the list\n        foreach (float num in numbers) {\n            sum += num;\n\
    \        }\n\n        // Find the minimum\n        foreach (float num in numbers)\
    \ {\n            if (num < min) {\n                min = num;\n            }\n\
    \        }\n\n        // Find the maximum\n        foreach (float num in numbers)\
    \ {\n            if (num > max) {\n                max = num;\n            }\n\
    \        }\n\n        // Normalize all the numbers\n        foreach (float num\
    \ in numbers) {\n            ranges[num] = (num - min) / (max - min);\n      \
    \  }\n\n        // Return the recalculated list\n        return numbers.Select(x\
    \ => x + ranges[x]).ToList();", "        float minValue = numbers.Min();\n   \
    \     float maxValue = numbers.Max();\n        if (maxValue < minValue) {\n  \
    \          Debug.WriteLine(\"Warning: maxValue < minValue, scaling down\");\n\
    \            numbers.Sort();\n            minValue = numbers.First();\n      \
    \      maxValue = numbers.Last();\n        }\n\n        float diffBetweenMinAndMax\
    \ = (maxValue - minValue) / 2.0f;\n        float scaledDownToZero = minValue -\
    \ diffBetweenMinAndMax;\n\n        if (scaledDownToZero >= minValue)\n       \
    \     numbers[0] = scaledDownToZero;\n        else\n            numbers[0] = minValue;\n\
    \n        var scaledDownToOne = minValue + diffBetweenMinAndMax;\n\n        if\
    \ (scaledDownToOne <= maxValue)\n            numbers[numbers.Count - 1] = scaledDownToOne;\n\
    \        else\n            numbers[numbers.Count - 1] = maxValue;\n\n        return\
    \ numbers;", "        var maxValue = numbers.Max();\n        var minValue = numbers.Min();\n\
    \        if (maxValue == minValue) {\n            // if numbers are already scaled\
    \ between 0 and 1, just return them\n            return numbers;\n        }\n\n\
    \        // normalize between 0 and 1 (max to 1)\n        var normalizedNumbers\
    \ = numbers.Select(x => (x - minValue) / (maxValue - minValue)).ToList();\n\n\
    \        // now scale everything between 0 and 1, using normalized numbers\n \
    \       // return new List<float>(new float[]{\n        //     (float)Math.Round(normalizedNumbers.Min()),\n\
    \        //     (float)Math.Round(normalizedNumbers.Min()),\n        //     (float)Math.Round(normalizedNumbers.Min()),\n\
    \        //     (float)Math.Round(normalizedNumbers.Min()),\n        //     (float)Math.Round(normalizedNumbers.Max())\n\
    \        // });\n\n        // alternative way, rounding up\n        // return\
    \ new List<float>(new float[]{\n        //     (float)Math.Round(normalizedNumbers.Min(),\
    \ MidpointRounding.AwayFromZero),\n        //     (float)Math.Round(normalizedNumbers.Min(),\
    \ MidpointRounding.AwayFromZero),\n        //     (float)Math.Round(normalizedNumbers.Min(),\
    \ MidpointRounding.AwayFromZero),\n        //     (float)Math.Round(normalizedNumbers.Min(),\
    \ MidpointRounding.AwayFromZero),\n        //     (float)Math.Round(normalizedNumbers.Max(),\
    \ MidpointRounding.AwayFromZero)\n        // });\n        throw new NotImplementedException();",
  "        if (numbers.Count < 2) {\n            throw new ArgumentException();\n\
    \        }\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        numbers.ForEach(n => {\n            if (n == 0.0f) {\n              \
    \  n = 0.0f;\n            } else if (n == max) {\n                n = 1.0f;\n\
    \            } else if (n == min) {\n                n = 0.0f;\n            }\n\
    \        });\n        return numbers;", "        var largest = numbers.Max();\n\
    \        var smallest = numbers.Min();\n        if (largest == smallest)\n   \
    \         return numbers;\n        var delta = (largest - smallest);\n       \
    \ var scale = (float)delta / (float)numbers.Count;\n        var result = new List<float>();\n\
    \        numbers.ForEach(x => result.Add(x * scale));\n        return result;",
  "        double max = numbers.Max();\n        double min = numbers.Min();\n    \
    \    double maxValue = max - min;\n\n        if (maxValue == 0.0f) {\n       \
    \     return numbers;\n        }\n\n        double increment = (maxValue - 1.0f)\
    \ / (numbers.Count - 1);\n        double rescaledNumbers = new List<float>();\n\
    \n        foreach (double number in numbers) {\n            rescaledNumbers.Add((float)(number\
    \ - min) * increment);\n        }\n\n        return rescaledNumbers;", "     \
    \   if (numbers.Count < 2) return numbers;\n        if (numbers.Count == 2) {\n\
    \            numbers[0] = numbers[0] / numbers[1];\n            return numbers;\n\
    \        }\n\n        float minValue = numbers[0];\n        float maxValue = numbers[0];\n\
    \        numbers.ForEach(num => {\n            if (num > maxValue) {\n       \
    \         maxValue = num;\n            }\n            if (num < minValue) {\n\
    \                minValue = num;\n            }\n        });\n\n        float\
    \ scale = (maxValue - minValue) / 2.0f;\n        float minValueNew = minValue\
    \ - scale;\n        float maxValueNew = maxValue + scale;\n\n        var newNumbers\
    \ = new List<float>();\n        numbers.ForEach(num => {\n            newNumbers.Add(num);\n\
    \        });\n        newNumbers.ForEach(num => {\n            num /= scale;\n\
    \        });\n\n        newNumbers.Add(minValueNew);\n        newNumbers.Add(maxValueNew);\n\
    \n        return newNumbers;", "        Debug.Assert(numbers.Count >= 2, \"Input\
    \ list must have at least two elements\");\n        Debug.Assert(numbers.Any(n\
    \ => n > 0 && n < 1), \"Elements of list must be between 0 and 1\");\n       \
    \ // find smallest and largest number\n        float smallest = numbers.Min();\n\
    \        float largest = numbers.Max();\n        // scale all numbers to between\
    \ 0.0 and 1.0\n        float factor = largest / Math.Abs(smallest - largest);\n\
    \        return numbers.Select(n => (n - smallest) * factor).ToList();", "   \
    \     // Calculate min/max of the supplied numbers\n        float max = numbers.Max();\n\
    \        float min = numbers.Min();\n\n        // Normalize all numbers to [0,\
    \ 1]\n        var normalizedNumbers = numbers.Select(n => (n - min) / (max - min)).ToList();\n\
    \n        // Apply a linear transformation to get all numbers from [0, 1]\n  \
    \      return normalizedNumbers.Select(n => (1.0f / (max - min)) * n).ToList();",
  "        Debug.Assert(numbers.Count > 0);\n        if (numbers.Count == 1) {\n \
    \           return numbers;\n        }\n        if (numbers.Count == 2) {\n  \
    \          numbers[0] = numbers[0] / numbers[1];\n            return numbers;\n\
    \        }\n        float largestValue = numbers[0];\n        float smallestValue\
    \ = numbers[0];\n        float newMin = numbers[0];\n        float newMax = numbers[0];\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            float currentValue\
    \ = numbers[i];\n            if (currentValue > largestValue) {\n            \
    \    largestValue = currentValue;\n            }\n            if (currentValue\
    \ < smallestValue) {\n                smallestValue = currentValue;\n        \
    \    }\n        }\n        // We need to scale everything by the largest and smallest\
    \ values\n        // The new min will now be the smallest of the largest, the\
    \ new max will be the largest\n        // of the smallest and the old min and\
    \ max will stay the same\n        newMax = largestValue;\n        newMin = smallestValue;\n\
    \        float scale = newMax - newMin;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            numbers[i] = ((numbers[i] - newMin) * scale) + newMin;\n\
    \        }\n        return numbers;", "        // Write your code here\n     \
    \   if (numbers.Count == 0) throw new ArgumentException(\"List cannot be empty\"\
    , \"numbers\");\n        float min = numbers.Min();\n        float max = numbers.Max();\n\
    \        var newNumbers = new List<float>();\n        var factor = 1.0 / (max\
    \ - min);\n        for (int i = 0; i < numbers.Count; i++) {\n            newNumbers.Add(numbers[i]\
    \ * factor);\n        }\n        return newNumbers;", "        if (numbers.Count\
    \ < 2)\n            return numbers;\n        List<float> scaled = new List<float>();\n\
    \        int min = numbers.Min();\n        int max = numbers.Max();\n        float\
    \ range = (max - min) / (float)numbers.Count;\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            scaled.Add((float)((numbers[i] - min) / range));\n       \
    \ return scaled;", "        Debug.Assert(numbers.Count >= 2, \"Expected list with\
    \ at least two elements.\");\n        float min = numbers.Min();\n        float\
    \ max = numbers.Max();\n        float range = (max - min) / (float)numbers.Count;\n\
    \        List<float> results = new List<float>();\n        for (int i = 0; i <\
    \ numbers.Count; i++)\n            results.Add(numbers[i] * range + min);\n  \
    \      return results;", "        if (numbers.Count == 0) {\n            return\
    \ numbers;\n        }\n        if (numbers.Count < 2) {\n            return numbers;\n\
    \        }\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        var min = Math.Abs(min);\n        var max = Math.Abs(max);\n        var\
    \ scale = (float)(max - min) / (float)numbers.Count;\n        var result = new\
    \ List<float>(numbers);\n        for (var i = 0; i < numbers.Count; i++) {\n \
    \           result[i] = (float)(numbers[i] * scale) + min;\n        }\n      \
    \  return result;", "        if (numbers.Count < 2) {\n            return null;\n\
    \        }\n\n        List<float> result = new List<float>(numbers.Count - 1);\n\
    \        float minValue = numbers.Min();\n        float maxValue = numbers.Max();\n\
    \n        int minIndex = 0;\n        int maxIndex = numbers.Count - 1;\n\n   \
    \     while (minIndex < maxIndex) {\n            float delta = minIndex < maxIndex\
    \ ? numbers[minIndex + 1] - minValue : maxValue - numbers[maxIndex];\n       \
    \     if (delta == 0) {\n                minIndex++;\n                maxIndex--;\n\
    \            } else {\n                float fraction = (maxValue - minValue)\
    \ / delta;\n                float oldValue = numbers[minIndex];\n            \
    \    numbers[minIndex] = minValue + fraction * (numbers[maxIndex] - numbers[minIndex]);\n\
    \                numbers[maxIndex] = oldValue - fraction * (numbers[maxIndex]\
    \ - numbers[minIndex]);\n            }\n\n            for (int i = minIndex +\
    \ 1; i <= maxIndex; i++) {\n                float temp = numbers[i];\n       \
    \         numbers[i] = numbers[i + 1];\n                numbers[i + 1] = temp;\n\
    \            }\n        }\n\n        float delta = minIndex < maxIndex ? numbers[minIndex\
    \ + 1] - minValue : maxValue - numbers[maxIndex];\n        if (delta != 0) {\n\
    \            float fraction = (maxValue - minValue) / delta;\n            for\
    \ (int i = maxIndex; i >= minIndex; i--) {\n                float temp = numbers[i];\n\
    \                numbers[i] = numbers[i + 1];\n                numbers[i + 1]\
    \ = temp;\n            }\n\n            for (int i = minIndex; i >= 0; i--) {\n\
    \                numbers[i + 1] = numbers[i] + fraction * (numbers[i + 1] - numbers[i]);\n\
    \            }\n        }\n\n        for (int i = minIndex; i < maxIndex; i++)\
    \ {\n            float temp = numbers[i];\n            numbers[i] = numbers[i\
    \ + 1];\n            numbers[i + 1] = temp;\n        }\n\n        result = numbers.ToArray();\n\
    \        return result;", "        if (numbers.Count == 0) {\n            throw\
    \ new ArgumentException($\"{numbers.Count} is not a positive integer\");\n   \
    \     }\n\n        float smallest = numbers.Min();\n        float largest = numbers.Max();\n\
    \n        float scaleFactor = (largest - smallest) / (float)numbers.Count;\n \
    \       return numbers.Select(x => x / scaleFactor).ToList();", "        if (numbers\
    \ == null)\n            return null;\n\n        if (numbers.Count < 2)\n     \
    \       return numbers;\n\n        float maxValue = numbers.Max();\n        float\
    \ minValue = numbers.Min();\n\n        if (maxValue == minValue)\n           \
    \ return numbers;\n\n        float delta = (maxValue - minValue) / (numbers.Count\
    \ - 1);\n\n        return numbers.Select(x => (x - minValue) / delta).ToList();",
  "        if (numbers.Count < 2)\n            return numbers;\n        var min =\
    \ numbers.Min();\n        var max = numbers.Max();\n        if (min == max)\n\
    \            return numbers;\n        var range = max - min;\n        var factor\
    \ = 1.0f / range;\n        var transformed = new List<float>();\n        for (var\
    \ i = 0; i < numbers.Count; i++) {\n            var value = numbers[i];\n    \
    \        transformed.Add(value * factor);\n        }\n        return transformed;",
  "        Debug.Assert(numbers.Count > 1);\n        Debug.Assert(numbers.All(n =>\
    \ n >= 0));\n        Debug.Assert(numbers.All(n => n <= 1));\n        numbers.Sort();\n\
    \        float scale = numbers.Min() / numbers.Max();\n        var result = new\
    \ List<float>(numbers);\n        for (var i = 0; i < numbers.Count; i++)\n   \
    \         result[i] *= scale;\n        return result;", "        numbers.Sort();\n\
    \        var xMax = numbers.Last();\n        var yMin = numbers.First();\n\n \
    \       // Compute scaling factors\n        var xScale = (xMax - yMin).Value /\
    \ (float)(numbers.Count - 1);\n        var yScale = (yMax - yMin).Value / (float)(numbers.Count\
    \ - 1);\n        // Compute actual linear transform\n        var xs = numbers.Select((x,index)\
    \ => x * xScale + yMin.Value);\n        return xs.ToList();", "        float[]\
    \ arr = numbers.ToArray();\n        double min = Math.Abs(arr[0]);\n        double\
    \ max = Math.Abs(arr[0]);\n        for (int i = 1; i < arr.Length; i++) {\n  \
    \          min = Math.Min(min, Math.Abs(arr[i]));\n            max = Math.Max(max,\
    \ Math.Abs(arr[i]));\n        }\n\n        double delta = (max - min);\n     \
    \   double range = (1.0f / delta);\n        double newMin = 0.0f;\n        double\
    \ newMax = 1.0f;\n\n        foreach (float f in arr) {\n            newMin +=\
    \ range;\n            newMax -= range;\n\n            double d = newMin - min;\n\
    \            double newVal = (f - min) / d;\n\n            newVal *= (max - newMin);\n\
    \            newVal += newMin;\n            arr = newVal.ToArray();\n        }\n\
    \n        return arr.ToList();", "        // Create a list to hold the results\n\
    \        var results = new List<float>();\n\n        // Find the two extremes\
    \ and then scale by subtracting the min from the max\n        var max = (float)\
    \ numbers.Max();\n        var min = (float) numbers.Min();\n\n        // If max\
    \ is 0, the minimum will be too small\n        if (max == 0)\n        {\n    \
    \        results = (List<float>) numbers.ToList().Select(x => (float)(x - min)).ToList();\n\
    \            return results;\n        }\n\n        // If min is 0, the maximum\
    \ will be too large\n        if (min == 0)\n        {\n            results = (List<float>)\
    \ numbers.ToList().Select(x => (float)(max - x)).ToList();\n            return\
    \ results;\n        }\n\n        // Find the ratio between min and max\n     \
    \   var ratio = (float) max / (float) min;\n\n        // Scale the numbers using\
    \ the ratio\n        foreach (var number in numbers)\n        {\n            results.Add(number\
    \ * (ratio - 1));\n        }\n\n        return results;", "        Debug.Assert(numbers.Count\
    \ > 0);\n        var unitNumber = numbers.Min();\n        var numbersToCopy =\
    \ new List<float>(numbers);\n        numbersToCopy.Remove(unitNumber);\n     \
    \   var totalSum = numbersToCopy.Sum();\n        var scaleFactor = totalSum /\
    \ numbers.Count;\n        foreach (var number in numbersToCopy) {\n          \
    \  number *= scaleFactor;\n        }\n        return numbersToCopy;", "      \
    \  if (numbers.Count == 0) return new List<float>();\n        if (numbers.Count\
    \ == 1) return numbers;\n        // find the smallest and largest\n        var\
    \ smallest = numbers.Min();\n        var largest = numbers.Max();\n        //\
    \ rescale values\n        foreach (var number in numbers) {\n            number\
    \ -= smallest;\n            number /= largest;\n        }\n        // normalize\
    \ smallest to zero\n        var newSmallest = (float)0.0f;\n        foreach (var\
    \ number in numbers) {\n            number += newSmallest;\n        }\n      \
    \  // normalize largest to one\n        var newLargest = (float)1.0f;\n      \
    \  foreach (var number in numbers) {\n            number -= newLargest;\n    \
    \    }\n        return new List<float>(numbers);", "        if (numbers.Count\
    \ < 2) {\n            throw new ArgumentException(\"At least two numbers required\"\
    );\n        }\n        float[] unit = new float[numbers.Count];\n        float\
    \ min = numbers.Min();\n        float max = numbers.Max();\n        double range\
    \ = Math.Max(max - min, 0);\n        int inc = 1;\n        if (range > 0) {\n\
    \            inc = Convert.ToInt32(Math.Floor(Math.Log(range) / Math.Log(2)) +\
    \ 1);\n        }\n        for (int i = 0; i < unit.Length; i++) {\n          \
    \  float delta = (numbers[i] - min) / range;\n            unit[i] = delta * inc;\n\
    \        }\n        return new List<float>(unit);", "        List<float> normalizedUnit\
    \ = new List<float>();\n        float min = numbers.Min();\n        float max\
    \ = numbers.Max();\n        float range = max - min;\n\n        float scale =\
    \ (float)Math.Pow(2, -24);\n        float offset = min * scale;\n        float\
    \ scaleFactor = range / (float)Math.Pow(scale, 24);\n\n        for (float number\
    \ : numbers) {\n            normalizedUnit.Add(number * scaleFactor);\n      \
    \  }\n\n        return normalizedUnit;", "        // If the smallest number is\
    \ 0, then set the smallest number to 1 and vice versa\n        float smallest\
    \ = numbers.Min();\n        if (smallest == 0.0f) {\n            numbers.Add(1.0f);\n\
    \            numbers.RemoveAt(0);\n        } else {\n            numbers.Add(0.0f);\n\
    \            numbers.RemoveAt(numbers.Count - 1);\n        }\n        float largest\
    \ = numbers.Max();\n        if (largest == 0.0f) {\n            numbers.Add(0.0f);\n\
    \            numbers.RemoveAt(0);\n        } else {\n            numbers.Add(1.0f);\n\
    \            numbers.RemoveAt(numbers.Count - 1);\n        }\n\n        // Now\
    \ that smallest and largest are 0 and 1, compute new scaling factor for each number\n\
    \        float scalingFactor = largest - smallest;\n        for (int i = 0; i\
    \ < numbers.Count; i++) {\n            numbers[i] = (numbers[i] - smallest) /\
    \ scalingFactor;\n        }\n\n        return numbers;", "        if (numbers.Count\
    \ < 2)\n            throw new ArgumentException(\"List must have at least two\
    \ elements\");\n        float min = numbers.Min();\n        float max = numbers.Max();\n\
    \        float rescale = (max - min) / 2.0;\n        List<float> results = new\
    \ List<float>(numbers.Count);\n        for (int i = 0; i < numbers.Count; i++)\n\
    \            results.Add(numbers[i] * rescale);\n        return results.ToList();",
  "        Debug.Assert(numbers.Count >= 2);\n        double min = numbers.Min();\n\
    \        double max = numbers.Max();\n        var minInv = 1.0 / min;\n      \
    \  var maxInv = 1.0 / max;\n        var out = new List<float>();\n        foreach\
    \ (var num in numbers) {\n            out.Add((num - min) * minInv);\n       \
    \     out.Add((num - max) * maxInv);\n        }\n        return out;", "     \
    \   float max = numbers.Max();\n        float min = numbers.Min();\n        numbers.RemoveAll(n\
    \ => n < min);\n        numbers.RemoveAll(n => n > max);\n        return numbers;",
  "        if (numbers.Count < 2) throw new ArgumentException(\"Too few numbers given\"\
    , \"numbers\");\n        if (numbers.Count > 200) throw new ArgumentException(\"\
    Too many numbers given\", \"numbers\");\n        List<float> rescaled = new List<float>(numbers);\n\
    \        float minValue = rescaled.Min();\n        float maxValue = rescaled.Max();\n\
    \        // This is not robust against overflow!\n        float delta = maxValue\
    \ - minValue;\n        if (delta == 0.0f) {\n            rescaled = new List<float>(new\
    \ float[]{(float)0.0f, (float)1.0f});\n            minValue = rescaled.Min();\n\
    \            maxValue = rescaled.Max();\n            delta = maxValue - minValue;\n\
    \        }\n        float rescaledMinValue = rescaled.Min();\n        float rescaledMaxValue\
    \ = rescaled.Max();\n        float rescaledDelta = rescaledMaxValue - rescaledMinValue;\n\
    \        rescaled[0] = (float)((rescaled[0] - minValue) / delta);\n        rescaled[rescaled.Count\
    \ - 1] = (float)((maxValue - rescaled[rescaled.Count - 1]) / delta);\n       \
    \ return rescaled;", "        // TODO: Implement this\n        throw new NotImplementedException();",
  "        if (numbers.Count < 2) return numbers;\n        float[] scaled = numbers.Select(n\
    \ => (n - numbers.Min()) / (numbers.Max() - numbers.Min())).ToArray();\n     \
    \   return numbers.Select(n => (n < 0 ? 0f : 1f) * (n - numbers.Min()) + numbers.Min()).ToList().ConvertAll(n\
    \ => n * scaled[n]).ToList();", "        // We need to rescale all numbers to\
    \ fit in the range of 0 to 1\n        float min = numbers.Min();\n        float\
    \ max = numbers.Max();\n        int range = (int)Math.Round(Math.Sqrt(Math.Pow(max\
    \ - min, 2) + 1));\n\n        var scaledNumbers = new List<float>(numbers.Count);\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            var scaledNumber\
    \ = (numbers[i] - min) / (max - min);\n            scaledNumbers[i] = scaledNumber\
    \ * range;\n        }\n\n        return scaledNumbers;", "        // Make sure\
    \ we have at least two numbers\n        if (numbers.Count < 2) return new List<float>(numbers);\n\
    \        // Make sure all numbers are floats (they can be int or short)\n    \
    \    foreach (float number in numbers)\n            if (number > 1.0f)\n     \
    \           throw new InvalidOperationException(\"All numbers must be in range\
    \ [0, 1]\");\n        // Make sure all numbers are floats\n        float min =\
    \ numbers.Min();\n        float max = numbers.Max();\n        if (min >= 0.0f\
    \ && min >= max) return new List<float>(numbers);\n        if (max <= 0.0f &&\
    \ max <= min) return new List<float>(numbers);\n        // Make sure numbers are\
    \ between 0.0 and 1.0\n        bool zeroOrOne = false;\n        foreach (float\
    \ number in numbers) {\n            if (number == 0.0f)\n                zeroOrOne\
    \ = true;\n            else if (number < 0.0f)\n                throw new InvalidOperationException(\"\
    All numbers must be in range [0, 1]\");\n            else if (number > 1.0f)\n\
    \                throw new InvalidOperationException(\"All numbers must be in\
    \ range [0, 1]\");\n        }\n        if (zeroOrOne) return new List<float>(numbers);\n\
    \        // Choose the transform by figuring out which numbers are zero (if any)\
    \ and which are not\n        float zero = 0.0f;\n        float one = 1.0f;\n \
    \       bool first = true;\n        foreach (float number in numbers) {\n    \
    \        if (!first) {\n                zero = zero;\n                one = one;\n\
    \            }\n            else {\n                if (number == 0.0f) {\n  \
    \                  zero = 1.0f;\n                    one = 0.0f;\n           \
    \     }\n                else {\n                    zero = 0.0f;\n          \
    \          one = 1.0f;\n                }\n            }\n            first =\
    \ false;\n        }\n        List<float> result = new List<float>();\n       \
    \ float lastZero = zero;\n        foreach (float number in numbers) {\n      \
    \      // Adjust the number to be in range (0.0,1.0)\n            if (number >\
    \ 0.0f && number < 1.0f)\n                number -= 1.0f;\n            // Scale\
    \ up the number\n            float scalingFactor = one / lastZero;\n         \
    \   number += lastZero * scalingFactor;\n            result.Add(number);\n   \
    \         lastZero = zero;\n        }\n        // Make sure result is sorted\n\
    \        Array.Sort(result);\n        return result;", "        if (numbers.Count\
    \ < 2) throw new ArgumentException();\n        float maxValue = numbers.Max();\n\
    \        float minValue = numbers.Min();\n        if (maxValue == minValue) throw\
    \ new ArgumentException();\n        double delta = maxValue - minValue;\n    \
    \    // Make sure the delta is between 0 and 1.\n        if (delta < 0) throw\
    \ new ArgumentException();\n        if (Math.Abs(delta) > Math.Abs((1.0f/Math.Max(maxValue,\
    \ minValue))) ) throw new ArgumentException();\n        float scaledMinValue =\
    \ minValue + ((numbers.Min()-minValue) * delta);\n        float scaledMaxValue\
    \ = maxValue - ((numbers.Max()-maxValue) * delta);\n        // Convert to doubles\
    \ before applying the scale.\n        numbers = numbers.Select(x => (double)x).ToList();\n\
    \        numbers.ForEach(x => (x *= (1.0f/delta)));\n        // Apply scaling.\n\
    \        numbers.ForEach(x => x -= scaledMinValue);\n        numbers.ForEach(x\
    \ => x += scaledMaxValue);\n        // Convert to floats after applying the scale.\n\
    \        numbers = numbers.Select(x => (float)x).ToList();\n        return numbers;",
  "        Debug.Assert(numbers != null);\n\n        var min = numbers.Min();\n  \
    \      var max = numbers.Max();\n\n        if (min == 0.0f) {\n            Debug.Assert(min\
    \ != 0.0f);\n            min = 0.0f;\n        }\n        if (max == 0.0f) {\n\
    \            Debug.Assert(max != 0.0f);\n            max = 1.0f;\n        }\n\n\
    \        var length = numbers.Count;\n        var scale = (float)Math.Log(max\
    \ / min);\n        var newList = new List<float>();\n\n        for (var i = 0;\
    \ i < length; i++) {\n            var newNumber = numbers[i] * scale;\n      \
    \      newList.Add(newNumber);\n        }\n\n        if (min == 0.0f) {\n    \
    \        newList[0] = 0.0f;\n        } else if (max == 1.0f) {\n            newList[newList.Count\
    \ - 1] = 1.0f;\n        }\n\n        return newList;", "        if (numbers.Count\
    \ < 2)\n            throw new ArgumentException(\"List of numbers must have at\
    \ least 2 elements!\");\n\n        // Calculate unit vector\n        List<float>\
    \ unit = new List<float>(new float[numbers.Count]);\n        for (int i = 0; i\
    \ < numbers.Count; i++)\n            unit[i] = numbers[i] / numbers[0];\n\n  \
    \      // Multiply each number by the unit vector\n        for (int i = 0; i <\
    \ numbers.Count; i++)\n            numbers[i] = numbers[i] * unit[0];\n\n    \
    \    // Scale each number by the largest absolute value of all numbers after the\
    \ first\n        for (int i = 1; i < numbers.Count; i++)\n            numbers[i]\
    \ /= Math.Max(numbers[i - 1] * unit[0], unit[1]);\n\n        // Return the result\n\
    \        return numbers;", "        if (numbers.Count < 2) throw new ArgumentException(\"\
    Invalid number of arguments\", \"numbers\");\n        float minimum = numbers.Min(),\
    \ maximum = numbers.Max();\n        if (minimum == maximum) throw new ArgumentException(\"\
    Cannot rescale numbers to unit interval\", \"numbers\");\n        double scale\
    \ = (double)numbers.Count / maximum;\n        return numbers.Select(v => v / scale).ToList();",
  "        float min = numbers.Min();\n        float max = numbers.Max();\n      \
    \  // Normalize numbers to be between 0 and 1\n        List<float> normalizedNumbers\
    \ = numbers.Select(num => (num - min) / (max - min)).ToList();\n        // Set\
    \ minimum value of numbers back to 0\n        normalizedNumbers.Min();\n     \
    \   // Set maximum value of numbers back to 1\n        normalizedNumbers.Max();\n\
    \        return normalizedNumbers;", "        int size = numbers.Count;\n    \
    \    // TODO: Add checks to make sure numbers is a List<float>\n\n        float\
    \ min = numbers.Min();\n        float max = numbers.Max();\n        if (min ==\
    \ max) min = 1.0f;\n        if (min == 0.0f) min = 0.0f;\n        if (max == 1.0f)\
    \ max = 1.0f;\n        if (max == 0.0f) max = 0.0f;\n\n        List<float> newNumbers\
    \ = new List<float>();\n        int n = 0;\n        float fMin = 0.0f, fMax =\
    \ 1.0f;\n        bool scale = false;\n        for (int i = 0; i < size; i++) {\n\
    \            float number = numbers[i];\n            if (i == 0) {\n         \
    \       fMin = number; fMax = number;\n            }\n            fMin = fMin\
    \ == 0.0f ? number : Math.Min(fMin, number);\n            fMax = fMax == 1.0f\
    \ ? number : Math.Max(fMax, number);\n\n            if (fMin < 0.0f) {\n     \
    \           fMin = 0.0f; scale = true;\n            }\n            if (fMax >\
    \ 1.0f) {\n                fMax = 1.0f; scale = true;\n            }\n\n     \
    \       float fValue = (fMax - fMin) / (max - min);\n            float newNumber\
    \ = (number - fMin) / fValue;\n            newNumbers.Add(newNumber);\n      \
    \      n = i;\n        }\n\n        if (scale) {\n            // The list was\
    \ scaled, so subtract the minimum and divide by the scale\n            float scaleValue\
    \ = (fMax - fMin) / (max - min);\n            for (int i = 0; i < newNumbers.Count;\
    \ i++) {\n                newNumbers[i] = newNumbers[i] - fMin;\n            \
    \    newNumbers[i] /= scaleValue;\n            }\n        }\n\n        // The\
    \ numbers are now between 0 and 1\n        for (int i = 0; i < newNumbers.Count;\
    \ i++) {\n            if (newNumbers[i] < 0.0f) newNumbers[i] = 0.0f;\n      \
    \      if (newNumbers[i] > 1.0f) newNumbers[i] = 1.0f;\n        }\n\n        return\
    \ newNumbers;", "        var result = new List<float>(numbers);\n\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            result[i] = result[i] / numbers[i];\n\
    \        }\n\n        return result;", "        // Linear mapping from min-max\
    \ interval to [0,1] interval, s.t. xmin -> 0 and xmax -> 1\n        // Source:\
    \ http://en.wikipedia.org/wiki/Linear_mapping#Mapping_a_range_to_a_range\n   \
    \     var xmin = numbers.Min();\n        var xmax = numbers.Max();\n        var\
    \ xrange = (xmax - xmin);\n        var rescaledNumbers = new List<float>();\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            var normalized\
    \ = ((numbers[i] - xmin) / xrange);\n            rescaledNumbers.Add(normalized);\n\
    \        }\n        return rescaledNumbers;", "        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        var newMin = 0;\n        var newMax\
    \ = 1;\n\n        if (min == max) {\n            newMin = newMax = min;\n    \
    \    } else if (min > max) {\n            throw new Exception(\"Cannot rescale\
    \ to unbounded domain\");\n        } else {\n            newMin = (min - min %\
    \ 1.0f + 1.0f) % 1.0f;\n            newMax = (max - max) % 1.0f;\n        }\n\n\
    \        var newNumbers = new List<float>();\n        foreach (var n in numbers)\
    \ {\n            var rescaled = ((n - min) / (max - min)) * newMax - newMin;\n\
    \            newNumbers.Add(rescaled);\n        }\n\n        return newNumbers;",
  "        var minValue = numbers.Min();\n        var maxValue = numbers.Max();\n\
    \        var scale = (maxValue - minValue) / (numbers.Count - 1);\n        return\
    \ numbers.Select(x => x * scale).ToList();", "        if (numbers.Count < 2)\n\
    \            return new List<float>(numbers);\n        var smallest = numbers.Min();\n\
    \        var largest = numbers.Max();\n        if (smallest == largest)\n    \
    \        return numbers;\n        var scale = (largest - smallest);\n        if\
    \ (scale == 0)\n            return new List<float>(numbers);\n        List<float>\
    \ scaled = new List<float>(numbers);\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            scaled.Add(numbers[i] - smallest + scale / 2.0f);\n    \
    \    }\n        return scaled;", "        double min = numbers.Min();\n      \
    \  double max = numbers.Max();\n        double range = Math.Max(Math.Abs(min),\
    \ Math.Abs(max));\n\n        // Scale to the range [0, range]\n        double\
    \ rescaledMin = 0;\n        double rescaledMax = range;\n        while (rescaledMin\
    \ < 0 && numbers.Any(x => Math.Abs(x - min) < 1e-5)) {\n            rescaledMin\
    \ += range;\n        }\n        while (rescaledMax > 0 && numbers.Any(x => Math.Abs(x\
    \ - max) < 1e-5)) {\n            rescaledMax -= range;\n        }\n        rescaledMin\
    \ = Math.Abs(rescaledMin);\n        rescaledMax = Math.Abs(rescaledMax);\n   \
    \     // Scale to the range [rescaledMin, rescaledMax]\n        double rangeScale\
    \ = rescaledMax - rescaledMin;\n        if (rescaledMax != 0) {\n            numbers.AddRange(numbers.Where(x\
    \ => Math.Abs(x - rescaledMin) < 1e-5)\n                                    .Select(x\
    \ => (float)(x - rescaledMin) / rangeScale)\n                                \
    \    .Select(x => (float)(Math.Abs(x) * rangeScale)));\n        }\n        if\
    \ (rescaledMin != 0) {\n            numbers.AddRange(numbers.Where(x => Math.Abs(x\
    \ - rescaledMax) < 1e-5)\n                                    .Select(x => (float)(x\
    \ - rescaledMax) / rangeScale)\n                                    .Select(x\
    \ => (float)(Math.Abs(x) * rangeScale)));\n        }\n        List<float> scaledNumbers\
    \ = new List<float>();\n        foreach (var number in numbers) {\n          \
    \  scaledNumbers.Add((float)(Math.Abs(number) + Math.Abs(number) - Math.Abs(number))\
    \ / 2);\n        }\n        return scaledNumbers;", "        if (numbers.Count\
    \ <= 1) return numbers;\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        numbers.ForEach(num => (float)(num - min) / (max - min));\n        return\
    \ numbers;", "        if (numbers.Count < 2) {\n            return numbers;\n\
    \        }\n\n        var newNumbers = new List<float>(numbers.Count);\n\n   \
    \     newNumbers.Add((float) MathF.Min(numbers[0], numbers[1]));\n        newNumbers.Add((float)\
    \ MathF.Max(numbers[0], numbers[1]));\n\n        return newNumbers;", "      \
    \  if (numbers.Count == 0) return numbers;\n        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        var scale = (max - min) / (1.0f - min);\n\
    \        var normalizedNumbers = numbers.Select(n => (float)((n - min) * scale)\
    \ + min);\n        return new List<float>(normalizedNumbers);", "        Debug.Assert(numbers\
    \ != null && numbers.Count >= 2, \"Input list must be non null and non-empty\"\
    );\n\n        float smallest = numbers.Min();\n        float largest = numbers.Max();\n\
    \        float range = largest - smallest;\n        float rescaled = numbers.Select(n\
    \ => ((n - smallest) / range) * range).Sum();\n        return numbers.Select(n\
    \ => (float)Math.Round(n * rescaled)).ToList();", "        // Get list of unique\
    \ values\n        var distinctValues = numbers.Distinct();\n        // Get max\
    \ and min values\n        var maxValue = distinctValues.Max();\n        var minValue\
    \ = distinctValues.Min();\n        // Get the delta of min/max values\n      \
    \  var delta = (maxValue - minValue) / (distinctValues.Count + 1);\n        //\
    \ Get transformed values\n        List<float> transformedValues = new List<float>(distinctValues.Count);\n\
    \        for (int i = 0; i < distinctValues.Count; i++) {\n            transformedValues.Add(minValue\
    \ + (i * delta));\n        }\n        return transformedValues;", "        if\
    \ (numbers.Count < 2) return numbers;\n        // Find the smallest and largest\
    \ of the input\n        var smallest = numbers.Min();\n        var largest = numbers.Max();\n\
    \        // Rescale all numbers to be between 0 and 1\n        // >>> RescaleToUnit((new\
    \ List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f,\
    \ (float)5.0f})))\n        // (new List<float>(new float[]{(float)0.0f, (float)0.25f,\
    \ (float)0.5f, (float)0.75f, (float)1.0f}))\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            var thisNumber = numbers[i];\n            numbers[i] = thisNumber\
    \ / (float)(largest - smallest);\n        }\n        return numbers;", "     \
    \   int largest = numbers.Max();\n        int smallest = numbers.Min();\n    \
    \    numbers.ForEach(n => n = ((n - smallest) / (largest - smallest)));\n    \
    \    return numbers;", "        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        var range = max - min;\n        foreach (var n in numbers) {\n      \
    \      n -= min;\n            n /= range;\n            n += min;\n        }\n\
    \        return numbers;", "        // First, sort the numbers ascending\n   \
    \     var numbersSorted = numbers.OrderBy(x => x);\n        // Now, divide them\
    \ into two groups: those smaller than 0.5 and those larger than 0.5\n        var\
    \ numbersSmallThanHalf = numbersSorted.Where(x => x < 0.5f);\n        var numbersGreaterThanHalf\
    \ = numbersSorted.Where(x => x > 0.5f);\n        // Now, multiply those numbers\
    \ by the scaling factor\n        var scaled = numbersSmallThanHalf.Select(x =>\
    \ (x - 0.5f) * 0.75f);\n        // Now, add them together, and return the results\n\
    \        return (scaled.Concat(numbersGreaterThanHalf)).ToList();", "        if\
    \ (numbers.Count == 0) {\n            return new List<float>();\n        }\n \
    \       float largest = numbers.Max();\n        float smallest = numbers.Min();\n\
    \        List<float> result = new List<float>();\n        // Scale the list by\
    \ smallest number so that smallest becomes 0, largest becomes 1\n        foreach\
    \ (float number in numbers) {\n            result.Add(number * smallest / largest);\n\
    \        }\n        return result;", "        List<float> result = new List<float>();\n\
    \        foreach (float n in numbers) {\n            float scale = (n - numbers.Min())\
    \ / (numbers.Max() - numbers.Min());\n            result.Add(scale);\n       \
    \ }\n        return result;", "        if (numbers.Count < 2) return numbers;\n\
    \        float min = numbers.Min();\n        float max = numbers.Max();\n    \
    \    float range = max - min;\n        float range = range > 0 ? range : 1;\n\
    \        float scale = 1.0 / range;\n        List<float> newList = new List<float>(numbers);\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            newList[i] *=\
    \ scale;\n        }\n        return newList;", "        // TODO: Implement linear\
    \ transformation here\n        //return numbers;\n        return new List<float>();",
  "        var min = numbers.Min();\n        var max = numbers.Max();\n        var\
    \ result = new List<float>(numbers.Count);\n        for (int i = 0; i < numbers.Count;\
    \ ++i) {\n            float scaledNumber = numbers[i] / max - min;\n         \
    \   result.Add(scaledNumber * max - min);\n        }\n        return result;",
  "        double totalMin = numbers.Min();\n        double totalMax = numbers.Max();\n\
    \        double scale = ((totalMax - totalMin) / (1.0f - totalMin));\n       \
    \ List<float> result = new List<float>();\n        foreach (float item in numbers)\
    \ {\n            result.Add((item - totalMin) * scale);\n        }\n        return\
    \ result;", "        float total = 0f;\n        float smallest = numbers.Min();\n\
    \        float largest = numbers.Max();\n        if (smallest == 0f && largest\
    \ == 1f)\n            return numbers;\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            total += numbers[i];\n        if (largest == 0f)\n       \
    \     largest = total;\n        if (smallest == 1f)\n            smallest = total;\n\
    \        float scale = largest / total;\n        float offset = 0f;\n        return\
    \ new List<float>(\n            numbers\n            .Select(num => (num - smallest\
    \ - offset) * scale)\n            .ToList()\n        );", "        int smallest\
    \ = numbers.Min();\n        int largest = numbers.Max();\n        double scale\
    \ = smallest / largest;\n        List<float> result = new List<float>();\n   \
    \     foreach (var number in numbers) {\n            result.Add((float)(number\
    \ * scale));\n        }\n        return result;", "        if (numbers.Count <\
    \ 2)\n            return numbers;\n        int count = numbers.Count;\n      \
    \  float smallest = numbers[0];\n        float largest = numbers[0];\n       \
    \ for (int i = 1; i < count; i++) {\n            if (numbers[i] < smallest) {\n\
    \                smallest = numbers[i];\n            }\n            if (numbers[i]\
    \ > largest) {\n                largest = numbers[i];\n            }\n       \
    \ }\n        if (smallest == 0) {\n            smallest = 1;\n        }\n    \
    \    if (largest == 0) {\n            largest = 1;\n        }\n        if (largest\
    \ == smallest) {\n            return numbers;\n        }\n        float scale\
    \ = (largest - smallest) / (float)count;\n        List<float> result = new List<float>();\n\
    \        for (int i = 0; i < count; i++) {\n            result.Add(numbers[i]\
    \ * scale);\n        }\n        return result;", "        // We will divide the\
    \ smallest and largest numbers by the number of numbers in the list\n        //\
    \ This ensures that all numbers will be within the range [0, 1]\n        var min\
    \ = numbers.Min();\n        var max = numbers.Max();\n        var scale = (max\
    \ - min) / (numbers.Count - 1);\n        // Perform the actual rescaling\n   \
    \     numbers.ForEach(x => x *= scale);\n        // Return the resulting list\n\
    \        return numbers;", "        var min = numbers.Min();\n        var max\
    \ = numbers.Max();\n        var scale = (max - min) / (float)numbers.Count;\n\n\
    \        var ret = new List<float>();\n        foreach (var n in numbers) {\n\
    \            ret.Add(scale*n + min);\n        }\n\n        return ret;", "   \
    \     // We could do some basic error checking to ensure there's at least 2 numbers\
    \ here,\n        // but this should be good enough to ensure our code will work\n\
    \        if (numbers.Count < 2) throw new ArgumentOutOfRangeException(\"numbers\"\
    , numbers.Count, \"At least 2 numbers are required.\");\n\n        // First get\
    \ the smallest and largest numbers in the list, then use the largest number\n\
    \        // to normalize the smallest and largest.\n        float smallest = numbers.Min();\n\
    \        float largest = numbers.Max();\n\n        // Now we'll find the range\
    \ between our smallest and largest numbers\n        // and divide our smallest\
    \ and largest numbers by that range.\n        float range = largest - smallest;\n\
    \        float normalizedSmallest = smallest / range;\n        float normalizedLargest\
    \ = largest / range;\n\n        // Now we'll apply the transformation to our smallest\
    \ and largest numbers\n        // and multiply them by the scale factor\n    \
    \    float scaleFactor = range / 2.0f;\n\n        List<float> scaledNumbers =\
    \ new List<float>(numbers.Count);\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            scaledNumbers.Add(numbers[i] * scaleFactor);\n        }\n\
    \        return scaledNumbers;", "        // TODO: Implement me!\n        return\
    \ numbers.Select(x => (x)).ToList();", "        if (numbers.Count < 2) {\n   \
    \         return numbers;\n        }\n        float min, max;\n        min = numbers.Min();\n\
    \        max = numbers.Max();\n        if (min == 0) {\n            min = 1;\n\
    \        }\n        if (max == 0) {\n            max = 1;\n        }\n       \
    \ float range = max - min;\n        if (range == 0) {\n            return numbers;\n\
    \        }\n        if (range > 1) {\n            return numbers;\n        }\n\
    \        float factor = range / 2;\n        float scaledMax = numbers.Max() +\
    \ (numbers.Count() * factor);\n        float scaledMin = numbers.Min() - (numbers.Count()\
    \ * factor);\n        numbers.Clear();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            numbers.Add(numbers[i] * factor - scaledMin);\n        \
    \    numbers.Add(numbers[i] * factor + scaledMax);\n        }\n        return\
    \ numbers;", "        // This is linear function y = mx + b where m is the slope,\
    \ b the bias\n        // Find slope and bias\n        float m = 1.0f;\n      \
    \  float b = 0.0f;\n        foreach (float f in numbers) {\n            m += f\
    \ / numbers.Count;\n            b += f;\n        }\n\n        // Find the new\
    \ minimum value\n        m = (float)(m * numbers.Count - b);\n\n        // The\
    \ new scale factor\n        float newScale = 1.0f / (m * numbers.Count);\n\n \
    \       // Apply the new scale\n        List<float> scaledNumbers = numbers.Select(n\
    \ => (n * newScale)).ToList();\n\n        // Rescale so that the new minimum value\
    \ is 0\n        float newMin = scaledNumbers.Min();\n        scaledNumbers.ForEach(n\
    \ => (n * newMin));\n\n        // Rescale so that the new maximum value is 1\n\
    \        float newMax = scaledNumbers.Max();\n        scaledNumbers.ForEach(n\
    \ => (n * (1 - newMax)));\n\n        // Return the scaled numbers\n        return\
    \ scaledNumbers;", "        if (numbers.Count < 2) {\n            return numbers;\n\
    \        }\n\n        numbers.Sort();\n        var min = numbers.Min();\n    \
    \    var max = numbers.Max();\n\n        float scale = (max - min) / (float)numbers.Count;\n\
    \n        foreach (float x in numbers) {\n            x *= scale;\n        }\n\
    \n        float delta = (max - min) / 2.0;\n        numbers.ForEach(x => (x -\
    \ min) * delta + min);\n        return numbers;", "        double maxValue = numbers.Max();\n\
    \        double minValue = numbers.Min();\n        if (maxValue == minValue)\n\
    \        {\n            return numbers;\n        }\n        double range = (maxValue\
    \ - minValue);\n        double scale = (1 / range);\n        foreach (float number\
    \ in numbers)\n        {\n            number -= minValue;\n            number\
    \ *= scale;\n        }\n        numbers.Reverse();\n        return numbers;",
  "        if (numbers.Count < 2) throw new ArgumentException(\"Must have at least\
    \ two numbers.\");\n        List<float> result = new List<float>();\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            float number = numbers[i];\n\
    \            if (i == 0) {\n                result.Add(number);\n            }\
    \ else {\n                float previous = result[i-1];\n                if (number\
    \ - previous > 0) throw new ArgumentException(\"Can only scale up\");\n      \
    \          float scale = 1.0f / previous;\n                result.Add(number *\
    \ scale);\n            }\n        }\n        return result;", "        // Transform\
    \ each number between 0 and 1\n        var result = new List<float>(numbers);\n\
    \        foreach (float number in numbers) {\n            // Clamp between 0.0\
    \ and 1.0\n            var numberClamped = Math.Clamp(number, 0.0f, 1.0f);\n \
    \           // Transform the number between 0 and 1\n            var numberScaled\
    \ = numberClamped / numberClamped;\n            // Add the scaled number to the\
    \ result list\n            result.Add(numberScaled);\n        }\n        // Return\
    \ the result list\n        return result;", "        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        var range = max - min;\n        var\
    \ zero = (float)min - ((range.Inverse % 0.0f) / 0.0f);\n        var result = new\
    \ List<float>();\n        var largest = numbers.Last();\n        for (int i =\
    \ 0; i < numbers.Count; i++) {\n            result.Add((zero + numbers[i]) / range);\n\
    \        }\n        if (largest < 0.0f) {\n            result.Add(largest);\n\
    \        }\n        return result;", "        float minValue = numbers.Min();\n\
    \        float maxValue = numbers.Max();\n\n        var result = numbers.Select(x\
    \ => Math.Min(Math.Max(x - minValue, 0.0f), maxValue - minValue));\n\n       \
    \ return result.ToList();", "        if (numbers.Count < 2) {\n            return\
    \ numbers;\n        }\n\n        // Get mean of numbers\n        var mean = numbers.Average();\n\
    \        // Get standard deviation of numbers\n        var stdDev = numbers.Select(n\
    \ => Math.Sqrt(Math.Pow(n - mean, 2))).Sum() / numbers.Count;\n\n        // Return\
    \ numbers after transform (multiplying by std dev and dividing by std mean)\n\
    \        return numbers.Select(n => n / stdDev * stdDev).ToList();", "       \
    \ var largest = numbers.Max();\n        var smallest = numbers.Min();\n      \
    \  var minScale = (float) smallest / largest;\n        var maxScale = (float)\
    \ largest / smallest;\n        return numbers.Select(n => (float) (n - smallest)\
    \ * minScale / maxScale).ToList();", "        // We want to keep all values between\
    \ 0 and 1\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        var scale = max - min;\n        var normalizedValues = new List<float>(numbers.Count);\n\
    \        foreach (var number in numbers) {\n            normalizedValues.Add((float)((number\
    \ - min) / scale));\n        }\n        return normalizedValues;", "        //\
    \ We will keep track of the minimum value of the list of numbers so far\n    \
    \    // and we will keep track of the maximum value of the list of numbers so\
    \ far\n        float minValue = 0;\n        float maxValue = 1;\n\n        //\
    \ We will apply a linear transform to each of the numbers in our list\n      \
    \  // such that the smallest number will become 0 and the largest will become\
    \ 1\n        foreach (float number in numbers) {\n            float scaledNumber;\n\
    \n            // If our number is less than our minimum value, update our min\
    \ value and our scaled number\n            // by scaling by our previous min value\n\
    \            if (number < minValue) {\n                minValue = number;\n  \
    \              scaledNumber = (number - minValue) * minValue;\n            }\n\
    \            // If our number is greater than our maximum value, update our max\
    \ value and our scaled number\n            // by scaling by our previous max value\n\
    \            else if (number > maxValue) {\n                maxValue = number;\n\
    \                scaledNumber = (number - maxValue) * maxValue;\n            }\n\
    \            // If our number is between two values, then we simply update our\
    \ scaled number\n            else {\n                scaledNumber = number;\n\
    \            }\n\n            // Now that we have our scaled number we can add\
    \ to our list with our new scaled number\n            numbers.Add(scaledNumber);\n\
    \        }\n\n        // Now that we have our numbers scaled we can just return\
    \ our numbers list with our new values\n        return numbers;", "        var\
    \ length = numbers.Count;\n        var smallest = -1.0f;\n        var largest\
    \ = 1.0f;\n\n        foreach (var number in numbers) {\n            if (smallest\
    \ == -1.0f) {\n                smallest = number;\n            }\n\n         \
    \   if (largest == 1.0f) {\n                largest = number;\n            }\n\
    \n            if (number < smallest ) {\n                smallest = number;\n\
    \            }\n\n            if (number > largest ) {\n                largest\
    \ = number;\n            }\n        }\n\n        var scale = (largest - smallest);\n\
    \n        var newList = new List<float>();\n\n        for (var i = 0; i < length;\
    \ i++){\n            newList.Add(numbers[i] * (largest - smallest) / scale);\n\
    \        }\n\n        return newList;", "        List<float> result = new List<float>(numbers.Count);\n\
    \        float scale = 1;\n        float min;\n        float max;\n        foreach\
    \ (float num in numbers) {\n            min = Math.Min(min, num);\n          \
    \  max = Math.Max(max, num);\n        }\n        foreach (float num in numbers)\
    \ {\n            float scaleChange = (num - min) / (max - min);\n            result.Add((scale\
    \ * scaleChange) + min);\n            scale *= 2;\n        }\n        return result;",
  "        double sum = Math.Min(numbers.Sum(), numbers.Max());\n        return numbers.Select(x\
    \ => (float)(x / sum)).ToList();", "        if (numbers == null) {\n         \
    \   throw new ArgumentNullException(nameof(numbers));\n        }\n\n        if\
    \ (numbers.Count < 2) {\n            throw new ArgumentException(\"Can only scale\
    \ a list with two elements\");\n        }\n\n        // We will add two new elements\
    \ to the list to ensure we have at least two elements\n        numbers.Add(0.0f);\n\
    \        numbers.Add(1.0f);\n\n        float totalMin = numbers.Min();\n     \
    \   float totalMax = numbers.Max();\n\n        // Normalize the values to [0,\
    \ 1]\n        List<float> scaledNumbers = numbers.Select(x => (x - totalMin) /\
    \ (totalMax - totalMin)).ToList();\n\n        // Rescale the normalized values\n\
    \        float scalingFactor = 0.0f;\n        if (scaledNumbers.Max() > 0) {\n\
    \            scalingFactor = 1.0f / scaledNumbers.Max();\n        }\n        scaledNumbers.ForEach(x\
    \ => x *= scalingFactor);\n\n        // Normalize the scaled values back to [0,\
    \ 1]\n        scaledNumbers = scaledNumbers.Select(x => (x - scaledNumbers.Min())\
    \ / (scaledNumbers.Max() - scaledNumbers.Min())).ToList();\n\n        return scaledNumbers;",
  "        if (numbers.Count < 2) {\n            return numbers;\n        }\n\n  \
    \      List<float> result = new List<float>(numbers.Count);\n        int rangeMin\
    \ = numbers.Min(n => n);\n        int rangeMax = numbers.Max(n => n);\n      \
    \  float rangeDiff = rangeMax - rangeMin;\n        float rangeTotal = rangeMax;\n\
    \n        float rangeDiffDiff = rangeDiff - rangeDiff;\n        if (rangeDiffDiff\
    \ > 0) {\n            rangeTotal += rangeDiff;\n        } else {\n           \
    \ rangeTotal -= rangeDiff;\n        }\n\n        float rangeTotalDiff = rangeTotal\
    \ - rangeMin;\n        float scale = (float)1 / (float)rangeTotalDiff;\n\n   \
    \     for (int i = 0; i < numbers.Count; i++) {\n            float current = numbers[i];\n\
    \            float next = current + rangeDiff;\n            float scaledNext =\
    \ next * scale;\n            result.Add(scaledNext);\n        }\n        return\
    \ result;", "        if (numbers.Count < 2) {\n            throw new ArgumentException(\"\
    RescaleToUnit(List<float>) requires a minimum of two elements\");\n        }\n\
    \        if (numbers.Count > 1000) {\n            throw new ArgumentException(\"\
    RescaleToUnit(List<float>) cannot process a list of more than 1000 elements\"\
    );\n        }\n        // This function is from http://www.codeproject.com/KB/cs/linearscaling.aspx\n\
    \        // It is used to convert between [0,1] and [min, max] values on a [0,1]\
    \ scale\n        List<float> linear = new List<float>(numbers);\n        double\
    \ min, max;\n        min = linear.Min();\n        max = linear.Max();\n      \
    \  double scaledMax = (max - min);\n        // Scale to [0,1]\n        for (double\
    \ i = 0; i < linear.Count; i++) {\n            double value = linear[i];\n   \
    \         linear[i] = (value - min) / scaledMax;\n        }\n        // Linearly\
    \ transform [0,1] -> [min, max] -> [min, max]\n        min = linear.Min();\n \
    \       max = linear.Max();\n        double scaledMin = (min - min);\n       \
    \ for (double i = 0; i < linear.Count; i++) {\n            double value = linear[i];\n\
    \            linear[i] = (value - min) / scaledMin;\n        }\n        return\
    \ linear;", "        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \n        var difference = max - min;\n        if (difference == 0) {\n      \
    \      return numbers;\n        }\n\n        var result = new List<float>(numbers.Count);\n\
    \        for (var i = 0; i < numbers.Count; i++) {\n            result[i] = numbers[i]\
    \ - min;\n        }\n\n        return result;", "        List<float> transformed\
    \ = new List<float>();\n        float smallestNumber = numbers.Min();\n      \
    \  float largestNumber = numbers.Max();\n        float delta = (largestNumber\
    \ - smallestNumber) / (numbers.Count - 1);\n        if (delta != 0) {\n      \
    \      for (int i = 0; i < numbers.Count; i++) {\n                float number\
    \ = numbers[i];\n                transformed.Add(smallestNumber + delta * i);\n\
    \            }\n        }\n        else {\n            transformed = numbers;\n\
    \        }\n        return transformed;", "        List<float> rescaledNumbers\
    \ = new List<float>();\n        float min = numbers.Min();\n        float max\
    \ = numbers.Max();\n        float scale = (float)(1.0f / (max - min));\n     \
    \   foreach(float number in numbers) {\n            rescaledNumbers.Add(number\
    \ * scale);\n        }\n        return rescaledNumbers;", "        bool isUnit\
    \ = false;\n        float min = numbers.Min();\n        float max = numbers.Max();\n\
    \        if (min == 0.0f && max == 1.0f) {\n            isUnit = true;\n     \
    \       numbers.Remove(numbers.Count - 1);\n        } else {\n            numbers.Sort();\n\
    \        }\n\n        float range = max - min;\n        if (min == 0.0f && max\
    \ == 1.0f) {\n            numbers.Remove(numbers.Count - 1);\n            numbers[0]\
    \ = numbers[0];\n            numbers[numbers.Count - 1] = numbers[numbers.Count\
    \ - 1];\n            return numbers;\n        }\n\n        if (range != 0.0f)\
    \ {\n            for (int i = 0; i < numbers.Count - 1; i++) {\n             \
    \   numbers[i] += min - numbers[i];\n            }\n        } else {\n       \
    \     for (int i = 0; i < numbers.Count - 1; i++) {\n                numbers[i]\
    \ = 0.0f;\n            }\n        }\n\n        if (isUnit) {\n            numbers[0]\
    \ = numbers[0];\n            numbers[numbers.Count - 1] = numbers[numbers.Count\
    \ - 1];\n        }\n        return numbers;", "        if (numbers.Count < 2)\n\
    \            return numbers;\n\n        var min = numbers.Min();\n        var\
    \ max = numbers.Max();\n\n        // If the max is zero, set it to one to avoid\
    \ divide by zero\n        if (max == 0)\n            max = 1.0f;\n\n        //\
    \ If the min is zero, set it to zero to prevent negative values\n        if (min\
    \ == 0)\n            min = 0.0f;\n\n        // Calculate scaling factor for linear\
    \ transformation\n        var scale = 1.0f / (max - min);\n\n        // Apply\
    \ linear transformation\n        var result = new List<float>();\n        foreach\
    \ (var number in numbers) {\n            result.Add(scale * number);\n       \
    \ }\n\n        return result;", "        if (numbers.Count < 2) {\n          \
    \  return numbers;\n        }\n        var smallest = numbers.Min();\n       \
    \ var largest = numbers.Max();\n        var difference = largest - smallest;\n\
    \        var min = smallest - smallest * difference;\n        var max = smallest\
    \ + largest * difference;\n        return numbers.Select((x) => x - min).Concat(numbers.Select((x)\
    \ => x + min)).ToList();", "        if (numbers.Count < 2) {\n            return\
    \ numbers;\n        }\n        var minValue = numbers.Min();\n        var maxValue\
    \ = numbers.Max();\n        if (minValue == maxValue) {\n            return numbers.Select(v\
    \ => v / maxValue).ToList();\n        }\n        var slope = (maxValue - minValue)\
    \ / (numbers.Count - 1);\n        var scale = (maxValue - minValue) / minValue;\n\
    \        return numbers.Select(v => ((slope * (v - minValue) + minValue) * scale).ToSingle()).ToList();",
  "        double minimum = numbers.Min();\n        double maximum = numbers.Max();\n\
    \        if (maximum == minimum) {\n            return numbers;\n        }\n \
    \       var unit = Math.Sqrt(maximum * maximum - maximum * minimum + minimum *\
    \ minimum) / maximum;\n        return numbers.Select(x => (float) (x * unit)).ToList();",
  "        float largest = numbers.Max();\n        float smallest = numbers.Min();\n\
    \        foreach (float number in numbers) {\n            float scaled = (number\
    \ - smallest) / (largest - smallest);\n            numbers.Add(number * scaled);\n\
    \        }\n        return numbers;", "        // First, find out min and max\
    \ of the numbers\n        float minVal = numbers.Min();\n        float maxVal\
    \ = numbers.Max();\n\n        // Now, normalize the numbers\n        foreach (float\
    \ number in numbers)\n            number = (number - minVal) / (maxVal - minVal);\n\
    \n        // Return the new list of numbers\n        return new List<float>(numbers);",
  "        Debug.Assert(numbers.Count >= 2, \"Expected at least 2 numbers\");\n\n\
    \        List<float> scaledNumbers = new List<float>(numbers);\n        double\
    \ rangeMin = numbers.Min();\n        double rangeMax = numbers.Max();\n      \
    \  double rangeLength = rangeMax - rangeMin;\n        double minValue = rangeMin;\n\
    \        double maxValue = rangeMax;\n\n        for (int i = 0; i < scaledNumbers.Count;\
    \ i++) {\n            scaledNumbers[i] = scaledNumbers[i] - minValue * rangeLength;\n\
    \        }\n\n        for (int i = 0; i < scaledNumbers.Count; i++) {\n      \
    \      scaledNumbers[i] = scaledNumbers[i] / rangeLength;\n        }\n\n     \
    \   return scaledNumbers;", "        if (numbers.Count < 2) {\n            throw\
    \ new ArgumentException(\"At least two numbers required\");\n        }\n\n   \
    \     List<float> result = new List<float>();\n        float min = numbers.Min();\n\
    \        float max = numbers.Max();\n        if (min == max) {\n            result.Add(0.0f);\n\
    \        } else {\n            result.Add(1.0f / max - min);\n        }\n    \
    \    foreach (float number in numbers) {\n            result.Add(number * result.Last());\n\
    \        }\n\n        return result;", "        float min = numbers.Min();\n \
    \       float max = numbers.Max();\n        if (min > max) {\n            min\
    \ = 1.0f / (max + 1);\n        } else {\n            min = 1.0f / (min + 1);\n\
    \        }\n        List<float> scaled = new List<float>();\n        foreach (float\
    \ n in numbers) {\n            scaled.Add(n * min);\n        }\n        return\
    \ scaled;", "        if (numbers.Count == 0)\n            return numbers;\n  \
    \      var min = numbers.Min();\n        var max = numbers.Max();\n        var\
    \ range = max - min;\n        var scale = (float)range / numbers.Count;\n    \
    \    foreach (var number in numbers) {\n            number -= min;\n         \
    \   number *= scale;\n        }\n        return numbers;", "        List<float>\
    \ result = new List<float>(numbers);\n        double max = numbers.Max();\n  \
    \      double min = numbers.Min();\n        if (min == 0.0f) {\n            result.Add(0.0f);\n\
    \            return result;\n        }\n        double scale = 1.0f / Math.Max(max\
    \ - min, 1.0f);\n        foreach (float number in numbers) {\n            result.Add(number\
    \ * scale);\n        }\n        return result;", "        numbers.Sort();\n  \
    \      float smallest = numbers[0];\n        float largest = numbers[0];\n\n \
    \       foreach (float number in numbers) {\n            if (number < smallest)\
    \ {\n                smallest = number;\n            }\n            if (number\
    \ > largest) {\n                largest = number;\n            }\n        }\n\n\
    \        float scaling = smallest / largest;\n\n        List<float> result = new\
    \ List<float>();\n\n        foreach (float number in numbers) {\n            result.Add(number\
    \ * scaling);\n        }\n\n        return result;", "        float smallest =\
    \ Math.Min(numbers.Min(), numbers.Max());\n        float largest = Math.Max(numbers.Min(),\
    \ numbers.Max());\n        float range = largest - smallest;\n        float scale\
    \ = 1.0f / range;\n        List<float> result = new List<float>(numbers.Count);\n\
    \        foreach (float number in numbers) {\n            float resultNumber =\
    \ (number - smallest) * scale;\n            result.Add(resultNumber);\n      \
    \  }\n        return result;", "        if (numbers.Count < 2)\n            return\
    \ numbers;\n\n        // Convert to a list without repeating values\n        List<float>\
    \ list = new List<float>();\n        foreach (float number in numbers) {\n   \
    \         if (!list.Contains(number))\n                list.Add(number);\n   \
    \     }\n        numbers.Clear();\n\n        // Compute the sum using the list\
    \ as weights\n        float sum = list.Sum();\n        if (sum != 1.0f)\n    \
    \        throw new Exception(\"Sum of weights is not 1\");\n        List<float>\
    \ weights = new List<float>(list.Count);\n        foreach (float weight in list)\n\
    \            weights.Add(weight);\n\n        // Compute the product using the\
    \ list as weights\n        float product = weights.Aggregate((x, y) => x * y);\n\
    \n        // Compute the minimum value\n        float min = weights.Min();\n \
    \       if (min != 0.0f)\n            throw new Exception(\"Min of weights not\
    \ 0\");\n\n        // Compute the maximum value\n        float max = weights.Max();\n\
    \        if (max != 1.0f)\n            throw new Exception(\"Max of weights not\
    \ 1\");\n\n        // Compute the rescaled number\n        List<float> rescaled\
    \ = new List<float>(list.Count);\n        for (int i = 0; i < list.Count; i++)\n\
    \            rescaled.Add(product*((weights[i] - min)/(max - min)));\n\n     \
    \   // Revert to a list if required\n        if (rescaled is List<float>)\n  \
    \          return (List<float>)rescaled;\n        else\n            return rescaled.ToArray();",
  "        // Your code here\n        return numbers;", "        if (numbers.Count\
    \ < 2) throw new ArgumentException(\"Input must be a list of at least two elements.\"\
    );\n        float max = numbers.Max();\n        float min = numbers.Min();\n \
    \       float range = (max - min) * 0.5f;\n        float scale = (range == 0.0f\
    \ ? 0.0f : (1.0f / range));\n        List<float> scaledNumbers = numbers.Select(n\
    \ => n*scale).ToList();\n        List<float> newNumbers = new List<float>();\n\
    \        foreach (float n in scaledNumbers) {\n            if (n > max) throw\
    \ new ArgumentException(\"Input numbers must be less than or equal to the maximum\
    \ possible number.\");\n            if (n < min) throw new ArgumentException(\"\
    Input numbers must be greater than or equal to the minimum possible number.\"\
    );\n            newNumbers.Add(n);\n        }\n        return newNumbers;", " \
    \       if (numbers.Count == 0) throw new ArgumentException(\"No numbers given\"\
    );\n        float min = numbers.Min();\n        float max = numbers.Max();\n \
    \       float range = max - min;\n        if (range == 0) throw new ArgumentException(\"\
    No numbers given\");\n        if (min == max) return numbers;\n        List<float>\
    \ result = new List<float>(numbers);\n        result.Sort();\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            result[i] = numbers[i] - min;\n\
    \        }\n        if (range > 0)\n        {\n            result.Sort();\n  \
    \          for (int i = 0; i < numbers.Count; i++)\n            {\n          \
    \      if (result[i] < 0) result[i] = 0 - result[i];\n            }\n        }\n\
    \        else\n        {\n            result.Sort();\n            for (int i =\
    \ 0; i < numbers.Count; i++)\n            {\n                if (result[i] > 0)\
    \ result[i] = 1 - result[i];\n            }\n        }\n        return result;",
  "        if (numbers.Count == 0)\n            throw new ArgumentException(\"Cannot\
    \ rescale empty list\");\n\n        if (numbers.Count == 1)\n            return\
    \ numbers;\n\n        if (numbers[0] == 0.0f)\n            return numbers;\n\n\
    \        var minValue = numbers.Min();\n        var maxValue = numbers.Max();\n\
    \n        float scaleFactor = (maxValue - minValue) / (float)numbers.Count;\n\n\
    \        // TODO: Make this more efficient by using a binary search to find the\
    \ midpoint of the range\n        var midPoint = numbers.Count / 2;\n        var\
    \ result = new List<float>();\n        float value = 0.0f;\n        while (midPoint\
    \ < numbers.Count) {\n            value = minValue + midPoint * scaleFactor;\n\
    \            result.Add(value);\n            midPoint++;\n        }\n\n      \
    \  // Move the values back into the original order\n        int index = -1;\n\
    \        var reversedList = new List<float>();\n        foreach (float number\
    \ in result)\n        {\n            index = reversedList.BinarySearch(ref number);\n\
    \            if (index < 0)\n            {\n                reversedList.Add(number);\n\
    \            }\n            else\n            {\n                reversedList[index]\
    \ = number;\n            }\n        }\n\n        return reversedList;", "    \
    \    var max = numbers.Max();\n        var min = numbers.Min();\n        if (min\
    \ == 0) {\n            return numbers;\n        }\n        var newMin = min /\
    \ max;\n        var newMax = max / min;\n        var newList = new List<float>(numbers);\n\
    \        for (int i = 0; i < newList.Count; i++) {\n            newList[i] = (newList[i]\
    \ - min) * newMax + newMin;\n        }\n        return newList;", "        if\
    \ (numbers.Count < 2) throw new Exception(\"Need at least two numbers!\");\n \
    \       float min = numbers.Min();\n        float max = numbers.Max();\n     \
    \   float scale = 1.0f / Math.Max(max - min, float.Epsilon);\n        numbers.ForEach(number\
    \ => number = (number - min) * scale);\n        return numbers;", "        int\
    \ N = numbers.Count;\n        if (N < 2) return numbers;\n        float max =\
    \ numbers.Min();\n        float min = numbers.Max();\n        float range = max\
    \ - min;\n        if (range == 0)\n            return numbers;\n        float\
    \ scale = 1.0f / range;\n        List<float> results = new List<float>(N);\n \
    \       foreach (float num in numbers) {\n            results.Add(num * scale);\n\
    \        }\n        return results;", "        if (numbers.Count < 2)\n      \
    \      throw new ArgumentException(\"List must have at least two elements\");\n\
    \        int n = numbers.Count;\n        var result = new List<float>(new float[n]);\n\
    \        double sum = numbers.Sum();\n        for (int i = 0; i < n; ++i) {\n\
    \            float newVal = (float)i / (float)n;\n            int index = i;\n\
    \            while (newVal > 1)\n                index++;\n            result.SetValue(sum\
    \ * (newVal - 1), index);\n        }\n        return result;", "        // Make\
    \ sure there's at least one element\n        if (numbers.Count < 2) return numbers;\n\
    \        // Make sure that all numbers are greater than or equal to zero\n   \
    \     Debug.Assert(numbers.All((x) => x > 0));\n\n        float[] result = new\
    \ float[numbers.Count];\n        // The transform is scaled from -1 to 1\n   \
    \     float scale = 1.0f / Math.Max(numbers.Min(), numbers.Max());\n        //\
    \ This algorithm is identical to what was used in MatLab\n        for (int i =\
    \ 0; i < numbers.Count; i++) {\n            result[i] = numbers[i] * scale;\n\
    \        }\n        return new List<float>(result);", "        // Scale all numbers\
    \ to [0,1]\n        float min = numbers.Min();\n        float max = numbers.Max();\n\
    \        foreach (float f in numbers) {\n            f /= max - min;\n       \
    \ }\n\n        // Scale all numbers back to original scale\n        numbers.AddRange(Enumerable.Repeat(min,\
    \ numbers.Count).Select(x => (x-min)/(max-min)));\n\n        return numbers;",
  "        float minValue = numbers.Min();\n        float maxValue = numbers.Max();\n\
    \        float currentMinValue = minValue;\n        float currentMaxValue = maxValue;\n\
    \        List<float> transformedNumbers = new List<float>(numbers);\n        while\
    \ (currentMinValue == minValue) {\n            currentMinValue = 0;\n        \
    \    currentMaxValue = 1;\n        }\n        while (currentMaxValue == maxValue)\
    \ {\n            currentMaxValue = 1;\n            currentMinValue = 0;\n    \
    \    }\n        for (int i = 0; i < numbers.Count; i++) {\n            float currentNumber\
    \ = numbers[i];\n            float currentDiff = (currentNumber - currentMinValue)\
    \ / (currentMaxValue - currentMinValue);\n            if (currentDiff > 0) {\n\
    \                currentNumber = currentMinValue + (currentMaxValue - currentMinValue)\
    \ * currentDiff;\n            } else if (currentDiff < 0) {\n                currentNumber\
    \ = currentMaxValue + (currentMinValue - currentMaxValue) * (1 - currentDiff);\n\
    \            }\n            transformedNumbers[i] = currentNumber;\n        }\n\
    \        return transformedNumbers;", "        if (numbers.Count < 2) return numbers;\n\
    \        var min = numbers.Min();\n        var max = numbers.Max();\n        var\
    \ range = max - min;\n        var scale = 1;\n        if (range < 0) {\n     \
    \       scale = (float)Math.Pow(2.0, -(double)range);\n            scale = Math.Pow(scale,\
    \ (double)numbers.Count);\n        }\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            numbers[i] *= scale;\n        return numbers;", "        float[]\
    \ arr = numbers.ToArray();\n        var m1 = new float[arr.Length];\n        var\
    \ m2 = new float[arr.Length];\n        for(int i = 0; i < arr.Length; i++) {\n\
    \            m1[i] = arr[i];\n            m2[i] = 0.0f;\n        }\n        for(int\
    \ i = arr.Length - 1; i >= 0; i--) {\n            m2[i] = Math.Sqrt(m1[i]*m1[i]);\n\
    \        }\n        float[] resultArr = new float[arr.Length];\n        for(int\
    \ i = 0; i < arr.Length; i++) {\n            resultArr[i] = m1[i]/m2[i];\n   \
    \     }\n        return numbers = new List<float>(resultArr);", "        if (numbers\
    \ == null || numbers.Count < 2) {\n            return numbers;\n        }\n  \
    \      numbers.Sort(new Comparison<float>((x, y) => { return Math.Sign(x) * Math.Sign(y);\
    \ }));\n        if (numbers.Count == 2) {\n            if (Math.Abs(numbers[0]\
    \ - numbers[1]) <= 0.0001f) {\n                return numbers;\n            }\
    \ else {\n                List<float> output = new List<float>(numbers.Count);\n\
    \                output.Add(0f);\n                output.Add(1f);\n          \
    \      return output;\n            }\n        }\n        List<float> output =\
    \ new List<float>(numbers.Count);\n        output.Add(0f);\n        float last\
    \ = numbers.First();\n        float lastDiff = 1f - last;\n        float lastDiffSquared\
    \ = last * lastDiff;\n        float currentDiff = numbers.Last() - last;\n   \
    \     while (output.Count < numbers.Count) {\n            float difference = numbers.Last()\
    \ - currentDiff;\n            float newCurrent = last + lastDiff * difference;\n\
    \            if (newCurrent < last) {\n                // we've gone too far\n\
    \                return null;\n            }\n            last = newCurrent;\n\
    \            float newLastDiff = lastDiff - currentDiff * lastDiff;\n        \
    \    if (newLastDiff < 0f) {\n                // we've gone too far\n        \
    \        return null;\n            }\n            lastDiff = newLastDiff;\n  \
    \          output.Add(newCurrent);\n        }\n        return output;", "    \
    \    // Sum up the values\n        var totalSum = numbers.Sum();\n\n        //\
    \ Calculate the scale\n        var scale = 1.0f / (float)(totalSum);\n\n     \
    \   // Convert every number to a scale value that yields the smallest integer\
    \ value\n        var intValues = numbers.Select(n => (int)(n * scale)).ToArray();\n\
    \n        // Convert back to floats\n        var floatValues = intValues.Select(i\
    \ => (float)i).ToList();\n\n        return floatValues;", "        if (numbers.Count\
    \ < 2) {\n            throw new ArgumentException(\"List must have at least two\
    \ elements\");\n        }\n        var min = numbers.Min();\n        var max =\
    \ numbers.Max();\n        var delta = max - min;\n        if (delta == 0) {\n\
    \            return numbers;\n        }\n\n        // This ensures that delta\
    \ is representable\n        if (delta > 1) {\n            throw new ArgumentException(\"\
    Delta must be smaller than 1\");\n        }\n\n        var newList = new List<float>(numbers.Count);\n\
    \n        // Calculate new values\n        for (var i = 1; i < numbers.Count;\
    \ ++i) {\n            newList[i] += delta * numbers[i - 1];\n        }\n     \
    \   newList[0] = (float)0.0;\n        newList[newList.Count - 1] = (float)1.0;\n\
    \n        return newList;", "        if (numbers.Count == 0) {\n            return\
    \ new List<float>();\n        }\n        List<float> scaleFactors = new List<float>();\n\
    \        foreach (float number in numbers) {\n            scaleFactors.Add(Math.Pow(number,\
    \ 2));\n        }\n        float smallest = Math.Min(scaleFactors.Min(), scaleFactors.Max());\n\
    \        float largest = Math.Max(scaleFactors.Min(), scaleFactors.Max());\n \
    \       scaleFactors.Remove(largest);\n        scaleFactors.Remove(smallest);\n\
    \        scaleFactors.Add(1.0f);\n        scaleFactors.Add(0.0f);\n        foreach\
    \ (float number in scaleFactors) {\n            numbers.Add(number);\n       \
    \ }\n        return numbers;", "        if (numbers.Count < 2) return numbers;\n\
    \        var smallest = numbers.Min();\n        var largest = numbers.Max();\n\
    \        var factor = largest - smallest;\n        if (factor == 0.0) {\n    \
    \        var tmp = numbers[0];\n            numbers[0] = (smallest + largest)\
    \ / 2.0f;\n            numbers[1] = tmp;\n            numbers.RemoveAt(0);\n \
    \           return numbers;\n        }\n        var result = numbers.Select(x\
    \ => (x - smallest) * factor).ToList();\n        if (numbers.Count > 1) {\n  \
    \          Debug.Assert(numbers.First() != smallest && numbers.Last() != largest,\
    \ \"Numbers are not ordered correctly\");\n            result.Add(numbers.Last());\n\
    \        }\n        return result;", "        float minValue = numbers.Min();\n\
    \        float maxValue = numbers.Max();\n        numbers.ForEach(x => x = (x\
    \ - minValue) / (maxValue - minValue));\n        return numbers;", "        if\
    \ (numbers.Count < 2) return numbers;\n\n        List<float> result = new List<float>(numbers);\n\
    \n        float min = numbers.Min();\n        float max = numbers.Max();\n\n \
    \       // Scale all numbers to between 0.0 and 1.0\n        // >>> RescaleToUnit((new\
    \ List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f,\
    \ (float)5.0f})))\n        // (new List<float>(new float[]{(float)0.0f, (float)0.25f,\
    \ (float)0.5f, (float)0.75f, (float)1.0f}))\n        for (int i = 0; i < result.Count;\
    \ i++) {\n            result[i] = (float)(result[i] - min) / (max - min);\n  \
    \      }\n        // Return original list if all numbers are above 1.0\n     \
    \   if (numbers.All(x => x > 1.0f)) return numbers;\n\n        return result;",
  "        float min = numbers.Min();\n        float max = numbers.Max();\n      \
    \  List<float> newNumbers = new List<float>();\n        float range = max - min;\n\
    \        foreach (float number in numbers) {\n            newNumbers.Add(Math.Floor((number\
    \ - min) / range * 1.0f) * range + min);\n        }\n        return newNumbers;",
  "        var result = new List<float>();\n        numbers.Sort();\n        var min\
    \ = numbers.First();\n        var max = numbers.Last();\n        var delta = (max\
    \ - min) / (numbers.Count - 1);\n        foreach (var n in numbers) {\n      \
    \      result.Add((float)((n - min) / delta));\n        }\n        return result;",
  "        int min = numbers.Min();\n        int max = numbers.Max();\n        if\
    \ (max == min)\n            return numbers;\n        List<float> normalized =\
    \ new List<float>();\n        for (int i = 0; i < numbers.Count; i++)\n      \
    \      normalized.Add(numbers[i] - min) / (max - min);\n        return normalized;",
  "        double[] dataArray = numbers.Select(x => (double)x).ToArray();\n      \
    \  double[] result = new double[dataArray.Length];\n        for (int i = 0; i\
    \ < result.Length; i++) {\n            result[i] = dataArray[i] * ((double)dataArray.Length\
    \ - 1);\n        }\n        return new List<float>(result.ToArray());", "    \
    \    // Sort the numbers so that they are in ascending order\n        var sorted\
    \ = numbers.OrderBy(num => num);\n\n        // Find the smallest number\n    \
    \    var smallestNumber = sorted.First();\n        // Rescale all numbers so that\
    \ smallest number is 0, largest number is 1\n        sorted = sorted.Select(num\
    \ => MathHelper.Clamp(num, smallestNumber, 1.0f)).ToList();\n        return sorted;",
  "        float range = (float)Math.Max(numbers.Min(), numbers.Max());\n        float\
    \ range2 = (float)range / 2;\n        float range3 = (float)Math.Round(range2);\n\
    \        List<float> newNumbers = new List<float>(numbers.Count);\n        float\
    \ x = range3;\n        float sum = 0;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            sum += numbers[i];\n            newNumbers.Add(x);\n   \
    \         x += range3;\n        }\n        newNumbers.Add(range);\n        for\
    \ (int i = numbers.Count - 1; i >= 0; i--) {\n            newNumbers[i] = newNumbers[i]\
    \ / sum;\n        }\n        return newNumbers;", "        List<float> unit =\
    \ new List<float>(numbers);\n        unit.Remove(unit.Min());\n        unit.Remove(unit.Max());\n\
    \        unit.Remove(unit.First());\n        unit.Remove(unit.Last());\n     \
    \   unit.Remove(unit.Last());\n        unit.Insert(0, 0.0f);\n        unit.Insert(1,\
    \ 1.0f);\n        unit.Insert(unit.Count, 1.0f);\n        return unit;", "   \
    \     if (numbers == null || numbers.Count < 2)\n            throw new ArgumentException(\"\
    numbers is null/empty or has less than 2 elements\", \"numbers\");\n\n       \
    \ var max = numbers.Max();\n        var min = numbers.Min();\n\n        var scale\
    \ = (float)1.0f / (max - min);\n        foreach (var number in numbers) {\n  \
    \          number *= scale;\n        }\n        return numbers;", "        if\
    \ (numbers.Count == 0)\n            return new List<float>();\n        var min\
    \ = numbers.Min();\n        var max = numbers.Max();\n        var scaled = numbers.Select(x\
    \ => (float)(x - min) / (max - min)).ToList();\n        scaled.Insert(0, 0);\n\
    \        scaled.Add(1);\n        return scaled;", "        // The numbers are\
    \ in range 0 <= x <= 1, so find the maximum\n        float max = numbers.Max();\n\
    \        // Find the smallest number in the numbers\n        float min = numbers.Min();\n\
    \        // The range of possible outcomes is the range from 0 to max, scaled\
    \ to 0 to 1\n        float range = max - min;\n        // The scale factor is\
    \ the range / 1\n        float scale = range / 1.0f;\n        // Iterate over\
    \ the list with the linear transform\n        // The results will be in range\
    \ 0 to 1\n        foreach (float n in numbers) {\n            // The n is the\
    \ current number in the list, scale it\n            n -= min;\n            n *=\
    \ scale;\n            // Add the scaled number back to the list\n            numbers.Add(n);\n\
    \        }\n        // Return the new list with the numbers scaled\n        return\
    \ numbers;", "        var maxValue = numbers.Max();\n        var minValue = numbers.Min();\n\
    \n        Debug.Assert(maxValue != minValue);\n\n        // Normalize each number\
    \ to be between 0.0 and 1.0\n        for (int i = 0; i < numbers.Count; i++) {\n\
    \            numbers[i] /= maxValue - minValue;\n        }\n\n        // Divide\
    \ each number by 1.0 to shift it to be between 0.0 and 1.0\n        for (int i\
    \ = 0; i < numbers.Count; i++) {\n            numbers[i] /= 1.0f;\n        }\n\
    \n        // Rescale each number to be between 0.0 and 1.0\n        for (int i\
    \ = 0; i < numbers.Count; i++) {\n            numbers[i] *= maxValue;\n      \
    \  }\n\n        // Scale each number by 1.0 to shift it to be between 0.0 and\
    \ 1.0\n        for (int i = 0; i < numbers.Count; i++) {\n            numbers[i]\
    \ *= 1.0f;\n        }\n\n        return numbers;", "        int smallest = numbers.Min();\n\
    \        int largest = numbers.Max();\n        double length = numbers.Sum();\n\
    \        double rescaled = 1.0f / length;\n        List<float> result = new List<float>(numbers);\n\
    \        for (int i = 0; i < result.Count; i++)\n            result[i] = smallest\
    \ + (largest - smallest) * result[i] * rescaled;\n        return result;", " \
    \       float min = numbers.Min();\n        float max = numbers.Max();\n     \
    \   float scaledMin = (min == 0f ? 0f : min) / (max - min);\n        float scaledMax\
    \ = (max == 0f ? 0f : max) / (max - min);\n        numbers.ForEach(n => n *= scaledMax\
    \ - scaledMin);\n        numbers.ForEach(n => n += scaledMin);\n        return\
    \ numbers;", "        // Normalize all values to range [0,1]\n        numbers.ForEach(x\
    \ => x = (float)Math.Round((x - numbers.Min()) / (numbers.Max() - numbers.Min()),\
    \ 2));\n\n        // Scale all values to range [0,1]\n        numbers.ForEach(x\
    \ => (float)Math.Round((x - numbers.Min()) * (1f / (numbers.Max() - numbers.Min()))));\n\
    \n        // Return scaled values\n        return numbers;", "        var largest\
    \ = numbers.Max();\n        var smallest = numbers.Min();\n        if (smallest\
    \ == 0f) smallest = 1f;\n        if (largest == 1f) largest = 0f;\n        numbers.ForEach(n\
    \ => n /= (float)Math.Max(largest, smallest));\n        return numbers;", "  \
    \      List<float> scaledNumbers = numbers.Select(x => x).ToList();\n\n      \
    \  var minValue = numbers.Min();\n        var maxValue = numbers.Max();\n\n  \
    \      bool isSmallerThanZero = minValue < 0;\n        bool isGreaterThanOne =\
    \ maxValue > 1;\n\n        scaledNumbers.RemoveAll(x => x == 0);\n        scaledNumbers.RemoveAll(x\
    \ => x == 1);\n\n        if (isSmallerThanZero) {\n            if (isGreaterThanOne)\
    \ {\n                scaledNumbers.RemoveAll(x => x == -1);\n                scaledNumbers.RemoveAll(x\
    \ => x == 0);\n                scaledNumbers.RemoveAll(x => x == 1);\n       \
    \         scaledNumbers.RemoveAll(x => x == -1);\n            } else {\n     \
    \           scaledNumbers.RemoveAll(x => x == -1);\n                scaledNumbers.RemoveAll(x\
    \ => x == 0);\n                scaledNumbers.RemoveAll(x => x == 1);\n       \
    \     }\n        } else {\n            if (isGreaterThanOne) {\n             \
    \   scaledNumbers.RemoveAll(x => x == -1);\n                scaledNumbers.RemoveAll(x\
    \ => x == 1);\n                scaledNumbers.RemoveAll(x => x == 0);\n       \
    \     } else {\n                scaledNumbers.RemoveAll(x => x == -1);\n     \
    \           scaledNumbers.RemoveAll(x => x == 0);\n            }\n        }\n\n\
    \        return scaledNumbers;", "        // Return an empty list if there are\
    \ no numbers in the list\n        if (numbers.Count < 2)\n            return new\
    \ List<float>();\n\n        // Sort the list\n        numbers.Sort();\n\n    \
    \    // Calculate the scale factor and scale each number in the list\n       \
    \ double scaleFactor = numbers.Max() - numbers.Min();\n        List<float> result\
    \ = new List<float>(numbers.Count);\n        for (int i = 0; i < numbers.Count;\
    \ i++)\n            result.Add(numbers[i] * scaleFactor);\n\n        // Return\
    \ the result (if the list was long enough)\n        return result.Count >= 2 ?\
    \ result : new List<float>();", "        // For each number, find the minimum\
    \ and maximum value\n        double minValue = numbers.Min();\n        double\
    \ maxValue = numbers.Max();\n        // Divide the numbers by their range\n  \
    \      List<float> scaled = new List<float>(numbers.Count);\n        foreach (float\
    \ number in numbers) {\n            scaled.Add((number - minValue) / (maxValue\
    \ - minValue));\n        }\n        // Normalize the scaled list so that the smallest\
    \ number becomes 0\n        scaled.Sort();\n        double smallestNumber = scaled[0];\n\
    \        double largestNumber = scaled[scaled.Count - 1];\n        // Subtract\
    \ the smallest number from the scaled list\n        foreach (float number in scaled)\
    \ {\n            number -= smallestNumber;\n        }\n        // Add 1 to largest\
    \ number so that the largest number becomes 1\n        scaled.Add((largestNumber\
    \ - smallestNumber) + 1);\n        // Re-normalize the numbers to between 0 and\
    \ 1\n        foreach (float number in scaled) {\n            number *= (1.0f /\
    \ largestNumber);\n        }\n        return scaled;", "        var maxValue =\
    \ numbers.Max();\n        var minValue = numbers.Min();\n        Debug.Assert(maxValue\
    \ > minValue, \"All numbers must be positive\");\n        // Scale the numbers\
    \ to range [0, 1]\n        // Using floats would yield different results for different\
    \ precisions\n        var scaledNumbers = numbers.Select(x => (x - minValue) /\
    \ (maxValue - minValue)).ToArray();\n        var resultNumbers = new List<float>();\n\
    \        for (var i = 0; i < scaledNumbers.Length; i++) {\n            // For\
    \ each element in the list, multiply it by its respective position in the list\n\
    \            // i.e. if numbers is [10, 20, 30], each element would be multiplied\
    \ by 10, then 20, then 30\n            resultNumbers.Add(scaledNumbers[i] * numbers.Count\
    \ + minValue);\n        }\n        return resultNumbers;", "        float sum\
    \ = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n            sum +=\
    \ numbers[i];\n        }\n\n        numbers[0] = 0;\n        numbers[numbers.Count\
    \ - 1] = 1 / sum;\n\n        List<float> reordered = new List<float>();\n    \
    \    float sum2 = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n    \
    \        sum2 += numbers[i] * i;\n        }\n\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            numbers.RemoveAt(0);\n            reordered.Add(sum2 / sum);\n\
    \        }\n        numbers.AddRange(reordered);\n        return numbers;", " \
    \       if (numbers.Count < 2) {\n            throw new ArgumentOutOfRangeException(\"\
    numbers\", \"Number of numbers cannot be less than or equal to 2.\");\n      \
    \  }\n        float smallest = numbers[0];\n        float largest = numbers[0];\n\
    \        foreach (float n in numbers) {\n            if (n < smallest) {\n   \
    \             smallest = (float)n;\n            }\n            if (n > largest)\
    \ {\n                largest = (float)n;\n            }\n        }\n        float\
    \ scale = (largest-smallest) / (float)numbers.Count;\n        foreach (float n\
    \ in numbers) {\n            n -= smallest;\n            n *= scale;\n       \
    \     numbers.Add(n);\n        }\n        return numbers;", "        float minValue\
    \ = numbers.Min();\n        float maxValue = numbers.Max();\n        List<float>\
    \ scaledNumbers = new List<float>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            scaledNumbers.Add(numbers[i] * (maxValue - minValue) / (numbers.Count\
    \ - i));\n        }\n        float sum = scaledNumbers.Sum();\n        if (sum\
    \ < 0) scaledNumbers.Add(0f);\n        if (sum > 1) scaledNumbers.Add(1f);\n \
    \       return scaledNumbers;", "        if (numbers.Count == 0) return numbers;\n\
    \        if (numbers.Count < 2) return numbers;\n        float maxValue = numbers.Max();\n\
    \        float minValue = numbers.Min();\n        float unit = (maxValue - minValue)\
    \ / 2.0f;\n        if (maxValue > minValue) {\n            numbers.ForEach(x =>\
    \ x *= unit);\n            numbers.ForEach(x => (x - minValue) / maxValue);\n\
    \        }\n        else {\n            numbers.ForEach(x => x *= unit);\n   \
    \     }\n        return numbers;", "        if (numbers.Count < 2) {\n       \
    \     return numbers;\n        }\n        var min = numbers.Min();\n        var\
    \ max = numbers.Max();\n        if (min == max) {\n            return numbers;\n\
    \        }\n\n        // Scale to the range 0 to 1.\n        // If min is negative\
    \ and max is positive, then we want the largest value to be 1.\n        // If\
    \ max is negative and min is positive, then we want the smallest value to be 0.\n\
    \        // If the min and max values are the same, simply return the numbers\n\
    \        // See more here: https://en.wikipedia.org/wiki/Linear_transform\n  \
    \      // https://stackoverflow.com/questions/20849947/linq-min-max-on-a-list-of-floats\n\
    \        var scale = (max - min) / (float)0.9999f;\n        var adjust = (max\
    \ < 0) ? -1 : 1;\n        var result = (numbers.Select(x => ((float)(x - min)\
    \ * scale) + adjust).ToList());\n\n        // If the largest number is 0 then\
    \ we'll need to add 1 to the smallest number to ensure it becomes a non-negative\
    \ number.\n        if (result.Max() == 0) {\n            var m = result.Min();\n\
    \            result.Add((float)(((float)m + 1) / scale));\n        }\n       \
    \ return result;", "        List<float> result = new List<float>();\n        float\
    \ min = numbers.Min();\n        float max = numbers.Max();\n        float delta\
    \ = max - min;\n        foreach (float number in numbers) {\n            result.Add(number\
    \ - (float)(Math.Pow(delta, numbers.Count - 1) / Math.Pow(numbers.Count, numbers.Count\
    \ - 1)));\n        }\n        return result;", "        if (numbers.Count < 2)\
    \ {\n            throw new ArgumentException(\"You must enter at least one number.\"\
    , \"numbers\");\n        }\n        float largest = numbers.Max();\n        float\
    \ smallest = numbers.Min();\n        float scale = largest - smallest;\n     \
    \   float scale = Mathf.Clamp(scale, 0.0f, 1.0f);\n        return numbers.Select(n\
    \ => (float)((n - smallest) * scale)).ToList();", "        if (numbers.Count <=\
    \ 1) {\n            return numbers;\n        }\n        double maxValue = numbers.Max();\n\
    \        if (maxValue == 0) {\n            return numbers;\n        }\n      \
    \  double minValue = numbers.Min();\n        if (minValue == 0) {\n          \
    \  return numbers;\n        }\n        double range = maxValue - minValue;\n \
    \       if (range <= 0) {\n            return numbers;\n        }\n        double\
    \ scaledSize = range / numbers.Count;\n        var newList = new List<float>(numbers.Count);\n\
    \        foreach (var number in numbers) {\n            newList.Add((float)((number\
    \ - minValue) * scaledSize));\n        }\n        return newList;", "        var\
    \ smallest = numbers.Min();\n        var largest = numbers.Max();\n        float\
    \ scale = (float)(largest - smallest);\n        var scaledNumbers = numbers.Select(x\
    \ => (x - smallest) / scale).ToList();\n        var result = scaledNumbers.Select(x\
    \ => (int)(x * 100)).ToList();\n        return new List<float>(result);", "  \
    \      // Check if there's more than one element in the list\n        if (numbers.Count\
    \ < 2) throw new ArgumentException();\n        // Find the smallest and largest\
    \ numbers in that list\n        var minVal = numbers.Min();\n        var maxVal\
    \ = numbers.Max();\n        // Find the difference between them\n        var diff\
    \ = (maxVal - minVal);\n        // Find the scale that makes the smallest number\
    \ zero\n        var scale = (maxVal - minVal) / diff;\n        // Return the result\
    \ multiplied by that scale\n        return numbers.Select(x => (x - minVal) *\
    \ scale).ToList();", "        Debug.Assert(numbers.Count >= 2);\n        Debug.Assert(numbers.All(x\
    \ => x > 0 && x < 1));\n        // find smallest and largest in list\n       \
    \ float largest = numbers.Max();\n        float smallest = numbers.Min();\n\n\
    \        // apply transform to smallest and largest numbers\n        numbers.ForEach(x\
    \ => smallest = Math.Min(x, smallest));\n        numbers.ForEach(x => largest\
    \ = Math.Max(x, largest));\n        return numbers.Select(x => (x - smallest)\
    \ / (largest - smallest)).ToList();", "        if (numbers.Count == 0)\n     \
    \       return new List<float>();\n        if (numbers.Count < 2)\n          \
    \  throw new ArgumentException(\"The provided list of numbers must be of at least\
    \ two elements.\");\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        var min = min / numbers.Count;\n        var max = max * numbers.Count;\n\
    \        var results = new List<float>();\n        results.AddRange(numbers);\n\
    \        // Rescale\n        for (int i = 0; i < results.Count; i++) {\n     \
    \       results[i] = ((results[i] - min) / (max - min));\n        }\n        //\
    \ Normalize\n        var result = new List<float>();\n        int n = results.Count;\n\
    \        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum\
    \ += results[i];\n        }\n        for (int i = 0; i < n; i++) {\n         \
    \   results[i] = results[i] / sum;\n        }\n        // Rescale\n        for\
    \ (int i = 0; i < results.Count; i++) {\n            results[i] = ((results[i]\
    \ - min) / (max - min));\n        }\n        return results;", "        if (numbers.Count\
    \ < 2)\n            throw new ArgumentOutOfRangeException(\"numbers\");\n    \
    \    var min = numbers.Min();\n        var max = numbers.Max();\n        var range\
    \ = max - min;\n        foreach (var number in numbers)\n            number *=\
    \ range / numbers.Count;\n        return numbers;", "        if (numbers.Count\
    \ < 2) {\n            throw new ArgumentException(\"Cannot scale with fewer than\
    \ two elements\");\n        }\n        var largest = numbers.Max();\n        var\
    \ smallest = numbers.Min();\n        if (smallest == largest) {\n            //\
    \ no change\n            return numbers;\n        }\n        // calculate the\
    \ scale\n        float scale = 1.0f / (largest - smallest);\n        // apply\
    \ the scale\n        List<float> scaled = numbers.Select(x => x * (scale - 1.0f)).ToList();\n\
    \        // return the scaled list\n        return scaled;", "        Debug.Assert(numbers.Count\
    \ >= 2);\n        Debug.Assert(numbers.All(n => n >= 0));\n        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        var scale = (max - min) / numbers.Count;\n\
    \        var result = new List<float>(numbers);\n        for (var i = 0; i < numbers.Count;\
    \ i++)\n        {\n            result[i] = (numbers[i] - min) * scale;\n     \
    \   }\n        return result;", "        if (numbers.Count == 0) {\n         \
    \   return new List<float>();\n        }\n        if (numbers.Count == 1) {\n\
    \            return numbers.ToList();\n        }\n        float minValue = numbers.Min();\n\
    \        float maxValue = numbers.Max();\n        float range = (maxValue - minValue);\n\
    \        float scalingFactor = range / numbers.Count;\n        float scaledValue\
    \ = 0;\n        List<float> result = new List<float>();\n        foreach (float\
    \ number in numbers) {\n            scaledValue = number * scalingFactor;\n  \
    \          scaledValue += minValue;\n            result.Add(scaledValue);\n  \
    \      }\n        return result;", "        if (numbers.Count < 2) {\n       \
    \     return numbers;\n        }\n\n        var length = numbers.Count;\n    \
    \    var scale = 0;\n        var maxValue = numbers.Max();\n        var minValue\
    \ = numbers.Min();\n\n        var xScale = maxValue - minValue;\n        if (xScale\
    \ == 0) {\n            return numbers;\n        }\n\n        var yScale = 1;\n\
    \        for (; scale < 1; scale++) {\n            yScale = scale * (maxValue\
    \ - minValue);\n            if (yScale == 0) {\n                break;\n     \
    \       }\n        }\n\n        numbers.Clear();\n        numbers.AddRange(Enumerable.Repeat(\n\
    \            minValue + (xScale / yScale),\n            length)\n        );\n\n\
    \        return numbers;", "        if (numbers.Count < 2) {\n            return\
    \ numbers;\n        }\n\n        var sum = numbers.Sum();\n        var largest\
    \ = numbers.Max();\n        var smallest = numbers.Min();\n        var delta =\
    \ (largest - smallest) / (sum - 1);\n\n        var list = new List<float>();\n\
    \n        foreach (var n in numbers) {\n            list.Add((n - smallest) *\
    \ delta + smallest);\n        }\n\n        return list;", "        float min =\
    \ numbers.Min();\n        float max = numbers.Max();\n        float range = max\
    \ - min;\n\n        // Normalize numbers to range [0.0, 1.0]\n        numbers\
    \ = numbers.Select(n => (n - min) / range).ToList();\n\n        // Normalize numbers\
    \ to range [0.0, 1.0]\n        numbers = numbers.Select(n => n * 2.0f - 1.0f).ToList();\n\
    \n        return numbers;", "        Debug.Assert(numbers.Count >= 2, \"Not enough\
    \ numbers to scale\");\n        float min = numbers.Min();\n        float max\
    \ = numbers.Max();\n        // If the list is empty, return just the numbers as\
    \ they are\n        if (numbers.Count == 0)\n            return numbers.ToList();\n\
    \        // If the numbers are the same, return them unchanged\n        else if\
    \ (numbers.Count == 1)\n            return numbers;\n        // If the minimum\
    \ is greater than the maximum, then the smallest number is 0\n        else if\
    \ (min > max)\n            return numbers.Select(v => 0.0f).ToList();\n      \
    \  // If the maximum is greater than the minimum, then the largest number is 1\n\
    \        else if (max < min)\n            return numbers.Select(v => 1.0f).ToList();\n\
    \        // Otherwise calculate a range based on the minimum & maximum numbers\n\
    \        else\n        {\n            float range = max - min;\n            float\
    \ scale = (float)((float)(1f - range.Min() / range.Max()));\n            return\
    \ numbers.Select(v => (float)(((float)v - min) * scale)).ToList();\n        }",
  "        if (numbers == null || numbers.Count < 2) {\n            return null;\n\
    \        }\n        if (numbers.Count == 2) {\n            float low = numbers[0];\n\
    \            float high = numbers[1];\n            float min = low < 0 ? -high\
    \ : high;\n            float max = low < 0 ? high : -low;\n            float scaled\
    \ = (min - min) / (max - min);\n            numbers[0] = scaled;\n           \
    \ numbers[1] = scaled;\n            return numbers;\n        }\n        float\
    \ min = numbers.Min();\n        float max = numbers.Max();\n        float scaled\
    \ = (min - min) / (max - min);\n        numbers.ForEach(n => n = scaled);\n  \
    \      return numbers;", "        var sortedNumbers = new SortedSet<float>(numbers);\n\
    \        var normalizedNumbers = new List<float>(sortedNumbers.Count);\n     \
    \   foreach (var n in sortedNumbers) {\n            normalizedNumbers.Add(n /\
    \ sortedNumbers.Max());\n        }\n        return normalizedNumbers;", "    \
    \    // Transform from [0, 1) to [0, 1]\n        List<float> scaled = new List<float>(numbers.Count);\n\
    \        double min = numbers.Min();\n        double max = numbers.Max();\n  \
    \      for (int i = 0; i < numbers.Count; i++) {\n            scaled.Add(Convert.ToSingle(numbers[i])\
    \ * (max - min) / (max - min));\n        }\n        return scaled;", "       \
    \ float smallestElement = numbers.Min();\n        float largestElement = numbers.Max();\n\
    \        if (largestElement == 0) {\n            largestElement = 1f;\n      \
    \  }\n        // If all the numbers are greater than 0, then return the original\
    \ list\n        if (largestElement > 0) {\n            return numbers;\n     \
    \   }\n        // If all the numbers are negative then scale them so that the\
    \ largest is 0 and smallest is 1\n        if (smallestElement < 0) {\n       \
    \     List<float> scaledNumbers = new List<float>();\n            for (int i =\
    \ 0; i < numbers.Count; i++) {\n                scaledNumbers.Add(numbers[i] *\
    \ (float)(largestElement / smallestElement));\n            }\n            return\
    \ scaledNumbers;\n        }\n        // If the smallest is 0, the largest is 1,\
    \ then scale them so that the largest is 1 and smallest is 0\n        if (smallestElement\
    \ == 0) {\n            List<float> scaledNumbers = new List<float>();\n      \
    \      for (int i = 0; i < numbers.Count; i++) {\n                scaledNumbers.Add(numbers[i]\
    \ - 1f);\n            }\n            return scaledNumbers;\n        }\n      \
    \  // If the smallest is greater than 0, the largest is 0, then scale them so\
    \ that the largest is 0 and smallest is 1\n        if (smallestElement > largestElement)\
    \ {\n            List<float> scaledNumbers = new List<float>();\n            for\
    \ (int i = 0; i < numbers.Count; i++) {\n                scaledNumbers.Add(numbers[i]\
    \ * (float)(1 / smallestElement));\n            }\n            return scaledNumbers;\n\
    \        }\n        // If the smallest is less than 0, the largest is 0, then\
    \ scale them so that the largest is 1 and smallest is 0\n        if (smallestElement\
    \ < 0f) {\n            List<float> scaledNumbers = new List<float>();\n      \
    \      for (int i = 0; i < numbers.Count; i++) {\n                scaledNumbers.Add(1f\
    \ - numbers[i]);\n            }\n            return scaledNumbers;\n        }\n\
    \        // If the smallest is equal to 0, the largest is 1, then scale them so\
    \ that the largest is 1 and smallest is 0\n        if (smallestElement == 0f)\
    \ {\n            List<float> scaledNumbers = new List<float>();\n            for\
    \ (int i = 0; i < numbers.Count; i++) {\n                scaledNumbers.Add(numbers[i]);\n\
    \            }\n            return scaledNumbers;\n        }\n        List<float>\
    \ scaledNumbers = new List<float>();\n        // If the smallest is greater than\
    \ the largest, scale them so that the largest is 1 and smallest is 0\n       \
    \ if (smallestElement > largestElement) {\n            float scaledSmallestElement\
    \ = (float)(smallestElement / largestElement);\n            float scaledLargestElement\
    \ = 1f - scaledSmallestElement;\n            for (int i = 0; i < numbers.Count;\
    \ i++) {\n                scaledNumbers.Add((numbers[i] - scaledLargestElement)\
    \ * (float)(scaledSmallestElement));\n            }\n            return scaledNumber",
  "        if (numbers.Count < 2)\n            return numbers;\n        // Find the\
    \ min and max\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        // Normalize each number so that it's in the range 0 to 1\n        var\
    \ range = (max - min);\n        var normal = new List<float>(numbers);\n     \
    \   foreach (var number in normal)\n            number = (float)(number/range\
    \ * (float)1.0f);\n        // Rescale so that min is 0 and max is 1\n        var\
    \ scaled = normal.Select(n => (float)(n - min) / range * 1.0f).ToArray();\n  \
    \      normal.Clear();\n        normal.AddRange(scaled);\n        return normal;",
  "        Debug.Assert(numbers.Count > 2);\n        float minNumber = numbers.Min();\n\
    \        float maxNumber = numbers.Max();\n        if (maxNumber - minNumber <\
    \ 1e-5) {\n            return new List<float>(numbers);\n        }\n        //\
    \ Rescale from [0, 1] to [minNumber, maxNumber]\n        float delta = (maxNumber\
    \ - minNumber);\n        return numbers.Select(v => (v - minNumber) / delta).ToList();",
  "        Debug.Assert(numbers.Count >= 2);\n        var result = new List<float>();\n\
    \        var sum = numbers.Sum();\n        foreach (var value in numbers) {\n\
    \            result.Add(value / sum);\n        }\n        return result;", " \
    \       List<float> result = new List<float>();\n        int min = numbers.Min();\n\
    \        int max = numbers.Max();\n        if (min == max)\n        {\n      \
    \      foreach (float number in numbers)\n            {\n                result.Add(number);\n\
    \            }\n        }\n        else\n        {\n            float xMin = (float)Math.Floor(numbers.Min());\n\
    \            float xMax = (float)Math.Ceiling(numbers.Max());\n            float\
    \ yMin = (float)Math.Floor(min);\n            float yMax = (float)Math.Ceiling(max);\n\
    \            float d = (xMax - xMin) / (yMax - yMin);\n            int yMinInt\
    \ = (int)yMin;\n            int yMaxInt = (int)yMax;\n            int yIntDelta\
    \ = yMaxInt - yMinInt;\n            float yInt = yMinInt - (yInt / yIntDelta);\n\
    \            for (int i = 0; i < numbers.Count; i++)\n            {\n        \
    \        float number = numbers[i];\n                float xInt = xMin + ((float)i\
    \ * d);\n                float yInt = yMin + ((float)yInt * (number - xInt));\n\
    \                result.Add(yInt);\n            }\n        }\n        return result;",
  "        float smallestNumberToBecomeZero = numbers.Min();\n        float largestNumberToBecomeOne\
    \ = numbers.Max();\n        float scaleFactor = largestNumberToBecomeOne - smallestNumberToBecomeZero;\n\
    \        List<float> resultingNumbers = new List<float>(numbers);\n        double\
    \ resultingScaleFactor = Convert.ToDouble(resultingNumbers.Max() - resultingNumbers.Min());\n\
    \        if (resultingScaleFactor > 0.0f) {\n            resultingScaleFactor\
    \ /= 2.0f;\n        }\n        else {\n            resultingScaleFactor *= 2.0f;\n\
    \        }\n        resultingScaleFactor *= scaleFactor;\n        if (resultingScaleFactor\
    \ < 1.0f) {\n            for (int i = 0; i < resultingNumbers.Count; i++) {\n\
    \                resultingNumbers[i] += smallestNumberToBecomeZero;\n        \
    \    }\n        }\n        return resultingNumbers;", "        if (numbers.Count\
    \ == 0) throw new ArgumentException(\"List of numbers cannot be empty\");\n  \
    \      var min = numbers.Min();\n        var max = numbers.Max();\n        foreach\
    \ (var number in numbers)\n            number *= max - min;\n        numbers.RemoveAt(0);\n\
    \        numbers.Insert(0, min);\n        numbers.Add(max);\n        return numbers;",
  "        long count = numbers.Count;\n        float minimum = numbers.Min();\n \
    \       float maximum = numbers.Max();\n\n        List<float> result = new List<float>(count);\n\
    \        for (int i = 0; i < count; ++i) {\n            float number = numbers[i];\n\
    \            float scaled = (number - minimum) / (maximum - minimum);\n      \
    \      float scaled2 = scaled * scaled;\n            float scaled3 = scaled2 *\
    \ scaled;\n            float scaled4 = scaled3 * scaled;\n            result.Add(scaled4);\n\
    \        }\n\n        return result;", "        if (numbers.Count < 2) {\n   \
    \         return numbers;\n        }\n        var minValue = numbers.Min();\n\
    \        var maxValue = numbers.Max();\n        if (minValue == maxValue) {\n\
    \            // If the list is already in the proper range, return the original\n\
    \            return numbers;\n        }\n        var scaleFactor = (float)Math.Pow((float)maxValue\
    \ / (float)minValue, 0.5f);\n        var scaleFactorToNormalize = scaleFactor;\n\
    \        if (scaleFactor < 1.000001f) {\n            scaleFactorToNormalize =\
    \ 1.000001f;\n        }\n        // Normalize each number in the list to range\
    \ between 0 and 1\n        foreach (var number in numbers) {\n            number\
    \ /= scaleFactorToNormalize;\n        }\n        return numbers;", "        if\
    \ (numbers.Count < 2)\n            throw new ArgumentOutOfRangeException(\"numbers\"\
    );\n        if (numbers.Max() < 1 || numbers.Min() > 0)\n            throw new\
    \ ArgumentException(\"Only numbers between 0 and 1 allowed.\");\n\n        var\
    \ zeros = numbers.Where(n => n == 0).ToArray();\n        var ones = numbers.Where(n\
    \ => n == 1).ToArray();\n        var zeroIndex = zeros.SingleOrDefault();\n  \
    \      var oneIndex = ones.SingleOrDefault();\n\n        var zeroMinusOne = zeros.Where(n\
    \ => n == oneIndex).FirstOrDefault();\n\n        if (zeroMinusOne == null)\n \
    \           throw new InvalidOperationException(\"Zero minus one must be present!\"\
    );\n\n        zeros[zeroIndex] -= oneIndex;\n        ones[oneIndex] += zeroIndex;\n\
    \n        return numbers.Select((n, i) => n / ones[i]).ToList();", "        var\
    \ min = numbers.Min();\n        var max = numbers.Max();\n        // Rescale numbers\
    \ to the range [min, max]\n        var range = max - min;\n        foreach (var\
    \ number in numbers) {\n            number -= min;\n            number = number\
    \ * (range / numbers.Count) + min;\n        }\n        return numbers;"]
stop_tokens:
- "\n    }\n"
