name: HumanEval_153_Strongest_Extension
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You will be given the name of a class (a string) and a list\
  \ of extensions.\n    // The extensions are to be used to load additional classes\
  \ to the class. The\n    // strength of the extension is as follows: Let CAP be\
  \ the number of the uppercase\n    // letters in the extension's name, and let SM\
  \ be the number of lowercase letters \n    // in the extension's name, the strength\
  \ is given by the fraction CAP - SM. \n    // You should find the strongest extension\
  \ and return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
  \    // If there are two or more extensions with the same strength, you should\n\
  \    // choose the one that comes first in the list.\n    // For example, if you\
  \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
  \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
  \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n  \
  \  // Example:\n    // >>> StrongestExtension((\"my_class\"), (new List<string>(new\
  \ string[]{(string)\"AA\", (string)\"Be\", (string)\"CC\"})))\n    // (\"my_class.AA\"\
  )\n    public static string StrongestExtension(string class_name, List<string> extensions)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrongestExtension((\"\
  Watashi\"), (new List<string>(new string[]{(string)\"tEN\", (string)\"niNE\", (string)\"\
  eIGHt8OKe\"}))).Equals((\"Watashi.eIGHt8OKe\")));\n    Debug.Assert(StrongestExtension((\"\
  Boku123\"), (new List<string>(new string[]{(string)\"nani\", (string)\"NazeDa\"\
  , (string)\"YEs.WeCaNe\", (string)\"32145tggg\"}))).Equals((\"Boku123.YEs.WeCaNe\"\
  )));\n    Debug.Assert(StrongestExtension((\"__YESIMHERE\"), (new List<string>(new\
  \ string[]{(string)\"t\", (string)\"eMptY\", (string)\"nothing\", (string)\"zeR00\"\
  , (string)\"NuLl__\", (string)\"123NoooneB321\"}))).Equals((\"__YESIMHERE.NuLl__\"\
  )));\n    Debug.Assert(StrongestExtension((\"K\"), (new List<string>(new string[]{(string)\"\
  Ta\", (string)\"TAR\", (string)\"t234An\", (string)\"cosSo\"}))).Equals((\"K.TAR\"\
  )));\n    Debug.Assert(StrongestExtension((\"__HAHA\"), (new List<string>(new string[]{(string)\"\
  Tab\", (string)\"123\", (string)\"781345\", (string)\"-_-\"}))).Equals((\"__HAHA.123\"\
  )));\n    Debug.Assert(StrongestExtension((\"YameRore\"), (new List<string>(new\
  \ string[]{(string)\"HhAas\", (string)\"okIWILL123\", (string)\"WorkOut\", (string)\"\
  Fails\", (string)\"-_-\"}))).Equals((\"YameRore.okIWILL123\")));\n    Debug.Assert(StrongestExtension((\"\
  finNNalLLly\"), (new List<string>(new string[]{(string)\"Die\", (string)\"NowW\"\
  , (string)\"Wow\", (string)\"WoW\"}))).Equals((\"finNNalLLly.WoW\")));\n    Debug.Assert(StrongestExtension((\"\
  _\"), (new List<string>(new string[]{(string)\"Bb\", (string)\"91245\"}))).Equals((\"\
  _.Bb\")));\n    Debug.Assert(StrongestExtension((\"Sp\"), (new List<string>(new\
  \ string[]{(string)\"671235\", (string)\"Bb\"}))).Equals((\"Sp.671235\")));\n  \
  \  }\n\n}\n"
completions: ["        string extension = extensions.OrderByDescending(e => e.ToUpperInvariant().Count()\
    \ - e.ToLowerInvariant().Count()).FirstOrDefault();\n        return class_name\
    \ + extension;", "        // This code takes the class name and a list of extensions\
    \ and returns the class\n        // name with the strongest extension.\n     \
    \   // Extensions is in the format: [extension_name1, extension_name2, ...]\n\
    \        string extension_with_strength = null;\n        foreach (var extension\
    \ in extensions) {\n            int extension_strength = 0;\n            int extension_cap\
    \ = 0;\n            int extension_sm = 0;\n            bool is_uppercase = false;\n\
    \            bool is_lowercase = false;\n            foreach (char c in extension)\
    \ {\n                if (Char.IsUpper(c)) {\n                    is_uppercase\
    \ = true;\n                    extension_strength++;\n                    extension_cap++;\n\
    \                }\n                if (Char.IsLower(c)) {\n                 \
    \   is_lowercase = true;\n                    extension_strength++;\n        \
    \            extension_sm++;\n                }\n            }\n            if\
    \ (extension_strength >= extension_cap) {\n                extension_with_strength\
    \ = class_name + extension;\n            }\n        }\n        if (extension_with_strength\
    \ != null) {\n            return extension_with_strength;\n        }\n       \
    \ else {\n            Console.WriteLine(\"No extensions found\");\n          \
    \  return \"\";\n        }", "        char[] cap = new char[class_name.Length];\n\
    \        int sm = 0;\n        foreach (string e in extensions) {\n           \
    \ cap = e.ToCharArray();\n            sm = cap.Count(s => (int)char.IsUpper(s))\
    \ - (int)char.IsLower(s);\n        }\n        List<char> results = new List<char>();\n\
    \        for (int i = 0; i < class_name.Length; i++) {\n            char ch =\
    \ class_name[i];\n            bool upper = char.IsUpper(ch);\n            bool\
    \ lower = char.IsLower(ch);\n            if (upper != lower)\n               \
    \ if (sm * 2 > cap.Count(s => s == ch))\n                    results.Add(ch);\n\
    \            else if (upper)\n                results.Add(ch);\n            else\n\
    \                results.Add(char.ToLower(ch));\n        }\n        if (results.Count\
    \ > 1)\n            return class_name + \".\" + results.GetValueOrDefault(1).ToString();\n\
    \        else\n            return class_name;", "        int highest = 0;\n  \
    \      string strongest = \"\";\n        foreach (string ext in extensions) {\n\
    \            int counter = ext.Count(x => x == class_name.Substring(0, 1));\n\
    \            int sm = ext.Count(x => x == class_name.Substring(0, 2));\n     \
    \       int strength = (counter - sm) / (counter / 2);\n            if (strength\
    \ > highest) {\n                highest = strength;\n                strongest\
    \ = ext;\n            }\n        }\n        return class_name + \".\" + strongest;",
  "        string strongest_extension = string.Empty;\n        double strongest_extension_strength\
    \ = double.MaxValue;\n\n        for (int i = 0; i < extensions.Count; i++) {\n\
    \            string extension = extensions[i];\n\n            double extension_strength\
    \ = GetExtensionStrength(extension);\n            if (extension_strength > strongest_extension_strength)\
    \ {\n                strongest_extension_strength = extension_strength;\n    \
    \            strongest_extension = extension;\n            }\n        }\n\n  \
    \      return string.Concat(class_name, \".\", strongest_extension);", "     \
    \   string extension_names = \"\";\n        List<string> result = new List<string>();\n\
    \        Dictionary<string, int> dictionary = new Dictionary<string, int>();\n\
    \        foreach (string extension in extensions) {\n            int index = extension.IndexOf('\
    \ ');\n            if (index > 0) {\n                string name = extension.Substring(0,\
    \ index);\n                string substr = extension.Substring(index + 1);\n \
    \               dictionary.Add(name, 0);\n                dictionary.Add(name,\
    \ dictionary.Last().Value);\n            }\n        }\n        foreach (KeyValuePair<string,\
    \ int> pair in dictionary) {\n            string key = pair.Key;\n           \
    \ int value = pair.Value;\n            if (key.Length > extension_names.Length)\
    \ {\n                extension_names = key;\n            }\n            else if\
    \ (value >= 0) {\n                result.Add(key + \".\" + extension_names);\n\
    \            }\n        }\n        if (result.Count > 1) {\n            return\
    \ result.OrderBy(x => x).First();\n        }\n        return class_name + \".\"\
    \ + extension_names;", "        var strongest_extension = extensions[0];\n   \
    \     var strength = extensions[0].Length - extensions[1].Length;\n\n        foreach\
    \ (string extension in extensions) {\n            var length = extension.Length\
    \ - extension.Replace(\"A\", \"\").Replace(\"B\", \"\").Replace(\"C\", \"\").Replace(\"\
    D\", \"\").Replace(\"E\", \"\").Replace(\"F\", \"\").Replace(\"G\", \"\").Replace(\"\
    H\", \"\").Replace(\"I\", \"\").Replace(\"J\", \"\").Replace(\"K\", \"\").Replace(\"\
    L\", \"\").Replace(\"M\", \"\").Replace(\"N\", \"\").Replace(\"O\", \"\").Replace(\"\
    P\", \"\").Replace(\"Q\", \"\").Replace(\"R\", \"\").Replace(\"S\", \"\").Replace(\"\
    T\", \"\").Replace(\"U\", \"\").Replace(\"V\", \"\").Replace(\"W\", \"\").Replace(\"\
    X\", \"\").Replace(\"Y\", \"\").Replace(\"Z\", \"\").Length;\n            strength\
    \ = strength - (length - extension.Replace(\"A\", \"\").Replace(\"B\", \"\").Replace(\"\
    C\", \"\").Replace(\"D\", \"\").Replace(\"E\", \"\").Replace(\"F\", \"\").Replace(\"\
    G\", \"\").Replace(\"H\", \"\").Replace(\"I\", \"\").Replace(\"J\", \"\").Replace(\"\
    K\", \"\").Replace(\"L\", \"\").Replace(\"M\", \"\").Replace(\"N\", \"\").Replace(\"\
    O\", \"\").Replace(\"P\", \"\").Replace(\"Q\", \"\").Replace(\"R\", \"\").Replace(\"\
    S\", \"\").Replace(\"T\", \"\").Replace(\"U\", \"\").Replace(\"V\", \"\").Replace(\"\
    W\", \"\").Replace(\"X\", \"\").Replace(\"Y\", \"\").Replace(\"Z\", \"\").Length);\n\
    \            if (strength > strongest_extension.Length)\n            {\n     \
    \           strongest_extension = extension;\n                strength = strength\
    \ - strongest_extension.Length;\n            }\n        }\n\n        return string.Format(\"\
    {0}.{1}\", class_name, strongest_extension);", "        int capital = 0;\n   \
    \     int lowercase = 0;\n        int strongest = 0;\n        string extension\
    \ = null;\n        foreach (string extension in extensions) {\n            capital\
    \ = (capital + extension.Count(x => x.ToUpper() == extension)).ToString();\n \
    \           lowercase = (lowercase + extension.Count(x => x.ToLower() == extension)).ToString();\n\
    \            if (capital == lowercase.ToString() && lowercase == extension.Length)\
    \ {\n                strongest = (strongest + extension.Count(x => x.ToUpper()\
    \ != extension)).ToString();\n            }\n        }\n        if (capital ==\
    \ lowercase.ToString() && lowercase == extension.Length) {\n            strongest\
    \ = (strongest + extension.Count(x => x.ToUpper() != extension)).ToString();\n\
    \        }\n        if (strongest.Equals(\"0\")) {\n            return class_name\
    \ + \"0\";\n        }\n        if (strongest.Equals(\"1\")) {\n            return\
    \ class_name + \"1\";\n        }\n        if (strongest.Equals(\"2\")) {\n   \
    \         return class_name + \"2\";\n        }\n        if (strongest.Equals(\"\
    3\")) {\n            return class_name + \"3\";\n        }\n        if (strongest.Equals(\"\
    4\")) {\n            return class_name + \"4\";\n        }\n        if (strongest.Equals(\"\
    5\")) {\n            return class_name + \"5\";\n        }\n        if (strongest.Equals(\"\
    6\")) {\n            return class_name + \"6\";\n        }\n        if (strongest.Equals(\"\
    7\")) {\n            return class_name + \"7\";\n        }\n        if (strongest.Equals(\"\
    8\")) {\n            return class_name + \"8\";\n        }\n        if (strongest.Equals(\"\
    9\")) {\n            return class_name + \"9\";\n        }\n        if (strongest.Equals(\"\
    10\")) {\n            return class_name + \"10\";\n        }\n        return class_name\
    \ + strongest.ToString();", "        // Write your code here\n        int cap\
    \ = 0;\n        int sm = 0;\n        for (int i = 0; i < extensions.Count; i++)\n\
    \        {\n            cap += extensions[i].Count(c => c >= 'A' && c <= 'Z');\n\
    \            sm += extensions[i].Count(c => c >= 'a' && c <= 'z');\n        }\n\
    \        return class_name + extensions[extensions.Count(s => s.Count(c => c >=\
    \ 'A' && c <= 'Z') == cap) - extensions.Count(s => s.Count(c => c >= 'a' && c\
    \ <= 'z') == sm).ToString();", "        if (extensions == null)\n            throw\
    \ new ArgumentNullException();\n        if (extensions == new List<string>())\n\
    \            return \"\";\n        int cap_ext = extensions.Count(x => x == class_name.Substring(class_name.Length\
    \ - 1, 1).ToUpper());\n        int sm_ext = extensions.Count(x => x == class_name.Substring(0,\
    \ class_name.Length - 1).ToLower());\n        int strength = cap_ext - sm_ext;\n\
    \        extensions.Sort();\n        extensions.Reverse();\n        var extension\
    \ = extensions.FirstOrDefault(x => x.Equals(class_name + extensions[extensions.IndexOf(x)\
    \ - 1]));\n        if (extension != null)\n            return class_name + extension;\n\
    \        return StrongestExtension(class_name, new List<string>(extensions.Skip(extensions.IndexOf(extension)).Take(extensions.Count()\
    \ - 1)));", "        int cap = class_name.ToUpper().Count;\n        int sm = class_name.ToLower().Count;\n\
    \        if (cap - sm < 0)\n            return class_name + \".???\";\n      \
    \  else\n            return class_name + \".\" + extensions.OrderBy(x => GetStrongest(x)).FirstOrDefault();",
  "        var x = class_name.Length;\n        var y = extensions.Count();\n     \
    \   var z = x + y;\n        var n = Convert.ToInt32((z - z % x) / y);\n      \
    \  var i = 0;\n        var max_extension = extensions.OrderByDescending(e => e.Length).FirstOrDefault();\n\
    \        foreach (var e in extensions) {\n            if (max_extension.Length\
    \ == e.Length) {\n                i = 1;\n                break;\n           \
    \ }\n        }\n        return $\"{class_name}._{max_extension.Substring(x, i)}\"\
    ;", "        int min = 0;\n        int max = 0;\n        string extension_name\
    \ = \"\";\n\n        foreach (string s in extensions) {\n            int a = s.Count(x\
    \ => char.IsUpper(x));\n            int b = s.Count(x => char.IsLower(x));\n \
    \           double strength = a / (double)a + b / (double)b;\n            if (strength\
    \ > max) {\n                max = strength;\n                extension_name =\
    \ s;\n            }\n            if (strength < min) {\n                min =\
    \ strength;\n            }\n        }\n        if (max <= 0) {\n            return\
    \ \"\";\n        }\n        if (min >= max) {\n            throw new Exception(\"\
    There is more than 1 extension with the same strength\");\n        }\n       \
    \ int c = extension_name.Count(x => char.IsUpper(x));\n        int d = extension_name.Count(x\
    \ => char.IsLower(x));\n        int e = Math.Min(c > d ? c : d, max);\n      \
    \  return class_name + extension_name[0] + extension_name[e - 1];", "        Debug.Assert(extensions.Count\
    \ > 0);\n        Debug.Assert(extensions.Count(e => e.Any(ch => char.IsUpper(ch))\
    \ != 0); // extension.Count\n        Debug.Assert(extensions.Count(e => e.Count(ch\
    \ => char.IsLower) != 0); // extension.Count\n        int sm = extensions.Count(e\
    \ => e.Count(ch => char.IsLower)); // extension.Count\n        int cap = extensions.Count(e\
    \ => e.Count(ch => char.IsUpper)); // extension.Count\n        double strength\
    \ = 0;\n        double fraction = cap / sm;\n        for (int i = 1; i < extensions.Count;\
    \ i++) {\n            Debug.Assert(extensions[i].All(ch => char.IsUpper(ch)) ==\
    \ true); // extension.Count\n            Debug.Assert(extensions[i].All(ch =>\
    \ char.IsLower(ch)) == true); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsUpper) == cap - sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.IsLower) == sm); // extension.Count\n            Debug.Assert(extensions[i].Count(ch\
    \ => char.", "        // Write your code here\n        string strongest_extension\
    \ = \"\";\n        for (int i = 0; i < extensions.Count; i++)\n        {\n   \
    \         string extension = extensions[i];\n            int count = extension.Count(x\
    \ => char.IsUpper(x));\n            int count1 = extension.Count(x => char.IsLower(x));\n\
    \            double value = ((double)count - count1) / 2;\n            if (value\
    \ > 0)\n            {\n                strongest_extension = class_name + \"_\"\
    \ + extension;\n                break;\n            }\n            else\n    \
    \        {\n                strongest_extension = class_name;\n              \
    \  break;\n            }\n        }\n        return strongest_extension;", " \
    \       Dictionary<string, int> dic = new Dictionary<string, int>();\n       \
    \ foreach(string ext in extensions) {\n            int temp = 0;\n           \
    \ for(int i = 0; i < ext.Length; i++) {\n                if(ext[i] >= 'A' && ext[i]\
    \ <= 'Z') {\n                    temp++;\n                } else if(ext[i] >=\
    \ 'a' && ext[i] <= 'z') {\n                    temp--;\n                }\n  \
    \          }\n            if(temp > 0) {\n                dic.Add(ext, temp);\n\
    \            }\n        }\n        int max_strength = 0;\n        string strongest_extension\
    \ = null;\n        foreach(KeyValuePair<string, int> extension in dic) {\n   \
    \         if(max_strength < extension.Value) {\n                max_strength =\
    \ extension.Value;\n                strongest_extension = extension.Key;\n   \
    \         }\n        }\n        return class_name + \".\" + strongest_extension;",
  "        // Your code here\n        string extension = extensions[0];\n        string\
    \ highest = extensions[0];\n        for (int i = 1; i < extensions.Count; i++)\
    \ {\n            string extension_temp = extensions[i];\n            int strength\
    \ = GetStrongestExtension(extension_temp);\n            if (strength > highest)\
    \ {\n                highest = extension_temp;\n            }\n        }\n   \
    \     return class_name + highest;", "        int cap_ext = class_name.ToUpper().ToCharArray().Count(c\
    \ => char.IsUpper(c));\n        int sm_ext = class_name.ToLower().ToCharArray().Count(c\
    \ => char.IsLower(c));\n        if (cap_ext > sm_ext)\n            return class_name\
    \ + extensions[0];\n        else if (cap_ext < sm_ext)\n            return class_name\
    \ + extensions[1];\n        else\n            return class_name + extensions[2];",
  "        Debug.Assert(extensions != null);\n        if (extensions.Count == 0)\n\
    \            return class_name;\n\n        Dictionary<string, int> extension_strength\
    \ = new Dictionary<string, int>();\n        foreach (string extension in extensions)\n\
    \            extension_strength[extension] = 1;\n\n        int total_extension_strength\
    \ = 0;\n        foreach (string extension in extensions)\n            total_extension_strength\
    \ += extension_strength[extension];\n\n        // Sort the extensions in ascending\
    \ order by strength\n        extension_strength.Values.Sort();\n\n        bool\
    \ is_strongest = false;\n        int best_strength = -1;\n        string best_extension\
    \ = null;\n        foreach (string extension in extension_strength.Keys) {\n \
    \           if (best_strength == -1 || extension_strength[extension] > best_strength)\
    \ {\n                best_strength = extension_strength[extension];\n        \
    \        best_extension = extension;\n            }\n            if (extension_strength[extension]\
    \ == best_strength) {\n                extension_strength[extension] = -1;\n \
    \           }\n        }\n\n        // Make sure that we only use extensions that\
    \ had no more strength than the\n        // class itself\n        foreach (string\
    \ extension in extension_strength.Keys) {\n            if (extension_strength[extension]\
    \ != -1) {\n                if (total_extension_strength == extension_strength[extension])\
    \ {\n                    is_strongest = false;\n                    break;\n \
    \               }\n                else {\n                    is_strongest =\
    \ true;\n                    break;\n                }\n            }\n      \
    \  }\n\n        // Return the class name followed by the best extension\n    \
    \    return class_name + best_extension;", "        Dictionary<string, int> extension_strengths\
    \ = extensions.GroupBy(e => e.ToLowerInvariant()).ToDictionary(g => g.Key, g =>\
    \ g.Count());\n        int max_strength = extension_strengths.Max(kv => kv.Value);\n\
    \        var result = class_name;\n        if (max_strength > 0)\n           \
    \ result += \".\" + extension_strengths.First(kv => kv.Value == max_strength).Key;\n\
    \        return result;", "        if (extensions.Count() == 0) return class_name;\n\
    \        List<string> classes = new List<string>();\n        classes.Add(class_name);\n\
    \        foreach (string extension in extensions) {\n            int index = 0;\n\
    \            int SM = 0;\n            while (true) {\n                index++;\n\
    \                string extension_name = class_name + extension.Substring(index,\
    \ extension.Length - index);\n                int CAP = (int)extension_name.Substring(0,\
    \ extension_name.Length - 1).Count(' ');\n                int SM = (int)extension_name.Substring(0,\
    \ extension_name.Length - 1).Replace(\"_\", \"\").Count(' ');\n              \
    \  if (CAP == SM) return extension_name;\n                if (CAP > SM) break;\n\
    \            }\n            classes.Add(extension);\n        }\n        if (classes.Count()\
    \ == 1) return classes[0];\n        int max_strength = -1;\n        string max_extension\
    \ = \"\";\n        foreach (string extension in extensions) {\n            string\
    \ extension_name = class_name + extension;\n            int CAP = (int)extension_name.Substring(0,\
    \ extension_name.Length - 1).Count(' ');\n            int SM = (int)extension_name.Substring(0,\
    \ extension_name.Length - 1).Replace(\"_\", \"\").Count(' ');\n            if\
    \ (CAP == SM) continue;\n            if (CAP > max_strength) {\n             \
    \   max_strength = CAP;\n                max_extension = extension;\n        \
    \    }\n        }\n        return max_extension;", "        HashSet<string> names\
    \ = new HashSet<string>(extensions);\n        double strongest_extension = double.MaxValue;\n\
    \        foreach (string extension in extensions) {\n            int count = (class_name.Count(i\
    \ => i.Equals('A', i))) + (class_name.Count(i => i.Equals('B', i))) + (class_name.Count(i\
    \ => i.Equals('C', i))) - (class_name.Count(i => i.Equals('a', i)));\n       \
    \     int sm = (class_name.Count(i => i.Equals('a', i))) + (class_name.Count(i\
    \ => i.Equals('b', i))) + (class_name.Count(i => i.Equals('c', i)));\n       \
    \     double fraction = count / sm;\n            strongest_extension = Math.Max(strongest_extension,\
    \ fraction);\n        }\n        string name = null;\n        if (strongest_extension\
    \ == double.MaxValue) {\n            foreach (string extension in extensions)\
    \ {\n                name = (class_name + extension).TrimEnd('.');\n         \
    \       if (names.Contains(name)) {\n                    name = null;\n      \
    \              break;\n                }\n            }\n        }\n        return\
    \ name ?? \"\";", "        Debug.Assert(class_name != null);\n        Debug.Assert(extensions\
    \ != null);\n        Debug.Assert(extensions != null && extensions.Count > 0);\n\
    \        Debug.Assert(class_name.Length > 0);\n        \n        string result\
    \ = \"class \" + class_name + \" {\";\n        foreach (string extension in extensions)\
    \ {\n            int SM = extension.Count(x => x == char.ToUpper(x));\n      \
    \      int CAP = extension.Count(x => x == char.ToUpper(x));\n            double\
    \ strength = CAP - SM;\n            if (strength > 0) {\n                if (result\
    \ != \"\") result += \"\\n\";\n                result += extension + \": \" +\
    \ strength;\n            }\n        }\n        return result + \"}\";", "    \
    \    if (extensions.Count == 0) return \"\";\n        if (extensions.Count <=\
    \ 1) return class_name + \".\" + extensions[0];\n        var map = extensions.Select(e\
    \ => new {\n            e = e,\n            i = extensions.IndexOf(e)\n      \
    \  }).ToDictionary(e => e.e, e => e.i);\n        var min = extensions.Select(e\
    \ => map.ContainsKey(e) ? map[e] : -1).Min();\n        var max = extensions.Select(e\
    \ => map.ContainsKey(e) ? map[e] : -1).Max();\n        string res = \"\";\n  \
    \      for (int i = min; i <= max; i++) {\n            int j = i;\n          \
    \  while (j != 0) {\n                if (map.ContainsKey(j))\n               \
    \     j--;\n                else\n                    break;\n            }\n\
    \            if (j > i)\n                res = class_name + \".\" + extensions[j];\n\
    \        }\n        return res;", "        List<string> strongest = extensions.Where(x\
    \ => x.ToUpper().Count() < x.ToLower().Count()).ToList();\n        if (strongest.Count\
    \ > 0) strongest = extensions.OrderByDescending(x => x.ToUpper().Count() - x.ToLower().Count()).First();\n\
    \        return string.Format(\"{0}.{1}\", class_name, strongest);", "       \
    \ // Your code goes here\n        string result1 = String.Empty;\n        int\
    \ strength1 = -1;\n        string result2 = String.Empty;\n        int strength2\
    \ = -1;\n        string result3 = String.Empty;\n        int strength3 = -1;\n\
    \        string result4 = String.Empty;\n        int strength4 = -1;\n       \
    \ string result5 = String.Empty;\n        int strength5 = -1;\n        foreach\
    \ (string x in extensions)\n        {\n            if (x.Count(Char.IsUpper) >=\
    \ x.Count(Char.IsLower))\n            {\n                strength1 = x.Count(Char.IsUpper)\
    \ - x.Count(Char.IsLower);\n                if (strength1 >= strength2 && strength1\
    \ >= strength3)\n                {\n                    result2 = x;\n       \
    \             strength2 = strength1;\n                }\n                if (strength2\
    \ >= strength3 && strength2 >= strength4)\n                {\n               \
    \     result3 = x;\n                    strength3 = strength2;\n             \
    \   }\n                if (strength3 >= strength4 && strength3 >= strength5)\n\
    \                {\n                    result4 = x;\n                    strength4\
    \ = strength3;\n                }\n                if (strength4 >= strength5)\n\
    \                {\n                    result5 = x;\n                    strength5\
    \ = strength4;\n                }\n            }\n        }\n\n        return\
    \ result1 + result2 + result3 + result4 + result5;", "        if (extensions.Count\
    \ == 0) throw new ArgumentException(\"No extensions are given!\");\n\n       \
    \ // This dictionary will hold the extensions and their strength.\n        Dictionary<string,\
    \ int> extension_strength = new Dictionary<string, int>();\n\n        // Add the\
    \ extensions given to the dictionary.\n        foreach (string extension in extensions)\
    \ {\n            // Capital letters.\n            int capitals = 0;\n        \
    \    foreach (char c in extension) {\n                if (char.IsUpper(c)) capitals++;\n\
    \            }\n\n            // Small letters.\n            int smalls = 0;\n\
    \            foreach (char c in extension) {\n                if (char.IsLower(c))\
    \ smalls++;\n            }\n\n            // Calculate the strength of the extension.\n\
    \            int extension_strength = (smalls / extension.Length) - capitals;\n\
    \n            if (extension_strength >= 0) extension_strength.Add(extension, extension_strength);\n\
    \        }\n\n        // Find the strongest extension.\n        string strongest_extension\
    \ = null;\n        foreach (string extension in extension_strength.Keys) {\n \
    \           if (extension_strength[extension] == extension_strength.Values.Max())\n\
    \                strongest_extension = extension;\n        }\n\n        // Return\
    \ the class name + the strongest extension.\n        return class_name + \".\"\
    \ + strongest_extension;", "        // Initialize your variables here\n      \
    \  int SM = extensions.Count;\n        string strongest_extension;\n        int\
    \ CAP = 0;\n        foreach(string extension in extensions) {\n            CAP\
    \ += extension.Count(x => Char.IsUpper(x));\n        }\n        strongest_extension\
    \ = class_name + (extensions[0].Substring(CAP - SM, SM));\n        return strongest_extension;",
  "        var totals = extensions.Select(x => (new Regex(x.ToUpper() + @\"\\..*\"\
    ).Matches(class_name).Count)).Sum();\n        int total = 0;\n        foreach\
    \ (var item in totals) {\n            total += item;\n        }\n        int cap\
    \ = total;\n        var sorted = extensions.OrderBy(x => x.ToUpper() + @\"\\..*\"\
    ).Select(x => x.ToUpper() + @\"\\..*\").Distinct().Take(extensions);\n       \
    \ var list = new List<string>();\n        foreach (var item in sorted) {\n   \
    \         list.Add(item + (totals - list.Count(x => (new Regex(x + @\"\\..*\"\
    ).Matches(class_name).Count))));\n        }\n        var result = class_name +\
    \ \".\" + list.FirstOrDefault(x => list.All(y => new Regex(y + @\"\\..*\").Matches(x).Count\
    \ < list.All(z => new Regex(x + @\"\\..*\").Matches(y).Count))).ToUpper();\n \
    \       return result;", "        Dictionary<string, int> strongest_extension\
    \ = new Dictionary<string, int>();\n        foreach (string extension in extensions)\
    \ {\n            if (class_name.Contains(extension)) {\n                if (extension.ToLower().Contains(\"\
    s\"))\n                    strongest_extension.Add(extension.Substring(0,1).ToUpper(),\
    \ extension.Substring(1, 2).Length);\n                else if (extension.ToLower().Contains(\"\
    c\"))\n                    strongest_extension.Add(extension.Substring(0,1).ToUpper(),\
    \ extension.Substring(1, 1).Length);\n                else if (extension.ToLower().Contains(\"\
    h\"))\n                    strongest_extension.Add(extension.Substring(0,1).ToUpper(),\
    \ extension.Substring(1, 1).Length);\n                else\n                 \
    \   strongest_extension.Add(extension.Substring(0,1).ToUpper(), extension.Substring(1,\
    \ 1).Length);\n            }\n        }\n        int maximum = 0;\n        foreach\
    \ (KeyValuePair<string, int> strongest_extension_pair in strongest_extension)\
    \ {\n            if (strongest_extension_pair.Value > maximum) {\n           \
    \     maximum = strongest_extension_pair.Value;\n                strongest_extension\
    \ = strongest_extension_pair.Key;\n            }\n        }\n        return class_name\
    \ + \".\" + strongest_extension;", "        var extension = new Dictionary<int,\
    \ string>();\n        foreach (var extension_name in extensions) {\n         \
    \   string temp_name = extension_name;\n            int temp_strength = 0;\n \
    \           var temp = temp_name.Split(' ');\n            temp_strength = temp.Count(x\
    \ => char.IsUpper(x)) - (temp.Count(x => char.IsLower(x)));\n            extension.Add(temp_strength,\
    \ temp_name);\n        }\n        var extension_map = extension.OrderByDescending(x\
    \ => x.Key).FirstOrDefault();\n        return class_name + extension_map.Value;",
  "        Debug.WriteLine(\"Starting...\");\n        string extension_name = extensions[0];\n\
    \        int extension_cap = extension_cap(extension_name);\n        int extension_strength\
    \ = extension_strength(extension_cap);\n        Debug.WriteLine(\"extension_cap:\"\
    \ + extension_cap);\n        Debug.WriteLine(\"extension_strength:\" + extension_strength);\n\
    \        if (extension_strength != -1) {\n            string extension_class =\
    \ extension_class_with_strength(class_name, extension_cap, extension_strength);\n\
    \            return extension_class.Replace(\".\", \"\") + extension_name.Replace(\"\
    .\", \"\");\n        }\n        else {\n            string extension_class = extension_class_with_strength(class_name,\
    \ extension_cap, extension_strength);\n            return extension_class.Replace(\"\
    .\", \"\") + extension_name;\n        }", "        Dictionary<int, string> strongest\
    \ = new Dictionary<int, string>();\n        foreach (string extension in extensions)\
    \ {\n            int index = 0;\n            while (index < extension.Length)\
    \ {\n                string temp = extension.Substring(0, index);\n          \
    \      int c = 0;\n                for (int i = 0; i < temp.Length; i++) {\n \
    \                   if (temp.ToCharArray()[i].ToString() == temp.ToCharArray()[i].ToString().ToUpper())\
    \ {\n                        c++;\n                    }\n                }\n\
    \                string key = c + \"-\" + temp;\n                if (!strongest.ContainsKey(c))\
    \ {\n                    strongest.Add(c, temp);\n                }\n        \
    \        index = index + 1;\n            }\n        }\n        string strongest_key\
    \ = \"\";\n        int max_key = int.MaxValue;\n        foreach (KeyValuePair<int,\
    \ string> entry in strongest) {\n            if (entry.Value > max_key) {\n  \
    \              max_key = entry.Value;\n                strongest_key = entry.Key;\n\
    \            }\n        }\n        return class_name + \".\" + strongest_key;",
  "        // Your code here\n        int total = 0;\n        Dictionary<string, int>\
    \ d = new Dictionary<string, int>();\n        foreach (string e in extensions)\
    \ {\n            int count = class_name.Count(c => c == e.ToUpper()) - class_name.Count(c\
    \ => c == e.ToLower());\n            if (d.ContainsKey(e) && d[e] < count) {\n\
    \                d[e] = count;\n            }\n            else {\n          \
    \      d.Add(e, count);\n            }\n        }\n        string strongest =\
    \ \"\";\n        int max = d.Max(x => x.Value);\n        foreach (string e in\
    \ d) {\n            if (d[e] == max) {\n                strongest = e + \".\"\
    ;\n                break;\n            }\n        }\n        return class_name\
    \ + strongest;", "        string extension_name = \"\";\n        string extension_strength\
    \ = \"\";\n        foreach (string extension in extensions)\n        {\n     \
    \       string first_letter = extension.Substring(0, 1);\n            string second_letter\
    \ = extension.Substring(1, 1);\n            int CAP = class_name.ToUpperInvariant().Count(x\
    \ => x == first_letter);\n            int SM = class_name.ToLowerInvariant().Count(x\
    \ => x == second_letter);\n            decimal strength = (decimal)CAP / SM;\n\
    \            if (strength > extension_strength)\n            {\n             \
    \   extension_name = extension;\n                extension_strength = strength;\n\
    \            }\n        }\n        return class_name + extension_name + \".\"\
    \ + extension_strength;", "        // Write your code here.\n        int len =\
    \ class_name.Length;\n        string ext = string.Empty;\n        string strongest\
    \ = string.Empty;\n        int sm = 0;\n        for (int i = 0; i < extensions.Count;\
    \ i++) {\n            if (extensions[i].Count(c => c==c[0]) >= len) {\n      \
    \          sm = extensions[i].Count(c => c <= class_name[0])-extensions[i].Count(c\
    \ => c > class_name[0]);\n                if (sm > 0) {\n                    if\
    \ (sm == 1) {\n                        ext = \".\" + extensions[i].Substring(0,\
    \ extensions[i].Length-1);\n                    } else {\n                   \
    \     ext = extensions[i].Substring(0, extensions[i].Length-1) + extensions[i].Substring(extensions[i].Length\
    \ - 1);\n                    }\n                }\n                if (sm == 0)\
    \ {\n                    strongest = extensions[i];\n                }\n     \
    \       }\n        }\n        if (strongest.Length == 0) strongest = class_name;\n\
    \        if (strongest.Length == class_name) return strongest;\n        else return\
    \ class_name + \".\" + strongest;", "        // Your code goes here\n        int\
    \ sm=0;\n        int cap=0;\n        List<string> list1 = new List<string>();\n\
    \        List<string> list2 = new List<string>();\n        for (int i = 0; i <\
    \ extensions.Count; i++) {\n            char ch = extensions[i].ToUpper().First();\n\
    \            if (ch>90)\n            {\n                if (ch>90)\n         \
    \       {\n                    list1.Add(extensions[i]);\n                }\n\
    \                else\n                {\n                    list2.Add(extensions[i]);\n\
    \                }\n            }\n        }\n        foreach (string e in list1)\n\
    \        {\n            sm+=e.Count(char.IsUpper);\n            cap+=e.Count(char.IsUpper)-e.Count(char.IsLower);\n\
    \        }\n        foreach (string e in list2)\n        {\n            sm+=e.Count(char.IsUpper);\n\
    \            cap+=e.Count(char.IsUpper)-e.Count(char.IsLower);\n        }\n  \
    \      if (cap<sm)\n        {\n            return class_name + \".\" + list1[list1.IndexOf(list1.OrderByDescending(a\
    \ => a).First())].ToUpper().First();\n        }\n        else\n        {\n   \
    \         return class_name + \".\" + list2[list2.IndexOf(list2.OrderByDescending(a\
    \ => a).First())].ToUpper().First();\n        }", "        // TODO: Complete this\
    \ method\n        var strongest_extension = \"\";\n\n        // TODO: Complete\
    \ this method\n        var extension_strength = new List<int>();\n        foreach\
    \ (var extension in extensions)\n        {\n            var number_of_upper =\
    \ extension.Count(c => c==char.ToUpper(c));\n            var number_of_lower =\
    \ extension.Count(c => c==char.ToLower(c));\n            var strength = (number_of_upper-number_of_lower)/2;\n\
    \            extension_strength.Add(strength);\n        }\n        extension_strength.Sort();\n\
    \        var index_of_max_strength = extension_strength.Count - 1;\n        strongest_extension\
    \ = class_name + \".\" + extensions[index_of_max_strength];\n        return strongest_extension;",
  "        // Your code here\n        var result = \"\";\n        var extension_strength\
    \ = new Dictionary<string, int>();\n        var extension_cap = new Dictionary<string,\
    \ int>();\n        var extension_sm = new Dictionary<string, int>();\n\n     \
    \   foreach (var item in extensions) {\n            var s = item.ToUpper();\n\
    \            extension_cap.Add(s, 0);\n            extension_strength.Add(s, 0);\n\
    \            extension_sm.Add(s, 0);\n        }\n\n        foreach (var item in\
    \ extensions) {\n            var s = item.ToUpper();\n            extension_cap[s]\
    \ += 1;\n            extension_strength[s] += 1;\n            extension_sm[s]\
    \ += 1;\n        }\n        var max_key = extension_strength.Keys.Max();\n\n \
    \       if (extension_strength[max_key] == 0)\n            return \"\";\n\n  \
    \      foreach (var item in extension_cap.Keys)\n            if (extension_strength[item]\
    \ == extension_strength[max_key])\n                result = result + class_name\
    \ + \".\" + item;\n                \n        return result;", "        int num\
    \ = 0;\n        int sm = 0;\n        foreach (string ext in extensions)\n    \
    \    {\n            num = ext.ToUpper().Length;\n            sm = ext.ToLower().Length;\n\
    \            float f = (float)num/(float)sm;\n            if (f > 0)\n       \
    \     {\n                return class_name + \".\" + ext.ToUpper();\n        \
    \    }\n        }\n        throw new ArgumentException(\"No strongest extension\
    \ found\");", "        string answer = \"\";\n        ArrayList ExtensionsHash\
    \ = new ArrayList();\n\n        foreach (string extension in extensions) {\n \
    \           string lowercase_extension = extension.ToLower();\n            string\
    \ uppercase_extension = extension.ToUpper();\n            int lowercase_hash =\
    \ GetHash(lowercase_extension);\n            int uppercase_hash = GetHash(uppercase_extension);\n\
    \            int hash = (lowercase_hash + uppercase_hash);\n            ExtensionsHash.Add(hash);\n\
    \        }\n\n        foreach (string hash in ExtensionsHash) {\n            string\
    \ class_name_hash = class_name + \".\" + hash;\n            int index = ExtensionsHash.IndexOf(hash);\n\
    \            if (index < 0) continue;\n            string ExtensionsString = class_name_hash;\n\
    \            string extension_string = ExtensionsString[index].ToString();\n\n\
    \            int strength = GetStrength(extension_string);\n            if (strength\
    \ != -1) {\n                answer = extension_string;\n            }\n      \
    \  }\n\n        return answer;", "        int SM = extensions.Count(c => c >=\
    \ 'a' && c <= 'z');\n        int CAP = extensions.Count(c => c >= 'A' && c <=\
    \ 'Z');\n        return class_name + extensions.Min(s => s.Count(c => c >= 'a'\
    \ && c <= 'z') - SM + CAP) + extensions.Min(s => s.Count(c => c >= 'A' && c <=\
    \ 'Z') - SM + CAP);", "        Debug.Assert(extensions != null && class_name !=\
    \ null);\n        string first_extension = extensions.FirstOrDefault();\n    \
    \    string strongest_extension = first_extension;\n        double strongest_extension_strength\
    \ = first_extension.Length / class_name.Length;\n        foreach (string extension\
    \ in extensions) {\n            double extension_strength = extension.Length /\
    \ class_name.Length;\n            if (extension_strength > strongest_extension_strength)\
    \ {\n                strongest_extension = extension;\n                strongest_extension_strength\
    \ = extension_strength;\n            }\n        }\n        return class_name +\
    \ \".\" + strongest_extension;", "        Dictionary<string, int> strongest_extensions\
    \ = new Dictionary<string, int>();\n        foreach (string extension in extensions)\
    \ {\n            int length = extension.Length;\n            string extension_name\
    \ = extension.Replace(\"_\", \"\").ToLower();\n            int count = 0;\n  \
    \          char letter = '\\0';\n            string new_extension_name =\"\";\n\
    \            for (int i = 0; i < length; i++){\n                letter = extension[i];\n\
    \                if (letter == char.ToUpper(letter)){\n                    count++;\n\
    \                }\n                else {\n                    if (count == 0)\n\
    \                    {\n                        new_extension_name += letter;\n\
    \                    }\n                    else\n                    {\n    \
    \                    new_extension_name += letter;\n                        count--;\n\
    \                    }\n                }\n            }\n            strongest_extensions.Add(new_extension_name,\
    \ 0);\n        }\n        var extension_strengths = strongest_extensions.OrderByDescending(s\
    \ => s.Value).ToList();\n        foreach (var extension_strength in extension_strengths)\n\
    \        {\n            if (class_name.ToLower() == extension_strength.Key.Replace(\"\
    _\", \"\").ToLower())\n            {\n                return class_name + \".\"\
    \ + extension_strength.Key;\n            }\n        }\n        return class_name\
    \ + \".\" + \"A\";", "        var capitals = new List<int>();\n        var lowercases\
    \ = new List<int>();\n        var extensions_arr = extensions.ToArray();\n   \
    \     foreach (var extension in extensions_arr) {\n            var extension_array\
    \ = extension.ToArray();\n            foreach (var extension_letter in extension_array)\
    \ {\n                var c = extension_letter;\n                if (char.IsUpper(extension_letter))\
    \ {\n                    capitals.Add(c.GetHashCode());\n                } else\
    \ {\n                    lowercases.Add(c.GetHashCode());\n                }\n\
    \            }\n        }\n        var capitals_array = capitals.ToArray();\n\
    \        var lowercases_array = lowercases.ToArray();\n        var total_capitals\
    \ = capitals.Sum();\n        var total_lowercases = lowercases.Sum();\n      \
    \  var strength = (total_capitals - total_lowercases) * .5;\n        var best_extension\
    \ = null;\n        foreach (var extension in extensions_arr) {\n            var\
    \ extension_array = extension.ToArray();\n            foreach (var extension_letter\
    \ in extension_array) {\n                var c = extension_letter;\n         \
    \       if (char.IsUpper(extension_letter)) {\n                    if (capitals.Contains(c.GetHashCode()))\
    \ {\n                        break;\n                    }\n                }\
    \ else {\n                    if (lowercases.Contains(c.GetHashCode())) {\n  \
    \                      break;\n                    }\n                }\n    \
    \        }\n            var strength_of_extension = extension_array.Length - lowercases.Count\
    \ - capitals.Count;\n            if (best_extension == null || best_extension.Length\
    \ > strength_of_extension) {\n                best_extension = extension;\n  \
    \              Console.WriteLine(\"{0}, {1}\", class_name, extension);\n     \
    \       }\n        }\n        return best_extension;", "        var extension\
    \ = extensions.OrderBy(s => s.ToUpperInvariant()).ThenBy(s => s.ToLowerInvariant()).FirstOrDefault();\n\
    \        if (extension == null) return null;\n        return class_name + extension.Substring(class_name.Length\
    \ - extension.Length);", "        var strongest = Enumerable.Range(0, extensions.Count).Select(i\
    \ => new { Extension = extensions[i], Strength = (double)extensions[i].Length\
    \ - class_name.Length })\n            .OrderByDescending(o => o.Strength)\n  \
    \          .First();\n        return string.Format(\"{0}.{1}\", class_name, strongest.Extension);",
  "        int a=0;\n        foreach (var extension in extensions) {\n           \
    \ a = a + (extension.Length - extension.ToLowerInvariant().Count());\n       \
    \ }\n        int b=0;\n        foreach (var extension in extensions) {\n     \
    \       b = b + (extension.ToLowerInvariant().Count() - extension.Length);\n \
    \       }\n        int c=(a-b)/a;\n        if (c>0) {\n            string max1=class_name;\n\
    \            string max2=class_name;\n            for (int i = 0; i < extensions.Count;\
    \ i++) {\n                string extension = extensions[i];\n                string\
    \ lower = extension.ToLowerInvariant();\n                int count = 1;\n    \
    \            int newCount = 0;\n                for (int j = 0; j < lower.Length;\
    \ j++) {\n                    if (lower[j] == 'a') {\n                       \
    \ count++;\n                    } else if (lower[j] == 'z') {\n              \
    \          count--;\n                    } else {\n                        break;\n\
    \                    }\n                    newCount = newCount + count;\n   \
    \                 if (newCount == c) {\n                        count = 1;\n \
    \                       newCount = 0;\n                        break;\n      \
    \              }\n                }\n                if (newCount == c) {\n  \
    \                  string new1 = class_name + \"_\" + extension.ToLowerInvariant();\n\
    \                    string new2 = class_name + \"_\" + extension.ToLowerInvariant()\
    \ + \"_s\";\n                    if (extension.ToLowerInvariant().Length < extension.Length)\
    \ {\n                        new1 = new1 + \"_\" + extension.ToLowerInvariant();\n\
    \                        new2 = new2 + \"_s\";\n                    }\n      \
    \              if (new1 < max1) {\n                        max1 = new1;\n    \
    \                }\n                    if (new2 < max2) {\n                 \
    \       max2 = new2;\n                    }\n                }\n            }\n\
    \            if (max1 < max2) {\n                return max1;\n            } else\
    \ {\n                return max2;\n            }\n        }\n        return class_name;",
  "        char[] cap = class_name.ToCharArray();\n        char[] sm = class_name.ToCharArray();\n\
    \        int cap_sum = 0;\n        int sm_sum = 0;\n        for (int i = 0; i\
    \ < cap.Length; i++) {\n            cap_sum += cap[i] >= 'A' ? cap[i] - 'A' :\
    \ cap[i] - 'a';\n        }\n        for (int i = 0; i < sm.Length; i++) {\n  \
    \          sm_sum += sm[i] >= 'a' ? sm[i] - 'a' : sm[i] - 'A';\n        }\n  \
    \      int strength = cap_sum - sm_sum;\n        extensions.Sort();\n        for\
    \ (int i = 0; i < extensions.Count; i++) {\n            if (extensions[i] < class_name)\
    \ {\n                strength++;\n            }\n            if (extensions[i]\
    \ > class_name) {\n                break;\n            }\n        }\n        string\
    \ strongest_extension = class_name + extensions.First(e => e < class_name).ToString()\
    \ + extensions.ElementAtOrDefault(extensions.IndexOf(class_name));\n        if\
    \ (extensions.Count > 1) {\n            for (int i = 0; i < extensions.Count;\
    \ i++) {\n                if (extensions.ElementAtOrDefault(extensions.IndexOf(strongest_extension))\
    \ == class_name) {\n                    strongest_extension = class_name + extensions.ElementAt(i).ToString()\
    \ + extensions.ElementAtOrDefault(extensions.IndexOf(strongest_extension)) + extensions.ElementAtOrDefault(extensions.IndexOf(class_name));\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return strongest_extension;", "        // Get the extensions' counts\n \
    \       var cap_count = extensions.Count(a => a.ToUpper().Count(b => b == 'A'));\n\
    \        var sm_count = extensions.Count(a => a.ToLower().Count(b => b == 'a'));\n\
    \n        // Calculate the strength\n        var strength = (float) cap_count\
    \ / (float) sm_count;\n        // Get the extensions with the greatest strength\n\
    \        return extensions.OrderByDescending(a => strength).First();", "     \
    \   var strongest_extension = extensions.ToDictionary(ext => ext).First();\n \
    \       foreach (string extension in extensions.Where(ext => ext.StartsWith(strongest_extension)).OrderBy(ext\
    \ => ext).ToList()) {\n            if (strongest_extension.Contains(extension))\
    \ {\n                strongest_extension = extension;\n            }\n       \
    \ }\n        return class_name + \".\" + strongest_extension;", "        int max\
    \ = 0;\n        foreach (string extension in extensions) {\n            int capital\
    \ = 0;\n            int lowercase = 0;\n            foreach (char c in extension.ToLower())\
    \ {\n                if (char.IsUpper(c)) capital++;\n                else lowercase++;\n\
    \            }\n            int streng = (capital - lowercase);\n            if\
    \ (max < streng)\n                max = streng;\n        }\n        return class_name\
    \ + extensions.FirstOrDefault(e => e.ToLower().Contains(max));", "        double\
    \ max_score = 0;\n        foreach(var extension in extensions) {\n           \
    \ var score = GetStrength(extension);\n            if (score > max_score) {\n\
    \                max_score = score;\n            }\n        }\n        return\
    \ class_name + extensions[extensions.IndexOf(extensions[extensions.FindIndex(x\
    \ => x == max_score)])];", "        var class_name_with_extensions = class_name\
    \ + \".\";\n        var extensions_with_strength = extensions \n            .Select(x\
    \ => x.ToUpperInvariant())\n            .Select(x => x.ToLowerInvariant())\n \
    \           .OrderByDescending(x => x.Count());\n        var highest_strength\
    \ = extensions_with_strength.First();\n        return class_name_with_extensions\
    \ + highest_strength;", "        // Your code here\n        string strongest =\
    \ string.Empty;\n        for (int i = 0; i < extensions.Count; i++) {\n      \
    \      int letterCount = class_name.Count(x => x == extensions[i].ToUpper());\n\
    \            int lowerCaseLetterCount = class_name.Count(x => x == extensions[i].ToLower());\n\
    \            int letterDiff = letterCount - lowerCaseLetterCount;\n          \
    \  strongest = extensions[i];\n            if (letterDiff > 0 && i != extensions.Count\
    \ - 1) {\n                int difference = letterCount - lowerCaseLetterCount;\n\
    \                int nextLetterDiff = difference + letterDiff;\n             \
    \   if (nextLetterDiff > 0 && (extensions.Count - i) == 0) {\n               \
    \     difference = letterCount - lowerCaseLetterCount;\n                }\n  \
    \              if (difference > 0 && i != extensions.Count - 1) {\n          \
    \          int nextDifference = difference + letterDiff;\n                   \
    \ if (nextDifference > 0 && (extensions.Count - i) == 0) {\n                 \
    \       difference = letterCount - lowerCaseLetterCount;\n                   \
    \ }\n                    if (difference == nextDifference && i != extensions.Count\
    \ - 1) {\n                        int nextDifference = difference + letterDiff;\n\
    \                        if (nextDifference > 0 && (extensions.Count - i) == 0)\
    \ {\n                            difference = letterCount - lowerCaseLetterCount;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        return strongest;", "        var maxStrength = new\
    \ List<int>();\n        var bestExtension = String.Empty;\n        foreach (var\
    \ ext in extensions) {\n            var className = String.Join(\".\", class_name.Split('.').Take(extension.Length\
    \ - 1).ToArray());\n            var strength = GetStrength(ext, className);\n\
    \            maxStrength.Add(strength);\n            if (strength > maxStrength.Max())\
    \ bestExtension = ext;\n        }\n        return String.Format(\"{0}.{1}\", class_name,\
    \ bestExtension);", "        int ca, sm;\n        string c;\n        foreach (string\
    \ s in extensions) {\n            ca = s.Count(c => char.IsUpper(c)); \n     \
    \       sm = s.Count(c => char.IsLower(c));\n            if (ca > sm) {\n    \
    \            c = s;\n            } else if (sm > ca) {\n                c = s;\n\
    \            }\n        }\n        if (c != class_name) {\n            throw new\
    \ Exception(\"Error\");\n        }\n        return c.Substring(class_name.Length\
    \ + 1);", "        // Add your code here\n        Dictionary<int, string> dic\
    \ = new Dictionary<int, string>();\n        foreach (string ext in extensions)\n\
    \        {\n            var n = ext.Count(x => x.Equals('A')) + ext.Count(x =>\
    \ x.Equals('a')) + ext.Count(x => x.Equals('C')) + ext.Count(x => x.Equals('c'));\n\
    \            var m = ext.Count(x => x.Equals('B')) + ext.Count(x => x.Equals('b'))\
    \ + ext.Count(x => x.Equals('e')) + ext.Count(x => x.Equals('E'));\n         \
    \   var p = ext.Count(x => x.Equals('D')) + ext.Count(x => x.Equals('d')) + ext.Count(x\
    \ => x.Equals('g')) + ext.Count(x => x.Equals('G'));\n            var s = ext.Count(x\
    \ => x.Equals('F')) + ext.Count(x => x.Equals('f')) + ext.Count(x => x.Equals('h'))\
    \ + ext.Count(x => x.Equals('H'));\n            var t = ext.Count(x => x.Equals('I'))\
    \ + ext.Count(x => x.Equals('i')) + ext.Count(x => x.Equals('j')) + ext.Count(x\
    \ => x.Equals('J'));\n            var v = ext.Count(x => x.Equals('K')) + ext.Count(x\
    \ => x.Equals('k')) + ext.Count(x => x.Equals('l')) + ext.Count(x => x.Equals('L'));\n\
    \            var w = ext.Count(x => x.Equals('M')) + ext.Count(x => x.Equals('m'))\
    \ + ext.Count(x => x.Equals('n')) + ext.Count(x => x.Equals('N'));\n         \
    \   var x = ext.Count(x => x.Equals('P')) + ext.Count(x => x.Equals('p')) + ext.Count(x\
    \ => x.Equals('r')) + ext.Count(x => x.Equals('R'));\n            var y = ext.Count(x\
    \ => x.Equals('S')) + ext.Count(x => x.Equals('s')) + ext.Count(x => x.Equals('t'))\
    \ + ext.Count(x => x.Equals('T'));\n            var z = ext.Count(x => x.Equals('V'))\
    \ + ext.Count(x => x.Equals('v')) + ext.Count(x => x.Equals('w')) + ext.Count(x\
    \ => x.Equals('W'));\n            var A = ext.Count(x => x.Equals('Y')) + ext.Count(x\
    \ => x.Equals('y')) + ext.Count(x => x.Equals('z')) + ext.Count(x => x.Equals('Z'));\n\
    \n            int a = (int)(n / A);\n            int b = (int)(m / b);\n     \
    \       int c = (int)(p ", "        var extension_counts = extensions.GroupBy(x\
    \ => x.Length).ToDictionary(x => x.Key, x => x.Count());\n        Dictionary<string,\
    \ int> extension_strengths;\n        if (extension_counts.TryGetValue(\"AA\",\
    \ out extension_strengths)) {\n            int AA_strength = extension_strengths[\"\
    AA\"];\n            int Be_strength = extension_strengths[\"Be\"];\n         \
    \   int CC_strength = extension_strengths[\"CC\"];\n            if (AA_strength\
    \ > Be_strength && AA_strength > CC_strength) {\n                return string.Concat(class_name,\
    \ \".AA\");\n            }\n            if (Be_strength > AA_strength && Be_strength\
    \ > CC_strength) {\n                return string.Concat(class_name, \".Be\");\n\
    \            }\n            if (CC_strength > AA_strength && CC_strength > Be_strength)\
    \ {\n                return string.Concat(class_name, \".CC\");\n            }\n\
    \        }\n        if (extension_counts.TryGetValue(\"Be\", out extension_strengths))\
    \ {\n            int AA_strength = extension_strengths[\"AA\"];\n            int\
    \ Be_strength = extension_strengths[\"Be\"];\n            int CC_strength = extension_strengths[\"\
    CC\"];\n            if (AA_strength > Be_strength && AA_strength > CC_strength)\
    \ {\n                return string.Concat(class_name, \".Be\");\n            }\n\
    \            if (Be_strength > AA_strength && Be_strength > CC_strength) {\n \
    \               return string.Concat(class_name, \".Be\");\n            }\n  \
    \          if (CC_strength > AA_strength && CC_strength > Be_strength) {\n   \
    \             return string.Concat(class_name, \".Be\");\n            }\n    \
    \    }\n        if (extension_counts.TryGetValue(\"CC\", out extension_strengths))\
    \ {\n            int AA_strength = extension_strengths[\"AA\"];\n            int\
    \ Be_strength = extension_strengths[\"Be\"];\n            int CC_strength = extension_strengths[\"\
    CC\"];\n            if (AA_strength > Be_strength && AA_strength > CC_strength)\
    \ {\n                return string.Concat(class_name, \".CC\");\n            }\n\
    \            if (Be_strength > AA_strength && Be_strength > CC_strength) {\n \
    \               return string.Concat(class_name, \".CC\");\n            }\n  \
    \          if (CC_strength > AA_strength && CC_strength > Be_strength) {\n   \
    \             return string.Concat(class_name, \".CC\");\n            }\n    \
    \    }\n        throw new Exception(\"No extension matches strongest extension\
    \ strength.\");", '        return GetExtension(class_name, extensions, false,
    0).ToString();', "        List<string> sorted_extensions = extensions.OrderByDescending(x\
    \ => x.Count(c => c>='A' && c<='Z')).ToList();\n        int sme = 0;\n       \
    \ foreach (string extension in sorted_extensions) {\n            sme += extension.Count(c\
    \ => c>='a' && c<='z') - extension.Count(c => c>='A' && c<='Z');\n        }\n\n\
    \        var sorted = sorted_extensions.Select(x => x.Substring(0, x.IndexOf('.')\
    \ + 1) + x).GroupBy(x => x.Substring(0, x.IndexOf('.') + 1)).Select(x => x.OrderByDescending(y\
    \ => sme - y.Count(c => c>='A' && c<='Z')).First()).ToList();\n\n        int best\
    \ = 0;\n        foreach (string extension in sorted_extensions) {\n          \
    \  int count = extension.Count(c => c>='a' && c<='z') - extension.Count(c => c>='A'\
    \ && c<='Z');\n            if (sorted.Count(y => y.EndsWith(extension)) > best)\n\
    \                best = sorted.Count(y => y.EndsWith(extension));\n        }\n\
    \n        return class_name + \".\" + sorted.First();", "        // Write your\
    \ code here\n        Dictionary<string, int> count = new Dictionary<string, int>();\n\
    \        foreach (string extension in extensions) {\n            if (count.ContainsKey(extension))\
    \ {\n                int value = count[extension];\n                count[extension]\
    \ = value + 1;\n            }\n            else {\n                count[extension]\
    \ = 1;\n            }\n        }\n        int smallestCount = 0;\n        foreach\
    \ (string extension in extensions) {\n            if (count[extension] > smallestCount)\
    \ {\n                smallestCount = count[extension];\n            }\n      \
    \  }\n        if (smallestCount < 2) {\n            return class_name;\n     \
    \   }\n        else if (smallestCount > 2) {\n            int max = 0;\n     \
    \       string maxExtension = string.Empty;\n            foreach (string extension\
    \ in extensions) {\n                if (count[extension] > max) {\n          \
    \          max = count[extension];\n                    maxExtension = extension;\n\
    \                }\n            }\n            return class_name + maxExtension;\n\
    \        }", "        // Write your code here\n        // YOUR CODE HERE", " \
    \       string result = class_name;\n        if (extensions.Count() > 0) {\n \
    \           extensions.Sort(new ExtensionComparer());\n            extensions.Reverse();\n\
    \            string extension_strength = extensions[0];\n            int extension_strength_num\
    \ = 0;\n            char[] class_name_upper = class_name.ToUpperInvariant().ToCharArray();\n\
    \            char[] extension_strength_upper = extension_strength.ToUpperInvariant().ToCharArray();\n\
    \            for (int i = 0; i < class_name_upper.Length; i++) {\n           \
    \     if (class_name_upper[i] == extension_strength_upper[i]) {\n            \
    \        extension_strength_num++;\n                }\n            }\n       \
    \     if (extension_strength_num > 0) {\n                result = class_name +\
    \ \".\" + extension_strength;\n            }\n            else {\n           \
    \     for (int i = 0; i < extensions.Count(); i++) {\n                    extensions[i]\
    \ = extensions[i].ToLowerInvariant();\n                }\n                extensions.Sort();\n\
    \                extensions.Reverse();\n                extension_strength = extensions[0];\n\
    \                extension_strength_num = 0;\n                char[] class_name_lower\
    \ = class_name.ToLowerInvariant().ToCharArray();\n                char[] extension_strength_lower\
    \ = extension_strength.ToLowerInvariant().ToCharArray();\n                for\
    \ (int i = 0; i < class_name_lower.Length; i++) {\n                    if (class_name_lower[i]\
    \ == extension_strength_lower[i]) {\n                        extension_strength_num++;\n\
    \                    }\n                }\n                if (extension_strength_num\
    \ > 0) {\n                    result = class_name + \".\" + extension_strength;\n\
    \                }\n            }\n        }\n        return result;", '        return
    "";', "        // Use a dictionary to keep track of the strength of the extensions\n\
    \        Dictionary<string, int> extension_strength = new Dictionary<string, int>();\n\
    \        foreach (string extension in extensions) {\n            // Get the number\
    \ of upper case letters in extension\n            int cap = extension.Count(x\
    \ => char.IsUpper(x));\n            string extension_name = extension;\n     \
    \       // Get the number of lower case letters in extension\n            int\
    \ sm = extension.Count(x => char.IsLower(x));\n            // Get the strength\
    \ of the extension\n            int strength = cap - sm;\n            // Add extension\
    \ to dictionary if not already in the dictionary\n            if (!extension_strength.ContainsKey(extension_name))\
    \ {\n                extension_strength[extension_name] = strength;\n        \
    \    }\n        }\n        \n        // Choose the extension with maximum strength\n\
    \        string best_extension = extension_strength.Max().Key;\n        // Return\
    \ extension name with maximum strength\n        return class_name + best_extension;",
  "        string extensions_sorted = new List<string>();\n        foreach (string\
    \ extension in extensions) {\n            extensions_sorted.Add(extension);\n\
    \        }\n        extensions_sorted.Sort();\n        StringBuilder sb = new\
    \ StringBuilder();\n        bool first_value = true;\n        foreach (string\
    \ extension in extensions_sorted) {\n            int SM = 0;\n            int\
    \ CAP = 0;\n            bool first = true;\n            foreach (string ext in\
    \ extensions_sorted) {\n                if (first == false && SM > CAP)\n    \
    \            {\n                    first = false;\n                    sb.Append(class_name\
    \ + \".\" + extension + \".\");\n                }\n                else\n   \
    \             {\n                    sb.Append(class_name + \".\" + ext + \".\"\
    );\n                    SM++;\n                    CAP++;\n                }\n\
    \            }\n            if (first)\n            {\n                sb.Append(class_name\
    \ + \".\" + extension + \".\");\n            }\n            first_value = false;\n\
    \        }\n        return sb.ToString();", "        string strongest_extension\
    \ = string.Empty;\n        List<string> extensions_list = extensions.ToList();\n\
    \        var counter = new Dictionary<string, int>() { };\n        foreach (string\
    \ extension in extensions_list) {\n            string current_extension = extension.Replace(\"\
    _\", string.Empty);\n            if (!counter.ContainsKey(current_extension.ToLower()))\
    \ {\n                counter[current_extension.ToLower()] = 1;\n            }\
    \ else {\n                counter[current_extension.ToLower()] += 1;\n       \
    \     }\n        }\n        if (counter.Values.Any()) {\n            int strongest_value\
    \ = counter.Values.Max();\n            foreach (string extension in extensions_list)\
    \ {\n                string current_extension = extension.Replace(\"_\", string.Empty);\n\
    \                if (counter[current_extension.ToLower()] == strongest_value)\
    \ {\n                    strongest_extension = class_name + \".\" + current_extension;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return strongest_extension;", "        IEnumerable<string> extensions_sorted\
    \ = extensions.OrderByDescending(e => e.Length);\n        IEnumerable<int> extensions_sorted_indexes\
    \ = extensions_sorted.Select((e, i) => i);\n        int? min_length = extensions_sorted.Take(1).First();\n\
    \        int? max_length = extensions_sorted.Last();\n        for (int i = 0;\
    \ i < extensions_sorted.Count; i++) {\n            int length = extensions_sorted_indexes[i].Length;\n\
    \            int? min = (i == 0) ? null : extensions_sorted_indexes[i - 1];\n\
    \            int? max = (i == extensions_sorted.Count - 1) ? null : extensions_sorted_indexes[i];\n\
    \            if (length < min_length) {\n                min_length = length;\n\
    \            } else if (length == min_length && max != null && max < min_length)\
    \ {\n                min_length = max;\n            }\n        }\n        return\
    \ class_name + \".\" + extensions_sorted.First().Substring(min_length);", "  \
    \      var extensions_set = extensions.ToArray();\n        var extension_strongest\
    \ = new Dictionary<string, int>();\n\n        // Add all extensions to the set\
    \ of extensions and count the extensions' strengths\n        foreach (var extension\
    \ in extensions_set) {\n            int strength = 0;\n            var index =\
    \ extension.IndexOfAny(new char[]{'A', 'B'});\n            if (index > -1) {\n\
    \                var letter_count = extension.Count(c => Char.IsUpper(c));\n \
    \               strength = (letter_count - 1);\n            }\n\n            var\
    \ index = extension.IndexOfAny(new char[]{'a', 'b', 'c'});\n            if (index\
    \ > -1) {\n                var letter_count = extension.Count(c => Char.IsLower(c));\n\
    \                strength += (letter_count - 1);\n            }\n\n          \
    \  extension_strongest.Add(extension.ToLower(), strength);\n        }\n\n    \
    \    // Sort the extension strength dictionary by value and return the first element\n\
    \        return extension_strongest.OrderByDescending(x => x.Value).First().Key.ToString()\
    \ + '.' + class_name;", "        int[] strongest_extensions_strength = new int[26];\n\
    \        for (int i = 0; i < extensions.Count(); i++) {\n            string extension\
    \ = extensions[i];\n            int extension_strength = extension.Length - extension.Replace(class_name,\
    \ \"\").Length;\n            extension_strength = extension_strength * extension_strength;\n\
    \            int max_strength = -1;\n            for (int j = 0; j < 26; j++)\
    \ {\n                strongest_extensions_strength[j] = Math.Max(strongest_extensions_strength[j],\
    \ extension_strength);\n                if (strongest_extensions_strength[j] >\
    \ max_strength) {\n                    max_strength = strongest_extensions_strength[j];\n\
    \                }\n            }\n        }\n\n        // return the strongest\
    \ extension\n        string extension_strength_strength = Enumerable.Range(0,\
    \ 26).Where(x => strongest_extensions_strength[x] == strongest_extensions_strength.Max()).Select(x\
    \ => x.ToString()).ToArray()[0];\n        string result = class_name + \".\" +\
    \ extension_strength_strength;\n        return result;", "        var strongest\
    \ = extensions.OrderByDescending(s => s.Count()).First();\n        return class_name\
    \ + \".\" + strongest;", "        Debug.Assert(class_name != null);\n        Debug.Assert(extensions\
    \ != null);\n        Debug.Assert(extensions.All(x => x != null));\n        int\
    \ cap = 0;\n        int sm = 0;\n        foreach (string extension in extensions)\
    \ {\n            int count = GetLetterCount(extension);\n            cap += count;\n\
    \            sm += count;\n        }\n        double strength = cap / sm;\n  \
    \      int strongest = -1;\n        int extension_count = 0;\n        foreach\
    \ (string extension in extensions) {\n            int count = GetLetterCount(extension);\n\
    \            if (strongest < 0 || count > strongest) {\n                strongest\
    \ = count;\n            }\n            if (count > extension_count) {\n      \
    \          extension_count = count;\n            }\n        }\n        if (strongest\
    \ == -1) {\n            return class_name;\n        }\n        return class_name\
    \ + \".\" + extensions.ElementAt(GetExtensionIndex(extensions, strongest));",
  "        if (extensions.Count == 0) return \"\";\n        var ext = extensions.FirstOrDefault(x\
    \ => x.Any(y => y == class_name.Substring(0, 1)));\n        var extension_name\
    \ = \"\";\n        if (ext != null) extension_name = ext[0].ToUpper() + ext.Substring(1);\n\
    \        double strength = 0;\n        for (int i = 0; i < extension_name.Length;\
    \ i++) {\n            int index = class_name.IndexOf(extension_name[i]) - i;\n\
    \            strength += index;\n        }\n        strength = (double)Math.Floor(strength\
    \ / extension_name.Length);\n        string result = \"\";\n        var count\
    \ = Enumerable.Range(1, int.MaxValue)\n        .Where(x => (double)x / strength\
    \ > 1)\n        .ToList();\n        if (count.Count == 0) return result;\n   \
    \     result = class_name + \".\";\n        for (int i = 0; i < count.Count; i++)\
    \ {\n            result += extensions[count - i];\n        }\n        return result;",
  "        // TODO: Write your code here.\n        Dictionary<int, int> counts = new\
    \ Dictionary<int, int>();\n        for (int i = 0; i < extensions.Count(); i++)\n\
    \            counts.Add(extensions[i].Count(c => Char.IsUpper(c)), extensions[i].Count(c\
    \ => Char.IsLower()));\n        foreach (KeyValuePair<int, int> k in counts)\n\
    \        {\n            int maxCount = k.Key;\n            int minCount = k.Value;\n\
    \            if (maxCount < minCount)\n            {\n                maxCount\
    \ = minCount;\n            }\n        }\n        string returnValue = class_name;\n\
    \        foreach (KeyValuePair<int, int> k in counts)\n        {\n           \
    \ int maxCount = k.Key;\n            int minCount = k.Value;\n            if (maxCount\
    \ != minCount)\n            {\n                if (maxCount > minCount)\n    \
    \            {\n                    returnValue += maxCount - minCount + k.Value;\n\
    \                }\n                else\n                {\n                \
    \    returnValue += k.Value;\n                }\n            }\n            else\n\
    \            {\n                if (maxCount > minCount)\n                {\n\
    \                    returnValue += maxCount - minCount;\n                }\n\
    \            }\n        }\n        return returnValue;", "        // Your code\
    \ goes here\n\n        int cap, sm;\n        string name;\n        string strongest_ext\
    \ = null;\n        if (extensions.Count() < 1) {\n            return class_name;\n\
    \        }\n        cap = extensions.Count(t => t.All(c => char.IsUpper(c)));\n\
    \        sm = extensions.Count(t => t.All(c => char.IsLower(c)));\n        if\
    \ (cap == sm) {\n            strongest_ext = class_name;\n        }\n        else\
    \ if(sm > cap)\n        {\n            strongest_ext = \".\" + extensions.ElementAt(0);\n\
    \            extensions.RemoveAt(0);\n        }\n        else\n        {\n   \
    \         strongest_ext = class_name.Substring(0, class_name.LastIndexOf(\".\"\
    ) + 1);\n        }\n        strongest_ext = strongest_ext + extensions.ElementAt(0).Substring(cap\
    \ - sm);\n        return strongest_ext;", "        // TODO\n        Array.Sort(extensions,\
    \ (x, y) => CompareExtension(x, y));\n        return class_name + \".\" + extensions[0];",
  "        string result = \"\";\n        List<int> caps = new List<int>();\n    \
    \    List<int> sms = new List<int>();\n        foreach (string extension in extensions)\
    \ {\n            int cap = extension.Count(x => x.ToUpper().Equals(x)).Count;\n\
    \            int sm = extension.Count(x => x.ToLower().Equals(x)).Count;\n   \
    \         caps.Add(cap);\n            sms.Add(sm);\n        }\n        int sms_max\
    \ = sms.Max();\n        int caps_max = caps.Max();\n        double strongest =\
    \ (caps_max - sms_max) / (caps_max + sms_max);\n        int max_num = caps.Max();\n\
    \        if (strongest == max_num) {\n            foreach (string extension in\
    \ extensions) {\n                int cap = extension.Count(x => x.ToUpper().Equals(x)).Count;\n\
    \                int sm = extension.Count(x => x.ToLower().Equals(x)).Count;\n\
    \                if (cap == caps.Max() && sm == sms.Max()) {\n               \
    \     result += class_name + \".\" + extension;\n                    break;\n\
    \                }\n            }\n        } else {\n            foreach (string\
    \ extension in extensions) {\n                int cap = extension.Count(x => x.ToUpper().Equals(x)).Count;\n\
    \                int sm = extension.Count(x => x.ToLower().Equals(x)).Count;\n\
    \                if (cap != caps.Max() && sm != sms.Max()) {\n               \
    \     result += class_name + \".\" + extension;\n                    break;\n\
    \                }\n            }\n        }\n        return result;", "     \
    \   // Your code goes here\n        \n        string result = (class_name + (\"\
    [\"+extensions+\"]\").Aggregate(new StringBuilder(class_name), (x, y) => x + y))+\"\
    .\";\n        \n        return result;", "        int sm = 0;\n        int cap\
    \ = 0;\n        string strongest_extension = class_name + extensions[0];\n   \
    \     foreach (var e in extensions) {\n            int extension_cap = e.Count();\n\
    \            if (extension_cap != 0) {\n                sm += extension_cap;\n\
    \                cap += extension_cap;\n                if (extension_cap > cap)\
    \ {\n                    strongest_extension = class_name + e;\n             \
    \   }\n            }\n        }\n        return strongest_extension;", "     \
    \   if (extensions == null) {\n            return null;\n        }\n        Dictionary<string,\
    \ int> dictionary = new Dictionary<string, int>();\n        foreach (string extension\
    \ in extensions) {\n            int numUpper = extension.Count(i => Char.IsUpper(i));\n\
    \            int numLower = extension.Count(i => Char.IsLower(i));\n         \
    \   int numCap = numUpper - numLower;\n            int numSM = numLower - numCap;\n\
    \            int value = numCap - numSM;\n            dictionary.Add(extension,\
    \ value);\n        }\n        if (dictionary.Count != 0) {\n            string\
    \ key = dictionary.Keys.Max();\n            return class_name + \".\" + key;\n\
    \        } else {\n            return null;\n        }", "        // Your code\
    \ here.\n        var extension = extensions.Where(x => x.ToUpper().Count() > x.ToLower().Count()).OrderBy(x\
    \ => -x.ToUpper().Count() - x.ToLower().Count()).FirstOrDefault();\n        return\
    \ string.Format(\"{0}.{1}\", class_name, extension);", "        ArrayList results\
    \ = new ArrayList();\n        foreach (string extension in extensions) {\n   \
    \         int cap_diff = extension.Count(x => char.IsUpper(x));\n            int\
    \ sm_diff = extension.Count(x => char.IsLower(x));\n            double strength\
    \ = cap_diff - sm_diff;\n            if (results.Contains(extension)) {\n    \
    \            if (strength > results[results.IndexOf(extension)]) {\n         \
    \           results.Remove(results.IndexOf(extension));\n                }\n \
    \               else {\n                    results.Add(extension);\n        \
    \        }\n            }\n            else {\n                results.Add(extension);\n\
    \            }\n        }\n        string result = class_name + \"(\" + string.Join(\"\
    , \", results) + \")\";\n        return result;", "        var extensions_count\
    \ = extensions.Count;\n        var strength_class = new int[extensions.Count];\n\
    \        var strength_ext = new int[extensions.Count];\n        var extensions_cap\
    \ = new int[extensions.Count];\n        var extensions_sm = new int[extensions.Count];\n\
    \        var highest_strength_class = -1;\n        var highest_strength_ext =\
    \ -1;\n        var highest_strength_class_index = -1;\n        var highest_strength_ext_index\
    \ = -1;\n        for (int i = 0; i < extensions.Count; i++) {\n            var\
    \ length = extensions[i].Length;\n            strength_class[i] = 0;\n       \
    \     strength_ext[i] = 0;\n            extensions_cap[i] = 0;\n            extensions_sm[i]\
    \ = 0;\n        }\n        for (int i = 0; i < extensions.Count; i++) {\n    \
    \        var length = extensions[i].Length;\n            for (int j = 0; j < length;\
    \ j++) {\n                var letter = extensions[i][j];\n                if (char.IsUpper(letter))\
    \ {\n                    strength_class[i]++;\n                    extensions_cap[i]++;\n\
    \                }\n                else if (char.IsLower(letter)) {\n       \
    \             strength_ext[i]++;\n                }\n                else {\n\
    \                    throw new Exception(\"Invalid extension name\");\n      \
    \          }\n            }\n        }\n        for (int i = 0; i < extensions.Count;\
    \ i++) {\n            var length = extensions[i].Length;\n            for (int\
    \ j = 0; j < length; j++) {\n                var letter = extensions[i][j];\n\
    \                if (char.IsUpper(letter)) {\n                    strength_class[i]\
    \ = strength_class[i] / extensions_cap[i];\n                }\n              \
    \  else if (char.IsLower(letter)) {\n                    strength_ext[i] = strength_ext[i]\
    \ / extensions_sm[i];\n                }\n            }\n        }\n        for\
    \ (int i = 0; i < extensions.Count; i++) {\n            if (strength_class[i]\
    \ > strength_ext[i]) {\n                highest_strength_class = i;\n        \
    \        highest_strength_class_index = i;\n            }\n            if (strength_ext[i]\
    \ > strength_class[i]) {\n                highest_strength_ext = i;\n        \
    \        highest_strength_ext_index = i;\n            }\n        }\n        if\
    \ (highest_strength_class == -1)\n            throw new Exception(\"No extensions\
    \ satisfy the highest strength\");\n        if (highest_strength_ext == -1)\n\
    \            throw new Exception(\"No extensions satisfy the highest strength\"\
    );\n        if (highest_strength_class > highest_strength_ext)\n            throw\
    \ new Exception(\"Two or more extensions satisfy the highest strength\");\n  \
    \      if (highest_strength_class == highest_strength_ext)\n            throw\
    \ new Exception(\"One extension satisfy the highest strength\");\n        var\
    \ extension_prefix = class_name + \".\";\n        var result = extensions[highest_strength_class].Substring(0,\
    \ extensions[highest_strength_class].IndexOf(extensions[highest_strength_ext]));\n",
  "        // Your code goes here\n        return null;", "        // Write your code\
    \ here\n        string strongest = string.Empty;\n        double strongest_strength\
    \ = -1;\n\n        var extensions_sorted = extensions.OrderBy(i => i.ToUpperInvariant()).ThenBy(i\
    \ => i.ToLowerInvariant());\n        foreach (var extension in extensions_sorted)\
    \ {\n            int extension_capital = Math.Abs(extension.Count(c => char.IsUpper(c)));\n\
    \            int extension_small = Math.Abs(extension.Count(c => char.IsLower(c)));\n\
    \            strongest_strength = (strongest_strength * (extension_capital - extension_small))\
    \ / extension_capital;\n            if (strongest_strength > strongest.Length)\n\
    \                strongest = extension;\n        }\n        return string.Concat(class_name.ToUpperInvariant(),\
    \ \".\", strongest);", "        List<int> counter = new List<int>();\n       \
    \ foreach(string e in extensions) {\n            char[] c = e.ToCharArray();\n\
    \            foreach(int i in Enumerable.Range(0, c.Length)) {\n             \
    \   if(Char.IsUpper(c[i]))\n                    counter.Add(i);\n            }\n\
    \        }\n        int highest_counter = 0;\n        foreach(int i in counter)\n\
    \            if(counter[i] > highest_counter) {\n                highest_counter\
    \ = counter[i];\n            }\n        List<string> strongest = new List<string>();\n\
    \        foreach(int i in counter) {\n            if(counter[i] == highest_counter)\
    \ {\n                strongest.Add(extensions[i]);\n            }\n        }\n\
    \        string classname = class_name + \".\";\n        foreach(string e in strongest)\
    \ {\n            classname += e;\n        }\n        return classname;", "   \
    \     // Write your code here!\n        string extension = extensions[0];\n  \
    \      bool extensionExist = false;\n        if (extensions.Count > 1) {\n   \
    \         for (int i = 1; i < extensions.Count; i++) {\n                if (extensions.ElementAt(i).Length\
    \ > extension.Length) {\n                    extension = extensions.ElementAt(i);\n\
    \                }\n            }\n            extensionExist = true;\n      \
    \  }\n        string result = \"\";\n        if (extensionExist) {\n         \
    \   result = class_name + \".\" + extension;\n        }\n        else {\n    \
    \        result = class_name;\n        }\n        return result;", "        int\
    \ sm_count = class_name.Count();\n        int cap_count = class_name.ToUpper().Count();\n\
    \        float strength = ((float)sm_count)/(cap_count);\n        int max_strength\
    \ = -1;\n        foreach (string ext in extensions) {\n            int ex_s =\
    \ ext.Count();\n            int ex_s_upper = ext.ToUpper().Count();\n        \
    \    float ex_strength = ((float)ex_s)/(ex_s_upper);\n            if (strength\
    \ > ex_strength) {\n                strength = ex_strength;\n                max_strength\
    \ = ex_s;\n            }\n        }\n        return class_name + \".\" + extensions.ElementAt(extensions.IndexOf(extensions[extensions.IndexOf(max_strength)])).ToString();",
  "        int cap = 0;\n        int sm = 0;\n\n        foreach (string extension\
    \ in extensions) {\n            int count = extension.Length;\n\n            if\
    \ (extension.Count(x => Char.IsUpper(x)).Count() > cap) {\n                cap\
    \ = extension.Count(x => Char.IsUpper(x)).Count();\n            }\n\n        \
    \    if (extension.Count(x => Char.IsLower(x)).Count() > sm) {\n             \
    \   sm = extension.Count(x => Char.IsLower(x)).Count();\n            }\n     \
    \   }\n\n        if (cap - sm > 0)\n        {\n            int index = 0;\n  \
    \          string extension = extensions.FirstOrDefault();\n\n            while\
    \ (extension != null)\n            {\n                if (extension.Count(x =>\
    \ Char.IsUpper(x)).Count() == cap - sm)\n                {\n                 \
    \   index = index;\n                }\n\n                if (extension.Count(x\
    \ => Char.IsLower(x)).Count() == sm)\n                {\n                    index\
    \ = index;\n                }\n\n                extension = extensions.Skip(index).FirstOrDefault();\n\
    \                index++;\n            }\n            extension = extensions.Skip(index).FirstOrDefault();\n\
    \n            return class_name + \".\" + extension;\n        }\n        else\n\
    \        {\n            return class_name;\n        }", "        List<string>\
    \ sorted = new List<string>();\n        Extension first = Extension.Empty;\n \
    \       foreach (Extension ext in extensions) {\n            if (ext.get_strength()\
    \ == 0) {\n                continue;\n            }\n            int strength\
    \ = ext.get_strength();\n            if (first == null || strength <= first.get_strength())\
    \ {\n                first = ext;\n            }\n        }\n        return class_name\
    \ + \"#\" + first.get_name() + \".\" + first.get_name();", "        if (extensions\
    \ == null || extensions.Count < 1) return \"\";\n        List<string> sorted_list\
    \ = extensions.OrderBy(s => s.ToUpper()).ToList();\n        int length = class_name.Length;\n\
    \        if (sorted_list.Count <= 1) return class_name;\n        int upper_cap\
    \ = sorted_list.FindIndex(s => s.ToUpper().Count() > length);\n        int lower_cap\
    \ = sorted_list.FindIndex(s => s.ToUpper().Count() == length);\n        double\
    \ strength = ((double)upper_cap - lower_cap) / sorted_list.Count;\n        if\
    \ (strength > 0) return class_name + sorted_list[(int)Math.Round(strength)];\n\
    \        else if (lower_cap > 0) return sorted_list[(int)Math.Round(-strength)];\n\
    \        return \"\";", "        Dictionary<string, int> strongest_extensions\
    \ = new Dictionary<string, int>();\n        foreach (string extension in extensions)\
    \ {\n            int strength = 0;\n            foreach (char c in extension)\n\
    \                if (char.IsUpper(c))\n                    strength++;\n     \
    \       foreach (char c in extension)\n                if (char.IsLower(c))\n\
    \                    strength--;\n            if (strongest_extensions.ContainsKey(extension))\n\
    \                strongest_extensions[extension] = Math.Min(strongest_extensions[extension],\
    \ strength);\n            else\n                strongest_extensions.Add(extension,\
    \ strength);\n        }\n        int strongest_strength = -1;\n        foreach\
    \ (KeyValuePair<string, int> pair in strongest_extensions)\n            if (pair.Value\
    \ == strongest_strength)\n                continue;\n            strongest_strength\
    \ = pair.Value;\n            return class_name + \".\" + pair.Key;", "       \
    \ var strongest = extensions.OrderBy(e => CountCap(e) - CountSm(e)).FirstOrDefault();\n\
    \        if (strongest == null) {\n            return \"\";\n        }\n     \
    \   return class_name + \".\" + strongest;", "        // Complete the implementation.\n\
    \        throw new NotImplementedException();", "        var streng = 0;\n   \
    \     var extensions_names = extensions.Select(x => x.ToLower()).ToList();\n \
    \       var class_name_without_extensions = class_name.Split('.').First();\n \
    \       var class_name_with_extensions = class_name_without_extensions + \".\"\
    \ + extensions_names.FirstOrDefault(x => x.ToUpper() == extensions_names.FirstOrDefault().ToUpper())\
    \ ?? extensions_names.FirstOrDefault();\n        var class_name_with_extensions_as_int\
    \ = new string[] { class_name_with_extensions }.Select(x => Convert.ToInt32(x)).FirstOrDefault();\n\
    \        streng = class_name_with_extensions_as_int / new string[] { class_name_without_extensions.ToLower()\
    \ }.Count(x => x.ToUpper() == x.ToLower());\n        extensions.Remove(class_name_with_extensions);\n\
    \        return class_name_with_extensions + \".\" + extensions.FirstOrDefault(x\
    \ => x.ToUpper() == extensions.FirstOrDefault().ToUpper()) ?? extensions.FirstOrDefault();",
  "        if (extensions == null || extensions.Count() == 0) throw new ArgumentNullException();\n\
    \        if (class_name == null || class_name.Length == 0) throw new ArgumentException();\n\
    \n        int cap = class_name.Length;\n        int sm = class_name.ToLowerInvariant().Count(x\
    \ => Char.IsUpper(x));\n\n        int sc = cap - sm;\n        IEnumerable<string>\
    \ x = extensions;\n        string highest = x.OrderBy(y => y).First();\n\n   \
    \     if (highest.Length == sm) highest = highest.Substring(0, sm);\n        else\
    \ if (highest.Length < sm) highest = new string(highest.Take(sm));\n        string\
    \ strongest = highest + extensions[0];\n\n        for (int i = 1; i < extensions.Count;\
    \ i++) {\n            int y = cap - extensions[i].ToLowerInvariant().Count(x =>\
    \ Char.IsUpper(x));\n            if (y == sc) strongest += \".\" + extensions[i];\n\
    \            else break;\n        }\n        return strongest;", "        int\
    \ SM = extensions.Count();\n        int CAP = class_name.ToUpper().Count();\n\
    \        double strength = CAP - SM;\n        extensions.Sort((x, y) => strength.CompareTo(x.ToUpper().Count()\
    \ - y.ToUpper().Count()));\n        var extension_name = extensions.First();\n\
    \        return class_name + \".\" + extension_name;", "        HashSet<string>\
    \ hash = new HashSet<string>();\n        List<string> strongest = new List<string>();\n\
    \        int sm = 0;\n        foreach (string item in extensions) {\n        \
    \    int cap = 0;\n            foreach (char c in item) {\n                if\
    \ (char.IsUpper(c))\n                    cap++;\n            }\n            int\
    \ sm2 = 0;\n            foreach (char c in item) {\n                if (char.IsLower(c))\n\
    \                    sm2++;\n            }\n            sm = cap - sm2;\n    \
    \        if (sm.Equals(0))\n                hash.Add(item);\n        }\n     \
    \   string res = class_name;\n        int max = -1;\n        foreach (string e\
    \ in hash)\n            if (max < extension.Length && extension.Contains(e) &&\
    \ str.IndexOf(e) < str.IndexOf(item))\n                max = str.IndexOf(e);\n\
    \        strongest.Add(max);\n        if (max >= 0)\n            return res +\
    \ \"[\" + strongest[0] + \"]\";\n        return res;", "        double max_strength\
    \ = -1;\n        string strongest_extension = \"\";\n        if (extensions.Count\
    \ > 0) {\n            for (int i = 0; i < extensions.Count; i++) {\n         \
    \       string extension = extensions[i];\n                int s = extension.Count();\n\
    \                if (max_strength < s) {\n                    max_strength = s;\n\
    \                    strongest_extension = extension;\n                }\n   \
    \         }\n        }\n        if (extensions.Count > 0 && max_strength != -1)\
    \ {\n            int i = 0;\n            for (; i < extensions.Count; i++) {\n\
    \                string extension = extensions[i];\n                int s = extension.Count();\n\
    \                if (max_strength < s) {\n                    strongest_extension\
    \ = extension;\n                    break;\n                }\n            }\n\
    \        }\n        if (extensions.Count > 0 && max_strength == -1) {\n      \
    \      int i = 0;\n            for (; i < extensions.Count; i++) {\n         \
    \       string extension = extensions[i];\n                int s = extension.Count();\n\
    \                if (s > max_strength) {\n                    max_strength = s;\n\
    \                    strongest_extension = extension;\n                }\n   \
    \         }\n        }\n        if (extensions.Count > 0 && max_strength != -1)\
    \ {\n            int i = 0;\n            for (; i < extensions.Count; i++) {\n\
    \                string extension = extensions[i];\n                int s = extension.Count();\n\
    \                if (max_strength > s) {\n                    strongest_extension\
    \ = extension;\n                    break;\n                }\n            }\n\
    \        }\n        return string.Format(\"{0}.{1}\", class_name, strongest_extension);",
  "        double max_strength = 0;\n        string strongest_extension = \"\";\n\
    \        foreach (string extension in extensions) {\n            int capitals\
    \ = extension.Length - class_name.Length;\n            int lowercases = class_name.Length\
    \ - extension.Length;\n            if (capitals / lowercases == max_strength)\
    \ {\n                strongest_extension = extension;\n                max_strength\
    \ = capitals / lowercases;\n            }\n        }\n        if (max_strength\
    \ < 1)\n            strongest_extension = \"No extension\";\n        return class_name\
    \ + \".\" + strongest_extension;", "        // your code here\n        if (extensions.Count()\
    \ > 0) {\n            var max = extensions.Sum(x => x.ToUpperInvariant().Count(y\
    \ => y.ToLowerInvariant().Equals(x.ToLowerInvariant())));\n            var min\
    \ = extensions.Sum(x => x.ToLowerInvariant().Count(y => y.ToUpperInvariant().Equals(x.ToUpperInvariant())));\n\
    \            double strength = max - min;\n            if (strength > 0) {\n \
    \               foreach (var ext in extensions)\n                    if (ext.ToUpperInvariant().Count(y\
    \ => y.ToLowerInvariant().Equals(ext.ToLowerInvariant())) > strength)\n      \
    \                  strength = ext.ToUpperInvariant().Count(y => y.ToLowerInvariant().Equals(ext.ToLowerInvariant()));\n\
    \            }\n            return class_name + \".\" + extensions.First(e =>\
    \ e.ToUpperInvariant().Count(y => y.ToLowerInvariant().Equals(e.ToLowerInvariant()))\
    \ == strength);\n        }\n        return \"\";", "        var c = class_name.Length;\n\
    \        var s = extensions.Count(x => x.ToLower().FirstOrDefault().ToUpper()\
    \ == x);\n        var cap = extensions.Count(x => x.ToLower().FirstOrDefault().ToUpper()\
    \ == x && x.ToLower().FirstOrDefault().ToUpper() == x.ToUpper());\n        var\
    \ sm = extensions.Count(x => x.ToLower().FirstOrDefault().ToUpper() == x && x.ToLower().FirstOrDefault().ToUpper()\
    \ == x.ToUpper() && x.ToLower().FirstOrDefault().ToUpper() == x.ToUpper());\n\
    \        var result = null;\n        if ((cap - sm) >= 0) {\n            result\
    \ = class_name + extensions.Min(x => x.ToLower().FirstOrDefault().ToUpper());\n\
    \        }\n        else if ((cap - sm) < 0) {\n            result = class_name\
    \ + extensions.Max(x => x.ToLower().FirstOrDefault().ToUpper());\n        }\n\
    \        else if ((cap - sm) == 0) {\n            throw new Exception(\"Class\
    \ '\" + class_name + \"' is empty!\");\n        }\n        return result;", " \
    \       var extension = new Dictionary<string, int>();\n        var extensions_names\
    \ = new List<string>();\n        foreach (var item in extensions) {\n        \
    \    var name = item;\n            var name_extension = item.Replace(\"_\", \"\
    \");\n            name_extension = name_extension.ToLower();\n            int\
    \ cnt = 0;\n            foreach (char c in name_extension) {\n               \
    \ if (char.IsUpper(c)) cnt++;\n            }\n            extensions_names.Add(String.Format(\"\
    {0}.{1}\", class_name, name_extension));\n            extension.Add(name_extension,\
    \ cnt);\n        }\n        extensions_names.Sort();\n        extensions_names.Reverse();\n\
    \        var max = extensions_names.Max();\n        int maxCount = 0;\n      \
    \  foreach (var item in extensions_names) {\n            var name = item;\n  \
    \          int cnt = extension[name];\n            if (cnt > maxCount) {\n   \
    \             maxCount = cnt;\n            }\n        }\n        if (maxCount\
    \ > 0) return String.Format(\"{0}.{1}\", class_name, extension[max]);\n      \
    \  return String.Format(\"{0}\", class_name);", "        var _extension = extensions.OrderBy(x=>char.IsUpper(x)).First();\n\
    \        var _class_name = class_name.ToUpper();\n        var _cap = _extension.Count(x\
    \ => char.IsUpper(x));\n        var _sm = _extension.Count(x => char.IsLower(x));\n\
    \        var strongest = class_name + _extension[0] + _class_name + _extension[0].ToString()\
    \ + (_cap - _sm).ToString();\n        if (_extension.Count(x => char.IsUpper(x)\
    \ == _cap) && (_extension.Count(x => char.IsLower(x) == _sm)) {\n            strongest\
    \ = _extension[0];\n        }\n        return strongest;", "        ArrayList\
    \ class_list = new ArrayList();\n        ArrayList extension_list = new ArrayList();\n\
    \        HashSet<string> class_extensions = new HashSet<string>();\n        foreach\
    \ (string ext in extensions) {\n            if (class_extensions.Contains(ext))\
    \ {\n                class_list.Add(class_name);\n                extension_list.Add(ext);\n\
    \            }\n            class_extensions.Add(ext);\n        }\n        double\
    \ st = 0;\n        foreach (string class_name in class_list) {\n            int\
    \ SM = 0;\n            int CAP = 0;\n            foreach (string extension in\
    \ extension_list) {\n                int s = GetStrength(class_name, extension);\n\
    \                if (s > st) {\n                    st = s;\n                }\n\
    \                if (s <= 0) {\n                    class_extensions.Remove(extension);\n\
    \                }\n            }\n            if (class_extensions.Count > 0)\
    \ {\n                class_list.Remove(class_name);\n            }\n        }\n\
    \        return class_list[0].ToString() + \".\" + extension_list[0];", "    \
    \    string max_strength = null;\n        bool max_strength_found = false;\n \
    \       int max_strength_strength = 0;\n        for (int i = 0; i < extensions.Count;\
    \ i++)\n        {\n            // Create a dictionary with the extension name\
    \ as the key\n            Dictionary<string, int> ext_dict = new Dictionary<string,\
    \ int>();\n            int ext_strength = 0;\n            string extension = extensions[i];\n\
    \            // Break the extension name into its constituent letters\n      \
    \      foreach (char c in extension)\n            {\n                if (c.ToString().ToUpperInvariant()\
    \ == c)\n                {\n                    // This letter belongs to the\
    \ extension's name\n                    ext_dict.Add(extension.Substring(0, i),\
    \ 1);\n                }\n                else\n                {\n          \
    \          // This letter does not belong to the extension's name\n          \
    \          ext_dict.Add(extension.Substring(0, i), 0);\n                }\n  \
    \          }\n\n            foreach (KeyValuePair<string, int> kvp in ext_dict)\n\
    \            {\n                ext_strength += kvp.Value * kvp.Key;\n       \
    \     }\n            // If the extension's strength is more then the previous\
    \ extension's strength\n            // and the previous extension's strength was\
    \ not found\n            if (ext_strength > max_strength_strength && !max_strength_found)\n\
    \            {\n                // The strength of the extension\n           \
    \     int strength = ext_strength;\n                // Update the maximum strength\n\
    \                max_strength = class_name + (string.Join(\".\", extensions.Skip(i).Take(1)));\n\
    \                // Set the found flag\n                max_strength_found = true;\n\
    \                // Update the maximum strength strength\n                max_strength_strength\
    \ = strength;\n            }\n        }\n\n        if (max_strength_found)\n \
    \       {\n            return max_strength;\n        }\n\n        if (max_strength_strength\
    \ > 0)\n        {\n            return max_strength + (\".\" + extensions.Take(1).Last());\n\
    \        }\n\n        return class_name;", "        int capacity, strength;\n\
    \        string strongest = null;\n        // Compute the strength of each extension\n\
    \        foreach (var extension in extensions) {\n            extension = extension.ToUpper();\n\
    \            strength = extension.Count(c => char.IsUpper(c));\n            capacity\
    \ += strength;\n        }\n        // Find the strongest\n        foreach (var\
    \ extension in extensions) {\n            extension = extension.ToUpper();\n \
    \           strength = extension.Count(c => char.IsUpper(c));\n            if\
    \ (strongest == null || strength < strongest.Length) {\n                strongest\
    \ = class_name + \".\" + extension;\n            }\n        }\n        return\
    \ strongest;", "        // Your code goes here\n        int cap = 0;\n       \
    \ int sm = 0;\n        foreach(var ext in extensions) {\n            cap = ext.Where(x\
    \ => char.IsUpper(x)).Count();\n            sm = ext.Where(x => char.IsLower(x)).Count();\n\
    \        }\n        return (class_name + \".\" + extensions[Math.Abs(cap - sm)].Substring(0,\
    \ Math.Abs(cap - sm)));", "        // This string will hold the extension with\
    \ the strongest strength.\n        string extension_with_strength = null;\n  \
    \      List<string> extensions_sorted = extensions.OrderBy(s => s).ToList();\n\
    \        string smallest = extensions_sorted[0];\n        for(int i = 1; i < extensions_sorted.Count;\
    \ i++) {\n            if (extensions_sorted[i].Length < extensions_sorted[i -\
    \ 1].Length) {\n                extension_with_strength = extensions_sorted[i];\n\
    \            } else {\n                extension_with_strength = extensions_sorted[i\
    \ - 1];\n                break;\n            }\n        }\n        string class_with_extension\
    \ = class_name.Remove(0, class_name.Length - extension_with_strength.Length);\n\
    \        if (extensions_with_strength.Count > 1) {\n            string smallest_extension\
    \ = extensions_with_strength[0];\n            for(int i = 1; i < extensions_with_strength.Count;\
    \ i++) {\n                if (extensions_with_strength[i].Length < extensions_with_strength[i\
    \ - 1].Length) {\n                    extension_with_strength = extensions_with_strength[i];\n\
    \                } else {\n                    extension_with_strength = extensions_with_strength[i\
    \ - 1];\n                    break;\n                }\n            }\n      \
    \      class_with_extension = class_with_extension.Remove(0, class_with_extension.Length\
    \ - extension_with_strength.Length);\n        }\n        return class_with_extension\
    \ + \".\" + extension_with_strength;", "        // Write your solution\n     \
    \   if (extensions.Count == 0) return \"\";\n        var strongest = extensions.FirstOrDefault(e\
    \ => e.Length > 0);\n        var cap = strongest.Where(e => e.ToUpperInvariant().Count()\
    \ > e.ToLowerInvariant().Count()).Count();\n        var sm = strongest.Where(e\
    \ => e.ToUpperInvariant().Count() < e.ToLowerInvariant().Count()).Count();\n \
    \       return class_name + \".\" + (cap - sm).ToString();", "        var sortedByStrength\
    \ = extensions.OrderByDescending(e => GetStrength(class_name, e));\n        return\
    \ sortedByStrength.First();", "        if (extensions.Count == 0) return class_name\
    \ + \".\";\n\n        // Get list of letters and sort them by length.\n      \
    \  var letters = extensions.Select(x => new {\n            Name = x,\n       \
    \     Value = x.Length\n        }).OrderBy(x => x.Value);\n\n        // Find smallest\
    \ number of uppercase letters and add it to the beginning of the list.\n     \
    \   var smallest_uppercase_length = letters.First(x => x.Name.ToUpper().Count()\
    \ >= x.Value).Value;\n\n        letters.Insert(0, new {\n            Name = class_name\
    \ + \".\",\n            Value = smallest_uppercase_length\n        });\n\n   \
    \     // Find smallest number of lowercase letters and add it to the beginning\
    \ of the list.\n        var smallest_lowercase_length = letters.First(x => x.Name.ToLower().Count()\
    \ >= x.Value).Value;\n\n        letters.Insert(0, new {\n            Name = class_name\
    \ + \".\",\n            Value = smallest_lowercase_length\n        });\n\n   \
    \     // Find biggest number of letters and add it to the end of the list.\n \
    \       var biggest_length = letters.Max(x => x.Value);\n\n        letters.Add(new\
    \ {\n            Name = class_name + \".\",\n            Value = biggest_length\n\
    \        });\n\n        // Create new string with extension names and sort them\
    \ by length.\n        var extension_names = letters.Select(x => x.Name).OrderBy(x\
    \ => x.Length);\n\n        // Find strongest extension.\n        var strongest\
    \ = extension_names.First(x => extension_names.Count(y => y == x).Equals(1));\n\
    \n        return class_name + \".\" + strongest;", "        char[] class_name_chars\
    \ = class_name.ToCharArray();\n        int cap = class_name_chars.Length - 1;\n\
    \        int sm = extensions[0].ToCharArray().Length;\n        int strength =\
    \ (cap - sm) / extensions[0].ToCharArray().Length;\n        StringBuilder extension\
    \ = new StringBuilder(class_name + \".\");\n        for (int i = 0; i < extensions[0].ToCharArray().Length;\
    \ i++) {\n            extension.Append(extensions[0][sm]);\n        }\n      \
    \  for (int i = 0; i < extensions.Count; i++) {\n            if (extensions[i].ToCharArray().Length\
    \ > cap) {\n                continue;\n            }\n            int cur_strength\
    \ = (extensions[i].ToCharArray().Length - sm) / extensions[i].ToCharArray().Length;\n\
    \            if (cur_strength == strength) {\n                extension.Append(extensions[i]);\n\
    \            }\n        }\n        return extension.ToString();", "        if\
    \ (extensions.Count == 0)\n            return class_name;\n        int strongest\
    \ = -1;\n        int max_index = -1;\n        for (int i = 0; i < extensions.Count;\
    \ i++) {\n            int index = extensions[i].IndexOf((char)65);\n         \
    \   int lower_index = extensions[i].IndexOf((char)97);\n            if (index\
    \ > lower_index) {\n                int diff = index - lower_index;\n        \
    \        if (diff > strongest) {\n                    strongest = diff;\n    \
    \                max_index = i;\n                }\n            }\n        }\n\
    \        if (max_index == -1)\n            return class_name;\n        if (strongest\
    \ == -1)\n            return class_name + extensions[max_index];\n        int\
    \ count = 0;\n        for (int i = 0; i < extensions.Count; i++) {\n         \
    \   if (extensions[i] == class_name + extensions[max_index]) {\n             \
    \   count++;\n            }\n        }\n        if (count >= 2)\n            return\
    \ class_name + extensions[max_index];\n        return class_name + extensions[0];",
  "        double maxStrength = 0;\n        string maxExtension = \"\";\n\n      \
    \  foreach (string ext in extensions) {\n            int caps = ext.ToUpper().Count();\n\
    \            int sms = ext.ToLower().Count();\n            double s = (caps-sms)/caps;\n\
    \n            if (s > maxStrength) {\n                maxStrength = s;\n     \
    \           maxExtension = ext;\n            }\n        }\n\n        return class_name\
    \ + \".\" + maxExtension;", "        string strength = \"-1\";\n        List<string>\
    \ sorted_list = extensions.OrderBy(x => x.ToUpper().Length).ThenBy(x => x.ToLower()).ToList();\n\
    \        foreach (string extension in sorted_list) {\n            string temp_strength\
    \ = extension.ToUpper().Substring(extension.Length - extension.ToUpper().Count(\"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\".ToUpper()));\n            if (temp_strength.Length\
    \ > strength.Length) {\n                strength = temp_strength;\n          \
    \  }\n        }\n        return class_name + \".\" + extensions[sorted_list.FindIndex(x\
    \ => x.ToUpper().Equals(class_name.ToUpper()))].ToUpper();", "        string classname\
    \ = class_name;\n        string longestExtension = extensions[0];\n        string\
    \ longestExtensionLength = 0;\n\n        // Calculate the extension length from\
    \ the extension name by getting the first letter\n        foreach (string extension\
    \ in extensions) {\n            int extensionLength = 0;\n            char charAtPosition\
    \ = extension[0];\n            for (int i = 1; i < extension.Length; i++) {\n\
    \                charAtPosition = charAtPosition.ToUpperInvariant();\n       \
    \         extensionLength += charAtPosition.ToLowerInvariant().Count() - charAtPosition.ToLowerInvariant().Count();\n\
    \            }\n\n            if (extensionLength > longestExtensionLength) {\n\
    \                longestExtension = extension;\n                longestExtensionLength\
    \ = extensionLength;\n            }\n        }\n        return classname + \"\
    .\" + longestExtension;", "        // Your code here\n        foreach (var extension\
    \ in extensions)\n        {\n            Console.WriteLine(extension);\n     \
    \       int counter = 0;\n            foreach (char letter in extension)\n   \
    \         {\n                counter += 1;\n            }\n            float strength\
    \ = counter / extension.Length;\n        }\n        string StrongestExtension\
    \ = class_name.Substring(class_name.LastIndexOf('.'));\n        return StrongestExtension;",
  "        var strongest = extensions.OrderBy(e => e.Length).FirstOrDefault();\n \
    \       if (strongest.Length <= 0)\n            return class_name;\n        var\
    \ count = extension.Count(e => e.Length > 0);\n        return class_name + \"\
    .\" + strongest.Substring(0, (int)(CAP - SM) * count);", "        // Sort extensions\
    \ by strength (the strength of the extension is CAP - SM).\n        var sorted_extensions\
    \ = extensions.OrderByDescending(x => (x.ToUpper().Count() - x.ToLower().Count()))\n\
    \            .ThenByDescending(x => (x.ToUpper().Count() - x.ToLower().Count()))\n\
    \            .ThenByDescending(x => (x.ToUpper().Count() - x.ToLower().Count()))\n\
    \            .ToList();\n\n        // Find strongest extension, return ClassName+StrongestExtension\n\
    \        return class_name + sorted_extensions.FirstOrDefault();", "        Dictionary<string,\
    \ int> strongest_extension_strength = new Dictionary<string, int>();\n       \
    \ foreach (string extension in extensions) {\n            int extension_strength\
    \ = 0;\n            string extension_with_smallest_number_of_uppercase_letters\
    \ = 0;\n            string extension_with_smallest_number_of_lowercase_letters\
    \ = 0;\n            \n            // If the extension's name has at least half\
    \ of the capital letters as lowercase\n            // letters, then the extension\
    \ has at most half of the lowercase letters. \n            // If the extension's\
    \ name has only half of the lowercase letters, then the extension \n         \
    \   // has at most half of the capital letters.\n            \n            //\
    \ Get the lowercase letters from the extension's name\n            string lowercase\
    \ = extension.ToLower();\n            \n            // Check if the extension\
    \ has at least half of the lowercase letters as \n            // the capital letters.\
    \ \n            if (lowercase.Count(c => char.IsUpper(c) / 2 == lowercase.Count(c\
    \ => char.IsUpper(c))) > lowercase.Count(c => char.IsUpper(c) / 2))\n        \
    \    {\n                extension_strength = extension.Count(c => char.IsUpper(c)\
    \ / 2);\n                extension_with_smallest_number_of_uppercase_letters =\
    \ extension;\n            }\n            \n            // Get the capital letters\
    \ from the extension's name\n            string uppercase = extension.ToUpper();\n\
    \            \n            // Check if the extension has at least half of the\
    \ capital letters as \n            // the lowercase letters. \n            if\
    \ (uppercase.Count(c => char.IsLower(c) / 2 == uppercase.Count(c => char.IsLower(c)))\
    \ > uppercase.Count(c => char.IsLower(c) / 2))\n            {\n              \
    \  extension_strength = extension.Count(c => char.IsLower(c) / 2);\n         \
    \       extension_with_smallest_number_of_lowercase_letters = extension;\n   \
    \         }\n            \n            // If the extension's name has only half\
    \ of the lowercase letters as \n            // the capital letters, then the extension\
    \ has at most half of the lowercase letters. \n            // If the extension's\
    \ name has at least half of the capital letters as lowercase letters, \n     \
    \       // then the extension has at most half of the lowercase letters. \n  \
    \          \n            // If the extension's name has at least half of the capital\
    \ letters as \n            // lowercase letters, then the extension has at most\
    \ half of the capital letters.\n            \n            // If the extension's\
    \ name has at least half of the lowercase letters as \n            // the capital\
    \ letters, then the extension has at most half of the lowercase letters. \n  \
    \          \n            // If the extension's name has only half of the capital\
    \ letters as lowercase letters, \n            // then the extension has at most ",
  "        string name = class_name;\n        string ext = \"\";\n\n        double\
    \ x = 0;\n        double y = 0;\n        double z = 0;\n        double w = 0;\n\
    \        double a = 0, b = 0, c = 0, d = 0;\n\n        foreach (string item in\
    \ extensions) {\n            double num = double.Parse(item);\n            string\
    \ s = num.ToString();\n            int xn = s.IndexOf('A');\n            int yn\
    \ = s.IndexOf('b', 0, xn-1);\n            int zn = s.IndexOf('c', 0, xn-1);\n\
    \            int wn = s.IndexOf('d', 0, xn-1);\n            a = a + (s.Length\
    \ - (xn + yn + zn + wn));\n            b = b + xn;\n            c = c + yn;\n\
    \            d = d + zn;\n            w = w + wn;\n            x = x + num;\n\
    \        }\n        int xc = x.ToString().Length;\n        int yc = y.ToString().Length;\n\
    \        int zc = z.ToString().Length;\n        int wc = w.ToString().Length;\n\
    \        int xa = a.ToString().Length;\n        int yb = b.ToString().Length;\n\
    \        int zc = z.ToString().Length;\n        int wc = w.ToString().Length;\n\
    \n        double fraction = xc - (yb + zc + wc);\n        if (fraction < 0) {\n\
    \            return name;\n        }\n\n        if (fraction > 0) {\n        \
    \    fraction = Fraction(x, y, z, w);\n            double tempx = x + fraction;\n\
    \            string tempy = Fraction(y, xa, yb);\n            string tempz = Fraction(z,\
    \ xa, zc);\n            string tempw = Fraction(w, xa, wc);\n            string\
    \ temp = name + \".\" + tempy + \".\" + tempz + \".\" + tempw;\n            return\
    \ temp;\n        }\n\n        fraction = xa - (yb + zc + wc);\n        if (fraction\
    \ < 0) {\n            return name;\n        }\n\n        if (fraction > 0) {\n\
    \            fraction = Fraction(x, y, z, w);\n            double tempx = x +\
    \ fraction;\n            string tempy = Fraction(y, xc, ya);\n            string\
    \ tempz = Fraction(z, xc, zb);\n            string tempw = Fraction(w, xc, wc);\n\
    \            string temp = name + \".\" + tempy + \".\" + tempz + \".\" + tempw;\n\
    \            return temp;\n        }\n\n        fraction = yc - (xb + zc + wc);\n\
    \        if (fraction < 0) {\n            return name;\n        }\n\n        if\
    \ (fraction > 0) {\n            fraction = Fraction(x, y, z, w);\n           \
    \ double tempx = x + fraction;\n            string tempy = Fraction(y, yb, xa);\n\
    \            string tempz = Fraction(z, yb, za);\n            string tempw = Fraction(",
  "        // Write your code here\n\n        return \"\";", "        if (extensions.Count\
    \ == 0) {\n            return \"\";\n        }\n        // Initialize an array\
    \ that stores the strength of the extensions\n        int[] extension_strength\
    \ = new int[extensions.Count];\n        // Initialize a string that is used to\
    \ store the strongest extension\n        string extension_strength_string = \"\
    \";\n\n        // Loop through all the extensions and compute the strength \n\
    \        // of each one.\n        for (int index = 0; index < extensions.Count;\
    \ index++) {\n            string extension = extensions[index];\n            int\
    \ extension_strength_for_this_extension = 0;\n\n            // Loop through all\
    \ the characters in the extension\n            foreach (char c in extension.ToCharArray())\
    \ {\n                // Check if the character is an uppercase letter\n      \
    \          if (Char.IsUpper(c)) {\n                    extension_strength_for_this_extension\
    \ += 1;\n                }\n                // Check if the character is a lowercase\
    \ letter\n                else if (Char.IsLower(c)) {\n                    extension_strength_for_this_extension\
    \ += 1;\n                }\n            }\n\n            // Divide the strength\
    \ of the extension by the \n            // strongest strength of this extension\n\
    \            extension_strength[index] = extension_strength_for_this_extension\
    \ / extensions.Max();\n            extension_strength_for_this_extension = 0;\n\
    \        }\n\n        // Compute the strongest extension.\n        for (int index\
    \ = 0; index < extensions.Count; index++) {\n            if (extension_strength[index]\
    \ == 0) {\n                return \"\";\n            }\n        }\n        //\
    \ Compute the maximum.\n        int max_strength = extension_strength.Max();\n\
    \n        // Find an extension of the same strength.\n        for (int index =\
    \ 0; index < extensions.Count; index++) {\n            if (extension_strength[index]\
    \ == max_strength) {\n                extension_strength_string = extensions[index]\
    \ + \".\" + extensions[index];\n            }\n        }\n        return class_name\
    \ + \".\" + extension_strength_string;", "        char[] cap_arr = class_name.ToCharArray();\n\
    \        int cap_length = cap_arr.Length;\n        char[] sm_arr = class_name.ToCharArray();\n\
    \        int sm_length = sm_arr.Length;\n        int total_cap = 0;\n        int\
    \ total_sm = 0;\n        for (int i = 0; i < cap_length; i++)\n            total_cap\
    \ += cap_arr[i].ToString().ToUpper().Length;\n        for (int i = 0; i < sm_length;\
    \ i++)\n            total_sm += sm_arr[i].ToString().ToLower().Length;\n     \
    \   double cap_percentage = total_cap / cap_length * 100;\n        double sm_percentage\
    \ = total_sm / sm_length * 100;\n        double strength = cap_percentage - sm_percentage;\n\
    \        string strongest = class_name;\n        for (int i = 0; i < extensions[0].Length;\
    \ i++)\n            strongest += extensions[0].ToString()[i];\n        for (int\
    \ i = extensions[0].Length; i < extensions[0].Length + extensions[1].Length; i++)\n\
    \            strongest += extensions[1].ToString()[i];\n        for (int i = extensions[0].Length\
    \ + extensions[1].Length; i < extensions[0].Length + extensions[1].Length + extensions[2].Length;\
    \ i++)\n            strongest += extensions[2].ToString()[i];\n        return\
    \ strongest;", "        Debug.Assert(extensions != null && extensions.Count >\
    \ 0);\n        Debug.Assert(class_name != \"my_class\");\n        Debug.Assert(class_name\
    \ != extensions[0].Substring(0, class_name.Length));\n        Debug.Assert(class_name.Substring(0,\
    \ 1).ToUpperInvariant() == class_name.Substring(0, 1).ToUpperInvariant());\n \
    \       Debug.Assert(class_name.Length == extensions[0].Length);\n\n        //\
    \ Find the strongest extension name in the list.\n        int strongest_extension_index\
    \ = -1;\n        int extension_length = extensions.Count;\n        double extension_strength\
    \ = -1;\n        for (int i = 0; i < extension_length; ++i) {\n            string\
    \ extension = extensions[i];\n            int extension_capitals = extension.Count(x\
    \ => Char.IsUpper(x));\n            int extension_smalls = extension.Count(x =>\
    \ Char.IsLower(x));\n            double extension_strength_fraction = extension_capitals\
    \ - extension_smalls;\n            if (extension_strength >= 0) {\n          \
    \      if (extension_strength_fraction < extension_strength) {\n             \
    \       strongest_extension_index = i;\n                    extension_strength\
    \ = extension_strength_fraction;\n                }\n            }\n        }\n\
    \        string extension_name = extensions[strongest_extension_index];\n    \
    \    return class_name + \".\" + extension_name;", "        // Your code goes\
    \ here\n        var sortedExtensions = extensions.OrderByDescending(ext => ext.Count(c\
    \ => c == c.ToUpper()));\n        var sortedExtensionNames = sortedExtensions.Select(ext\
    \ => ext.Substring(0,ext.Length)).ToList();\n        if (sortedExtensionNames.Count\
    \ == 1) {\n            return class_name + \".\" + sortedExtensionNames[0];\n\
    \        }\n        var totalStrength = sortedExtensions.Select(ext => ext.Count(c\
    \ => c == c.ToUpper())).Sum();\n        var result = (sortedExtensionNames[0]\
    \ + \".\" + sortedExtensionNames[1]);\n        if (totalStrength == 2) {\n   \
    \         foreach (var extensionName in sortedExtensionNames) {\n            \
    \    result = class_name + \".\" + extensionName;\n                if (extensions.Contains(extensionName))\
    \ {\n                    result += \"(\" + (extensions.IndexOf(extensionName)\
    \ + 1) + \")\";\n                }\n            }\n        }\n        if (totalStrength\
    \ > 2) {\n            foreach (var extensionName in sortedExtensionNames) {\n\
    \                result = class_name + \".\" + extensionName;\n              \
    \  if (extensions.Contains(extensionName)) {\n                    result += \"\
    (\" + (extensions.IndexOf(extensionName) + 1) + \")\";\n                }\n  \
    \          }\n        }\n        return result;", "        int maxStrength = -1;\n\
    \        int minStrength = int.MaxValue;\n        foreach (string s in extensions)\
    \ {\n            int sint = s.Length;\n            int sc = s.Count();\n     \
    \       int scap = s.ToUpper().Count();\n            int smint = s.ToLower().Count();\n\
    \            int scapsmint = scap - smint;\n            int capsint = caps - sint;\n\
    \            int smcapsint = smint - scapsint;\n            int minscapsint =\
    \ scapsmint < smint ? scapsmint : smint;\n            int capscapsint = scapsmint\
    \ < scint ? scapsmint : scint;\n            int maxscapsint = scapsmint < smint\
    \ ? smint : scapsmint;\n            int maxscapsmint = scapsmint < smint ? scapsmint\
    \ : smint;\n            int mincapsint = capscapsint < capsint ? capscapsint :\
    \ capsint;\n            int maxcapsint = capscapsint < capsint ? capsint : capscapsint;\n\
    \            int mincapsmint = capscapsint < capsint ? capscapsint : capsint;\n\
    \            int maxcapsmint = capscapsint < capsint ? capsint : capscapsint;\n\
    \            int maxint = (minint < maxint ? minint : maxint);\n            int\
    \ minint = (maxint < minint ? maxint : minint);\n            int max = (maxint\
    \ < minint ? maxint : minint);\n            int min = (minint < maxint ? minint\
    \ : maxint);\n            int sm = (minint < maxint ? minint : maxint);\n    \
    \        int sc = (minint < maxint ? minint : maxint);\n            int caps =\
    \ (minint < maxint ? minint : maxint);\n            int smcaps = (minint < maxint\
    \ ? minint : maxint);\n            int scaps = (minint < maxint ? minint : maxint);\n\
    \            int capscaps = (minint < maxint ? minint : maxint);\n           \
    \ int scapsmint = (minint < maxint ? minint : maxint);\n            int smint\
    \ = (minint < maxint ? ", "        int cap = 0, sm = 0;\n        string str =\
    \ \"\";\n        int st = 0;\n        foreach (string extension in extensions)\
    \ {\n            foreach (char c in extension.ToCharArray()) {\n             \
    \   if (char.IsUpper(c)) {\n                    cap++;\n                } else\
    \ {\n                    sm++;\n                }\n            }\n           \
    \ if (cap > sm) {\n                cap = sm;\n                st = cap;\n    \
    \        } else {\n                sm = cap;\n                st = sm;\n     \
    \       }\n        }\n        foreach (string extension in extensions) {\n   \
    \         foreach (char c in extension.ToCharArray()) {\n                if (char.IsUpper(c))\
    \ {\n                    cap--;\n                } else {\n                  \
    \  sm--;\n                }\n            }\n            if (cap == sm) {\n   \
    \             str = class_name + \".\" + extension;\n                break;\n\
    \            }\n        }\n        return str;", "        List<char> alphabet\
    \ = new List<char>();\n        List<int> strength = new List<int>();\n       \
    \ foreach (string extension in extensions) {\n            int length = 0;\n  \
    \          foreach (char c in extension) {\n                length++;\n      \
    \          alphabet.Add((char)c);\n            }\n            int strength_of_extension\
    \ = alphabet.Count(x => x == class_name.ToUpper()) - alphabet.Count(x => x ==\
    \ class_name.ToLower());\n            strength.Add(strength_of_extension);\n \
    \       }\n        int strongest_extension = strength.Max();\n        if (strongest_extension\
    \ > 0) {\n            int strongest_extension_index = strength.IndexOf(strongest_extension);\n\
    \            string strongest_extension_name = class_name + extensions[strongest_extension_index];\n\
    \            return strongest_extension_name;\n        } else {\n            return\
    \ class_name;\n        }", "        int best_strength = -1;\n        string best_extension\
    \ = string.Empty;\n        foreach (string extension in extensions) {\n      \
    \      int extension_score = ExtensionScore(extension);\n            if (extension_score\
    \ > best_strength) {\n                best_strength = extension_score;\n     \
    \           best_extension = extension;\n            }\n        }\n        return\
    \ best_extension;", "        if (extensions.Any()) {\n            string strongest_extension\
    \ = \"\";\n            var extension_strengths = new Dictionary<char, int>();\n\
    \            foreach (var extension in extensions) {\n                var chars\
    \ = extension.ToCharArray();\n                int strength = 0;\n            \
    \    foreach (var c in chars) {\n                    if (chars.Contains(c))\n\
    \                        strength++;\n                }\n                extension_strengths[chars.First()]\
    \ = strength;\n            }\n            var strongest = extension_strengths.OrderByDescending(e\
    \ => e.Value).First();\n            if (strongest != null && strongest.Value !=\
    \ 0)\n                return class_name + \".\" + strongest.Key;\n        }\n\
    \        return class_name;", "        Extension strongest = null;\n        int\
    \ strength = 0;\n        foreach (string extension in extensions)\n          \
    \  if (extension.Contains(class_name))\n            {\n                char c\
    \ = extension[0];\n                if (c == class_name[class_name.Length - 1])\n\
    \                {\n                    char l = extension[extension.Length -\
    \ 1];\n                    if (l == class_name[class_name.Length - 2])\n     \
    \               {\n                        int cap = class_name.Length - 3;\n\
    \                        int sm = class_name.Length - 2;\n                   \
    \     int diff_cap_sm = (int)((double)cap - (double)sm);\n                   \
    \     double diff = diff_cap_sm / cap;\n                        strength += diff;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        if (strength > 0)\n        {\n            strongest = new\
    \ Extension(class_name);\n            strongest.strength = strength;\n       \
    \ }\n        if (strongest == null)\n        {\n            int strength_other\
    \ = 0;\n            foreach (string extension in extensions)\n            {\n\
    \                char c = extension[0];\n                if (c != class_name[class_name.Length\
    \ - 1])\n                {\n                    char l = extension[extension.Length\
    \ - 1];\n                    if (l != class_name[class_name.Length - 2])\n   \
    \                 {\n                        int cap = class_name.Length - 3;\n\
    \                        int sm = class_name.Length - 2;\n                   \
    \     int diff_cap_sm = (int)((double)cap - (double)sm);\n                   \
    \     double diff = diff_cap_sm / cap;\n                        strength_other\
    \ += diff;\n                    }\n                }\n            }\n        \
    \    if (strength_other > 0)\n            {\n                strongest = new Extension(class_name);\n\
    \                strongest.strength = strength_other;\n            }\n       \
    \ }\n        if (strongest == null)\n            return \"\";\n        int index\
    \ = extensions.IndexOf(strongest);\n        if (index != -1)\n            extensions.Remove(strongest);\n\
    \        foreach (Extension e in extensions)\n        {\n            e.strength\
    \ = 0;\n        }\n        extensions.Insert(index, strongest);\n        string\
    \ result = class_name + \".\";\n        foreach (Extension e in extensions)\n\
    \        {\n            result += e.name;\n        }\n        return result;",
  "        var dictionary = new Dictionary<int, List<string>>();\n        foreach\
    \ (var extension in extensions) {\n            var s = extension.ToUpperInvariant();\n\
    \            var key = s.Length * s.Length;\n            var list = dictionary.ContainsKey(key)\
    \ ? dictionary[key] : new List<string>();\n            list.Add(extension);\n\
    \            dictionary.Add(key, list);\n        }\n        var result = \"\"\
    ;\n        foreach (var entry in dictionary) {\n            var key = entry.Key;\n\
    \            var list = entry.Value;\n            var max = list.Max();\n    \
    \        if (list.Count > 1)\n                max = Math.Min(max, list.First());\n\
    \            if (list.Count > 0)\n                result += $\"{class_name}.{string.Join(\"\
    .\", list.Take(list.Count() == 1 ? 1 : list.Count()))}.{max}\";\n        }\n \
    \       return result.Length == 0 ? \"ClassName\" : result;", "        string\
    \ extension_class_name = \"\";\n        string extension_strength = \"-1\";\n\
    \        foreach (string extension in extensions) {\n            // Count Cap\
    \ letters\n            int cap_letters = extension.Count(c => char.IsUpper(c));\n\
    \            \n            // Count SM letters\n            int sm_letters = extension.Count(c\
    \ => char.IsLower(c));\n\n            // Calculate the strength\n            int\
    \ strongest = cap_letters - sm_letters;\n            \n            // If the extension\
    \ has the strongest strength yet, then add it\n            // to the list to compare\
    \ against the extension_strength\n            if (extension_strength != \"-1\"\
    \ && extension_strength != strongest) {\n                extension_strength =\
    \ strongest;\n                extension_class_name = extension;\n            }\n\
    \        }\n        // Return the name of the class and its strongest extension\n\
    \        return class_name + \".\" + extension_class_name;", "        // Use HashSet<>\
    \ to keep track of the extensions\n        HashSet<string> ext = new HashSet<string>();\n\
    \        foreach (var ext in extensions) {\n            // Find the letter with\
    \ most occurrences in the class name\n            int count = 0;\n           \
    \ foreach (var letter in class_name) {\n                if (letter == ext.Substring(0,\
    \ 1).ToUpper()) {\n                    count++;\n                }\n         \
    \   }\n            // If this is the best extension, then add it\n           \
    \ if (ext.Substring(0, 1).ToUpper() == class_name.Substring(0, 1).ToUpper()) {\n\
    \                ext.Add(ext.Substring(0, 1).ToUpper());\n            }\n    \
    \        else {\n                // Find all with the same strength\n        \
    \        List<string> sameStrength = new List<string>();\n                foreach\
    \ (var letter in class_name) {\n                    if (letter == ext.Substring(0,\
    \ 1).ToUpper()) {\n                        sameStrength.Add(letter);\n       \
    \             }\n                }\n                string bestStrength = sameStrength.First();\n\
    \                ext.Add(bestStrength);\n            }\n        }\n        List<string>\
    \ results = new List<string>();\n        string shortestExtension = \"\";\n  \
    \      foreach (var extension in extensions) {\n            if (ext.Contains(extension))\
    \ {\n                results.Add(extension);\n                shortestExtension\
    \ = extension;\n            }\n        }\n        if (results.Count > 1) {\n \
    \           return results.OrderBy(x => x.CompareTo(shortestExtension)).First();\n\
    \        }\n        else { // there is one extension\n            return shortestExtension;\n\
    \        }", "        var strongest_extension = extensions[0];\n        var strongest_strength\
    \ = -1;\n\n        foreach (var extension in extensions) {\n            if (StrongestExtension(extension,\
    \ class_name, strongest_strength)) {\n                strongest_extension = extension;\n\
    \                strongest_strength = StrongestExtension(extension, class_name,\
    \ strongest_strength);\n            }\n        }\n\n        return class_name\
    \ + \".\" + strongest_extension;", "        int CAP = 0;\n        int SM = 0;\n\
    \        foreach (string s in extensions)\n        {\n            int len = s.Length;\n\
    \            for (int i = 0; i < len; i++)\n            {\n                if\
    \ (Char.IsUpper(s[i]))\n                {\n                    CAP++;\n      \
    \          }\n                else if (Char.IsLower(s[i]))\n                {\n\
    \                    SM++;\n                }\n            }\n        }\n    \
    \    int strength = CAP - SM;\n        if (strength > 0)\n        {\n        \
    \    int index = extensions.FindIndex(x => x.Length == strength);\n          \
    \  if (index > 0)\n            {\n                return class_name + \".\" +\
    \ extensions[index];\n            }\n            else\n            {\n       \
    \         return class_name;\n            }\n        }\n        else\n       \
    \ {\n            return class_name;\n        }", "        // TODO: Create a Dictionary\
    \ with the extensions so that you can find them by name.\n        // TODO: Create\
    \ a list of the extensions so that you can sort them.\n        Dictionary<string,\
    \ int> extensions_counter = new Dictionary<string, int>();\n        foreach (string\
    \ extension in extensions)\n        {\n            var ext = extension.ToLower();\n\
    \            if (extensions_counter.ContainsKey(ext))\n            {\n       \
    \         extensions_counter[ext]++;\n            }\n            else\n      \
    \      {\n                extensions_counter.Add(ext, 1);\n            }\n   \
    \     }\n\n        // TODO: Sort the extensions_counter dictionary by the value\
    \ of the counter dictionary.\n        // TODO: Find the first extension that has\
    \ a non-zero counter and return its name.\n        List<string> sortedList = new\
    \ List<string>(extensions_counter.OrderByDescending(x => x.Value).ToList());\n\
    \        \n        //Console.WriteLine(sortedList);\n        if (extensions_counter[sortedList[0]]\
    \ > 0) {\n            return class_name + \".\" + sortedList[0];\n        }\n\
    \        \n        throw new ApplicationException(\"No strongest extension was\
    \ found\");", "        string retval = null;\n        int cap = class_name.Length\
    \ - class_name.Replace(\"_\", \"\").Length;\n        int sm = class_name.Replace(\"\
    _\", \"\").Length;\n        List<int> count_list = new List<int>();\n        foreach\
    \ (string e in extensions) {\n            int count = 0;\n            foreach\
    \ (char c in e) \n                if (char.IsUpper(c)) \n                    count++;\n\
    \            count_list.Add(count);\n        }\n        int max_count = count_list.Max();\n\
    \        int min_count = count_list.Min();\n        int strength = (max_count\
    \ - min_count);\n        if (strength > 0) {\n            List<string> exts =\
    \ new List<string>();\n            foreach (string e in extensions) {\n      \
    \          string ext = e.Replace(\"_\", \"\");\n                int count = 0;\n\
    \                foreach (char c in ext) \n                    if (char.IsUpper(c))\
    \ \n                        count++;\n                if (count == cap) \n   \
    \                 exts.Add(e);\n                else if (count == sm) \n     \
    \               exts.Add(e.Replace(\"_\", \"\"));\n            }\n           \
    \ if (exts.Count == 1) {\n                retval = \"Class.\" + class_name + \"\
    .\" + exts[0];\n            } else if (exts.Count > 1) {\n                string\
    \ first;\n                string second;\n                if (exts.Count > 2)\
    \ \n                    first = exts[0];\n                else\n             \
    \       first = exts[1];\n                bool ok = true;\n                for\
    \ (int i = 1; i < exts.Count; i++) {\n                    if (exts[i] != first\
    \ \n                        && exts[i - 1] == exts[i]) \n                    \
    \    ok = false;\n                }\n                if (ok)\n               \
    \     retval = class_name + \".\" + first;\n                else {\n         \
    \           retval = \"Class.\" + class_name + \".\" + exts[0];\n            \
    \    }\n            }\n        }\n        return retval;", "        string extension\
    \ = class_name;\n        string extension_strength = extensions[extensions.Count()\
    \ - 1];\n        string strongest = class_name + \".\" + extension;\n        bool\
    \ change = true;\n        int counter = 0;\n        while (counter < extensions.Count())\
    \ {\n            change = true;\n            counter++;\n            if (class_name.Equals(extensions[extensions.Count()\
    \ - counter])) {\n                change = false;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1];\n                    if (temp.Length > extension_strength.Length)\n  \
    \                      extension_strength = temp;\n                }\n       \
    \     }\n            if (change) {\n                counter++;\n             \
    \   change = true;\n                if (class_name.Equals(extensions[extensions.Count()\
    \ - counter - 1])) {\n                    change = false;\n                  \
    \  string temp = class_name + \".\" + extensions[extensions.Count() - counter\
    \ - 1]", "        var extension_strength = extensions.Select(x => x.ToLowerInvariant())\n\
    \                                      .ToArray();\n        int max_index = -1;\n\
    \        for (int i = 0; i < extension_strength.Length; i++) {\n            if\
    \ (extension_strength[i] != extension_strength[max_index]) {\n               \
    \ for (int j = i+1; j < extension_strength.Length; j++) {\n                  \
    \  int index = extension_strength[j].ToLowerInvariant()\n                    \
    \    .IndexOf(extension_strength[i].ToLowerInvariant());\n                   \
    \ if (index >= 0) {\n                        max_index = j;\n                \
    \        break;\n                    }\n                }\n            }\n   \
    \     }\n        if (max_index < 0) return class_name;\n        var max_strength\
    \ = extensions.IndexOf(extensions[max_index]);\n        string extension = extensions[max_index];\n\
    \        if (extensions.Count(x => x.ToLowerInvariant() == extension.ToLowerInvariant())\
    \ >\n            extensions.Count(x => x.ToLowerInvariant() == extension_strength[max_index]))\
    \ {\n            extension = extensions[max_strength];\n        }\n        return\
    \ class_name + \".\" + extension;", "        int CAP = 0;\n        int SM = 0;\n\
    \        for(int i = 0; i < extensions.Count; i++) {\n            if(extensions[i].Length\
    \ > CAP) {\n                CAP = extensions[i].Length;\n            }\n     \
    \       if(extensions[i].Length < SM) {\n                SM = extensions[i].Length;\n\
    \            }\n        }\n        double Strength = (CAP - SM) / CAP;\n     \
    \   List<string> SortedExtensions = new List<string>(extensions);\n        SortedExtensions.Sort();\n\
    \        int NumOfExtensions = SortedExtensions.Count;\n        int i;\n     \
    \   for(i = 0; i < NumOfExtensions; i++) {\n            if((SortedExtensions[i].Length\
    \ == CAP) && (SortedExtensions[i].Length < SM)) {\n                return class_name\
    \ + SortedExtensions[i];\n            }\n            if((SortedExtensions[i].Length\
    \ == SM) && (SortedExtensions[i].Length < CAP)) {\n                return class_name\
    \ + SortedExtensions[i];\n            }\n        }\n        for(i = 0; i < NumOfExtensions;\
    \ i++) {\n            if((SortedExtensions[i].Length == SM) && (SortedExtensions[i].Length\
    \ == CAP)) {\n                return class_name + SortedExtensions[i];\n     \
    \       }\n        }\n        return \"-1\";", "        // Initialize an empty\
    \ dictionary for the extensions used in the class\n        Dictionary<string,\
    \ int> extensions_used = new Dictionary<string, int>();\n        // Initialize\
    \ a variable that holds the strongest extension found so far\n        string strongest\
    \ = \"\";\n        // Iterate over the extensions in the list\n        foreach\
    \ (string extension in extensions) {\n            // Get the number of capital\
    \ letters in the extension\n            int capitals = extension.Count(x => x\
    \ == (char)(x >> 64));\n            // Get the number of lowercase letters in\
    \ the extension\n            int lowercases = extension.Count(x => x == (char)(x\
    \ >> 48));\n            // The strength of the extension is the fraction CAP -\
    \ SM\n            int strength = capitals - lowercases;\n            // If the\
    \ extension is already in the dictionary, just increment the count\n         \
    \   if (extensions_used.ContainsKey(extension))\n                extensions_used[extension]\
    \ = extensions_used[extension] + 1;\n            // Otherwise, if this new extension's\
    \ strength is better than the strongest,\n            // then update both the\
    \ strongest and the extensions_used variables\n            else if (strength >\
    \ extensions_used[strongest])\n                strongest = extension;\n      \
    \      else\n                extensions_used[strongest] = extensions_used[strongest]\
    \ + 1;\n        }\n        // Finally, return the class name with the strongest\
    \ extension\n        return class_name + \".\" + strongest;", "        // Your\
    \ code goes here.\n        var extension_dictionary = new Dictionary<string, int>();\n\
    \        foreach (var extension in extensions) {\n            var split_extension\
    \ = extension.Split(' ');\n            var count_upper = split_extension.Count(item\
    \ => item.Length > 0);\n            var count_lower = split_extension.Count(item\
    \ => item.Length < 1);\n            var strength = count_upper - count_lower;\n\
    \            extension_dictionary.Add(split_extension[0] + \".\" + split_extension[1],\
    \ strength);\n        }\n\n        if (extension_dictionary.Count > 1) {\n   \
    \         var sorted_extensions = extension_dictionary.OrderBy(a => a.Value).ToList();\n\
    \            return class_name + sorted_extensions.First().Key;\n        }\n \
    \       return class_name + extension_dictionary.First().Key;", "        var extensions_sorted\
    \ = extensions.OrderBy(x => GetStrongest(x, class_name, extensions));\n      \
    \  var strongest_extension = extensions_sorted.FirstOrDefault();\n        return\
    \ strongest_extension;", "        double maxStrength = 0;\n        string maxStrongestExtension\
    \ = null;\n        string maxStrongestExtensionName = null;\n\n        // Your\
    \ code here!\n        foreach (string extension in extensions) {\n           \
    \ double extensionStrength = 0;\n            string extensionName = null;\n  \
    \          foreach (char c in extension) {\n                int letter = Convert.ToInt32(c);\n\
    \                extensionStrength += (letter - 64) * letter;\n            }\n\
    \            if (extensionStrength > maxStrength) {\n                maxStrength\
    \ = extensionStrength;\n                extensionName = extension;\n         \
    \       maxStrongestExtensionName = extensionName;\n            }\n        }\n\
    \n        return string.Concat(class_name, \".\", maxStrongestExtensionName);",
  "        // Initialize array where extensions are sorted by strength\n        int[]\
    \ sorted = new int[extensions.Count];\n\n        // Sort extensions by strength\n\
    \        extensions.Sort((x, y) => CompareExtensions(x, y));\n\n        // Initialize\
    \ empty string\n        string result=string.Empty;\n\n        // Initialize counter\n\
    \        int counter=0;\n\n        // Iterate through extensions until only 1\
    \ extension is left\n        foreach (string ext in extensions) {\n          \
    \  // If this is the first extension, set the strength to -1\n            if (counter==0)\
    \ {\n                sorted[counter] = -1;\n            }\n            // Check\
    \ if current extension is equal to extension from the sorted array\n         \
    \   if (ext==extensions[counter]) {\n                // If this is the strongest\
    \ extension, return the class name and the extension\n                if (sorted[counter]==-1)\
    \ {\n                    return class_name.ToString() + \".\" + ext;\n       \
    \         }\n                // If extension's strength is lower than the strongest\
    \ extension so far, update strongest extension so far\n                else if\
    \ (sorted[counter]<0) {\n                    sorted[counter] = -1;\n         \
    \       }\n            }\n            // If extension is lower then the current\
    \ strongest extension, set strength of this extension\n            else if (sorted[counter]<0)\
    \ {\n                sorted[counter] = ext.Length;\n            }\n\n        \
    \    // Increment counter\n            counter++;\n        }\n\n        // If\
    \ extensions array has only 1 extension, return it and do not return any class\
    \ name since there is no class name to return\n        if (counter==1) {\n   \
    \         return extensions[0];\n        }\n        // If extensions array has\
    \ more extensions than 1, find out which extension is the strongest extension\n\
    \        else if (counter>1) {\n            // Initialize extension name\n   \
    \         string strongest = extensions[0];\n\n            // Iterate through\
    \ extensions until only 1 extension is left\n            counter=0;\n        \
    \    foreach (string ext in extensions) {\n                // If extension's strength\
    \ is higher than the current strongest extension so far, update strongest extension\n\
    \                if (sorted[counter]>0) {\n                    strongest = ext;\n\
    \                }\n                // If extension's strength is lower than the\
    \ strongest extension so far, update strongest extension so far\n            \
    \    else if (sorted[counter]<0) {\n                    strongest = ext;\n   \
    \             }\n\n                // Increment counter\n                counter++;\n\
    \            }\n\n            // Return the strongest extension\n            return\
    \ strongest;\n        }\n\n        // If the extensions array has 0 or 1 extensions,\
    \ return an empty string\n        return string.Empty;", "        string extension\
    \ = \"\";\n        if (extensions.Count > 1) {\n            extensions = extensions.Distinct().OrderBy(x\
    \ => GetStrength(class_name, x)).ToList();\n            if (extensions.Count >\
    \ 1) {\n                extension = extensions.First().ToString();\n         \
    \   }\n        }\n        else {\n            extension = extensions[0];\n   \
    \     }\n        return extension;", "        string extension = extensions[0];\n\
    \        int sm = 0;\n        foreach (string s in extensions) {\n           \
    \ foreach (char c in s) {\n                if (char.IsUpper(c)) {\n          \
    \          sm++;\n                }\n            }\n        }\n        double\
    \ num = extension.Length;\n        double cap = class_name.ToUpper().Length;\n\
    \        double frac = cap - sm;\n        double result = num / frac;\n      \
    \  if (result == 0) {\n            string s = extension;\n            while (s.Contains(\"\
    .\"))\n                s = s.Substring(s.IndexOf(\".\") + 1);\n            extension\
    \ = s;\n            result = extension.Length;\n        }\n        return class_name\
    \ + \".\" + extension;", "        // Write your code here\n        HashSet<string>\
    \ set = new HashSet<string>(extensions.Select(x => x.ToUpperInvariant()));\n \
    \       int max = 0;\n        string maxStr = \"\";\n        foreach (string ext\
    \ in extensions) {\n            int value = ext.ToUpperInvariant().Count(x =>\
    \ x >= 'A' && x <= 'Z');\n            if (value > max)\n            {\n      \
    \          max = value;\n                maxStr = ext;\n            }\n      \
    \  }\n        return class_name + \".\" + maxStr;", "        string strongest_extension\
    \ = class_name;\n        if (extensions.Count > 0) {\n            double max_strength\
    \ = -1;\n            foreach (string extension in extensions) {\n            \
    \    double extension_strength = GetExtensionStrength(extension);\n          \
    \      if (extension_strength > max_strength) {\n                    strongest_extension\
    \ = extension;\n                    max_strength = extension_strength;\n     \
    \           }\n            }\n        }\n        return strongest_extension;",
  "        if (extensions.Count == 0) return \"\";\n        int[] counts = new int[26];\n\
    \        char[] alphabet = Enumerable.Range(0,26).Select(i => (char)('a' + i)).ToArray();\n\
    \        foreach (string extension in extensions) {\n            for (int i =\
    \ 0; i < extension.Length; i++) {\n                counts[alphabet[(int)extension[i]-'a']]\
    \ += 1;\n            }\n        }\n        int max = int.MinValue;\n        int\
    \ max_index = -1;\n        for (int i = 0; i < 26; i++) {\n            if (counts[i]\
    \ > max) {\n                max = counts[i];\n                max_index = i;\n\
    \            }\n        }\n        return class_name + \".\" + Enumerable.Range(0,26).Select(i\
    \ => (char)('a' + i)).Where(x => counts[max_index] == max).FirstOrDefault();",
  "        int[] arr = new int[extensions.Count];\n        for(int i = 0; i < extensions.Count;\
    \ i++) {\n            arr[i] = ExtensionToStrength(extensions[i]);\n        }\n\
    \        int max = arr.Max();\n        if(max == 0) return class_name;\n     \
    \   int index = Array.FindIndex(arr, e => e == max);\n        int strength = arr[index];\n\
    \        if(strength > 0) {\n            return class_name + \".\" + extensions[index];\n\
    \        }\n        else {\n            int i = 1;\n            string temp =\
    \ \".\";\n            while(i < strength) {\n                temp = temp + \"\
    x\";\n                i++;\n            }\n            return class_name + temp;\n\
    \        }", "        Dictionary<int, string> strongest = new Dictionary<int,\
    \ string>();\n        foreach (var extension in extensions) {\n            int\
    \ strongestValue = 0;\n            int index = -1;\n            foreach (char\
    \ c in extension) {\n                index++;\n                if (char.IsUpper(c))\
    \ {\n                    strongestValue += index * 25;\n                }\n  \
    \              if (char.IsLower(c)) {\n                    strongestValue += 25;\n\
    \                }\n            }\n            if (strongestValue.Equals(0)) {\n\
    \                strongestValue.Equals(0);\n            }\n            if (strongestValue.Equals(class_name.Length))\
    \ {\n                strongestValue.Equals(class_name.Length);\n            }\n\
    \            strongestValue--;\n            if (!strongestValue.Equals(0)) {\n\
    \                strongest.Add(strongestValue, extension);\n            }\n  \
    \      }\n        string strongestKey = null;\n        if (strongest.Keys.ToList().Count\
    \ > 1) {\n            int max = 0;\n            for (int i = 1; i < strongest.Keys.Count;\
    \ i++) {\n                if (strongest[i].Equals(strongest[max])) {\n       \
    \             max = i;\n                }\n            }\n            strongestKey\
    \ = strongest[max];\n        } else {\n            strongestKey = strongest[strongest.Keys.First()];\n\
    \        }\n        return class_name + \".\" + strongestKey;", "        if (extensions.Count()\
    \ == 0) return class_name;\n        double max_strength = extensions.Max(x =>\
    \ x.Replace(class_name.Length, 0) - x.Replace(class_name.Length - class_name.Replace(class_name.Substring(0,\
    \ class_name.Length - 1).Last(), string.Empty).Length));\n        extensions =\
    \ extensions.Where(x => x.Replace(class_name.Length, 0) - x.Replace(class_name.Length\
    \ - class_name.Replace(class_name.Substring(0, class_name.Length - 1).Last(),\
    \ string.Empty).Length) == max_strength).OrderBy(x => x.Replace(class_name.Length,\
    \ 0) - x.Replace(class_name.Length - class_name.Replace(class_name.Substring(0,\
    \ class_name.Length - 1).Last(), string.Empty).Length)).ToList();\n        if\
    \ (extensions.Count() > 0) return class_name + extensions[0];\n        else return\
    \ class_name;", "        // Create a dictionary to hold a count of each extension:\n\
    \        var count = new Dictionary<string, int>();\n        // Create a dictionary\
    \ to hold the extensions:\n        var extensions_dict = new Dictionary<string,\
    \ string>();\n\n        // Loop through the extensions:\n        foreach (var\
    \ extension in extensions) {\n            // Get the number of uppercase letters\
    \ in the extension:\n            var count_upppercase = extension.Count(x => char.IsUpper(x));\n\
    \            // Get the number of lowercase letters in the extension:\n      \
    \      var count_lowercase = extension.Count(x => char.IsLower(x));\n        \
    \    // Get the fraction of the uppercase letters in the extension:\n        \
    \    var frac = count_upppercase / extension.Count;\n            // Add the extension:\n\
    \            extensions_dict[extension] = extension;\n\n            // Increment\
    \ the count\n            count[extension] = count_upppercase;\n\n            //\
    \ If the count is greater than zero, return the extension\n            // with\
    \ the greatest count:\n            if (count_upppercase > 0) {\n             \
    \   return class_name + \".\" + extensions_dict[extension];\n            }\n \
    \       }\n\n        // Return the first extension (with the greatest count) that\
    \ appears\n        // first in the list:\n        foreach (var extension in extensions)\
    \ {\n            if (count[extension] > 0) {\n                return class_name\
    \ + \".\" + extensions_dict[extension];\n            }\n        }\n\n        //\
    \ If there are no extensions with the greatest count, return \n        // the\
    \ empty string:\n        return \"\";", "        // This array keeps track of\
    \ the strength level of each extension\n        // The strength level starts as\
    \ -1 (no strength)\n        var extension_strengths = new int[extensions.Count];\n\
    \n        // Go through the extensions\n        for (int i = 0; i < extensions.Count;\
    \ i++) {\n            // Get the extension's name\n            var extension_name\
    \ = extensions[i];\n\n            // Get the number of uppercase letters in extension_name\n\
    \            var num_uppercase_letters = extension_name.ToUpper().Count(c => c\
    \ == 'A');\n\n            // Get the number of lowercase letters in extension_name\n\
    \            var num_lowercase_letters = extension_name.ToLower().Count(c => c\
    \ == 'a');\n\n            // Get the fraction of uppercase letters in extension_name\n\
    \            var frac = num_uppercase_letters - num_lowercase_letters;\n\n   \
    \         // If the extension_strengths array already has an entry for the extension,\n\
    \            // add its strength to the existing entry \n            if (extension_strengths[i]\
    \ >= 0) {\n                // If the extension_strengths array already has an\
    \ entry for the extension,\n                // add its strength to the existing\
    \ entry \n                extension_strengths[i] += frac;\n            }\n   \
    \         else {\n                // If the extension_strengths array does not\
    \ have an entry for the extension,\n                // add a new entry \n    \
    \            extension_strengths[i] = frac;\n            }\n        }\n\n    \
    \    // Sort extension_strengths descending, so that we find the strongest extension\n\
    \        Array.Sort(extension_strengths);\n\n        // Find the strongest extension\
    \ in extension_strengths\n        int strongest_extension = extension_strengths.FirstOrDefault(x\
    \ => x >= 0);\n\n        // If strongest_extension is -1, there are no extensions\
    \ with strength >= 0\n        if (strongest_extension == -1) {\n            //\
    \ Find the strongest extension in extension_strengths\n            strongest_extension\
    \ = extension_strengths.LastOrDefault(x => x >= 0);\n        }\n\n        // Return\
    \ the name of the class with this extension\n        return class_name + \".\"\
    \ + extensions[extension_strengths.IndexOf(strongest_extension)];", "        var\
    \ extension_strongest = new List<string>();\n        foreach (var extension in\
    \ extensions) {\n            var extension_strength = extension.Length;\n    \
    \        var class_strongest = new List<string>();\n            foreach (var c\
    \ in extension.ToLowerInvariant()) {\n                if (char.IsUpper(c)) class_strongest.Add(c);\n\
    \                else if (char.IsLower(c)) class_strongest.Add('-');\n       \
    \     }\n            if (class_strongest.Count == extension_strength) {\n    \
    \            extension_strongest.Add(class_name + \".\" + String.Join(\"\", class_strongest));\n\
    \            }\n        }\n        return extension_strongest.OrderBy(e => e).First();",
  "        int max_extension_strength = -1;\n        string strongest_extension =\
    \ null;\n        // TODO: Write your code here\n\n        foreach (var extension\
    \ in extensions) {\n            int extension_strength = extension.ToUpper().Count()\
    \ - extension.ToLower().Count();\n            if (extension_strength > max_extension_strength)\
    \ {\n                max_extension_strength = extension_strength;\n          \
    \      strongest_extension = extension;\n            }\n        }\n\n        return\
    \ class_name + \".\" + strongest_extension;", "        int[] cap_counter = new\
    \ int[26];\n        int[] sm_counter = new int[26];\n        for (int i = 0; i\
    \ < extensions.Count; i++) {\n            int cap = extensions[i].Count(c => char.IsUpper(c));\n\
    \            int sm = extensions[i].Count(c => char.IsLower(c));\n           \
    \ int sum = cap + sm;\n            cap_counter[sum - 1]++;\n            sm_counter[sum\
    \ - 1]++;\n        }\n        double max_val = -1;\n        int max_index = -1;\n\
    \        for (int i = 0; i < cap_counter.Length; i++) {\n            if (cap_counter[i]\
    \ > sm_counter[i]) {\n                max_val = cap_counter[i];\n            \
    \    max_index = i;\n            }\n        }\n        return class_name + extensions[max_index];",
  "        // Your code here\n        int CAP = 0;\n        int SM = 0;\n        string\
    \ StrongestExtension = class_name;\n        foreach (string e in extensions) {\n\
    \            if (e.Length > CAP)\n                CAP = e.Length;\n          \
    \  if (e.Length > SM)\n                SM = e.Length;\n        }\n        double\
    \ strength = (CAP - SM) / (double)(CAP);\n        double min = 0;\n        double\
    \ max = 0;\n        string minExt = class_name;\n        foreach (string e in\
    \ extensions) {\n            if (e.Length == CAP) {\n                double x\
    \ = Double.Parse(e) / strength;\n                if (x < min)\n              \
    \      min = x;\n                if (x > max)\n                    max = x;\n\
    \            }\n        }\n        if (min == 0)\n            return StrongestExtension;\n\
    \        if (min > 0)\n            minExt = StrongestExtension + \".\" + extensions[extensions.IndexOf(extensions)];\n\
    \        else if (max < 0)\n            minExt = StrongestExtension + \".\" +\
    \ extensions[0];\n        return minExt;", "        double max = 0;\n        foreach\
    \ (string extension in extensions) {\n            int sm = extension.Length;\n\
    \            int cap = class_name.Length;\n            double fraction = (double)(cap\
    \ - sm) / cap;\n            if (fraction > max) {\n                max = fraction;\n\
    \            }\n        }\n        \n        int index = 0;\n        while (index\
    \ < extensions.Count) {\n            if (max < extensions[index].Length) {\n \
    \               return (class_name + \".\" + extensions[index]);\n           \
    \ }\n            index++;\n        }\n        return class_name + \".\" + extensions[0];",
  "        string extension = extensions[0];\n        string extension_class = class_name.Substring(0,\
    \ class_name.IndexOf(extension) + extension.Length);\n        extension_class\
    \ = extension_class.Substring(0, extension_class.IndexOf('.'));\n        int CAP\
    \ = extension.Count();\n        int SM = extension_class.Count();\n        if\
    \ (CAP - SM == 0) {\n            return class_name + \".\" + extension;\n    \
    \    } else {\n            double strength = Math.Sqrt(CAP - SM);\n          \
    \  List<string> sorted_extensions = extensions.OrderBy(o => o.Length).ToList();\n\
    \            bool found = false;\n            int i = 0;\n            while (!found\
    \ && i < extensions.Count) {\n                string next_extension = extensions[i];\n\
    \                string next_extension_class = class_name.Substring(0, class_name.IndexOf(next_extension)\
    \ + next_extension.Length);\n                next_extension_class = next_extension_class.Substring(0,\
    \ next_extension_class.IndexOf('.'));\n                int next_CAP = next_extension.Count();\n\
    \                int next_SM = next_extension_class.Count();\n               \
    \ if (next_CAP - next_SM == 0) {\n                    string next_extension_class_name\
    \ = extension_class + \".\" + next_extension;\n                    if (next_extension_class_name.Equals(class_name\
    \ + \".\" + next_extension)) {\n                        found = true;\n      \
    \              } else {\n                        strength = strength - Math.Sqrt(next_CAP\
    \ - next_SM);\n                        i += 1;\n                    }\n      \
    \          } else {\n                    double next_strength = Math.Sqrt(next_CAP\
    \ - next_SM);\n                    if (next_strength > strength) {\n         \
    \               strength = next_strength;\n                        extension =\
    \ next_extension;\n                        extension_class = next_extension_class;\n\
    \                    }\n                    i += 1;\n                }\n     \
    \       }\n            if (found) {\n                return extension_class +\
    \ \".\" + extension;\n            } else {\n                return class_name\
    \ + \".\" + extension;\n            }\n        }", "        int cap = class_name.ToUpper().Count()\
    \ - class_name.ToLower().Count();\n        int sm = class_name.ToLower().Count()\
    \ - class_name.ToUpper().Count();\n        int fraction = cap - sm;\n\n      \
    \  return class_name + extensions[extensions.IndexOf(extensions[extensions.FindIndex(e\
    \ => e.Substring(0,1).ToUpper().Equals(class_name.ToUpper()) ? cap : sm)].Substring(0,1).ToUpper())];",
  "        var caps = new int[256];\n        var smas = new int[256];\n        var\
    \ max = int.MinValue;\n        foreach (var extension in extensions) {\n     \
    \       int cap = 0;\n            int sm = 0;\n            foreach (var c in extension)\
    \ {\n                if (c == 'A') cap++;\n                if (c == 'b') cap++;\n\
    \                if (c == 'C') cap++;\n                if (c == 'd') cap++;\n\
    \                if (c == 'e') cap++;\n                if (c == 'F') cap++;\n\
    \                if (c == 'G') cap++;\n                if (c == 'H') cap++;\n\
    \                if (c == 'I') cap++;\n                if (c == 'j') cap++;\n\
    \                if (c == 'k') cap++;\n                if (c == 'L') cap++;\n\
    \                if (c == 'm') cap++;\n                if (c == 'N') cap++;\n\
    \                if (c == 'O') cap++;\n                if (c == 'p') cap++;\n\
    \                if (c == 'q') cap++;\n                if (c == 'r') cap++;\n\
    \                if (c == 's') cap++;\n                if (c == 'T') cap++;\n\
    \                if (c == 'u') cap++;\n                if (c == 'V') cap++;\n\
    \                if (c == 'w') cap++;\n                if (c == 'x') cap++;\n\
    \                if (c == 'y') cap++;\n                if (c == 'Z') cap++;\n\
    \            }\n            int s = extension.Length;\n            for (var i\
    \ = 0; i < cap; i++) {\n                caps[i] += s;\n            }\n       \
    \     for (var i = 0; i < sm; i++) {\n                smas[i] += s;\n        \
    \    }\n            if (cap > max) {\n                max = cap;\n           \
    \ }\n            if (sm > max) {\n                max = sm;\n            }\n \
    \       }\n        int[] caps2 = caps.OrderByDescending(x => x).ToArray();\n \
    \       int[] smas2 = smas.OrderByDescending(x => x).ToArray();\n        int i\
    \ = caps2.Length - 1;\n        int j = smas2.Length - 1;\n        while (i >=\
    \ 0 && j >= 0) {\n            if (caps2[i] == 0 && smas2[j] == 0) {\n        \
    \        return class_name + \".\" + extensions[j];\n            }\n         \
    \   if (caps2[i] != 0 && smas2[j] != 0) {\n                double caps = caps2[i]\
    \ / (double)caps2[i];\n                double smas = smas2[j] / (double)smas2[j];\n\
    \                if (caps > smas) {\n                    return class_name + \"\
    .\" + extensions[j];\n                }\n            }\n            if (caps2[i]\
    \ == 0 && smas2[j] != 0) {\n                return class_name + \".\" + extensions[j];\n\
    \            }\n            if (caps2[i] != 0 && smas2[j] == 0) {\n          \
    \      return class_name + ", "        // Write your code here.\n        string\
    \ extension_class_name = \"\";\n        double extension_strength = -1.0;\n  \
    \      double total_strength = 0;\n        double total_percentage = 0;\n    \
    \    for(int i=0; i<extensions.Count; i++) {\n            string extension_class_name\
    \ = extensions[i].Split(new char[]{'.'})[0];\n            extension_strength =\
    \ (Double.Parse(extensions[i].Split(new char[]{'.'})[1].Replace(\"Str\", \"\"\
    ))*-1);\n            total_strength = total_strength + extension_strength;\n \
    \           total_percentage = total_percentage + (extension_strength*100)/total_strength;\n\
    \        }\n        bool found = false;\n        for(int i=0; i<extensions.Count;\
    \ i++) {\n            string extension_class_name = extensions[i].Split(new char[]{'.'})[0];\n\
    \            extension_strength = (Double.Parse(extensions[i].Split(new char[]{'.'})[1].Replace(\"\
    Str\", \"\"))*-1);\n            if(extension_strength == total_strength) {\n \
    \               found = true;\n                break;\n            }\n       \
    \ }\n        if (total_percentage < 0.1 && extensions.Count>1){\n            for(int\
    \ i=0; i<extensions.Count; i++) {\n                string extension_class_name\
    \ = extensions[i].Split(new char[]{'.'})[0];\n                extension_strength\
    \ = (Double.Parse(extensions[i].Split(new char[]{'.'})[1].Replace(\"Str\", \"\"\
    ))*-1);\n                if(extension_strength < total_strength) {\n         \
    \           found = false;\n                    break;\n                }\n  \
    \          }\n        }\n        \n        if (found){\n            return class_name\
    \ + \".\" + extension_class_name;\n        }\n        else{\n            return\
    \ class_name;\n        }", "        if (extensions.Count == 0) throw new Exception(\"\
    List of extensions is empty.\");\n        var res = extensions.OrderByDescending(x\
    \ => x.Count).First().Split('').Select(x => x.ToUpper()).ToList();\n        return\
    \ class_name + \".\" + res.ToArray().OrderByDescending(x => x).First();", "  \
    \      var sortedList = extensions.OrderBy(x => x.ToUpperInvariant()).ToList();\n\
    \        int upperCaseLetterCount = sortedList.Where(x => x.ToUpperInvariant().Equals(x.ToLowerInvariant()))\n\
    \            .Count();\n        int lowerCaseLetterCount = sortedList.Where(x\
    \ => x.ToLowerInvariant().Equals(x.ToLowerInvariant()))\n            .Count();\n\
    \        var strength = upperCaseLetterCount - lowerCaseLetterCount;\n       \
    \ if (strength == 0) return class_name;\n        else return $\"{class_name}.{sortedList[0].ToUpperInvariant()}{strength}\"\
    ;", "        int CAP = class_name.Length;\n        int SM = extensions.Count;\n\
    \        double strength = Math.Sqrt(CAP-SM);\n        int SM_C = SM/CAP;\n  \
    \      int SM_S = SM%CAP;\n        double strength_C = Math.Sqrt(CAP-SM_C);\n\
    \        int strength_S = Math.Sqrt(CAP-SM_S);\n        int SM_M = SM-(SM_C*CAP);\n\
    \        double strength_M = Math.Sqrt(CAP-SM_M);\n        int SM_L = SM-(SM_S*CAP);\n\
    \        double strength_L = Math.Sqrt(CAP-SM_L);\n        int SM_P = SM-(SM_M*CAP);\n\
    \        double strength_P = Math.Sqrt(CAP-SM_P);\n        int SM_S = SM-(SM_L*CAP);\n\
    \        double strength_S = Math.Sqrt(CAP-SM_S);\n        int SM_C = SM-(SM_P*CAP);\n\
    \        double strength_C = Math.Sqrt(CAP-SM_C);\n        int SM_M = SM-(SM_S*CAP);\n\
    \        double strength_M = Math.Sqrt(CAP-SM_M);\n        int SM_L = SM-(SM_C*CAP);\n\
    \        double strength_L = Math.Sqrt(CAP-SM_L);\n        int SM_P = SM-(SM_M*CAP);\n\
    \        double strength_P = Math.Sqrt(CAP-SM_P);\n        int SM_C = SM-(SM_L*CAP);\n\
    \        double strength_C = Math.Sqrt(CAP-SM_C);\n        int SM_M = SM-(SM_P*CAP);\n\
    \        double strength_M = Math.Sqrt(CAP-SM_M);\n        int SM_L = SM-(SM_S*CAP);\n\
    \        double strength_L = Math.Sqrt(CAP-SM_L);\n        int SM_P = SM-(SM_C*CAP);\n\
    \        double strength_P = Math.Sqrt(CAP-SM_P);\n        int SM_S = SM-(SM_M*CAP);\n\
    \        double strength_S = Math.Sqrt(CAP-SM_S);\n        int SM_C = SM-(SM_L*CAP);\n\
    \        double strength_C = Math.Sqrt(CAP-SM_C);\n        int SM_M = SM-(SM_P*CAP);\n\
    \        double strength_M = Math.Sqrt(CAP-SM_M);\n        int SM_L = SM-(SM_S*CAP);\n\
    \        double strength_L = Math.Sqrt(CAP-SM_L);\n        int SM_P = SM-(SM_C*CAP);\n\
    \        double strength_P = Math.Sqrt(CAP-SM_P", "        string result = \"\
    Unknown\";\n        int maximum = 0;\n        foreach (string extension in extensions)\
    \ {\n            int strength = GetExtensionStrength(extension);\n           \
    \ int strength_of_class = GetClassStrength(class_name);\n            if (strength\
    \ > maximum) {\n                result = extension;\n                maximum =\
    \ strength;\n            }\n        }\n        return result;", "        string\
    \ result = class_name;\n        // Your code goes here.\n        double cap =\
    \ class_name.ToUpper().Count(x => x != '_');\n        double sm = class_name.ToLower().Count(x\
    \ => x != '_');\n        double total = (cap - sm);\n        if (total != 0) {\n\
    \            double strongest = total / extensions[extensions.FindIndex(x => x.ToUpper().Count(x\
    \ => x != '_') == cap)].ToUpper().Count(x => x != '_');\n            if (strongest\
    \ > 0)\n                result = class_name + extensions[extensions.FindIndex(x\
    \ => x.ToUpper().Count(x => x != '_') == cap)].ToUpper().Substring(0, extensions[extensions.FindIndex(x\
    \ => x.ToUpper().Count(x => x != '_') == cap)].ToUpper().IndexOf('.')) + '.' +\
    \ extensions[extensions.FindIndex(x => x.ToUpper().Count(x => x != '_') == cap)].ToUpper().Substring(extensions[extensions.FindIndex(x\
    \ => x.ToUpper().Count(x => x != '_') == cap)].ToUpper().IndexOf('.') + 1);\n\
    \        }\n        return result;", "        string extensions_sorted = extensions.OrderBy(ext\
    \ => ext.ToUpperInvariant()).ToList();\n        double extensions_strength = 0;\n\
    \        for(int i = 0; i < extensions_sorted.Count; i++) {\n            extensions_strength\
    \ += System.Math.Abs((extensions_sorted[i].Length - (class_name.ToUpperInvariant().Count(x\
    \ => char.IsUpper(x)))) - (class_name.ToLowerInvariant().Count(x => char.IsLower(x))));\n\
    \        }\n        extensions_strength = Math.Abs(extensions_strength);\n   \
    \     return class_name + \".\" + extensions_sorted.FirstOrDefault(ext => extensions_strength\
    \ == extensions_sorted.IndexOf(ext))?.ToUpperInvariant();", "        // Your code\
    \ goes here\n        string str = class_name.ToLower().Replace(\" \", \"\");\n\
    \        char[] cap = class_name.ToLower().Replace(\" \", \"\").ToCharArray().Where(x\
    \ => x.ToString().ToUpper() != x).ToArray();\n        char[] sm = class_name.ToLower().Replace(\"\
    \ \", \"\").ToCharArray().Where(x => x.ToString().ToLower() != x).ToArray();\n\
    \        int i = cap.Count(x => x == char.ToUpper(x));\n        int j = sm.Count(x\
    \ => x == char.ToLower(x));\n        int n = cap.Length - sm.Length;\n       \
    \ int capCount = cap.Count(x => x == char.ToUpper(x));\n        int smCount =\
    \ sm.Count(x => x == char.ToLower(x));\n        double strength;\n        string\
    \ ext;\n        int max = 0;\n        List<string> maxStrList = new List<string>();\n\
    \        bool isStrong;\n        double maxStrong = 0;\n        foreach (string\
    \ ex in extensions) {\n            isStrong = false;\n            strength = capCount\
    \ - smCount;\n            ext = ex.Replace(\" \", \"\");\n            if (ex ==\
    \ class_name || ex == \"\") {\n                continue;\n            }\n    \
    \        foreach (char c in ext) {\n                if (str == c) {\n        \
    \            isStrong = true;\n                    break;\n                }\n\
    \            }\n            if (isStrong) {\n                double a = cap.Count(x\
    \ => x == char.ToUpper(x));\n                double b = sm.Count(x => x == char.ToLower(x));\n\
    \                double c = cap.Length - sm.Length;\n                double d\
    \ = (a + b) / 2;\n                if (strength > maxStrong) {\n              \
    \      max = strength;\n                    maxStrong = strength;\n          \
    \          maxStrList.Clear();\n                    maxStrList.Add(ex);\n    \
    \            }\n                if (strength == maxStrong) {\n               \
    \     if (d > max) {\n                        max = d;\n                     \
    \   maxStrong = strength;\n                        maxStrList.Clear();\n     \
    \                   maxStrList.Add(ex);\n                    }\n             \
    \   }\n            }\n        }\n        if (maxStrList.Count == 1) {\n      \
    \      ext = maxStrList[0];\n        }\n        else {\n            int a = 0;\n\
    \            string str = \"\";\n            foreach (string ex in maxStrList)\
    \ {\n                str = \"\";\n                for (int i = 0; i < ex.length;\
    \ i++) {\n                    str += (ex[i]);\n                }\n           \
    \     for (int i = 0; i < str.length; i++) {\n                    if (str[i] ==\
    \ str[i]) {\n                        a++;\n                    }\n           \
    \     }\n            }\n            if (a > maxStrList.Count) {\n            \
    \    ext = \"\";\n            }", '        // Your code here', "        int CAP\
    \ = 0;\n        int SM = 0;\n        foreach (string extension in extensions)\n\
    \        {\n            CAP += extension.Length;\n            SM = extension.Length;\n\
    \        }\n        decimal Strength = (decimal)CAP / (decimal)SM;\n        List<string>\
    \ extensions_sorted = extensions.OrderBy(o => Strength).ToList();\n        if\
    \ (extensions_sorted.Count < 2)\n        {\n            return class_name + extensions_sorted[0];\n\
    \        }\n        else\n        {\n            return class_name + extensions_sorted[0]\
    \ + extensions_sorted[1];\n        }", "        if (extensions.Count() == 0) return\
    \ class_name;\n        int[] nums = new int[26];\n        int nums_cnt = 0;\n\
    \        foreach (string extension in extensions) {\n            string s = extension;\n\
    \            foreach (char c in s) {\n                if (char.IsUpper(c)) {\n\
    \                    nums[(int)c - 'A']++;\n                    nums_cnt++;\n\
    \                }\n            }\n        }\n        List<int> sorted_nums =\
    \ nums.OrderByDescending(i => i).ToList();\n        int idx = sorted_nums.Count()\
    \ - 1;\n        int strongest_extension = -1;\n        bool found = false;\n \
    \       for (int i = sorted_nums.Count()-1; i > idx; i--) {\n            if (sorted_nums[i]\
    \ == sorted_nums[idx]) {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (found) {\n            return class_name\
    \ + \".\" + extensions[idx];\n        }\n        for (int i = sorted_nums.Count()-1;\
    \ i > sorted_nums.Count()-nums_cnt; i--) {\n            if (sorted_nums[i] ==\
    \ sorted_nums[idx]) {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (found) {\n            return class_name\
    \ + \".\" + extensions[idx];\n        }\n        string ext = \"\";\n        foreach\
    \ (char c in class_name) {\n            if (char.IsUpper(c)) {\n             \
    \   ext = \"A\" + ext;\n            } else if (char.IsLower(c)) {\n          \
    \      ext = \"a\" + ext;\n            }\n        }\n        return class_name\
    \ + \".\" + ext;", "        // Write your code here.\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach (string s in extensions)\n        {\n   \
    \         int c = s.Length;\n            if (char.IsUpper(s[0]))\n           \
    \     cap++;\n            if (char.IsLower(s[0]))\n                sm++;\n   \
    \     }\n        double strength = cap - sm;\n        Debug.WriteLine(\"Cap: \"\
    \ + cap + \" Sm: \" + sm + \" Strength: \" + strength);\n        if (strength\
    \ > 0)\n            return class_name + \".\" + extensions.OrderByDescending(s\
    \ => s).First();\n        else\n            return class_name + \".\" + extensions.OrderByDescending(s\
    \ => s).FirstOrDefault();", "        string strongest_extension = string.Empty;\n\
    \        var class_extensions = new HashSet<string>();\n\n        foreach (string\
    \ extension in extensions) {\n            int num_upper = class_name.IndexOf(extension,\
    \ StringComparison.OrdinalIgnoreCase);\n            if (num_upper > 0) {\n   \
    \             class_extensions.Add(class_name.Substring(num_upper, extension.Length));\n\
    \            }\n        }\n        if (class_extensions.Count > 1) {\n       \
    \     foreach (string class_extension in class_extensions) {\n               \
    \ var fraction = class_extension.Length / class_name.Length;\n               \
    \ if (fraction > 1) {\n                    strongest_extension = class_extension;\n\
    \                }\n            }\n        }\n        if (strongest_extension\
    \ == string.Empty) {\n            return class_name;\n        }\n        return\
    \ class_name + \".\" + strongest_extension;", "        double strongest_extension_strength\
    \ = 0;\n        var class_name_array = class_name.Split('.');\n        foreach\
    \ (var extension in extensions) {\n            double extension_strength = extension.Split('\
    \ ')\n                .Where(x => x.All(c => Char.IsUpper(c)))\n             \
    \   .Where(x => x.All(c => Char.IsLower(c)))\n                .Count();\n    \
    \        if (extension_strength > strongest_extension_strength) {\n          \
    \      strongest_extension_strength = extension_strength;\n            }\n   \
    \     }\n        \n        if (strongest_extension_strength > 0) {\n         \
    \   class_name_array.ToList().Sort();\n            class_name_array.RemoveAt(0);\n\
    \            strongest_extension_strength = class_name_array.Last().ToString();\n\
    \        }\n        return String.Join(\".\", class_name_array);", "        var\
    \ extensions_sorted = extensions.OrderBy(ext => ext.Length).ToList();\n      \
    \  var extensions_count = extensions.Count();\n        int max_strength = -1;\n\
    \        string result;\n        // Find max strength.\n        foreach (var extension\
    \ in extensions_sorted) {\n            var strength = extension.ToUpperInvariant().Count(char.IsUpper);\n\
    \            if (strength > max_strength) {\n                result = class_name\
    \ + \".\" + extension;\n                max_strength = strength;\n           \
    \ } else if (strength == max_strength) {\n                result += \".\" + extension;\n\
    \            }\n        }\n        // If there are more than one extensions with\
    \ the same strength, choose the one that comes first.\n        if (extensions_count\
    \ > 1) {\n            var first_extension = extensions_sorted.First();\n     \
    \       var strength = first_extension.ToUpperInvariant().Count(char.IsUpper);\n\
    \            if (strength == max_strength) {\n                result = class_name\
    \ + \".\" + first_extension;\n            }\n        }\n        return result;",
  "        string result = \"\";\n        int cap = 0;\n        int sm = 0;\n    \
    \    foreach (string ext in extensions) {\n            cap = cap + ext.Count(c\
    \ => c == 'A');\n            sm = sm + ext.Count(c => c == 'a');\n        }\n\
    \        decimal strongest_ext = 0;\n        if (sm == cap) {\n            strongest_ext\
    \ = cap;\n        } else {\n            strongest_ext = (decimal)(cap - sm) /\
    \ cap;\n        }\n        int index = extensions.IndexOf(strongest_ext);\n  \
    \      if (index != -1) {\n            result = class_name.Substring(0, class_name.Length\
    \ - index) + extensions[index];\n        }\n        return result;", "       \
    \ string extension = extensions.OrderByDescending(x => x.Length).First();\n  \
    \      return class_name + extension;", "        double sm = 0;\n        double\
    \ cap = 0;\n        double str = 0;\n        foreach (var item in extensions)\
    \ {\n            string s = item.ToLower();\n            char c = s[0];\n    \
    \        int i = 1;\n            while (i < s.Length) {\n                if (Char.IsUpper(s[i]))\n\
    \                    i++;\n                else\n                    break;\n\
    \            }\n            cap = i - 1;\n            sm = s.Length;\n       \
    \     str = cap - sm;\n            if (str > strongest) {\n                strongest\
    \ = str;\n                bestExtension = item;\n            }\n        }\n  \
    \      return \"{0}.{1}\", class_name, bestExtension;", "        var result =\
    \ \"\";\n        var cap = class_name.Length;\n        var sm = class_name.Replace(class_name.ToLower(),\
    \ \"\").Length;\n        var strength = Math.Abs(cap - sm);\n        extensions.Sort((x,\
    \ y) => (x.Replace(x.ToLower(), \"\").Length.CompareTo(y.Replace(y.ToLower(),\
    \ \"\").Length)));\n        foreach (var ex in extensions)\n        {\n      \
    \      if (ex.Replace(ex.ToLower(), \"\").Length <= cap - sm)\n            {\n\
    \                result = result + class_name + \".\" + ex;\n            }\n \
    \           else if (ex.Replace(ex.ToLower(), \"\").Length > cap - sm)\n     \
    \       {\n                result = result + ex;\n            }\n            else\
    \ if (ex.Replace(ex.ToLower(), \"\").Length == cap - sm)\n            {\n    \
    \            result = result + class_name + \".\" + ex;\n            }\n     \
    \   }\n        return result;", "        int[] c = new int[26];\n        int[]\
    \ s = new int[26];\n        int ccount = 0;\n        int scount = 0;\n       \
    \ foreach(string ext in extensions) {\n            int ca = 0;\n            int\
    \ sa = 0;\n            foreach (char c in ext.ToLower()) {\n                if\
    \ (c >= 'A' && c <= 'Z')\n                    ca++;\n                else\n  \
    \                  sa++;\n            }\n            ccount = (ccount + ca) /\
    \ 2;\n            scount = (scount + sa) / 2;\n            c[c / 2] += 1;\n  \
    \          s[sa / 2] += 1;\n        }\n        int min = Math.Abs(ccount - scount);\n\
    \        foreach(int s in s)\n            min = Math.Min(s, min);\n        for(int\
    \ i = 0; i <= 26; i++)\n            if (c[i] < min)\n                min = 0;\n\
    \        for(int i = 0; i <= 26; i++)\n            if (c[i] > 0)\n           \
    \     if (s[i] > min)\n                    min = 0;\n        for(int i = 0; i\
    \ <= 26; i++)\n            if(c[i] != 0) {\n                if (ccount > min)\n\
    \                    return class_name + \".\" + extensions[ccount - 1];\n   \
    \             else if (scount > min)\n                    return class_name +\
    \ \".\" + extensions[scount - 1];\n            }\n        return class_name;",
  "        extensions = extensions.OrderBy(s => s).ToList();\n        int length =\
    \ class_name.Length;\n        int CAP = length / 2;\n        int SM = length -\
    \ CAP;\n        double strongest = -1;\n        foreach (string extension in extensions)\
    \ {\n            int C = 0;\n            int S = 0;\n            for (int i =\
    \ 0; i < CAP; i++) {\n                if (class_name[i] == extension[i])\n   \
    \                 C++;\n            }\n            for (int i = 0; i < SM; i++)\
    \ {\n                if (class_name[i] == extension[CAP + i])\n              \
    \      S++;\n            }\n            double F = C / CAP;\n            double\
    \ G = S / SM;\n            if (F > G) {\n                strongest = extension;\n\
    \            }\n        }\n        return (class_name + \".\" + strongest);",
  '        // Your code here', "        bool first = true;\n        string strongest\
    \ = null;\n        foreach (string extension in extensions) {\n            if\
    \ (first) {\n                first = false;\n                strongest = extension;\n\
    \                continue;\n            }\n            int extension_strength\
    \ = 0;\n            for (int i = 0; i < extension.Length; i++) {\n           \
    \     if (char.IsUpper(extension[i])) {\n                    extension_strength++;\n\
    \                }\n                else if (char.IsLower(extension[i])) {\n \
    \                   extension_strength--;\n                }\n            }\n\
    \            if (extension_strength > 0) {\n                if (extension_strength\
    \ == strongest.Length) {\n                    continue;\n                }\n \
    \               else if (extension_strength < strongest.Length) {\n          \
    \          strongest = extension;\n                }\n            }\n        \
    \    else {\n                strongest = extension;\n            }\n        }\n\
    \        return class_name + \".\" + strongest;", "        string retval = \"\"\
    ;\n        foreach (string ext in extensions) {\n            char[] cap = ext.ToLower().ToCharArray();\n\
    \            int cap_max = cap.Count();\n            int cap_min = cap.Min();\n\
    \            int sm = ext.Count(c => c == 'z');\n            int sm2 = ext.Count(c\
    \ => c == 'Z');\n            int sm3 = ext.Count(c => c == 'Z' || c == 'z');\n\
    \            int sm4 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'z');\n   \
    \         int sm5 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n\
    \            int sm6 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c ==\
    \ 'Z' || c == 'z');\n            int sm7 = ext.Count(c => c == 'Z' || c == 'Z'\
    \ || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n            int sm8 = ext.Count(c\
    \ => c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c\
    \ == 'z');\n            int sm9 = ext.Count(c => c == 'Z' || c == 'Z' || c ==\
    \ 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n        \
    \    int sm10 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' ||\
    \ c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n            int\
    \ sm11 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z'\
    \ || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n            int\
    \ sm12 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z'\
    \ || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n            int\
    \ sm13 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z'\
    \ || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c == 'z');\n\
    \            int sm14 = ext.Count(c => c == 'Z' || c == 'Z' || c == 'Z' || c ==\
    \ 'Z' || c == 'Z' || c == 'Z' || c == 'Z' || c", "        HashSet<string> strongest\
    \ = new HashSet<string>();\n        foreach (string extension in extensions) {\n\
    \            int num = System.Text.RegularExpressions.Regex.Matches(extension.ToUpper(),\
    \ @\"[A-Z]\").Count - System.Text.RegularExpressions.Regex.Matches(extension.ToLower(),\
    \ @\"[a-z]\").Count;\n            double num2 = System.Text.RegularExpressions.Regex.Matches(extension.ToUpper(),\
    \ @\"[A-Z]\").Count / System.Text.RegularExpressions.Regex.Matches(extension.ToLower(),\
    \ @\"[a-z]\").Count;\n            int num3 = Convert.ToInt32(Math.Floor(num2 *\
    \ 100));\n            string ext = extension.Substring(extension.Length - num);\n\
    \            int strength = (int)Math.Ceiling(num3);\n            if (strongest.Contains(extension))\
    \ {\n                strength += 1;\n            }\n            if (strength >\
    \ 0) {\n                strongest.Add(extension);\n            }\n        }\n\
    \        if (strongest.Count > 0) {\n            return class_name + \"._\" +\
    \ strongest.First();\n        }\n        return \"none\";", "        // Your code\
    \ goes here\n        string name = class_name;\n        string result = \"\";\n\
    \        int count = extensions[0].Length;\n        foreach (string extension\
    \ in extensions) {\n            foreach (char c in extension) {\n            \
    \    if (c >= 'A' && c <= 'Z') {\n                    count += 1;\n          \
    \      } else if (c >= 'a' && c <= 'z') {\n                    count += 1;\n \
    \               }\n            }\n        }\n        double strength = count /\
    \ extensions[0].Length;\n        foreach (string extension in extensions) {\n\
    \            if (strength < extension.Length / extension.Length) {\n         \
    \       result = name + \".\" + extension;\n                break;\n         \
    \   }\n        }\n        return result;", "        List<Tuple<string, int>> extensions_sorted\
    \ = new List<Tuple<string, int>>();\n        foreach (string extension in extensions)\
    \ {\n            string lowercase_extension = extension.ToLower();\n         \
    \   int count_cap = lowercase_extension.Count(c => char.IsUpper(c));\n       \
    \     int count_sm = lowercase_extension.Count(c => char.IsLower(c));\n      \
    \      double strength = (count_cap - count_sm) / (double)count_cap;\n       \
    \     extensions_sorted.Add(new Tuple<string, int>(lowercase_extension, strength));\n\
    \        }\n        extensions_sorted.Sort();\n        var strongest_extension\
    \ = extensions_sorted[0].Item1;\n        foreach (var tuple in extensions_sorted)\
    \ {\n            if (tuple.Item2 < strongest_extension.Count(c => char.IsUpper(c))\n\
    \                && tuple.Item2 < strongest_extension.Count(c => char.IsLower(c)))\
    \ {\n                strongest_extension = tuple.Item1;\n            }\n     \
    \   }\n        return class_name + \".\" + strongest_extension;", "        Dictionary<string,\
    \ int> extensions_counters = new Dictionary<string, int>();\n        // Let's\
    \ first count the frequency of extensions in the list\n        foreach (string\
    \ extension in extensions) {\n            int i = 0;\n            if (extensions_counters.ContainsKey(extension))\n\
    \                i = extensions_counters[extension];\n            else\n     \
    \           i = 1;\n            extensions_counters[extension] = i;\n        }\n\
    \n        // Now that we have a list of extensions and their frequency let's find\
    \ the\n        // strongest one.\n        List<string> strongest_list = new List<string>();\n\
    \        int max_counter = extensions_counters[extensions[0]];\n        string\
    \ max_extension = extensions[0];\n        for (int i = 1; i < extensions.Count;\
    \ i++) {\n            if (extensions_counters[extensions[i]] > max_counter) {\n\
    \                max_extension = extensions[i];\n                max_counter =\
    \ extensions_counters[extensions[i]];\n            }\n            else\n     \
    \           extensions_counters[extensions[i]] = extensions_counters[extensions[i]]\
    \ + 1;\n        }\n        strongest_list.Add(max_extension);\n        string\
    \ new_class;\n        if (max_counter == 0)\n            return class_name + max_extension;\n\
    \        if (max_counter == 1)\n            return class_name + \".\" + max_extension;\n\
    \        for (int i = 0; i < extensions.Count; i++) {\n            if (extensions_counters[extensions[i]]\
    \ > max_counter) {\n                strongest_list.Add(class_name + \".\" + extensions[i]);\n\
    \            }\n        }\n        return new_class;", '        return "";', " \
    \       string strongest_extension = String.Empty;\n\n        foreach (string\
    \ extension in extensions) {\n            int extension_strength = GetStrength(extension);\n\
    \            if (extension_strength > 0) {\n                strongest_extension\
    \ = String.Concat(class_name, \".\", extension);\n                if (extension_strength\
    \ == GetStrength(strongest_extension)) {\n                    return strongest_extension;\n\
    \                }\n            }\n        }\n\n        return strongest_extension;",
  "        // write your code here\n        var letters = class_name.ToUpperInvariant().SelectMany(c\
    \ => c.ToLowerInvariant()).Distinct();\n        var sm = letters.Count() - extensions.Select(e\
    \ => e.ToUpperInvariant().Count()).Sum();\n        return $\"{class_name}.S{Math.Abs(letters.Count()\
    \ - sm)}{extensions[0].ToUpperInvariant()}\"; ", "        var dict = new Dictionary<string,\
    \ int>();\n        var results = new Dictionary<int, string>();\n        foreach\
    \ (var extension in extensions) {\n            int strength = extension.ToLower().Count(c\
    \ => Char.IsUpper(c)) - (extension.ToLower().Count(c => Char.IsLower()));\n  \
    \          if (!dict.ContainsKey(strength)) {\n                dict.Add(strength,\
    \ extension);\n            } else {\n                int index = dict[strength].IndexOf(extension);\n\
    \                if (index > -1) {\n                    string strongest = dict[strength];\n\
    \                    while (dict.ContainsKey(strength - 1)) {\n              \
    \          strength--;\n                        strongest = dict[strength];\n\
    \                    }\n                    results.Add(strength, strongest);\n\
    \                }\n            }\n        }\n        Console.WriteLine(\"{0}.{1}\"\
    , class_name, results.First().Value);\n        return class_name + results.First().Value;",
  "        HashSet<string> hSet = new HashSet<string>();\n        hSet.Add(class_name);\n\
    \        hSet.AddRange(extensions);\n        string extension = \"\";\n      \
    \  double max = double.NegativeInfinity;\n        foreach (string s in hSet) {\n\
    \            extension = s.Substring(0, 1);\n            double value = double.Parse(s.Substring(1));\n\
    \            string temp = \"\";\n            if (value > max)\n             \
    \   max = value;\n            if (value != 0)\n                temp += extension;\n\
    \            else\n                temp += s[0];\n        }\n        return extension;"]
stop_tokens:
- "\n    }\n"
