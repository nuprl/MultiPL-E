name: HumanEval_20_find_closest_elements
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // From a supplied list of numbers (of length at least two) select\
  \ and return two that are the closest to each\n    // other and return them in order\
  \ (smaller number, larger number).\n    // >>> FindClosestElements((new List<float>(new\
  \ float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n\
  \    // (Tuple.Create(2.0f, 2.2f))\n    // >>> FindClosestElements((new List<float>(new\
  \ float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n\
  \    // (Tuple.Create(2.0f, 2.0f))\n    public static Tuple<float, float> FindClosestElements(List<float>\
  \ numbers) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(FindClosestElements((new\
  \ List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f,\
  \ (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));\n    Debug.Assert(FindClosestElements((new\
  \ List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f,\
  \ 5.9f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f,\
  \ (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f,\
  \ 2.2f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f,\
  \ (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f,\
  \ 2.0f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f,\
  \ (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f,\
  \ 3.1f))));\n    }\n\n}\n"
completions: ["        int[] counts = new int[numbers.Count];\n        float smallest\
    \ = (float)numbers[0];\n        float largest = (float)numbers[0];\n        for\
    \ (int i = 0; i < numbers.Count; ++i) {\n            counts[i] = (float)numbers[i];\n\
    \        }\n\n        for (int i = 0; i < numbers.Count; ++i) {\n            smallest\
    \ = (float)numbers.Min(f => f);\n            largest = (float)numbers.Max(f =>\
    \ f);\n            float diff = largest - smallest;\n            float scale =\
    \ diff / (float)Math.Pow(largest, 2);\n\n            counts[i] = Math.Round(counts[i]\
    \ * scale) / scale;\n        }\n\n        for (int i = 0; i < numbers.Count; ++i)\
    \ {\n            smallest = (float)numbers.Min(f => f);\n            largest =\
    \ (float)numbers.Max(f => f);\n            float diff = largest - smallest;\n\
    \            float scale = diff / (float)Math.Pow(largest, 2);\n\n           \
    \ counts[i] = Math.Round(counts[i] * scale) / scale;\n        }\n        return\
    \ Tuple.Create(Math.Min(counts[0], Math.Max(counts[1], counts[2])), Math.Max(counts[0],\
    \ Math.Max(counts[1], counts[2])));", "        List<float> sortedNumbers = new\
    \ List<float>(numbers);\n        sortedNumbers.Sort();\n        float smallest\
    \ = sortedNumbers[0];\n        float largest = sortedNumbers[0];\n        float\
    \ closestToSmallest = sortedNumbers[0];\n        float closestToLargest = sortedNumbers[0];\n\
    \        int closestToSmallestIndex = 0;\n        int closestToLargestIndex =\
    \ 0;\n        for (int i = 1; i < sortedNumbers.Count; i++) {\n            if\
    \ (sortedNumbers[i] - sortedNumbers[i - 1] < 0.001f) {\n                closestToSmallest\
    \ = sortedNumbers[i];\n                closestToSmallestIndex = i - 1;\n     \
    \       }\n            else if (sortedNumbers[i] - sortedNumbers[i - 1] > 0.001f)\
    \ {\n                closestToLargest = sortedNumbers[i];\n                closestToLargestIndex\
    \ = i;\n            }\n        }\n        return new Tuple<float, float>(closestToSmallest,\
    \ closestToLargest);", "        if (numbers.Count < 2) return null;\n\n      \
    \  float[] inputArray = numbers.ToArray();\n\n        // Get all squares of inputArray\n\
    \        var squaredArray = from x in inputArray\n                           \
    \ from y in inputArray\n                            select x * x;\n\n        //\
    \ Find the smallest and largest numbers\n        var minValue = squaredArray.Min();\n\
    \        var maxValue = squaredArray.Max();\n\n        // Find the middle value\n\
    \        var middleValue = (minValue + maxValue) / 2f;\n\n        // Find the\
    \ two numbers that are closest to each other\n        var closest1 = new List<float>();\n\
    \        var closest2 = new List<float>();\n        for (int i = 0; i < inputArray.Length;\
    \ i++) {\n            float square = inputArray[i] * inputArray[i];\n        \
    \    float diff = square - middleValue * middleValue;\n\n            // Check\
    \ whether one of the closest numbers is closer to the middle than the other\n\
    \            if (diff < 0f) {\n                closest1.Add(inputArray[i]);\n\
    \            }\n            else if (diff > 0f) {\n                closest2.Add(inputArray[i]);\n\
    \            }\n        }\n\n        // Return result\n        return Tuple.Create(closest1.Min(),\
    \ closest2.Min());", "        var sortedNumbers = numbers.OrderBy(n => n);\n \
    \       if (sortedNumbers.Count < 2) throw new ArgumentException(\"Numbers must\
    \ have at least 2 elements\");\n        var closestNumber1 = sortedNumbers[0];\n\
    \        var closestNumber2 = sortedNumbers[1];\n        if (Math.Abs(closestNumber1\
    \ - closestNumber2) < Math.Abs(sortedNumbers[2] - sortedNumbers[1])) {\n     \
    \       closestNumber2 = sortedNumbers[2];\n        }\n        return new Tuple<float,\
    \ float>(closestNumber1, closestNumber2);", "        float smallest = numbers[0];\n\
    \        float largest = numbers[0];\n\n        foreach (float n in numbers) {\n\
    \            if (n > largest) {\n                largest = n;\n            }\n\
    \            if (n < smallest) {\n                smallest = n;\n            }\n\
    \        }\n\n        if (smallest == largest) {\n            return (smallest,\
    \ smallest);\n        }\n\n        return (smallest, largest);", "        List<float>\
    \ returnValues = new List<float>();\n        if (numbers.Count < 2) return new\
    \ Tuple<float, float>(null, null);\n\n        float smallestDifference = numbers.ElementAt(0)\
    \ - numbers.ElementAt(1);\n        float largestDifference = numbers.ElementAt(0)\
    \ - numbers.ElementAt(numbers.Count - 1);\n\n        List<float> smallerNumbers\
    \ = numbers.Take(numbers.Count - 1).ToList();\n        smallerNumbers.Add(numbers.ElementAt(0));\n\
    \n        List<float> biggerNumbers = numbers.Skip(numbers.Count - 1).ToList();\n\
    \        biggerNumbers.Add(numbers.ElementAt(numbers.Count - 1));\n\n        List<float>\
    \ smallerDifferences = FindClosestElements(smallerNumbers);\n        List<float>\
    \ biggerDifferences = FindClosestElements(biggerNumbers);\n\n        // Determine\
    \ the smallest and largest elements\n        if (smallerDifferences.First() <\
    \ smallestDifference)\n        {\n            smallestDifference = smallerDifferences.First();\n\
    \        }\n        if (biggerDifferences.First() > largestDifference)\n     \
    \   {\n            largestDifference = biggerDifferences.First();\n        }\n\
    \n        // Add the differences to the list of difference values\n        returnValues.AddRange(smallerDifferences);\n\
    \        returnValues.AddRange(biggerDifferences);\n\n        // Sort values\n\
    \        returnValues.Sort();\n\n        return new Tuple<float, float>(returnValues.First(),\
    \ returnValues.Last());", "        // Sort numbers and find the closest pairs\n\
    \        var sorted = numbers.OrderBy(n => n).ToArray();\n        var left = sorted.FirstOrDefault();\n\
    \        var right = sorted.LastOrDefault();\n\n        float diff;\n        if\
    \ (left == right) {\n            return new Tuple<float, float>(left, left);\n\
    \        }\n\n        float mid = (left + right) / 2;\n\n        diff = GetDiff(left,\
    \ mid);\n        if (diff > right.Subtract(mid).Abs()) {\n            right =\
    \ mid;\n        } else if (diff < left.Subtract(mid).Abs()) {\n            left\
    \ = mid;\n        }\n\n        // Now we have the two numbers that are closest\
    \ to each other in their sorted position\n        return new Tuple<float, float>(left,\
    \ right);", "        if (numbers == null || numbers.Count == 0) return Tuple.Create(0,\
    \ 0);\n\n        float min = numbers.Min();\n        float max = numbers.Max();\n\
    \        int diff;\n        if (numbers.Count == 1) {\n            float num =\
    \ numbers[0];\n            if (Math.Abs(num - min) < Math.Abs(max - num)) return\
    \ Tuple.Create(num, num);\n            return Tuple.Create(min, max);\n      \
    \  }\n\n        foreach (float num in numbers) {\n            diff = num - min;\n\
    \            if (Math.Abs(diff - max) < Math.Abs(max - num)) return Tuple.Create(num,\
    \ num);\n            diff = min - num;\n            if (Math.Abs(diff - min) <\
    \ Math.Abs(min - num)) return Tuple.Create(num, num);\n        }\n        return\
    \ Tuple.Create(min, max);", "        var smallestDelta = Math.Abs(numbers[0] -\
    \ numbers[1]);\n        var biggestDelta = Math.Abs(numbers[1] - numbers[0]);\n\
    \        var smallestNumber = numbers[0];\n        var biggestNumber = numbers[1];\n\
    \        var index = numbers.IndexOf(numbers[0]);\n        while (index > 0 &&\
    \ numbers[index] == smallestNumber) {\n            index--;\n        }\n     \
    \   while (index < numbers.Count && numbers[index] == biggestNumber) {\n     \
    \       index++;\n        }\n        if (smallestNumber == numbers[0] || smallestNumber\
    \ == numbers[1]) {\n            smallestNumber = smallestDelta == 0 ? numbers[0]\
    \ : numbers[1];\n        }\n        if (biggestNumber == numbers[0] || biggestNumber\
    \ == numbers[1]) {\n            biggestNumber = biggestDelta == 0 ? numbers[0]\
    \ : numbers[1];\n        }\n        var tuple = new Tuple<float, float>(smallestNumber,\
    \ biggestNumber);\n        return tuple;", "        var sortedNumbers = numbers.OrderBy(n\
    \ => n).ToList();\n        if (sortedNumbers.Count == 2) {\n            // two\
    \ numbers are the same - just return the smallest\n            return new Tuple<float,\
    \ float>(sortedNumbers[0], sortedNumbers[0]);\n        }\n        if (sortedNumbers.Count\
    \ == 1) {\n            // only one number, just return it\n            return\
    \ new Tuple<float, float>(sortedNumbers[0], sortedNumbers[0]);\n        }\n  \
    \      // find the two numbers that are closest\n        var closestPointOne =\
    \ GetClosestNumber(sortedNumbers.Take(sortedNumbers.Count / 2));\n        var\
    \ closestPointTwo = GetClosestNumber(sortedNumbers.Skip(sortedNumbers.Count /\
    \ 2).Take(sortedNumbers.Count / 2));\n        // if they're the same distance,\
    \ return whichever one comes first\n        if (closestPointOne == closestPointTwo)\
    \ {\n            return closestPointOne;\n        }\n        // they are two different\
    \ numbers, so return the smaller one\n        return new Tuple<float, float>(closestPointTwo,\
    \ closestPointOne);", "        float x = numbers[0];\n        float y = numbers[1];\n\
    \        if (numbers == null || numbers.Count < 2) {\n            return default(Tuple<float,\
    \ float>);\n        }\n\n        if (numbers[0] == numbers[1]) {\n           \
    \ numbers[0] = numbers[1] = numbers[2];\n        }\n\n        var smallest = numbers[0];\n\
    \        var largest = numbers[0];\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            if (numbers[i] - numbers[i - 1] > Math.Abs(numbers[i] -\
    \ numbers[i - 1])) {\n                smallest = numbers[i - 1];\n           \
    \     largest = numbers[i];\n            } else {\n                smallest =\
    \ numbers[i];\n                largest = numbers[i - 1];\n            }\n    \
    \    }\n\n        return new Tuple<float, float>(smallest, largest);", "     \
    \   var min = numbers.Min();\n        var max = numbers.Max();\n        if (min\
    \ == max) {\n            return new Tuple<float, float>(min, min);\n        }\n\
    \        var middle = numbers.Count / 2;\n        var left = new List<float>(numbers.Take(middle));\n\
    \        var right = new List<float>(numbers.Skip(middle));\n        var result\
    \ = FindClosestElements(left).CompareTo(FindClosestElements(right)) < 0\n    \
    \        ? FindClosestElements(left) : FindClosestElements(right);\n        return\
    \ result;", "        if (numbers == null || numbers.Count == 0)\n            return\
    \ default(Tuple<float, float>);\n        int min = numbers.Min();\n        int\
    \ max = numbers.Max();\n        if (min == max)\n            return default(Tuple<float,\
    \ float>);\n        if (numbers.Count == 1) {\n            if (numbers[0] == min\
    \ || numbers[0] == max)\n                return default(Tuple<float, float>);\n\
    \            return Tuple.Create(numbers[0], numbers[0]);\n        }\n       \
    \ if (min > max) {\n            int tmp = min;\n            min = max;\n     \
    \       max = tmp;\n        }\n        float distance;\n        int index1 = -1;\n\
    \        int index2 = -1;\n        float[] arr1 = numbers.ToArray();\n       \
    \ float[] arr2 = new float[arr1.Length];\n        float temp = 0;\n        for\
    \ (int i = 0; i < arr1.Length; i++) {\n            temp = arr1[i];\n         \
    \   arr2[i] = temp;\n            distance = Math.Abs(temp - min);\n          \
    \  if (distance < 0)\n                distance = Math.Abs(max - temp);\n     \
    \       arr1[i] = temp;\n            arr2[i] = temp;\n            if (distance\
    \ < Math.Abs(arr2[index2] - arr1[index1])) {\n                index1 = i;\n  \
    \              index2 = i;\n            }\n        }\n        if (arr2.Length\
    \ > 2)\n            Array.Reverse(arr2);\n        if (index1 == index2 && index1\
    \ == 0)\n            return default(Tuple<float, float>);\n        if (index1\
    \ != 0)\n            return Tuple.Create(arr2[index1], arr2[index2]);\n      \
    \  return Tuple.Create(arr2[0], arr2[1]);", "        int[] count = new int[numbers.Count];\n\
    \n        // Count frequencies in each array\n        for (int i = 0; i < numbers.Count;\
    \ ++i)\n            ++count[numbers[i]];\n\n        int minCount = numbers[0].Length;\n\
    \        int closestCount = 0;\n\n        // Find the smallest number in the list\
    \ that exceeds half of the smallest frequencies.\n        for (int i = 0; i <\
    \ numbers.Count; ++i) {\n            int count = 0;\n            for (int j =\
    \ 0; j < numbers[i].Length; ++j)\n                count += count[j];\n       \
    \     if (count < minCount / 2)\n                minCount = count;\n        }\n\
    \n        // Find the two numbers in each array that have a frequency of minCount\
    \ / 2\n        for (int i = 0; i < numbers.Count; ++i) {\n            int count\
    \ = 0;\n            for (int j = 0; j < numbers[i].Length; ++j)\n            \
    \    count += count[j];\n            if (count < minCount / 2)\n             \
    \   continue;\n            int count2 = count - minCount;\n            for (int\
    \ j = 0; j < numbers[i].Length; ++j)\n                count2--;\n            if\
    \ (count2 == 0)\n                return new Tuple<float, float>(numbers[i][0],\
    \ numbers[i][numbers[i].Length - 1]);\n            int count3 = count - minCount\
    \ - 1;\n            for (int j = 0; j < numbers[i].Length; ++j)\n            \
    \    count3++;\n            if (count3 == 0)\n                return new Tuple<float,\
    \ float>(numbers[i][0], numbers[i][1]);\n        }\n        return Tuple.Create(numbers[0][0],\
    \ numbers[numbers.Count - 1][1]);", "        // Create an array of numbers from\
    \ first to last.\n        float[] numberArray = new float[numbers.Count];\n  \
    \      int i = 0;\n        // Fill the first number of the array with the first\
    \ number\n        numberArray[i] = numbers.First();\n        // Go through all\
    \ other numbers and put them in the array\n        foreach (float number in numbers.Skip(1))\
    \ {\n            numberArray[i++] = number;\n        }\n        // Sort the array\
    \ using the built in sort function\n        Array.Sort(numberArray);\n       \
    \ // Get the index to the number that corresponds to the \"closest\" number to\
    \ the first number\n        float index1 = numberArray.BinarySearch(numbers[0]);\n\
    \        // Get the index to the number that corresponds to the \"closest\" number\
    \ to the second number\n        float index2 = numberArray.BinarySearch(numbers[1]);\n\
    \        // Return the elements in the correct order\n        return Tuple.Create(numberArray[index1],\
    \ numberArray[index2]);", "        if (numbers == null || numbers.Count < 2) {\n\
    \            throw new ArgumentException(\"numbers not null or empty.\");\n  \
    \      }\n\n        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \n        // If min is greater than max, return min.\n        if (min > max) {\n\
    \            return new Tuple<float, float>(min, min);\n        }\n\n        //\
    \ Otherwise, find all pairs of numbers (one less than min, one more than max)\
    \ that are close\n        // to each other.\n        var results = new List<Tuple<float,\
    \ float>>();\n        var currentSum = min;\n        var currentDistance = max\
    \ - min;\n        var currentIndex = 0;\n        var currentSumIndex = 0;\n  \
    \      while (currentSum != max) {\n            var currentDiff = max - currentSum;\n\
    \            var currentDistance2 = currentDistance * currentDistance;\n     \
    \       var currentSumIndex2 = currentSumIndex * currentSumIndex;\n          \
    \  var currentSumIndex3 = currentSumIndex2 * currentSumIndex;\n            var\
    \ currentSumIndex4 = currentSumIndex3 * currentSumIndex;\n\n            var currentSumSquare\
    \ = currentSum * currentSum;\n            var currentDistance3 = currentDistance\
    \ * currentDistance;\n            var currentDistance4 = currentDistance * currentDistance2;\n\
    \            var currentDistance5 = currentDistance * currentDistance3;\n\n  \
    \          var currentSumSquare2 = currentSumSquare * currentSum;\n          \
    \  var currentDistance3 = currentDistance2 * currentDistance;\n            var\
    \ currentDistance4 = currentDistance2 * currentDistance2;\n            var currentDistance5\
    \ = currentDistance2 * currentDistance3;\n\n            var currentSumSquare3\
    \ = currentSumSquare2 * currentSum;\n            var currentDistance4 = currentDistance3\
    \ * currentDistance;\n            var currentDistance5 = currentDistance3 * currentDistance2;\n\
    \            var currentDistance6 = currentDistance3 * currentDistance3;\n\n \
    \           results.Add(new Tuple<float, float>(currentSum + (((currentDistance\
    \ * currentDistance) / (currentSumSquare2 + currentSumSquare3 + currentSumSquare4))\
    \ / currentDistance4), currentSum + (((currentDistance * currentDistance2) / (currentSumSquare3\
    \ + currentSumSquare5)) / currentDistance5)));\n            results.Add(new Tuple<float,\
    \ float>(currentSum + (((currentDistance * currentDistance3) / (currentSumSquare4\
    \ + currentSumSquare5)) / currentDistance6), currentSum + (((currentDistance *\
    \ currentDistance5) / (currentSumSquare6 + currentSumSquare7)) / currentDistance7)));\n\
    \n            currentSum += currentDiff;\n            currentDistance = max -\
    \ currentSum;\n            currentSum = currentSum;\n            currentSumIndex++;\n\
    \        }\n\n        // Sort pairs by distance (the smaller number), ascending\n\
    \        results.Sort((x, y) => x.Item1.CompareTo(y.Item1));\n\n        // ",
  "        if (numbers == null || numbers.Count == 0)\n            throw new ArgumentException(\"\
    Can't find two numbers from an empty list\");\n        if (numbers.Count == 1)\n\
    \            return (numbers[0], numbers[0]);\n        var x = new List<float>(numbers);\n\
    \        var smallest1 = Math.Abs(x.ElementAt(0) - x.ElementAt(1));\n        var\
    \ smallest2 = Math.Abs(x.ElementAt(0) - x.ElementAt(2));\n        var smallest3\
    \ = Math.Abs(x.ElementAt(1) - x.ElementAt(2));\n        var smallest4 = Math.Abs(x.ElementAt(0)\
    \ - x.ElementAt(3));\n        var smallest5 = Math.Abs(x.ElementAt(0) - x.ElementAt(4));\n\
    \        var smallest6 = Math.Abs(x.ElementAt(1) - x.ElementAt(4));\n        var\
    \ smallest7 = Math.Abs(x.ElementAt(2) - x.ElementAt(4));\n        var smallest8\
    \ = Math.Abs(x.ElementAt(3) - x.ElementAt(4));\n        if (smallest1 < smallest2\
    \ && smallest1 < smallest3 && smallest2 < smallest4 && smallest2 < smallest5 &&\
    \ smallest3 < smallest4 && smallest3 < smallest5 && smallest4 < smallest6 && smallest4\
    \ < smallest7 && smallest5 < smallest6 && smallest5 < smallest7 && smallest6 <\
    \ smallest8) {\n            return new Tuple<float, float>(x.ElementAt(0), x.ElementAt(1));\n\
    \        }\n        if (smallest1 < smallest2 && smallest1 < smallest3 && smallest2\
    \ < smallest4 && smallest2 < smallest5 && smallest3 < smallest4 && smallest3 <\
    \ smallest5 && smallest4 < smallest6 && smallest4 < smallest7 && smallest5 < smallest6\
    \ && smallest5 < smallest7 && smallest6 < smallest8) {\n            return new\
    \ Tuple<float, float>(x.ElementAt(1), x.ElementAt(1));\n        }\n        if\
    \ (smallest1 < smallest2 && smallest1 < smallest3 && smallest2 < smallest4 &&\
    \ smallest2 < smallest5 && smallest3 < smallest4 && smallest3 < smallest5 && smallest4\
    \ < smallest6 && smallest4 < smallest7 && smallest5 < smallest6 && smallest5 <\
    \ smallest7 && smallest6 < smallest8) {\n            return new Tuple<float, float>(x.ElementAt(2),\
    \ x.ElementAt(2));\n        }\n        if (smallest1 < smallest2 && smallest1\
    \ < smallest3 && smallest2 < smallest4 && smallest2 < smallest5 && ", "      \
    \  // Find two closest numbers, sort the list and return the two\n        return\
    \ FindClosestElements(numbers, numbers);", "        if (numbers == null || numbers.Count\
    \ < 2) {\n            return null;\n        }\n        float[] data = numbers.ToArray();\n\
    \        float smallest = data[0];\n        float largest = data[0];\n       \
    \ for (int i = 1; i < data.Length; i++) {\n            if (data[i] < smallest)\
    \ {\n                smallest = data[i];\n            } else if (data[i] > largest)\
    \ {\n                largest = data[i];\n            }\n        }\n        return\
    \ new Tuple<float, float>(smallest, largest);", "        if (numbers.Count < 2)\
    \ {\n            return null;\n        }\n        var initialSet = new HashSet<float>(numbers);\n\
    \        float maxDistance = float.MaxValue;\n        float maxElement = numbers[0];\n\
    \        float minElement = numbers[0];\n        foreach (float element in numbers)\
    \ {\n            var diff = Mathf.Abs(element - minElement);\n            if (diff\
    \ > maxDistance) {\n                maxDistance = diff;\n                maxElement\
    \ = element;\n            }\n            diff = Mathf.Abs(element - maxElement);\n\
    \            if (diff < maxDistance) {\n                maxDistance = diff;\n\
    \                minElement = element;\n            }\n        }\n        return\
    \ new Tuple<float, float>(minElement, maxElement);", "        var minDistance\
    \ = float.MaxValue;\n        float minValue = 0;\n        float maxValue = 0;\n\
    \        float newValue;\n        foreach (var number in numbers) {\n        \
    \    float value = Math.Abs(number);\n            if (value < minDistance) {\n\
    \                minDistance = value;\n                minValue = number;\n  \
    \          } else if (value > minDistance) {\n                maxValue = number;\n\
    \            }\n        }\n        if (minDistance == float.MaxValue) {\n    \
    \        throw new Exception(\"No numbers exist\");\n        }\n        newValue\
    \ = minValue;\n        while (minValue != maxValue) {\n            newValue =\
    \ newValue * 2 - 1;\n            minValue = newValue;\n            newValue =\
    \ newValue + minValue;\n        }\n        return Tuple.Create(minValue, maxValue);",
  "        float max = numbers.Max();\n        float min = numbers.Min();\n      \
    \  float middle = min + (max - min) / 2;\n        float result = new float[2];\n\
    \        // Find the two numbers that are closest to each other in order.\n  \
    \      for (int i = 0; i < numbers.Count; i++) {\n            float distance =\
    \ MathHelper.Abs(middle) - numbers[i];\n            if (distance < 0) {\n    \
    \            distance = distance * -1;\n            }\n            if (i == 0)\
    \ {\n                result[0] = numbers[i];\n                result[1] = numbers[i\
    \ - 1];\n            } else {\n                if (distance < result[0]) {\n \
    \                   result[0] = distance;\n                    result[1] = numbers[i];\n\
    \                }\n            }\n        }\n        return Tuple.Create(result[0],\
    \ result[1]);", "        List<float> results = new List<float>();\n\n        //\
    \ Pick the first two closest numbers. If the two numbers we picked are equal then\
    \ we\n        // pick the first two numbers in the list, because if the two numbers\
    \ are equal they will\n        // be equal (they will be the same number).\n \
    \       if (numbers.Count >= 2) {\n            float first = numbers[0];\n   \
    \         float second = numbers[1];\n            float third = numbers[2];\n\n\
    \            int smallestIndex = -1;\n            int largestIndex = numbers.Count\
    \ - 1;\n\n            bool firstSmallerThanSecond = IsSmaller(first, second);\n\
    \            bool firstLargerThanSecond = IsLarger(first, second);\n         \
    \   bool secondSmallerThanFirst = IsSmaller(second, first);\n            bool\
    \ secondLargerThanFirst = IsLarger(second, first);\n\n            // If both numbers\
    \ are equally smaller, pick the smaller of the two (ie. the first).\n        \
    \    // If both numbers are equally larger, pick the larger (ie. the second).\n\
    \            if (firstSmallerThanSecond && firstLargerThanSecond) {\n        \
    \        first = second;\n            }\n            else if (secondSmallerThanFirst\
    \ && secondLargerThanFirst) {\n                second = first;\n            }\n\
    \n            // If one number is equally smaller, pick that number. If both numbers\
    \ are equally smaller\n            // then just pick the smaller number.\n   \
    \         else if (firstSmallerThanSecond) {\n                first = second;\n\
    \            }\n            else if (secondSmallerThanFirst) {\n             \
    \   second = first;\n            }\n\n            // If both numbers are equally\
    \ larger, pick the larger of the two (ie. the second).\n            else if (firstLargerThanSecond)\
    \ {\n                first = second;\n            }\n            else if (secondLargerThanFirst)\
    \ {\n                second = first;\n            }\n\n            // Now just\
    \ pick the numbers which we will then be returning.\n            results.Add(first);\n\
    \            results.Add(second);\n        }\n\n        // If there is only one\
    \ number, return the number that is equally closest.\n        else if (numbers.Count\
    \ == 1) {\n            float first = numbers[0];\n            results.Add(first);\n\
    \        }\n\n        // Return an empty list.\n        else {\n            return\
    \ new Tuple<float, float>(float.NaN, float.NaN);\n        }\n\n        // Return\
    \ the results tuple.\n        return new Tuple<float, float>(results[0], results[1]);",
  "        // Sort the list\n        numbers.Sort();\n\n        // The two closest\
    \ numbers are the smallest and largest of the list\n        float smallest = numbers[0];\n\
    \        float largest = numbers[0];\n\n        // Find the smallest and largest\
    \ of the list\n        float current;\n        float nextElement;\n\n        //\
    \ Loop over the list\n        for (int i = 0; i < numbers.Count; i++) {\n    \
    \        // Get the current number and next number\n            current = numbers[i];\n\
    \            nextElement = numbers[i + 1];\n\n            // If the current number\
    \ is the smallest or the next number is largest\n            if (current < smallest\
    \ || nextElement > largest) {\n                // Set the new smallest and largest\
    \ numbers\n                smallest = current;\n                largest = nextElement;\n\
    \            }\n        }\n\n        // Return the two closest numbers\n     \
    \   return Tuple.Create(smallest, largest);", "        float smallestDifference\
    \ = float.MaxValue;\n        var smallestDifferenceT = new Tuple<float, float>(float.MaxValue,\
    \ float.MaxValue);\n        foreach (var item in numbers) {\n            var difference\
    \ = item - smallestDifferenceT._Item1;\n            if (difference < smallestDifference)\
    \ {\n                smallestDifference = difference;\n                smallestDifferenceT\
    \ = new Tuple<float, float>(item, difference);\n            }\n        }\n   \
    \     return smallestDifferenceT;", "        // Sort the numbers using a custom\
    \ delegate to sort on the absolute value of the difference between the numbers.\n\
    \        // Note: we could use Math.Abs() as our sorting function, but since this\
    \ is a learning exercise, we do not\n        // use a custom delegate and instead\
    \ implement the sorting function ourselves.\n        numbers.Sort((x, y) => {\n\
    \            var xAbs = Math.Abs(x);\n            var yAbs = Math.Abs(y);\n  \
    \          if (xAbs < yAbs) {\n                return -1;\n            } else\
    \ if (xAbs > yAbs) {\n                return 1;\n            } else {\n      \
    \          // If the numbers are equal, return the difference between them.\n\
    \                return xAbs - yAbs;\n            }\n        });\n        // If\
    \ we reach this point, the numbers are already sorted by absolute value, so just\
    \ return the first two numbers,\n        // which are the first two numbers closest\
    \ to the other.\n        if (numbers.Count <= 2) {\n            return new Tuple<float,\
    \ float>(numbers[0], numbers[1]);\n        }\n        // Return the first two\
    \ numbers from the sorted list. The first two numbers from the sorted list are\
    \ the ones\n        // closest to each other. Return the difference between the\
    \ two numbers as well.\n        return new Tuple<float, float>(numbers[0], numbers[1]);",
  "        int minIndex = 0;\n        int maxIndex = numbers.Count - 1;\n        while\
    \ (true) {\n            Tuple<float, float> result = GetClosestElement(numbers,\
    \ minIndex, maxIndex);\n            if (result.Item1 <= result.Item2) return result;\n\
    \            if (result.Item2 < minIndex) minIndex = result.Item2;\n         \
    \   else if (result.Item2 < maxIndex) maxIndex = result.Item2;\n            else\
    \ return result;\n        }", "        // Find the first number in the list that\
    \ is less than the second number.\n        int leftIndex = numbers.FindIndex(x\
    \ => x < numbers[1]);\n        // Find the first number in the list that is greater\
    \ than the first number.\n        int rightIndex = numbers.FindIndex(x => x >\
    \ numbers[0]);\n        // If there are two numbers then return them in order\
    \ (smallest first, largest first).\n        if (rightIndex == 0 && leftIndex ==\
    \ 0) {\n            return new Tuple<float, float>(numbers[0], numbers[1]);\n\
    \        }\n        // If there are not two numbers then return the first two\
    \ that are closest to each other.\n        if (rightIndex == 0) {\n          \
    \  return new Tuple<float, float>(numbers[leftIndex], numbers[leftIndex + 1]);\n\
    \        }\n        if (leftIndex == 0) {\n            return new Tuple<float,\
    \ float>(numbers[rightIndex], numbers[rightIndex + 1]);\n        }\n        //\
    \ Find the difference between the two numbers and return the two that are the\
    \ closest to each other.\n        float leftDifference = numbers[rightIndex] -\
    \ numbers[leftIndex];\n        float rightDifference = numbers[leftIndex] - numbers[rightIndex];\n\
    \        if (leftDifference < rightDifference) {\n            return new Tuple<float,\
    \ float>(numbers[leftIndex], numbers[leftIndex + 1]);\n        } else {\n    \
    \        return new Tuple<float, float>(numbers[rightIndex], numbers[rightIndex\
    \ + 1]);\n        }", "        List<int> list = new List<int>();\n        foreach\
    \ (float number in numbers) {\n            list.Add(Convert.ToInt32(number));\n\
    \        }\n\n        Array.Sort(list);\n        var min = list.First();\n   \
    \     var max = list.Last();\n\n        var minIndex = list.FindIndex(x => x ==\
    \ min);\n        var maxIndex = list.FindIndex(x => x == max);\n\n        if (minIndex\
    \ == -1 || maxIndex == -1)\n            throw new Exception(\"Invalid input list\"\
    );\n\n        var ret = new Tuple<float, float>(list[minIndex], list[maxIndex]);\n\
    \n        return ret;", "        float smallest = numbers.Min();\n        float\
    \ largest = numbers.Max();\n        float middle = (smallest + largest) / 2;\n\
    \        float left = numbers.FindIndex(x => x <= middle);\n        float right\
    \ = numbers.FindIndex(x => x > middle);\n        if (left < right) {\n       \
    \     return new Tuple<float, float>(numbers[left], numbers[right]);\n       \
    \ } else {\n            return new Tuple<float, float>(numbers[right], numbers[left]);\n\
    \        }", "        var minDiff = float.MaxValue;\n        var closestElements\
    \ = Enumerable.Empty<float>().ToArray();\n        var currentMinDiff = float.MaxValue;\n\
    \n        for (int i = 0; i < numbers.Count - 1; i++) {\n            var curr\
    \ = numbers[i];\n            var next = numbers[i + 1];\n            var diff\
    \ = next - curr;\n            if (diff < 0 && currentMinDiff < 0) {\n        \
    \        currentMinDiff = diff;\n                closestElements = new[] { curr,\
    \ next };\n                continue;\n            }\n            if (diff < 0\
    \ && diff > minDiff) {\n                closestElements = new[] { curr, next };\n\
    \                minDiff = diff;\n            }\n            if (diff > 0 && diff\
    \ < currentMinDiff) {\n                currentMinDiff = diff;\n              \
    \  closestElements = new[] { curr, next };\n            }\n        }\n       \
    \ if (currentMinDiff > minDiff) {\n            closestElements = new[] { closestElements[0],\
    \ closestElements[1] };\n        }\n        return Tuple.Create(closestElements[0],\
    \ closestElements[1]);", "        double smallest = double.MaxValue;\n       \
    \ double largest = double.MinValue;\n        float smallestFloat = float.MaxValue;\n\
    \        float largestFloat = float.MinValue;\n        float floatToDouble = (float)numbers[0];\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            double number\
    \ = numbers[i];\n            if (number == 0) {\n                double doubleToFloat\
    \ = floatToDouble;\n                floatToDouble = (float)(doubleToFloat / number);\n\
    \                numbers.RemoveAt(i);\n                i--;\n                continue;\n\
    \            }\n            double doubleToFloat = floatToDouble;\n          \
    \  floatToDouble = (float)(doubleToFloat / number);\n            if (doubleToFloat\
    \ < smallest || smallest == double.MaxValue) {\n                smallest = doubleToFloat;\n\
    \            }\n            if (doubleToFloat > largest || largest == double.MinValue)\
    \ {\n                largest = doubleToFloat;\n            }\n            if (number\
    \ < smallestFloat || smallestFloat == float.MaxValue) {\n                smallestFloat\
    \ = number;\n            }\n            if (number > largestFloat || largestFloat\
    \ == float.MinValue) {\n                largestFloat = number;\n            }\n\
    \        }\n        return new Tuple<float, float>(smallestFloat, largestFloat);",
  "        if (numbers.Count < 2)\n            return null;\n        float smallestDifference\
    \ = (float)Math.Abs(numbers.First() - numbers.Last());\n        float secondSmallestDifference\
    \ = (float)Math.Abs(numbers.First() - numbers.ElementAt(1));\n        float secondBiggestDifference\
    \ = (float)Math.Abs(numbers.ElementAt(1) - numbers.Last());\n        if (smallestDifference\
    \ == 0) {\n            if (secondSmallestDifference == 0)\n                return\
    \ new Tuple<float, float>(numbers.First(), numbers.ElementAt(1));\n          \
    \  else if (secondBiggestDifference == 0)\n                return new Tuple<float,\
    \ float>(numbers.First(), numbers.Last());\n            else\n               \
    \ return new Tuple<float, float>(numbers.First(), numbers.Last());\n        }\n\
    \        if (secondSmallestDifference == 0) {\n            if (secondBiggestDifference\
    \ == 0)\n                return new Tuple<float, float>(numbers.ElementAt(1),\
    \ numbers.Last());\n            else\n                return new Tuple<float,\
    \ float>(numbers.ElementAt(1), numbers.ElementAt(1));\n        }\n        if (secondBiggestDifference\
    \ == 0) {\n            return new Tuple<float, float>(numbers.First(), numbers.Last());\n\
    \        }\n        if (smallestDifference < secondBiggestDifference) {\n    \
    \        return new Tuple<float, float>(numbers.First(), numbers.ElementAt(1));\n\
    \        }\n        if (smallestDifference > secondSmallestDifference) {\n   \
    \         return new Tuple<float, float>(numbers.ElementAt(1), numbers.Last());\n\
    \        }\n        return new Tuple<float, float>(numbers.ElementAt(1), numbers.ElementAt(1));",
  "        int minIndex = 1;\n        int maxIndex = 0;\n        float minDiff = numbers[0].Abs()\
    \ - numbers[1].Abs();\n        for (int i = 1; i < numbers.Count; i++) {\n   \
    \         float diff = numbers[i].Abs() - numbers[minIndex].Abs();\n         \
    \   if (diff < minDiff) {\n                minDiff = diff;\n                minIndex\
    \ = i;\n            } else if (diff > minDiff) {\n                maxIndex = i;\n\
    \            }\n        }\n        return new Tuple<float, float>(numbers[minIndex],\
    \ numbers[maxIndex]);", "        if (numbers.Count == 0) return null;\n      \
    \  if (numbers.Count < 2) return null;\n        double smallestDifference = double.PositiveInfinity;\n\
    \        float smallestDifferenceValue = float.PositiveInfinity;\n        float\
    \ largestDifferenceValue = float.NegativeInfinity;\n        float largestDifference\
    \ = float.NegativeInfinity;\n        float currentSmallestDifference = double.PositiveInfinity;\n\
    \        float currentLargestDifference = float.NegativeInfinity;\n        float\
    \ currentSmallestDifferenceValue = float.PositiveInfinity;\n        float currentLargestDifferenceValue\
    \ = float.NegativeInfinity;\n        float currentNumber;\n        float currentNumberValue;\n\
    \        bool currentIsSmallest;\n        bool currentIsLargest;\n        float\
    \ currentDifference;\n        foreach (float number in numbers) {\n          \
    \  currentNumber = number;\n            currentNumberValue = number;\n       \
    \     currentIsSmallest = true;\n            currentIsLargest = true;\n      \
    \      currentDifference = double.PositiveInfinity;\n            foreach (float\
    \ value in numbers) {\n                if (value != currentNumber) {\n       \
    \             currentIsSmallest = false;\n                    if (value < currentNumber)\
    \ {\n                        currentIsLargest = false;\n                    }\n\
    \                    else {\n                        currentIsLargest = true;\n\
    \                    }\n                    currentDifference = Math.Abs(value\
    \ - currentNumber);\n                    if (currentDifference < currentSmallestDifference)\
    \ {\n                        currentSmallestDifference = currentDifference;\n\
    \                        currentSmallestDifferenceValue = value;\n           \
    \         }\n                    if (currentDifference > currentLargestDifference)\
    \ {\n                        currentLargestDifference = currentDifference;\n \
    \                       currentLargestDifferenceValue = value;\n             \
    \       }\n                }\n            }\n            if (currentIsSmallest)\
    \ {\n                currentSmallestDifferenceValue = currentNumberValue;\n  \
    \          }\n            if (currentIsLargest) {\n                currentLargestDifferenceValue\
    \ = currentNumberValue;\n            }\n        }\n        return (Tuple.Create(currentSmallestDifferenceValue,\
    \ currentLargestDifferenceValue));", "        var min = numbers.Min();\n     \
    \   var max = numbers.Max();\n        var diff = max - min;\n        if (diff\
    \ == 0) return new Tuple<float, float>(min, max);\n\n        var middle = (min\
    \ + max) / 2;\n        var closestLeft = FindClosestElements(numbers.Where(x =>\
    \ x < middle).OrderBy(x => x).ToList());\n        var closestRight = FindClosestElements(numbers.Where(x\
    \ => x > middle).OrderByDescending(x => x).ToList());\n        if (closestLeft.Item1\
    \ <= closestRight.Item1) {\n            return new Tuple<float, float>(closestLeft.Item1,\
    \ closestLeft.Item2);\n        }\n        return closestRight;", "        double\
    \ closest = Double.MaxValue;\n        double minDistance = Double.MaxValue;\n\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            double distance\
    \ = Sqrt((numbers[i] - numbers[i + 1]) * (numbers[i] - numbers[i + 1]));\n   \
    \         if (distance < minDistance) {\n                minDistance = distance;\n\
    \                closest = numbers[i];\n            }\n        }\n\n        if\
    \ (minDistance < Double.MaxValue) {\n            return new Tuple<float, float>(closest,\
    \ numbers[numbers.Count - 1]);\n        } else {\n            throw new Exception(\"\
    Could not find two closest elements.\");\n        }", "        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        var diff = max - min;\n        var\
    \ half = diff / 2.0f;\n        var minDiff = half;\n\n        return numbers.Select(number\
    \ => new Tuple<float, float>(number, number - minDiff)).OrderBy(tuple => tuple.Item2).First();",
  "        if (numbers == null || numbers.Count < 2)\n            throw new ArgumentException(\"\
    numbers\", \"List of numbers must be non-null and have a minimum length of 2\"\
    );\n\n        float leftNumber = numbers[0];\n        float rightNumber = numbers[0];\n\
    \n        if (numbers.Count > 1) {\n            // We have at least one number\
    \ to choose, so we can go through them one at a time\n            for (int i =\
    \ 1; i < numbers.Count; i++) {\n                // We need a second number to\
    \ compare to the one we're using for this iteration\n                float secondLeftNumber\
    \ = numbers[i];\n                float secondRightNumber = numbers[i];\n     \
    \           float leftDifference = leftNumber.Abs() + secondLeftNumber.Abs();\n\
    \                float rightDifference = rightNumber.Abs() + secondRightNumber.Abs();\n\
    \                if (leftDifference < rightDifference) {\n                   \
    \ leftNumber = secondLeftNumber;\n                    rightNumber = secondRightNumber;\n\
    \                } else {\n                    leftNumber = secondRightNumber;\n\
    \                    rightNumber = secondLeftNumber;\n                }\n    \
    \        }\n        }\n        return new Tuple<float, float>(leftNumber, rightNumber);",
  "        Debug.Assert(numbers.Count >= 2);\n        Debug.Assert(numbers[0] != 0.0f);\n\
    \        Debug.Assert(numbers[1] != 0.0f);\n        float smallerNumber = numbers[0];\n\
    \        float largerNumber = numbers[0];\n        for(int i = 1;i < numbers.Count;i++)\
    \ {\n            if(numbers[i]<smallerNumber) {\n                smallerNumber\
    \ = numbers[i];\n            }\n            if(numbers[i]>largerNumber) {\n  \
    \              largerNumber = numbers[i];\n            }\n        }\n        return\
    \ (new Tuple<float, float>(smallerNumber, largerNumber));", "        int minDifference\
    \ = int.MaxValue;\n        float minNumber = numbers.First();\n        float maxNumber\
    \ = numbers.Last();\n        for(int i = 1; i < numbers.Count; i++) {\n      \
    \      float number = numbers[i];\n            int difference = (int)(Math.Abs(number\
    \ - minNumber) - Math.Abs(number - maxNumber));\n            if(difference < minDifference)\
    \ {\n                minDifference = difference;\n                minNumber =\
    \ number;\n            } else if(difference == minDifference) {\n            \
    \    if(number < minNumber) {\n                    minDifference = difference;\n\
    \                    minNumber = number;\n                }\n            }\n \
    \           if(number > maxNumber) {\n                maxNumber = number;\n  \
    \          }\n        }\n        return new Tuple<float, float>(minNumber, maxNumber);",
  "        if (numbers.Count < 2) {\n            throw new InvalidOperationException(\"\
    Can't find closest value from less than two values\");\n        }\n\n        var\
    \ largest = numbers.Max();\n        var smallest = numbers.Min();\n        var\
    \ minDistance = largest.Abs() - smallest.Abs();\n\n        if (minDistance ==\
    \ 0.0f) {\n            // All numbers are equal, return first value\n        \
    \    return new Tuple<float, float>(numbers[0], numbers[0]);\n        }\n\n  \
    \      var currentDifference = largest.Abs() - smallest.Abs();\n        var currentDistance\
    \ = numbers.Average(x => x.Abs());\n        var closestElementIndex = 0;\n   \
    \     var closestElement = smallest;\n\n        // If the smallest absolute difference\
    \ is less than the current difference the search is finished.\n        if (minDistance\
    \ < currentDifference) {\n            return new Tuple<float, float>(closestElement,\
    \ numbers[0]);\n        }\n\n        while (closestElementIndex < numbers.Count\
    \ - 1 && currentDistance < minDistance) {\n            closestElementIndex++;\n\
    \            closestElement = numbers[closestElementIndex];\n            currentDistance\
    \ = numbers.Average(x => x.Abs());\n        }\n\n        return Tuple.Create(closestElement,\
    \ closestElement);", "        // This could use some work to optimise, since it\
    \ has to deal with three cases.\n        // 1. There are no numbers left.\n  \
    \      // 2. There is a single number left.\n        // 3. There are two numbers\
    \ and they're equal or smaller.\n        var result = new Tuple<float, float>(numbers[0],\
    \ numbers[0]);\n        if (numbers.Count == 1) {\n            return result;\n\
    \        }\n        var smallest = numbers[0];\n        var largest = numbers[0];\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            if (numbers[i]\
    \ > largest) {\n                largest = numbers[i];\n            }\n       \
    \     if (numbers[i] < smallest) {\n                smallest = numbers[i];\n \
    \           }\n        }\n        return result.Item1 != smallest ? new Tuple<float,\
    \ float>(smallest, largest) : result;", "        float smallest = Math.Min(numbers[0]);\n\
    \        float largest = Math.Max(numbers[0]);\n        float smallest_diff =\
    \ (largest - smallest);\n        float largest_diff = (largest - numbers[0]);\n\
    \        float smallest_diff_plus_largest_diff = (smallest + largest_diff);\n\
    \        float largest_diff_minus_smallest_diff = (largest - smallest_diff);\n\
    \        if (smallest == numbers[0] && largest == numbers[0]) {\n            throw\
    \ new ApplicationException(\"The list of numbers contains only one number.\");\n\
    \        }\n        float nearest_to_first_number = largest - smallest_diff_plus_largest_diff;\n\
    \        float nearest_to_second_number = smallest + largest_diff_minus_smallest_diff;\n\
    \        return Tuple.Create(nearest_to_first_number, nearest_to_second_number);",
  "        if (numbers.Count < 2) {\n            throw new ArgumentException(\"Numbers\
    \ must have at least two elements\");\n        }\n\n        // The next two lines\
    \ ensure the numbers are sorted by absolute value.\n        numbers.Sort((x, y)\
    \ => Math.Abs(x) - Math.Abs(y));\n\n        var result = new Tuple<float, float>(0,\
    \ 0);\n        var closestResult = result.Item1;\n        var closestNumber =\
    \ result.Item2;\n        var lastNumber = numbers.Last();\n\n        // Calculate\
    \ the distance between each pair and find the smallest distance\n        // and\
    \ the two numbers between the two closest distances.\n        for (int i = 0;\
    \ i < numbers.Count; i++) {\n            var currentNumber = numbers[i];\n   \
    \         var nextNumber = numbers[i + 1];\n            var distance = CalculateDistance(lastNumber,\
    \ currentNumber, nextNumber);\n            Debug.Assert(distance >= 0);\n\n  \
    \          if (distance < closestResult) {\n                closestResult = distance;\n\
    \                closestNumber = currentNumber;\n            } else if (distance\
    \ == closestResult) {\n                closestNumber = nextNumber;\n         \
    \   }\n\n            lastNumber = currentNumber;\n        }\n\n        return\
    \ new Tuple<float, float>(closestResult, closestNumber);", "        if (numbers.Count\
    \ < 2) {\n            return null;\n        }\n        Array.Sort(numbers);\n\
    \        return numbers.Skip(1).Take(2).ToArray().Select(n => new Tuple<float,\
    \ float>(numbers[n], numbers[0])).FirstOrDefault();", "        int numElements\
    \ = numbers.Count;\n        if (numElements < 2) {\n            throw new ArgumentException(\"\
    Must supply at least two elements to find the closest elements\", \"numbers\"\
    );\n        }\n        double distance = Math.Abs(numbers.First() - numbers.Last());\n\
    \        double min = distance;\n        double max = distance;\n        double\
    \ currentMin = distance;\n        double currentMax = distance;\n        double\
    \ previousMax = distance;\n        double previousMin = distance;\n        double\
    \ currentElement = numbers.First();\n        double currentElementDifference =\
    \ Math.Abs(numbers.First() - numbers.Last());\n        double previousElement\
    \ = numbers.First();\n        double previousElementDifference = Math.Abs(numbers.First()\
    \ - numbers.Last());\n        double previousMinElement = numbers.First();\n \
    \       double previousMinElementDifference = Math.Abs(numbers.First() - numbers.Last());\n\
    \        double previousMaxElement = numbers.First();\n        double previousMaxElementDifference\
    \ = Math.Abs(numbers.First() - numbers.Last());\n\n        for (int index = 1;\
    \ index < numElements; index++) {\n            double currentElementDifference\
    \ = Math.Abs(numbers.ElementAt(index) - currentElement);\n            if (currentElementDifference\
    \ < min) {\n                min = currentElementDifference;\n                currentMin\
    \ = currentElement;\n                currentElement = numbers.ElementAt(index);\n\
    \            }\n            double previousElementDifference = Math.Abs(numbers.ElementAt(index)\
    \ - previousElement);\n            if (previousElementDifference < min) {\n  \
    \              min = previousElementDifference;\n                currentMin =\
    \ previousElement;\n                previousElement = numbers.ElementAt(index);\n\
    \            }\n\n            double previousMinElementDifference = Math.Abs(numbers.ElementAt(index)\
    \ - previousMinElement);\n            if (previousMinElementDifference < min)\
    \ {\n                min = previousMinElementDifference;\n                currentMin\
    \ = previousMinElement;\n                previousMinElement = numbers.ElementAt(index);\n\
    \            }\n\n            double previousMaxElementDifference = Math.Abs(numbers.ElementAt(index)\
    \ - previousMaxElement);\n            if (previousMaxElementDifference < min)\
    \ {\n                min = previousMaxElementDifference;\n                currentMin\
    \ = previousMaxElement;\n                previousMaxElement = numbers.ElementAt(index);\n\
    \            }\n\n            double currentMaxElementDifference = Math.Abs(numbers.ElementAt(index)\
    \ - currentMax);\n            if (currentMaxElementDifference < min) {\n     \
    \           min = currentMaxElementDifference;\n                currentMax = currentMaxElement;\n\
    \                currentMaxElement = numbers.ElementAt(index);\n            }\n\
    \n            double currentMinElementDifference = Math.Abs(numbers.ElementAt(index)\
    \ - currentMin);\n            if (currentMinElementDifference < min) {\n     \
    \           min = currentMinElementDifference;\n                current", "  \
    \      Tuple<float, float> results;\n        float smallest = numbers[0];\n  \
    \      float largest = numbers[0];\n\n        if (numbers.Count == 1) return new\
    \ Tuple<float, float>(numbers[0], numbers[0]);\n\n        float a = numbers[0];\n\
    \        float b = numbers[0];\n\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            float c = numbers[i];\n            a = Math.Min(a, c);\n    \
    \        b = Math.Max(b, c);\n        }\n\n        if (a >= b) {\n           \
    \ results = new Tuple<float, float>(a, b);\n        } else {\n            results\
    \ = new Tuple<float, float>(b, a);\n        }\n\n        return results;", " \
    \       float min = numbers[0];\n        float max = numbers[0];\n        float\
    \ smallest = min;\n        float largest = max;\n        int count = 1;\n    \
    \    for (int i = 0; i < numbers.Count - 1; i++) {\n            if (numbers[i]\
    \ <= min || min == 0.0f) {\n                min = numbers[i];\n              \
    \  smallest = numbers[i];\n            } else {\n                smallest = numbers[i];\n\
    \            }\n            if (numbers[i] > max || max == 0.0f) {\n         \
    \       max = numbers[i];\n                largest = numbers[i];\n           \
    \ } else {\n                largest = numbers[i];\n            }\n           \
    \ count++;\n        }\n        Tuple<float, float> t = new Tuple<float, float>(smallest,\
    \ largest);\n        return t;", "        if (numbers == null || numbers.Count\
    \ == 0) return default(Tuple<float, float>);\n        float x = numbers[0];\n\
    \        float y = numbers[0];\n        float dX = x;\n        float dY = y;\n\
    \        float minDistance = Float.MaxValue;\n        float minDistanceIndex =\
    \ 0;\n        for (int i = 1; i < numbers.Count; i++) {\n            float dx\
    \ = x - numbers[i];\n            float dy = y - numbers[i];\n            float\
    \ distanceSquared = (dx * dx) + (dy * dy);\n            if (distanceSquared <\
    \ minDistance) {\n                minDistance = distanceSquared;\n           \
    \     minDistanceIndex = i;\n            }\n        }\n        return Tuple.Create(x,\
    \ y);", "        float smallest = Math.Min(numbers.Min(), numbers.Max());\n  \
    \      float largest = Math.Max(numbers.Min(), numbers.Max());\n        if (smallest\
    \ == largest) {\n            return Tuple.Create(smallest, smallest);\n      \
    \  }\n        float smallerThan, largerThan;\n        float closest = smallest\
    \ - 1f;\n        List<float> numbersToFind = numbers.Where(n => n != smallest\
    \ && n != largest).ToList();\n        float middleValue = ((smallest + largest)\
    \ / 2f) - 1f;\n        float smallerValue = smallest;\n        float largerValue\
    \ = largest;\n        bool moreSmall = true;\n        bool moreLarger = true;\n\
    \        float closenessToSmallest = null;\n        float closenessToLarger =\
    \ null;\n        foreach (float number in numbersToFind) {\n            float\
    \ diff = number - middleValue;\n            if (Math.Abs(diff) < closenessToSmallest)\
    \ {\n                smallerValue = number;\n                closenessToSmallest\
    \ = diff;\n            }\n            if (Math.Abs(diff) < closenessToLarger)\
    \ {\n                largerValue = number;\n                closenessToLarger\
    \ = diff;\n            }\n            if (diff < 0f) {\n                moreSmall\
    \ = false;\n                moreLarger = false;\n            }\n            if\
    \ (diff > 0f) {\n                moreSmall = true;\n                moreLarger\
    \ = true;\n            }\n        }\n        if (moreSmall) {\n            smallerValue\
    \ = smallerValue + 1f;\n        }\n        if (moreLarger) {\n            largerValue\
    \ = largerValue + 1f;\n        }\n        smallest = smallerValue;\n        largest\
    \ = largerValue;\n        return Tuple.Create(smallest, largest);", "        //\
    \ sort numbers first so that pairs are next to each other\n        Array.Sort(numbers);\n\
    \n        // find first pair\n        float firstPair = numbers[0];\n\n      \
    \  // find second pair\n        float secondPair = numbers[0];\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            if (numbers[i] - firstPair < secondPair\
    \ - numbers[i]) {\n                secondPair = numbers[i];\n            }\n \
    \       }\n\n        // return smallest and largest elements\n        return new\
    \ Tuple<float, float>(firstPair, secondPair);", "        Debug.Assert(numbers.Count\
    \ >= 2);\n        float firstItem = numbers.First();\n        float secondItem\
    \ = numbers.Last();\n        float distance = Math.Abs(firstItem - secondItem);\n\
    \        if (firstItem < secondItem) {\n            float tempFirstItem = firstItem;\n\
    \            firstItem = secondItem;\n            secondItem = tempFirstItem;\n\
    \        }\n        List<float> closestElements = new List<float>();\n       \
    \ closestElements.Add(firstItem);\n        closestElements.Add(secondItem);\n\
    \        float currentDistance;\n        bool foundFirst = false;\n        bool\
    \ foundSecond = false;\n        for(int i = 1; i < numbers.Count; i += 2) {\n\
    \            currentDistance = Math.Abs(numbers[i - 1] - numbers[i]);\n      \
    \      if (foundFirst) {\n                if (currentDistance < distance) {\n\
    \                    foundSecond = false;\n                    distance = currentDistance;\n\
    \                    closestElements[closestElements.Count - 2] = numbers[i];\n\
    \                }\n            }\n            if (foundSecond) {\n          \
    \      if (currentDistance < distance) {\n                    foundFirst = false;\n\
    \                    distance = currentDistance;\n                    closestElements[closestElements.Count\
    \ - 1] = numbers[i];\n                }\n            }\n            if (currentDistance\
    \ < distance) {\n                foundFirst = true;\n                foundSecond\
    \ = false;\n                closestElements[closestElements.Count - 1] = numbers[i];\n\
    \            }\n        }\n        return Tuple.Create(closestElements[0], closestElements[1]);",
  "        // Convert each number to a float and sort the list from smallest to largest\n\
    \        var listOfFloats = numbers.Select(f => (float)f).OrderBy(f => f).ToList();\n\
    \n        // Select the closest two elements (i.e. largest and smallest). \n \
    \       // We assume that the list is sorted from smallest to largest.\n     \
    \   // For a tie between highest and lowest number the returned numbers should\
    \ be \n        // the same.\n        var maxNum = listOfFloats.TakeWhile(f =>\
    \ f < listOfFloats.Skip(1).FirstOrDefault()).FirstOrDefault();\n        var minNum\
    \ = listOfFloats.Skip(1).FirstOrDefault();\n\n        // The difference between\
    \ the min and max numbers\n        var difference = maxNum - minNum;\n\n     \
    \   // The square of the difference\n        var squaredDifference = (float)Math.Pow(difference,\
    \ 2);\n\n        // The square of the sum\n        var sumOfSquaredDifferences\
    \ = listOfFloats.Sum(f => squaredDifference);\n\n        // The difference between\
    \ the sum and one third the sum of the squared differences\n        var differenceBetweenSumAnd1ThirdSumOfSquaredDifferences\
    \ = sumOfSquaredDifferences / 3.0f;\n\n        // The square of the difference\
    \ between the sum and one third the sum of the squared differences\n        var\
    \ differenceBetweenSquareOfDifferenceBetweenSumAnd1ThirdSumOfSquaredDifferences\
    \ = squaredDifference / 3.0f;\n\n        // The result is the maximum between\
    \ the max and min numbers\n        var result = Math.Max(maxNum, minNum);\n\n\
    \        // The result is either the lowest or the highest number from the list.\n\
    \        // This must be one of the two values that minimizes the difference between\
    \ the max and min numbers\n        // or the difference between the min and max\
    \ numbers.\n        if (result < minNum || result > maxNum)\n        {\n     \
    \       result = Math.Min(result, minNum, maxNum);\n        }\n\n        // Return\
    \ the result as a tuple\n        return Tuple.Create(result, result);", "    \
    \    if (numbers.Count <= 2) return null;\n\n        float smallest = numbers.First();\n\
    \        float largest = numbers.Last();\n        var sorted = numbers.OrderBy(n\
    \ => Math.Abs(n - smallest)).ThenByDescending(n => Math.Abs(n - largest));\n \
    \       float smallest2 = sorted.First();\n        float largest2 = sorted.Last();\n\
    \        if (Math.Abs(smallest - smallest2) < Math.Abs(largest - largest2)) return\
    \ new Tuple<float, float>(smallest, largest);\n        return new Tuple<float,\
    \ float>(smallest2, largest2);", "        Debug.Assert(numbers.Count >= 2);\n\
    \        float minX = numbers.Min();\n        float maxX = numbers.Max();\n  \
    \      float minY = numbers.Min();\n        float maxY = numbers.Max();\n    \
    \    for (int i = 1; i < numbers.Count; i++) {\n            float x = numbers[i];\n\
    \            float y = (numbers[i] - minX) * (numbers[i] - minX) + (maxY - minY)\
    \ * (maxY - minY);\n            if (Math.Abs(x - minX) < Math.Abs(x - maxX)) {\n\
    \                minY = y;\n            } else if (Math.Abs(x - maxX) < Math.Abs(x\
    \ - minX)) {\n                maxY = y;\n            } else {\n              \
    \  float xMin = (numbers[i - 1] - minX) * (numbers[i - 1] - minX) + (maxY - minY)\
    \ * (maxY - minY);\n                float xMax = (numbers[i] - minX) * (numbers[i]\
    \ - minX) + (maxY - minY) * (maxY - minY);\n                if (xMin < xMax) {\n\
    \                    minX = x;\n                    maxX = x;\n              \
    \  } else {\n                    minY = y;\n                    maxY = y;\n  \
    \              }\n            }\n        }\n        return new Tuple<float, float>(minX,\
    \ minY);", "        List<float> tempNumbers = numbers.ToList();\n        float\
    \ small = tempNumbers.Min();\n        float large = tempNumbers.Max();\n     \
    \   if (tempNumbers.Count == 2) {\n            return new Tuple<float, float>(small,\
    \ large);\n        }\n        bool found = false;\n        float smallestDifference\
    \ = float.MaxValue;\n        int smallestIndex = 0;\n        int largestIndex\
    \ = 0;\n        for (int i = 0; i < tempNumbers.Count - 1; i++) {\n          \
    \  float difference = tempNumbers[i + 1] - tempNumbers[i];\n            if (difference\
    \ < smallestDifference) {\n                smallestDifference = difference;\n\
    \                smallestIndex = i;\n            }\n            if (difference\
    \ > largestDifference) {\n                largestDifference = difference;\n  \
    \              largestIndex = i;\n            }\n        }\n        Tuple<float,\
    \ float> closestToLeft = FindClosestElements(tempNumbers.GetRange(0, smallestIndex),\
    \ large, smallestIndex);\n        Tuple<float, float> closestToRight = FindClosestElements(tempNumbers.GetRange(smallestIndex\
    \ + 1, tempNumbers.Count - 1), large, smallestIndex + 1);\n        if (smallestDifference\
    \ < largestDifference) {\n            if (closestToLeft.Item1 < closestToRight.Item1)\
    \ {\n                return closestToLeft;\n            } else {\n           \
    \     return closestToRight;\n            }\n        } else {\n            if\
    \ (closestToLeft.Item1 < closestToRight.Item1) {\n                return closestToRight;\n\
    \            } else {\n                return closestToLeft;\n            }\n\
    \        }", "        if (numbers.Count == 0) return new Tuple<float, float>(numbers.Count,\
    \ numbers.Count);\n        // Store the minimum and maximum number\n        float\
    \ min = numbers.First();\n        float max = numbers.Last();\n        // Find\
    \ the two closest numbers to the minimum and maximum\n        float closest1 =\
    \ FindClosest(numbers, min);\n        float closest2 = FindClosest(numbers, max);\n\
    \        // Find the difference between the minimum and maximum\n        float\
    \ difference = max - min;\n        // Return the result\n        return new Tuple<float,\
    \ float>(closest1, closest2);", "        // For efficiency this implementation\
    \ uses a Dictionary<long, float> to store the numbers with the smallest delta\n\
    \        // to the current number in the loop. Without a Dictionary, the program\
    \ would have to test the deltas every\n        // time around the loop. If there\
    \ are N numbers, it means it would have to test N deltas every time. On the\n\
    \        // other hand, using Dictionary<TKey,TValue> takes O(1) average time\
    \ per lookup, so if we have N numbers, we are\n        // looking at O(N log N)\
    \ runtime.\n        HashSet<long> deltaSet = new HashSet<long>();\n\n        long\
    \ smallestDelta = numbers.First() - numbers.Last();\n        long smallestKey\
    \ = numbers.First();\n        float smallestNumber = numbers.First();\n      \
    \  float closestSmallerNumber = numbers.First();\n        float closestLargerNumber\
    \ = numbers.Last();\n        long currentKey;\n        float currentNumber;\n\
    \        float closestNumber;\n        float closestDelta = numbers.First();\n\
    \        float closestNumberTwo;\n\n        foreach (float currentNumber in numbers)\
    \ {\n            long currentDelta = currentNumber - numbers.Last();\n       \
    \     if (deltaSet.Contains(currentDelta)) {\n                // If we have seen\
    \ this delta before, update the smallest delta and the smallest key.\n       \
    \         // This takes O(log N) time.\n                smallestDelta = currentDelta;\n\
    \                smallestKey = currentKey;\n            }\n            else {\n\
    \                // If we have not seen this delta before, add it to the hashset\
    \ and set the smallest delta\n                // to zero (this takes O(1) time\
    \ in the worst case).\n                deltaSet.Add(currentDelta);\n         \
    \       smallestDelta = float.NegativeInfinity;\n            }\n\n           \
    \ // Now find the smallest number that has a smaller delta to the current number\
    \ than the\n            // smallest delta to the previous number or the smallest\
    \ delta.\n            if (smallestDelta > currentDelta || (smallestDelta == currentDelta\
    \ && currentKey > smallestKey)) {\n                smallestDelta = currentDelta;\n\
    \                smallestKey = currentKey;\n                closestSmallerNumber\
    \ = currentNumber;\n            }\n\n            // Now find the largest number\
    \ that has a larger delta to the current number than the\n            // smallest\
    \ delta to the previous number or the smallest delta.\n            if (currentDelta\
    \ > closestDelta || (currentDelta == closestDelta && currentKey < smallestKey))\
    \ {\n                closestDelta = currentDelta;\n                closestKey\
    \ = currentKey;\n                closestLargerNumber = currentNumber;\n      \
    \      }\n\n            currentKey = Convert.ToInt64(Math.Round(currentKey, MidpointRounding.AwayFromZero));\n\
    \        }\n\n        // ", "        float smallest = (float)0;\n        float\
    \ biggest = (float)0;\n        float smallest2 = (float)0;\n        float biggest2\
    \ = (float)0;\n        float delta = (float)0;\n        float delta2 = (float)0;\n\
    \        float squareSum = (float)0;\n        foreach (float number in numbers)\
    \ {\n            float squared = Math.Pow(number, 2);\n            if (number\
    \ < smallest || ((number == smallest) && (smallest < biggest))) {\n          \
    \      smallest = number;\n                smallest2 = smallest2;\n          \
    \      delta2 = delta2;\n                delta2 = smallest2 - number;\n      \
    \          squareSum = squareSum + delta2;\n            }\n            if (number\
    \ > biggest || ((number == biggest) && (biggest < smallest))) {\n            \
    \    biggest = number;\n                biggest2 = biggest2;\n               \
    \ delta2 = delta2;\n                delta2 = biggest2 - number;\n            \
    \    squareSum = squareSum + delta2;\n            }\n        }\n        if (smallest2\
    \ == biggest2) {\n            return Tuple.Create(smallest, smallest);\n     \
    \   }\n        if (smallest2 < biggest2) {\n            return Tuple.Create(smallest,\
    \ biggest2);\n        }\n        return Tuple.Create(biggest2, smallest2);", " \
    \       double smallestDifference = double.MaxValue;\n        double bestDistance\
    \ = double.MaxValue;\n        float bestLeft = double.MaxValue;\n        float\
    \ bestRight = double.MinValue;\n        foreach (float number in numbers) {\n\
    \            // Convert number to a double\n            double doubleNumber =\
    \ (double)number;\n            double difference = Math.Abs(doubleNumber - bestDistance);\n\
    \            if (difference < smallestDifference) {\n                bestDistance\
    \ = difference;\n                bestLeft = number;\n                bestRight\
    \ = doubleNumber;\n            }\n        }\n        return new Tuple<float, float>(bestLeft,\
    \ bestRight);", "        var a = numbers.Select(num => new { Number = num, Dist\
    \ = num.Subtract(numbers.First()) }).ToList();\n        var closest = a.OrderBy(item\
    \ => Math.Abs(item.Dist)).First();\n        return new Tuple<float, float>(closest.Number,\
    \ closest.Dist);", "        if (numbers == null) {\n            throw new ArgumentNullException(\"\
    numbers\");\n        }\n        if (numbers.Count < 2) {\n            throw new\
    \ ArgumentException(\"At least two numbers are required\", \"numbers\");\n   \
    \     }\n        float bestMatch1 = Math.Abs(numbers[0]);\n        float bestMatch2\
    \ = Math.Abs(numbers[0]);\n        float diff1 = bestMatch1;\n        float diff2\
    \ = bestMatch2;\n        foreach (float number in numbers) {\n            float\
    \ diff = Math.Abs(number);\n            if (diff < diff1) {\n                bestMatch2\
    \ = bestMatch1;\n                bestMatch1 = diff;\n                diff1 = diff;\n\
    \            } else if (diff > diff2) {\n                bestMatch2 = diff;\n\
    \                diff2 = diff;\n            }\n        }\n        return new Tuple<float,\
    \ float>(bestMatch1, bestMatch2);", "        var result = new List<float>();\n\
    \        var differences = new List<float>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            if (result.Count == 0)\n                result.Add(numbers[i]);\n\
    \            else\n                result.Add((float)Math.Sqrt(Math.Pow(result[0]\
    \ - numbers[i], 2) + Math.Pow(result[1] - numbers[i], 2)));\n\n            differences.Add(numbers[i]\
    \ - result[result.Count - 1]);\n        }\n\n        var smallestDifference =\
    \ Math.Min(differences.Min());\n        var greatestDifference = Math.Max(differences.Max());\n\
    \n        return Tuple.Create(smallestDifference, greatestDifference);", "   \
    \     float min1 = numbers[0];\n        float min2 = numbers[0];\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            float tmp1 = numbers[i];\n\
    \            float tmp2 = numbers[i];\n            float distance = Sqrt((tmp1\
    \ - min1) * (tmp1 - min1) + (tmp2 - min2) * (tmp2 - min2));\n            if (distance\
    \ < 0.0f) {\n                min1 = tmp1;\n                min2 = tmp2;\n    \
    \        }\n        }\n        return new Tuple<float, float>(min1, min2);", " \
    \       int size = (int)numbers.Count;\n        if (size < 2) return Tuple.Create(numbers[0],\
    \ numbers[0]);\n        if (size == 2) return Tuple.Create(numbers[0], numbers[1]);\n\
    \n        // Find the numbers that would be closer to each other if they were\
    \ just sorted, then remove them from numbers\n        List<float> sortedNumbers\
    \ = numbers.OrderBy(num => num).ToList();\n\n        // Find the difference between\
    \ numbers[0] and numbers[1]\n        float deltaX = sortedNumbers[0] - sortedNumbers[1];\n\
    \        // Find the difference between numbers[1] and numbers[2]\n        float\
    \ deltaY = sortedNumbers[1] - sortedNumbers[2];\n        // Find the difference\
    \ between numbers[2] and numbers[3]\n        float deltaZ = sortedNumbers[2] -\
    \ sortedNumbers[3];\n\n        // The smaller of the three is our answer, return\
    \ it\n        if (deltaX < deltaY && deltaX < deltaZ)\n            return Tuple.Create(sortedNumbers[0],\
    \ sortedNumbers[2]);\n        else if (deltaY < deltaZ)\n            return Tuple.Create(sortedNumbers[1],\
    \ sortedNumbers[3]);\n        else\n            return Tuple.Create(sortedNumbers[2],\
    \ sortedNumbers[0]);", "        float[] numberArr = numbers.ToArray();\n     \
    \   Array.Sort(numberArr);\n        float closest = numberArr[0];\n        float\
    \ smallest = numberArr[0];\n        float largest = numberArr[0];\n        float\
    \ tempClosest = numberArr[0];\n        float tempSmallest = numberArr[0];\n  \
    \      float tempLargest = numberArr[0];\n        for (int i = 0; i < numberArr.Length\
    \ - 1; i++) {\n            if (numberArr[i + 1] - numberArr[i] == 0) {\n     \
    \           float temp = tempClosest;\n                tempClosest = numberArr[i\
    \ + 1];\n                tempSmallest = temp;\n                tempLargest = temp;\n\
    \            } else {\n                float temp = numberArr[i + 1];\n      \
    \          if (temp - numberArr[i] == 0) {\n                    float temp1 =\
    \ tempSmallest;\n                    tempSmallest = temp1;\n                 \
    \   tempLargest = temp1;\n                } else {\n                    float\
    \ temp1 = tempLargest;\n                    tempLargest = temp1;\n           \
    \         tempSmallest = temp1;\n                }\n            }\n        }\n\
    \        return new Tuple<float, float>(closest, smallest);", "        double\
    \ min = double.MaxValue;\n        double max = double.MinValue;\n        float\
    \ minElement = numbers.First();\n        float maxElement = numbers.Last();\n\
    \        foreach(float number in numbers) {\n            double newMin = Math.Abs(minElement\
    \ - number);\n            double newMax = Math.Abs(maxElement - number);\n   \
    \         if (newMin < min) min = newMin;\n            if (newMax > max) max =\
    \ newMax;\n        }\n        return new Tuple<float, float>(min, max);", "  \
    \      float closest = numbers.First();\n        float smallest = numbers.First();\n\
    \        float largest = numbers.First();\n        if (numbers.Count < 2) throw\
    \ new ArgumentException(\"numbers must contain at least two elements\");\n   \
    \     if (numbers.Count > 2) // otherwise don't bother with the 2nd case (which\
    \ is trivial)\n        {\n            float currentClosest = numbers.First();\n\
    \            float currentSmallest = numbers.First();\n            float currentLargest\
    \ = numbers.First();\n            for (int i = 1; i < numbers.Count; i++)\n  \
    \          {\n                float next = numbers[i];\n                float\
    \ currentDiff = Math.Abs(next - currentClosest);\n                if (currentDiff\
    \ < currentSmallest)\n                {\n                    currentClosest =\
    \ next;\n                    currentSmallest = currentDiff;\n                }\n\
    \                else if (currentDiff > currentLargest)\n                {\n \
    \                   currentLargest = currentDiff;\n                }\n       \
    \         else if (currentDiff == currentSmallest)\n                {\n      \
    \              if (next < currentClosest)\n                    {\n           \
    \             currentClosest = next;\n                        currentSmallest\
    \ = currentDiff;\n                    }\n                    else if (next > currentLargest)\n\
    \                    {\n                        currentLargest = currentDiff;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ Tuple.Create(closest, largest);", "        float smallestDist = float.MaxValue;\n\
    \        int smallestIdx = -1;\n        float largestDist = float.MaxValue;\n\
    \        int largestIdx = -1;\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            float thisDist = GetDistance(numbers[i - 1], numbers[i]);\n \
    \           if (smallestDist > thisDist) {\n                smallestDist = thisDist;\n\
    \                smallestIdx = i - 1;\n            }\n            if (largestDist\
    \ < thisDist) {\n                largestDist = thisDist;\n                largestIdx\
    \ = i;\n            }\n        }\n        return Tuple.Create(numbers[smallestIdx],\
    \ numbers[largestIdx]);", "        Debug.Assert(numbers.Count >= 2);\n       \
    \ double minimum = Math.Min(numbers.First(), numbers.Last());\n        double\
    \ maximum = Math.Max(numbers.First(), numbers.Last());\n\n        // We need a\
    \ closed interval so we divide our minimum and maximum by two and make sure they\
    \ are close.\n        // The number we're dividing by isn't important, just that\
    \ it's close.\n        minimum -= Math.Sign(minimum) * Math.Abs(Math.Truncate(minimum\
    \ / 2.0f));\n        maximum += Math.Sign(maximum) * Math.Abs(Math.Truncate(maximum\
    \ / 2.0f));\n\n        // Now let's find all values within our closed interval\
    \ of our minimum and maximum\n        List<float> results = new List<float>();\n\
    \n        double current;\n        double next;\n        double prev;\n\n    \
    \    foreach (double d in new List<double>((numbers.ToList()).OrderBy(n => n)))\
    \ {\n            current = d;\n            if (current > maximum) {\n        \
    \        break;\n            }\n            next = current + Math.Sign(current)\
    \ * Math.Abs(Math.Truncate(current / 2.0f));\n\n            if (next < minimum)\
    \ {\n                break;\n            }\n\n            // If the value is within\
    \ the closed interval we're looking for we add it into our result list\n     \
    \       if (current >= minimum && current <= maximum) {\n                results.Add(current);\n\
    \            }\n\n            // If we have our first value greater than our next\
    \ value then we know we're looking for the next\n            // value in the range\
    \ we're looking for. Otherwise, we'll look at the previous value. \n         \
    \   // If we've gone through the entire range we're looking for then we can stop\
    \ looking.\n            if (next > minimum && next <= maximum) {\n           \
    \     prev = next;\n            } else {\n                prev = current;\n  \
    \          }\n        }\n        if (results.Count > 0) {\n            return\
    \ new Tuple<float, float>(results.Min(), results.Max());\n        }\n        return\
    \ Tuple.Create(minimum, maximum);", "        if (numbers.Count < 2) throw new\
    \ ArgumentException(\"numbers must have at least 2 elements\");\n        double\
    \ closestX = double.MaxValue;\n        double closestY = double.MaxValue;\n  \
    \      for (int index = 1; index < numbers.Count; ++index) {\n            double\
    \ currentX = (numbers[index - 1] + numbers[index]);\n            double currentY\
    \ = (numbers[index - 1] - numbers[index]);\n            double currentDistance\
    \ = Math.Sqrt((currentX * currentX) + (currentY * currentY));\n            double\
    \ currentDistanceSqrt = Math.Sqrt(currentDistance);\n            if (currentDistance\
    \ < closestDistance) {\n                closestX = currentX;\n               \
    \ closestY = currentY;\n                closestDistance = currentDistance;\n \
    \           } else if (currentDistanceSqrt < closestDistanceSqrt) {\n        \
    \        closestX = currentX;\n                closestY = currentY;\n        \
    \        closestDistanceSqrt = currentDistanceSqrt;\n            }\n        }\n\
    \        if (closestX == double.MaxValue || closestY == double.MaxValue) return\
    \ default(Tuple<float, float>);\n        return Tuple.Create(closestX, closestY);",
  "        float small = numbers[0].Abs();\n        float large = numbers[0].Abs();\n\
    \        float best = numbers[0];\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            float tmp = numbers[i].Abs();\n            if (tmp < small)\
    \ {\n                small = tmp;\n                best = numbers[i];\n      \
    \      }\n            if (tmp > large) {\n                large = tmp;\n     \
    \       }\n        }\n        return Tuple.Create(best, small);", "        var\
    \ distances = new List<float>();\n        float smallest = numbers.Min();\n  \
    \      float largest = numbers.Max();\n\n        if (smallest > largest) {\n \
    \           throw new ArgumentException(\"First argument must be greater than\
    \ the second argument.\");\n        }\n\n        float distance = smallest;\n\n\
    \        if (numbers.Count == 2) {\n            // We have two elements. Return\
    \ them.\n            return Tuple.Create(numbers.First(), numbers.Last());\n \
    \       }\n\n        // We have more than one element. We can look at them in\
    \ pairs.\n        foreach (float num in numbers) {\n            distances.Add(Math.Abs((num\
    \ - smallest)));\n        }\n\n        distances.Sort((x, y) => Math.Sign(x -\
    \ y));\n\n        // Look at the first two elements and see which one is closer.\n\
    \        float distance = float.MaxValue;\n        float x = distances[0];\n \
    \       float y = distances[1];\n        if (Math.Sign(x - y) != Math.Sign(y -\
    \ x)) {\n            throw new InvalidOperationException(\"The list must be in\
    \ ascending order.\");\n        }\n        if (Math.Abs(x - y) < distance) {\n\
    \            distance = x;\n        }\n        else {\n            distance =\
    \ y;\n        }\n\n        // If there are only two elements in the list, return\
    \ them.\n        if (numbers.Count == 2) {\n            return Tuple.Create(numbers.First(),\
    \ numbers.Last());\n        }\n\n        // At this point we know there are at\
    \ least two elements in the list.\n        // There are three possible cases:\n\
    \        //\n        // 1. The first element is the smallest, the second is the\
    \ largest. Return them.\n        // 2. The first element is the largest, the second\
    \ is the smallest. Return them.\n        // 3. The first and second elements are\
    \ equal. Return the smaller of the two.\n\n        // Case 1: The first element\
    \ is the smallest, the second is the largest. Return them.\n        if (Math.Abs(x\
    \ - smallest) < distance) {\n            return Tuple.Create(smallest, numbers.Last());\n\
    \        }\n        else {\n            return Tuple.Create(numbers.First(), largest);\n\
    \        }\n\n        // Case 2: The first element is the largest, the second\
    \ is the smallest. Return them.\n        else if (Math.Abs(y - smallest) < distance)\
    \ {\n            return Tuple.Create(numbers.First(), smallest);\n        }\n\
    \        else {\n            return Tuple.Create(largest, numbers.Last());\n \
    \       }\n\n        // Case 3: The first and second elements are equal. Return\
    \ the smaller of the two.\n        else if (Math.Abs(x - largest) < distance)\
    \ {\n            return Tuple.Create(largest, smallest);\n        }\n        else\
    \ {\n            return Tuple.Create(smallest, largest);\n        }", "      \
    \  long maxDifference = 0;\n        var first = numbers.ElementAt(0);\n      \
    \  var second = numbers.ElementAt(1);\n        var difference = Convert.ToDouble(Math.Sqrt(Math.Pow(first\
    \ - second, 2)));\n        if (difference > maxDifference) {\n            maxDifference\
    \ = difference;\n            second = first;\n        }\n        difference =\
    \ Convert.ToDouble(Math.Sqrt(Math.Pow(second - first, 2)));\n        if (difference\
    \ > maxDifference) {\n            maxDifference = difference;\n            first\
    \ = second;\n        }\n        return Tuple.Create(first, second);", "      \
    \  if (numbers.Count < 2) {\n            return null;\n        }\n        var\
    \ max = numbers.Max();\n        var min = numbers.Min();\n        var sum = 0;\n\
    \        foreach (var number in numbers) {\n            sum += number;\n     \
    \   }\n        var avg = sum / numbers.Count;\n\n        // See if average is\
    \ close to max or min\n        if (Math.Abs(max - avg) < Math.Abs(max - min))\
    \ {\n            // If average is closer to max, find the closest to min\n   \
    \         var closestToMin = numbers.Where(x => Math.Abs(x - min) < Math.Abs(x\
    \ - avg)).FirstOrDefault();\n            var closestToMax = numbers.Where(x =>\
    \ Math.Abs(x - avg) < Math.Abs(x - max)).FirstOrDefault();\n            if (closestToMin\
    \ != null) {\n                return Tuple.Create(closestToMin, closestToMax);\n\
    \            }\n        }\n\n        // If average is closer to min, find the\
    \ closest to max\n        var closestToMax = numbers.Where(x => Math.Abs(x - avg)\
    \ < Math.Abs(x - min)).FirstOrDefault();\n        var closestToMin = numbers.Where(x\
    \ => Math.Abs(x - max) < Math.Abs(x - avg)).FirstOrDefault();\n        if (closestToMax\
    \ != null) {\n            return Tuple.Create(closestToMax, closestToMin);\n \
    \       }\n\n        return null;", "        int n = numbers.Count;\n        float\
    \ smaller = numbers.First();\n        float larger = numbers.Last();\n       \
    \ if (n == 2 || n == 3) return (Tuple.Create(smaller, larger));\n\n        if\
    \ (n > 3) {\n            int i = 0;\n            float smaller2 = numbers[i++];\n\
    \            float larger2 = numbers[i++];\n            for (int j = 2; j < n;\
    \ j++) {\n                float smaller3 = numbers[j - 2];\n                float\
    \ larger3 = numbers[j - 1];\n                float smaller1 = numbers[i + 2];\n\
    \                float larger1 = numbers[i + 1];\n                float smaller4\
    \ = numbers[j + 2];\n                float larger4 = numbers[j + 1];\n\n     \
    \           float delta = (larger4 - smaller4) - (larger3 - smaller3);\n     \
    \           if (delta > 0) {\n                    delta = (larger1 - smaller1)\
    \ - (larger2 - smaller2);\n                    if (delta > 0) {\n            \
    \            delta = (larger3 - smaller3) - (larger4 - smaller4);\n          \
    \              if (delta > 0) {\n                            delta = (smaller1\
    \ - larger1) - (smaller2 - larger2);\n                            if (delta >\
    \ 0) {\n                                delta = (smaller3 - larger3) - (smaller4\
    \ - larger4);\n                                if (delta > 0) {\n            \
    \                        smaller = smaller1;\n                               \
    \     larger = smaller3;\n                                }\n                \
    \                else {\n                                    smaller = smaller3;\n\
    \                                    larger = smaller4;\n                    \
    \            }\n                            }\n                            else\
    \ {\n                                smaller = smaller1;\n                   \
    \             larger = smaller2;\n                            }\n            \
    \            }\n                        else {\n                            smaller\
    \ = smaller1;\n                            larger = smaller2;\n              \
    \          }\n                    }\n                    else {\n            \
    \            smaller = smaller1;\n                        larger = smaller2;\n\
    \                    }\n                }\n                else {\n          \
    \          smaller = smaller1;\n                    larger = smaller2;\n     \
    \           }\n            }\n        }\n        return (Tuple.Create(smaller,\
    \ larger));", "        // Find the two closest numbers from our list\n       \
    \ var closest = numbers.Skip(1).Take(2).ToList();\n        var closest2 = numbers.Skip(1).ToList();\n\
    \        // Find the difference between each number and each of the two closest\
    \ numbers\n        foreach (var x in closest) {\n            foreach (var y in\
    \ closest2) {\n                var difference = Math.Abs(x - y);\n           \
    \     if (difference < closest[0].Value) {\n                    closest.Clear();\n\
    \                    closest2.Clear();\n                    return new Tuple<float,\
    \ float>(y, x);\n                }\n                if (difference < closest[1].Value)\
    \ {\n                    closest[0] = y;\n                    closest[1] = x;\n\
    \                }\n            }\n        }\n        // If no numbers are close\
    \ return the first two numbers that we've found\n        if (closest.Count !=\
    \ 2) return new Tuple<float, float>(closest[0], closest[1]);\n        // If we\
    \ get this far we've found two pairs of numbers that are\n        // the closest\
    \ so return the smallest of these pairs\n        var minDiff = Math.Abs(closest[0].Value\
    \ - closest[1].Value);\n        foreach (var x in closest) {\n            if (Math.Abs(x.Value\
    \ - closest[0].Value) < minDiff) {\n                minDiff = Math.Abs(x.Value\
    \ - closest[0].Value);\n            }\n            if (Math.Abs(x.Value - closest[1].Value)\
    \ < minDiff) {\n                minDiff = Math.Abs(x.Value - closest[1].Value);\n\
    \            }\n        }\n        return new Tuple<float, float>(closest[0],\
    \ closest[1]);", "        float minValue = numbers.Min();\n        float maxValue\
    \ = numbers.Max();\n        if (minValue > maxValue) {\n            throw new\
    \ ArgumentException(\"Cannot find closest: numbers are out of order!\");\n   \
    \     }\n\n        int index = 0;\n        float closestValue = minValue;\n  \
    \      while (index < numbers.Count - 1 && numbers[index] <= closestValue) {\n\
    \            index++;\n        }\n\n        while (index > 0) {\n            if\
    \ (numbers[index] > closestValue) {\n                index--;\n            }\n\
    \            else {\n                break;\n            }\n        }\n\n    \
    \    return new Tuple<float, float>(numbers[index], numbers[index + 1]);", " \
    \       Debug.Assert(numbers.Count >= 2);\n        double biggestDistance = Math.Abs(numbers[0]\
    \ - numbers[1]);\n        foreach (var a in numbers) {\n            double currentDistance\
    \ = Math.Abs(a - numbers[1]);\n            if (currentDistance < biggestDistance)\
    \ {\n                biggestDistance = currentDistance;\n            }\n     \
    \   }\n        var smallerNumber = (from n in numbers where n < numbers[1] select\
    \ n).First();\n        var largerNumber = (from n in numbers where n > numbers[1]\
    \ select n).First();\n        return Tuple.Create(smallerNumber, largerNumber);",
  "        float smallest = numbers.Min();\n        float largest = numbers.Max();\n\
    \        int count = 0;\n        bool inOrder = true;\n        float smallestDifference\
    \ = float.MaxValue;\n        float largestDifference = float.MinValue;\n     \
    \   float difference;\n        foreach (float number in numbers) {\n         \
    \   if (inOrder) {\n                difference = float.Abs(number - largest);\n\
    \                if (difference < smallestDifference) {\n                    smallestDifference\
    \ = difference;\n                    smallest = number;\n                }\n \
    \               difference = float.Abs(number - smallest);\n                if\
    \ (difference > largestDifference) {\n                    largestDifference =\
    \ difference;\n                    largest = number;\n                }\n    \
    \        } else {\n                difference = float.Abs(number - smallest);\n\
    \                if (difference > largestDifference) {\n                    largestDifference\
    \ = difference;\n                    largest = number;\n                }\n  \
    \              difference = float.Abs(number - largest);\n                if (difference\
    \ < smallestDifference) {\n                    smallestDifference = difference;\n\
    \                    smallest = number;\n                }\n            }\n  \
    \          count++;\n            if (count == 2)\n            {\n            \
    \    inOrder = !inOrder;\n            }\n        }\n        return new Tuple<float,\
    \ float>(smallest, largest);", "        if (numbers.Count < 2) throw new ArgumentException(\"\
    Must have at least two numbers\", \"numbers\");\n        float currentNumber =\
    \ numbers.ElementAt(1);\n        float secondNumber = numbers.ElementAt(0);\n\
    \        // If there is a tie, return both\n        if (currentNumber == secondNumber)\
    \ return (Tuple.Create(currentNumber, currentNumber));\n        // If only one\
    \ is closer, return that\n        float currentDist = numbers[0].Abs() - currentNumber;\n\
    \        float secondDist = numbers[0].Abs() - secondNumber;\n        if (currentDist\
    \ < secondDist) return (Tuple.Create(currentNumber, secondNumber));\n        return\
    \ (Tuple.Create(secondNumber, currentNumber));", "        var result = new Tuple<float,\
    \ float>(numbers[0], numbers[0]);\n        foreach (var number in numbers) {\n\
    \            if (number > result.Item2) {\n                result = new Tuple<float,\
    \ float>(number, number);\n            }\n        }\n        return result;",
  "        var sortedNumbers = numbers.OrderBy(n => Math.Abs(n));\n        float closestNumber\
    \ = sortedNumbers[0];\n        float secondClosestNumber = sortedNumbers[1];\n\
    \        float smaller = Math.Abs(numbers[0]);\n        float larger = Math.Abs(numbers[1]);\n\
    \        // If both are equally close, return the smallest one\n        if (smaller\
    \ == larger) {\n            return new Tuple<float, float>(numbers[0], numbers[0]);\n\
    \        }\n        // If both are equally close, return the smallest one\n  \
    \      if (smaller < larger) {\n            return new Tuple<float, float>(numbers[1],\
    \ numbers[1]);\n        }\n        // If smaller is greater than larger, return\
    \ the smallest one\n        if (smaller > larger) {\n            return new Tuple<float,\
    \ float>(numbers[0], numbers[1]);\n        }\n        // Else, find the smallest\
    \ number that is larger than both numbers\n        float secondClosestSmaller\
    \ = sortedNumbers[1];\n        float secondClosestLarger = Math.Abs(numbers[1]);\n\
    \        if (secondClosestSmaller < secondClosestLarger) {\n            return\
    \ new Tuple<float, float>(numbers[0], numbers[1]);\n        } else {\n       \
    \     // Otherwise, we need to find the smallest number that is smaller than both\
    \ numbers\n            float secondClosestSmallerSmaller = sortedNumbers[0];\n\
    \            float secondClosestSmallerLarger = Math.Abs(numbers[0]);\n      \
    \      if (secondClosestSmallerSmaller < secondClosestSmallerLarger) {\n     \
    \           return new Tuple<float, float>(numbers[1], numbers[0]);\n        \
    \    } else {\n                // Else, we need to find the smallest number that\
    \ is greater than both numbers\n                float secondClosestLargerSmaller\
    \ = sortedNumbers[1];\n                float secondClosestLargerLarger = Math.Abs(numbers[1]);\n\
    \                if (secondClosestLargerSmaller < secondClosestLargerLarger) {\n\
    \                    return new Tuple<float, float>(numbers[0], numbers[1]);\n\
    \                } else {\n                    // Else, we need to return the\
    \ two numbers that we would return if they weren't equal\n                   \
    \ return new Tuple<float, float>(secondClosestLarger, secondClosestSmaller);\n\
    \                }\n            }\n        }", "        if (numbers.Count == 0)\
    \ return default(Tuple<float, float>);\n        if (numbers.Count == 1) return\
    \ new Tuple<float, float>(numbers[0], numbers[0]);\n        List<float> sorted\
    \ = numbers.OrderBy(n => n).ToList();\n        if (sorted[0] == sorted[1]) return\
    \ new Tuple<float, float>(sorted[0], sorted[0]);\n        var mid = numbers.Count\
    \ / 2;\n        var left = new List<float>(sorted.GetRange(0, mid));\n       \
    \ var right = new List<float>(sorted.GetRange(mid, numbers.Count - mid));\n  \
    \      var leftClosest = FindClosestElements(left);\n        var rightClosest\
    \ = FindClosestElements(right);\n        var leftDiff = leftClosest.Item1 - leftClosest.Item2;\n\
    \        var rightDiff = rightClosest.Item1 - rightClosest.Item2;\n        if\
    \ (leftDiff != rightDiff) {\n            if (leftDiff < rightDiff) return leftClosest;\n\
    \            else return rightClosest;\n        }\n        return new Tuple<float,\
    \ float>(leftClosest.Item1, rightClosest.Item1);", "        if (numbers.Count\
    \ < 2) throw new ArgumentException(\"Needs at least 2 numbers to compare.\", \"\
    numbers\");\n        numbers.Sort();\n        // Convert the numbers to doubles\
    \ so that we can compare them\n        double[] doubleNumbers = numbers.Select(x\
    \ => (double)x).ToArray();\n        double smallest = doubleNumbers[0];\n    \
    \    double largest = doubleNumbers[0];\n        for (int i = 0; i < numbers.Count\
    \ - 1; i++) {\n            double tmp = doubleNumbers[i];\n            if (tmp\
    \ < smallest) {\n                smallest = tmp;\n            }\n            else\
    \ if (tmp > largest) {\n                largest = tmp;\n            }\n      \
    \  }\n        return new Tuple<float, float>(smallest, largest);", "        float\
    \ closest = (float)numbers.Min();\n        float closest2 = (decimal)numbers.Min();\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            float test\
    \ = (float) numbers[i];\n            float test2 = (decimal)numbers[i];\n    \
    \        if (test < closest) {\n                closest2 = test2;\n          \
    \      closest = test;\n            } else if (test > closest) {\n           \
    \     closest2 = test2;\n                closest = test;\n            }\n    \
    \    }\n        return Tuple.Create((float)closest, closest2);", "        if (numbers.Count\
    \ < 2) {\n            throw new ArgumentException(\"numbers must be at least 2\
    \ long\");\n        }\n\n        // Compute minimum difference\n        float\
    \ minDiff = numbers[1].Abs() - numbers[0].Abs();\n\n        // Search for min\
    \ value greater than or equal to min difference\n        float bestNum2 = numbers[0].Abs();\n\
    \        float bestNum1 = numbers[1].Abs();\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            float diff = (numbers[i] - bestNum1).Abs();\n          \
    \  if (diff <= minDiff) {\n                bestNum2 = numbers[i].Abs();\n    \
    \            bestNum1 = bestNum2;\n            } else {\n                minDiff\
    \ = diff;\n                bestNum2 = numbers[i].Abs();\n                bestNum1\
    \ = bestNum2;\n            }\n        }\n\n        // return tuple with best found\
    \ value\n        return Tuple.Create(bestNum1, bestNum2);", "        IEnumerable<float>\
    \ sortedNumbers = numbers.OrderBy(n => n).ToArray();\n        if (sortedNumbers.Length\
    \ <= 2)\n            throw new ArgumentException(\"Must have at least two numbers\
    \ to compare\");\n        // The first two numbers will never be close enough\
    \ to each other\n        float a = sortedNumbers[0];\n        float b = sortedNumbers[1];\n\
    \        // The current best solution so far\n        float closest = a;\n   \
    \     // The current difference between a and b\n        float difference = a\
    \ - b;\n        // The next best solution so far\n        float nextClosest =\
    \ b;\n        // The next difference between a and b\n        float nextDifference\
    \ = a - b;\n        // The current difference between a and b\n        float differenceFromNextClosest\
    \ = a;\n        // The next best solution so far\n        float nextNextClosest\
    \ = a;\n        // The next difference between a and b\n        float nextNextDifference\
    \ = a - b;\n        // The current difference between a and b\n        float differenceFromNextNextClosest\
    \ = a;\n        // The next best solution so far\n        float nextNextNextClosest\
    \ = a;\n        // The next difference between a and b\n        float nextNextNextDifference\
    \ = a - b;\n        // The current difference between a and b\n        float differenceFromNextNextNextClosest\
    \ = a;\n        // The next best solution so far\n        float nextNextNextNextClosest\
    \ = a;\n        // The next difference between a and b\n        float nextNextNextNextDifference\
    \ = a - b;\n        // The current difference between a and b\n        float differenceFromNextNextNextNextClosest\
    \ = a;\n        // The next best solution so far\n        float nextNextNextNextNextClosest\
    \ = a;\n        // The next difference between a and b\n        float nextNextNextNextNextDifference\
    \ = a - b;\n\n        float bestDifference = difference;\n        float bestNextDifference\
    \ = nextDifference;\n\n        float bestNextNextDifference = nextNextDifference;\n\
    \        float bestNextNextNextDifference = nextNextNextDifference;\n        float\
    \ bestNextNextNextNextDifference = nextNextNextNextDifference;\n\n        float\
    \ bestNextNextNextNextDifference = nextNextNextNextNextDifference;\n\n       \
    \ float bestNextNextNextNextNextDifference = nextNextNextNextNextNextDifference;\n\
    \n        float bestNextNextNextNextNextNextDifference = nextNextNextNextNextNextNextDifference;\n\
    \n        float bestNextNextNextNextNextNextNextDifference = nextNextNextNextNextNextNextDifference;\n\
    \n        float bestNextNextNextNextNextNextNextDifference = nextNextNextNextNextNextNextNextDifference",
  "        double totalDifference;\n        double difference = Math.Abs(numbers.Last()\
    \ - numbers.First());\n        var currentClosest = new Tuple<float, float>(numbers.First(),\
    \ numbers.First());\n        var previousClosest = new Tuple<float, float>(numbers.First(),\
    \ numbers.First());\n        for (int i = 1; i < numbers.Count; i++) {\n     \
    \       double thisDifference = Math.Abs(numbers[i] - numbers.First());\n    \
    \        if (totalDifference == 0) {\n                totalDifference = thisDifference;\n\
    \                currentClosest = previousClosest;\n                previousClosest\
    \ = currentClosest;\n            } else if (thisDifference < totalDifference)\
    \ {\n                totalDifference = thisDifference;\n                currentClosest\
    \ = previousClosest;\n            } else {\n                totalDifference =\
    \ thisDifference;\n                previousClosest = currentClosest;\n       \
    \     }\n        }\n        return currentClosest;", "        // TODO: validate\
    \ that numbers has at least two elements\n        // TODO: throw ArgumentException\
    \ when numbers.length is less than 2\n        \n        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        \n        var middle = (min + max)\
    \ / 2;\n        \n        return Tuple.Create(max, middle);", "        Debug.Assert(numbers.Count\
    \ > 2);\n        float smallest = numbers[0];\n        float largest = numbers[0];\n\
    \        float diff = largest - smallest;\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            float num = numbers[i];\n            float diff = num -\
    \ smallest;\n            if (diff < diff) {\n                smallest = num;\n\
    \            } else {\n                largest = num;\n            }\n       \
    \ }\n        return Tuple.Create(smallest, largest);", "        float min1 = numbers[0];\n\
    \        float max1 = numbers[0];\n        float min2 = numbers[0];\n        float\
    \ max2 = numbers[0];\n\n        int minDiff = -1;\n        int maxDiff = -1;\n\
    \n        int minIndex = 0;\n        int maxIndex = 0;\n\n        for (int i =\
    \ 1; i < numbers.Count; i++) {\n            float current1 = numbers[i];\n   \
    \         float current2 = numbers[i];\n\n            int diff = 0;\n\n      \
    \      diff += (current1 - min1);\n            if (diff > minDiff) minDiff = diff;\n\
    \n            diff += (current2 - max1);\n            if (diff > maxDiff) maxDiff\
    \ = diff;\n\n            if (current1 < min1) {\n                min1 = current1;\n\
    \                minIndex = i;\n            }\n            if (current2 < max1)\
    \ {\n                max1 = current2;\n                maxIndex = i;\n       \
    \     }\n        }\n\n        if (minDiff < 0) {\n            // the numbers are\
    \ all negative\n            if (maxDiff < 0) {\n                return new Tuple<float,\
    \ float>(min1, min2);\n            } else {\n                return new Tuple<float,\
    \ float>(min2, max1);\n            }\n        } else if (maxDiff < 0) {\n    \
    \        // the numbers are all positive\n            if (minDiff < 0) {\n   \
    \             return new Tuple<float, float>(max1, max2);\n            } else\
    \ {\n                return new Tuple<float, float>(min2, max2);\n           \
    \ }\n        } else {\n            // They are both non-negative.\n          \
    \  if (minDiff > maxDiff) {\n                return new Tuple<float, float>(min1,\
    \ max2);\n            } else {\n                return new Tuple<float, float>(max1,\
    \ min2);\n            }\n        }", "        if (numbers.Count < 2) return null;\n\
    \        IEnumerable<Tuple<float, float>> pairs = numbers.Select((number, index)\
    \ => new {\n            Tuple = Tuple.Create(number, index),\n            Distance\
    \ = (float)Math.Sqrt((Math.Pow(number - numbers.ElementAt(index), 2)) + (Math.Pow(index\
    \ - numbers.ElementAt(numbers.Count - 1), 2))),\n            Indexed = index\n\
    \        }).OrderBy(element => element.Distance);\n        if (pairs.Count() >\
    \ 0) {\n            return pairs.ElementAt(0).Tuple;\n        }\n        return\
    \ null;", "        if (numbers.Count < 2) throw new ArgumentOutOfRangeException(\"\
    numbers\");\n        var a1 = numbers[0];\n        var a2 = numbers[1];\n    \
    \    var b1 = numbers.Take(2).ToArray().OrderBy(n => n).First();\n        var\
    \ b2 = numbers.Skip(1).Take(2).ToArray().OrderBy(n => n).First();\n        return\
    \ Tuple.Create(a1, a2);", "        // If there are no numbers then return an empty\
    \ tuple with both numbers\n        if (numbers.Count == 0) return Tuple.Create(numbers.First(),\
    \ numbers.First());\n\n        // We have 2 numbers so return them in order and\
    \ find the two closest numbers to each\n        // other\n        float left =\
    \ Math.Abs(numbers.First());\n        float right = Math.Abs(numbers.Last());\n\
    \n        // We need the absolute value of the difference between the two numbers\
    \ to determine the\n        // best fit\n        float bestDiff = float.MaxValue;\n\
    \        float bestDiffLeft = bestDiff;\n        float bestDiffRight = bestDiff;\n\
    \n        foreach (var number in numbers) {\n            float diffLeft = number\
    \ - left;\n            float diffRight = number - right;\n\n            // Keep\
    \ the best fit and update the diff values if necessary\n            if (diffLeft\
    \ < bestDiffLeft) {\n                bestDiffLeft = diffLeft;\n            }\n\
    \            if (diffRight < bestDiffRight) {\n                bestDiffRight =\
    \ diffRight;\n            }\n\n            // Keep the best fit and update the\
    \ diff values if necessary\n            if (diffLeft + diffRight < bestDiff +\
    \ bestDiffLeft) {\n                bestDiff = diffLeft + diffRight;\n        \
    \    }\n        }\n\n        // Return the best fit and best fit left/right values\n\
    \        return Tuple.Create(left, right);", "        double minDiff = double.MaxValue;\n\
    \        var closest = Tuple.Create(numbers[0], numbers[0]);\n\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            double diff = Math.Abs(numbers[i]\
    \ - numbers[i - 1]);\n            if (diff < minDiff) {\n                minDiff\
    \ = diff;\n                closest = Tuple.Create(numbers[i], numbers[i - 1]);\n\
    \            }\n        }\n\n        return closest;", "        Debug.Assert(numbers.Count\
    \ >= 2);\n        Array.Sort(numbers);\n        if (numbers.Count >= 2)\n    \
    \        return new Tuple<float, float>(numbers[0], numbers[1]);\n        else\n\
    \            return new Tuple<float, float>(numbers[0], numbers[0]);", "     \
    \   Debug.Assert(numbers.Count > 1);\n\n        double a = numbers[0];\n     \
    \   double b = numbers[1];\n        double delta = Math.Abs(b - a);\n\n      \
    \  double[] d = new double[2];\n        d[0] = (b - a) / 2.0;\n        d[1] =\
    \ Math.Sqrt(delta);\n\n        var result = new List<double>();\n        double\
    \ c = a + d[0] * delta;\n\n        do {\n            result.Add(c);\n        \
    \    double e = Math.Sqrt(delta * delta);\n            double f = c * c * (1.0\
    \ + e * e);\n            c = b + d[1] * f;\n\n        } while (b <= c);\n\n  \
    \      return Tuple.Create(Convert.ToDouble(result[0]), Convert.ToDouble(result[1]));",
  "        Array.Sort(numbers);\n        Array.Sort(numbers, (x, y) => Math.Sign(x-y));\n\
    \        if (numbers.Count == 1) {\n            return new Tuple<float, float>(numbers[0],\
    \ numbers[0]);\n        }\n        int minIndex = 0;\n        int maxIndex = numbers.Count\
    \ - 1;\n        while (minIndex < maxIndex) {\n            int minValue = numbers[minIndex];\n\
    \            int maxValue = numbers[maxIndex];\n            float delta = Math.Abs(minValue\
    \ - maxValue);\n            if (delta == 0) {\n                minIndex++;\n \
    \               maxIndex--;\n                continue;\n            } else if\
    \ (delta > 0 && maxValue < numbers[maxIndex - 1]) {\n                maxIndex--;\n\
    \            } else {\n                minIndex++;\n            }\n        }\n\
    \        return new Tuple<float, float>(numbers[minIndex], numbers[maxIndex]);",
  "        // Create a dictionary to hold our best guesses\n        Dictionary<float,\
    \ float> best = new Dictionary<float, float>();\n        float[] numberArray =\
    \ new float[numbers.Count];\n        int i = 0; // Index for our numbers array\n\
    \        int j = 0; // Index for our best-guess array\n        for (int k = 0;\
    \ k < numbers.Count; k++) { \n            numberArray[i] = numbers[k];\n     \
    \       i++;\n        }\n        \n        float[] bestGuess = new float[bestGuess.Count];\n\
    \        j = 0;\n        for (int k = 0; k < bestGuess.Count; k++) { \n      \
    \      bestGuess[k] = bestGuess[k];\n            j++;\n        }\n\n        //\
    \ Iterate through every number\n        for (int k = 0; k < numbers.Count; k++)\
    \ {\n            // Start with our best guess as our next guess\n            float\
    \ guess = bestGuess[k];\n            float guessedValue = 0;\n            float\
    \ bestValue = 0;\n            float difference = 0;\n\n            // Do a linear\
    \ search\n            while (i < numbers.Count) {\n                // Do we have\
    \ this value in our best guess?\n                if (bestGuess[k] > guess) {\n\
    \                    guess = bestGuess[k];\n                }\n              \
    \  guessedValue = numberArray[i];\n\n                // Check if we have found\
    \ a better value\n                if (bestValue == 0) {\n                    bestValue\
    \ = guessedValue;\n                } else {\n                    difference =\
    \ Math.Abs(guessedValue - bestValue);\n                }\n                if (difference\
    \ < bestValue) {\n                    // We found a better number\n          \
    \          bestValue = guessedValue;\n                }\n                i++;\n\
    \            }\n\n            // If the difference is greater than our best guess,\
    \ we'll store this in our best guess\n            if (difference > bestValue)\
    \ {\n                bestGuess[k] = bestValue;\n            }\n        }\n\n \
    \       // Return the best two numbers\n        return Tuple.Create(bestGuess[0],\
    \ bestGuess[1]);", "        if (numbers.Count < 2) {\n            throw new ArgumentException(\"\
    There are not enough numbers in the list\");\n        }\n        float smallest\
    \ = (float)numbers.Min();\n        float largest = (float)numbers.Max();\n   \
    \     float smallestDiff = smallest - largest;\n        float largestDiff = largest\
    \ - smallest;\n        if (smallestDiff < largestDiff) {\n            throw new\
    \ ArgumentException(\"The smallest number must be larger than the largest\");\n\
    \        }\n        int smallestIndex = 0;\n        int largestIndex = 1;\n  \
    \      float smallestVal = numbers[smallestIndex];\n        float largestVal =\
    \ numbers[largestIndex];\n        float largestDiffVal = largestVal - smallestVal;\n\
    \        float smallestValDiff = smallestVal - smallest;\n        float largestValDiff\
    \ = largestVal - largest;\n        if (smallestValDiff < largestValDiff) {\n \
    \           smallestIndex += 1;\n        }\n        if (largestValDiff < smallestValDiff)\
    \ {\n            largestIndex += 1;\n        }\n        if (smallestIndex < 0\
    \ || largestIndex < 0) {\n            throw new ArgumentException(\"There is nothing\
    \ to find\");\n        }\n        if (smallestIndex == largestIndex) {\n     \
    \       throw new ArgumentException(\"There is nothing to find\");\n        }\n\
    \        float newSmallestVal = numbers[smallestIndex];\n        float newLargestVal\
    \ = numbers[largestIndex];\n        float newSmallestDiffVal = newSmallestVal\
    \ - smallest;\n        float newLargestDiffVal = newLargestVal - largest;\n  \
    \      if (newSmallestDiffVal < newLargestDiffVal) {\n            return new Tuple<float,\
    \ float>(newSmallestVal, newLargestVal);\n        }\n        return new Tuple<float,\
    \ float>(newLargestVal, newSmallestVal);", "        // Calculate a pairwise square\
    \ root of each number in the input list (the square root is the \n        // Euclidean\
    \ distance from the point a to b).\n        IEnumerable<float> sqrts = numbers.Select((n)\
    \ => Math.Sqrt((double)n));\n\n        // Find the two numbers (with the smallest\
    \ square root of the numbers) that are the closest to each other.\n        IEnumerable<Tuple<float,\
    \ float>> closest = sqrts.Where((n) => numbers.Contains((n - sqrts.Min())));\n\
    \n        // Return the closest pairs.\n        return closest.MinBy(n => n.Item1).ThenBy(n\
    \ => n.Item2);", "        var closest = new float[2];\n        var lastMin = numbers.First();\n\
    \        var lastMax = numbers.First();\n        foreach (var x in numbers) {\n\
    \            if (Math.Abs(x - lastMin) < Math.Abs(x - lastMax)) {\n          \
    \      closest[0] = lastMin;\n                closest[1] = lastMax;\n        \
    \    } else {\n                closest[0] = lastMax;\n                closest[1]\
    \ = lastMin;\n            }\n\n            closest[0] = Math.Max(closest[0], x);\n\
    \            closest[1] = Math.Min(closest[1], x);\n\n            lastMin = x;\n\
    \            lastMax = x;\n        }\n\n        return Tuple.Create(closest[0],\
    \ closest[1]);", "        if (numbers.Count < 2) {\n            return Tuple.Create(numbers.Min(),\
    \ numbers.Max());\n        }\n\n        var largest = numbers[0];\n        var\
    \ smallest = numbers[0];\n\n        var smallestIndex = 1;\n        var largestIndex\
    \ = 1;\n\n        // Find the smallest and largest numbers and indexes.\n    \
    \    for (var i = 0; i < numbers.Count; i++) {\n            if (largest < numbers[i])\
    \ {\n                largest = numbers[i];\n                largestIndex = i;\n\
    \            }\n\n            if (smallest > numbers[i]) {\n                smallest\
    \ = numbers[i];\n                smallestIndex = i;\n            }\n        }\n\
    \n        // Swap the two numbers if they are in the wrong order.\n        if\
    \ (largest != smallest) {\n            var temp = largest;\n            largest\
    \ = smallest;\n            smallest = temp;\n        }\n\n        // Swap the\
    \ two indexes if they are in the wrong order.\n        if (largestIndex != smallestIndex)\
    \ {\n            var temp = largestIndex;\n            largestIndex = smallestIndex;\n\
    \            smallestIndex = temp;\n        }\n\n        return Tuple.Create(smallest,\
    \ largest);", "        if (numbers.Count < 2) return null;\n        float bigger\
    \ = numbers.Max();\n        float smaller = numbers.Min();\n        int smallerIndex\
    \ = numbers.IndexOf(smaller);\n        int biggerIndex = numbers.IndexOf(bigger);\n\
    \        if (smallerIndex >= biggerIndex) return null;\n        float smallerValue\
    \ = numbers[smallerIndex];\n        float biggerValue = numbers[biggerIndex];\n\
    \        if (biggerValue < smallerValue) smallerValue = biggerValue;\n       \
    \ return Tuple.Create(smallerValue, biggerValue);", "        List<float> result\
    \ = new List<float>(numbers);\n        bool swap = false;\n        do {\n    \
    \        swap = false;\n            for(int i = 0; i < numbers.Count - 2; i++)\
    \ {\n                float a = numbers[i];\n                float b = numbers[i\
    \ + 1];\n                float c = numbers[i + 2];\n\n                float sum1\
    \ = a + b + c;\n\n                float sum2 = a + b - c;\n\n                float\
    \ sum3 = a - b + c;\n\n                float sum4 = a - b - c;\n\n           \
    \     if(Math.Abs(sum1) < Math.Abs(sum2) && Math.Abs(sum1) < Math.Abs(sum3) &&\
    \ Math.Abs(sum1) < Math.Abs(sum4)) {\n                    if(b < c) {\n      \
    \                  result.Add(c);\n                        result.Add(b);\n  \
    \                      swap = true;\n                    } else {\n          \
    \              result.Add(a);\n                        result.Add(c);\n      \
    \                  swap = true;\n                    }\n                }\n  \
    \          }\n        } while(swap);\n        return new Tuple<float, float>(result.First(),\
    \ result.Last());", "        List<int> differences = new List<int>();\n      \
    \  float smallestDifference = float.MaxValue;\n        float largestDifference\
    \ = float.MinValue;\n        float closest = float.MaxValue;\n        float smaller\
    \ = float.MaxValue;\n        float larger = float.MinValue;\n        float currentNumber\
    \ = numbers.First();\n        numbers.Remove(currentNumber);\n        float targetNumber\
    \ = numbers.First();\n        numbers.Remove(targetNumber);\n        differences.Add(0);\n\
    \        while (!numbers.Any()) {\n            List<int> newDifferences = new\
    \ List<int>(differences);\n            newDifferences.RemoveAll(i => i == 0);\n\
    \            newDifferences.Add(currentNumber - targetNumber);\n            float\
    \ newSmallestDifference = differences.Min();\n            float newLargestDifference\
    \ = differences.Max();\n            if (newSmallestDifference < smallestDifference)\
    \ {\n                smallestDifference = newSmallestDifference;\n           \
    \     closest = currentNumber;\n                smaller = targetNumber;\n    \
    \        }\n            if (newLargestDifference > largestDifference) {\n    \
    \            largestDifference = newLargestDifference;\n                closest\
    \ = targetNumber;\n                larger = currentNumber;\n            }\n  \
    \          if (newDifferences.Count < 1) {\n                differences.Add(newDifferences.Min());\n\
    \                currentNumber = newDifferences.Min();\n                numbers.Remove(currentNumber);\n\
    \                targetNumber = newDifferences.Min();\n                numbers.Remove(targetNumber);\n\
    \            } else {\n                currentNumber = newDifferences.Min();\n\
    \                numbers.Remove(currentNumber);\n                targetNumber\
    \ = newDifferences.Min();\n                numbers.Remove(targetNumber);\n   \
    \             differences.Add(newDifferences.Min());\n            }\n        }\n\
    \        return Tuple.Create(closest, smallestDifference);", "        // Sort\
    \ the numbers so the closer number is first\n        numbers.Sort();\n       \
    \ // Take the first two numbers, and find the difference between them\n      \
    \  float diff = numbers[0].Subtract(numbers[1]);\n        // Now find the closest\
    \ numbers, if none are in the list return None\n        if (numbers.Count < 2)\
    \ return new Tuple<float, float>(numbers[0], numbers[0]);\n        // Now keep\
    \ looping through the list until we find the next number that is too close to\
    \ the first number\n        foreach (float n in numbers) {\n            float\
    \ diff = n.Subtract(numbers[0]);\n            if (diff < 0.01) return new Tuple<float,\
    \ float>(numbers[0], n);\n            if (diff > diff) diff = diff;\n        }\n\
    \        return new Tuple<float, float>(numbers[0], numbers[0]);", "        Debug.Assert(numbers.Count\
    \ >= 2);\n        var smallestDifference = float.MaxValue;\n        var secondSmallestDifference\
    \ = float.MaxValue;\n        foreach (var number in numbers) {\n            var\
    \ difference = Mathf.Abs(number - numbers.ElementAt(1));\n            if (difference\
    \ < smallestDifference) {\n                secondSmallestDifference = smallestDifference;\n\
    \                smallestDifference = difference;\n            } else if (difference\
    \ < secondSmallestDifference) {\n                secondSmallestDifference = difference;\n\
    \            }\n        }\n        return (Tuple.Create(numbers.ElementAt(1),\
    \ numbers.ElementAt(0)), Tuple.Create(numbers.ElementAt(0), numbers.ElementAt(1)));",
  "        var closest = new List<float>();\n        var closest = numbers.Where(d\
    \ => Math.Abs(d - numbers[closest.Count]) < Math.Abs(d - numbers[closest.Count-1])).OrderBy(d\
    \ => d - numbers[closest.Count-1]).FirstOrDefault();\n        var closest = numbers.Where(d\
    \ => Math.Abs(d - numbers[closest.Count]) < Math.Abs(d - numbers[closest.Count-1])).OrderBy(d\
    \ => d - numbers[closest.Count]).FirstOrDefault();\n        return new Tuple<float,\
    \ float>(closest.Item1, closest.Item2);", "        long smallestDiff = numbers.Min(a\
    \ => Math.Abs(a - numbers.Min()) + 1);\n        long largestDiff = numbers.Max(a\
    \ => Math.Abs(a - numbers.Max()) + 1);\n        float[] diffs = new float[numbers.Count];\n\
    \        float smallestDiffInner = smallestDiff;\n        float largestDiffInner\
    \ = largestDiff;\n        for (int i = 0; i < numbers.Count; i++) {\n        \
    \    diffs[i] = Math.Abs(numbers.ElementAtOrDefault(i) - numbers.ElementAtOrDefault(Math.Min(i,\
    \ largestDiffInner)));\n            if (diffs[i] < smallestDiffInner) {\n    \
    \            smallestDiffInner = diffs[i];\n            }\n            if (diffs[i]\
    \ > largestDiffInner) {\n                largestDiffInner = diffs[i];\n      \
    \      }\n        }\n        float smallestDiffOuter = smallestDiff;\n       \
    \ float largestDiffOuter = largestDiff;\n        float smallestDiffOuterInner\
    \ = smallestDiffInner;\n        float largestDiffOuterInner = largestDiffInner;\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            diffs[i] = Math.Abs(numbers.ElementAtOrDefault(Math.Max(i,\
    \ smallestDiffOuterInner)) - numbers.ElementAtOrDefault(Math.Min(i, largestDiffOuterInner)));\n\
    \            if (diffs[i] < smallestDiffOuterInner) {\n                smallestDiffOuterInner\
    \ = diffs[i];\n            }\n            if (diffs[i] > largestDiffOuterInner)\
    \ {\n                largestDiffOuterInner = diffs[i];\n            }\n      \
    \  }\n        float smallestDiffOuterOuter = smallestDiff;\n        float largestDiffOuterOuter\
    \ = largestDiff;\n        float smallestDiffOuterOuterInner = smallestDiffInner;\n\
    \        float largestDiffOuterOuterInner = largestDiffInner;\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            diffs[i] = Math.Abs(numbers.ElementAtOrDefault(Math.Max(i,\
    \ smallestDiffOuterOuterInner)) - numbers.ElementAtOrDefault(Math.Min(i, largestDiffOuterOuterInner)));\n\
    \            if (diffs[i] < smallestDiffOuterOuterInner) {\n                smallestDiffOuterOuterInner\
    \ = diffs[i];\n            }\n            if (diffs[i] > largestDiffOuterOuterInner)\
    \ {\n                largestDiffOuterOuterInner = diffs[i];\n            }\n \
    \       }\n        float smallestDiffOuterOuterOuter = smallestDiff;\n       \
    \ float largestDiffOuterOuterOuter = largestDiff;\n        if (smallestDiffOuterOuterInner\
    \ > largestDiffOuterOuterInner) {\n            return new Tuple<", "        int\
    \ minDistance = numbers.Count > 2 ? 1 : numbers[0].Abs() - numbers[1].Abs();\n\
    \        int minIndex = 0;\n        for (int i = 1; i < numbers.Count; i++)\n\
    \        {\n            float currentDistance = numbers[minIndex].Abs() - numbers[i].Abs();\n\
    \            if (currentDistance < minDistance)\n            {\n             \
    \   minDistance = currentDistance;\n                minIndex = i;\n          \
    \  }\n        }\n        return Tuple.Create(numbers[minIndex], numbers[minIndex\
    \ + 1]);", "        float[] array = new float[numbers.Count];\n        numbers.CopyTo(array,\
    \ 0);\n        float minValue = array[0];\n        float maxValue = array[0];\n\
    \n        for (int i = 1; i < array.Length; i++) {\n            if (array[i] <\
    \ minValue) {\n                minValue = array[i];\n            } else if (array[i]\
    \ > maxValue) {\n                maxValue = array[i];\n            }\n       \
    \ }\n\n        return new Tuple<float, float>(minValue, maxValue);", "       \
    \ var min = numbers.First();\n        var max = numbers.Last();\n        var firstElement\
    \ = numbers[0];\n        var secondElement = numbers[1];\n        if (Math.Abs(firstElement\
    \ - secondElement) < Math.Abs(min - max)) {\n            min = firstElement;\n\
    \            secondElement = firstElement;\n        }\n        if (Math.Abs(secondElement\
    \ - firstElement) < Math.Abs(min - max)) {\n            min = secondElement;\n\
    \            secondElement = secondElement;\n        }\n        return Tuple.Create(min,\
    \ secondElement);", "        if (numbers.Count <= 1) {\n            throw new\
    \ InvalidOperationException(\"The supplied list of numbers must be of length greater\
    \ than 1.\");\n        }\n        // Sort the input numbers (first ascending,\
    \ second descending)\n        IEnumerable<Tuple<float, float>> sortedNumbers =\
    \ numbers\n            .Select(number => new Tuple<float, float>(number, numbers.IndexOf(number)))\n\
    \            .OrderBy(tuple => tuple.Item1)\n            .ThenByDescending(tuple\
    \ => tuple.Item2)\n            .ToArray();\n        // Return the two numbers\
    \ with the smallest distance\n        float firstNumber = sortedNumbers[0].Item1;\n\
    \        float secondNumber = sortedNumbers[0].Item2;\n        float smallestDistance\
    \ = float.MaxValue;\n        float secondSmallestDistance = float.MaxValue;\n\
    \        int smallestIndex = 0;\n        int secondSmallestIndex = 0;\n      \
    \  // Iterate through the sorted numbers and test each pair\n        foreach (Tuple<float,\
    \ float> pair in sortedNumbers) {\n            // Find the distance between the\
    \ first number in the input list and the second number in the sorted list\n  \
    \          float firstNumberDistance = Vectors.Distance(firstNumber, pair.Item1);\n\
    \            // Find the distance between the second number in the input list\
    \ and the first number in the sorted list\n            float secondNumberDistance\
    \ = Vectors.Distance(secondNumber, pair.Item2);\n            // Compare distance\
    \ and set new variables\n            if (firstNumberDistance < secondNumberDistance)\
    \ {\n                firstNumber = pair.Item1;\n                secondNumber =\
    \ pair.Item2;\n                secondSmallestDistance = firstNumberDistance;\n\
    \                secondSmallestIndex = smallestIndex;\n            } else if (secondNumberDistance\
    \ < firstNumberDistance) {\n                secondNumber = pair.Item1;\n     \
    \           firstNumber = pair.Item2;\n                smallestDistance = secondNumberDistance;\n\
    \                smallestIndex = secondSmallestIndex;\n            }\n       \
    \ }\n        // Return the sorted input numbers with the smallest distance (closest\
    \ to each other)\n        return Tuple.Create(firstNumber, secondNumber);", " \
    \       numbers.Sort(new MyComparer());\n\n        float closest = numbers[0];\n\
    \        float smaller = numbers[0];\n\n        // find closest smaller element\n\
    \        foreach (float n in numbers) {\n            if (n > closest) {\n    \
    \            smaller = closest;\n                closest = (float) n;\n      \
    \      }\n        }\n\n        // find closest larger element\n        foreach\
    \ (float n in numbers) {\n            if (n < closest) {\n                smaller\
    \ = closest;\n                closest = (float) n;\n            }\n        }\n\
    \n        return Tuple.Create(closest, smaller);", "        var diffs = numbers.Zip(numbers.Skip(1),\
    \ Tuple.Create)\n                       .Select((t, i) => Tuple.Create(t.Item2\
    \ - t.Item1, t.Item1))\n                       .OrderBy(t => t.Item1)\n      \
    \                 .ToList();\n        return diffs.FirstOrDefault(t => t.Item1\
    \ < 0) ? diffs.Last() : diffs.First();", "        if (numbers.Count < 2) return\
    \ new Tuple<float, float>(0, 0);\n\n        // Sort the array\n        Array.Sort(numbers);\n\
    \n        // Get the minimum value of the two smallest values\n        float minDiff\
    \ = numbers[0];\n        float minDiff2 = numbers[0];\n\n        // Get the two\
    \ smallest values\n        float firstNumber = numbers[0];\n        float secondNumber\
    \ = numbers[0];\n\n        for (int i = 1; i < numbers.Count; ++i) {\n       \
    \     float diff = (firstNumber - numbers[i]);\n            float diff2 = (secondNumber\
    \ - numbers[i]);\n\n            if (diff < minDiff) {\n                minDiff\
    \ = diff;\n                minDiff2 = diff2;\n                firstNumber = numbers[i];\n\
    \            } else if (diff < minDiff2) {\n                minDiff2 = diff2;\n\
    \                secondNumber = numbers[i];\n            }\n        }\n\n    \
    \    return new Tuple<float, float>(firstNumber, secondNumber);", "        var\
    \ sorted = numbers.OrderBy(x => x);\n        float closestToPreviousNumber = numbers.First();\n\
    \        float closestToNextNumber = numbers.Last();\n        float closestToPreviousPreviousNumber\
    \ = numbers.ElementAt(0);\n        float closestToNextNextNumber = numbers.ElementAt(numbers.Count\
    \ - 1);\n        float previousDifference = float.MaxValue;\n        float nextDifference\
    \ = float.MaxValue;\n        float previousDifference2 = float.MaxValue;\n   \
    \     float nextDifference2 = float.MaxValue;\n        float previousDifference3\
    \ = float.MaxValue;\n        float nextDifference3 = float.MaxValue;\n       \
    \ for (int index = 0; index < numbers.Count; index += 2) {\n            float\
    \ difference = numbers[index] - closestToPreviousNumber;\n            float difference2\
    \ = numbers[index + 1] - closestToNextNumber;\n            float difference3 =\
    \ numbers[index + 1] - closestToPreviousNumber;\n            if (difference <\
    \ previousDifference) {\n                previousDifference = difference;\n  \
    \              previousDifference2 = difference2;\n                previousDifference3\
    \ = difference3;\n            }\n            if (difference > nextDifference)\
    \ {\n                nextDifference = difference;\n                nextDifference2\
    \ = difference2;\n                nextDifference3 = difference3;\n           \
    \ }\n        }\n        return new Tuple<float, float>(closestToPreviousNumber,\
    \ closestToNextNumber);", "        var tuples = new List<Tuple<float, float>>();\n\
    \        foreach (var i in Enumerable.Range(0, numbers.Count - 1)) {\n       \
    \     var diff = numbers[i + 1] - numbers[i];\n            var diffSquared = diff\
    \ * diff;\n            var diff = diff / (diffSquared + 1.0f);\n            var\
    \ a = (float)i;\n            var b = (float)(i + 1);\n            if (Math.Abs(diffSquared\
    \ - Math.Sqrt(diffSquared)) > 1.0e-6f) {\n                var c = numbers[a] +\
    \ diff * b;\n                var d = numbers[b] - diff * a;\n                tuples.Add(Tuple.Create(Math.Abs(c\
    \ - d) < 0.01f * Math.Abs(c - d) ? a : b, Math.Abs(c - d) < 0.01f * Math.Abs(c\
    \ - d) ? b : a));\n            }\n        }\n        if (tuples.Count == 0) throw\
    \ new Exception(\"No numbers satisfy the requirements presented.\");\n       \
    \ tuples.Sort();\n        return tuples.First();", "        var min = numbers.Min();\n\
    \        var max = numbers.Max();\n        double leftDist, rightDist;\n     \
    \   double rightMaxDist, leftMaxDist;\n        bool leftIsBigger, rightIsBigger\
    \ = false;\n\n        // If they are equal, use the original elements\n      \
    \  // For this, we find their distance to eachother, and determine which is greater\n\
    \        // If the right is bigger - use that one\n        // If its not - use\
    \ the left\n        var leftClosest = numbers.First();\n        var rightClosest\
    \ = numbers.Last();\n        leftDist = Vectors.Distance(Vectors.UnitX, numbers.Select(x\
    \ => x - leftClosest));\n        rightDist = Vectors.Distance(Vectors.UnitX, numbers.Select(x\
    \ => x - rightClosest));\n        leftMaxDist = Vectors.Distance(Vectors.UnitX,\
    \ numbers.Select(x => x - max));\n        rightMaxDist = Vectors.Distance(Vectors.UnitX,\
    \ numbers.Select(x => x - max));\n        if (rightDist > leftMaxDist) {\n   \
    \         rightIsBigger = true;\n            rightClosest = max;\n        }\n\
    \        if (leftDist > rightMaxDist) {\n            leftIsBigger = true;\n  \
    \          leftClosest = max;\n        }\n\n        if (leftIsBigger || rightIsBigger)\
    \ {\n            return new Tuple<float, float>(leftClosest, rightClosest);\n\
    \        } else {\n            return new Tuple<float, float>(numbers.First(),\
    \ numbers.Last());\n        }", "        if (numbers.Count < 2) throw new ArgumentException();\n\
    \        float smallestDiff = numbers[0] - numbers[1];\n        float biggestDiff\
    \ = numbers[1] - numbers[0];\n        float smallestVal = numbers[0];\n      \
    \  float biggestVal = numbers[1];\n        float smallestElement = numbers[0];\n\
    \        float biggestElement = numbers[1];\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            float diff = numbers[i] - numbers[i - 1];\n            float\
    \ val = numbers[i];\n            if (diff < smallestDiff) {\n                smallestDiff\
    \ = diff;\n                smallestVal = val;\n                smallestElement\
    \ = numbers[i - 1];\n            }\n            if (diff > biggestDiff) {\n  \
    \              biggestDiff = diff;\n                biggestVal = val;\n      \
    \          biggestElement = numbers[i - 1];\n            }\n        }\n      \
    \  return new Tuple<float, float>(smallestVal, smallestElement);", "        //\
    \ Find the smallest and largest in the list\n        float smallest = numbers[0];\n\
    \        float largest = numbers[0];\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            if (numbers[i] < smallest) {\n                smallest =\
    \ numbers[i];\n            }\n            if (numbers[i] > largest) {\n      \
    \          largest = numbers[i];\n            }\n        }\n        // Find the\
    \ two numbers that match the smallest and largest\n        float smallestMatch\
    \ = smallest;\n        float largestMatch = largest;\n        float smallestDiff\
    \ = float.MaxValue;\n        float largestDiff = float.MinValue;\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            float diff = numbers[i] -\
    \ smallest;\n            if (diff < smallestDiff) {\n                smallestDiff\
    \ = diff;\n                smallestMatch = numbers[i];\n            }\n      \
    \      if (diff > largestDiff) {\n                largestDiff = diff;\n      \
    \          largestMatch = numbers[i];\n            }\n        }\n        return\
    \ Tuple.Create(smallestMatch, largestMatch);", "        List<float> temp = new\
    \ List<float>();\n        float closestDistance = float.MaxValue;\n        float\
    \ closestX;\n        float closestY;\n        float currentX;\n        float currentY;\n\
    \        bool done = false;\n        do {\n            temp.Sort();\n        \
    \    currentX = temp[0];\n            currentY = temp[1];\n            int xIndex\
    \ = 0;\n            int yIndex = 1;\n            for (int i = 2; i < numbers.Count;\
    \ i++) {\n                float distance = (currentX - numbers[xIndex])*(currentX\
    \ - numbers[xIndex]) + (currentY - numbers[yIndex])*(currentY - numbers[yIndex]);\n\
    \                if (distance < closestDistance) {\n                    closestDistance\
    \ = distance;\n                    closestX = currentX;\n                    closestY\
    \ = currentY;\n                }\n                else {\n                   \
    \ if (xIndex == 0 || yIndex == 0) break;\n                    xIndex++;\n    \
    \                yIndex++;\n                }\n            }\n            if (xIndex\
    \ == 0 || yIndex == 0) break;\n            xIndex++;\n            yIndex++;\n\
    \        } while (!done);\n        return new Tuple<float, float>(closestX, closestY);",
  "        // Sort numbers\n        var sorted = numbers.OrderBy(n => n);\n      \
    \  // Initialize smallest and largest numbers\n        var smallest = sorted[0];\n\
    \        var largest = sorted[0];\n\n        // Find smallest number\n       \
    \ foreach (var n in sorted) {\n            if (n < smallest) {\n             \
    \   smallest = n;\n            }\n        }\n\n        // Find largest number\n\
    \        foreach (var n in sorted) {\n            if (n > largest) {\n       \
    \         largest = n;\n            }\n        }\n\n        // Return smallest\
    \ number if that is the same as the largest\n        if (smallest == largest)\
    \ {\n            return new Tuple<float, float>(smallest, largest);\n        }\n\
    \n        // Return smallest number if there are multiple that are the same\n\
    \        if (numbers.Count > 1) {\n            float closest = smallest;\n   \
    \         int count = 0;\n            foreach (var n in sorted) {\n          \
    \      if (n < closest) {\n                    closest = n;\n                \
    \    count = 1;\n                }\n                else if (n == closest) {\n\
    \                    count++;\n                }\n            }\n            return\
    \ new Tuple<float, float>(closest, Math.Round(largest * Math.Round(1.0 / count)));\n\
    \        }\n\n        // Return largest number if there are multiple that are\
    \ the same\n        if (numbers.Count > 1) {\n            float closest = largest;\n\
    \            int count = 0;\n            foreach (var n in sorted) {\n       \
    \         if (n > closest) {\n                    closest = n;\n             \
    \       count = 1;\n                }\n                else if (n == closest)\
    \ {\n                    count++;\n                }\n            }\n        \
    \    return new Tuple<float, float>(Math.Round(smallest * Math.Round(1.0 / count)),\
    \ closest);\n        }\n\n        // Return smallest number if the list has exactly\
    \ one number\n        if (numbers.Count == 1) {\n            return new Tuple<float,\
    \ float>(smallest, smallest);\n        }\n\n        // Return smallest number\
    \ if there is no number in the list\n        return new Tuple<float, float>(smallest,\
    \ largest);", "        List<float> closest1 = new List<float>();\n        List<float>\
    \ closest2 = new List<float>();\n        float diff = float.MaxValue;\n      \
    \  int n1 = 0, n2 = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n  \
    \          float n2 = numbers[i];\n            float diff1 = (float)Math.Abs(n1\
    \ - n2);\n            float diff2 = (float)Math.Abs(n2 - n1);\n            if\
    \ (diff1 < diff) {\n                closest1.Add(n2);\n                closest2.Add(n1);\n\
    \                n1 = n2;\n            } else {\n                closest1.Add(n1);\n\
    \                closest2.Add(n2);\n                n2 = n1;\n            }\n\
    \        }\n        return Tuple.Create(closest1[0], closest2[0]);", "       \
    \ if (numbers.Count < 2) return null;\n        var numberList = numbers.ToList();\n\
    \        float lowest = numberList[0], highest = numberList[0];\n        float\
    \ lowestDiff = float.MaxValue, highestDiff = float.MinValue;\n        for (int\
    \ i = 0; i < numbers.Count - 1; i++) {\n            float diff = numberList[i]\
    \ - numberList[i - 1];\n            if (diff < lowestDiff) {\n               \
    \ lowest = numberList[i];\n                lowestDiff = diff;\n            }\n\
    \            if (diff > highestDiff) {\n                highest = numberList[i];\n\
    \                highestDiff = diff;\n            }\n        }\n        return\
    \ new Tuple<float, float>(lowest, highest);", "        if (numbers.Count < 2)\
    \ {\n            throw new ArgumentException(\"Must provide a list of at least\
    \ two numbers to compare.\", \"numbers\");\n        }\n\n        if (numbers.Count\
    \ < 2) {\n            throw new ArgumentException(\"Must provide a list of at\
    \ least two numbers to compare.\", \"numbers\");\n        }\n\n        var initialValue\
    \ = numbers[0];\n        var candidates = numbers.Where(x => Math.Abs(x - initialValue)\
    \ < 1.0).ToList();\n\n        var bestCandidate = candidates[0];\n        var\
    \ bestDistance = float.MaxValue;\n        var bestNumbers = new List<float>()\
    \ { initialValue };\n\n        for (int i = 1; i < candidates.Count; i++) {\n\
    \            var candidate = candidates[i];\n            var distance = float.MaxValue;\n\
    \n            for (int j = 0; j < candidates.Count; j++) {\n                var\
    \ otherCandidate = candidates[j];\n\n                var diff = otherCandidate\
    \ - candidate;\n                if (Math.Abs(diff) < distance) {\n           \
    \         distance = diff;\n                    bestCandidate = candidate;\n \
    \                   bestDistance = distance;\n                    bestNumbers\
    \ = bestNumbers.Union(new List<float>() { otherCandidate }).ToList();\n      \
    \          }\n            }\n        }\n\n        return bestCandidate.Equals(candidates[0])\
    \ ? bestCandidate.ToTuple() : bestCandidate.ToTuple().Reverse();", "        int\
    \ minIndex = 0;\n        int maxIndex = numbers.Count - 1;\n        float minDistance\
    \ = float.MaxValue;\n        float maxDistance = float.MinValue;\n        float\
    \ min1 = numbers[minIndex];\n        float min2 = numbers[minIndex];\n       \
    \ float min3 = numbers[minIndex];\n        float min4 = numbers[minIndex];\n \
    \       float max1 = numbers[maxIndex];\n        float max2 = numbers[maxIndex];\n\
    \        float max3 = numbers[maxIndex];\n        float max4 = numbers[maxIndex];\n\
    \        while (minIndex <= maxIndex) {\n            float currentDistance = CalculateDistance(min1,\
    \ min2, min3, min4, max1, max2, max3, max4);\n            if (currentDistance\
    \ < minDistance) {\n                minDistance = currentDistance;\n         \
    \       min1 = numbers[minIndex];\n            }\n            else if (currentDistance\
    \ > minDistance) {\n                maxDistance = currentDistance;\n         \
    \       max1 = numbers[maxIndex];\n            }\n            minIndex++;\n  \
    \          maxIndex--;\n        }\n        return new Tuple<float, float>(min1,\
    \ min2);", "        if (numbers == null || numbers.Count < 2) {\n            return\
    \ new Tuple<float, float>(numbers.First(), numbers.First());\n        }\n    \
    \    var m = numbers.Min();\n        var M = -m;\n        var m = numbers.Min();\n\
    \        var M = -m;\n        var mX = numbers.Min();\n        var mXX = numbers.Min();\n\
    \        var MX = -m;\n        var mY = numbers.Max();\n        var mYY = numbers.Max();\n\
    \        var MY = -mY;\n        var mZ = numbers.Max();\n        var mZZ = numbers.Max();\n\
    \        var MZ = -mZ;\n        var a = numbers.Count - 1;\n        float b =\
    \ (float)(numbers.Count - 1);\n        float c = (float)(-numbers.Count - 1);\n\
    \        float d = (float)(-numbers.Count - 1);\n        float e = (float)(-numbers.Count\
    \ - 1);\n        float f = (float)(-numbers.Count - 1);\n        float g = (float)(-numbers.Count\
    \ - 1);\n        float h = (float)(-numbers.Count - 1);\n        float i = (float)(-numbers.Count\
    \ - 1);\n        float j = (float)(-numbers.Count - 1);\n        float k = (float)(-numbers.Count\
    \ - 1);\n        float l = (float)(-numbers.Count - 1);\n        float mN = 0;\n\
    \        float MN = 0;\n        float mXN = 0;\n        float MXN = 0;\n     \
    \   float mYN = 0;\n        float MYN = 0;\n        float mZN = 0;\n        float\
    \ mZZN = 0;\n        float MZN = 0;\n        float aN = 0;\n        float bN =\
    \ 0;\n        float cN = 0;\n        float dN = 0;\n        float eN = 0;\n  \
    \      float fN = 0;\n        float gN = 0;\n        float hN = 0;\n        float\
    \ iN = 0;\n        float jN = 0;\n        float kN = 0;\n        float lN = 0;\n\
    \        float mX1N = 0;\n        float mY1N = 0;\n        float mZ1N = 0;\n \
    \       float mXX1N = 0;\n        float mYY1N = 0;\n        float mZZ1N = 0;\n\
    \        float mXXY1N = 0;\n        float mYYZ1N = 0;\n        float mZZX1N =\
    \ 0;\n        float mYZ1N = 0;\n        float mYZZ1N = 0;\n        float mXYZ1N\
    \ = 0;\n        float mXZ1N = 0;\n        float mXY1N = 0;\n        float mYZ1N\
    \ = 0;\n        float mX1N = 0;\n        float mY1N", "        int n = numbers.Count;\n\
    \        if (n < 2) throw new ArgumentException(\"Must have at least two numbers\
    \ in list\");\n        float[] numberArray = numbers.ToArray();\n        Array.Sort(numberArray);\n\
    \        int minIndex = 0, maxIndex = n - 1;\n        while (maxIndex >= minIndex)\
    \ {\n            float minValue = numberArray[minIndex];\n            float maxValue\
    \ = numberArray[maxIndex];\n            int mid = minIndex + (maxIndex - minIndex)\
    \ / 2;\n            float currentMinValue = numberArray[mid];\n            float\
    \ currentMaxValue = numberArray[mid];\n            if (currentMinValue == minValue\
    \ || currentMaxValue == minValue) {\n                if (currentMinValue == minValue\
    \ && currentMaxValue == maxValue)\n                    return new Tuple<float,\
    \ float>(minValue, maxValue);\n                if (currentMinValue == maxValue)\n\
    \                    minIndex = mid + 1;\n                else\n             \
    \       maxIndex = mid - 1;\n            }\n            else if (currentMinValue\
    \ == maxValue || currentMaxValue == maxValue) {\n                if (currentMinValue\
    \ == maxValue && currentMaxValue == minValue)\n                    return new\
    \ Tuple<float, float>(minValue, maxValue);\n                if (currentMinValue\
    \ == minValue)\n                    maxIndex = mid - 1;\n                else\n\
    \                    minIndex = mid + 1;\n            }\n            else if (currentMinValue\
    \ < minValue && currentMaxValue < maxValue) {\n                if (currentMinValue\
    \ < minValue && currentMaxValue < minValue)\n                    minIndex = mid\
    \ + 1;\n                else if (currentMinValue < minValue && currentMaxValue\
    \ > minValue)\n                    maxIndex = mid - 1;\n                else\n\
    \                    maxIndex = mid - 1;\n            }\n            else if (currentMinValue\
    \ > maxValue && currentMaxValue > maxValue) {\n                if (currentMinValue\
    \ > maxValue && currentMaxValue > maxValue)\n                    minIndex = mid\
    \ + 1;\n                else if (currentMinValue > maxValue && currentMaxValue\
    \ < maxValue)\n                    maxIndex = mid - 1;\n                else\n\
    \                    maxIndex = mid - 1;\n            }\n            else if (currentMinValue\
    \ < minValue && currentMaxValue > maxValue) {\n                if (currentMinValue\
    \ < minValue && currentMaxValue > maxValue)\n                    minIndex = mid\
    \ + 1;\n                else if (currentMinValue < minValue && currentMaxValue\
    \ < maxValue)\n                    maxIndex = mid - 1;\n                else\n\
    \                    maxIndex = mid - 1;\n            }\n            else if (currentMinValue\
    \ > maxValue && currentMaxValue < maxValue) {\n                if (currentMinValue\
    \ > maxValue && currentMaxValue < maxValue)\n", "        float min = float.MaxValue;\n\
    \        float max = float.MinValue;\n        foreach (float number in numbers)\
    \ {\n            float diff = number - min;\n            if (diff < -max) {\n\
    \                max = diff;\n            } else if (diff > max) {\n         \
    \       min = diff;\n            }\n        }\n        return new Tuple<float,\
    \ float>(min, max);", "        float lowest = numbers[0];\n        float highest\
    \ = numbers[0];\n        int smallest = int.MaxValue;\n        int largest = int.MinValue;\n\
    \        foreach(var n in numbers) {\n            float tempLow = Math.Abs(n -\
    \ lowest);\n            float tempHigh = Math.Abs(highest - n);\n            int\
    \ temp = tempLow;\n            smallest = temp;\n            temp = tempHigh;\n\
    \            largest = temp;\n            lowest = n;\n            highest = n;\n\
    \        }\n        var smallestElement = numbers.ElementAt(smallest);\n     \
    \   var largestElement = numbers.ElementAt(largest);\n        if(smallestElement\
    \ == largestElement) {\n            smallestElement = numbers.ElementAt(0);\n\
    \            largestElement = numbers.ElementAt(0);\n        }\n        if(smallestElement\
    \ < largestElement) {\n            return new Tuple<float, float>(smallestElement,\
    \ largestElement);\n        }\n        return new Tuple<float, float>(largestElement,\
    \ smallestElement);", "        if (numbers.Count < 2) throw new ArgumentException(\"\
    List must have at least 2 elements.\");\n        if (numbers.First() < numbers.Last())\
    \ throw new ArgumentException(\"List must not contain an equal element\");\n \
    \       var a = numbers.First();\n        var b = numbers.Last();\n        var\
    \ diff = a.CompareTo(b);\n        if (diff == 0) throw new ArgumentException(\"\
    List must be nonempty.\");\n        var min = Math.Abs(a); // a must be bigger\
    \ than b\n        var max = Math.Abs(b);\n        var ab = numbers.Select(n =>\
    \ new Tuple<float, float>(n, Math.Abs(n)));\n        var abSortedByAb = ab.OrderBy(ab\
    \ => ab.Item2).ToList();\n        var abSortedByAbMin = abSortedByAb.Where(ab\
    \ => ab.Item2 < min).ToList();\n        var abSortedByAbMax = abSortedByAb.Where(ab\
    \ => ab.Item2 > max).ToList();\n        var abSortedByAbDiff = abSortedByAb.Where(ab\
    \ => ab.Item2 > ab.Item1).ToList();\n        var abSortedByAbDiffMin = abSortedByAbDiff.Where(ab\
    \ => ab.Item2 < min).ToList();\n        var abSortedByAbDiffMax = abSortedByAbDiff.Where(ab\
    \ => ab.Item2 > max).ToList();\n        var abSortedByAbDiffDiff = abSortedByAbDiff.Where(ab\
    \ => ab.Item2 > ab.Item1).ToList();\n        var abSortedByAbDiffDiffMin = abSortedByAbDiffDiff.Where(ab\
    \ => ab.Item2 < min).ToList();\n        var abSortedByAbDiffDiffMax = abSortedByAbDiffDiff.Where(ab\
    \ => ab.Item2 > max).ToList();\n        var abSortedByAbDiffDiffDiff = abSortedByAbDiffDiff.Where(ab\
    \ => ab.Item2 > ab.Item1).ToList();\n        var abSortedByAbDiffDiffDiffMin =\
    \ abSortedByAbDiffDiffDiff.Where(ab => ab.Item2 < min).ToList();\n        var\
    \ abSortedByAbDiffDiffDiffMax = abSortedByAbDiffDiffDiff.Where(ab => ab.Item2\
    \ > max).ToList();\n        var abSortedByAbDiffDiffDiffDiff = abSortedByAbDiffDiffDiff.Where(ab\
    \ => ab.Item2 > ab.Item1).ToList();\n        var abSortedBy", "        if (numbers.Count\
    \ < 2)\n            throw new ArgumentException(\"List of numbers must be of length\
    \ > 2\");\n\n        // Convert the numbers to a sorted list of floats.  Sort\
    \ the list so the numbers closest to each other will\n        // be next to each\
    \ other.\n        List<float> sortedNumbers = numbers.OrderBy(n => n).ToList();\n\
    \n        Tuple<float, float> closestElement = null;\n        float smallestDifference\
    \ = (float)Math.Abs(sortedNumbers[0] - sortedNumbers[1]);\n        for (int i\
    \ = 0; i < sortedNumbers.Count - 1; i++) {\n            float difference = (float)Math.Abs(sortedNumbers[i\
    \ + 1] - sortedNumbers[i]);\n            if (difference < smallestDifference)\
    \ {\n                smallestDifference = difference;\n                closestElement\
    \ = new Tuple<float, float>(sortedNumbers[i], sortedNumbers[i + 1]);\n       \
    \     }\n        }\n\n        return closestElement;", "        List<float> smallerNumbers\
    \ = numbers.Take(2).OrderBy(n => n).ToList();\n        List<float> greaterNumbers\
    \ = numbers.Skip(1).OrderBy(n => n).ToList();\n        float smallest = Math.Abs(numbers.Min()\
    \ - numbers[0]);\n        float largest = Math.Abs(numbers.Max() - numbers[0]);\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (Math.Abs(numbers[i]\
    \ - numbers[0]) <= smallest) {\n                smallest = Math.Abs(numbers[i]\
    \ - numbers[0]);\n            }\n            if (Math.Abs(numbers[i] - numbers[0])\
    \ > largest) {\n                largest = Math.Abs(numbers[i] - numbers[0]);\n\
    \            }\n        }\n        for (int i = 0; i < smallerNumbers.Count; i++)\
    \ {\n            float distance = smallerNumbers[i] - numbers[0];\n          \
    \  if (distance < smallest && distance > 0.0f) {\n                smallerNumbers[i]\
    \ = numbers[0];\n            }\n        }\n        for (int i = smallerNumbers.Count\
    \ - 1; i >= 0; i--) {\n            float distance = greaterNumbers[i] - numbers[0];\n\
    \            if (distance < smallest && distance > 0.0f) {\n                greaterNumbers[i]\
    \ = numbers[0];\n            }\n        }\n        return new Tuple<float, float>(smallerNumbers[0],\
    \ greaterNumbers[0]);", "        int size = numbers.Count;\n        if (size <\
    \ 2) {\n            throw new ArgumentException(\"The list must have at least\
    \ two elements.\");\n        }\n        float a = numbers[0];\n        float b\
    \ = numbers[1];\n        // We have two extremely close numbers, so we must first\
    \ find a closer number.\n        // So here we find the midpoint, which is in\
    \ between them (b + a / 2) and then we find the two numbers that are closer to\
    \ it.\n        float a2 = a + (b - a) / 2f;\n        float b2 = b - (b - a) /\
    \ 2f;\n        float a2_closest = FindClosestElement(a2, numbers);\n        float\
    \ b2_closest = FindClosestElement(b2, numbers);\n        return Tuple.Create(a2_closest,\
    \ b2_closest);", "        double[] valuesAsDoubleArray = new double[numbers.Count];\n\
    \        for (int i = 0; i < values.Count; i++) {\n            valuesAsDoubleArray[i]\
    \ = values[i];\n        }\n        // Calculate the sum of squares for every number\
    \ in valuesAsDoubleArray\n        double sumOfSquaresAsDouble = values.Sum(a =>\
    \ Math.Pow(a, 2));\n        double absoluteSumOfSquaresAsDouble = Math.Abs(sumOfSquaresAsDouble);\n\
    \        // Find the average of the sums of squares of every number in valuesAsDoubleArray\n\
    \        double averageOfSumOfSquaresAsDouble = sumOfSquaresAsDouble / values.Count;\n\
    \        // Sum all values of numbersAsDoubleArray\n        double sumOfAllValuesAsDouble\
    \ = numbers.Sum(a => Math.Pow(a, 2));\n        // The total squared difference\
    \ between every number in valuesAsDoubleArray and averageOfSumOfSquaresAsDouble\n\
    \        double differenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble\
    \ = sumOfAllValuesAsDouble - averageOfSumOfSquaresAsDouble;\n        // Find a\
    \ minimum absolute difference between any two number in valuesAsDoubleArray\n\
    \        int indexOfSmallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble\
    \ = -1;\n        for (int i = 0; i < valuesAsDoubleArray.Length; i++) {\n    \
    \        if (Math.Abs(valuesAsDoubleArray[i] - averageOfSumOfSquaresAsDouble)\
    \ < Math.Abs(valuesAsDoubleArray[i] - averageOfSumOfSquaresAsDouble - differenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble))\
    \ {\n                indexOfSmallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble\
    \ = i;\n            }\n        }\n        // The smallest difference between any\
    \ two numbers in valuesAsDoubleArray is between sumOfSquaresAsDouble and averageOfSumOfSquaresAsDouble\n\
    \        // Find the second number in valuesAsDoubleArray that is closest to the\
    \ smallest difference between sumOfSquaresAsDouble and averageOfSumOfSquaresAsDouble\n\
    \        int secondIndexOfSmallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble\
    \ = -1;\n        double smallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble\
    \ = Math.Abs(valuesAsDoubleArray[indexOfSmallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble]\
    \ - averageOfSumOfSquaresAsDouble);\n        double secondSmallestDifferenceBetweenSumOfSquaresAndAverageOfSumOfSquaresAsDouble",
  "        float first = numbers[0];\n        float second = numbers[1];\n       \
    \ for (int i = 2; i < numbers.Count; i++) {\n            float difference = numbers[i]\
    \ - first;\n            if (difference < second) {\n                second = first;\n\
    \                first = numbers[i];\n            }\n            else {\n    \
    \            second = numbers[i];\n            }\n        }\n        return (first,\
    \ second);", "        if (numbers.Count < 2) {\n            throw new ArgumentException(\"\
    List must be at least two long\");\n        }\n        float smallest = Math.Abs(numbers[0]);\n\
    \        float largest = Math.Abs(numbers[0]);\n        var foundOne = new List<float>();\n\
    \        var foundTwo = new List<float>();\n        var startIndex = 0;\n    \
    \    var endIndex = numbers.Count - 1;\n        while (startIndex <= endIndex)\
    \ {\n            float currentSmaller = numbers[startIndex];\n            float\
    \ currentLarger = numbers[endIndex];\n            float currentMiddle = (currentSmaller\
    \ + currentLarger) / 2;\n            bool foundOneInOrder = true;\n          \
    \  bool foundTwoInOrder = true;\n            while (foundOneInOrder && foundTwoInOrder)\
    \ {\n                if (currentMiddle < currentLarger) {\n                  \
    \  foundOneInOrder = false;\n                    foundOne.Add(currentSmaller);\n\
    \                }\n                if (currentMiddle > currentSmaller) {\n  \
    \                  foundTwoInOrder = false;\n                    foundTwo.Add(currentLarger);\n\
    \                }\n                currentMiddle = (currentSmaller + currentLarger)\
    \ / 2;\n            }\n            startIndex++;\n            endIndex--;\n  \
    \      }\n        if (foundOne.Count == 1 && foundTwo.Count == 1) {\n        \
    \    return Tuple.Create(foundOne[0], foundTwo[0]);\n        }\n        if (foundOne.Count\
    \ == 1 && foundTwo.Count == 0) {\n            return Tuple.Create(foundOne[0],\
    \ numbers[endIndex]);\n        }\n        if (foundOne.Count == 0 && foundTwo.Count\
    \ == 1) {\n            return Tuple.Create(numbers[endIndex], foundTwo[0]);\n\
    \        }\n        if (foundOne.Count == 0 && foundTwo.Count == 0) {\n      \
    \      throw new ArgumentException(\"List must have at least one element in it.\"\
    );\n        }\n        return null;", "        Debug.Assert(numbers.Count >= 2,\
    \ \"numbers must be at least 2\");\n        Debug.Assert(numbers.Count <= 1000,\
    \ \"numbers may not be greater than 1000\");\n        Tuple<float, float> result\
    \ = new Tuple<float, float>(-1.0f, -1.0f);\n        numbers.Sort();\n        if\
    \ (numbers.Count == 2) {\n            return result;\n        }\n        var mid\
    \ = numbers.Count / 2;\n        var low = numbers.Take(mid).ToArray();\n     \
    \   var high = numbers.Skip(mid).ToArray();\n        var a = FindClosestElement(low,\
    \ high);\n        var b = FindClosestElement(high, low);\n        if (a.Item1\
    \ == -1.0f && b.Item1 == -1.0f) {\n            return result;\n        }\n   \
    \     if (a.Item1 < b.Item1) {\n            result.Item1 = a.Item1;\n        \
    \    result.Item2 = b.Item1;\n        } else {\n            result.Item1 = b.Item1;\n\
    \            result.Item2 = a.Item1;\n        }\n        return result;", "  \
    \      float bigger1 = numbers[0];\n        float smaller1 = numbers[0];\n   \
    \     float bigger2 = numbers[0];\n        float smaller2 = numbers[0];\n\n  \
    \      for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i] <\
    \ smaller1) {\n                smaller1 = numbers[i];\n            } else if (numbers[i]\
    \ > bigger1) {\n                bigger1 = numbers[i];\n            }\n       \
    \     if (numbers[i] > bigger2) {\n                bigger2 = numbers[i];\n   \
    \         } else if (numbers[i] < smaller2) {\n                smaller2 = numbers[i];\n\
    \            }\n        }\n        return new Tuple<float, float>(bigger1, bigger2);",
  "        // Convert the numbers to BigIntegers and then to Decimals.\n        //\
    \ This is because BigInteger has a much higher precision that Decimal.\n     \
    \   List<BigInteger> bigIntegersNumber = numbers.Select(x => (BigInteger) x).ToList();\n\
    \        List<Decimal> decimalsNumber = bigIntegersNumber.Select(x => (Decimal)\
    \ x).ToList();\n\n        Decimal min1 = decimalsNumber.Min();\n        Decimal\
    \ max1 = decimalsNumber.Max();\n\n        Decimal min2 = decimalsNumber.Min();\n\
    \        Decimal max2 = decimalsNumber.Max();\n\n        Decimal min3 = decimalsNumber.Min();\n\
    \        Decimal max3 = decimalsNumber.Max();\n\n        Decimal min4 = decimalsNumber.Min();\n\
    \        Decimal max4 = decimalsNumber.Max();\n\n        Decimal min5 = decimalsNumber.Min();\n\
    \        Decimal max5 = decimalsNumber.Max();\n\n        Decimal min6 = decimalsNumber.Min();\n\
    \        Decimal max6 = decimalsNumber.Max();\n\n        Decimal min7 = decimalsNumber.Min();\n\
    \        Decimal max7 = decimalsNumber.Max();\n\n        Decimal min8 = decimalsNumber.Min();\n\
    \        Decimal max8 = decimalsNumber.Max();\n\n        Decimal min9 = decimalsNumber.Min();\n\
    \        Decimal max9 = decimalsNumber.Max();\n\n        Decimal min10 = decimalsNumber.Min();\n\
    \        Decimal max10 = decimalsNumber.Max();\n\n        Decimal min11 = decimalsNumber.Min();\n\
    \        Decimal max11 = decimalsNumber.Max();\n\n        Decimal min12 = decimalsNumber.Min();\n\
    \        Decimal max12 = decimalsNumber.Max();\n\n        Decimal min13 = decimalsNumber.Min();\n\
    \        Decimal max13 = decimalsNumber.Max();\n\n        Decimal min14 = decimalsNumber.Min();\n\
    \        Decimal max14 = decimalsNumber.Max();\n\n        Decimal min15 = decimalsNumber.Min();\n\
    \        Decimal max15 = decimalsNumber.Max();\n\n        Decimal min16 = decimalsNumber.Min();\n\
    \        Decimal max16 = decimalsNumber.Max();\n\n        Decimal min17 = decimalsNumber.Min();\n\
    \        Decim", "        var min = numbers.Min();\n        var max = numbers.Max();\n\
    \        var result = new Tuple<float, float>(min, max);\n        return result;",
  "        // Find the two numbers with smallest difference in absolute value.\n \
    \       float smallestDifference, largestDifference;\n        if (numbers.Count\
    \ == 0)\n            return new Tuple<float, float>(float.NegativeInfinity, -float.PositiveInfinity);\n\
    \        smallestDifference = numbers.First();\n        largestDifference = numbers.Last();\n\
    \        if (smallestDifference > largestDifference) {\n            smallestDifference\
    \ = largestDifference;\n            largestDifference = numbers.First();\n   \
    \     }\n        for (int i = 1; i < numbers.Count - 1; ++i) {\n            float\
    \ currentDifference = numbers.ElementAt(i) - numbers.ElementAt(i - 1);\n     \
    \       if (currentDifference > smallestDifference) {\n                smallestDifference\
    \ = currentDifference;\n                largestDifference = numbers.ElementAt(i);\n\
    \            }\n        }\n        return new Tuple<float, float>(smallestDifference,\
    \ largestDifference);", "        // Ensure at least two numbers are supplied\n\
    \        if (numbers.Count < 2) {\n            throw new ArgumentException(\"\
    Must supply at least two numbers\", \"numbers\");\n        }\n        // Convert\
    \ each number into a floating point number\n        float[] floatNumbers = new\
    \ float[numbers.Count];\n        for (int i = 0; i < floatNumbers.Length; i++)\
    \ {\n            floatNumbers[i] = Convert.ToSingle(numbers[i]);\n        }\n\
    \        // Sort the numbers in ascending order\n        Array.Sort(floatNumbers);\n\
    \        // Find the two closest numbers from the sorted array\n        float\
    \ smallerNumber = floatNumbers[0];\n        float largerNumber = floatNumbers[0];\n\
    \        for (int i = 1; i < floatNumbers.Length; i++) {\n            if (floatNumbers[i]\
    \ < smallerNumber) {\n                smallerNumber = floatNumbers[i];\n     \
    \       } else if (floatNumbers[i] > largerNumber) {\n                largerNumber\
    \ = floatNumbers[i];\n            }\n        }\n        return new Tuple<float,\
    \ float>(smallerNumber, largerNumber);", "        List<float> sorted = numbers.OrderBy(n\
    \ => n).ToList();\n        if (sorted.Count < 2) {\n            return null;\n\
    \        }\n        float a = sorted[0], b = sorted[sorted.Count - 1];\n     \
    \   float c = Mathf.Round((a + b) / 2);\n        float d = Mathf.Round(c / 2);\n\
    \        if (a < b) {\n            return Tuple.Create(d, b);\n        }\n   \
    \     if (b < c) {\n            return Tuple.Create(b, d);\n        }\n      \
    \  float e, f;\n        if (a + c < b) {\n            e = b;\n            f =\
    \ c;\n        } else {\n            e = c;\n            f = a;\n        }\n  \
    \      if (f - e > 1) {\n            return Tuple.Create(d, e);\n        }\n \
    \       return Tuple.Create(e, d);", "        float smallest = Math.Abs(numbers.Min());\n\
    \        float largest = Math.Abs(numbers.Max());\n        numbers.Sort(delegate(float\
    \ f1, float f2) { return (f1 < f2) ? -1 : 1; });\n        int first = 0, last\
    \ = numbers.Count - 1;\n        while (last > first) {\n            float mid\
    \ = (first + last) / 2;\n            if (Math.Abs(numbers[mid] - smallest) < Math.Abs(numbers[mid]\
    \ - largest)) {\n                first = mid + 1;\n            } else {\n    \
    \            last = mid - 1;\n            }\n        }\n        numbers.Sort(delegate(float\
    \ f1, float f2) { return (f1 > f2) ? -1 : 1; });\n        first = 0;\n       \
    \ last = numbers.Count - 1;\n        while (last > first) {\n            float\
    \ mid = (first + last) / 2;\n            if (Math.Abs(numbers[mid] - largest)\
    \ < Math.Abs(numbers[mid] - smallest)) {\n                first = mid + 1;\n \
    \           } else {\n                last = mid - 1;\n            }\n       \
    \ }\n        return Tuple.Create(numbers[first], numbers[last]);", "        float\
    \ minDiff = float.MaxValue;\n        float minIndex = -1;\n        foreach (float\
    \ number in numbers) {\n            float diff = Abs(number - numbers[minIndex]);\n\
    \            if (diff < minDiff) {\n                minDiff = diff;\n        \
    \        minIndex = -1;\n            } else if (diff == minDiff) {\n         \
    \       minIndex++;\n            }\n        }\n        if (minIndex == 0) {\n\
    \            return new Tuple<float, float>(numbers[0], numbers[0]);\n       \
    \ } else if (minIndex == numbers.Count - 1) {\n            return new Tuple<float,\
    \ float>(numbers[numbers.Count - 1], numbers[minIndex]);\n        } else {\n \
    \           int index = minIndex % numbers.Count;\n            int start = Math.Min(index,\
    \ numbers.Count - index - 1);\n            int end = Math.Max(index, numbers.Count\
    \ - index - 1);\n            return new Tuple<float, float>(numbers[start], numbers[end]);\n\
    \        }", "        float max = numbers.Max();\n        float min = numbers.Min();\n\
    \        float absMax = Mathf.Abs(max);\n        float absMin = Mathf.Abs(min);\n\
    \        if (absMax > absMin)\n            throw new ArgumentException(\"max must\
    \ be less than min!\");\n\n        int count = numbers.Count;\n        if (count\
    \ < 2) throw new ArgumentException(\"Must have at least 2 elements!\");\n\n  \
    \      // Sort the list so the elements are in ascending order\n        numbers.Sort();\n\
    \n        // The first number will be the min and the second will be the max\n\
    \        float a1 = numbers[0];\n        float a2 = numbers[1];\n\n        //\
    \ The second number will be the min and the first will be the max\n        float\
    \ b1 = a2;\n        float b2 = a1;\n\n        // Return the tuple of the first\
    \ two numbers \n        if (absMax < absMin) {\n            return new Tuple<float,\
    \ float>(b2, b1);\n        } else {\n            return new Tuple<float, float>(b1,\
    \ b2);\n        }", "        float smallestDifference = float.MaxValue;\n    \
    \    var smallestIndex = 0;\n        float largestDifference = float.MinValue;\n\
    \        var largestIndex = 0;\n        for (var i = 0; i < numbers.Count; i++)\
    \ {\n            var difference = Math.Abs(numbers[i] - numbers[smallestIndex]);\n\
    \            if (difference < smallestDifference) {\n                smallestDifference\
    \ = difference;\n                smallestIndex = i;\n            }\n         \
    \   difference = Math.Abs(numbers[i] - numbers[largestIndex]);\n            if\
    \ (difference > largestDifference) {\n                largestDifference = difference;\n\
    \                largestIndex = i;\n            }\n        }\n        return (Tuple.Create(numbers[smallestIndex],\
    \ numbers[largestIndex]));", "        float smallest = -1.0f; // Not sure how\
    \ negative numbers would affect this \n        float largest = 99999999999.0f;\
    \ // but not sure how you'd handle that\n        float result = numbers.Min();\n\
    \        foreach (float num in numbers) {\n            float difference = Math.Abs(smallest\
    \ - num);\n            if (difference < smallest || difference > largest) {\n\
    \                smallest = num;\n                largest = num;\n           \
    \ }\n            else if (difference == smallest) {\n                smallest\
    \ = num;\n            }\n            else if (difference == largest) {\n     \
    \           largest = num;\n            }\n        }\n        return new Tuple<float,\
    \ float>(smallest, largest);", "        if (numbers.Count < 2) return null;\n\n\
    \        double xMin = numbers.Min();\n        double xMax = numbers.Max();\n\
    \        List<Tuple<double, double>> closestElements = new List<Tuple<double,\
    \ double>>();\n\n        // Find the nearest neighbor.\n        double minDistance\
    \ = double.MaxValue;\n        Tuple<double, double> minElement = null;\n     \
    \   for (int i = 0; i < numbers.Count; i++) {\n            double x = numbers[i];\n\
    \            double distance = Math.Abs(x - xMin);\n            if (distance <\
    \ minDistance) {\n                minDistance = distance;\n                minElement\
    \ = new Tuple<double, double>(x, x);\n            } else if (distance == minDistance)\
    \ {\n                minElement.Item2 = x;\n            }\n        }\n\n     \
    \   // Add the element to the list if we have found a nearest neighbor.\n    \
    \    if (minElement != null) {\n            closestElements.Add(minElement);\n\
    \        }\n\n        // Return the results of our search, sorted by distance.\n\
    \        return closestElements.OrderBy(item => item.Item2).ThenBy(item => item.Item1).FirstOrDefault();",
  "        List<int> distances = new List<int>();\n        int smallestDistance =\
    \ (int)Math.Sqrt(numbers.Count);\n        int smallestDistanceIndex = 0;\n   \
    \     int largestDistanceIndex = 0;\n\n        foreach (int number in numbers.ToArray())\
    \ {\n            // Calculate the squared distance between the current number\n\
    \            // and the smallest distance so far.\n            int distance =\
    \ Math.Sqrt(Math.Pow(number - numbers[smallestDistanceIndex], 2));\n\n       \
    \     // Add the distance to the list of distances.\n            distances.Add(distance);\n\
    \n            // If the smallest distance is no more than twice the largest,\n\
    \            // then we are done. Otherwise, we keep going.\n            if (distance\
    \ < smallestDistance * 2) {\n                smallestDistanceIndex = distances.Count\
    \ - 1;\n                smallestDistance = distance;\n            }\n        \
    \    else {\n                // Calculate the squared distance between the current\
    \ number\n                // and the current smallest distance so far.\n     \
    \           distance = Math.Sqrt(Math.Pow(number - numbers[smallestDistanceIndex],\
    \ 2));\n\n                // If the distance is smaller than the smallest distance,\n\
    \                // then swap the smallest distance and the current index.\n \
    \               if (distance < smallestDistance) {\n                    int tmp\
    \ = smallestDistanceIndex;\n                    smallestDistanceIndex = smallestDistance;\n\
    \                    smallestDistance = tmp;\n                }\n\n          \
    \      // If the distance is larger than the largest distance\n              \
    \  // so far, then update the largest distance so far.\n                if (distance\
    \ > largestDistance) {\n                    largestDistanceIndex = distances.Count\
    \ - 1;\n                    largestDistance = distance;\n                }\n \
    \           }\n        }\n\n        // Return the smallest number, the smallest\
    \ distance, and the largest\n        // number, the largest distance.\n      \
    \  return Tuple.Create(numbers[smallestDistanceIndex], smallestDistance,\n   \
    \         numbers[largestDistanceIndex], largestDistance);", "        if (numbers\
    \ == null || numbers.Count < 2) return null;\n        List<float> first = new\
    \ List<float>(numbers.Take(numbers.Count / 2).Select(n => n - numbers[numbers.Count\
    \ / 2]));\n        List<float> second = new List<float>(numbers.Skip(numbers.Count\
    \ / 2).Select(n => n + numbers[numbers.Count / 2]));\n        List<float> result\
    \ = first.Zip(second, (f, s) => Math.Abs(f - s)).OrderBy(x => x).FirstOrDefault();\n\
    \        return result.Equals(default(float, double) ? null : new Tuple<float,\
    \ float>(result.Value, result.Item1));", "        double minDistance = double.MaxValue;\n\
    \        double closest = 0;\n        double temp = double.MinValue;\n       \
    \ double tempClosest = 0;\n        if (numbers.Count < 2) throw new ArgumentException(\"\
    There must be at least two numbers in the list\");\n        numbers.Sort();\n\
    \        double first = Math.Abs(numbers[0] - numbers[1]);\n        double second\
    \ = Math.Abs(numbers[0] - numbers[2]);\n        double third = Math.Abs(numbers[1]\
    \ - numbers[2]);\n        if (first < second) {\n            temp = first;\n \
    \           tempClosest = second;\n            closest = Math.Abs(numbers[0] -\
    \ numbers[2]);\n        }\n        if (second < third) {\n            temp = second;\n\
    \            tempClosest = third;\n            closest = Math.Abs(numbers[1] -\
    \ numbers[2]);\n        }\n        double firstDifference = Math.Abs(numbers[0]\
    \ - temp);\n        double secondDifference = Math.Abs(numbers[1] - temp);\n \
    \       if (firstDifference < secondDifference) {\n            temp = first;\n\
    \            tempClosest = second;\n            closest = Math.Abs(numbers[0]\
    \ - numbers[2]);\n        }\n        if (secondDifference < third) {\n       \
    \     temp = second;\n            tempClosest = third;\n            closest =\
    \ Math.Abs(numbers[1] - numbers[2]);\n        }\n        return Tuple.Create(temp,\
    \ tempClosest);", "        if (numbers.Count < 2)\n            throw new ArgumentException(\"\
    Number of elements must be at least 2\");\n        // Initialize two points to\
    \ begin with\n        var initialPoint = new Tuple<float, float>(numbers[0], numbers[1]);\n\
    \        var initialDifference = float.MaxValue;\n        // Initialize a list\
    \ of points that will contain the result\n        var results = new List<Tuple<float,\
    \ float>>();\n        // Use a binary search to find the closest pair of numbers\
    \ to the initial point and keep adding points to our result list\n        while\
    \ (results.Count < 2)\n        {\n            // Find the next point\n       \
    \     var nextPoint = BinarySearchForClosest(numbers, initialPoint, initialDifference);\n\
    \            // Get the difference between the current point and the next point\n\
    \            var difference = NextPointToPoint(numbers, initialPoint, nextPoint);\n\
    \            // If this point is the closer point then keep it otherwise remove\
    \ it from the list\n            if (difference < initialDifference)\n        \
    \    {\n                results.Add(nextPoint);\n                initialDifference\
    \ = difference;\n            }\n            else\n            {\n            \
    \    results.Remove(nextPoint);\n            }\n            // Get the next point\n\
    \            initialPoint = nextPoint;\n        }\n        // Sort the points\
    \ to get their results in order\n        results = results.OrderBy(x => x.Item1).ThenBy(x\
    \ => x.Item2);\n        // Return the results with the first element in the tuple\
    \ being the closer point\n        return results;", "        float minNumber;\n\
    \        float maxNumber;\n\n        if (numbers.Count < 2)\n            return\
    \ default(Tuple<float, float>);\n\n        minNumber = numbers.Min();\n      \
    \  maxNumber = numbers.Max();\n\n        foreach (float number in numbers) {\n\
    \            if (number < minNumber) {\n                minNumber = number;\n\
    \            } else if (number > maxNumber) {\n                maxNumber = number;\n\
    \            }\n        }\n\n        float closest = minNumber;\n        float\
    \ secondClosest = minNumber;\n\n        foreach (float number in numbers) {\n\
    \            if (number == closest) {\n                if (number > secondClosest)\
    \ {\n                    secondClosest = number;\n                }\n        \
    \    } else if (number == secondClosest) {\n                if (number < closest)\
    \ {\n                    closest = number;\n                }\n            } else\
    \ if (Math.Abs(number - secondClosest) < Math.Abs(number - closest)) {\n     \
    \           secondClosest = closest;\n                closest = number;\n    \
    \        }\n        }\n\n        return Tuple.Create(closest, secondClosest);",
  "        List<float> numbers2 = numbers.ToList();\n        List<float> smallest\
    \ = new List<float>();\n        List<float> largest = new List<float>();\n   \
    \     float minDiff = 10.0f;\n        for (int i = 0; i < numbers.Count - 1; i++)\
    \ {\n            float diff = Math.Abs(numbers2[i] - numbers2[i + 1]);\n     \
    \       if (diff < minDiff) {\n                minDiff = diff;\n             \
    \   smallest.Clear();\n                largest.Clear();\n                smallest.Add(numbers2[i]);\n\
    \                largest.Add(numbers2[i + 1]);\n            } else {\n       \
    \         if (diff == minDiff) {\n                    smallest.Add(numbers2[i]);\n\
    \                    largest.Add(numbers2[i + 1]);\n                }\n      \
    \      }\n        }\n        return Tuple.Create(smallest.Count + largest.Count\
    \ == 0 ? 1.0f : smallest.Min(), largest.Count + smallest.Count == 0 ? 1.0f : largest.Max());",
  "        List<float> newnumbers = numbers.ToList();\n        float smallestDifference\
    \ = 1.0f;\n        float largestDifference = 1.0f;\n\n        for(int i = 0; i\
    \ < newnumbers.Count - 2; i++) {\n            float currentDifference = (newnumbers[i\
    \ + 1] - newnumbers[i]) * (newnumbers[i + 2] - newnumbers[i + 1]);\n         \
    \   if(currentDifference < smallestDifference) {\n                smallestDifference\
    \ = currentDifference;\n                newnumbers.RemoveAt(i);\n            }\n\
    \            if(currentDifference > largestDifference) {\n                largestDifference\
    \ = currentDifference;\n                newnumbers.RemoveAt(i);\n            }\n\
    \        }\n        return new Tuple<float, float>((float)smallestDifference,\
    \ (float)largestDifference);", "        // Create an empty array to hold the results\n\
    \        var output = new float[2];\n        // Iterate through the supplied numbers\n\
    \        for (var i = 1; i < numbers.Count; i++) {\n            // Initialize\
    \ minimum distance to distance between first and second number in the supplied\
    \ list\n            var min = float.MaxValue;\n            // Get the distance\
    \ between first and second number in the supplied list\n            var distance\
    \ = Vectors.Distance(numbers[i - 1], numbers[i]);\n            // Iterate through\
    \ the supplied list\n            for (var j = 0; j < numbers.Count; j++) {\n \
    \               // Get the current distance\n                var current = Vectors.Distance(numbers[i\
    \ - 1], numbers[j]);\n                // See if current is closer than the previous\
    \ minimum\n                if (current < min) {\n                    // Update\
    \ the minimum distance\n                    min = current;\n                }\n\
    \            }\n            // If the minimum distance is greater than the distance\
    \ between first and second number in the supplied list\n            // then set\
    \ the second number to be equal to the first number\n            if (min > distance)\
    \ {\n                output[0] = numbers[i - 1];\n                output[1] =\
    \ numbers[i];\n            }\n        }\n        // Return the results\n     \
    \   return output;", "        // Find the two numbers closest to each other.\n\
    \        float smallest = numbers.Min();\n        float largest = numbers.Max();\n\
    \        float midpoint = smallest + (largest - smallest) / 2;\n        var a\
    \ = numbers.Where(x => Math.Abs(x - midpoint) < Math.Abs(smallest - midpoint)\
    \ && Math.Abs(x - midpoint) < Math.Abs(largest - midpoint)).OrderByDescending(x\
    \ => Math.Abs(x - midpoint)).Take(2).Select(x => x).ToList();\n        var b =\
    \ numbers.Where(x => Math.Abs(x - midpoint) < Math.Abs(smallest - midpoint) &&\
    \ Math.Abs(x - midpoint) < Math.Abs(largest - midpoint)).OrderBy(x => Math.Abs(x\
    \ - midpoint)).Take(2).Select(x => x).ToList();\n        // Return the two closest\
    \ elements.\n        return new Tuple<float, float>(a.First(), a.Last());", " \
    \       if (numbers.Count < 2)\n            return new Tuple<float, float>(numbers.First(),\
    \ numbers.Last());\n\n        List<float> middle = new List<float>();\n      \
    \  middle.Add(numbers.First());\n        middle.Add(numbers.Last());\n\n     \
    \   List<float> half = new List<float>(middle);\n        half.Remove(numbers.First());\n\
    \        half.Remove(numbers.Last());\n\n        List<float> differences = GetDifferences(numbers,\
    \ middle);\n        float closest = GetClosest(differences, half, numbers);\n\
    \        int indexA = GetIndexFrom(numbers, middle, closest);\n        int indexB\
    \ = GetIndexFrom(numbers, half, closest);\n\n        return new Tuple<float, float>(numbers[indexA],\
    \ numbers[indexB]);", "        if (numbers.Count < 2) return null;\n        var\
    \ firstNumber = numbers.First();\n        var lastNumber = numbers.Last();\n \
    \       float biggestNumberDifference = float.MaxValue;\n        var smallerNumber\
    \ = firstNumber;\n        var largerNumber = firstNumber;\n        foreach (var\
    \ number in numbers) {\n            var currentDifference = Mathf.Abs(number -\
    \ firstNumber);\n            if (currentDifference > biggestNumberDifference)\
    \ {\n                biggestNumberDifference = currentDifference;\n          \
    \      smallerNumber = number;\n                largerNumber = lastNumber;\n \
    \           }\n            else {\n                largerNumber = number;\n  \
    \          }\n        }\n        return (Tuple.Create(smallerNumber, largerNumber));",
  "        float[] floatValues = new float[numbers.Count];\n        for (int i = 0;\
    \ i < numbers.Count; i++)\n            floatValues[i] = numbers[i];\n        Array.Sort(floatValues,\
    \ (a, b) => a - b);\n\n        float previousFloat = floatValues[0];\n       \
    \ float nextFloat = floatValues[1];\n        for (int i = 2; i < numbers.Count;\
    \ i++) {\n            float current = floatValues[i];\n            if (current\
    \ == previousFloat) {\n                return new Tuple<float, float>(previousFloat,\
    \ nextFloat);\n            }\n            if (current < previousFloat) {\n   \
    \             previousFloat = current;\n            }\n            if (current\
    \ > nextFloat) {\n                nextFloat = current;\n            }\n      \
    \  }\n\n        return new Tuple<float, float>(previousFloat, nextFloat);", " \
    \       var closest = numbers.Min();\n        var result = new List<float>();\n\
    \n        var differences = numbers.GroupBy(n => Math.Abs(closest.Value) - Math.Abs(n)).Select(n\
    \ => n.Key);\n\n        foreach (var difference in differences.OrderBy(n => n))\
    \ {\n            var number = numbers.FirstOrDefault(n => Math.Abs(closest.Value)\
    \ - Math.Abs(n) == difference);\n            result.Add(number);\n        }\n\n\
    \        return new Tuple<float, float>(closest.Value, result.FirstOrDefault());",
  "        List<float> selected = numbers.Where(x => x > numbers[0]).ToList();\n \
    \       List<float> unselected = numbers.Where(x => x < numbers[0]).ToList();\n\
    \        float closest = selected.Min();\n        if (unselected.Count < 2) {\n\
    \            return new Tuple<float, float>(numbers[0], numbers[0]);\n       \
    \ }\n        float difference = numbers.Min() - numbers.Max();\n        if (unselected.Count\
    \ >= 2) {\n            float smallest = (difference < 0.0f) ? closest : numbers.Min();\n\
    \            float largest = (difference < 0.0f) ? numbers.Max() : closest;\n\
    \            return new Tuple<float, float>(smallest, largest);\n        }\n \
    \       float smallest = (difference < 0.0f) ? closest : numbers.Min();\n    \
    \    float largest = (difference < 0.0f) ? numbers.Max() : closest;\n        return\
    \ new Tuple<float, float>(smallest, largest);", "        float smallestValue =\
    \ numbers.Min();\n        float largestValue = numbers.Max();\n        float difference\
    \ = largestValue - smallestValue;\n        float smallestDifference = smallest\
    \ - largestValue;\n        float largestDifference = largest - smallestValue;\n\
    \n        // Convert the smallest difference to the closest difference\n     \
    \   if (smallestDifference > 0) {\n            smallestDifference = Math.Abs(smallestDifference);\n\
    \        }\n\n        // Convert the largest difference to the closest difference\n\
    \        if (largestDifference > 0) {\n            largestDifference = Math.Abs(largestDifference);\n\
    \        }\n\n        // Determine the order of the numbers\n        float orderOfNumbers\
    \ = numbers[numbers.IndexOf(smallestValue)];\n        float secondOrderOfNumbers\
    \ = numbers[numbers.IndexOf(largestValue)];\n\n        // Determine the two closest\
    \ values\n        float closest1 = smallestValue + orderOfNumbers * smallestDifference;\n\
    \        float closest2 = largestValue + secondOrderOfNumbers * largestDifference;\n\
    \n        return new Tuple<float, float>(closest1, closest2);", "        float\
    \ min = numbers[0], max = numbers[0];\n        float closest1, closest2;\n   \
    \     for (int i = 1; i < numbers.Count; i++) {\n            float thisMin = numbers[i],\
    \ thisMax = numbers[i];\n            if (thisMin < min) {\n                min\
    \ = thisMin;\n            }\n            if (thisMax > max) {\n              \
    \  max = thisMax;\n            }\n            if (thisMin < closest1) {\n    \
    \            closest1 = thisMin;\n            }\n            if (thisMax < closest2)\
    \ {\n                closest2 = thisMax;\n            }\n        }\n        return\
    \ Tuple.Create(closest1, closest2);", "        BigDecimal bignum = new BigDecimal(numbers.Sum()).Abs()\
    \ % new BigDecimal(100).Abs();\n        bignum = bignum.Multiply(new BigDecimal(100).Add(numbers[0]).Add(numbers[1]));\n\
    \        double[] input = new double[] { bignum.ToString(), numbers[0], numbers[1]\
    \ };\n        BigDecimal bignum2 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum3 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum4 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum5 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum6 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum7 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum8 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum9 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum10 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum11 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum12 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum13 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum14 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum15 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum16 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum17 = new BigDecimal(numbers[1]).Add(new BigDecimal(numbers[0]));\n\
    \        BigDecimal bignum18 = new BigDecimal(numbers[0]).Add(new BigDecimal(numbers[1]));\n\
    \        BigDecimal bignum19 = new BigDecimal(numbers[1]).Add(", "        if (numbers.Count\
    \ < 2)\n            throw new ArgumentException(\"numbers\", \"numbers.Count must\
    \ be greater than 1\");\n\n        // The first number is the closest to the second.\n\
    \        var firstClosest = Math.Abs(numbers[0] - numbers[1]);\n        var secondClosest\
    \ = Math.Abs(numbers[0] - numbers[0]);\n\n        // The smallest number we find\
    \ is the firstClosest.\n        var closest = firstClosest;\n\n        // Loop\
    \ through all the remaining numbers.\n        for (var i = 0; i < numbers.Count;\
    \ i++) {\n            // If the current number is equal to the second closest\
    \ and the first closest has not changed, then we have\n            // found a\
    \ pair of numbers that are the closest to each other.\n            if ((numbers[i]\
    \ == secondClosest && first == firstClosest)\n                || (numbers[i] !=\
    \ secondClosest && numbers[i] != firstClosest)) {\n                // Set the\
    \ new closest number.\n                closest = numbers[i];\n            }\n\n\
    \            // If we have found the smallest number, then break out of the loop.\n\
    \            if (closest == firstClosest)\n                break;\n        }\n\
    \n        // Return the numbers in an ordered tuple.\n        return (Tuple.Create(numbers[numbers.Count\
    \ - 1], closest));", "        int N = numbers.Count;\n        if (N < 2)\n   \
    \         throw new ArgumentException(\"Must have two or more numbers to compare\"\
    , \"number\");\n        float diff = Math.Abs(numbers[1] - numbers[0]);\n    \
    \    float bestDistance = diff;\n        float bestClosestElement = numbers[0];\n\
    \        float bestClosestElementIndex = -1;\n        for (int i = 1; i < N; i++)\
    \ {\n            float diff = numbers[i] - numbers[i - 1];\n            float\
    \ distance = Math.Abs(diff);\n            if (distance < bestDistance) {\n   \
    \             bestDistance = distance;\n                bestClosestElement = numbers[i];\n\
    \                bestClosestElementIndex = i - 1;\n            }\n        }\n\
    \        return new Tuple<float, float>(bestClosestElement, bestClosestElementIndex);",
  "        if (numbers.Count < 2) return null;\n        numbers.Sort();\n\n      \
    \  int i = numbers.Count / 2;\n        int j = numbers.Count - 1;\n        float\
    \ result = numbers[i];\n\n        while (j >= i) {\n            if (Math.Abs(numbers[j]\
    \ - result) < Math.Abs(numbers[i] - result)) {\n                j = numbers.Count\
    \ - 1;\n            } else {\n                i = numbers.Count / 2;\n       \
    \     }\n        }\n        if (Math.Abs(numbers[i] - result) < Math.Abs(numbers[j]\
    \ - result)) {\n            return new Tuple<float, float>(numbers[i], numbers[j]);\n\
    \        } else {\n            return new Tuple<float, float>(numbers[j], numbers[i]);\n\
    \        }", "        float smallest, largest;\n        var closest = new List<float>();\n\
    \        bool biggest = numbers.Count >= 2;\n        foreach (float number in\
    \ numbers) {\n            if (biggest) {\n                if (number > largest)\
    \ {\n                    biggest = false;\n                }\n            }\n\
    \            else {\n                if (number < smallest) {\n              \
    \      smallest = number;\n                }\n            }\n            if (biggest)\
    \ {\n                if (Math.Abs(number - largest) < Math.Abs(number - smallest))\
    \ {\n                    closest.Add(number);\n                    largest = number;\n\
    \                }\n                else {\n                    closest.Add(smallest);\n\
    \                    smallest = number;\n                }\n            }\n  \
    \          else {\n                if (Math.Abs(number - smallest) < Math.Abs(number\
    \ - largest)) {\n                    closest.Add(number);\n                  \
    \  smallest = number;\n                }\n                else {\n           \
    \         closest.Add(largest);\n                    largest = number;\n     \
    \           }\n            }\n        }\n        return closest.Count > 0 ? new\
    \ Tuple<float, float>(closest.Min(), closest.Max()) : default(Tuple<float, float>);",
  "        float smallest, largest;\n        if (numbers.Count < 2) {\n          \
    \  throw new ArgumentException(\"List must have at least two elements\");\n  \
    \      }\n        if (numbers.Count == 2) {\n            smallest = largest =\
    \ numbers[0];\n        } else {\n            smallest = numbers[0];\n        \
    \    largest = numbers[0];\n            for (int i = 1; i < numbers.Count; ++i)\
    \ {\n                if (numbers[i] < smallest) {\n                    smallest\
    \ = numbers[i];\n                } else if (numbers[i] > largest) {\n        \
    \            largest = numbers[i];\n                }\n            }\n       \
    \ }\n        return new Tuple<float, float>(smallest, largest);", "        Debug.Assert(numbers.Count\
    \ > 2);\n        float diff = 0;\n        float minDiff = float.MaxValue;\n  \
    \      float maxDiff = float.MinValue;\n        float closestLeft = 0.0f;\n  \
    \      float closestRight = 0.0f;\n        float closestDiff = 0.0f;\n       \
    \ int index;\n\n        for (int i = 0; i < numbers.Count - 1; i++) {\n      \
    \      float left = numbers[i];\n            float right = numbers[i + 1];\n\n\
    \            diff = Mathf.Abs(left - right);\n\n            if (diff < minDiff)\
    \ {\n                minDiff = diff;\n                closestLeft = left;\n  \
    \              closestRight = right;\n                closestDiff = diff;\n  \
    \          }\n        }\n\n        Debug.Assert(minDiff > 0);\n        Debug.Assert(closestLeft\
    \ != 0.0f);\n        Debug.Assert(closestRight != 0.0f);\n        Debug.Assert(closestDiff\
    \ > 0);\n\n        // Check if we found an odd number of elements\n        if\
    \ (numbers.Count % 2 != 0) {\n            Debug.Assert(closestLeft != 0.0f);\n\
    \            Debug.Assert(closestRight != 0.0f);\n            Debug.Assert(closestDiff\
    \ > 0);\n            Debug.Assert(closestLeft < closestRight);\n            return\
    \ new Tuple<float, float>(closestLeft, closestRight);\n        }\n\n        for\
    \ (int i = numbers.Count - 1; i > 0; i--) {\n            float left = numbers[i];\n\
    \            float right = numbers[i - 1];\n\n            diff = Mathf.Abs(left\
    \ - right);\n\n            if (diff < minDiff) {\n                minDiff = diff;\n\
    \                closestLeft = left;\n                closestRight = right;\n\
    \                closestDiff = diff;\n            }\n        }\n\n        // If\
    \ we are here, then numbers[1] is closest to numbers[0]\n        Debug.Assert(minDiff\
    \ > 0);\n        Debug.Assert(closestLeft != 0.0f);\n        Debug.Assert(closestRight\
    \ != 0.0f);\n        Debug.Assert(closestDiff > 0);\n\n        return new Tuple<float,\
    \ float>(closestLeft, closestRight);", "        var numberSet = numbers.ToLookup(x\
    \ => x);\n        // Sort the numberSet's by distance between them.\n        var\
    \ closestElements = numberSet\n            .Where(x => x.Key != numberSet.First().Key)\n\
    \            .OrderBy(x => Math.Abs(x.Key + numberSet.First().Key))\n        \
    \    .First()\n            .ToArray();\n\n        // Return the elements sorted\
    \ by distance and ordered by their distance to the closest element.\n        return\
    \ closestElements.Concat(\n            numberSet\n                .Where(x =>\
    \ x.Key != closestElements.First().Key)\n                .OrderBy(x => Math.Abs(x.Key\
    \ + numberSet.First().Key))\n                .First()\n                .ToArray())\n\
    \            .OrderBy(x => x.Key)\n            .ToArray()\n            .Select(x\
    \ => Tuple.Create(x.Item1, x.Item2));", "        float maxDifference;\n      \
    \  float numberWithMaxDifference;\n        float temp1, temp2;\n        float\
    \ temp3, temp4;\n        float temp5, temp6;\n        float temp7, temp8;\n  \
    \      float temp9, temp10;\n        float temp11, temp12;\n        float temp13,\
    \ temp14;\n        float temp15, temp16;\n        float temp17, temp18;\n    \
    \    float temp19, temp20;\n        float temp21, temp22;\n        float temp23,\
    \ temp24;\n        float temp25, temp26;\n        float temp27, temp28;\n    \
    \    float temp29, temp30;\n        float temp31, temp32;\n        float temp33,\
    \ temp34;\n        float temp35, temp36;\n        float temp37, temp38;\n    \
    \    float temp39, temp40;\n        float temp41, temp42;\n        float temp43,\
    \ temp44;\n        float temp45, temp46;\n        float temp47, temp48;\n    \
    \    float temp49, temp50;\n        float temp51, temp52;\n        float temp53,\
    \ temp54;\n        float temp55, temp56;\n        float temp57, temp58;\n    \
    \    float temp59, temp60;\n        float temp61, temp62;\n        float temp63,\
    \ temp64;\n        float temp65, temp66;\n        float temp67, temp68;\n    \
    \    float temp69, temp70;\n        float temp71, temp72;\n        float temp73,\
    \ temp74;\n        float temp75, temp76;\n        float temp77, temp78;\n    \
    \    float temp79, temp80;\n        float temp81, temp82;\n        float temp83,\
    \ temp84;\n        float temp85, temp86;\n        float temp87, temp88;\n    \
    \    float temp89, temp90;\n        float temp91, temp92;\n        float temp93,\
    \ temp94;\n        float temp95, temp96;\n        float temp97, temp98;\n    \
    \    float temp99, temp100;\n        float temp101, temp102;\n        float temp103,\
    \ temp104;\n        float temp105, temp106;\n        float temp107, temp108;\n\
    \        float temp109, temp110;\n        float temp111, temp112;\n        float\
    \ temp113, temp114;\n        float temp115, temp116;\n        float temp117, temp118;\n\
    \        float temp119, temp120;\n        float temp", "        float maxDiff\
    \ = numbers[0].Abs() - numbers[1].Abs();\n        int i = 0;\n        int j =\
    \ 1;\n        while (j < numbers.Count) {\n            float diff = numbers[j].Abs()\
    \ - numbers[i].Abs();\n            if (diff > maxDiff) {\n                maxDiff\
    \ = diff;\n                i = j;\n            }\n            ++j;\n        }\n\
    \        return (Tuple.Create(numbers[i], numbers[i - 1]));", "        float max1\
    \ = numbers.Min();\n        float min1 = numbers.Max();\n        float max2 =\
    \ numbers.Min();\n        float min2 = numbers.Max();\n        for (int i = 0;\
    \ i < numbers.Count; i++) {\n            float val = numbers[i];\n           \
    \ if (val < max1) {\n                max1 = val;\n            } else if (val >\
    \ min1) {\n                min1 = val;\n            }\n            if (val > max2)\
    \ {\n                max2 = val;\n            } else if (val < min2) {\n     \
    \           min2 = val;\n            }\n        }\n        if (min1 != min2) {\n\
    \            return new Tuple<float, float>(min1, min2);\n        }\n        if\
    \ (max1 != max2) {\n            return new Tuple<float, float>(max1, max2);\n\
    \        }\n        return new Tuple<float, float>(max1, max2);", "        if\
    \ (numbers.Count < 2) throw new ArgumentException(\"The list must contain at least\
    \ two elements!\");\n        var smallestDifference = (numbers.First() - numbers.Last());\n\
    \        var result = new Tuple<float, float>();\n        for (var i = 1; i <\
    \ numbers.Count; i++)\n        {\n            var currentDifference = numbers[i]\
    \ - numbers[i - 1];\n            var isClosest = Math.Abs(currentDifference) <\
    \ smallestDifference;\n            if (isClosest)\n            {\n           \
    \     smallestDifference = currentDifference;\n                result = new Tuple<float,\
    \ float>(numbers[i], numbers[i - 1]);\n            }\n        }\n        return\
    \ result;", "        Debug.Assert(numbers.Count > 2);\n        Debug.Assert(numbers.All(n\
    \ => n > 0));\n        Debug.Assert(numbers.All(n => n < numbers.Max()));\n  \
    \      Debug.Assert(numbers.All(n => n > 0));\n        Debug.Assert(numbers.All(n\
    \ => n < numbers.Max()));\n        Debug.Assert(numbers.All(n => n == numbers[0]));\n\
    \        Debug.Assert(numbers.All(n => n == numbers[1]));\n\n        double distance\
    \ = GetDistance(numbers[0], numbers[1]);\n        var closestElements = new List<float>();\n\
    \        int closestCount = 0;\n        for (int i = 0; i < numbers.Count - 1;\
    \ i++) {\n            var currentElement = numbers[i];\n            var nextElement\
    \ = numbers[i + 1];\n\n            // Skip past the current element if we've reached\
    \ our destination\n            if (i == numbers.Count - 2) {\n               \
    \ nextElement = numbers[0];\n            }\n\n            var distance = GetDistance(currentElement,\
    \ nextElement);\n            if (distance < distance) {\n                distance\
    \ = distance;\n                closestCount = 1;\n            } else {\n     \
    \           if (closestCount > 0) {\n                    closestElements.Add(currentElement);\n\
    \                }\n                closestCount = closestCount + 1;\n       \
    \     }\n        }\n        if (closestCount > 0) {\n            closestElements.Add(numbers[numbers.Count\
    \ - 1]);\n        }\n        return Tuple.Create(closestElements[0], closestElements[1]);",
  "        float smallest = numbers.First();\n        float largest = numbers.Last();\n\
    \        numbers.Sort();\n\n        if (numbers.Count < 2)\n            return\
    \ new Tuple<float, float>(smallest, largest);\n        int index = 0;\n      \
    \  float middle = numbers[index];\n        float temp = middle;\n\n        do\
    \ {\n            temp = numbers[index];\n\n            // Keep track of the smallest\
    \ and largest numbers we've seen so far.\n            smallest = temp < smallest\
    \ ? temp : smallest;\n            largest = temp > largest ? temp : largest;\n\
    \            index++;\n        } while (index < numbers.Count - 1);\n\n      \
    \  // Return the result\n        return new Tuple<float, float>(smallest, largest);",
  "        if (numbers == null) return null;\n        using (var md5 = MD5.Create())\
    \ {\n            var bytes = md5.ComputeHash(numbers.ToArray()).Take(10).ToArray();\n\
    \            return new Tuple<float, float>(bytes[0], bytes[1]);\n        }",
  "        // Calculate the \"average\" using MathHelper, otherwise we'd end up dividing\
    \ by zero\n        var average = MathHelper.Average(numbers);\n\n        // Sort\
    \ the list by absolute value, smallest to largest\n        numbers.Sort();\n\n\
    \        // Find the two smallest values\n        var smallerNumber = numbers.TakeWhile(x\
    \ => x < average).First();\n        var largerNumber = numbers.SkipWhile(x =>\
    \ x < average).Skip(1).First();\n\n        return Tuple.Create(smallerNumber,\
    \ largerNumber);", "        // Sort the numbers first\n        numbers.Sort();\n\
    \n        // Find the smallest element and largest element and subtract 1 from\
    \ each to make sure they are the smallest/largest\n        float smallest = numbers[0];\n\
    \        float largest = numbers[0];\n\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            smallest = Math.Min(numbers[i], smallest);\n           \
    \ largest = Math.Max(numbers[i], largest);\n        }\n\n        // Now that the\
    \ values are sorted we can check which numbers are closer to eachother\n     \
    \   if (numbers[0] - smallest > largest) {\n            smallest = numbers[0];\n\
    \            largest = numbers[0];\n        } else {\n            smallest = largest;\n\
    \        }\n\n        float closest = 0;\n\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            // If this number is closer than the others\n          \
    \  if (numbers[i] - closest > largest - smallest) {\n                closest =\
    \ numbers[i];\n            }\n\n            // If this number is closer than the\
    \ others\n            if (numbers[i] - closest < smallest - largest) {\n     \
    \           closest = numbers[i];\n            }\n        }\n\n        return\
    \ Tuple.Create(smallest, largest);", "        if (numbers.Count < 2)\n       \
    \     throw new ArgumentException(\"list must have at least two elements.\");\n\
    \        float x = numbers[0];\n        float y = numbers[1];\n        float dsq\
    \ = (x - y) * (x - y);\n        int idx = 1;\n        while (idx < numbers.Count\
    \ - 1) {\n            float xn = numbers[idx];\n            float yn = numbers[idx\
    \ + 1];\n            float dsqn = (xn - yn) * (xn - yn);\n            if (dsqn\
    \ < dsq) {\n                idx = idx + 1;\n            }\n            else\n\
    \                dsq = dsqn;\n        }\n        return (Tuple.Create(x, y));",
  "        numbers.Sort();\n        int min1 = numbers.IndexOf(numbers[0]);\n    \
    \    int min2 = numbers.IndexOf(numbers[1]);\n\n        if (min1 == min2) {\n\
    \            return new Tuple<float, float>(numbers[0], numbers[1]);\n       \
    \ }\n\n        int m1 = numbers.IndexOf(numbers[min1]);\n        int m2 = numbers.IndexOf(numbers[min2]);\n\
    \n        if (m1 == m2) {\n            return new Tuple<float, float>(numbers[m1],\
    \ numbers[min2]);\n        }\n\n        if (m1 < m2)\n            return new Tuple<float,\
    \ float>(numbers[m1], numbers[m2]);\n        else\n            return new Tuple<float,\
    \ float>(numbers[m2], numbers[m1]);", "        var smallest = numbers[0];\n  \
    \      var largest = numbers[0];\n\n        for (var i = 1; i < numbers.Count;\
    \ i++) {\n            var current = numbers[i];\n            if (Math.Abs(smallest\
    \ - current) < Math.Abs(largest - current))\n                smallest = current;\n\
    \            else\n                largest = current;\n        }\n\n        return\
    \ new Tuple<float, float>(smallest, largest);", "        float smallest = (float)numbers[0];\n\
    \        float largest = (float)numbers[0];\n\n        foreach (float number in\
    \ numbers) {\n            if (smallest * 100 > number)\n                smallest\
    \ = number;\n\n            if (largest * 100 < number)\n                largest\
    \ = number;\n        }\n\n        // For odd lengths, make smallest == largest.\n\
    \        if (numbers.Count % 2 == 0) {\n            float temp = largest;\n  \
    \          largest = smallest;\n            smallest = temp;\n        }\n\n  \
    \      return new Tuple<float, float>(smallest, largest);", "        float smallestDiff\
    \ = numbers.Min(f => Math.Abs(f - numbers.Last()));\n\n        var smallest =\
    \ numbers.First();\n        var largest = numbers.Last();\n\n        foreach (var\
    \ number in numbers) {\n            var diff = Math.Abs(number - largest);\n \
    \           if (diff < smallestDiff) {\n                smallestDiff = diff;\n\
    \                smallest = number;\n            }\n            diff = Math.Abs(number\
    \ - smallest);\n            if (diff < smallestDiff) {\n                smallestDiff\
    \ = diff;\n                largest = number;\n            }\n        }\n     \
    \   return Tuple.Create(smallest, largest);", "        if (numbers.Count < 2)\
    \ {\n            throw new ArgumentException();\n        }\n\n        var minX\
    \ = numbers.Min();\n        var maxX = numbers.Max();\n        var mid = numbers.Count\
    \ / 2;\n\n        float minY = numbers.ElementAt(mid);\n        float maxY = numbers.ElementAt(mid\
    \ + 1);\n\n        if (minX > maxX) {\n            // Swap min and max to avoid\
    \ an edge case where x is the minimum and y is maximum.\n            float temp\
    \ = minX;\n            minX = maxX;\n            maxX = temp;\n            temp\
    \ = minY;\n            minY = maxY;\n            maxY = temp;\n        }\n\n \
    \       // Find the closest pair to each, by finding the two y values closest\
    \ to the minimum and maximum.\n        var minIndex = numbers.BinarySearch(minY);\n\
    \        var maxIndex = numbers.BinarySearch(maxY);\n        if (minIndex < 0\
    \ || maxIndex < 0) {\n            throw new ArgumentException();\n        }\n\n\
    \        // If the minimum and maximum are in the same side of the array and if\
    \ either\n        // is the first or last item in the list then the minimum must\
    \ be in the first half of\n        // the array and the maximum must be in the\
    \ second half. This is a tricky situation\n        // so just split them up into\
    \ two halves and try again.\n        if ((minIndex == 0 || minIndex == numbers.Count\
    \ - 1) && (maxIndex == 0 || maxIndex == numbers.Count - 1)) {\n            float\
    \ midPoint = numbers.Count / 2;\n            minIndex = numbers.BinarySearch(minY);\n\
    \            maxIndex = numbers.BinarySearch(maxY);\n\n            // If the minimum\
    \ is in the first half and maximum is in the second half, then\n            //\
    \ they must both be in the first half of the array. At this point we know that\
    \ the minimum\n            // is not the maximum.\n            if ((minIndex <\
    \ 0 || minIndex == numbers.Count - 1) && (maxIndex < 0 || maxIndex == numbers.Count\
    \ - 1)) {\n                minIndex = midPoint;\n                maxIndex = midPoint;\n\
    \            }\n        }\n\n        // If we get to here then we know that the\
    \ minimum and maximum are in the same half of the array.\n        // The minimum\
    \ is in the first half of the array and the maximum is in the second half.\n \
    \       // We know that the minimum must be before the first number and the maximum\
    \ must be after the\n        // last number so we get the index (minIndex) of\
    \ the first number and the index (maxIndex) of the\n        // last number in\
    \ the array and use the index to get the element we want.\n        var minElement\
    \ = numbers.ElementAt(minIndex);\n        var maxElement = numbers.ElementAt(maxIndex);\n\
    \n        // Now that we know the minimum and maximum are in the same half of\
    \ the array, we can just\n        // return the tuple. If the minimum is after\
    \ the maximum, we return (maxElement, minElement", "        int minDistance =\
    \ Int32.MaxValue;\n        int minIndex = -1;\n        int maxIndex = -1;\n  \
    \      for (int i = 0; i < numbers.Count - 1; i++) {\n            float x = numbers[i];\n\
    \            float y = numbers[i + 1];\n            float distance = Math.Abs(x\
    \ - y);\n            if (distance < minDistance) {\n                minDistance\
    \ = distance;\n                minIndex = i;\n            } else if (distance\
    \ > maxDistance) {\n                maxDistance = distance;\n                maxIndex\
    \ = i;\n            }\n        }\n\n        if (minDistance == maxDistance) {\n\
    \            return new Tuple<float, float>(numbers[minIndex], numbers[maxIndex]);\n\
    \        } else {\n            return new Tuple<float, float>(numbers[minIndex],\
    \ numbers[maxIndex]);\n        }", "        float[] valuesArray = numbers.ToArray();\n\
    \        int minimum = Math.Min(valuesArray.Length, 2);\n\n        if (minimum\
    \ == 2) {\n            return new Tuple<float, float>(Math.Min(valuesArray[0],\
    \ valuesArray[1]), Math.Max(valuesArray[0], valuesArray[1]));\n        }\n\n \
    \       if (minimum == 3) {\n            return new Tuple<float, float>(Math.Min(valuesArray[0],\
    \ valuesArray[1]), Math.Max(valuesArray[0], valuesArray[1]));\n        }\n\n \
    \       if (minimum == 4) {\n            return new Tuple<float, float>(Math.Min(valuesArray[0],\
    \ valuesArray[1]), Math.Max(valuesArray[0], valuesArray[1]));\n        }\n\n \
    \       float minimumValue = valuesArray[0];\n        float maximumValue = valuesArray[1];\n\
    \        int indexOfMinimumValue = -1;\n        for (int i = 1; i < minimum; i++)\
    \ {\n            if (valuesArray[i] < minimumValue) {\n                minimumValue\
    \ = valuesArray[i];\n                indexOfMinimumValue = i;\n            }\n\
    \        }\n        if (indexOfMinimumValue == -1)\n            indexOfMinimumValue\
    \ = 0;\n        indexOfMinimumValue++;\n        int indexOfMaximumValue = minimum;\n\
    \        for (int i = minimum + 1; i < valuesArray.Length; i++) {\n          \
    \  if (valuesArray[i] > maximumValue) {\n                maximumValue = valuesArray[i];\n\
    \                indexOfMaximumValue = i;\n            }\n        }\n        if\
    \ (indexOfMaximumValue == values.Length)\n            indexOfMaximumValue = values.Length\
    \ - 1;\n\n        float closestToMinimum = valuesArray[indexOfMinimumValue];\n\
    \        float closestToMaximum = valuesArray[indexOfMaximumValue];\n        if\
    \ (minimumValue + maximumValue < closestToMinimum)\n            closestToMinimum\
    \ = minimumValue + maximumValue;\n        if (minimumValue + maximumValue > closestToMaximum)\n\
    \            closestToMaximum = minimumValue + maximumValue;\n\n        return\
    \ new Tuple<float, float>(closestToMinimum, closestToMaximum);", "        var\
    \ x = new List<float>(numbers);\n        var y = x.ToArray();\n        // Really\
    \ inefficient method of finding the closest two elements - not very efficient,\
    \ however\n        // it works for lists of size 1 and 2\n        // First find\
    \ which number is closest to the first number\n        var x0 = y.First(d => Math.Abs(d\
    \ - x.First()) < double.Epsilon);\n        Debug.Assert(x0.Equals(x.First(), double.Epsilon),\
    \ \"x0 is close enough to first number in list to remove it\");\n        var x1\
    \ = y.First(d => Math.Abs(d - x.First()) < double.Epsilon);\n        Debug.Assert(x1.Equals(x.First(),\
    \ double.Epsilon), \"x1 is close enough to first number in list to remove it\"\
    );\n        // Now find the second closest number\n        var x2 = y.First(d\
    \ => Math.Abs(d - x.First()) < double.Epsilon);\n        Debug.Assert(x2.Equals(x.First(),\
    \ double.Epsilon), \"x2 is close enough to first number in list to remove it\"\
    );\n        // Now combine both into one list for return\n        var result =\
    \ new List<float>(2);\n        result.Add(x0);\n        result.Add(x1);\n    \
    \    result.Add(x2);\n        return Tuple.Create(result.First(), result.Last());",
  "        if (numbers.Count == 0) return new Tuple<float, float>(0, 0);\n       \
    \ if (numbers.Count < 2) return null;\n        float n1 = numbers[0];\n      \
    \  float n2 = numbers[1];\n        float a1 = Math.Abs(n1 - n2);\n        float\
    \ a2 = Math.Abs(n2 - n1);\n        if (Math.Abs(n1 - n2) <= a2 && a1 <= a2) return\
    \ new Tuple<float, float>(n1, n2);\n        float n3 = numbers[numbers.Count -\
    \ 1];\n        float n4 = numbers[numbers.Count - 2];\n        float b1 = Math.Abs(n4\
    \ - n3);\n        float b2 = Math.Abs(n3 - n4);\n        if (Math.Abs(n4 - n3)\
    \ <= b2 && b1 <= b2) return new Tuple<float, float>(n4, n3);\n        return null;",
  "        // Convert input into a list of pairs of floats containing the two numbers\
    \ with smallest absolute difference\n        List<Tuple<float, float>> pairs =\
    \ numbers.Select(number => new Tuple<float, float>(Math.Abs(number), number)).ToList();\n\
    \        // Sort pairs by smallest difference between input numbers and sort pairs\
    \ by second number\n        pairs.Sort((x, y) => x.Item1.CompareTo(y.Item1));\n\
    \        pairs.Sort((x, y) => x.Item2.CompareTo(y.Item2));\n        // Return\
    \ first and second number in the first pair which is the closest to each\n   \
    \     return pairs.First().Item2, pairs.Last().Item2;", "        List<float> sortedNumbers\
    \ = numbers.OrderBy(n => n).ToList();\n        SortedDictionary<float, float>\
    \ closest = sortedNumbers.GroupBy(n => n).ToDictionary(g => g.Key, g => g.First());\n\
    \        float smallerNumberValue = sortedNumbers.Last();\n        float largerNumberValue\
    \ = sortedNumbers.First();\n\n        if (closest[smallerNumberValue] < closest[largerNumberValue])\n\
    \            return new Tuple<float, float>(closest[largerNumberValue], largerNumberValue);\n\
    \        else\n            return new Tuple<float, float>(smallerNumberValue,\
    \ closest[smallerNumberValue]);", "        if (numbers == null || numbers.Count\
    \ < 2)\n            throw new ArgumentException(\"Must supply at least 2 numbers\"\
    );\n        float first = numbers.First();\n        float second = numbers.Last();\n\
    \        if (first > second)\n            throw new ArgumentException(\"First\
    \ number must be smaller than second\");\n        List<float> orderedNumbers =\
    \ new List<float>(numbers);\n        orderedNumbers.Sort((a, b) => Math.Abs(a\
    \ - b));\n        int firstIndex = 0, secondIndex = 0;\n        if (Math.Abs(orderedNumbers[0]\
    \ - orderedNumbers[1]) < Math.Abs(orderedNumbers[2] - orderedNumbers[3]))\n  \
    \          firstIndex = 1;\n        else\n            secondIndex = 2;\n     \
    \   float returnValue1 = orderedNumbers[firstIndex];\n        float returnValue2\
    \ = orderedNumbers[secondIndex];\n        if (Math.Abs(returnValue1 - returnValue2)\
    \ < Math.Abs(returnValue1 - returnValue2))\n            return new Tuple<float,\
    \ float>(returnValue1, returnValue2);\n        else\n            return new Tuple<float,\
    \ float>(returnValue2, returnValue1);"]
stop_tokens:
- "\n    }\n"
