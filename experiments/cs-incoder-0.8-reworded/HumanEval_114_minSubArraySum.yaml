name: HumanEval_114_minSubArraySum
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a list of integers nums, find the minimum sum of any non-empty\
  \ sub-list\n    // of nums.\n    // Example\n    // >>> Minsubarraysum((new List<long>(new\
  \ long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))\n    //\
  \ (1L)\n    // >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L,\
  \ (long)-3L})))\n    // (-6L)\n    public static long Minsubarraysum(List<long>\
  \ nums) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))\
  \ == (1L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L,\
  \ (long)-2L, (long)-3L}))) == (-6L));\n    Debug.Assert(Minsubarraysum((new List<long>(new\
  \ long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));\n\
  \    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L})))\
  \ == (-9999999999999999L));\n    Debug.Assert(Minsubarraysum((new List<long>(new\
  \ long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L})))\
  \ == (-6L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L,\
  \ (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L})))\
  \ == (3L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L,\
  \ (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)-10L}))) == (-10L));\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)7L}))) == (7L));\n    Debug.Assert(Minsubarraysum((new\
  \ List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));\n    }\n\n}\n"
completions: ["        // Solution 1, using dynamic programming\n        long min\
    \ = int.MaxValue;\n        long[] d = new long[nums.Count];\n        long[] minSubArray\
    \ = new long[nums.Count];\n        long[] minSubArraySum = new long[nums.Count];\n\
    \        for (int i = 0; i < nums.Count; ++i) {\n            d[i] = nums[i]; //\
    \ initialize the min subarray sum\n            minSubArray[i] = nums[i]; // initialize\
    \ the min subarray\n        }\n        for (int i = 1; i < nums.Count; ++i) {\n\
    \            for (int j = i; j < nums.Count; ++j) {\n                d[j] = Math.Min(d[j],\
    \ d[j - i] + nums[j]);\n            }\n            minSubArray[i] = nums[i]; //\
    \ update the min subarray\n            for (int j = 0; j < i; ++j) { // update\
    \ the min subarray sum\n                minSubArraySum[i] = Math.Min(minSubArraySum[i],\
    \ minSubArray[j] + d[i]);\n            }\n        }\n        return minSubArraySum.Min();",
  "        if (nums.Count == 0) {\n            throw new InvalidOperationException(\"\
    The array is empty\");\n        }\n        var minsum = nums[0];\n        var\
    \ minsum1 = minsum;\n        var minsum2 = minsum;\n        var minsum3 = minsum;\n\
    \        var minsum4 = minsum;\n        var minsum5 = minsum;\n        for (int\
    \ i = 1; i < nums.Count; i++) {\n            var sum = 0;\n            for (int\
    \ j = 0; j < nums.Count; j++) {\n                if (j == i) {\n             \
    \       sum += nums[j];\n                }\n                else {\n         \
    \           sum += (nums[j] - minsum1);\n                }\n            }\n  \
    \          if (sum < minsum) {\n                minsum = sum;\n              \
    \  minsum1 = sum;\n            }\n        }\n        minsum2 = 0; // No need of\
    \ extra variable here, only to help debugging\n        for (int i = nums.Count\
    \ - 2; i >= 0; i--) {\n            var sum = 0;\n            for (int j = 0; j\
    \ < nums.Count; j++) {\n                if (j == i) {\n                    sum\
    \ += nums[j];\n                }\n                else {\n                   \
    \ sum += (nums[j] - minsum2);\n                }\n            }\n            if\
    \ (sum < minsum2) {\n                minsum2 = sum;\n            }\n        }\n\
    \        minsum3 = 0; // No need of extra variable here, only to help debugging\n\
    \        for (int i = 0; i < nums.Count; i++) {\n            var sum = 0;\n  \
    \          for (int j = 0; j < nums.Count; j++) {\n                if (j == i)\
    \ {\n                    sum += nums[j];\n                }\n                else\
    \ {\n                    sum += (nums[j] - minsum3);\n                }\n    \
    \        }\n            if (sum < minsum3) {\n                minsum3 = sum;\n\
    \            }\n        }\n        minsum4 = 0; // No need of extra variable here,\
    \ only to help debugging\n        for (int i = 0; i < nums.Count; i++) {\n   \
    \         var sum = 0;\n            for (int j = 0; j < nums.Count; j++) {\n \
    \               if (j == i) {\n                    sum += nums[j];\n         \
    \       }\n                else {\n                    sum += (nums[j] - minsum4);\n\
    \                }\n            }\n            if (sum < minsum4) {\n        \
    \        minsum4 = sum;\n            }\n        }\n        minsum5 = 0; // No\
    \ need of extra variable here, only to help debugging\n        for (int i = 0;\
    \ i < nums.Count; i++) {\n            var sum = 0;\n            for (int j = 0;\
    \ j < nums.Count; j++) {\n                if (j == i) {\n                    sum\
    \ += nums[j];\n                }\n                else {\n                   \
    \ sum += (nums[j] - minsum5);\n                }\n            }\n            if\
    \ (sum < minsum5) {\n                minsum5 = sum;\n            }\n        }\n\
    \        return minsum + minsum1 + minsum2 + minsum3 + minsum4 + minsum5;", " \
    \       long[] a = new long[nums.Count];\n        long[] b = new long[nums.Count];\n\
    \        long result = 0;\n        int i = 0;\n        int j = 0;\n        foreach\
    \ (long n in nums) {\n            a[i] = n;\n            i++;\n        }\n   \
    \     while (i < a.Length) {\n            result += a[i];\n            i++;\n\
    \        }\n        while (j < b.Length) {\n            b[j] = nums[j];\n    \
    \        j++;\n        }\n        while (i + j < b.Length) {\n            b[i\
    \ + j] = nums[i + j];\n            i += j;\n            j++;\n        }\n    \
    \    long ans = result;\n        for (int k = i; k < b.Length; k++) {\n      \
    \      ans += b[k];\n        }\n        return ans;", "        long smallestSum\
    \ = nums.Sum();\n        List<long> currentSum = new List<long> { smallestSum\
    \ };\n        HashSet<long> found = new HashSet<long>();\n        while(!found.Contains(smallestSum))\
    \ {\n            found.Add(smallestSum);\n            currentSum.Add(smallestSum);\n\
    \            currentSum = currentSum.Concat(nums.Where(n => found.Contains(n)).SelectMany(n\
    \ => { found.Remove(n); return currentSum; }).ToList());\n            smallestSum\
    \ = currentSum.Min();\n        }\n        return smallestSum;", "        // Use\
    \ a dictionary to cache the subarray sums for each num\n        var cache = nums.GroupBy(n\
    \ => n).ToDictionary(g => g.Key, g => g.Sum());\n\n        // Calculate the sum\
    \ of all the numbers in the list to know which subarray\n        // to check next\n\
    \        long minSum = nums.Sum();\n\n        // Find the smallest number in the\
    \ list to start the search from\n        for (int i = 0; i < nums.Count; i++)\
    \ {\n            long sum = 0;\n            for (int j = i; j < nums.Count; j++)\
    \ {\n                // If the current number is less than the one we already\
    \ have,\n                // we can skip adding it since it will be added as a\
    \ sub-array\n                // when adding the remaining numbers\n          \
    \      if (sum + nums[j] < minSum) continue;\n\n                // We add the\
    \ current number to the current sub-array\n                sum += nums[j];\n\n\
    \                // If the current sum is smaller than the minimum sum, we\n \
    \               // have found a new sub-array\n                if (sum < minSum)\
    \ {\n                    minSum = sum;\n                }\n            }\n   \
    \     }\n\n        // Return the minimum sum\n        return minSum;", "     \
    \   var result = nums.Sum();\n        for (int i = 1; i < nums.Count; i++) {\n\
    \            var sub = nums.Skip(i).TakeWhile(x => x >= nums[0]);\n          \
    \  var sumsub = sub.Sum();\n            result = result < sumsub ? result : sumsub;\n\
    \        }\n        return result;", "        long min = nums[0];\n        long\
    \ temp;\n        foreach (var n in nums.Skip(1)) {\n            temp = min;\n\
    \            min += n;\n            if (min >= temp) return min;\n        }\n\
    \        return min;", "        Debug.Assert(nums.Count > 0);\n        var list\
    \ = new List<long>();\n        long min = long.MaxValue;\n        long sum = long.MaxValue;\n\
    \        foreach (long i in nums) {\n            list.Add(i);\n            sum\
    \ += i;\n            if (sum < min) {\n                min = sum;\n          \
    \  }\n        }\n        long ans = long.MaxValue;\n        foreach (long i in\
    \ list) {\n            if (i >= min) {\n                ans = i;\n           \
    \ }\n        }\n        return ans;", "        long result = nums[0];\n      \
    \  List<long> list = new List<long>();\n        foreach (long i in nums)\n   \
    \         list.Add(i);\n        list.RemoveAt(0);\n        while(list.Count >\
    \ 0) {\n            long sum = 0;\n            foreach(long i in list)\n     \
    \           sum += i;\n            list.RemoveAt(0);\n            result = Math.Min(result,\
    \ sum);\n        }\n        return result;", "        int N = nums.Count;\n  \
    \      long Sum = nums.Min();\n        long Min = -9223372036854775807;\n    \
    \    int Max = 0;\n        for (int i = 0; i < N; i++)\n            Sum = Sum\
    \ + nums[i];\n        if (Sum > 0)\n            Min = sum;\n        for (int i\
    \ = 0; i < (N - 1); i++) {\n            Sum = Sum - nums[i];\n            if (Sum\
    \ < 0)\n                Min = sum;\n        }\n        return Min;", "       \
    \ long[] d = new long[nums.Count];\n        long minSum = long.MinValue;\n   \
    \     int minIndex = -1;\n        for (int i = 0; i < nums.Count; i++) {\n   \
    \         d[i] = nums[i];\n        }\n        for (int i = 0; i < nums.Count -\
    \ 1; i++) {\n            if (d[i] + d[i + 1] < minSum) {\n                minSum\
    \ = d[i] + d[i + 1];\n                minIndex = i;\n            }\n        }\n\
    \        long sum = 0;\n        for (int i = minIndex; i <= nums.Count - 1; i++)\
    \ {\n            sum += d[i];\n        }\n        return sum;", "        List<long>\
    \ results = new List<long>();\n        long min = 0;\n        foreach (var i in\
    \ nums) {\n            if (min == 0) min = i;\n            else\n            \
    \    min = Math.min(min, i);\n        }\n        results.Add(min);\n        long\
    \ result = 0;\n        var max = new long[nums.Count];\n        foreach (var i\
    \ in nums)\n            max[nums.IndexOf(i)] = i;\n        foreach (var i in nums)\
    \ {\n            result += max[nums.IndexOf(i)];\n        }\n        return result;",
  "        if (nums.Count == 0) return 0;\n        long result = nums.Min();\n   \
    \     long sum = 0;\n        long min = nums[0];\n        for (int i = 0; i <\
    \ nums.Count - 1; i++) {\n            sum = sum + nums[i];\n            min =\
    \ Math.Min(min, sum);\n            sum -= min;\n            if (sum < 0) sum =\
    \ sum + min;\n        }\n        return sum;", "        var sum = new List<long>();\n\
    \        long sum1 = 0;\n        long sum2 = 0;\n        foreach (var i in nums)\n\
    \            sum1 += i;\n        foreach (var j in nums)\n            sum2 +=\
    \ j;\n        if (sum1 > sum2)\n            sum1 = sum2;\n        else if (sum1\
    \ < sum2)\n            sum2 = sum1;\n        foreach (var i in nums) {\n     \
    \       if (sum1 + i < sum2) {\n                sum1 += i;\n            } else\
    \ {\n                sum2 -= i;\n            }\n        }\n        sum2 += sum2;\n\
    \        if (sum1 < sum2)\n            return sum1;\n        return sum2;", " \
    \       long sum = 0;\n        List<int> list = new List<int>();\n\n        for\
    \ (int i = 0; i < nums.Count; i++) {\n            if (list[i] == -1) {\n     \
    \           sum += nums[i];\n                list.Add(i);\n            }\n   \
    \         else if (nums[i] == sum) {\n                list.Add(i);\n         \
    \   }\n            else if (nums[i] > sum) {\n                sum = nums[i];\n\
    \                list.Clear();\n                list.Add(i);\n            }\n\
    \            else {\n                list.Add(i);\n            }\n        }\n\
    \        if (list.Count > 0) {\n            sum += list[0];\n        }\n     \
    \   return sum;", "        var n = nums.Count;\n        if (n == 0) {\n      \
    \      return 0;\n        }\n        long min = long.MaxValue;\n        var best\
    \ = new List<long>(n);\n        var bestsum = new List<long>();\n\n        long\
    \ sum = 0;\n        for (int i = 0; i < n; i++) {\n            var j = 0;\n  \
    \          while (j < n && nums[j] < nums[i]) {\n                j++;\n      \
    \      }\n            if (j == n) {\n                sum = sum + nums[i];\n  \
    \              best.Add(nums[i]);\n                if (sum < min) {\n        \
    \            min = sum;\n                    bestsum = best;\n               \
    \ }\n            } else if (j < n) {\n                sum = sum + nums[j];\n \
    \               best.AddRange(nums.GetRange(j, n - j));\n                if (sum\
    \ < min) {\n                    min = sum;\n                    bestsum = best;\n\
    \                }\n            }\n        }\n        var totalsum = best.Sum();\n\
    \        if (totalsum > 0) {\n            var ms = new List<long>(bestsum);\n\
    \            while (totalsum > 0) {\n                totalsum = totalsum - ms.Sum();\n\
    \                ms.Add(bestsum.Min());\n            }\n            return ms.Sum();\n\
    \        } else {\n            return 0;\n        }", "        long minval = nums.First();\n\
    \        long maxval = nums.Last();\n        long range = 0;\n        double total\
    \ = 0;\n        double range1 = 0;\n        double range2 = 0;\n        double\
    \ range3 = 0;\n        double range4 = 0;\n        double range5 = 0;\n      \
    \  double range6 = 0;\n        double range7 = 0;\n        double range8 = 0;\n\
    \        double range9 = 0;\n        double range10 = 0;\n        double range11\
    \ = 0;\n        double range12 = 0;\n        double range13 = 0;\n        double\
    \ range14 = 0;\n        double range15 = 0;\n        double range16 = 0;\n   \
    \     double range17 = 0;\n        double range18 = 0;\n        double range19\
    \ = 0;\n        double range20 = 0;\n        double range21 = 0;\n        double\
    \ range22 = 0;\n        double range23 = 0;\n        double range24 = 0;\n   \
    \     double range25 = 0;\n        double range26 = 0;\n        double range27\
    \ = 0;\n        double range28 = 0;\n        double range29 = 0;\n        double\
    \ range30 = 0;\n        double range31 = 0;\n        double range32 = 0;\n   \
    \     double range33 = 0;\n        double range34 = 0;\n        double range35\
    \ = 0;\n        double range36 = 0;\n        double range37 = 0;\n        double\
    \ range38 = 0;\n        double range39 = 0;\n        double range40 = 0;\n   \
    \     double range41 = 0;\n        double range42 = 0;\n        double range43\
    \ = 0;\n        double range44 = 0;\n        double range45 = 0;\n        double\
    \ range46 = 0;\n        double range47 = 0;\n        double range48 = 0;\n   \
    \     double range49 = 0;\n        double range50 = 0;\n        double range51\
    \ = 0;\n        double range52 = 0;\n        double range53 = 0;\n        double\
    \ range54 = 0;\n        double range55 = 0;\n        double range56 = 0;\n   \
    \     double range57 = 0;\n        double range58 = 0;\n        double range59\
    \ = 0;\n        double range60 = 0;\n        double range61 = 0;\n        double\
    \ range62 = 0;\n        double range63 = 0;\n        double range64 = 0;\n   \
    \     double range65 = 0;\n        double range66 = 0;\n        double range67\
    \ = 0;\n        double range68 = 0;\n        double range69 = 0;\n        double\
    \ range70 = 0;\n        double range71 = 0;\n        double range72 = 0;\n   \
    \     double range73 = 0;\n        double range74 = 0;\n        double range75\
    \ = 0;\n        double range76 = 0;\n        double range77 = 0;\n        double\
    \ range78 = 0;\n        double range79 = 0;\n        double range80 = 0;\n   \
    \     double range81 = 0;\n        double range", "        // initialize min and\
    \ sum with first number\n        var min = 0;\n        var sum = 0;\n\n      \
    \  // iterate over each number\n        for (int i = 0; i < nums.Count; i++) {\n\
    \n            // if the next number is less than the current min, then set min\
    \ to the current number and sum to 0\n            if (nums[i] < min)\n       \
    \         min = nums[i];\n            else\n                sum += nums[i];\n\
    \        }\n\n        // return min\n        return sum;", "        long minsum\
    \ = long.MaxValue;\n        for(int i = 0; i < nums.Count; i++) {\n          \
    \  for(int j = i; j < nums.Count; j++) {\n                if(nums[i] > nums[j])\
    \ {\n                    minsum = MinSum(nums, i, j, minsum);\n              \
    \  }\n            }\n        }\n        return minsum;", "        long minsum\
    \ = (long)nums[0];\n        foreach (var s in nums.Skip(1))\n            minsum\
    \ -= s;\n        return minsum;", "        long minSum = -1L;\n        long minSum2\
    \ = 0;\n        for (int i = 0; i < nums.Count; i++) {\n            long subSum\
    \ = 0;\n            long x = nums[i];\n            for (int j = i; j < nums.Count;\
    \ j++)\n                subSum += nums[j];\n            if (subSum < 0)\n    \
    \            subSum = -subSum;\n            if (subSum > minSum2)\n          \
    \      minSum2 = minSum;\n            minSum = Math.Min(subSum, minSum);\n   \
    \     }\n        return minSum2;", "        long sum = 0;\n        long minSum\
    \ = nums.Min();\n\n        int subIndex = 1;\n        int currentIndex = 0;\n\n\
    \        bool needNextSub = true;\n        for (int index = 0; index < nums.Count;\
    \ index++) {\n            if (currentIndex < subIndex) {\n                sum\
    \ += nums[currentIndex];\n                if (sum < minSum) {\n              \
    \      minSum = sum;\n                }\n            }\n            currentIndex++;\n\
    \n            if (needNextSub) {\n                subIndex++;\n              \
    \  if (subIndex == nums.Count) {\n                    needNextSub = false;\n \
    \               }\n            }\n        }\n\n        return minSum;", "    \
    \    long result = nums.Min();\n        if (nums.Count > 1)\n            foreach\
    \ (long number in nums)\n                if (number >= result)\n             \
    \       result = Math.Min(result, number);\n        return result;", "       \
    \ long min = 0;\n        long max = 0;\n        long sum = 0;\n        for (int\
    \ i = 0; i < nums.Count; i++) {\n            if (min > nums[i]) min = nums[i];\n\
    \            if (max < nums[i]) max = nums[i];\n        }\n\n        long range\
    \ = max - min;\n        int count = 0;\n\n        for (int i = 0; i < nums.Count;\
    \ i++) {\n            if (min < nums[i]) {\n                sum += nums[i];\n\
    \                count++;\n                min = nums[i];\n            } else\
    \ if (max - nums[i] > range) {\n                sum += nums[i] * (count - 1);\n\
    \                count += count - 1;\n                max = nums[i];\n       \
    \     } else {\n                sum += nums[i] * (count - 1);\n              \
    \  count += count - 1;\n            }\n        }\n\n        return sum;", "  \
    \      long min = nums.Min();\n        long max = (long)nums.Max();\n        long\
    \ sum = nums.Sum();\n        for (int i = 0; i < nums.Count; i++) {\n        \
    \    long curSum = sum - nums[i];\n            long curMax = max - nums[i];\n\
    \            if (curSum < 0)\n                curSum = curSum - curMax;\n    \
    \        else if (curSum > 0)\n                curSum = curSum + curMax;\n   \
    \         if (curSum < min)\n                min = curSum;\n            if (curSum\
    \ > max)\n                max = curSum;\n        }\n        return max;", "  \
    \      long min = 0;\n        var sum = 0;\n        foreach (var num in nums)\
    \ {\n            sum += num;\n            if (sum < min) min = sum;\n        }\n\
    \        return min;", "        int n = nums.Count;\n        long[] s = new long[n];\n\
    \        long[] m = new long[n];\n        long sum = 0;\n        long min = int.MaxValue;\n\
    \        for(int i = 0; i != n; i++) {\n            s[i] = nums[i];\n        \
    \    sum += s[i];\n            m[i] = s[i];\n            while(i != 0 && s[i]\
    \ < m[i]) {\n                s[--i] -= s[i];\n                sum += s[i];\n \
    \           }\n            if(sum < min) {\n                min = sum;\n     \
    \           for(int j = 0; j != n; j++)\n                    m[j] = s[j];\n  \
    \          }\n        }\n        return min;", "        long minSum = nums.Min();\n\
    \        for (int i = 0; i < nums.Count; i++) {\n            for (int j = i +\
    \ 1; j < nums.Count; j++) {\n                minSum = Min(Min(nums[i], nums[j]),\
    \ minSum);\n            }\n        }\n        return minSum;", "        var numsCopy\
    \ = new List<long>(nums);\n        var numsCopyIndex = 0;\n        var minSum\
    \ = new List<long>();\n        while (true) {\n            var maxIndex = numsCopy.Count\
    \ - 1;\n            var sum = 0;\n            if (maxIndex < 0)\n            \
    \    break;\n            while (maxIndex >= 0 && numsCopy[maxIndex] == numsCopy[maxIndex\
    \ + 1])\n                maxIndex--;\n            while (numsCopyIndex < maxIndex)\
    \ {\n                var nums = numsCopy.Skip(numsCopyIndex).Take(maxIndex - numsCopyIndex).ToList();\n\
    \                sum += nums.Sum();\n                numsCopyIndex++;\n      \
    \      }\n            if (minSum.Count > 0)\n                minSum.Add(sum);\n\
    \            else\n                minSum = new List<long>(sum);\n        }\n\
    \        return minSum.Min();", "        long minSum = nums.Aggregate((i, s) =>\
    \ \n            s == 0L ? i : ((i < s) ? i : s));\n        Debug.Assert(minSum\
    \ > 0L);\n        return minSum;", "        var sum = new List<long>();\n    \
    \    foreach (var i in nums)\n        {\n            sum = AddSubarrays(sum, i);\n\
    \        }\n        return sum.Min();", "        if (nums == null) throw new ArgumentNullException(\"\
    nums\");\n        if (nums.Count == 0) return 0;\n\n        long min = long.MinValue;\n\
    \        long max = long.MaxValue;\n        for (long i = 0; i < nums.Count; i++)\
    \ {\n            for (long j = i + 1; j < nums.Count; j++) {\n               \
    \ min = Math.Min(min, nums[i] + nums[j]);\n                max = Math.Max(max,\
    \ nums[i] + nums[j]);\n            }\n        }\n        return (min == max) ?\
    \ 0 : min < 0 ? -min : max;", "        List<long> sums = new List<long>();\n \
    \       int leftmost = 0;\n        int rightmost = nums.Count - 1;\n\n       \
    \ while (rightmost >= leftmost + 1) {\n            int mid = (leftmost + rightmost)\
    \ / 2;\n            int leftsum = nums[leftmost] + nums[mid + 1] + nums[mid +\
    \ 2];\n            int rightsum = nums[rightmost] + nums[mid - 1] + nums[mid -\
    \ 2];\n            if (leftsum > rightsum) {\n                rightmost = mid\
    \ - 2;\n            } else {\n                leftmost = mid + 2;\n          \
    \  }\n        }\n        sums.Add(nums[leftmost]);\n        sums.AddRange(Enumerable.Range(0,\
    \ rightmost - leftmost + 1).Select(i => nums[leftmost + i]));\n        return\
    \ sums.Min();", "        Debug.Assert(nums.Count > 0);\n        long ans = nums.Sum();\n\
    \        foreach (var item in nums.Skip(1))\n            ans = Math.Min(ans, item\
    \ + nums.Sum() - item);\n        return ans;", "        var n = nums.Count;\n\
    \        if (n == 0) {\n            return 0;\n        }\n        // Find n, the\
    \ size of the sub-array.\n        long sum = 0;\n        for(int i = 1; i <= n;\
    \ i++){\n            if (nums[i - 1] > 0){\n                long j = nums[i -\
    \ 1];\n                for (int k = i; k < n; k++){\n                    if (nums[k]\
    \ >= j){\n                        j += nums[k];\n                    }\n     \
    \           }\n                sum += j;\n            }\n        }\n        return\
    \ sum;", "        long min = long.MaxValue;\n        long sum = 0;\n        foreach\
    \ (long n in nums) {\n            sum += n;\n            if (n < min) min = n;\n\
    \            if (sum > min) break;\n        }\n        return sum;", "       \
    \ long ret = 0;\n        long minSum = nums.Min();\n        foreach (int val in\
    \ nums.SkipWhile(x => x == minSum).TakeWhile(x => x >= minSum))\n            ret\
    \ = Math.Min(ret + val, ret);\n        return ret;", "        int n = nums.Count;\n\
    \        // If there is no number in the list, return the minimum value\n    \
    \    // of the list itself.\n        if (n == 0) return nums[0].GetHashCode();\n\
    \        // If the list is empty, return the minimum value of the list.\n    \
    \    if (n == 1) return nums[0].GetHashCode();\n        int min = 0;\n       \
    \ int min2 = n;\n        // Find min of list from both ends\n        while(min\
    \ < min2) {\n            if (nums[min].GetHashCode() > nums[min2].GetHashCode())\
    \ {\n                min2 = min;\n            }\n            else {\n        \
    \        min++;\n            }\n        }\n        int min3 = min2;\n        int\
    \ min4 = n;\n        // Find min of list from both ends\n        while(min < min4)\
    \ {\n            if (nums[min].GetHashCode() < nums[min3].GetHashCode()) {\n \
    \               min3 = min;\n            }\n            else {\n             \
    \   min++;\n            }\n        }\n        int min5 = min3;\n        int min6\
    \ = n;\n        // Find min of list from both ends\n        while(min < min6)\
    \ {\n            if (nums[min].GetHashCode() > nums[min5].GetHashCode()) {\n \
    \               min5 = min;\n            }\n            else {\n             \
    \   min++;\n            }\n        }\n        // If min5 is bigger than min3,\
    \ we found the minimal sum\n        if (min5 > min3) return nums[min5].GetHashCode();\n\
    \        // if min3 is bigger than min5, we found the minimal sum\n        if\
    \ (min3 > min5) return nums[min3].GetHashCode();\n        // If min2 is bigger\
    \ than min3, we found the minimal sum\n        if (min2 > min3) return nums[min2].GetHashCode();\n\
    \        // if min2 is bigger than min5, we found the minimal sum\n        if\
    \ (min2 > min5) return nums[min2].GetHashCode();\n        return min;", "    \
    \    List<long> list = new List<long>();\n        double sum = 0;\n        int\
    \ count = 0;\n        long min = long.MaxValue;\n        bool flag = true;\n \
    \       for (int i = 0; i < nums.Count; i++) {\n            if (flag) {\n    \
    \            sum += nums[i];\n                count += 1;\n                list.Add(sum);\n\
    \                sum = 0;\n                flag = false;\n            } else {\n\
    \                sum -= nums[i];\n                count += 1;\n              \
    \  if (sum < 0) {\n                    flag = true;\n                }\n     \
    \           min = Math.Min(min, sum);\n            }\n        }\n        return\
    \ count;", "        long minSum = nums[0];\n\n        long[] numsCopy = nums.ToArray();\n\
    \n        Queue<long> queue = new Queue<long>();\n\n        Queue<long> currentQueue\
    \ = new Queue<long>();\n\n        HashSet<long> alreadyEnqueued = new HashSet<long>();\n\
    \n        long currentSum = numsCopy[0];\n\n        for (int i = 0; i < numsCopy.Length;\
    \ i++) {\n            if (numsCopy[i] > currentSum) {\n                currentSum\
    \ = numsCopy[i];\n                currentQueue.Enqueue(currentSum);\n        \
    \    }\n            else if (numsCopy[i] < currentSum) {\n                while\
    \ (currentQueue.Count > 0) {\n                    long elementToRemove = currentQueue.Dequeue();\n\
    \n                    if (elementToRemove > minSum) {\n                      \
    \  minSum = elementToRemove;\n                        queue.Enqueue(elementToRemove);\n\
    \                        alreadyEnqueued.Add(elementToRemove);\n             \
    \       }\n                }\n            }\n            else {\n            \
    \    if (currentQueue.Count > 0) {\n                    long elementToRemove =\
    \ currentQueue.Dequeue();\n\n                    if (elementToRemove > minSum)\
    \ {\n                        minSum = elementToRemove;\n                     \
    \   queue.Enqueue(elementToRemove);\n                        alreadyEnqueued.Add(elementToRemove);\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  while (!queue.IsEmpty) {\n            long elementToRemove = queue.Dequeue();\n\
    \n            if (elementToRemove > minSum) {\n                minSum = elementToRemove;\n\
    \            }\n        }\n\n        if (minSum < 0) minSum = 0;\n\n        return\
    \ minSum;", "        long sum = 0;\n        long temp;\n        long min = 0;\n\
    \        for (long i = 0; i < nums.Count; i++) {\n            if (nums.Count >\
    \ i) {\n                for (long j = i; j < nums.Count; j++) {\n            \
    \        temp = nums[j];\n                    if (temp > 0) {\n              \
    \          sum -= temp;\n                    }\n                    if (sum <\
    \ min) {\n                        min = sum;\n                    }\n        \
    \        }\n            }\n            sum = nums.Min(x => x);\n        }\n  \
    \      return min;", "        // This variable will hold the answer to the question\n\
    \        // \"What is the minimum sum of any non-empty sub-list of nums?\"\n \
    \       long answer = 0;\n        // This variable will hold the length of the\
    \ current sub-list\n        int listlength = 0;\n        // Loop through every\
    \ number in the input list \n        foreach (var n in nums) {\n            //\
    \ If the current number is greater than zero\n            if (n > 0) {\n     \
    \           // If this is the first element in the sub-list\n                if\
    \ (listlength == 0) {\n                    // Add the number to the answer\n \
    \                   answer += n;\n                    // Reset the list length\
    \ to 1\n                    listlength++;\n                }\n               \
    \ // If the current number is less than the last element in the sub-list\n   \
    \             else if (n < nums[listlength - 1]) {\n                    // Add\
    \ the number to the answer\n                    answer += n;\n               \
    \     // Reset the list length to 1\n                    listlength++;\n     \
    \           }\n                // Otherwise, this is the last number in the sub-list\n\
    \                else {\n                    // Add the number to the answer\n\
    \                    answer += n;\n                    // The length of the current\
    \ sub-list is increased\n                    listlength++;\n                }\n\
    \            }\n        }\n        // If the length of the sub-list hasn't been\
    \ increased by 1 \n        // (i.e. the last element in the list is less than\
    \ zero)\n        if (listlength > 0) {\n            // Return the answer\n   \
    \         return answer;\n        }\n        // If the length of the sub-list\
    \ has been increased by 1\n        // (i.e. the last element in the list is greater\
    \ than zero)\n        else {\n            // Return the answer -1\n          \
    \  return -1;\n        }", "        long retVal = 0L;\n        long min = nums.Min();\n\
    \        long max = nums.Max();\n\n        for (int i = 0; i < nums.Count; i++)\
    \ {\n            long n = nums[i];\n            if (n < min) {\n             \
    \   min = n;\n            }\n            if (n > max) {\n                max =\
    \ n;\n            }\n        }\n\n        for (int i = 0; i < nums.Count; i++)\
    \ {\n            long n = nums[i];\n            long diff = max - n;\n       \
    \     if (diff > 0) {\n                diff = diff * -1;\n            }\n    \
    \        retVal += diff;\n        }\n\n        return retVal;", "        long\
    \ min = nums.Min();\n        long sum = 0;\n        foreach (var item in nums)\
    \ {\n            sum += item;\n            if (min > sum) min = sum;\n       \
    \ }\n        return min;", "        long answer;\n        long total = 0;\n  \
    \      for (int i = 0; i < nums.Count; i++) {\n            total += nums[i];\n\
    \            Debug.Assert(total > 0);\n            if (i < nums.Count - 1) {\n\
    \                if (total - nums[i - 1] < nums[i + 1] - total)\n            \
    \        answer = total;\n            }\n            else {\n                if\
    \ (total - nums[i + 1] < 0)\n                    answer = total;\n           \
    \ }\n        }\n        return answer;", "        // Find the minimum sum of the\
    \ first 1 number\n        long minsum = nums.First();\n        // Find the minimum\
    \ sum of the remaining numbers, if any\n        for (int i = 1; i < nums.Count;\
    \ ++i) {\n            minsum = MinSum(minsum, nums[i]);\n        }\n        return\
    \ minsum;", "        long numsSumMin = nums.Min();\n        int numsSize = nums.Count;\n\
    \        if (numsSize == 0) {\n            return numsSumMin;\n        }\n   \
    \     long sum = 0;\n        int sumIndex = 0;\n        for (int i = 0; i < numsSize;\
    \ i++) {\n            for (int j = i; j < numsSize; j++) {\n                if\
    \ (nums[i] > nums[j]) {\n                    for (int k = i; k < j; k++) {\n \
    \                       sum = sum + nums[k];\n                        if (sum\
    \ < numsSumMin) {\n                            sumIndex = k;\n               \
    \             numsSumMin = sum;\n                        }\n                 \
    \   }\n                }\n            }\n        }\n        return numsSumMin;",
  "        int n = nums.Count;\n        int start = 0;\n        long total = 0;\n\
    \        int end = 0;\n        // Find the maximum sum.\n        while (start\
    \ < n - 1) {\n            end = n - 1;\n            while (end > start) {\n  \
    \              total += nums[end];\n                end--;\n            }\n  \
    \          start = end + 1;\n        }\n        while (end < n) {\n          \
    \  total += nums[end];\n            end++;\n        }\n        return total;",
  "        int minSum = nums.Min();\n        int index = -1;\n        int sum = nums[index];\n\
    \        foreach (var x in nums.Skip(index + 1).Take(nums.Count - index - 1))\
    \ {\n            sum = x + sum;\n            if (sum < minSum) {\n           \
    \     minSum = sum;\n                index = x;\n            }\n        }\n  \
    \      return minSum;", "        int n = nums.Count;\n        long sum = 0;\n\
    \        Dictionary<long, List<long>> d = new Dictionary<long, List<long>>();\n\
    \        // build d which holds keys in nums and value for each key in d\n   \
    \     for (int i = 0; i < n; i++) {\n            long sum = nums.Sum();\n    \
    \        if (!d.ContainsKey(sum))\n                d.Add(sum, new List<long>());\n\
    \            d[sum].Add(nums[i]);\n        }\n        long min = -1;\n       \
    \ // find minimum sum for each key in d\n        foreach (KeyValuePair<long, List<long>>\
    \ kvp in d) {\n            long subsum = kvp.Key.Sum();\n            if (min ==\
    \ -1 || subsum < min)\n                min = subsum;\n            else\n     \
    \           min = Math.Min(min, subsum);\n        }\n        return min;", " \
    \       // Base case: an empty array\n        if (nums == null || nums.Count ==\
    \ 0)\n            return 0;\n        // Base case: one element\n        if (nums.Count\
    \ == 1)\n            return nums[0];\n        // Recursively compute the sum of\
    \ the first two elements \n        long subarraysum = Minsubarraysum(nums.GetRange(0,\
    \ 2));\n        // Recursively compute the sum of the rest of the elements \n\
    \        long restsum = Minsubarraysum(nums.GetRange(2, nums.Count - 1));\n  \
    \      // Return the greater of the two sums\n        return Math.Max(subarraysum,\
    \ restsum);", "        long result = long.MinValue;\n        foreach (int value\
    \ in nums) {\n            long newResult = value + result;\n            if (newResult\
    \ < long.MinValue) {\n                result = long.MinValue;\n            } else\
    \ {\n                result = newResult;\n            }\n        }\n        return\
    \ result;", "        int n = nums.Count;\n        if (n == 0) {\n            return\
    \ 0;\n        }\n        int minSum = nums[0];\n        long sum = 0;\n      \
    \  for (int i = 1; i < n; i++) {\n            sum += nums[i];\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n            }\n        }\n\
    \        return minSum;", "        var result = new double[nums.Count];\n    \
    \    long ans = nums.Count == 0 ? 0 : nums[0]; // init result with first number\n\
    \        double sum = 0;\n        for (int i = 0; i < nums.Count; i++) {\n   \
    \         if (i > 0) sum += nums[i - 1];\n            if (sum < ans) continue;\n\
    \            ans = Math.Min(ans, sum);\n            result[i] = ans;\n       \
    \     sum = 0;\n        }\n        return result.Min() >= 0.0 ? result.Max() -\
    \ ans : ans;", "        long sum = 0;\n        for (int i = 0; i < nums.Count;\
    \ i++) {\n            sum += nums[i];\n            if (sum < 0) {\n          \
    \      sum = 0;\n            }\n            if (sum > nums.Count) {\n        \
    \        sum = nums.Count - 1;\n            }\n            if (sum > nums.Count\
    \ - 1) {\n                sum = 0;\n            }\n            if (sum < 0) {\n\
    \                sum = 0;\n            }\n        }\n        return sum;", " \
    \       // Using a List is a nice way to do this.\n        int n = nums.Count;\n\
    \        long min = nums.Min();\n        int minIndex = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            if (nums[i] < min) {\n                min =\
    \ nums[i];\n                minIndex = i;\n            }\n        }\n        int\
    \ sum = 0;\n        for (int i = minIndex; i < n; i++) {\n            if (i ==\
    \ minIndex) {\n                sum += nums[i];\n            }\n            else\
    \ {\n                sum += nums[i] - min;\n            }\n        }\n       \
    \ return sum;", "        // TODO: Implement me!\n        long sum;\n        long\
    \ min = long.MinValue;\n        long max = long.MaxValue;\n        if (nums ==\
    \ null)\n            return 0;\n        if (nums.Count == 0)\n            return\
    \ sum;\n        sum = nums[0];\n        nums.Remove(nums[0]);\n        for (long\
    \ index = 1; index < nums.Count; index++) {\n            sum += nums[index];\n\
    \            if (sum < min)\n                min = sum;\n            if (sum >\
    \ max)\n                max = sum;\n            nums.Remove(nums[index]);\n  \
    \          sum = sum - nums[index];\n            if (sum < min)\n            \
    \    min = sum;\n            if (sum > max)\n                max = sum;\n    \
    \        nums.Add(nums[index]);\n        }\n        if (min == long.MinValue)\n\
    \            return 0;\n        sum = 0;\n        for (long i = 0; i < nums.Count;\
    \ i++) {\n            sum += nums[i];\n        }\n        if (sum < min)\n   \
    \         min = sum;\n        if (sum > max)\n            max = sum;\n       \
    \ return sum - min;", "        long sum = 0;\n        if (nums.Count != 0) {\n\
    \            long n = nums.Count;\n            long sum = nums[0];\n         \
    \   while (n > 1) {\n                sum += nums[--n];\n            }\n      \
    \  }\n        return sum;", "        if (nums == null || nums.Count == 0) {\n\
    \            throw new ArgumentNullException(\"nums\");\n        }\n\n       \
    \ long[] values = new long[nums.Count];\n        int n = 0;\n        foreach (long\
    \ x in nums) {\n            if (n >= values.Length) {\n                values\
    \ = new long[values.Length + 1];\n            }\n            values[n++] = x;\n\
    \        }\n\n        int[] counts = new int[values.Length];\n        for (int\
    \ i = 0; i < values.Length; i++) {\n            if (values[i] != 0) {\n      \
    \          counts[i] = 0;\n            } else {\n                counts[i]++;\n\
    \            }\n        }\n\n        long minSum = long.MaxValue;\n        for\
    \ (int i = 0; i < values.Length; i++) {\n            if (counts[i] > 0) {\n  \
    \              if (counts[i] < minSum) {\n                    minSum = counts[i];\n\
    \                }\n            }\n        }\n        return minSum;", "     \
    \   long result = 0;\n        long sum = nums.Sum();\n        foreach (long a\
    \ in nums)\n        {\n            result += a;\n            if (result >= sum)\n\
    \                return result;\n        }\n        return result;", "       \
    \ // Solution 1:\n        // Find length of longest contiguous subarray of nums\n\
    \        var size = nums.Max(n => n);\n        // Build hash table\n        Dictionary<long,\
    \ long> dic = new Dictionary<long, long>();\n        foreach (var v in nums)\n\
    \            dic[v] = dic.ContainsKey(v) ? dic[v] + 1 : 1;\n        // Find the\
    \ prefix sum\n        long result = nums.Sum();\n        foreach (var v in nums)\n\
    \            result += dic[v];\n        return result;", "        if (nums.Count\
    \ == 0)\n            return 0;\n        if (nums.Count == 1)\n            return\
    \ nums[0];\n        long min = nums[0];\n        long max = nums[0];\n       \
    \ long sum = 0;\n        foreach (long num in nums)\n            min = num < min\
    \ ? num : min;\n        foreach (long num in nums.Skip(1))\n            max =\
    \ num > max ? num : max;\n        foreach (long num in nums.Skip(1))\n       \
    \     sum += num < max ? num - min : min - num;\n        return sum < min ? min\
    \ : sum < max ? min : max;", "        long sum = nums[0];\n        long n = nums.Count;\n\
    \        if (n == 1) return sum;\n        for (int i = 1; i < n; ++i) {\n    \
    \        if (nums[i] < sum) sum = nums[i];\n        }\n        for (int i = 1;\
    \ i < n; ++i) {\n            long c = nums[i];\n            while (c > sum) {\n\
    \                sum += nums[i - 1];\n                --i;\n            }\n  \
    \      }\n        return sum;", "        // Find the min in the sorted array\n\
    \        var min = nums.Min();\n        long minSum = nums.Sum(a => a + min);\n\
    \        long maxSum = nums.Sum(a => a);\n        // For each element in the unsorted\
    \ array\n        long sum = 0;\n        foreach (var a in nums) {\n          \
    \  sum += a;\n            if (sum < minSum)\n                minSum = sum;\n \
    \           if (sum > maxSum)\n                maxSum = sum;\n        }\n    \
    \    return minSum;", "        long res = long.MinValue;\n        foreach (int\
    \ i in nums)\n            res = Math.Min(res + i, res);\n        return res;",
  "        long ret = 0L;\n\n        double min = Double.MaxValue;\n        for (int\
    \ i = 0; i < nums.Count - 1; i++) {\n            double diff = nums[i + 1] - nums[i];\n\
    \            if (diff < min) {\n                min = diff;\n            }\n \
    \       }\n        for (int i = 0; i < nums.Count - 1; i++) {\n            double\
    \ diff = nums[i + 1] - nums[i];\n            if (diff < min && nums[i] != -1L)\
    \ {\n                ret += nums[i];\n                min = diff;\n          \
    \  }\n        }\n        return ret;", "        var minSum = nums.Min();\n\n \
    \       foreach (var x in nums)\n            if (x == 0)\n                return\
    \ minSum;\n\n        long sum = 0;\n        foreach (var x in nums)\n        \
    \    sum += x;\n        while (sum >= minSum) {\n            foreach (var x in\
    \ nums) {\n                sum += x;\n                if (sum < minSum)\n    \
    \                minSum = sum;\n            }\n        }\n\n        return minSum;",
  "        long sum = 0;\n        long max = nums[0];\n        long min = (long)nums[0];\n\
    \n        for (int i = 0; i < nums.Count; i++) {\n            sum += nums[i];\n\
    \            max = Math.Max(max, nums[i]);\n            min = Math.Min(min, nums[i]);\n\
    \        }\n        return min + (max - min);", "        if (nums.Count < 1) return\
    \ 0;\n        var m = nums[0].Min();\n        long sum = 0;\n        for (int\
    \ i = 1; i < nums.Count; i++) {\n            sum += nums[i] - m;\n           \
    \ m = nums[i];\n        }\n        return sum;", "        long sum = 0;\n    \
    \    if (nums.Count == 0) return 0;\n        long lastValue = nums.First();\n\
    \        for (int i = 0; i < nums.Count - 1; ++i) {\n            sum += nums[i];\n\
    \            lastValue = Math.Min(lastValue, nums[i + 1]);\n        }\n      \
    \  return sum;", "        Debug.Assert(nums.Count != 0);\n        long min = nums[0];\n\
    \        for (int i = 1; i < nums.Count; i++) {\n            min = nums[i] < nums[i-1]\
    \ ? nums[i] : min;\n        }\n        return min;", "        long min = int.MaxValue;\n\
    \        long cur = 0;\n        long sum = 0;\n        for (long i = 0; i < nums.Count;\
    \ i++) {\n            if (cur > 0)\n                sum += nums[i];\n        \
    \    if (nums[i] > 0)\n                cur += nums[i];\n            min = MathNet.Numerics.LinearAlgebra.DoubleMath.Min(min,\
    \ sum);\n        }\n        return min;", "        var minSum = nums.Min();\n\
    \        var length = nums.Count();\n        long sum = 0;\n        for (var i\
    \ = 0; i <= length; i++) {\n            if (i != length) {\n                sum\
    \ += nums[Math.Min(i, length - 1)];\n            } else {\n                sum\
    \ += nums[i];\n            }\n            if (sum < minSum) {\n              \
    \  minSum = sum;\n            }\n            sum -= nums[i];\n        }\n    \
    \    return minSum;", "        if (nums == null || nums.Count == 0) {\n      \
    \      return 0;\n        }\n        \n        long sum = 0;\n        for (int\
    \ i = 0; i < nums.Count - 1; i++) {\n            long left = nums[i];\n      \
    \      long right = nums[i + 1];\n            long sum = left + right;\n     \
    \       long min = sum;\n            foreach (long j in Enumerable.Range(0, nums.Count\
    \ - 1)) {\n                sum += nums[j];\n                long jmin = sum;\n\
    \                for (int k = i + 1; k <= j; k++) {\n                    jmin\
    \ = Math.Min(jmin, sum + nums[k]);\n                }\n                if (jmin\
    \ < min) {\n                    min = jmin;\n                }\n            }\n\
    \            sum = sum + min;\n        }\n        return sum;", "        long\
    \ minimum = nums.First();\n        foreach(long i in nums.Skip(1))\n        {\n\
    \            minimum = Math.Min(minimum - i, i);\n        }\n        return minimum;",
  "        long minSum = nums.Min();\n        long totalSum = 0;\n        foreach\
    \ (var item in nums.Skip(1))\n            totalSum += item;\n        if (totalSum\
    \ < minSum)\n            return minSum;\n        long[] subArray = new long[nums.Count\
    \ - 1];\n        for (int i = 0; i < nums.Count - 1; i++)\n            subArray[i]\
    \ = nums[i];\n        for (int i = 0; i < nums.Count - 1; i++)\n            subArray[i]\
    \ = Math.Min(subArray[i + 1], nums.Min());\n        return Minsubarraysum(subArray);",
  "        if (nums.Count <= 0) throw new ArgumentException(\"Input must be non-empty\"\
    , \"nums\");\n        var minSum = nums[0];\n        long n = nums.Count;\n  \
    \      var min = nums[0];\n        for(int i=1; i<n; ++i) {\n            if (nums[i]\
    \ < min) {\n                min = nums[i];\n            }\n            minSum\
    \ -= min;\n        }\n        return minSum;", "        long minSum = long.MaxValue;\n\
    \        long currentSum;\n        foreach(long num in nums) {\n            currentSum\
    \ = currentSum - num;\n            if(currentSum < minSum) {\n               \
    \ minSum = currentSum;\n            }\n        }\n        return minSum;", " \
    \       long result = 1L;\n        long currentSum = 0L;\n        long minSum\
    \ = -1L;\n        foreach (var n in nums) {\n            currentSum += n;\n  \
    \          if (currentSum < minSum) {\n                minSum = currentSum;\n\
    \            }\n        }\n        result = minSum;\n        return result;",
  "        long result = 0L;\n        foreach (long x in nums) {\n            result\
    \ += x;\n        }\n        return result;", "        long minSum = nums.FirstOrDefault();\n\
    \        int maxIndex = nums.Count - 1;\n        for (int i = nums.Count - 2;\
    \ i >= 0; i--) {\n            long left = nums[i];\n            long right = nums[i\
    \ + 1];\n            int j = i + 2;\n            while (j >= 0) {\n          \
    \      int k = j + 1;\n                while (k <= j) {\n                    if\
    \ (left > right) {\n                        long temp = left;\n              \
    \          left = right;\n                        right = temp;\n            \
    \        }\n                    long val = nums[k];\n                    left\
    \ = Min(left, val);\n                    right = Max(right, val);\n          \
    \          k++;\n                }\n                long val = nums[j];\n    \
    \            left = Min(left, val);\n                right = Max(right, val);\n\
    \                j--;\n            }\n            if (left < right) {\n      \
    \          minSum = left;\n                maxIndex = i;\n            } else {\n\
    \                minSum = right;\n                maxIndex = i + 1;\n        \
    \    }\n        }\n        return minSum;", "        long sum = 0;\n        foreach(long\
    \ i in nums)\n        {\n            sum += i;\n            Console.WriteLine(\"\
    sum is {0}\", sum);\n        }", "        var n = nums.Count;\n        long sum\
    \ = 0;\n        int low = 0;\n        int high = n - 1;\n        while (high >\
    \ low) {\n            sum += nums[low];\n            int mid = low + (high - low)\
    \ / 2;\n            sum -= nums[mid];\n            if (sum < 0) {\n          \
    \      low = mid + 1;\n            }\n            else {\n                high\
    \ = mid - 1;\n            }\n        }\n        return sum;", "        long n\
    \ = nums.Count;\n        long sum = 0;\n        long maxSum = -1;\n        for(int\
    \ i=0;i<n;i++){\n            long val = nums[i];\n            sum += val;\n  \
    \          if(sum>maxSum){\n                maxSum = sum;\n            }\n   \
    \     }\n        return maxSum;", "        if (nums == null)\n            throw\
    \ new ArgumentNullException(\"nums\");\n        if (nums.Count == 0)\n       \
    \     return 0;\n        var min = nums.Min();\n        if (min == 0L)\n     \
    \       return 0;\n        long sum = 0;\n        foreach (var x in nums)\n  \
    \          sum += x;\n        long nextSum = sum;\n        var res = 0;\n    \
    \    long nextMin = min;\n        foreach (var x in nums) {\n            sum =\
    \ nextSum;\n            sum += x;\n            nextSum = sum;\n            if\
    \ (sum < nextMin)\n                res = nextSum - nextMin;\n            nextMin\
    \ = x;\n        }\n        return res;", "        long minSum = nums.Sum();\n\
    \        int n = nums.Count;\n        for (int i = 0; i < n; ++i) {\n        \
    \    long sum = nums[i];\n            for (int j = i + 1; j < n; ++j) {\n    \
    \            sum += nums[j];\n                if (sum < minSum) {\n          \
    \          minSum = sum;\n                }\n            }\n        }\n      \
    \  return minSum;", "        if (nums.Count == 0 || nums.Count == 1) return nums.First();\n\
    \        long[] sums = new long[nums.Count];\n        long n = nums.First();\n\
    \        long s = 0;\n        int i = 0;\n        while (i<nums.Count-1) {\n \
    \           s = s + n;\n            sums[i] = s;\n            n = n - nums[i];\n\
    \            i++;\n        }\n        if (n == 0) {\n            s = s - sums[0];\n\
    \        }\n        return s;", "        // Initialize maxSum and minSum\n   \
    \     long minSum = -6L;\n        long maxSum = 6L;\n\n        // Initialize array\
    \ for storing the sum values\n        long[] sums = new long[nums.Count + 1];\n\
    \n        // Initialize sum[0]\n        sums[0] = nums[0];\n\n        // Calculate\
    \ the sum of each sums array\n        for (int i = 1; i < sums.Length; i++) {\n\
    \            sums[i] = sums[i - 1] + nums[i];\n        }\n\n        // For each\
    \ sum, find out the index of the smallest sum\n        for (int i = 0; i < sums.Length;\
    \ i++) {\n            long sum = sums[i];\n            int pos = 0;\n\n      \
    \      while (sum > 0) {\n                sum += nums[pos];\n                pos++;\n\
    \            }\n\n            if (sum < minSum) {\n                minSum = sum;\n\
    \                minPos = pos;\n            }\n\n            sum -= nums[pos];\n\
    \            if (sum > maxSum) maxSum = sum;\n        }\n\n        return minSum;",
  "        if (nums.Count == 0) return 0;\n        long minSum = nums.First();\n \
    \       long minSum2 = nums.First();\n        long sum = 0;\n        for (int\
    \ i = 0; i < nums.Count - 1; i++) {\n            sum += nums[i];\n           \
    \ minSum2 = sum < minSum2 ? sum : minSum2;\n            if (sum > 0) {\n     \
    \           minSum = sum > minSum ? sum : minSum;\n            }\n        }\n\
    \        return minSum;", "        long sum = 0;\n        long minSum = -Long.MaxValue;\n\
    \        int n = nums.Count;\n        int[] subset = new int[n];\n        for\
    \ (int i = 0; i < n; ++i) {\n            subset[i] = i;\n        }\n        Debug.WriteLine(\"\
    Subset \" + subset);\n        double bestDiff = Double.PositiveInfinity;\n   \
    \     for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; ++j)\
    \ {\n                if (j - i >= Math.Min(subset[i], subset[j])) {\n        \
    \            long diff = sum - nums.ElementAt(j) - nums.ElementAt(i);\n      \
    \              if (diff < bestDiff) {\n                        minSum = sum;\n\
    \                        sum = diff;\n                        bestDiff = diff;\n\
    \                        subset[i] = j;\n                        subset[j] = i;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ minSum;", "        if (nums == null)\n            throw new ArgumentNullException();\n\
    \        if (nums.Count == 0)\n            return 0;\n\n        long sum = 0;\n\
    \        int n = nums.Count;\n        // Find smallest non-negative number in\
    \ nums\n        long smallest = nums[0];\n        for (int i = 1; i < n; i++)\
    \ {\n            smallest = smallest > nums[i] ? smallest : nums[i];\n       \
    \ }\n        // Find largest negative number in nums\n        long largest = smallest;\n\
    \        for (int i = n-1; i >= 0; i--) {\n            largest = largest < nums[i]\
    \ ? largest : nums[i];\n        }\n\n        // If largest is negative, smallest\
    \ must be positive.\n        if (largest < 0) {\n            smallest = -smallest;\n\
    \            largest = -largest;\n        }\n\n        // Divide smallest by largest\
    \ until largest is 0.\n        double fraction = (double)(smallest / largest);\n\
    \        double remainder;\n        while ((fraction > 0.0d) && (fraction < 1.0d)\
    \ && (largest != 0)) {\n            fraction = fraction - 1.0d;\n            smallest\
    \ = (long) Math.Floor(fraction * largest);\n            remainder = (long)(fraction\
    \ - smallest);\n            sum = sum + remainder;\n            largest = largest\
    \ - remainder;\n        }\n\n        // Add remainder of smallest to the sum.\n\
    \        sum = sum + smallest;\n        return sum;", "        long n = nums.Count;\n\
    \        long[] numArray = new long[n];\n        int count = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            numArray[i] = nums[i];\n        }\n      \
    \  for (int i = 0; i < n - 1; i++) {\n            int startIndex = i;\n      \
    \      for (int j = i + 1; j < n; j++) {\n                if (numArray[startIndex]\
    \ + numArray[j] < numArray[i]) {\n                    startIndex = j;\n      \
    \          }\n            }\n            int endIndex = i;\n            for (int\
    \ j = i + 1; j < n; j++) {\n                if (numArray[startIndex] + numArray[j]\
    \ > numArray[i]) {\n                    endIndex = j;\n                }\n   \
    \         }\n            if (startIndex != endIndex) {\n                swap(numArray,\
    \ startIndex, endIndex);\n                count += numArray[startIndex];\n   \
    \         }\n        }\n        return count;", "        long retval = long.MaxValue;\n\
    \        var hash = new Dictionary<long, List<long>>();\n\n        // first check\
    \ all the values\n        foreach (long num in nums) {\n            // if there\
    \ already exists a list for this number, add this value\n            // to the\
    \ list and return it\n            if (hash.ContainsKey(num))\n            {\n\
    \                hash[num].Add(num);\n                foreach (var list in hash[num])\n\
    \                {\n                    retval += list.Sum();\n              \
    \  }\n                break;\n            }\n            // otherwise, set this\
    \ number as the key to create a new list\n            // for this number\n   \
    \         else\n            {\n                hash.Add(num, new List<long>());\n\
    \                hash[num].Add(num);\n            }\n        }\n\n        return\
    \ retval;", "        if (nums == null || nums.Count == 0) return 0;\n        int\
    \ N = nums.Count;\n        double minSum = 0;\n        int minIdx = 0;\n     \
    \   for (int i = 0; i < N; i++) {\n            if (i == minIdx) minSum = Math.Min(minSum,\
    \ nums[i]);\n            else minSum = Math.Min(Math.Min(minSum, nums[i]), nums[minIdx]);\n\
    \            if (N > 1) {\n                int startIdx = minIdx;\n          \
    \      bool isAllSum = true;\n                for (int j = startIdx; j < N; j++)\
    \ {\n                    if (j == startIdx) {\n                        isAllSum\
    \ = true;\n                        minSum = Math.Min(minSum, nums[j]);\n     \
    \               }\n                    else {\n                        minSum\
    \ = Math.Min(Math.Min(minSum, nums[j]), nums[j + 1]);\n                      \
    \  isAllSum = false;\n                    }\n                }\n             \
    \   if (isAllSum) minIdx = i + 1;\n            }\n        }\n        return minSum;",
  "        if (nums.Count == 0) return 0L;\n        // Find the smallest of the remaining\
    \ items,\n        // by finding the minimum of the remaining items minus the\n\
    \        // minimum of the remaining items of the current item and adding the\n\
    \        // current item minus that.\n        return nums.Min() - Minsubarraysum(nums.Skip(1).Take(nums.Count\
    \ - 1))\n            + nums.First();", "        int minSum = nums.Min();\n   \
    \     long sum = 0;\n        foreach (long n in nums) {\n            sum += n;\n\
    \            minSum = Math.Min(sum, minSum);\n        }\n        return minSum;",
  "        long sum = 0;\n        long minSoFar = nums[0];\n        long minSoFar2\
    \ = nums[0];\n        bool emptySet = true;\n        for(int i = 1; i < nums.Count;\
    \ i++) {\n            if(minSoFar + nums[i] < minSoFar2) {\n                minSoFar\
    \ = minSoFar + nums[i];\n            } else if(minSoFar2 > nums[i]) {\n      \
    \          minSoFar2 = nums[i];\n                emptySet = false;\n         \
    \   } else {\n                break;\n            }\n        }\n        if(emptySet)\
    \ {\n            return minSoFar2;\n        } else {\n            for(int i =\
    \ 0; i < nums.Count; i++) {\n                if(nums[i] - minSoFar2 < minSoFar2\
    \ - nums[i]) {\n                    minSoFar2 = nums[i] - minSoFar2;\n       \
    \         }\n            }\n            sum = minSoFar2 + Minsubarraysum(nums.Skip(1).Take(nums.Count\
    \ - 1));\n            return sum;\n        }", "        long ret = 0L;\n     \
    \   for (int i = 0; i < nums.Count; i++) {\n            long m = nums[i];\n  \
    \          int n = nums.Count - 1 - i;\n            while (n >= 0 && m < nums[n])\
    \ {\n                m = (long)(m + nums[n] * (long)(1L / nums[n]));\n       \
    \         n--;\n            }\n            ret += m;\n        }\n        return\
    \ ret;", "        long min = long.MaxValue;\n        long sum = 0;\n        foreach\
    \ (long i in nums) {\n            sum += i;\n            if (sum < min)\n    \
    \            min = sum;\n        }\n        return min;", "        long min =\
    \ long.MaxValue;\n        foreach (long num in nums) {\n            if (num <\
    \ min) {\n                min = num;\n            }\n        }\n        return\
    \ min;", "        long min = long.MaxValue;\n        bool found = false;\n   \
    \     long sum = 0;\n        long currentSum;\n        foreach(long n in nums)\
    \ {\n            currentSum = sum + n;\n            if (currentSum < min && !found)\
    \ {\n                min = currentSum;\n                found = true;\n      \
    \      } else if (currentSum < min && found) {\n                min = currentSum;\n\
    \            }\n            sum += n;\n        }\n        if (!found) {\n    \
    \        return 0;\n        }\n        return min;", "        // Create array\
    \ for storing sums\n        long[] sum = new long[nums.Count];\n\n        // Calculate\
    \ sums of subarray\n        for (int i = 0; i < nums.Count - 1; i++) {\n     \
    \       sum[i] = nums[i + 1] - nums[i];\n        }\n\n        // Return minimum\
    \ sum\n        long min = sum.Min();\n        for (int i = 0; i < nums.Count -\
    \ 1; i++) {\n            long sum = sum[i + 1] - sum[i];\n            if (sum\
    \ < min)\n                min = sum;\n        }\n        return min;", "     \
    \   if (nums == null)\n            return 0;\n\n        long maxSum = nums.Min();\n\
    \        int j = 0;\n        bool inNegative = false;\n\n        for (int i =\
    \ 0; i < nums.Count; ++i) {\n            long sum = nums[i];\n\n            if\
    \ (sum < 0)\n                inNegative = true;\n\n            while (true) {\n\
    \                if (j < nums.Count - 1 && sum < nums[j + 1])\n              \
    \      break;\n                else\n                    ++j;\n            }\n\
    \n            maxSum = Math.Max(maxSum, sum);\n        }\n\n        if (inNegative)\n\
    \            return maxSum * -1;\n\n        return maxSum;", "        long min\
    \ = long.MaxValue;\n        long max = nums.Max();\n\n        foreach (long num\
    \ in nums) {\n            if (num < min) min = num;\n            if (num > max)\
    \ max = num;\n        }\n        return max - min + 1;", "        long minSum\
    \ = nums.Min();\n        for (int i = 0; i < nums.Count - 1; i++) {\n        \
    \    long sum = 0;\n            int j = 0;\n            for (int k = 0; k < nums.Count\
    \ - i; k++) {\n                sum += nums[k];\n            }\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n            }\n           \
    \ if (nums[j] >= minSum) {\n                minSum -= nums[j];\n            }\n\
    \        }\n        return minSum;", "        long minSum = nums.Aggregate((sum,\
    \ num) => sum + num);\n        foreach (int index in Enumerable.Range(0, nums.Count))\
    \ {\n            long sum = 0;\n            List<long> next = new List<long>();\n\
    \            foreach (long val in nums.Skip(index)) {\n                sum +=\
    \ val;\n                next.Add(val);\n            }\n            if (sum < minSum)\
    \ minSum = sum;\n            nums.RemoveAll(i => next.Contains(i));\n        }\n\
    \        return minSum;", "        // write your code in C# 6.0 with .NET Core\
    \ 3.1 SDK\n        ulong sum = nums.Sum();\n        var max = Enumerable.Range(0,\
    \ nums.Count).Max();\n        ulong maxsum = Enumerable.Range(0, nums.Count -\
    \ max).Sum();\n        if(sum > maxsum) return sum;\n        return maxsum;",
  "        if (nums.Count == 0) return 0L;\n        long[] numbers = nums.ToArray();\n\
    \        Array.Sort(numbers);\n        long[] left = new long[numbers.Length];\n\
    \        long[] right = new long[numbers.Length];\n        for (int i = 0; i <\
    \ numbers.Length; i++) {\n            left[i] = numbers[i];\n            right[i]\
    \ = numbers[i];\n        }\n        bool leftChanged = false;\n        bool rightChanged\
    \ = false;\n        int leftStartIndex = 0;\n        int rightStartIndex = 0;\n\
    \        while (leftStartIndex < left.Length - 1) {\n            if (left[leftStartIndex]\
    \ + left[leftStartIndex + 1] < left[leftStartIndex + 1]) {\n                left[leftStartIndex\
    \ + 1] = left[leftStartIndex] + left[leftStartIndex + 1];\n                leftChanged\
    \ = true;\n            }\n            leftStartIndex++;\n        }\n        while\
    \ (rightStartIndex < right.Length - 1) {\n            if (right[rightStartIndex]\
    \ + right[rightStartIndex + 1] < right[rightStartIndex + 1]) {\n             \
    \   right[rightStartIndex + 1] = right[rightStartIndex] + right[rightStartIndex\
    \ + 1];\n                rightChanged = true;\n            }\n            rightStartIndex++;\n\
    \        }\n        while (leftStartIndex < left.Length - 1) {\n            if\
    \ (left[leftStartIndex] + left[leftStartIndex + 1] < right[rightStartIndex + 1])\
    \ {\n                left[leftStartIndex + 1] = right[rightStartIndex + 1];\n\
    \                leftChanged = true;\n            }\n            leftStartIndex++;\n\
    \            rightStartIndex++;\n        }\n        while (rightStartIndex < right.Length\
    \ - 1) {\n            if (right[rightStartIndex] + right[rightStartIndex + 1]\
    \ < left[leftStartIndex + 1]) {\n                right[rightStartIndex + 1] =\
    \ left[leftStartIndex + 1];\n                rightChanged = true;\n          \
    \  }\n            leftStartIndex++;\n            rightStartIndex++;\n        }\n\
    \        while (leftStartIndex < left.Length - 1) {\n            if (left[leftStartIndex]\
    \ + left[leftStartIndex + 1] < right[rightStartIndex + 1]) {\n               \
    \ left[leftStartIndex + 1] = right[rightStartIndex + 1];\n                leftChanged\
    \ = true;\n            }\n            leftStartIndex++;\n            rightStartIndex++;\n\
    \        }\n        while (rightStartIndex < right.Length - 1) {\n           \
    \ if (right[rightStartIndex] + right[rightStartIndex + 1] < left[leftStartIndex\
    \ + 1]) {\n                right[rightStartIndex + 1] = left[leftStartIndex +\
    \ 1];\n                rightChanged = true;\n            }\n            leftStartIndex++;\n\
    \            rightStartIndex++;\n        }\n        if (left", "        if (nums.Count\
    \ == 0) return 0;\n        long[] arr = nums.ToArray();\n        long[] arr1 =\
    \ new long[arr.Length];\n        long max = int.MaxValue;\n        int maxIdx\
    \ = 0;\n        for (int i = 0; i < arr.Length; i++) {\n            if (arr[i]\
    \ > max) {\n                maxIdx = i;\n                max = arr[i];\n     \
    \       }\n        }\n        long[] arr2 = nums.Take(maxIdx).ToArray();\n   \
    \     for (int i = 0; i < arr2.Length; i++) {\n            arr1[i] = arr2[i];\n\
    \        }\n        long sum = 0;\n        for (int i = 0; i < arr.Length; i++)\
    \ {\n            arr1[i] = arr[i] - max;\n            sum += arr1[i];\n      \
    \  }\n        return sum;", "        List<long> subnums = new List<long>();\n\
    \        long maxsum = nums.Sum();\n        for (int i = 0; i < nums.Count; i++)\
    \ {\n            long sum = 0;\n            for (int j = i; j < nums.Count; j++)\
    \ {\n                sum += nums[j];\n                if (sum > maxsum) {\n  \
    \                  maxsum = sum;\n                }\n                subnums.Add(sum);\n\
    \            }\n        }\n        long result = subnums.Sum();\n        if (result\
    \ > maxsum) {\n            return maxsum;\n        }\n        return result;",
  "        if (nums.Count == 0)\n            return 0;\n        if (nums.Count ==\
    \ 1)\n            return nums.First();\n        long[] tmp = new long[nums.Count];\n\
    \        int minsum = nums.Sum();\n        for (int i = 0; i < nums.Count; i++)\n\
    \            tmp[i] = nums[i];\n        // find minimum sum of non-empty sub-array\
    \ in tmp\n        for (int i = 0; i < tmp.Length; i++) {\n            int count\
    \ = 0;\n            int left = 0;\n            int right = tmp.Length - 1;\n \
    \           while (left < right) {\n                int mid = (left + right) /\
    \ 2;\n                if (tmp[mid] < tmp[count])\n                    left = mid\
    \ + 1;\n                else\n                    right = mid;\n            }\n\
    \            if (left == right)\n                minsum = tmp[count];\n      \
    \  }\n        return minsum;", "        // sort by value, then index\n       \
    \ nums.Sort();\n        List<long> sorted = nums.OrderBy(x => x).ToList();\n \
    \       int total = 0;\n        foreach (var item in sorted) {\n            if\
    \ (item > 0)\n                total += item;\n            else\n             \
    \   total -= item;\n        }\n        if (nums.Count != sorted.Count)\n     \
    \       return -1L;\n        return total;", "        long minSum = 0;\n     \
    \   int i = 0;\n        int len = 0;\n        for (int j = 0; i < nums.Count;\
    \ j = i + 1) {\n            if (nums[j] == nums[i]) {\n                len++;\n\
    \            }\n            if (len > 0) {\n                minSum = nums.Sum()\
    \ - (ulong)((ulong)len - 1);\n                i = j;\n            }\n        }\n\
    \        return minSum;", "        long minsum = nums[0];\n        for (int i\
    \ = 0; i < nums.Count; i++) {\n            if (nums[i] > 0) {\n              \
    \  int count = 0;\n                for (int j = i; j < nums.Count; j++)\n    \
    \                if (nums[j] == nums[i]) count++;\n                if (count >\
    \ 0)\n                    minsum = Minsubarraysum(nums, i + 1, count);\n     \
    \       }\n        }\n        return minsum;", "        long numsSum = nums.Sum();\n\
    \        if (numsSum < 0)\n            throw new ArgumentException(\"The input\
    \ list must contain only positive integers.\", \"nums\");\n        var array =\
    \ nums.ToArray();\n        var N = array.Length;\n        var maxLength = nums.Max(n\
    \ => n.Length);\n        if (maxLength < N) throw new ArgumentException(\"The\
    \ input list must contain at least one item.\", \"nums\");\n        long[] array\
    \ = array.Take(maxLength).ToArray();\n        long[] answer = new long[N];\n \
    \       long[] sum = new long[N];\n        long[] sum2 = new long[N];\n      \
    \  long[] sum3 = new long[N];\n        long[] sum4 = new long[N];\n        long\
    \ maxSum = numsSum;\n        for (int i = 0; i < N; i++) {\n            sum[i]\
    \ = array[i];\n            sum2[i] = array[i] * array[i];\n            sum3[i]\
    \ = array[i] * array[i] * array[i];\n            sum4[i] = array[i] * array[i]\
    \ * array[i] * array[i];\n        }\n        sum[0] = maxSum;\n        sum2[0]\
    \ = maxSum * maxSum;\n        sum3[0] = maxSum * maxSum * maxSum;\n        sum4[0]\
    \ = maxSum * maxSum * maxSum * maxSum;\n        int j = 0;\n        bool isDivided\
    \ = false;\n        while (j < N) {\n            while (sum[j] <= maxSum) {\n\
    \                if (sum[j] == 0) {\n                    isDivided = true;\n \
    \                   sum2[j] = sum3[j] = 0;\n                    sum4[j] = sum2[j]\
    \ * sum2[j];\n                    break;\n                }\n                sum2[j]\
    \ = sum2[j] * sum2[j];\n                sum3[j] = sum3[j] * sum3[j];\n       \
    \         sum4[j] = sum4[j] * sum4[j];\n                j++;\n            }\n\
    \            if (isDivided) break;\n            j++;\n        }\n        int minSum\
    \ = 0;\n        int minSum2 = 1;\n        int minSum3 = 1;\n        int minSum4\
    \ = 1;\n        if (sum2[j] == 0) {\n            minSum = 0;\n            minSum2\
    \ = 0;\n            minSum3 = 1;\n            minSum4 = 0;\n        } else {\n\
    \            double tempSum = sum2[j] / sum2[j];\n            if (tempSum < minSum2)\
    \ {\n                minSum2 = tempSum;\n            }\n            tempSum =\
    \ sum3[j] / sum3[j];\n            if (tempSum < minSum3) {\n                minSum3\
    \ = tempSum;\n            }\n            tempSum = sum4[j] / sum4[j];\n      \
    \      if (tempSum < minSum4) {\n                ", "        if (nums.Count <\
    \ 1 || nums.Any(n => n == 0)) {\n            return nums.Single();\n        }\n\
    \        var lower = nums.Take(nums.Count / 2).OrderBy(n => n).ToList();\n   \
    \     var higher = nums.Skip(nums.Count / 2).OrderByDescending(n => n).ToList();\n\
    \        var sum = lower.Concat(higher).Sum();\n        return Math.Abs(sum);",
  "        long min = long.MaxValue, max = 0;\n        int leftIndex = 0, rightIndex\
    \ = 0;\n        while(true) {\n            long left = nums[leftIndex++];\n  \
    \          long right = nums[rightIndex++];\n            max = Math.Max(max, left\
    \ + right);\n            if(min == long.MaxValue || max == long.MinValue)\n  \
    \              break;\n            min = Math.Min(min, left + right);\n      \
    \  }\n        return min;", "        // Find the minimum sum of any non-empty\
    \ sub-list of nums.\n        // Let min_sum = 0 be the minimum sum of any non-empty\
    \ sub-list of nums.\n        // Let index = 0 be the index at which nums starts.\n\
    \        // For each index from index to nums.Count, increment min_sum by the\
    \ value of\n        // nums[index] minus the minimum of nums[:index]\n       \
    \ long min_sum = 0L;\n        long index = 0L;\n        foreach (long num in nums)\
    \ {\n            if (index != 0) {\n                min_sum = num - nums[index\
    \ - 1];\n            }\n            if (index == nums.Count) {\n             \
    \   break;\n            }\n            index ++;\n        }\n        return min_sum;",
  "        long min = long.MaxValue;\n        long[] sums = new long[nums.Count];\n\
    \        foreach (long x in nums) {\n            for (int i = 0; i < nums.Count;\
    \ i++) {\n                if (i != x) {\n                    sums[i] += x;\n \
    \                   if (sums[i] < min) min = sums[i];\n                }\n   \
    \         }\n        }\n        return min;", "        // Find all the unique\
    \ sums\n        List<long> sums = nums.GroupBy(i => i).Select(i => i.Sum()).ToList();\n\
    \        if (sums.Count <= 1)\n            return sums[0];\n        // Find all\
    \ possible sums of elements from sums and add them up\n        List<long> subsums\
    \ = Enumerable.Range(0, sums.Count - 1).Select(i => (sums[i] + sums[i + 1]) /\
    \ 2).ToList();\n        // Find the minimum sum among subsums\n        long min\
    \ = subsums.Min();\n        // Get the indices of the elements that are in subsums\n\
    \        List<int> subsumsIndices = subsums.Where(x => x == min).Select(i => i).ToList();\n\
    \        // Find the sum of the left and right sub-sums (excluding min)\n    \
    \    long leftSum = subsums[subsumsIndices[0] - 1];\n        long rightSum = subsums[subsumsIndices[subsumsIndices.Count\
    \ - 1]];\n        // Return min plus the sum of the left and right sub-sums\n\
    \        return sums.Where(i => i == min).Sum() + leftSum + rightSum;", '        return
    Minsubarraysum(nums, 0, nums.Count - 1, 0);', "        if (nums == null || nums.Count\
    \ == 0)\n            return -1L;\n        var a = nums.ToArray();\n        long\
    \ m = a[0];\n        int i = 0;\n        int j = 0;\n        long sum = 0;\n \
    \       bool found = false;\n        do {\n            sum = 0;\n            while\
    \ (j < i && !found) {\n                sum += a[j];\n                if (sum >=\
    \ m) {\n                    m = sum;\n                    found = true;\n    \
    \            }\n                j++;\n            }\n            if (sum >= m)\
    \ {\n                found = true;\n                i++;\n            } else {\n\
    \                j++;\n            }\n        } while (!found);\n        return\
    \ m;", "        long minsum = 0, sum = 0;\n        int i = 0, k = 0;\n       \
    \ for (; i < nums.Count - 1; i++) {\n            sum = 0;\n            for (;\
    \ k < nums.Count - i; k++) {\n                sum += nums[k];\n            }\n\
    \            if (sum < minsum) {\n                minsum = sum;\n            }\n\
    \        }\n        return minsum;", "        Debug.Assert(nums != null);\n  \
    \      if (nums.Count == 0) return 0;\n        if (nums.Count == 1) return nums.First();\n\
    \        int minsum = nums.First();\n        long minsubarraysum = 0;\n      \
    \  HashSet<long> set = new HashSet<long>(nums);\n        Debug.Assert(nums.Count\
    \ == set.Count);\n        do {\n            Debug.Assert(set.Count > 0);\n   \
    \         long sum = set.Sum();\n            if (sum < minsum) {\n           \
    \     minsum = sum;\n                minsubarraysum = sum;\n            } else\
    \ if (sum == minsum) {\n                minsubarraysum += sum;\n            }\n\
    \            set.Remove(sum);\n        } while (set.Count > 0);\n        return\
    \ minsubarraysum;", "        List<long> nums2 = new List<long>();\n        //\
    \ We start with the smallest number possible (zero) and increment the \n     \
    \   // sum by the largest number possible (max).\n        // We also keep track\
    \ of the largest number we could possibly see so \n        // that when we increment\
    \ by that largest number we can't get back down to zero.\n        long sum = 0,\
    \ max = nums.Sum(n => (long)n) - 1;\n        for (int i = 0; i < nums.Count; i++)\
    \ {\n            nums2.Add(nums[i]);\n            if (nums2.Sum(n => (long)n)\
    \ > max) {\n                sum = 0;\n                max = Math.Max(max, nums2.Sum(n\
    \ => (long)n));\n            }\n            sum += nums2.Sum(n => (long)n);\n\
    \            nums2.RemoveAt(0);\n        }\n        return sum;", "        if\
    \ (nums == null) {\n            return 0;\n        }\n        if (nums.Count <\
    \ 2) {\n            return nums.Min();\n        }\n        long[] ints = new long[nums.Count];\n\
    \        for (int i = 0; i < nums.Count; i++) {\n            ints[i] = nums[i];\n\
    \        }\n        Array.Sort(ints);\n        long leftSum = Minsubarraysum(ints,\
    \ 0, ints.Length - 1);\n        long rightSum = Minsubarraysum(ints, 0, ints.Length\
    \ - 1);\n        int min = leftSum;\n        if (rightSum < leftSum) {\n     \
    \       min = -rightSum;\n        }\n        return min;", "        long min =\
    \ int.MaxValue;\n        long max = 0;\n        long sum = 0;\n        bool first\
    \ = true;\n        foreach (var item in nums) {\n            if (first) {\n  \
    \              min = item;\n                first = false;\n                max\
    \ = item;\n                sum = item;\n                continue;\n          \
    \  }\n            if (item > max) {\n                max = item;\n           \
    \ }\n            if (item < min) {\n                min = item;\n            }\n\
    \            sum += item;\n        }\n        long n = nums.Count;\n        while\
    \ (n > 1) {\n            n /= 2;\n            sum += nums[n];\n        }\n   \
    \     return Math.Min(sum, max - min);", "        if (nums == null || nums.Count\
    \ < 1) return 0;\n\n        long sum = 0;\n\n        List<long> numsCopy = new\
    \ List<long>(nums);\n        numsCopy.Remove(numsCopy[0]);\n\n        for (int\
    \ i = 0; i < nums.Count; i++)\n        {\n            long num = nums[i];\n\n\
    \            if (num > 0)\n            {\n                sum += num;\n      \
    \          numsCopy.Remove(num);\n            }\n            else\n          \
    \  {\n                if (numsCopy.Count > 0)\n                {\n           \
    \         sum += numsCopy[0];\n                    numsCopy.Remove(0);\n     \
    \           }\n            }\n        }\n\n        return sum;", "        if (nums.Count\
    \ == 0) throw new ArgumentException(\"Must provide at least 1 element\");\n  \
    \      long min = long.MaxValue;\n        long currentmin = long.MaxValue;\n \
    \       bool isSubset = false;\n        foreach (long num in nums) {\n       \
    \     currentmin = Math.Min(currentmin, num + min);\n            min += num;\n\
    \            if (!isSubset && num == currentmin) isSubset = true;\n        }\n\
    \        if (isSubset) return currentmin;\n        foreach (long num in nums)\
    \ {\n            currentmin = Math.Min(currentmin, num - min);\n            min\
    \ -= num;\n            if (num == currentmin) isSubset = true;\n        }\n  \
    \      return currentmin;", "        int n = nums.Count;\n        long min = long.MaxValue;\n\
    \n        for(int i = 0; i < n; i++) {\n            // Find all combinations of\
    \ indices whose sum is minimum\n            int k = 0;\n            int minSum\
    \ = nums.Sum();\n            int minSumIndex = 0;\n            for(int j = i;\
    \ j < n; j++) {\n                long sum = nums[j];\n                k = j -\
    \ i;\n                if(sum < minSum) {\n                    minSum = sum;\n\
    \                    minSumIndex = k;\n                }\n            }\n\n  \
    \          if(minSumIndex == 0) {\n                min = Math.Min(min, (long)nums[i]);\n\
    \            } else {\n                min = Math.Min(min, Minsubarraysum(nums.Take(minSumIndex\
    \ + 1).ToList()));\n            }\n        }\n\n        return min;", "      \
    \  if (nums.Count == 0) return 0L;\n        long sum = nums[0];\n        int n\
    \ = nums.Count;\n        for (int i = 1; i < n; i++) {\n            long tmp =\
    \ sum;\n            sum = SumOfSubarray(nums, i, n - 1);\n            if (sum\
    \ < tmp) return sum;\n        }\n        return sum;", "        if (nums.Count\
    \ == 0)\n            return 0;\n        long numSubarraySum = nums[0];\n     \
    \   long minsubarraysum = 0;\n        long subarraysum = 1;\n        for(int i\
    \ = 1; i < nums.Count; i++) {\n            subarraysum += nums[i];\n         \
    \   if (minsubarraysum < subarraysum)\n                minsubarraysum = subarraysum;\n\
    \            numSubarraySum = numSubarraySum + nums[i];\n        }\n        if\
    \ (minsubarraysum > 0)\n            return minsubarraysum;\n        else\n   \
    \         return -numSubarraySum;", "        var min = long.MaxValue;\n      \
    \  bool isEven = true;\n        var sum = new List<long>();\n        foreach (var\
    \ n in nums.Where(x => x > 0)) {\n            if (isEven) {\n                sum\
    \ += n;\n                if (n < min)\n                    min = n;\n        \
    \    }\n            else\n                sum -= n;\n            isEven = !isEven;\n\
    \        }\n        return min;", "        var max = nums.Max();\n        var\
    \ min = nums.Min();\n        var sum = 0L;\n        var total = 0;\n        var\
    \ sumOfMin;\n        var currentMax;\n        var currentMin;\n        foreach\
    \ (var n in nums) {\n            if (n > max) {\n                currentMax =\
    \ max;\n                currentMin = min;\n                sumOfMin = sum;\n \
    \               max = n;\n                min = n;\n                sum = 0;\n\
    \            } else if (n <= min && n > 0) {\n                sum += n - min;\n\
    \                min = n;\n            } else {\n                sumOfMin += sum;\n\
    \                sum += max - min;\n                max = n;\n               \
    \ min = n;\n                sum = 0;\n            }\n            if (sumOfMin\
    \ > total) {\n                total = sumOfMin;\n            }\n        }\n  \
    \      return total;", "        Debug.Assert(nums.Count > 0);\n\n        var sums\
    \ = new int[nums.Count];\n\n        sums[0] = nums[0];\n        for (var i = 1;\
    \ i < nums.Count; ++i) {\n            var j = i;\n            while (j > 0 &&\
    \ nums[j - 1] == nums[j]) {\n                j -= 1;\n            }\n        \
    \    sums[i] = sums[i - 1] + nums[j];\n        }\n        // We found a sub-array\
    \ that is the same size as the entire array. That\n        // means we found the\
    \ smallest sum of any possible sub-array\n        return sums.Min();", "     \
    \   long min = nums.Sum();\n        int start = 0;\n        long sum = 0;\n  \
    \      bool change = true;\n        while (change == true) {\n            change\
    \ = false;\n            sum = sum + nums[start];\n            start++;\n     \
    \       while (start < nums.Count && nums[start] == sum) {\n                start++;\n\
    \            }\n            if (start == nums.Count) {\n                change\
    \ = true;\n            }\n        }\n        return sum;", "        long s = nums.First();\n\
    \        long result = 0;\n        List<long> used = new List<long>();\n\n   \
    \     // Find all sublists in nums, including those containing only a single element\n\
    \        // We use .Where() to iterate over the lists lazily.\n        foreach\
    \ (var sublist in nums.Where(x => x > 0 && used.Contains(x) == false)) {\n   \
    \         used.Add(sublist);\n\n            foreach (var val in sublist.Where(x\
    \ => x > 0 && used.Contains(x) == false)) {\n                used.Add(val);\n\
    \                result += val;\n            }\n        }\n\n        // There\
    \ was at least one sublist. Return its sum.\n        if (used.Count != 0) {\n\
    \            result = used[used.Count - 1];\n        }\n\n        return result;",
  "        long sum = 0;\n        long min = long.MaxValue;\n        foreach (long\
    \ num in nums)\n            sum += num;\n\n        foreach (long num in nums)\n\
    \            min = Math.Min(min, num - sum);\n        return min;", "        long\
    \ sum = 0;\n        long min = Long.MaxValue;\n\n        foreach (long num in\
    \ nums)\n            sum += num;\n\n        if (sum < 0)\n            return 0;\n\
    \n        sum += nums.Sum();\n\n        foreach (long num in nums)\n        {\n\
    \            if (num < min)\n            {\n                min = num;\n     \
    \       }\n\n            sum += num;\n        }\n\n        return sum;", "   \
    \     Debug.Assert(nums.Any());\n        long minval = nums[0];\n        long\
    \ maxval = nums[0];\n        long sum = 0;\n        // Find all ranges that contain\
    \ the minimum or maximum value\n        foreach (long val in nums) {\n       \
    \     if (val < minval)\n                minval = val;\n            if (val >\
    \ maxval)\n                maxval = val;\n            // Find the sum of any non-zero\
    \ sub-array of nums containing val\n            long rangesum = 0;\n         \
    \   int len = Math.Max(0, (int)(maxval - minval));\n            while (len > 0)\
    \ {\n                // Find the sub-array of nums containing val, with a length\
    \ len\n                List<long> sublist = nums.Where((val2) => val2 < val).Take(len).ToList();\n\
    \                sum += range.Sum(sublist);\n                len -= sublist.Count;\n\
    \            }\n        }\n        return minval > 0 ? sum : -sum;", "       \
    \ // Find a contiguous segment in the array that has at least a non-zero value.\n\
    \        List<long> firstNonZero = new List<long>();\n        for (int i = 0;\
    \ i < nums.Count; i++) {\n            if (nums[i] != 0) {\n                firstNonZero.Add(nums[i]);\n\
    \                if (firstNonZero.Count == 2) {\n                    break;\n\
    \                }\n            }\n        }\n        long startIndex = firstNonZero.Count\
    \ - 1;\n        long endIndex = 0;\n        long sum = 0;\n        while (true)\
    \ {\n            if (startIndex == 0) {\n                startIndex = 1;\n   \
    \         }\n            if (endIndex == firstNonZero.Count - 1) {\n         \
    \       endIndex = firstNonZero.Count;\n            }\n            long left =\
    \ nums[startIndex - 1];\n            long right = nums[endIndex];\n          \
    \  long middle = (left + right) / 2;\n            if (left > right) {\n      \
    \          sum = left + right;\n                break;\n            }\n      \
    \      if (nums[startIndex] < middle && nums[endIndex] > middle) {\n         \
    \       sum = nums[startIndex];\n                startIndex--;\n            }\
    \ else {\n                sum = nums[endIndex];\n                endIndex++;\n\
    \            }\n        }\n        return sum;", "        if (nums.Count < 2)\
    \ return nums[0];\n        long[] a = nums.ToArray();\n        long[] c = new\
    \ long[a.Length];\n        long[] d = new long[a.Length];\n        long[] e =\
    \ new long[a.Length];\n        long ans = 0, last = 0;\n        long sum = 0;\n\
    \        int start = 0;\n        for (int i = 1; i < a.Length; i++) {\n      \
    \      sum += a[i];\n            if (sum < a[0]) {\n                sum = a[0];\n\
    \                start = i;\n            }\n        }\n        sum -= a[start];\n\
    \        bool first = true;\n        for (int i = start + 1; i < a.Length; i++)\
    \ {\n            if (sum < a[i]) {\n                sum = a[i];\n            \
    \    start = i;\n            }\n        }\n        sum = sum - a[start];\n   \
    \     for (int i = start; i < a.Length; i++) {\n            c[i] = sum;\n    \
    \        d[i] = sum;\n            e[i] = 0;\n        }\n        for (int i = 0;\
    \ i <= a.Length; i++) {\n            ans = Math.Min(ans, c[i] + d[i]);\n     \
    \       last = Math.Max(last, sum);\n            sum -= c[i];\n            if\
    \ (sum < d[i]) {\n                sum = d[i];\n            }\n            c[i]\
    \ = sum;\n            d[i] = sum;\n            sum += a[i];\n            e[i]\
    \ = 0;\n        }\n        return last + ans;", "        if (nums.Count == 0)\
    \ return 0L;\n        long smallest = nums[0].GetHashCode();\n        long smallestSum\
    \ = nums[0].GetHashCode();\n        bool minSumReached = false;\n        bool\
    \ currentSublistEmpty = true;\n        for (int i = 1; i < nums.Count; i++) {\n\
    \            int smallestSumReachable = smallestSum - nums[i].GetHashCode();\n\
    \            if (!minSumReached && smallestSumReachable < 0 && nums[i - 1] < nums[i])\
    \ {\n                minSumReached = true;\n                smallestSumReachable\
    \ = -1;\n            }\n            if (minSumReached && nums[i - 1] == nums[i])\
    \ break;\n            if (smallestSumReachable >= 0) {\n                if (nums[i\
    \ - 1] < nums[i] && !currentSublistEmpty) {\n                    smallestSumReachable\
    \ = -1;\n                    currentSublistEmpty = true;\n                } else\
    \ {\n                    currentSublistEmpty = false;\n                }\n   \
    \         }\n            if (smallestSumReachable >= 0) {\n                smallest\
    \ = nums[i].GetHashCode();\n                smallestSum = smallestSumReachable;\n\
    \            }\n        }\n        return smallest == nums[0].GetHashCode() ?\
    \ nums[0].GetHashCode() : smallestSum;", "        int n = nums.Count;\n      \
    \  if (n == 0)\n            return 0L;\n        long[] a = new long[n];\n    \
    \    Arrays.Fill(a, 0L);\n        long[] v = new long[n];\n        for (int i\
    \ = 0; i < n; i++)\n            a[i] = nums[i];\n        for (int i = n - 2; i\
    \ >= 0; i--)\n            v[i] = a[i] + v[i + 1];\n        for (int i = 0; i <\
    \ n; i++)\n            if (v[i] < 0)\n                v[i] = 0L;\n        return\
    \ a[0] + v[0];", "        long result = 0;\n        long sum = 0;\n        foreach(long\
    \ i in nums) {\n            sum = sum + i;\n            if (sum >= 0) {\n    \
    \            result = Math.Min(result, sum);\n            }\n        }\n     \
    \   return result;", "        if (nums.Count < 2) {\n            return nums.Sum();\n\
    \        }\n        long min = nums[0];\n        long max = nums[0];\n       \
    \ long sum = 0;\n        foreach (var i in nums) {\n            sum += i;\n  \
    \          max = Math.Max(max, i);\n            min = Math.Min(min, i);\n    \
    \    }\n        long minSum = sum - min + max;\n        for (int i = 1; i < nums.Count;\
    \ i++) {\n            sum += nums[i];\n            min = Math.Min(min, nums[i]);\n\
    \            max = Math.Max(max, nums[i]);\n            minSum = Math.Min(minSum,\
    \ sum - min + max);\n        }\n        return minSum;", "        long sum = 0;\n\
    \        int n = nums.Count;\n        long prev = -9223372036854775807;\n    \
    \    for(int i=0;i<n;i++) {\n            sum += nums[i];\n            prev = prev>0?\
    \ Math.Min(prev, sum) : sum;\n        }\n        return prev;", "        var sum\
    \ = new List<long>();\n        sum.Add(nums.Min());\n        int count = nums.Count;\n\
    \        while(count > 1) {\n            int i = count / 2;\n            long\
    \ max = sum[i];\n            int j = (int)Math.Log10(count) + 1;\n           \
    \ if(j > i) {\n                j = i;\n            }\n            long newsum;\n\
    \            while(true) {\n                long mid = sum[i] - max;\n       \
    \         sum += new List<long>(new long[]{mid});\n                newsum = (long)((sum[j]\
    \ - mid) / j);\n                if(newsum < max) {\n                    max =\
    \ newsum;\n                }\n                j = (int)Math.Log10(j) + 1;\n  \
    \              if(j > i) {\n                    j = i;\n                }\n  \
    \              if(count - j >= 1) {\n                    sum += new List<long>(new\
    \ long[]{sum[i]});\n                    break;\n                }\n          \
    \  }\n            sum.Add(max);\n            count -= j;\n        }\n        sum.Add(nums.Min());\n\
    \        return sum.Min();", "        long minSum = 0L;\n        long minIndex\
    \ = -1L;\n        long prevSum = 0L;\n        long currentSum = 0L;\n        bool\
    \ isFirst = true;\n        bool isNext = true;\n        for (int i = 0; i < nums.Count\
    \ - 1; ++i) {\n            isNext = true;\n            currentSum = 0L;\n    \
    \        long curr = nums[i];\n            isFirst = true;\n            for (int\
    \ j = i + 1; j < nums.Count; ++j) {\n                if (isFirst) {\n        \
    \            isFirst = false;\n                    currentSum += curr;\n     \
    \           }\n                else {\n                    isNext = true;\n  \
    \                  isFirst = false;\n                }\n                if (j\
    \ - i > 1) {\n                    currentSum += nums[j] - nums[i];\n         \
    \       }\n            }\n            if (currentSum < prevSum) {\n          \
    \      minSum = currentSum;\n                minIndex = i;\n                prevSum\
    \ = currentSum;\n            }\n        }\n        return (minSum < 0 ? -minSum\
    \ : minIndex);", "        long sum = 0;\n        long[] array = new long[nums.Count];\n\
    \        int n = nums.Count;\n        for (int i = 0; i < n; i++) {\n        \
    \    array[i] = nums[i];\n        }\n        for (int i = n; n > 0; i--) {\n \
    \           long k = nums[n - 1];\n            for (int j = i; j < n; j++) {\n\
    \                sum -= array[j];\n                sum += k;\n            }\n\
    \            n = i;\n        }\n        return sum;", "        if (nums == null\
    \ || nums.Count == 0)\n            return 0;\n        long sum = nums[0];\n  \
    \      long minsum = sum;\n        for (int i = 0; i < nums.Count - 1; i++)\n\
    \        {\n            if (nums[i + 1] - nums[i] <= minsum)\n               \
    \ minsum = nums[i + 1] - nums[i];\n        }\n        sum -= minsum;\n       \
    \ return sum;", "        long[] numsarray = nums.ToArray();\n        if (numsarray.Length\
    \ == 0)\n            return 0;\n\n        var numssubarray = numsarray[0];\n \
    \       var minsubarraysum = numsarray[0];\n        var minsubarraysumindex =\
    \ 0;\n        var minsubarraysumleft = 0;\n        var minsubarraysumright = 0;\n\
    \        var totalsum = 0;\n        for (var i = 1; i < numsarray.Length; i++)\
    \ {\n            if (numssubarray > numsarray[i]) {\n                numssubarray\
    \ = numsarray[i];\n                var j = 0;\n                for (var k = i;\
    \ k < numsarray.Length; k++) {\n                    if (numsarray[k] < numssubarray)\
    \ {\n                        numssubarray = numsarray[k];\n                  \
    \      minsubarraysumright = minsubarraysum + numssubarray;\n                \
    \        j++;\n                    }\n                }\n                minsubarraysum\
    \ = minsubarraysumright - numssubarray;\n                minsubarraysumindex =\
    \ i;\n                minsubarraysumleft = minsubarraysum + numsarray[i];\n  \
    \              totalsum = totalsum + minsubarraysum;\n                for (var\
    \ k = i + 1; k < numsarray.Length; k++) {\n                    if (numsarray[k]\
    \ < minsubarraysumleft) {\n                        minsubarraysumleft = numsarray[k];\n\
    \                        minsubarraysumright = minsubarraysum - minsubarraysumleft;\n\
    \                        j++;\n                    }\n                }\n    \
    \            minsubarraysum = minsubarraysumright - minsubarraysumleft;\n    \
    \        }\n        }\n        return totalsum;", "        long result = 0;\n\
    \        int leftIndex = 0;\n        int rightIndex = 0;\n        while (rightIndex\
    \ < nums.Count - 1) {\n            if (nums[leftIndex] < nums[rightIndex]) {\n\
    \                long leftSubArray = nums.GetRange(leftIndex, nums.Count - leftIndex\
    \ + 1);\n                leftIndex++;\n                result += leftSubArray.Sum();\n\
    \            }\n            else {\n                long rightSubArray = nums.GetRange(rightIndex\
    \ + 1, nums.Count - rightIndex);\n                rightIndex++;\n            \
    \    result += rightSubArray.Sum();\n            }\n        }\n        if (nums[leftIndex]\
    \ < 0) {\n            result -= nums[leftIndex];\n            leftIndex++;\n \
    \       }\n        return result;", "        int n = nums.Count;\n        long\
    \ minsum = 0;\n\n        for (int i = 0; i < n; i++) {\n            long x = nums[i];\n\
    \            if (i + 1 < n)\n                x += nums[i + 1];\n            minsum\
    \ = FindMinSum(x, minsum);\n        }\n        return minsum;", "        long\
    \ minSum = 0, sum = 0;\n        bool lastIsZero = true;\n\n        foreach (var\
    \ x in nums)\n        {\n            if (lastIsZero && x == 0)\n            {\n\
    \                lastIsZero = false;\n                continue;\n            }\n\
    \n            if (lastIsZero)\n            {\n                sum += x;\n    \
    \            continue;\n            }\n\n            sum += x;\n            lastIsZero\
    \ = x != 0;\n            if (sum < minSum)\n            {\n                minSum\
    \ = sum;\n            }\n        }\n\n        return minSum;", "        long answer\
    \ = 0;\n        foreach (long i in nums)\n            answer = Math.Min(answer,\
    \ i);\n        return answer;", "        // Sort the list using a custom comparer\
    \ that just compares the values\n        // of the list items.\n        var comparer\
    \ = new Comparison<long>((x, y) => { return y - x; });\n        nums.Sort((a,\
    \ b) => comparer.Compare(a, b));\n\n        // Set up an accumulator to hold the\
    \ sum of the current sub-list.\n        long sum = 0;\n        long minSum = nums[0];\n\
    \        // Iterate over all items in the list and add them to the sum until\n\
    \        // a non-empty sub-list is found.\n        foreach (long i in nums) {\n\
    \            sum += i;\n            if (sum < minSum) {\n                minSum\
    \ = sum;\n            }\n        }\n\n        // Return the minimum sum.\n   \
    \     return minSum;", "        long min = Long.MaxValue;\n        long sum =\
    \ 0;\n        for (int i = 0; i < nums.Count; i++) {\n            sum -= nums[i];\n\
    \            if (sum < min) {\n                min = sum;\n            }\n   \
    \         sum += nums[i];\n        }\n        return min;", "        List<long>\
    \ numsCopy = nums.ToList();\n        long numsToFind = numsCopy.First();\n   \
    \     long sum = numsCopy.Sum();\n        long count = 0;\n\n        do {\n  \
    \          count++;\n            sum -= numsToFind;\n            numsCopy.Remove(numsToFind);\n\
    \            numsToFind = numsCopy.First();\n        } while (numsToFind > 0);\n\
    \n        return sum;", "        Debug.Assert(nums.Count > 0);\n        if (nums.Count\
    \ == 1) {\n            return nums[0];\n        }\n        \n        var min =\
    \ nums[0];\n        foreach (var n in nums) {\n            if (n >= min)\n   \
    \             min = n;\n        }\n        \n        List<long> subarray = new\
    \ List<long>();\n        var start = 0, end = 0;\n        \n        while (start\
    \ < nums.Count && end < nums.Count) {\n            var mid = start + (end - start)\
    \ / 2;\n            if (nums[mid] < min)\n                end = mid;\n       \
    \     else\n                start = mid;\n        }\n        \n        // We need\
    \ to find the end because there might be a subarray smaller than the minimum we're\
    \ looking for.\n        var end = nums.Count - 1;\n        while (end > start\
    \ && nums[end] == min)\n            end--;\n        \n        // Now find the\
    \ minimum.\n        for (int i = start; i <= end; i++) {\n            if (nums[i]\
    \ == min)\n                return min;\n            else if (nums[i] > min)\n\
    \                min = nums[i];\n        }\n        return min;", "        long\
    \ min = long.MaxValue;\n        long max = long.MinValue;\n        long sum =\
    \ 0;\n        foreach (var item in nums) {\n            sum += item;\n       \
    \     min = Math.Min(min, sum);\n            max = Math.Max(max, sum);\n     \
    \   }\n        return min - max;", "        // find all the sublists with one\
    \ element and no duplicates\n        List<List<long>> groups = nums\n        \
    \    .Where(x => x.Equals(x))\n            .GroupBy(x => x)\n            .Where(g\
    \ => g.Count() == 1)\n            .ToList();\n        if (groups.Count == 0) {\
    \ return 0L; }\n        List<long> list = new List<long>();\n        foreach (var\
    \ g in groups) {\n            foreach (var i in g) {\n                list.Add(i);\n\
    \            }\n        }\n        List<long> allnums = new List<long>();\n  \
    \      foreach (var n in nums) {\n            allnums.Add(n);\n        }\n   \
    \     long minSum = allnums.Min(x => x.CompareTo(minSum));\n        if (minSum\
    \ == -1) { return 0L; }\n        long currentSum = 0L;\n        List<long> solution\
    \ = new List<long>();\n        solution.Add(minSum);\n        solution.Add(0L);\n\
    \        for (int i = 0; i < groups.Count; i++) {\n            List<long> sublist\
    \ = new List<long>();\n            foreach (var num in list) {\n             \
    \   if (num + groups[i].Min() < minSum + currentSum) {\n                    sublist.Add(num);\n\
    \                    currentSum += num;\n                } else if (num + groups[i].Min()\
    \ >= minSum + currentSum) {\n                    break;\n                }\n \
    \           }\n            currentSum -= sublist.Min();\n            foreach (var\
    \ num in sublist) {\n                solution.add(num + groups[i].Min());\n  \
    \          }\n            solution.Add(currentSum);\n        }\n        solution.RemoveAt(solution.Count\
    \ - 1);\n        long answer = solution.Sort(Compare).First();\n        return\
    \ answer;", "        long result = 1L;\n        long maxSum = 1L;\n        for\
    \ (int i = 0; i < nums.Count; ++i) {\n            bool useThisNum = nums.Skip(i).TakeWhile(x\
    \ => x > 0L).TakeWhile(x => x <= maxSum).Any();\n            if (useThisNum) {\n\
    \                long thisSum = FindSum(nums.Skip(i).TakeWhile(x => x > 0).TakeWhile(x\
    \ => x <= maxSum).ToList());\n                if (thisSum > maxSum) {\n      \
    \              result = thisSum;\n                    maxSum = thisSum;\n    \
    \            }\n            }\n        }\n        return result;", "        long[]\
    \ numArr = nums.ToArray();\n        long minSum = nums.Min();\n        long maxSum\
    \ = nums.Max();\n        long sum = 0;\n        int start = 0;\n        int end\
    \ = nums.Count - 1;\n        while (start < end) {\n            sum += numArr[start];\n\
    \            if (sum < minSum) {\n                minSum = sum;\n            }\n\
    \            sum += numArr[end];\n            if (sum > maxSum) {\n          \
    \      maxSum = sum;\n            }\n            start++;\n            end--;\n\
    \        }\n        return (minSum + maxSum);", "        Array.Sort(nums);\n \
    \       int startIndex = 0;\n        int endIndex = nums.Count - 1;\n        while\
    \ (endIndex > startIndex) {\n            int currentSum = nums[startIndex] + nums[endIndex];\n\
    \            if (currentSum < 0)\n                endIndex--;\n            else\n\
    \                startIndex++;\n        }\n        return nums[endIndex];", " \
    \       long smallestSum = long.MinValue;\n        long min = long.MaxValue;\n\
    \        long max = 0;\n        bool found = true;\n        foreach (var item\
    \ in nums) {\n            if (item < min)\n                min = item;\n     \
    \       if (item > max)\n                max = item;\n        }\n        if (min\
    \ == long.MinValue)\n            return long.MinValue;\n        if (max == long.MaxValue)\n\
    \            return long.MaxValue;\n        double delta = (max - min) / (nums.Count\
    \ - 1);\n        double x = 1;\n        double y = 1;\n        double sum = 0;\n\
    \        int count = 0;\n        for (; count++ < nums.Count; count++) {\n   \
    \         sum += nums[count];\n            double z = (sum - min) / delta;\n \
    \           double d = Math.Sqrt(z);\n            if (Math.Abs(d - z) > double.Epsilon)\n\
    \                x = y;\n            else\n                y = z;\n          \
    \  if (x == y)\n                found = false;\n        }\n        smallestSum\
    \ = sum;\n        if (found)\n            return smallestSum;\n        else\n\
    \            return long.MinValue;", "        int n = nums.Count;\n        long\
    \ sum = 0;\n        long minsum = -2;\n\n        for(int i = 0; i < n; i++) {\n\
    \            sum -= nums[i];\n            if (sum < 0) {\n                sum\
    \ = 0;\n            }\n        }\n        sum -= nums.Sum();\n        if (sum\
    \ < 0) {\n            sum = 0;\n        }\n\n        minsum = sum;\n\n       \
    \ for(int i = 0; i < n; i++) {\n            sum += nums[i];\n            if (sum\
    \ > minsum) {\n                minsum = sum;\n            }\n        }\n     \
    \   return minsum;", "        // Add 1 because the first and last elements are\
    \ the minimum and maximum\n        // and each element in the array will have\
    \ a corresponding minimum and\n        // maximum.\n        long min = nums.Min()\
    \ + 1;\n        long max = nums.Max() + 1;\n        long sum = 0;\n        long\
    \ currentSum = 0;\n        // Start by adding the first element\n        sum +=\
    \ nums[0];\n        currentSum += nums[0];\n        // Add the last element\n\
    \        sum += nums[nums.Count - 1];\n        currentSum += nums[nums.Count -\
    \ 1];\n        // Do some calculations\n        // Loop through the array from\
    \ 1 to the length of the list\n        for (int i = 1; i < nums.Count; i++) {\n\
    \            // If the current element is bigger than the previous element, then\
    \ we\n            // need to start over\n            if (nums[i] > max) {\n  \
    \              sum = currentSum;\n                max = nums[i];\n           \
    \ }\n            // If the current element is smaller than the previous element,\
    \ then we\n            // need to keep the current sum\n            if (nums[i]\
    \ < min) {\n                sum += currentSum;\n                min = nums[i];\n\
    \            }\n            // The current element is equal to the previous element\
    \ so we can add\n            // the current sum to the sum\n            sum +=\
    \ currentSum;\n            currentSum += nums[i];\n        }\n        // Return\
    \ the sum at the end\n        return sum;", "        long minsum = 0L;\n     \
    \   bool flag = true;\n        long result = 0;\n        long tempsum = 0L;\n\n\
    \        // find minimum sum\n        long minsum = nums.Sum();\n\n        //\
    \ loop through all elements\n        for (long i = 0; i < nums.Count; i++) {\n\
    \            bool flag = true;\n\n            // find difference of current element\
    \ with minimum element so far\n            for (int j = 0; j < i; j++) {\n   \
    \             if (nums[j] >= minsum) {\n                    tempsum = tempsum\
    \ + nums[j];\n                    flag = false;\n                    break;\n\
    \                }\n            }\n\n            if (flag) {\n               \
    \ result = tempsum;\n            }\n            flag = false;\n            minsum\
    \ = tempsum;\n            tempsum = 0L;\n        }\n\n        // handle remaining\
    \ elements\n        if (minsum != 0) {\n            for (int i = nums.Count -\
    \ 1; i >= 0; i--) {\n                tempsum = tempsum + nums[i];\n          \
    \      if (tempsum == minsum) {\n                    result = tempsum;\n     \
    \               break;\n                }\n            }\n        }\n        return\
    \ result;", "        if (nums == null)\n            throw new ArgumentNullException(nameof(nums));\n\
    \        var max = Math.Min(nums.Max(), nums.Min());\n        if (nums.Count ==\
    \ 0)\n            return 0;\n        var max2 = max;\n        var sum = 0;\n \
    \       var total = 0;\n        for (var j = 0; j < nums.Count - 1; j++)\n   \
    \         total += nums[j];\n        for (var j = 0; j < nums.Count - 1; j++)\
    \ {\n            var start = j;\n            var end = j;\n            for (var\
    \ k = j + 1; k < nums.Count; k++) {\n                total -= nums[k];\n     \
    \           if (total < 0)\n                    total = 0;\n                max2\
    \ = Math.Max(max2, max);\n                max -= nums[k];\n                if\
    \ (max2 < min)\n                    end = k;\n            }\n            var tmp\
    \ = max2;\n            max2 = max;\n            max = tmp;\n            sum =\
    \ Math.Min(sum, total + start);\n        }\n        if (max2 == max)\n       \
    \     throw new ArgumentException(\"Too much negative numbers!\");\n        return\
    \ sum;", "        Debug.Assert(nums.Count >= 1);\n\n        long minSum = 0;\n\
    \n        var subarrays = nums.Where((n) => n != nums[0]).GroupBy(n => (n % 2)\
    \ == 0);\n\n        foreach (var subarray in subarrays) {\n            var sum\
    \ = subarray.Select(n => n).Sum();\n            minSum = Math.Min(minSum, sum);\n\
    \        }\n\n        return minSum;", "        var sums = new List<long>();\n\
    \        var currentsum = 0;\n\n        foreach (var num in nums) {\n        \
    \    if (sums.Count == 0) {\n                currentsum = num;\n            }\
    \ else {\n                currentsum += num;\n                sums.Add(currentsum);\n\
    \            }\n        }\n\n        var minSum = sums.Min();\n\n        // Find\
    \ subarray\n        var index = 0;\n        foreach (var sum in sums) {\n    \
    \        while (sum < minSum) {\n                index++;\n                sum\
    \ -= sums[index];\n            }\n\n            if (sum == minSum) {\n       \
    \         return index - 1;\n            }\n        }\n\n        return 0;", " \
    \       if (nums == null || nums.Count == 0)\n            return 0;\n\n      \
    \  long minSum = nums[0].Value;\n\n        for (int i = 1; i < nums.Count; ++i)\
    \ {\n            long sum = 0;\n\n            for (int j = 0; j < i; ++j) {\n\
    \                sum += nums[j].Value;\n            }\n\n            long newSum\
    \ = sum;\n\n            for (int j = i + 1; j < nums.Count; ++j) {\n         \
    \       sum += nums[j].Value;\n\n                if (sum < newSum) {\n       \
    \             newSum = sum;\n                }\n            }\n\n            if\
    \ (minSum > newSum)\n                minSum = newSum;\n        }\n\n        return\
    \ minSum;", "        long minsum = long.MaxValue;\n        var subList = new List<long>(nums);\n\
    \        long[] subNums = new long[subList.Count];\n        int count = 0;\n\n\
    \        // Find the positions of non-zero elements in subList\n        foreach\
    \ (long l in subList)\n        {\n            if (l != 0)\n            {\n   \
    \             subNums[count++] = l;\n            }\n        }\n\n        if (subList.Count\
    \ != count)\n        {\n            return minsum;\n        }\n\n        // Find\
    \ the minimum sum for sub-array starting at index i\n        int i = 0, j = 0;\n\
    \        long minSum = subNums[0];\n        while (i < subNums.Length && j < count)\n\
    \        {\n            long sum = subNums[i] - subNums[j];\n            minSum\
    \ = (sum < minSum) ? sum : minSum;\n            i++;\n            j++;\n     \
    \   }\n\n        minsum = minSum;\n        return minsum;", "        long result\
    \ = nums[0];\n        for (int i = 1; i < nums.Count; i++) {\n            long\
    \ nextsum = nums[i];\n            long cursum = 0;\n            for (int j = 0;\
    \ j < i; j++) {\n                cursum += nums[j];\n                nextsum -=\
    \ nums[j];\n                if (nextsum < cursum) {\n                    result\
    \ = nextsum;\n                    break;\n                }\n            }\n \
    \       }\n        return result;", "        if (nums == null || nums.Count ==\
    \ 0)\n            throw new ArgumentException(\"nums may not be empty\", \"nums\"\
    );\n        // Convert to an array\n        var arr = nums.ToArray();\n      \
    \  // Get the length of the array\n        var len = arr.Length;\n        if (len\
    \ == 0)\n            return 0;\n        // If the array is all positive, just\
    \ return 0\n        if (arr.Max() == 0)\n            return 0;\n        var sum\
    \ = 0;\n        // We need the last element of the array to be the sum\n     \
    \   var lastNum = arr[0];\n        for (int i = 0; i < len - 1; i++) {\n     \
    \       sum += lastNum;\n            lastNum = arr[i + 1];\n        }\n      \
    \  // If the last element of the array was all positive, just return 0\n     \
    \   if (lastNum > 0)\n            return 0;\n        // If the last element of\
    \ the array was all negative, just return the\n        // sum of the array\n \
    \       if (lastNum < 0)\n            return sum;\n        // If the last element\
    \ of the array was positive, the sum of the array\n        // is negative.\n \
    \       return -sum;", "        long minSum = nums.First();\n        long subSum\
    \ = 0;\n        long tempSum = nums.First();\n        foreach (long num in nums.Skip(1))\n\
    \        {\n            subSum += tempSum;\n            tempSum = num;\n     \
    \       if (subSum < minSum)\n            {\n                minSum = subSum;\n\
    \            }\n        }\n        return minSum;", "        long answer = nums.Min();\n\
    \        for(int i=1; i<nums.Count; i++) {\n            answer += nums[i];\n \
    \       }\n        return answer;", "        long total = 0L;\n        foreach\
    \ (long num in nums) {\n            if (num > 0L) {\n                total +=\
    \ num;\n                List<long> remaining = new List<long>(nums.Where(num =>\
    \ num > 0L));\n                long subtotal = Minsubarraysum(remaining);\n  \
    \              if (subtotal < total) {\n                    return subtotal;\n\
    \                }\n            }\n        }\n        return total;", "      \
    \  if (nums.Count == 0)\n            return 0L;\n        List<long> minsum = new\
    \ List<long>();\n        int currentmin = nums[0];\n        for (int i = 1; i\
    \ < nums.Count; i++)\n        {\n            if (nums[i] + currentmin > nums[i\
    \ - 1])\n            {\n                currentmin = nums[i];\n            }\n\
    \            else\n            {\n                currentmin = nums[i - 1];\n\
    \            }\n            minsum.Add(currentmin);\n        }\n        return\
    \ minsum.Min();", "        long minSum = long.MaxValue;\n        int length =\
    \ nums.Count;\n        if (length == 0) {\n            return minSum;\n      \
    \  }\n        if (length == 1) {\n            minSum = nums[0];\n            return\
    \ minSum;\n        }\n        List<long> subList = new List<long>(nums.Where((x,\
    \ i) => i < length / 2));\n        long subMinSum = Minsubarraysum(subList);\n\
    \        long current = nums[length - 1];\n        bool add = false;\n       \
    \ for (int i = length - 2; i >= 0; i--) {\n            long sum = current - nums[i];\n\
    \            current = sum;\n            if (add) {\n                sum -= subMinSum;\n\
    \            }\n            if (sum < minSum) {\n                minSum = sum;\n\
    \            }\n            add = current;\n        }\n        return minSum;",
  "        if (nums == null)\n            return 0;\n        if (nums.Count <= 0)\n\
    \            return 0;\n        long minsum = nums.Min();\n        long maxsum\
    \ = nums.Max();\n        for (int i = 0; i < nums.Count - 1; i++)\n        {\n\
    \            long lsum = nums[i];\n            long rsum = nums[i + 1];\n    \
    \        long diff = lsum - rsum;\n            if (minsum > diff)\n          \
    \      minsum = diff;\n        }\n        return minsum;", "        if (nums.Count\
    \ == 0) return 0L;\n        long minSum = 0;\n        foreach (var num in nums)\
    \ {\n            minSum = Math.Min(minSum, Sum(num, nums));\n        }\n     \
    \   return minSum;", "        long sum;\n        long low = 0;\n        long high\
    \ = nums.Count - 1;\n        bool found = false;\n        while (low < high) {\n\
    \            found = false ;\n            sum = 0;\n            for (long i =\
    \ low; i <= high; i++) {\n                sum = sum + nums[i];\n             \
    \   if (sum < low) {\n                    low = sum;\n                }\n    \
    \            else if (sum > high) {\n                    high = sum;\n       \
    \         }\n                else {\n                    found = true;\n     \
    \               break;\n                }\n            }\n            if (!found)\
    \ {\n                return -1;\n            }\n        }\n        return low;",
  "        var minSum = nums.Min();\n        var minIndex = nums.IndexOf(minSum);\n\
    \        if (minIndex == -1) return minSum;\n\n        var subArraySums = new\
    \ List<long>();\n\n        for (int i = minIndex; i < nums.Count; i++) {\n   \
    \         var currentSum = nums[i] + minSum;\n            if (subArraySums.Count()\
    \ == 0 || currentSum <= subArraySums.Last()) {\n                subArraySums.Add(currentSum);\n\
    \            }\n            else {\n                var lastElement = subArraySums.Last();\n\
    \                if (currentSum - lastElement > minSum) {\n                  \
    \  minSum = currentSum;\n                    minIndex = i;\n                }\n\
    \                else if (currentSum - lastElement < minSum) {\n             \
    \       subArraySums.Clear();\n                    subArraySums.Add(currentSum);\n\
    \                }\n            }\n        }\n\n        return minSum;", "   \
    \     int maxsum = nums.Min();\n        int sum = 0;\n        foreach (long num\
    \ in nums)\n            sum += num;\n        if (sum == 0)\n            return\
    \ 0;\n        foreach (long num in nums.TakeWhile(n => n < maxsum)) {\n      \
    \      sum += num;\n            if (sum < maxsum)\n                break;\n  \
    \      }\n        return sum - maxsum;", "        long sum = (long)0;\n      \
    \  int sumIndex = 0;\n        bool found = false;\n        foreach (var n in nums)\
    \ {\n            if (n != 0) {\n                found = true;\n              \
    \  sum += n;\n                sumIndex++;\n            }\n        }\n        if\
    \ (found) {\n            List<long> remaining = nums.FindAll(num => num != 0);\n\
    \            if (remaining.Count > 0) return Minsubarraysum(remaining);\n    \
    \    }\n        return sum;", "        if (nums.Count <= 1) {\n            return\
    \ nums.Min();\n        }\n        long sum = 0;\n        long minSum = nums[0];\n\
    \        for (int i = 1; i < nums.Count; i++) {\n            sum += nums[i];\n\
    \            if (sum < minSum) {\n                minSum = sum;\n            }\n\
    \        }\n        return minSum;", "        long minSum = 0;\n        long sum\
    \ = 0;\n        bool hasNonZeroSum = false;\n        List<long> nonZeroSums =\
    \ new List<long>();\n\n        foreach (var num in nums) {\n            sum +=\
    \ num;\n            if (sum != 0) {\n                hasNonZeroSum = true;\n \
    \           }\n            if (hasNonZeroSum) {\n                nonZeroSums.Add(sum);\n\
    \            }\n        }\n\n        // If all numbers are zero, return zero.\n\
    \        if (sum == 0) {\n            return 0;\n        }\n\n        // If there\
    \ are no numbers, return zero.\n        if (nonZeroSums.Count == 0) {\n      \
    \      return 0;\n        }\n\n        /*\n         If we have only positive numbers,\
    \ then\n         we can find minimum subarray in O(n) time by sorting nums\n \
    \        and then finding sum from left to right.\n\n         If we have only\
    \ negative numbers, then\n         we can find minimum subarray in O(n) time by\
    \ sorting nums\n         and then finding sum from right to left.\n\n        \
    \ So, the total time complexity is O(max(nums.Count, O(sum(nums.Count))))\n  \
    \       */\n\n        // If we have only positive numbers, sort them.\n      \
    \  if (nonZeroSums.Count == nums.Count) {\n            nonZeroSums.Sort();\n \
    \       }\n\n        // If we have only negative numbers, reverse them.\n    \
    \    if (nonZeroSums.Count > nums.Count) {\n            nonZeroSums = nonZeroSums.Reverse();\n\
    \        }\n\n        // Find the sum of first element to rightmost element of\
    \ array.\n        long startSum = nonZeroSums[0];\n\n        // Find the sum of\
    \ first element to left most element of array.\n        long endSum = nonZeroSums.Last();\n\
    \n        // If the sum of first element to right most element of array is greater\n\
    \        // than sum of first element to left most element of array, then we\n\
    \        // can safely find minimum subarray in O(n) time.\n        if (startSum\
    \ > endSum) {\n            return startSum;\n        }\n\n        // If sum of\
    \ first element to right most element of array is equal to\n        // sum of\
    \ first element to left most element of array, then we can\n        // find minimum\
    \ subarray in O(n) time.\n        if (startSum == endSum) {\n            return\
    \ startSum;\n        }\n\n        // Now, find the next largest element to left\
    \ most element of array.\n        long nextSum = nonZeroSums[nonZeroSums.Count\
    \ - 1];\n\n        // Find the largest element of array from right to left.\n\
    \        long maxSum = nonZeroSums.Last();\n\n        // If the sum of the next\
    \ largest element to left most element of\n        // array is greater than the ",
  "        long sum = 0;\n        if (nums == null || nums.Count == 0) return 0;\n\
    \        long firstValue = nums.FirstOrDefault();\n        long firstNum = firstValue;\n\
    \        bool firstSublistIsIncomplete = false;\n        bool allSublistsAreIncomplete\
    \ = true;\n        long maxSum = firstValue;\n        foreach (long value in nums.Skip(1))\n\
    \        {\n            sum += value;\n            long sublistSum = sum;\n  \
    \          bool isFirstSublistIncomplete = firstSublistIsIncomplete;\n       \
    \     bool allSublistsAreIncompleteInThisSublist = true;\n            bool valueIsInCurrentSublist\
    \ = true;\n            while (true)\n            {\n                if (allSublistsAreIncompleteInThisSublist)\n\
    \                {\n                    firstSublistIsIncomplete = false;\n  \
    \              }\n                if (!firstSublistIsIncomplete)\n           \
    \     {\n                    maxSum = Math.Max(maxSum, sublistSum);\n        \
    \            if (maxSum < sublistSum)\n                    {\n               \
    \         break;\n                    }\n                    allSublistsAreIncompleteInThisSublist\
    \ = false;\n                }\n                if (!valueIsInCurrentSublist)\n\
    \                {\n                    break;\n                }\n          \
    \      if (!firstSublistIsIncomplete)\n                {\n                   \
    \ sublistSum += value;\n                    isFirstSublistIncomplete = true;\n\
    \                }\n                valueIsInCurrentSublist = true;\n        \
    \    }\n            if (allSublistsAreIncompleteInThisSublist)\n            {\n\
    \                allSublistsAreIncomplete = false;\n            }\n          \
    \  firstNum = value;\n        }\n        return sum;", "        List<long> numbers\
    \ = nums.ToList();\n        long sum = 0;\n        long min = long.MaxValue;\n\
    \        foreach(var value in numbers) {\n            sum += value;\n        \
    \    if(sum < min) {\n                min = sum;\n            }\n        }\n \
    \       return min;", "        Debug.Assert(nums.Count > 0);\n\n        long minSum\
    \ = 0L;\n        long currentSum = 0L;\n\n        var maxSum = nums.Max();\n\n\
    \        if (maxSum < 0L)\n            return 0L;\n\n        for (int i = 0; i\
    \ < nums.Count - 1; i++) {\n            currentSum += nums[i];\n\n           \
    \ if (currentSum > maxSum) {\n                minSum = currentSum;\n         \
    \       currentSum = 0L;\n            }\n        }\n\n        return minSum;",
  "        if (nums == null)\n            throw new ArgumentNullException(\"nums\"\
    );\n        long smallestSum = long.MinValue;\n        for (int i = 0; i < nums.Count\
    \ - 1; i++) {\n            smallestSum = Math.Min(smallestSum, sumSubsets(nums,\
    \ i, nums.Count - 1));\n        }\n        return smallestSum;", "        if (nums\
    \ == null || nums.Count == 0) {\n            return 0;\n        }\n        long\
    \ sum = 0;\n        double curSum = 0;\n        for (int i = 0; i < nums.Count\
    \ - 1; ++i) {\n            curSum += nums[i];\n            if (curSum < 0)\n \
    \               curSum = 0;\n            sum += curSum;\n        }\n        if\
    \ (sum < 0) {\n            sum = 0;\n        }\n        return sum;", "      \
    \  var sums = nums.Where(x => x != 0).Select(x => (long)x).ToArray();\n      \
    \  Debug.Assert(sums.Length == nums.Count);\n        Array.Sort(sums);\n     \
    \   int n = sums.Length;\n        long minSum = sums[0];\n        int minI = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            long currentSum = sums[i];\n\
    \            int j = i;\n            while (j > 0 && sums[j - 1] > currentSum)\
    \ {\n                j--;\n            }\n            sums[j] = currentSum;\n\
    \            while (j < n && sums[j] == sums[j + 1]) {\n                j++;\n\
    \            }\n            if (j < n) {\n                sums[j] = currentSum;\n\
    \            }\n            if (currentSum < minSum) {\n                minSum\
    \ = currentSum;\n                minI = i;\n            }\n        }\n       \
    \ return minSum;", "        int[] indexes = new int[nums.Count];\n        int[]\
    \ count = new int[nums.Count];\n        int result = 0;\n        for (int i =\
    \ 0; i < nums.Count; i++) {\n            indexes[i] = i;\n            count[i]\
    \ = 1;\n        }\n        for (int i = 0; i < nums.Count; i++) {\n          \
    \  if (indexes[i] < nums.Count - 1) {\n                count[indexes[i + 1]]++;\n\
    \            }\n        }\n        while (true) {\n            int max = -1;\n\
    \            for (int i = 0; i < nums.Count; i++) {\n                if (count[i]\
    \ > max) {\n                    max = count[i];\n                }\n         \
    \   }\n            if (max == 0) {\n                return result;\n         \
    \   }\n            result += max;\n            count[max] = 0;\n            for\
    \ (int i = 0; i < nums.Count; i++) {\n                if (count[i] == 0) {\n \
    \                   count[i] = 1;\n                    indexes[i] = i;\n     \
    \           }\n                else {\n                    count[i]--;\n     \
    \               if (count[i] == 0) {\n                        count[i] = 1;\n\
    \                        indexes[i + 1] = i;\n                        break;\n\
    \                    }\n                }\n            }\n        }", "      \
    \  List<long> subarray = new List<long>();\n        long maxSum = -(long.MaxValue);\n\
    \        long minSum = (long.MinValue);\n        foreach (long i in nums) {\n\
    \            subarray.Add(i);\n            long sum = MinSum(subarray);\n    \
    \        if (sum > maxSum) {\n                maxSum = sum;\n            }\n \
    \           if (sum < minSum) {\n                minSum = sum;\n            }\n\
    \        }\n        return minSum;", "        long n = nums.Count;\n        long\
    \ m = nums.Count > 0 ? nums.Max() : long.MaxValue;\n        long[] d = new long[n];\n\
    \        long dsum = 0;\n        for (int i = 0; i < n; i++) {\n            d[i]\
    \ = dsum;\n            dsum += nums[i];\n            if (dsum > m)\n         \
    \       dsum -= m;\n        }\n        long dsum2 = dsum - m;\n        if (n <\
    \ 2)\n            return dsum2;\n        long minsubarraysum = long.MaxValue;\n\
    \        int besti = 0; // index to start a search\n        long minsum = dsum2;\n\
    \        long bestsum = dsum2;\n        while (true) {\n            // If best\
    \ sum has already been calculated, we can exit the loop\n            if (bestsum\
    \ == dsum2) {\n                besti = -1;\n                break;\n         \
    \   }\n            if (bestsum < dsum2) {\n                besti = -1;\n     \
    \       } else {\n                bestsum += bestsum;\n                besti =\
    \ dsum - bestsum;\n            }\n            // If we found a better solution,\
    \ break out of loop\n            if (bestsum < minsum) {\n                break;\n\
    \            }\n            int bestj = besti;\n            int j;\n         \
    \   long bestjsum;\n            for (j = 0; j < n; j++) {\n                long\
    \ jsum = bestjsum + d[j];\n                if (jsum > bestsum) {\n           \
    \         bestsum = dsum;\n                    bestjsum = jsum;\n            \
    \        bestj = j;\n                }\n                if (jsum < bestsum) {\n\
    \                    if (bestjsum > jsum) {\n                        bestjsum\
    \ = jsum;\n                        bestj = j;\n                    }\n       \
    \             break;\n                }\n            }\n            minsubarraysum\
    \ += d[j];\n            if (bestj >= 0) {\n                minsubarraysum += d[j];\n\
    \                minsum -= d[j];\n            }\n        }\n        return minsubarraysum;",
  "        long low = long.MaxValue;\n        long high = long.MinValue;\n       \
    \ long ans = long.MaxValue;\n        foreach (long num in nums) {\n          \
    \  long mid = low + (high - low) / 2;\n            if (num > mid) {\n        \
    \        high = mid;\n            } else {\n                low = mid;\n     \
    \       }\n            if (high < low)\n                high = low;\n        }\n\
    \n        if (nums.Count() > 0) {\n            ans = Math.Min(ans, high - low);\n\
    \        }\n        return ans;", "        long sum = 0;\n        long prev =\
    \ 0;\n        foreach (var n in nums) {\n            if (n == prev)\n        \
    \        sum++;\n            else\n                sum -= prev;\n            prev\
    \ = n;\n        }\n        return sum;"]
stop_tokens:
- "\n    }\n"
