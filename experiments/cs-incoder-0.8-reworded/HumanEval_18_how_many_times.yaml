name: HumanEval_18_how_many_times
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n    // >>> HowManyTimes((\"\"), (\"a\"))\n  \
  \  // (0L)\n    // >>> HowManyTimes((\"aaa\"), (\"a\"))\n    // (3L)\n    // >>>\
  \ HowManyTimes((\"aaaa\"), (\"aa\"))\n    // (3L)\n    public static long HowManyTimes(string\
  \ str, string substring) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(HowManyTimes((\"\
  \"), (\"x\")) == (0L));\n    Debug.Assert(HowManyTimes((\"xyxyxyx\"), (\"x\")) ==\
  \ (4L));\n    Debug.Assert(HowManyTimes((\"cacacacac\"), (\"cac\")) == (4L));\n\
  \    Debug.Assert(HowManyTimes((\"john doe\"), (\"john\")) == (1L));\n    }\n\n\
  }\n"
completions: ["        long count = 0;\n        char[] arr = new char[str.Length];\n\
    \        str = str.ToLower();\n        foreach (char c in str) {\n           \
    \ if (Array.IndexOf(substring, c) >= 0)\n                count++;\n        }\n\
    \        return count;", "        var result = new HashSet<string>();\n      \
    \  var lastOccurrence = str.IndexOf(substring);\n        while(lastOccurrence\
    \ != -1) {\n            result.Add(str.Substring(0, lastOccurrence));\n      \
    \      lastOccurrence = str.IndexOf(substring, lastOccurrence + 1);\n        }\n\
    \        return result.Count;", "        long ret = 0;\n        List<int> indexes\
    \ = new List<int>();\n        int index = -1;\n        int currentIndex = -1;\n\
    \n        // If there are no matches, return 0.\n        if (str == null || substring\
    \ == null || str.Length <= substring.Length) {\n            return ret;\n    \
    \    }\n\n        // Loop through all characters in the original string.\n   \
    \     for (int i = 0; i < str.Length; i++) {\n            // Loop through all\
    \ characters in the substring from the current character.\n            int j =\
    \ 0;\n            while (j < substring.Length) {\n                // If the current\
    \ character of the substring is equal to the current character of the original,\n\
    \                // then add an index to the index list.\n                if (str[i]\
    \ == substring[j]) {\n                    indexes.Add(i);\n                  \
    \  index++;\n                    j++;\n                }\n                else\
    \ {\n                    // If the current character in the substring is not equal\
    \ to the current character of the original,\n                    // then find\
    \ the next character in the original string.\n                    while (index\
    \ < 0) {\n                        currentIndex++;\n                        if\
    \ (currentIndex >= str.Length) {\n                            break;\n       \
    \                 }\n                        if (str[currentIndex] == substring[j])\
    \ {\n                            indexes.Add(currentIndex);\n                \
    \            index++;\n                            j++;\n                    \
    \    }\n                    }\n                }\n            }\n        }\n\n\
    \        // If there are no indexes found, then return 0.\n        if (indexes.Count\
    \ == 0) {\n            return 0;\n        }\n\n        // Remove all indexes from\
    \ the index list.\n        List<int> removedIndexes = new List<int>();\n     \
    \   for (int i = indexes.Count - 1; i >= 0; i--) {\n            removedIndexes.Add(indexes[i]);\n\
    \            index.RemoveAt(indexes[i]);\n        }\n        indexes.Clear();\n\
    \n        // Loop through the remaining indexes and add +1 to the counter.\n \
    \       for (int i = 0; i < removedIndexes.Count; i++) {\n            indexes.Add(removedIndexes[i]);\n\
    \            index++;\n        }\n\n        // Return the number of times the\
    \ substring can be found.\n        ret = index;\n        return ret;", "     \
    \   if (str == null || str == string.Empty || substring == null || substring ==\
    \ string.Empty)\n            return 0;\n        long count = 0;\n        HashSet<string>\
    \ seen = new HashSet<string>();\n        for (int i = 0; i < str.Length; i++)\
    \ {\n            if (str[i] != substring[i])\n                continue;\n    \
    \        seen.Add(str);\n            count++;\n            str = str.Remove(i,\
    \ 1);\n        }\n        if (str != string.Empty)\n            seen.Add(str);\n\
    \        return count;", "        var hash = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\
    \        hash.Add(substring);\n        long result = 1;\n\n        if (str.Length\
    \ == 0) return 0;\n\n        foreach (var c in str) {\n            if (hash.Contains(c))\
    \ result++;\n        }\n\n        return result;", "        long count = 0;\n\
    \        if (str == null || str == string.Empty || substring == null || substring\
    \ == string.Empty) {\n            return 0;\n        }\n        char[] chArr =\
    \ new char[str.Length];\n        for (int i = 0; i < str.Length; i++) {\n    \
    \        chArr[i] = str[i];\n        }\n        int charsLeft = str.Length;\n\
    \        for (int i = 0; i < substring.Length; i++) {\n            while (charsLeft\
    \ > 0) {\n                int charIndex = charsLeft;\n                bool charFound\
    \ = false;\n                while (charIndex < str.Length) {\n               \
    \     if (chArr[charIndex] == substring[i]) {\n                        charFound\
    \ = true;\n                        break;\n                    }\n           \
    \         charIndex++;\n                }\n                if (!charFound) {\n\
    \                    charsLeft--;\n                }\n                else {\n\
    \                    count++;\n                    break;\n                }\n\
    \            }\n        }\n        return count;", "        long count = 0;\n\
    \        foreach (char sub in substring) {\n            int index = str.IndexOf(sub);\n\
    \            if (index != -1) {\n                count += index == 0 ? 1 : 0;\n\
    \                str = str.Remove(index, 1);\n            } else {\n         \
    \       break;\n            }\n        }\n        return count;", "        long\
    \ count = 0;\n        for (int i = str.Length - substring.Length + 1; i < str.Length;\
    \ i++) {\n            if (str.Substring(i, substring.Length).Equals(substring))\
    \ {\n                count += 1;\n            }\n        }\n        return count;",
  "        if (String.IsNullOrEmpty(str) || String.IsNullOrEmpty(substring)) return\
    \ 0;\n\n        // Use a HashSet to count the number of times each letter is present.\n\
    \        HashSet<string> set = new HashSet<string>();\n\n        // Iterate over\
    \ each character in the string.\n        foreach (char c in str)\n        {\n\
    \            if (set.Contains(c))\n            {\n                set.Remove(c);\n\
    \            }\n            else\n            {\n                set.Add(c);\n\
    \            }\n        }\n\n        // Iterate over each character in the substring.\n\
    \        foreach (char c in substring)\n        {\n            if (set.Contains(c))\n\
    \            {\n                set.Remove(c);\n            }\n            else\n\
    \            {\n                set.Add(c);\n            }\n        }\n\n    \
    \    // The substring has been counted (set.Count == 1) OR not counted (set.Count\
    \ == 0).\n        return set.Count == 0 ? 0 : set.Count;", "        // Count all\
    \ the cases of \"substring\" in \"str\"\n        var count = 0;\n        var chars\
    \ = str.ToCharArray();\n        Array.Reverse(str);\n        var foundIndex =\
    \ -1;\n        for (var i = 0; i != str.Length; ++i) {\n            if (chars[i]\
    \ == substring[0]) {\n                ++count;\n                if (count == substring.length\
    \ + 1) {\n                    foundIndex = i;\n                    break;\n  \
    \              }\n            }\n        }\n        if (foundIndex == -1) {\n\
    \            return 0;\n        }\n        // Count the cases that don't overlap.\n\
    \        var overlaps = 0;\n        for (var i = foundIndex + 1; str.Length >\
    \ 0; ++i) {\n            if (chars[i] == substring[0]) {\n                count\
    \ += 1;\n                if (count == substring.length + 1) {\n              \
    \      foundIndex = i;\n                    break;\n                }\n      \
    \      } else {\n                overlaps += count;\n                count = 0;\n\
    \            }\n        }\n        // Count the cases that don't overlap but don't\
    \ equal the expected \"substring\".\n        // This is when the substring has\
    \ more characters than the string has.\n        // For example, \"c\" is a substring\
    \ that occurs \"3\" times when \"aaa\" is searched for,\n        // but \"aaa\"\
    \ occurs twice when \"c\" is searched for because \"a\" is in the middle.\n  \
    \      var mismatches = 0;\n        for (var i = foundIndex + 1; str.Length >\
    \ 0; ++i) {\n            if (chars[i] == substring[0]) {\n                if (count\
    \ == substring.length + 1) {\n                    foundIndex = i;\n          \
    \          break;\n                }\n            } else {\n                mismatches\
    \ += count;\n                count = 0;\n            }\n        }\n        //\
    \ Count the cases that don't overlap but don't equal the expected \"substring\"\
    \ and\n        // the substring has more characters than the string has.\n   \
    \     // For example, \"c\" is a substring that occurs \"3\" times when \"aaa\"\
    \ is searched for,\n        // but \"aaa\" occurs twice when \"c\" is searched\
    \ for because \"a\" is in the middle.\n        var mismatchesAndOverlaps = 0;\n\
    \        for (var i = foundIndex + 1; str.Length > 0; ++i) {\n            if (chars[i]\
    \ == substring[0]) {\n                count += 1;\n                if (count ==\
    \ substring.length + 1) {\n                    foundIndex = i;\n             \
    \       break;\n                }\n            } else {\n                mismatchesAndOverlaps\
    \ += count;\n                count = 0;\n            }\n        }\n        //\
    \ The count of overlaps is always one less than the actual overlapping count.\n\
    \        // For example, if overlaps = 3, then \"aaa\" occurs 3 times, and \"\
    a\" is in the middle of \"aaa\".\n        // So the actual overlap is \"3 - 1\
    \ = 3\". This is a quirk of the algorithm,\n        // but it's important because\
    \ it's used to help us distinguish between mismatches and mismatches\n       \
    \ // in the same string.\n", "        long count = 0;\n        foreach (char c\
    \ in str) {\n            if (substring.IndexOf(c) >= 0) count++;\n        }\n\
    \        return count;", "        int k = str.IndexOf(substring);\n        if\
    \ (k == -1) return 0;\n        int l = substring.Length;\n        long count =\
    \ 0;\n        while (k >= 0) {\n            count++;\n            k = str.IndexOf(substring,\
    \ k+1);\n        }\n        return count;", "        var chars = str.ToCharArray();\n\
    \        var subs = substring.ToCharArray();\n        var max = 0;\n        for\
    \ (int i = 0; i <= chars.Length; i++) {\n            for (int j = 0, k = 0; j\
    \ <= subs.Length - 1 && k < chars.Length; j++) {\n                if (chars[k]\
    \ == subs[j]) {\n                    k++;\n                }\n            }\n\
    \            if (max < k) {\n                max = k;\n            }\n       \
    \ }\n        return max;", "        long count = 0;\n        for (int i = 0; i\
    \ < str.Length; i++) {\n            if (str[i] == substring[0])\n            \
    \    for (int j = 1; j < substring.Length; j++)\n                    if (str[i\
    \ + j] != substring[j])\n                        break;\n            if (i ==\
    \ str.Length - substring.Length)\n                for (int j = 0; j < substring.Length;\
    \ j++)\n                    if (str[i + j] != substring[j])\n                \
    \        break;\n            if (i + substring.Length == str.Length) {\n     \
    \           for (int j = 1; j < substring.Length; j++)\n                    if\
    \ (str[i + j] != substring[j])\n                        break;\n            }\n\
    \            count += (str[i] == substring[0]) + 1;\n        }\n        return\
    \ count;", "        if (str == null || substring == null) return 0;\n        long\
    \ count = 0;\n        int i = str.IndexOf(substring);\n        while (i>=0) {\n\
    \            i++;\n            count++;\n            i = str.IndexOf(substring,\
    \ i);\n        }\n        return count;", "        var charList = new List<char>(substring);\n\
    \        var strList = new List<char>(str);\n        long count = 0;\n       \
    \ // Check for each character in the original string and see how many times it\
    \ can be found in the substring\n        foreach (var ch in str) {\n         \
    \   if (charList.Contains(ch)) {\n                count += 1;\n            }\n\
    \        }\n\n        // If there are any more characters to process, add them\n\
    \        if (charList.Any()) {\n            foreach (var ch in charList) {\n \
    \               strList.Remove(ch);\n            }\n        }\n\n        // If\
    \ there is still any remaining characters to process, add them\n        if (strList.Any())\
    \ {\n            count += HowManyTimes(strList.ToArray(), substring);\n      \
    \  }\n\n        return count;", "        long answer = 0;\n        string s0 =\
    \ string.Join(\"\", str);\n        string s1 = string.Join(\"\", substring);\n\
    \        \n        if (s0.Length < s1.Length) {\n            throw new ArgumentException(\"\
    String length must be greater than substring length.\");\n        }\n        \n\
    \        for (int i = 0; i < s1.Length; i++) {\n            if (s0.IndexOf(substring,\
    \ i) > 0) {\n                answer += 1;\n            }\n        }\n        return\
    \ answer;", "        Debug.Assert(str != null && substring != null);\n\n     \
    \   int count = str.Count(s => s == substring);\n\n        // find overlaps\n\
    \        foreach (char c in substring)\n            while (count > 0 && str.IndexOf(c)\
    \ > str.IndexOf(str.Substring(0, str.IndexOf(c))))\n                count--;\n\
    \n        return count;", "        HashSet<string> hashSet = new HashSet<string>();\n\
    \        foreach (string s in str) {\n            if (hashSet.Add(s)) {\n    \
    \            hashSet.add(substring);\n            }\n        }\n        return\
    \ hashSet.Count(substring);", "        string strippedSubstring = \"\", strippedStr\
    \ = \"\";\n        for (int i = 0; i < substring.Length; i++) {\n            if\
    \ (substring.ElementAt(i) == '.') {\n                strippedSubstring += substring.Substring(0,\
    \ i) + \"|\" + substring.Substring(i + 1, substring.Length - i);\n           \
    \ }\n            else {\n                strippedSubstring += substring.Substring(0,\
    \ i);\n            }\n        }\n        strippedSubstring = strippedSubstring.TrimEnd('|');\n\
    \        strippedStr = str.TrimEnd('|');\n        return strippedSubstring.Count(strippedStr.Contains);",
  "        long total = 0;\n        for (int i = 0; i < str.Length - substring.Length\
    \ + 1; i++) {\n            total += (str.Substring(0, i + 1).Equals(substring));\n\
    \        }\n        return total;", "        long count = 1;\n        foreach\
    \ (var s in substring)\n            if (str.Contains(s)) {\n                count++;\n\
    \                str = str.Replace(s, \"\");\n            } else {\n         \
    \       str = \"\";\n            }\n\n        return count;", "        long total\
    \ = 0;\n        string s = string.Empty;\n        foreach(char c in substring)\
    \ {\n            s = s + c;\n        }\n        foreach(char c in str) {\n   \
    \         if(c.Equals(s, StringComparison.OrdinalIgnoreCase)) {\n            \
    \    total++;\n            }\n        }\n        return total;", "        // Get\
    \ the size of the target string\n        long size = 0;\n        for (int i =\
    \ 0; i < str.Length; i++) {\n            // Get the character at the current index\n\
    \            char c = str[i];\n            // Get the index of the current character\n\
    \            int index = i + 1;\n            // Check if the character is the\
    \ same as the substring\n            if ((c == substring[index]) && (c != str[str.Length\
    \ - 1])) {\n                // Increment the count for this character\n      \
    \          size += 1;\n            }\n        }\n        // Return the final count\n\
    \        return size;", "        if (str == null || substring == null) {\n   \
    \         throw new ArgumentNullException();\n        }\n        if (str.IndexOf(substring)\
    \ == -1) {\n            return 0;\n        }\n        long count = 0;\n      \
    \  for (int i = 0; i < str.Length; i++) {\n            if (str.IndexOf(substring,\
    \ i) >= 0) {\n                count++;\n            }\n        }\n        return\
    \ count;", "        // For each letter of the string, count how many times the\
    \ substring appears in it.\n        long result = str.Count(x => x == substring);\n\
    \n        // For each letter of the substring, count how many times the string\
    \ appears in it.\n        result += substring.Count(x => x == str);\n\n      \
    \  // Return all the counts\n        return result;", "        Regex r = new Regex(substring);\n\
    \        return (long) r.Matches(str).Count;", "        long? counter = str.Length;\n\
    \        long? count = str.Count(char.IsWhiteSpace);\n        counter = counter.HasValue\
    \ ? counter.Value : 0;\n        count = count.HasValue ? count.Value : 0;\n  \
    \      var charArray = str.ToCharArray();\n        var substringArray = substring.ToCharArray();\n\
    \        var isInSubString = substringArray.All(x => charArray.Contains(x));\n\
    \        if (isInSubString) counter += count.Value;\n        return counter.HasValue\
    \ ? counter.Value : 0;", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\
    \ {\n            throw new ArgumentNullException(\"str\", \"String must not be\
    \ null or empty.\");\n        }\n\n        long count = 0;\n        foreach (var\
    \ c in str) {\n            if (c == substring[0]) {\n                for (var\
    \ i = 1; i < substring.Length; i++) {\n                    if (string.Compare(str,\
    \ i, substring, StringComparison.OrdinalIgnoreCase) == 0) {\n                \
    \        count += 1;\n                        str = str.Substring(i, str.Length\
    \ - i);\n                    }\n                }\n            } else {\n    \
    \            for (var j = 0; j < substring.Length; j++) {\n                  \
    \  if (string.Compare(str, j + 1, substring, StringComparison.OrdinalIgnoreCase)\
    \ == 0) {\n                        count += 1;\n                        str =\
    \ str.Substring(j + 1, str.Length - j);\n                    }\n             \
    \   }\n            }\n        }\n\n        return count;", "        long result\
    \ = long.MinValue;\n        long index = 0;\n        for (int i = 0; i < str.Length;\
    \ i++) {\n            long found = str.IndexOf(substring, index) + substring.Length\
    \ - 1;\n            if (found < 0)\n                break;\n            if (str[i]\
    \ != substring[index]) {\n                index++;\n                continue;\n\
    \            }\n            if (str[i] == substring[index] && found < str.Length)\n\
    \                index++;\n            else {\n                result += found\
    \ - index;\n                index = found;\n            }\n        }\n       \
    \ return result;", '        return str.Count(i => i.Equals(substring, StringComparison.InvariantCultureIgnoreCase))
    != str.IndexOf(substring, StringComparison.InvariantCultureIgnoreCase) ? 0 : 1;',
  "        if (str.Length == 0) {\n            return 0;\n        }\n        var count\
    \ = SubstringCount(str, substring);\n        // handle overlapping cases\n   \
    \     var overlapCount = SubstringCount(str, substring, false);\n        return\
    \ count + overlapCount;", "        return string.Compare(substring, str, true)\
    \ *\n            string.Compare(substring, str.Substring(0, str.Length - substring.Length),\
    \ true) *\n            string.Compare(substring, str.Substring(str.Length - substring.Length),\
    \ true);", "        // Calculate the hash code\n        long hash = HashCode(str);\n\
    \n        // Find the first index\n        long index = Array.IndexOf(hash, HashCode(substring));\n\
    \n        // If there is no index, then substring is not found\n        if (index\
    \ == -1) return 0L;\n\n        // Find the last index\n        index = Array.IndexOf(hash,\
    \ HashCode(substring, str.Length - index));\n\n        // Return the number of\
    \ times the substring occurs\n        return index - index + 1;", "        long\
    \ numTimes = 0;\n        bool foundAtLeastOnce = false;\n        int startIndex\
    \ = 0, endIndex = str.Length;\n        // If the substring is longer than the\
    \ string, we can't do anything else than counting how much times the substring\
    \ exists.\n        if (substring.Length > str.Length) {\n            return 0;\n\
    \        }\n        if (substring == \"\") {\n            // If we got here, then\
    \ the substring wasn't found.\n            return 0;\n        }\n        // The\
    \ algorithm works by comparing every character in the string to the substring,\
    \ and incrementing the counter\n        // when the characters are the same.\n\
    \        while (startIndex < endIndex) {\n            if (string.Compare(str,\
    \ startIndex, substring, 0, substring.Length) == 0) {\n                ++numTimes;\n\
    \                foundAtLeastOnce = true;\n            }\n            startIndex\
    \ += 1;\n        }\n        if (foundAtLeastOnce) {\n            // There may\
    \ be overlaps so we need to count them\n            int lengthOfSubstringToCompare\
    \ = substring.Length;\n            int lengthOfStr = str.Length;\n           \
    \ int index = 0;\n            while (index < lengthOfSubstringToCompare && index\
    \ < lengthOfStr) {\n                if (string.Compare(str, index + 1, substring,\
    \ index + 1, substring.Length) == 0) {\n                    ++numTimes;\n    \
    \            }\n                index += 1;\n            }\n        }\n      \
    \  return numTimes;", "        long matches = 0;\n        long index = 0;\n\n\
    \        do {\n            // Use a for loop to find the next substring index.\
    \ Substring ends with index 0 if no more matches.\n            for (; (index <\
    \ str.Length) && (index < substring.Length); index++) {\n                if (str[index]\
    \ == substring[index]) {\n                    matches++;\n                }\n\
    \            }\n            str += substring[index];\n            index++;\n \
    \       } while (index < str.Length);\n        return matches;", "        if (str\
    \ == null || substring == null)\n            throw new ArgumentNullException(\"\
    str\", \"str\");\n        return str.Split(substring).Count(s => s == substring);",
  '        return str.Count(x => x == substring);', "        long matchCount = 0;\n\
    \        int i = 0;\n        int j = str.Length;\n        int k = 0;\n       \
    \ long pos1 = 0, pos2 = 0;\n        bool found = false;\n        while (i <= j)\
    \ {\n            found = false;\n            if (str.Length < substring.length\
    \ + 1) {\n                break;\n            }\n            while (i < j) {\n\
    \                if (str.Substring(i, j).Equals(substring)) {\n              \
    \      matchCount += 1;\n                    found = true;\n                 \
    \   break;\n                }\n                i += 1;\n            }\n      \
    \      if (!found) {\n                while (k < substring.length && k <= str.Length\
    \ - j + 1) {\n                    pos2 = str.IndexOf(substring, k);\n        \
    \            if (pos2 > pos1 && pos1 > 0) {\n                        matchCount\
    \ += 1;\n                        found = true;\n                        break;\n\
    \                    }\n                    pos1 = pos2;\n                   \
    \ k += 1;\n                }\n            }\n        }\n        return matchCount;",
  "        List<string> strArray = new List<string>(str);\n        List<string> subArray\
    \ = new List<string>(substring);\n        long n = 0;\n        foreach (string\
    \ ss in subArray) {\n            n = n * strArray.Count(ss => ss.Contains(ss));\n\
    \        }\n        return n;", "        int count = 0;\n        for (int i =\
    \ 0; i < str.Length; i++) {\n            if (str.Contains(substring, i)) {\n \
    \               count++;\n            }\n        }\n        return count;", " \
    \       string pattern = string.Join(\"|\", substring);\n        long count =\
    \ Regex.Matches(str, pattern).Count;\n        return count;", "        if (str\
    \ == null || substring == null)\n            return 0;\n        long count = (str.Length\
    \ * substring.Length) - (str.Length + substring.Length) - 1;\n        int i =\
    \ 0;\n        int j = str.Length - substring.Length + 1;\n        while (i <=\
    \ j) {\n            i += str.IndexOf(substring, i);\n            j -= str.IndexOf(substring,\
    \ j);\n            ++count;\n        }\n        return count;", "        // We\
    \ need to do this twice, since we can't just use str.Contains(substring).\n  \
    \      var result = (str.Length == 0) ? 0 : Long.MaxValue;\n        var count\
    \ = Int32.MaxValue;\n        for (int i = 0; i < str.Length; i++) {\n        \
    \    if (str[i] == substring[0]) {\n                if (i + substring.length >\
    \ str.Length)\n                    throw new ArgumentOutOfRangeException(\"Substring\
    \ larger than original string\");\n                for (int j = 0; j < substring.Length;\
    \ j++) {\n                    if (i + j >= str.Length)\n                     \
    \   throw new ArgumentOutOfRangeException(\"Substring larger than original string\"\
    );\n                    if (str[i + j] != substring[j])\n                    \
    \    break;\n                    result = (result > 0) ? result + 1 : result;\n\
    \                    count = (count > 0) ? count + 1 : count;\n              \
    \  }\n            }\n        }\n        if (count == Int32.MaxValue)\n       \
    \     return result;\n        return result + (count * 2);", "        HashSet<string>\
    \ strHash = new HashSet<string>();\n        for (int i = 0; i < str.Length; i++)\
    \ {\n            string strChar = str.Substring(i);\n            if (!string.IsNullOrEmpty(strChar))\
    \ {\n                strHash.add(strChar);\n            }\n        }\n\n     \
    \   HashSet<string> substringHash = new HashSet<string>();\n        for (int i\
    \ = 0; i < substring.Length; i++) {\n            string subChar = substring.Substring(i);\n\
    \            if (!string.IsNullOrEmpty(subChar)) {\n                substringHash.add(subChar);\n\
    \            }\n        }\n\n        long result = 0;\n        int j = 0;\n  \
    \      int index = 0;\n        int jIndex = 0;\n        for (string s in substringHash)\
    \ {\n            if (s.Length > 1) {\n                jIndex = str.IndexOf(s,\
    \ index + 1);\n                if (jIndex == -1) {\n                    jIndex\
    \ = str.IndexOf(s, index);\n                }\n                if (jIndex != -1\
    \ && (jIndex > j)) {\n                    j = jIndex;\n                }\n   \
    \         }\n        }\n\n        for (int i = 0; i < str.Length; i++) {\n   \
    \         string strChar = str.Substring(i);\n            if (strHash.Contains(strChar))\
    \ {\n                result += (substringHash.Contains(str.Substring(i, str.Length\
    \ - i)));\n            }\n        }\n\n        return result;", "        List<int>\
    \ indexes = new List<int>();\n        for (int i = 0; i < str.Length; i++) {\n\
    \            if (str[i] == substring[0]) {\n                int j = str.IndexOf(substring,\
    \ i + 1);\n                if (j > -1)\n                    indexes.Add(j);\n\
    \            }\n        }\n        if (indexes.Count > 0) {\n            int minIndex\
    \ = indexes.Min();\n            int maxIndex = indexes.Max();\n            if\
    \ (minIndex < maxIndex)\n                return maxIndex - minIndex + 1;\n   \
    \     }\n        return 0;", "        if (substring == \"\" || str == \"\")\n\
    \            return 0;\n\n        long ret = 0;\n        int len = substring.Length;\n\
    \        int strlen = str.Length;\n        \n        for (int i = 0; i < strlen;\
    \ i++)\n        {\n            int index = str.IndexOf(substring, i);\n      \
    \      \n            if (index != -1)\n                ret += index - i;\n   \
    \     }\n        \n        return ret;", "        Dictionary<string, long> dict\
    \ = new Dictionary<string, long>();\n        long[] charCounts = new long[str.Length];\n\
    \        long count = 0;\n        for (int i = 0; i < str.Length; i++) {\n   \
    \         charCounts[i] = 0;\n        }\n        foreach (char c in substring)\
    \ {\n            dict[c] = dict.ContainsKey(c) ? dict[c] + 1 : 1;\n          \
    \  for (int i = 0; i < str.Length; i++) {\n                if (c == str[i]) {\n\
    \                    charCounts[i]++;\n                }\n            }\n    \
    \    }\n        for (int i = 0; i < str.Length; i++) {\n            if (charCounts[i]\
    \ > 0) {\n                count += dict[substring[i]] / charCounts[i];\n     \
    \       }\n        }\n        return count;", "        long result = 0, pos;\n\
    \n        pos = str.IndexOf(substring);\n        while (pos >= 0) {\n        \
    \    result += 1;\n            pos = str.IndexOf(substring, pos + 1);\n      \
    \  }\n\n        return result;", "        long res = 0;\n        foreach(char\
    \ c in str) {\n            if(str.IndexOf(substring, 0, substring.length) == 0)\
    \ {\n                res++;\n            }\n        }\n        return res;", " \
    \       // If string is null, return 0\n        if (str == null) {\n         \
    \   return 0L;\n        }\n\n        // If substring is null, return 0\n     \
    \   if (string.IsNullOrEmpty(substring)) {\n            return 0L;\n        }\n\
    \n        // Initialize a variable for count and for string length\n        long\
    \ count = 0L;\n        int length = str.Length;\n\n        // Initialize a variable\
    \ to hold index of substring\n        int idx;\n\n        // Initialize a variable\
    \ to hold index where substring starts\n        int start;\n\n        // Initialize\
    \ a variable to hold index where substring ends\n        int end;\n\n        //\
    \ Initialize a variable to hold substring length\n        int length = substring.Length;\n\
    \n        // If substring is not found, then return 0.\n        if (!str.Contains(substring))\
    \ {\n            return 0L;\n        }\n\n        // If string is longer than\
    \ substring, return 0.\n        if (length > substring.Length) {\n           \
    \ return 0L;\n        }\n\n        // Initialize a variable to hold index of first\
    \ occurence of\n        // substring\n        idx = 0;\n\n        // Initialize\
    \ a variable to hold index where the first occurence starts\n        start = idx;\n\
    \n        // Initialize a variable to hold index where the first occurence ends\n\
    \        end = 0;\n\n        // While the index of substring can't be found anymore\n\
    \        while (idx < length) {\n            // Initialize a variable to hold\
    \ index of the first occurence of\n            // substring\n            idx =\
    \ 0;\n\n            // While the index of string can't be found anymore\n    \
    \        while (idx < length) {\n                // If the substring at given\
    \ index and string at given index\n                // are same\n             \
    \   if (str[idx] == substring[start] && str[idx + 1] == substring[end]) {\n  \
    \                  // Increment the counter\n                    count += 1;\n\
    \n                    // While the counter exceeds the length of substring\n \
    \                   if (count > length) {\n                        // Break out\
    \ of the loop\n                        break;\n                    }\n       \
    \         }\n\n                // Increment the index\n                idx +=\
    \ 1;\n            }\n\n            // Increment the index\n            idx +=\
    \ 1;\n\n            // Increment the start index\n            start += 1;\n\n\
    \            // Increment the end index\n            end += 1;\n        }\n\n\
    \        return count;", "        int position = 0;\n        long counter = 0;\n\
    \        string current = \"\";\n        foreach (char c in substring) {\n   \
    \         int index = str.IndexOf(c.ToString(), position);\n            if (index\
    \ >= 0) {\n                counter++;\n                current = str.Substring(0,\
    \ index);\n            }\n            position += c.Length;\n        }\n     \
    \   return counter;", "        long count = 0;\n        foreach (var item in str.Split('\
    \ '))\n        {\n            if (item == substring)\n            {\n        \
    \        count++;\n            }\n        }\n        return count;", "       \
    \ if (str == \"\") {\n            return 0;\n        }\n        long len = (str\
    \ + substring).Length;\n        if (len == 0) {\n            return 0;\n     \
    \   }\n        string str1 = str.Substring(0, 1);\n        if (substring == str1)\
    \ {\n            return 1;\n        }\n        string str2 = str.Substring(0,\
    \ 2);\n        if (substring == str2) {\n            return 2;\n        }\n  \
    \      string str3 = str.Substring(0, 3);\n        if (substring == str3) {\n\
    \            return 3;\n        }\n        string str4 = str.Substring(0, 4);\n\
    \        if (substring == str4) {\n            return 4;\n        }\n        string\
    \ str5 = str.Substring(0, 5);\n        if (substring == str5) {\n            return\
    \ 5;\n        }\n        string str6 = str.Substring(0, 6);\n        if (substring\
    \ == str6) {\n            return 6;\n        }\n        string str7 = str.Substring(0,\
    \ 7);\n        if (substring == str7) {\n            return 7;\n        }\n  \
    \      string str8 = str.Substring(0, 8);\n        if (substring == str8) {\n\
    \            return 8;\n        }\n        string str9 = str.Substring(0, 9);\n\
    \        if (substring == str9) {\n            return 9;\n        }\n        string\
    \ str10 = str.Substring(0, 10);\n        if (substring == str10) {\n         \
    \   return 10;\n        }\n        string str11 = str.Substring(0, 11);\n    \
    \    if (substring == str11) {\n            return 11;\n        }\n        string\
    \ str12 = str.Substring(0, 12);\n        if (substring == str12) {\n         \
    \   return 12;\n        }\n        string str13 = str.Substring(0, 13);\n    \
    \    if (substring == str13) {\n            return 13;\n        }\n        string\
    \ str14 = str.Substring(0, 14);\n        if (substring == str14) {\n         \
    \   return 14;\n        }\n        string str15 = str.Substring(0, 15);\n    \
    \    if (substring == str15) {\n            return 15;\n        }\n        string\
    \ str16 = str.Substring(0, 16);\n        if (substring == str16) {\n         \
    \   return 16;\n        }\n        string str17 = str.Substring(0, 17);\n    \
    \    if (substring == str17) {\n            return 17;\n        }\n        string\
    \ str18 = str.Substring(0, 18);\n        if (substring == str18) {\n         \
    \   return 18;\n        }\n        string str19 = str.Substring(0, 19);\n    \
    \    if (substring == str19) {\n            return 19;\n        }\n        string\
    \ str20 = str.Substring(0, 20);\n        if (substring == str20) {\n         \
    \   return 20;\n        }\n        string str21 = str.Substring(0, 21);\n", " \
    \       if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n  \
    \          return 0;\n        // Create a dictionary (hash) of our substring to\
    \ our string's length\n        Dictionary<string, long> map = new Dictionary<string,\
    \ long>();\n        // Iterate through each character of the string\n        for\
    \ (int i = 0; i < str.Length; i++) {\n            // If the character is in the\
    \ substring, increase our count.\n            if (str.Substring(i, 1).Contains(substring))\n\
    \                map[substring]++;\n        }\n        // If we didn't have any\
    \ matches, return 0\n        if (map.Count == 0)\n            return 0;\n    \
    \    // Otherwise iterate through each key, count the matches, and return the\
    \ maximum.\n        long maxCount = 0;\n        foreach (var item in map) {\n\
    \            if (item.Value > maxCount)\n                maxCount = item.Value;\n\
    \        }\n        return maxCount;", "        long count = 0;\n        foreach\
    \ (char c in str)\n            if (c == substring[0]) {\n                count++;\n\
    \                str = str.Remove(0, 1);\n                if (str.Contains(substring))\n\
    \                    count += HowManyTimes(str, substring);\n                str\
    \ = str.Remove(1);\n                if (str.Contains(substring))\n           \
    \         count += HowManyTimes(str, substring);\n            }\n        return\
    \ count;", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n\
    \            return 0L;\n\n        var strArray = str.ToLower();\n        var\
    \ substringArray = substring.ToLower();\n\n        var substringHash = new HashSet<string>(substringArray);\n\
    \        var commonCharsFound = 0;\n        for (int i = 0; i < strArray.Length;\
    \ i++) {\n            if (strArray[i] != substringArray[i])\n                continue;\n\
    \n            commonCharsFound++;\n            if (commonCharsFound > substringArray.Length)\n\
    \                break; // substring ends early\n        }\n\n        var overlap\
    \ = substringArray.Length - commonCharsFound;\n        return (long) overlap;",
  "        long ret = 0;\n        int i = 0;\n        while (i < str.Length) {\n \
    \           if (str[i] == substring[i]) {\n                ++i;\n            \
    \    continue;\n            }\n            if (str.Length - i < substring.Length)\
    \ {\n                ++i;\n                continue;\n            }\n        \
    \    while (i < str.Length) {\n                if (str[i] == substring[i]) {\n\
    \                    ++i;\n                    ++ret;\n                    continue;\n\
    \                }\n                if (i == str.Length - 1) {\n             \
    \       ++i;\n                    ++ret;\n                    continue;\n    \
    \            }\n                if (str.Length - i < substring.Length) {\n   \
    \                 ++i;\n                    ++ret;\n                    continue;\n\
    \                }\n                if (str.Length - i == substring.Length) {\n\
    \                    ++i;\n                    ++ret;\n                    ++i;\n\
    \                    ++ret;\n                    continue;\n                }\n\
    \                ++i;\n            }\n        }\n        return ret;", "     \
    \   // Create a StringComparer that always returns true (case-insensitive)\n \
    \       var strcomp = new StringComparer(StringComparison.InvariantCultureIgnoreCase);\n\
    \        // Initialize result to zero\n        var count = 0;\n        // Create\
    \ a regex pattern and compile it\n        var pattern = string.Format(\"(?i)({0}){1}\"\
    , substring, str);\n        var regex = new Regex(pattern, RegexOptions.IgnoreCase);\n\
    \        // Match the regex in the text\n        var matches = regex.Matches(str);\n\
    \        // If the match is a match\n        if (matches.Count > 0) {\n      \
    \      // Get the first match from the match\n            var matchText = matches[0].Value;\n\
    \            // Split the match into parts using the pattern delimiter\n     \
    \       var matchParts = Regex.Split(matchText, pattern);\n            // For\
    \ each part of the match\n            for (var i = 0; i < matchParts.Length; i++)\
    \ {\n                // Increment result for part of the match that did not match\n\
    \                count += strcomp.IndexOf(matchParts[i], 0, matchParts[i].Length);\n\
    \            }\n        }\n        return count;", "        if (string.IsNullOrEmpty(str)\
    \ || string.IsNullOrEmpty(substring)) {\n            return 0;\n        }\n  \
    \      var n = str.Count(c => c == substring);\n        if (n == 0) {\n      \
    \      return 0;\n        }\n        return n;", "        long result = str.Count(p\
    \ => p == substring);\n        if (str.Length > substring.Length) {\n        \
    \    result *= (str.Length - substring.Length) / (str.Length - 1);\n        }\n\
    \        return result;", '        return str.Count(substring, StringComparer.OrdinalIgnoreCase);',
  "        if (str == null || str.Length < substring.length) return 0L;\n        long\
    \ len = 0;\n        for (int i = 0; i < str.Length; i++) {\n            if (str[i]\
    \ == substring[0]) {\n                len++;\n                for (int j = 1;\
    \ j < substring.Length; j++) {\n                    if (str[i + j] != substring[j])\
    \ break;\n                }\n            }\n        }\n        return len;", " \
    \       long countZero = str.IndexOf(substring) == -1 ? 0 : 1;\n        long countOne\
    \ = str.IndexOf(substring, StringComparison.Ordinal) == -1 ? 0 : 1;\n        long\
    \ countTwo = str.IndexOf(substring, StringComparison.OrdinalIgnoreCase) == -1\
    \ ? 0 : 1;\n        long countThree = str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ == -1 ? 0 : 1;\n        long countMoreThanOne = str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ > -1 ? 1 : 0;\n        long countMoreThanTwo = str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ > -1 ? 1 : 0;\n        long countMoreThanThree = str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ > -1 ? 1 : 0;\n        return countZero + (countOne * 2) + (countTwo * 2) +\
    \ (countThree * 2) + (countMoreThanOne * 3) + (countMoreThanTwo * 3) + (countMoreThanThree\
    \ * 3);", "        int length = str.Length;\n        long count = 0;\n       \
    \ if (length == 0) {\n            return count;\n        }\n        if (string.IsNullOrWhiteSpace(str))\
    \ {\n            return count;\n        }\n        if (string.IsNullOrWhiteSpace(substring))\
    \ {\n            return count;\n        }\n        if (substring == \"\") {\n\
    \            return count;\n        }\n        if (length == 1) {\n          \
    \  return count;\n        }\n        if (length == 1) {\n            return count;\n\
    \        }\n\n        int i = 0, j = 0;\n        while (i < length) {\n      \
    \      int subLength = substring.Length;\n            bool subFound = false;\n\
    \            for (j = 0; j < subLength; j++) {\n                if (str[i + j]\
    \ != substring[j]) {\n                    break;\n                }\n        \
    \        if (j == subLength - 1) {\n                    subFound = true;\n   \
    \             }\n            }\n            if (subFound == false) {\n       \
    \         count++;\n            }\n            i += subLength;\n        }\n  \
    \      return count;", "        long sum = 0;\n        foreach (char c in str.ToLower())\
    \ {\n            if (substring.Contains(c)) {\n                sum += 1;\n   \
    \         }\n        }\n        return sum;", "        var matchStrings = new\
    \ HashSet<string>(str.Split(new[] { 'a', ',', '!' }, StringSplitOptions.RemoveEmptyEntries));\n\
    \        var foundStrings = new HashSet<string>();\n        foreach (var match\
    \ in matchStrings) {\n            if (foundStrings.Contains(match)) {\n      \
    \          continue;\n            }\n            if (str.Contains(match)) {\n\
    \                foundStrings.Add(match);\n                string newStr = str;\n\
    \                newStr = str.Replace(match, \"\");\n                var newSubstring\
    \ = substring;\n                newSubstring = substring.Replace(match, \"\");\n\
    \                var result = HowManyTimes(newStr, newSubstring);\n          \
    \      foundStrings.Add(match + result);\n            }\n        }\n        return\
    \ foundStrings.Count;", "        var c = str.Length;\n        var d = substring.Length;\n\
    \        if (c <= 0 || d <= 0 || c == 0 || d == 0) return 0;\n        \n     \
    \   // Use a table to count overlapping substring for each position\n        var\
    \ table = new int[c, d];\n        \n        // Initialize table by finding substring\n\
    \        var j = 0;\n        foreach (var c in substring) table[0, j] = table[0,\
    \ j] + (c == str[j]);\n        \n        // Look for the substring\n        for\
    \ (var i = 1; i < c; ++i) {\n            for (var j = 0; j < d; ++j) {\n     \
    \           if (str[i - 1] == substring[j]) table[i, j] = table[i, j] + 1;\n \
    \               else table[i, j] = table[i, j - 1];\n            }\n        }\n\
    \        \n        // Count overlaping substring\n        var count = 0;\n   \
    \     foreach (var row in table) {\n            if (row.Sum() == d) count++;\n\
    \        }\n        return count;", '        return str.ToLowerInvariant().Split(substring).Length;',
  "        List<char> chars = new List<char>();\n        for (int i = 0; i < str.Length;\
    \ i++) {\n            chars.Add(str[i]);\n        }\n        for (int i = 0; i\
    \ < substring.Length; i++) {\n            chars.Add(substring[i]);\n        }\n\
    \        bool found = false;\n        long count = 0;\n        while (!found &&\
    \ chars.Count > 0) {\n            found = true;\n            for (int i = 0; i\
    \ < chars.Count; i++) {\n                if (chars[i] != chars[chars.Count - i\
    \ - 1]) {\n                    found = false;\n                    break;\n  \
    \              }\n            }\n            if (found) {\n                count++;\n\
    \                chars.RemoveAt(chars.Count - 1);\n            }\n        }\n\
    \        return count;", "        int i = str.IndexOf(substring);\n        if\
    \ (i == -1)\n            return 0L;\n        if (substring == \"\")\n        \
    \    return 1L;\n        else\n            return str.Length - str.IndexOf(substring,\
    \ i + 1) - str.IndexOf(substring, 0) - 1;", "        var result = new StringBuilder();\n\
    \        foreach (var c in str) {\n            if (substring.Contains(c)) {\n\
    \                result.Append(c);\n            }\n        }\n        var foundSubstring\
    \ = str.Contains(substring);\n        return result.ToString().Split(new[] { 'a'\
    \ }).Length - 1;", "        if (string.IsNullOrEmpty(substring)) return 0;\n\n\
    \        long count = 1;\n\n        // Find out how many times the substring can\
    \ be found in str\n        foreach (char c in substring) {\n            count\
    \ = Math.Min(count, str.IndexOf(substring, c - 1));\n        }\n\n        return\
    \ count;", "        var length = str.Length;\n        var index = str.IndexOf(substring);\n\
    \        if (index == -1) throw new IndexOutOfRangeException(\"No substring \"\
    \ + substring + \" exists in \" + str + \".\");\n        var count = 0;\n    \
    \    // Iterate through the string until we find an occurrence of the substring\
    \ at the end.\n        while (index != -1) {\n            count++;\n         \
    \   index = str.IndexOf(substring, index + 1);\n        }\n        return count;",
  "        // Count overlapping cases. i.e. substring is in both strings\n       \
    \ var cnt = 0;\n        for (int i = 0; i < str.Length; i++) {\n            if\
    \ (str.Substring(i, 1).Equals(substring)) {\n                cnt++;\n        \
    \    }\n        }\n        return cnt;", "        long ret = 0;\n        int i\
    \ = str.IndexOf(substring);\n        int j = substring.Length;\n        while\
    \ (i >= 0 && j >= 0) {\n            if (str.CompareTo(substring, i, j) == 0) {\n\
    \                ++ret;\n                i += j;\n                j -= i;\n  \
    \          } else {\n                i -= j;\n                j += i;\n      \
    \      }\n        }\n        return ret;", "        var startIndex = 0;\n    \
    \    var foundCount = 0;\n        while (startIndex < str.Length) {\n        \
    \    var endIndex = str.IndexOf(substring, startIndex);\n            if (endIndex\
    \ == -1) break;\n            foundCount += endIndex - startIndex + 1;\n      \
    \      startIndex = endIndex + 1;\n        }\n        return foundCount;", " \
    \       if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) return\
    \ 0L;\n        if (string.Compare(substring, str.Substring(0, substring.Length),\
    \ System.StringComparison.OrdinalIgnoreCase) != 0) return 0L;\n        var res\
    \ = 0;\n        for (int i = 1; i < str.Length; i++) {\n            if (str[i]\
    \ == substring[0]) {\n                for (int j = 0; j < substring.Length; j++)\
    \ {\n                    if (str[i + j] != substring[j]) {\n                 \
    \       break;\n                    }\n                }\n                if (j\
    \ == substring.Length) {\n                    res++;\n                }\n    \
    \        }\n        }\n        return res;", "        string temp = str;\n   \
    \     StringBuilder temp2 = new StringBuilder(temp);\n        temp2.Remove(substring,\
    \ StringComparison.InvariantCultureIgnoreCase);\n        long count = temp2.ToString().Split('\
    \ ').Where(s => s.IndexOf(substring, StringComparison.OrdinalIgnoreCase) >= 0).Count();\n\
    \        temp = str.Substring(str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ + substring.Length);\n        temp2.Clear();\n        while (temp.Length > 0)\
    \ {\n            temp2.Append(temp);\n            temp2.Append(\" \");\n     \
    \       temp = temp.Substring(0, temp.Length - 1);\n            count = temp2.ToString().Split('\
    \ ').Where(s => s.IndexOf(substring, StringComparison.OrdinalIgnoreCase) >= 0).Count()\
    \ + count;\n        }\n        return count;", "        long times = 0;\n    \
    \    bool found = false;\n        for (int i = 0; i < str.Length - substring.length;\
    \ i++) {\n            if (string.Compare(substring, str, i, substring.length,\
    \ StringComparison.OrdinalIgnoreCase) == 0) {\n                found = true;\n\
    \                break;\n            }\n        }\n        if (found)\n      \
    \      times++;\n        return times;", "        long result = 0;\n        foreach\
    \ (var c in substring) {\n            if (str[str.IndexOf(c, StringComparison.InvariantCultureIgnoreCase)]\
    \ != '\\0') {\n                ++result;\n            }\n        }\n        return\
    \ result;", "        long matchCount = 0;\n        bool isCharSet = str.Length\
    \ == substring.Length;\n        // The two strings must have the same length.\n\
    \        if (str == substring)\n            return matchCount;\n        if (str\
    \ == null || substring == null)\n            return 0;\n\n        int startIndex\
    \ = 0, endIndex = 0;\n        while (true) {\n            // Find first character\
    \ in the substring that does not have a match.\n            startIndex = 0;\n\
    \            while (startIndex < substring.Length && startIndex < str.Length &&\
    \ str[startIndex] == substring[startIndex])\n                startIndex++;\n \
    \           endIndex = startIndex;\n\n            // If we found no match, exit\
    \ the loop.\n            if (startIndex == endIndex)\n                return matchCount;\n\
    \n            // If we didn't find any match, but there are characters to match,\
    \ exit the loop.\n            if (startIndex >= substring.Length)\n          \
    \      return matchCount + str.Length;\n\n            // If we found a match,\
    \ keep looking for the next character.\n            while (startIndex < endIndex)\
    \ {\n                endIndex++;\n\n                // If we found a match, keep\
    \ looking for the next character.\n                if (str[startIndex] == substring[startIndex])\n\
    \                    startIndex++;\n                else\n                   \
    \ break;\n            }\n            // Increment the match count by one if there\
    \ is a match.\n            if (startIndex == endIndex)\n                matchCount++;\n\
    \        }", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n\
    \            return 0;\n        var list = new List<string>();\n        bool found\
    \ = false;\n        for (int i = 0; i < str.Length; i++) {\n            if (str.Contains(substring,\
    \ i)) {\n                list.Add(str.Substring(i));\n                found =\
    \ true;\n            }\n            if (found && i + 1 < str.Length && !str.Contains(substring,\
    \ i + 1))\n                list.Add(str.Substring(i + 1));\n        }\n      \
    \  return list.Count(l => l.Equals(substring));", "        if (str == null ||\
    \ str == \"\" || substring == null || substring == \"\")\n            return 0L;\n\
    \        long result = 0L;\n        long minLen = str.Length - substring.Length;\n\
    \        long maxLen = str.Length;\n        long minIndex = str.IndexOf(substring);\n\
    \        long maxIndex = minIndex + substring.Length;\n        while (true) {\n\
    \            long len = minIndex <= maxIndex ? minIndex - maxIndex : maxIndex\
    \ - minIndex;\n            if (len > minLen) {\n                result += (len\
    \ - minLen);\n                minIndex = str.IndexOf(substring, minIndex + len);\n\
    \            }\n            if (len < maxLen) {\n                maxIndex = str.IndexOf(substring,\
    \ maxIndex - len);\n            }\n            if (minIndex < maxIndex) {\n  \
    \              return result + 1;\n            }\n        }", "        var counter\
    \ = 0;\n\n        for (int i = 0; i < str.Length - substring.Length + 1; i++)\
    \ {\n            var j = 0;\n            for (; j < substring.Length && str[i\
    \ + j] == substring[j]; j++);\n            counter += (j == substring.Length)\
    \ ? 0 : 1;\n        }\n\n        return counter;", "        long count = 0;\n\
    \        foreach (var c in str) {\n            if (c == substring[0]) {\n    \
    \            count++;\n                str = str.Remove(0, 1);\n            }\
    \ else if (c == substring[1]) {\n                count++;\n                str\
    \ = str.Remove(0, 2);\n            } else if (c == substring[2]) {\n         \
    \       count++;\n                str = str.Remove(0, 3);\n            } else\
    \ if (c == substring[3]) {\n                count++;\n                str = str.Remove(0,\
    \ 4);\n            } else if (c == substring[4]) {\n                count++;\n\
    \                str = str.Remove(0, 5);\n            } else if (c == substring[5])\
    \ {\n                count++;\n                str = str.Remove(0, 6);\n     \
    \       } else if (c == substring[6]) {\n                count++;\n          \
    \      str = str.Remove(0, 7);\n            } else if (c == substring[7]) {\n\
    \                count++;\n                str = str.Remove(0, 8);\n         \
    \   } else if (c == substring[8]) {\n                count++;\n              \
    \  str = str.Remove(0, 9);\n            } else if (c == substring[9]) {\n    \
    \            count++;\n                str = str.Remove(0, 10);\n            }\
    \ else if (c == substring[10]) {\n                count++;\n                str\
    \ = str.Remove(0, 11);\n            } else if (c == substring[11]) {\n       \
    \         count++;\n                str = str.Remove(0, 12);\n            } else\
    \ if (c == substring[12]) {\n                count++;\n                str = str.Remove(0,\
    \ 13);\n            } else if (c == substring[13]) {\n                count++;\n\
    \                str = str.Remove(0, 14);\n            } else if (c == substring[14])\
    \ {\n                count++;\n                str = str.Remove(0, 15);\n    \
    \        } else if (c == substring[15]) {\n                count++;\n        \
    \        str = str.Remove(0, 16);\n            } else if (c == substring[16])\
    \ {\n                count++;\n                str = str.Remove(0, 17);\n    \
    \        } else if (c == substring[17]) {\n                count++;\n        \
    \        str = str.Remove(0, 18);\n            } else if (c == substring[18])\
    \ {\n                count++;\n                str = str.Remove(0, 19);\n    \
    \        } else if (c == substring[19]) {\n                count++;\n        \
    \        str = str.Remove(0, 20);\n            } else if (c == substring[20])\
    \ {\n                count++;\n                str = str.Remove(0, 21);\n    \
    \        } else if (c == substring[21]) {\n                count++;\n        \
    \        str = str.Remove(0, 22);\n            } else if (c == substring[22])\
    \ {\n                count++;\n                str = str.Remove(0, 23);\n    \
    \        } else if (c == substring[23]) {\n                count++;\n        \
    \        str = str.Remove(0, 24);\n            } else if (c == substring[24])\
    \ {\n                count++;\n                str = str.Remove(0, 25);\n    \
    \        } else if (c == substring[25]) {\n                count++;\n        \
    \        str = str.Remove(0, 26);\n            } else if (c == substring[26])\
    \ {\n                count++;\n                str = str.Remove(0, 27);\n    \
    \        } else if (c == substring[27]) {\n                count++;\n        \
    \        str = str.Remove(0, 28);", "        if (str == null || substr == null)\
    \ {\n            throw new ArgumentException(\"Strings or substrings cannot be\
    \ null.\");\n        }\n\n        if (str.IndexOf(substring) == -1) {\n      \
    \      throw new ArgumentException(\"Strings cannot be empty.\");\n        }\n\
    \n        // Add one for each overlapping case\n        long result = 0;\n   \
    \     string sub1 = substring + \"\\0\";\n        string sub2 = substring + \"\
    \\0\\0\";\n        bool found = false;\n        for (int i = 0; i < str.Length;\
    \ i++) {\n            if (str[i] == substring[0]) {\n                if (str[i\
    \ + substring.Length] == substring[substring.Length - 1]) {\n                \
    \    found = true;\n                } else if (str[i + substring.Length] == substring[substring.Length\
    \ - 2]) {\n                    found = true;\n                    result += 2;\n\
    \                } else {\n                    result += 1;\n                }\n\
    \            }\n\n            if (found == true) {\n                if (sub1.IndexOf(str[i])\
    \ != -1) {\n                    if (sub2.IndexOf(str[i + substring.Length]) !=\
    \ -1) {\n                        result += 2;\n                    }\n       \
    \         } else {\n                    if (sub2.IndexOf(str[i + substring.Length])\
    \ != -1) {\n                        result += 1;\n                    }\n    \
    \            }\n                found = false;\n            }\n        }\n   \
    \     return result;", "        long result = 0;\n        for (int i = 0; i <\
    \ str.Length; i++) {\n            if (string.Compare(substring, str[i].ToString())\
    \ == 0) {\n                result++;\n            }\n        }\n        return\
    \ result;", '        return str.Length == 0 ? 0 : (str.IndexOf(substring, StringComparison.OrdinalIgnoreCase)
    + 1);', "        List<long> result = new List<long>();\n        if (str.IndexOf(substring)\
    \ != -1) { result.Add(1L); }\n        if (str.IndexOf(substring,0) == 0) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,0) == str.Length - 1) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,1) == 0) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,1) == str.Length - 1) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,2) == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,2)\
    \ == str.Length - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,3)\
    \ == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,3) == str.Length\
    \ - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,4) == 0) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,4) == str.Length - 1) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,5) == 0) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,5) == str.Length - 1) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,6) == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,6)\
    \ == str.Length - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,7)\
    \ == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,7) == str.Length\
    \ - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,8) == 0) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,8) == str.Length - 1) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,9) == 0) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,9) == str.Length - 1) { result.Add(1L); }\n        if\
    \ (str.IndexOf(substring,10) == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,10)\
    \ == str.Length - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,11)\
    \ == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,11) == str.Length\
    \ - 1) { result.Add(1L); }\n        if (str.IndexOf(substring,12) == 0) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,12) == str.Length - 1) { result.Add(1L);\
    \ }\n        if (str.IndexOf(substring,13) == 0) { result.Add(1L); }\n       \
    \ if (str.IndexOf(substring,13) == str.Length - 1) { result.Add(1L); }\n     \
    \   if (str.IndexOf(substring,14) == 0) { result.Add(1L); }\n        if (str.IndexOf(substring,14)\
    \ == str.Length - 1", "        // The result is a long because string are immutable\
    \ and we want to modify the result variable\n        long res = 0;\n        foreach\
    \ (char c in str) {\n            if (c == substring[0]) {\n                long\
    \ nextCount = HowManyTimes(str.Substring(1, str.Length - 1), substring);\n   \
    \             long lastCount = HowManyTimes(str.Substring(1, str.Length - 1),\
    \ substring);\n                if (lastCount > nextCount) {\n                \
    \    res += (lastCount - nextCount);\n                }\n            }\n     \
    \   }\n        return res;", "        if (str == null || str == \"\") {\n    \
    \        return 0L;\n        }\n        if (substring == null || substring ==\
    \ \"\") {\n            return 0L;\n        }\n\n        HashSet<string> seen =\
    \ new HashSet<string>();\n        long result = 1;\n        foreach (char c in\
    \ str.ToCharArray()) {\n            string sSubstr = substring.ToLowerInvariant();\n\
    \            if (seen.Contains(sSubstr)) {\n                sSubstr = sSubstr.ToUpperInvariant();\n\
    \                if (seen.Contains(sSubstr)) {\n                    result *=\
    \ 2;\n                }\n            }\n            if (sSubstr.Contains(c.ToString()))\
    \ {\n                seen = new HashSet<string>(seen.Union(new string[] { sSubstr\
    \ }).ToArray());\n                result += 1;\n            }\n        }\n\n \
    \       return result;", "        string fullSubstring = string.Join(\"\", str.Select(c\
    \ => c.ToString()));\n        return fullSubstring.Replace(substring, \"\").Length;",
  "        int n = str.Length;\n        int m = substring.Length;\n        long sum\
    \ = 0;\n        if (m > n)\n            return -1;\n        int[] d = new int[26];\n\
    \        Array.Fill(d,-1);\n        Dictionary<int, int> result = new Dictionary<int,\
    \ int>();\n        for (int i = 0; i < n; ++i) {\n            d[str[i] - 'a']++;\n\
    \            sum += d[str[i] - 'a'];\n            if (substring != str[i]) {\n\
    \                for (int j = 0; j < m; ++j) {\n                    if (j == 0)\n\
    \                        ++d[str[i] - (j + 'a')];\n                    else if\
    \ (j != 0)\n                        d[str[i] - (j + 'a')] = d[str[i] - (j + 'a')]\
    \ + d[str[i - 1] - (j + 'a')];\n                    if (substring == str[i - m])\n\
    \                        ++result[str[i] - (j + 'a')];\n                }\n  \
    \          }\n        }\n        long mostOccurrences = 0;\n        int max =\
    \ result.Keys.Max();\n        int maxKey = result.ElementAt(max).Key;\n      \
    \  foreach (int key in result.Keys) {\n            if (key >= maxKey) {\n    \
    \            mostOccurrences += result[key];\n                break;\n       \
    \     }\n        }\n        return mostOccurrences;", '        return str.Split().Where(x
    => x == substring).Count();', "        long ret = 0;\n        string searchStr\
    \ = \"(\" + substring + \")\";\n        int index = str.IndexOf(searchStr);\n\
    \        while (index >= 0) {\n            if (str.IndexOf(searchStr, index -\
    \ 1) >= 0) {\n                index = str.IndexOf(searchStr, index + 1);\n   \
    \         }\n            else if (str.IndexOf(searchStr, index + 1) == -1) {\n\
    \                index = str.IndexOf(searchStr, index + 2);\n            }\n \
    \           else {\n                ret++;\n                break;\n         \
    \   }\n        }\n        return ret;", "        if (str == null || substring\
    \ == null) return 0;\n        var res = 0;\n        foreach (var c in substring)\
    \ {\n            var index = str.IndexOf(c, 0);\n            if (index != -1)\
    \ {\n                var subIndex = str.IndexOf(substring, index+1);\n       \
    \         if (subIndex == -1) continue;\n                if (subIndex >= index)\
    \ res ++;\n            }\n        }\n        return res;", "        long count\
    \ = 0;\n        int len = substring.Length;\n\n        for (int i = 0; i < str.Length\
    \ - len; i++) {\n            if (str.Substring(i, len).Equals(substring)) {\n\
    \                count++;\n            }\n        }\n        return count;", " \
    \       long count = 0, i = 0;\n\n        while(str.IndexOf(substring, i) > -1)\
    \ {\n            count++;\n            i += substring.Length;\n        }\n\n \
    \       return count;", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\
    \ {\n            return 0;\n        }\n\n        // Sort substrings so we don't\
    \ have to check multiple overlapping substrings.\n        Array.Sort(substring.ToCharArray());\n\
    \n        // Create a hashset of substrings to check against each original string\n\
    \        var substrings = new HashSet<string>(substring);\n        var hashset\
    \ = new HashSet<string>(str);\n\n        // Return matches found\n        return\
    \ hashset.Intersect(substrings).Count;", "        // Using System.Linq means you\
    \ don't have to worry about edge cases\n        // where you go out of bounds\
    \ in your strings\n        var strs = str.Split(new char[] {'a'});\n        var\
    \ subs = substring.Split(new char[] {'a'});\n\n        // This loop goes through\
    \ all possible substring combinations. Note that we're not counting\n        //\
    \ \"aa\" in \"aaa\" here. So \"aa\" ends up being counted twice:\n        // >>>\
    \ for s1 in subs:\n        //         for s2 in subs:\n        //            \
    \ print \"%s==>%s\" % (s1, s2)\n        //             if (s1 == s2): continue\n\
    \        //             if (s1.Contains(s2)):\n        //                 print\
    \ 1\n        //                 break\n        //             print 0\n      \
    \  // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n    \
    \    // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n  \
    \      // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // aa==>aa\n        // 0==>aa\n        // aa==>aa\n        // 0==>aa\n\
    \        // ", "        long result = 0;\n        string original = str;\n   \
    \     string sub = substring;\n        StringBuilder builder = new StringBuilder(str);\n\
    \        do {\n            int originalIndex = original.IndexOf(sub, 0);\n   \
    \         if (originalIndex >= 0) {\n                string s = original.Substring(0,\
    \ originalIndex);\n                string ss = original.Substring(originalIndex);\n\
    \                string sss = sub;\n                string ssss = sub;\n     \
    \           string sssss = sub;\n                string ssssss = sub;\n      \
    \          string sssssss = sub;\n                string ssssssss = sub;\n   \
    \             builder.Remove(0, originalIndex);\n                builder.Insert(0,\
    \ s);\n                builder.Insert(0, ss);\n                builder.Insert(0,\
    \ sss);\n                builder.Insert(0, ssss);\n                builder.Insert(0,\
    \ sssss);\n                builder.Insert(0, ssssss);\n                builder.Insert(0,\
    \ sssssss);\n                builder.Insert(0, ssssssss);\n                builder.Insert(0,\
    \ sssssssss);\n                builder.Insert(0, ssssssssss);\n              \
    \  builder.Insert(0, sssssssssss);\n                builder.Insert(0, ssssssssssss);\n\
    \                builder.Insert(0, sssssssssssss);\n                builder.Insert(0,\
    \ ssssssssssssss);\n                builder.Insert(0, sssssssssssssss);\n    \
    \            builder.Insert(0, ssssssssssssss);\n                builder.Insert(0,\
    \ ssssssssssssssss);\n                builder.Insert(0, sssssssssssssssss);\n\
    \                builder.Insert(0, ssssssssssssssssss);\n                builder.Insert(0,\
    \ ssssssssssssssssssss);\n                builder.Insert(0, ssssssssssssssssssss);\n\
    \                builder.Insert(0, ssssssssssssssssssss);\n                builder.Insert(0,\
    \ ssssssssssssssssssss);\n                builder.Insert(0, sssssssssssssssssssss);\n\
    \                builder.Insert(0, ssssssssssssssssssssss);\n                builder.Insert(0,\
    \ ssssssssssssssssssssss);\n                builder.Insert(0, ssssssssssssssssssssss);\n\
    \                builder.Insert(0, ssssssssssssssssssssssss);\n              \
    \  builder.Insert(0, ssssss", "        if (String.IsNullOrEmpty(str)) {\n    \
    \        throw new ArgumentException(\"str\", \"The input string cannot be empty\
    \ or null.\");\n        }\n        if (String.IsNullOrEmpty(substring)) {\n  \
    \          throw new ArgumentException(\"substring\", \"The substring cannot be\
    \ empty or null.\");\n        }\n        if (str.Contains(substring)) {\n    \
    \        return (str.Count(i => i == substring));\n        }\n        else {\n\
    \            long numberOfTimes = 0;\n            int left = 0;\n            int\
    \ right = str.Length - 1;\n            while (left <= right) {\n             \
    \   int mid = (left + right) / 2;\n                if (string.Compare(str, substring,\
    \ 0, mid, StringComparison.OrdinalIgnoreCase) == 0) {\n                    numberOfTimes\
    \ += mid - left;\n                    left = mid;\n                }\n       \
    \         else if (string.Compare(str, substring, mid, str.Length, StringComparison.OrdinalIgnoreCase)\
    \ == 0) {\n                    numberOfTimes += right - mid;\n               \
    \     right = mid;\n                }\n                else {\n              \
    \      int i1 = mid;\n                    int i2 = str.Length - 1;\n         \
    \           while (i1 > 0 && i2 > 0 && string.Compare(str[i1], str[i2], 0, i1,\
    \ StringComparison.OrdinalIgnoreCase) == 0) {\n                        i1--;\n\
    \                        i2--;\n                    }\n                    if\
    \ (i2 <= i1) {\n                        numberOfTimes += mid - left;\n       \
    \                 left = mid;\n                    }\n                    else\
    \ {\n                        numberOfTimes += right - mid;\n                 \
    \       right = mid;\n                    }\n                }\n            }\n\
    \            return (numberOfTimes);\n        }", "        long counter = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            if (str.Substring(i,\
    \ substring).Equals(substring)) {\n                counter++;\n            }\n\
    \        }\n        return counter;", "        // Use a hashmap to count how many\
    \ times each character is repeated. \n        Dictionary<string, long> count =\
    \ new Dictionary<string, long>();\n        long count = 0;\n        // If the\
    \ string has no characters, return zero.\n        if (!String.IsNullOrEmpty(str))\
    \ {\n            // Iterate over every character in the string.\n            for\
    \ (int i = 0; i < str.Length; i++) {\n                // Get the char at that\
    \ index.\n                char ch = str[i];\n                // Get the substring\
    \ that we want to find the count of.\n                string sub = substring.Substring(0,\
    \ 1);\n                // If the char matches the substring, we increment the\
    \ count by one.\n                if (ch == sub[0]) {\n                    count++;\n\
    \                }\n                // If we find a substring that does not match\
    \ the char we're looking for, then we decrement the count.\n                else\
    \ {\n                    count--;\n                }\n                // If we\
    \ find a character that does not match the substring we're looking for, then we\
    \ decrement the count.\n                if (count == 0) {\n                  \
    \  count--;\n                }\n                // If the count reaches 0, then\
    \ we have found the substring we were looking for.\n                if (count\
    \ == 0) {\n                    // Set the count at that character to the current\
    \ count.\n                    count[ch] = count;\n                    break;\n\
    \                }\n            }\n        }\n        return count;", '        return
    str.Count(s => s.IndexOf(substring, StringComparison.InvariantCultureIgnoreCase)
    >= 0);', "        long count = 0;\n        HashSet<string> stringSet = new HashSet<string>();\n\
    \        stringSet.Add(substring);\n        int startIndex = 0;\n        for (int\
    \ index = str.IndexOf(substring, startIndex); index >= 0; index = str.IndexOf(substring,\
    \ startIndex)) {\n            stringSet.Add(str.Substring(index, substring.Length));\n\
    \            startIndex = index + 1;\n        }\n        if (stringSet.Contains(str))\
    \ {\n            return count;\n        }\n        foreach (string str2 in stringSet)\
    \ {\n            count += HowManyTimes(str, str2);\n        }\n        return\
    \ count;", "        var sb = new StringBuilder();\n        long result = 0;\n\
    \        foreach (var character in substring) {\n            sb.Append(character);\n\
    \            result += Enumerable.Range(0, str.Length - sb.Length).Where(i =>\
    \ str.Substring(i,sb.Length).Equals(sb.ToString())).Count();\n            sb.Remove(sb.Length\
    \ - 1);\n        }\n        return result;", "        string lower = substring.ToLower();\n\
    \        string upper = substring.ToUpper();\n\n        long count = 0;\n    \
    \    long len = str.Length;\n        long upperLen = upper.Length;\n        long\
    \ lowerLen = lower.Length;\n\n        if (len > 0)\n        {\n            int\
    \ i = 0;\n            int j = 0;\n            while (true)\n            {\n  \
    \              if (i >= len)\n                    break;\n\n                i\
    \ = str.IndexOf(substring, i);\n                if (i == -1)\n               \
    \     break;\n\n                count++;\n                i += lowerLen;\n   \
    \             while (true)\n                {\n                    if (j >= upperLen)\n\
    \                        break;\n\n                    j = upper.IndexOf(upper,\
    \ j);\n                    if (j == -1)\n                        break;\n\n  \
    \                  count++;\n                    j += lowerLen;\n            \
    \    }\n                i += lowerLen;\n            }\n        }\n        return\
    \ count;", '        return str.Split(substring).Length;', "        long result\
    \ = 0;\n        if (substring.Length == 0)\n            return 0;\n        if\
    \ (string.IsNullOrEmpty(str))\n            return 0;\n        str = str.ToLower();\n\
    \        substring = substring.ToLower();\n        str = str.Substring(0, substring.Length);\n\
    \        substring += substring.Substring(0, 1);\n        int length = str.Length;\n\
    \        int start = 0;\n        while (true) {\n            int startIndex =\
    \ str.IndexOf(substring, start, StringComparison.InvariantCulture);\n        \
    \    if (startIndex == -1)\n                return result;\n            string\
    \ sub = str.Substring(start, startIndex - start);\n            int sublength =\
    \ sub.Length;\n            if (sublength < substring.Length)\n               \
    \ return result;\n            start += substring.Length - sublength;\n       \
    \     if (start >= length)\n                return result;\n            result++;\n\
    \        }", "        long count = 0;\n        char[] charArray = str.ToCharArray();\n\
    \        char[] charArraySub = substring.ToCharArray();\n        // Search for\
    \ each char of string in substring\n        foreach (char c in charArray) {\n\
    \            if (c.Equals(charArraySub[0], StringComparison.OrdinalIgnoreCase))\
    \ {\n                count += 1;\n                charArraySub = charArraySub.Skip(1).ToArray();\n\
    \            }\n            else {\n                break;\n            }\n  \
    \      }\n        return count;", "        string trimmedStr = str.Trim().ToLowerInvariant();\n\
    \        string trimmedSub = substring.Trim().ToLowerInvariant();\n        long\
    \ sum = 0;\n        int length = str.Length;\n        int subLength = substring.Length;\n\
    \        for (int i = 0; i < length; i++) {\n            int count1 = trimmedStr.IndexOf(trimmedSub,\
    \ 0, i);\n            int count2 = trimmedStr.IndexOf(trimmedSub, i, length);\n\
    \            if (count1 < 0 || count2 < 0 || count1 < count2) break;\n       \
    \     int count3 = trimmedStr.IndexOf(substring, trimmedSub, 0, count1);\n   \
    \         int count4 = trimmedStr.IndexOf(substring, trimmedSub, count1, length);\n\
    \            if (count3 < 0 || count4 < 0) break;\n            int count5 = trimmedStr.IndexOf(substring,\
    \ trimmedSub, 0, count3);\n            int count6 = trimmedStr.IndexOf(substring,\
    \ trimmedSub, count3, length);\n            if (count5 < 0 || count6 < 0) break;\n\
    \            sum += (count5 - count6);\n        }\n        return sum;", "   \
    \     HashSet<string> set = new HashSet<string>();\n        HashSet<string> setOfSub\
    \ = new HashSet<string>();\n        if (str.Length > substring.Length) return\
    \ 0L;\n\n        long count = 0;\n        if (str.Length >= substring.Length)\
    \ {\n            foreach (char c in str.ToLower()) {\n                foreach\
    \ (char s in substring.ToLower()) {\n                    if (s.Equals(c)) {\n\
    \                        set.Add(s);\n                    }\n                \
    \    else {\n                        setOfSub.Add(s);\n                    }\n\
    \                }\n            }\n\n            foreach (string sub in setOfSub)\
    \ {\n                foreach (string s in set) {\n                    if (sub.Equals(s))\
    \ count++;\n                }\n            }\n        }\n\n        return count;",
  "        var len = str.Length;\n        if (len == 0) return 0;\n        var found\
    \ = str.IndexOf(substring);\n        if (found >= 0) {\n            var count\
    \ = 1;\n            for (var i = found + 1; i < len; i++)\n                if\
    \ (str[i] == substring[i - 1])\n                    count++;\n            return\
    \ count;\n        }\n        return 0;", "        long times = 0, lastCharCount\
    \ = 0;\n        for (int i = 0; i < str.Length; i++)\n            if (str[i] ==\
    \ substring[lastCharCount]) times++;\n            else { lastCharCount = i; break;\
    \ }\n        return times;", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\
    \ return 0;\n        if (substring == str) return 1;\n        var charList = str.ToCharArray();\n\
    \        var subList = substring.ToCharArray();\n        var count = 0;\n    \
    \    for (var i = 0; charList.Length > i; i++) {\n            if (subList.Contains(charList[i]))\
    \ count++;\n        }\n        return count;", "        // Create a dictionary\
    \ to count how many times each substring appears\n        var substringDict =\
    \ str.GroupBy(x => substring)\n                               .ToDictionary(x\
    \ => x.Key, x => x.Count());\n\n        // Count how many times each substring\
    \ appears in the original string\n        long ret = 0;\n        foreach (var\
    \ s in str.GroupBy(x => substring))\n            ret = Math.Max(ret, substringDict[s.Key].Count);\n\
    \n        return ret;", "        // We need to use a HashSet<> to keep track of\
    \ how many times the substring has been seen so far\n        // We use a HashSet<>\
    \ because it's more efficient to check membership than using the .Contains() method\n\
    \        // The HashSet<> can grow quite large and slow down search. Using a List<>\
    \ is a better solution because we will\n        // be adding elements to the list\
    \ very often.\n        HashSet<string> seen = new HashSet<string>();\n       \
    \ List<long> results = new List<long>();\n\n        // Loop through the original\
    \ string and count how many times the substring has been seen so far\n       \
    \ for (int i = 0; i < str.Length; i++)\n        {\n            if (substring.Equals(str[i]))\n\
    \            {\n                // This substring has been seen before, increment\
    \ the counter for this substring\n                if (seen.Contains(str[i]))\n\
    \                    seen.Add(str[i]);\n                else\n               \
    \     seen.Add(str[i]); // Don't add it again, we'll increment it on the next\
    \ occurence\n\n                // We have found a substring that has already been\
    \ seen, increase the counter\n                // If this substring wasn't seen\
    \ before, then just increment the counter\n                if (!seen.Contains(substring))\n\
    \                    seen.Add(substring);\n            }\n            else\n \
    \           {\n                // This substring isn't the substring we are searching\
    \ for and we've been \"seen\" more than once,\n                // so we need to\
    \ decrease the counter for this substring and increase the counter for\n     \
    \           // any substring that is \"seen\" more than once\n               \
    \ if (seen.Contains(str[i]))\n                    seen.Remove(str[i]);\n     \
    \       }\n        }\n\n        // If we only have one substring then return it\n\
    \        if (seen.Count == 1)\n        {\n            results.Add(1);\n      \
    \  }\n        else\n        {\n            // Loop through every string in the\
    \ HashSet and add 1 to the list if the substring has been seen more than once\n\
    \            foreach (string item in seen)\n            {\n                if\
    \ (seen.Count > 1)\n                    results.Add(results.Sum(item => 1));\n\
    \            }\n        }\n\n        // Sort the results List from highest to\
    \ lowest\n        results = results.OrderByDescending(item => item).ToList();\n\
    \n        // Return the total number of overlapping substring times\n        return\
    \ (long)results.First();", '        return HowManyTimes(new string(str), substring,
    0);', "        if (substring == null)\n            return 0;\n\n        long count\
    \ = str.IndexOf(substring);\n        if (count != -1)\n            return count;\n\
    \n        count = str.IndexOf(substring, StringComparison.InvariantCulture);\n\
    \        if (count != -1)\n            return count;\n\n        foreach (string\
    \ str2 in str.Split(',').Select(s => s.Trim()).Where(s => s.Length > 0).ToArray())\
    \ {\n            count = str.IndexOf(str2, StringComparison.InvariantCulture);\n\
    \            if (count != -1)\n                return count;\n        }\n    \
    \    return 0;", '        return HowManyTimes(new HashSet<long>(str.ToCharArray()),
    new HashSet<long>(substring.ToCharArray()));', "        string lower = string.Concat(Enumerable.Repeat(substring,\
    \ str.Count(x => x == char.ToLower(substring))).Select(x => x.ToLower()));\n \
    \       string upper = string.Concat(Enumerable.Repeat(substring, str.Count(x\
    \ => x == char.ToUpper(substring))).Select(x => x.ToUpper()));\n        string\
    \ full = string.Concat(Enumerable.Repeat(substring, str.Count(x => x == substring)).Select(x\
    \ => x));\n        long[] counts = new long[] { 0, 0 };\n        if (string.IsNullOrEmpty(lower)\
    \ || string.IsNullOrEmpty(upper) || string.IsNullOrEmpty(full))\n            return\
    \ 0;\n        if (str.Length == 0)\n            return 0;\n        if (substring.Length\
    \ == 0)\n            return 0;\n        foreach (var c in lower)\n           \
    \ counts[str.Count(x => x == c)] += 1;\n        foreach (var c in upper)\n   \
    \         counts[str.Count(x => x == c)] += 1;\n        foreach (var c in full)\n\
    \            counts[str.Count(x => x == c)] += 1;\n        return counts[0];",
  "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {\n \
    \           return 0;\n        }\n        long count = 0, lenght = str.Length;\n\
    \        int count = 0;\n        string s0 = string.Empty;\n        string sub\
    \ = string.Empty;\n        for (int i = 0; i < lenght; i++) {\n            s0\
    \ = s0 + str[i];\n            if (s0.Contains(substring)) {\n                count++;\n\
    \                for (int j = 0; j < lenght; j++) {\n                    sub =\
    \ sub + str[j];\n                    if (sub.Contains(substring)) {\n        \
    \                count++;\n                    }\n                }\n        \
    \    }\n        }\n        return count;", "        string hash = GetHash(str,\
    \ substring);\n        return GetCount(hash, str, substring);", "        Debug.Assert(!string.IsNullOrWhiteSpace(str));\n\
    \        Debug.Assert(!string.IsNullOrWhiteSpace(substring));\n\n        // https://stackoverflow.com/questions/2637646/count-the-number-of-occurrences-of-a-string-within-another-string-in-c-sharp\n\
    \        long count = (str.Length - str.Replace(substring, string.Empty).Length)\
    \ / substring.Length;\n        count = Math.Min(count, str.Length - str.IndexOf(substring,\
    \ 0));\n        return count;", "        long count = 0;\n        foreach (char\
    \ c in str) {\n            if (c == substring[0]) {\n                count +=\
    \ HowManyTimes(str.Substring(1, str.Length - 2), substring);\n            }\n\
    \        }\n        return count;", "        string original = str.ToLower();\n\
    \        string sub = substring.ToLower();\n\n        long count = 0;\n      \
    \  int lensub = sub.length;\n        int lenstr = original.Length;\n        char[]\
    \ charArray = sub.GetChars();\n        int[] charArrayIndex = new int[lensub];\n\
    \        int i = 0;\n\n        for (; i < lenstr; ++i) {\n            int j =\
    \ 0, k = 0;\n            while (j < lensub) {\n                char ch = charArray[j++];\n\
    \                if (ch == str[i]) {\n                    charArrayIndex[k] =\
    \ i;\n                    ++k;\n                }\n                ++j;\n    \
    \        }\n            count += k;\n        }\n        return count;", "    \
    \    string allSubstrings = string.Join(\"\", str.Select((x, i) => new { x, i\
    \ })).ToLower();\n        string allSubstringsWithin = string.Join(\"\", str.Select((x,\
    \ i) => new { x, i })).ToLower();\n\n        Dictionary<string, long> substringCounts\
    \ = new Dictionary<string, long>();\n\n        foreach (string s in allSubstrings.Split(substring).OrderBy(x\
    \ => x))\n        {\n            if (substringCounts.ContainsKey(s))\n       \
    \     {\n                substringCounts[s]++;\n            }\n            else\n\
    \            {\n                substringCounts.Add(s, 1);\n            }\n  \
    \      }\n\n        long sum = 0;\n        foreach (KeyValuePair<string, long>\
    \ pair in substringCounts)\n        {\n            sum += pair.Value;\n      \
    \  }\n\n        return sum;", "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\
    \ {\n            return 0L;\n        }\n        var startIndex = str.IndexOf(substring);\n\
    \        if (startIndex < 0)\n            return 0;\n        var endIndex = str.IndexOf(substring,\
    \ startIndex + 1);\n        if (endIndex < 0)\n            endIndex = str.Length;\n\
    \        return endIndex - startIndex;", "        if (str == null || str == \"\
    \" || substring == null || substring == \"\") {\n            return 0;\n     \
    \   }\n\n        long times = 0;\n\n        char[] chars = str.ToLower().ToCharArray();\n\
    \        char[] subs = substring.ToLower().ToCharArray();\n\n        long startIndex\
    \ = Array.IndexOf(chars, substring);\n        long endIndex = Array.IndexOf(chars,\
    \ substring, startIndex + 1);\n\n        for (int i = startIndex; i <= endIndex;\
    \ i++) {\n            if (chars[i] != subs[i - startIndex]) {\n              \
    \  break;\n            }\n\n            times++;\n        }\n\n        return\
    \ times;", "        long count = 0;\n        int strLen = str.Length;\n      \
    \  int substringLen = substring.Length;\n        char[] strArray = str.ToCharArray();\n\
    \        char[] substringArray = substring.ToCharArray();\n        StringBuilder\
    \ builder = new StringBuilder();\n        int pos = 0;\n        bool found = false;\n\
    \        bool endFound = false;\n        bool startFound = false;\n        while\
    \ (pos < strLen) {\n            while (pos < strLen && !found) {\n           \
    \     char c = strArray[pos];\n                if (char.IsUpper(c) || char.IsLower(c))\
    \ {\n                    builder.Append(c);\n                    found = true;\n\
    \                }\n                pos++;\n            }\n            if (pos\
    \ == strLen) {\n                found = false;\n                endFound = true;\n\
    \                break;\n            }\n            if (!found) {\n          \
    \      found = true;\n                startFound = true;\n            }\n    \
    \        if (!startFound) {\n                found = false;\n                startFound\
    \ = false;\n            }\n            if (!found && endFound) {\n           \
    \     found = true;\n                endFound = false;\n            }\n      \
    \      if (found) {\n                count = 0;\n                for (int i =\
    \ pos; i < substringArray.Length && !found; i++) {\n                    char c\
    \ = substringArray[i];\n                    if (char.IsUpper(c) || char.IsLower(c))\
    \ {\n                        builder.Append(c);\n                        found\
    \ = true;\n                    }\n                    count++;\n             \
    \   }\n            }\n        }\n        if (count > 0) {\n            return\
    \ count;\n        }\n        else {\n            return -1;\n        }", "   \
    \     long counter = 0;\n        foreach (char c in substring) {\n           \
    \ counter = str.IndexOf(substring, counter) + counter;\n        }\n        return\
    \ counter;", "        bool isOverlap = false;\n        int times = 0;\n      \
    \  foreach(char c in substring) {\n            bool findCharInString = str.Contains(c);\n\
    \            if(!findCharInString) {\n                if(!isOverlap) {\n     \
    \               times ++;\n                    isOverlap = true;\n           \
    \     } else {\n                    times ++;\n                    isOverlap =\
    \ false;\n                }\n            }\n        }\n        return times;",
  "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n   \
    \         return 0;\n        var result = new long[substring.Length];\n      \
    \  for (var i = 0; i < substring.Length; i++)\n            result[i] = str.IndexOf(substring,\
    \ i, StringComparison.Ordinal);\n        // If all chars are matched, return the\
    \ length of the string\n        if (result.All(c => c>=0))\n            return\
    \ str.Length;\n        long ret = 0;\n        long max = result.Max();\n     \
    \   for (int i = 0; i < max; i++)\n            ret += result[i];\n        return\
    \ ret;", "        long count = 0;\n        foreach (char c in str) {\n       \
    \     if (c == substring[0]) count++;\n            if (c == substring[1]) count++;\n\
    \            if (c == substring[2]) count++;\n            if (c == substring[3])\
    \ count++;\n            if (c == substring[4]) count++;\n            if (c ==\
    \ substring[5]) count++;\n            if (c == substring[6]) count++;\n      \
    \      if (c == substring[7]) count++;\n            if (c == substring[8]) count++;\n\
    \            if (c == substring[9]) count++;\n            if (c == substring[10])\
    \ count++;\n            if (c == substring[11]) count++;\n            if (c ==\
    \ substring[12]) count++;\n            if (c == substring[13]) count++;\n    \
    \        if (c == substring[14]) count++;\n            if (c == substring[15])\
    \ count++;\n            if (c == substring[16]) count++;\n            if (c ==\
    \ substring[17]) count++;\n            if (c == substring[18]) count++;\n    \
    \        if (c == substring[19]) count++;\n            if (c == substring[20])\
    \ count++;\n            if (c == substring[21]) count++;\n            if (c ==\
    \ substring[22]) count++;\n            if (c == substring[23]) count++;\n    \
    \        if (c == substring[24]) count++;\n            if (c == substring[25])\
    \ count++;\n            if (c == substring[26]) count++;\n            if (c ==\
    \ substring[27]) count++;\n            if (c == substring[28]) count++;\n    \
    \        if (c == substring[29]) count++;\n            if (c == substring[30])\
    \ count++;\n            if (c == substring[31]) count++;\n            if (c ==\
    \ substring[32]) count++;\n            if (c == substring[33]) count++;\n    \
    \        if (c == substring[34]) count++;\n            if (c == substring[35])\
    \ count++;\n            if (c == substring[36]) count++;\n            if (c ==\
    \ substring[37]) count++;\n            if (c == substring[38]) count++;\n    \
    \        if (c == substring[39]) count++;\n            if (c == substring[40])\
    \ count++;\n            if (c == substring[41]) count++;\n            if (c ==\
    \ substring[42]) count++;\n            if (c == substring[43]) count++;\n    \
    \        if (c == substring[44]) count++;\n            if (c == substring[45])\
    \ count++;\n            if (c == substring[46]) count++;\n            if (c ==\
    \ substring[47]) count++;\n            if (c == substring[48]) count++;\n    \
    \        if (c == substring[49]) count++;\n            if (c == substring[50])\
    \ count++;\n            if (c == substring[51]) count++;\n            if (c ==\
    \ substring[52]) count++;\n            if (c == substring[53]) count++;\n    \
    \        if (c == substring[54]) count++;\n            if (c == substring[55])\
    \ count++;\n            if (c == substring[56]) ", "        var pattern = new\
    \ Regex(substring);\n        var result = pattern.Matches(str).Count();\n    \
    \    return (long)result;", "        long sum = 0;\n        foreach (char c in\
    \ str) {\n            if (c == substring[0]) {\n                sum += 1;\n  \
    \              for (int i = 1; i < substring.Length; i++) {\n                \
    \    if (c != substring[i]) {\n                        sum += 1;\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n        return sum;", "        // return 0 if str is empty or substring\
    \ is empty.\n        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n\
    \            return 0;\n        // If str is empty, return 0.\n        if (str.Length\
    \ == 0)\n            return 0;\n        // If substring is empty, return str.Length.\n\
    \        if (substring.Length == 0)\n            return str.Length;\n        //\
    \ Get all occurrences of substring in str (overlapping)\n        var occurrences\
    \ = str.IndexOf(substring) + substring.Length;\n        var count = str.Count(str\
    \ => str.IndexOf(substring, 0, occurrences) >= occurrences);\n        return count;",
  "        return str.Count(s1 => substring.IndexOf(s1, StringComparison.OrdinalIgnoreCase)\
    \ >= 0) * substring\n                .Count(s1 => str.IndexOf(s1, StringComparison.OrdinalIgnoreCase)\
    \ >= 0);", "        long result = 0;\n        int startIndex = 0;\n        while\
    \ (startIndex < str.Length - substring.Length) {\n            if (str.Substring(startIndex,\
    \ substring.Length) == substring) {\n                startIndex += substring.Length;\n\
    \                result++;\n            }\n            startIndex++;\n       \
    \ }\n        return result;", '        return HowManyTimesCSharp(str, substring,
    false);', '        return str.Split(substring, StringSplitOptions.None).Length;',
  "        if (str == null) throw new ArgumentNullException(\"str\");\n        if\
    \ (substring == null) throw new ArgumentNullException(\"substring\");\n      \
    \  if (str.Length == 0) throw new ArgumentException(\"Str cannot be empty!\");\n\
    \        if (substring.Length == 0) throw new ArgumentException(\"Substring cannot\
    \ be empty!\");\n\n        string allChars = string.Concat(str.Select(c => (char)c).ToArray());\n\
    \        long result = 0;\n        long start = 0;\n        long index = 0;\n\
    \        long index2 = 0;\n        char startChar = ' ';\n        char currentChar\
    \ = ' ';\n        long indexChar = 0;\n        long indexChar2 = 0;\n        bool\
    \ firstChar = true;\n        bool found = false;\n        bool found2 = false;\n\
    \        bool isCharAlreadyInSubString = false;\n\n        for (int i = 0; i <\
    \ substring.Length; i++) {\n            startChar = substring[i];\n          \
    \  start = 0;\n            isCharAlreadyInSubString = false;\n            currentChar\
    \ = ' ';\n            indexChar = 0;\n            indexChar2 = 0;\n          \
    \  for (int j = 0; j < str.Length; j++) {\n                if (currentChar ==\
    \ startChar) {\n                    if (firstChar) {\n                       \
    \ index++;\n                        index2 = 0;\n                        firstChar\
    \ = false;\n                    }\n                    else {\n              \
    \          index2++;\n                    }\n                    isCharAlreadyInSubString\
    \ = true;\n                }\n                currentChar = str[j];\n        \
    \        if (isCharAlreadyInSubString) {\n                    indexChar++;\n \
    \                   indexChar2++;\n                }\n                else {\n\
    \                    if (indexChar >= index2) {\n                        if (indexChar2\
    \ >= index) {\n                            found = true;\n                   \
    \         result = 1;\n                            indexChar = 0;\n          \
    \                  indexChar2 = 0;\n                            startChar = '\
    \ ';\n                            currentChar = ' ';\n                       \
    \     index = index2;\n                            isCharAlreadyInSubString =\
    \ false;\n                            break;\n                        }\n    \
    \                }\n                }\n            }\n            if (found &&\
    \ !found2) {\n                result = 1;\n                found = false;\n  \
    \              startChar = ' ';\n                currentChar = ' ';\n        \
    \        index = index2;\n                isCharAlreadyInSubString = false;\n\
    \            }\n            if (!found && found2) {\n                found2 =\
    \ false;\n                result = 1;\n                startChar = ' ';\n    \
    \            currentChar = ' ';\n                index = index2;\n           \
    \     isCharAlreadyInSubString = false;\n            }\n        }\n        return\
    \ result;", "        long n = str.Length;\n        long result = 1;\n        foreach\
    \ (char c in substring) {\n            n = n - 1;\n            if (n >= 0)\n \
    \               result++;\n            else\n                break;\n        }\n\
    \        if (n < 0)\n            result = 0;\n        return result;", "     \
    \   long count = 0;\n        for (int i = 0; i <= str.Length - substring.Length;\
    \ i++) {\n            string sub = str.Substring(i, substring.Length);\n     \
    \       if (sub.ToUpper() == substring.ToUpper()) {\n                count++;\n\
    \            }\n        }\n        return count;", "        string pattern = String.Format(\"\
    (?<={0})\", substring);\n        long result = -1;\n        try {\n          \
    \  Regex r = new Regex(pattern);\n            result = r.Matches(str).Count;\n\
    \        } catch (ArgumentException) {\n            // If pattern not found, just\
    \ return -1, indicating not found\n        }\n        return result;", "     \
    \   if (str == \"\" || substring == \"\") return 0;\n        // Find all possible\
    \ substrings\n        var substrings = Enumerable.Range(0, str.Length).Select(i\
    \ => str.Substring(i)).ToList();\n        // Get all possible substrings from\
    \ substrings containing substring\n        var substringsOfStr = Enumerable.Range(0,\
    \ substrings.Count).Select(i => substrings.ElementAt(i)).Where(x => x.Contains(substring)).ToList();\n\
    \        // Return count of overlapping substrings\n        return substringsOfStr.Count();",
  '        return Regex.Matches(str, substring).Count.LongCount();', "        if (str\
    \ == null || substring == null) return 0L;\n        string sb = string.Join(\"\
    \", Enumerable.Range(0, str.Length).Select(i => str[i]));\n        string ss =\
    \ string.Join(\"\", Enumerable.Range(0, substring.Length).Select(i => substring[i]));\n\
    \        long counts = new long[ss.Length];\n        for (int i = 0; i != ss.Length;\
    \ ++i) counts[i] = (sb.IndexOf(ss) >= 0) ? 1 : 0;\n        return counts.Sum();",
  "        if (str.IndexOf(substring) == -1) {\n            return 0L;\n        }\n\
    \n        long count = 0;\n\n        // Iterate through the string and for each\
    \ string compare the substring to the string.\n        for (long i = 0; i < str.Length\
    \ - substring.Length + 1; i++) {\n            if (str.Substring(i, substring.Length).Equals(substring,\
    \ StringComparison.OrdinalIgnoreCase)) {\n                count++;\n         \
    \   }\n        }\n\n        return count;", "        long count = 0L;\n      \
    \  long end = 0L;\n        bool endFound = false;\n        for (int i = 0; !endFound\
    \ && i < str.Length; ++i) {\n            end = str.IndexOf(substring, i);\n  \
    \          if (end == -1) {\n                endFound = true;\n            } else\
    \ {\n                count += end - i;\n                i = end;\n           \
    \ }\n        }\n        return count;", "        return Enumerable.Range(0, str.Length\
    \ - substring.Length + 1)\n            .Where((x) => str.Substring(x, substring.Length)\
    \ == substring)\n            .Count();", "        string result = \"\";\n    \
    \    foreach (char c in substring) {\n            if (str.Contains(c)) {\n   \
    \             if (result.IndexOf(substring) != -1) {\n                    result\
    \ = \"(\" + result + str.IndexOf(substring) + \")\";\n                } else {\n\
    \                    result = str.IndexOf(substring) + \")\";\n              \
    \  }\n            }\n        }\n        return (long) result;", "        if (String.IsNullOrEmpty(str)\
    \ || String.IsNullOrEmpty(substring)) {\n            return 0;\n        }\n  \
    \      long count = (long) str.Split(new[] { substring }, StringSplitOptions.None).Length;\n\
    \        return count;", "        List<string> substrings = substring.ToCharArray().ToList();\n\
    \        long numTimes = 0;\n\n        // Build a frequency table of the substrings\n\
    \        Dictionary<string, long> freq = new Dictionary<string, long>();\n   \
    \     foreach (string s in substrings)\n        {\n            freq[s] = freq[s]\
    \ + 1;\n        }\n\n        // For each character, see if it's in the frequency\
    \ table\n        foreach (char c in str)\n        {\n            if (freq.ContainsKey(c.ToString()))\n\
    \            {\n                // Update the frequency table\n              \
    \  freq[c.ToString()] = freq[c.ToString()] + 1;\n            }\n        }\n\n\
    \        // Return the frequency table\n        foreach (KeyValuePair<string,\
    \ long> pair in freq)\n        {\n            numTimes += pair.Value;\n      \
    \  }\n\n        return numTimes;", "        Dictionary<string, long> dict = Dictionary<string,\
    \ long>();\n\n        foreach (string sub in substring) {\n            if (!dict.ContainsKey(sub))\
    \ {\n                dict.Add(sub, 0);\n            }\n            dict[sub]++;\n\
    \        }\n\n        long count = 0;\n\n        foreach (string s in str) {\n\
    \            count += dict[s];\n        }\n        return count;", "        //\
    \ Compute longest common prefix for both strings\n        int lcp = str.Length\
    \ < substring.Length ? str.Length : substring.Length;\n        string lcpStr =\
    \ \"\";\n        for (int i = 0; i < lcp; i++) {\n            lcpStr += str[i];\n\
    \        }\n        string lcpSubStr = \"\";\n        for (int i = 0; i < substring.Length;\
    \ i++) {\n            lcpSubStr += substring[i];\n        }\n\n        // Compute\
    \ longest common prefix with upper and lower bound\n        int lcpUb = lcp <\
    \ substring.Length ? lcp : substring.Length;\n        int lcpLb = lcp < substring.Length\
    \ ? substring.Length : lcp;\n        string lcpSubStrUb = \"\";\n        for (int\
    \ i = 0; i < substring.Length; i++) {\n            lcpSubStrUb += substring[i];\n\
    \        }\n        string lcpSubStrLb = \"\";\n        for (int i = 0; i < substring.Length;\
    \ i++) {\n            lcpSubStrLb += substring[i];\n        }\n\n        // If\
    \ strings too short, return 0\n        if (lcpUb < lcpLb) {\n            return\
    \ 0L;\n        }\n\n        // If strings too long, return 0\n        if (lcpUb\
    \ > lcpLb) {\n            return 0L;\n        }\n\n        string commonSub =\
    \ lcpSubStrUb;\n        int commonLcp = lcpUb;\n        List<int> common = new\
    \ List<int>();\n        for (int i = 0; i < commonLcp - 1; i++) {\n          \
    \  int j = i + 1;\n            while (j < commonLcp) {\n                if (commonSub[i]\
    \ == commonSub[j]) {\n                    common.Add(j);\n                   \
    \ commonSub = lcpSubStrLb;\n                    commonLcp = lcpLb;\n         \
    \           commonSub = lcpSubStrUb;\n                    commonLcp = lcpUb;\n\
    \                    break;\n                }\n                j++;\n       \
    \     }\n        }\n\n        int count = 0;\n        for (int i = 0; i < common.Count;\
    \ i++) {\n            int start = common[i];\n            int end = start + 1;\n\
    \            while (end < commonLcp) {\n                if (commonSub[end] ==\
    \ commonSub[start]) {\n                    count++;\n                    end +=\
    \ 1;\n                } else {\n                    break;\n                }\n\
    \            }\n        }\n        return count;", "        int count = 0;\n \
    \       foreach (char c in str) {\n            if (c == substring[0]) {\n    \
    \            count++;\n                string substr = substring.Substring(1);\n\
    \                foreach (char c2 in str) {\n                    if (c == c2)\
    \ {\n                        count += HowManyTimes(str.Substring(1), substr);\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ count;", "        string s = str.ToLower();\n        string sub = substring.ToLower();\n\
    \n        if (sub == \"\")\n            return 0;\n        else if (s == sub)\n\
    \            return 1;\n        else if (sub.IndexOf(s) >= 0)\n            return\
    \ 1 + HowManyTimes(s, sub.Substring(sub.IndexOf(s)));\n        else if (s.IndexOf(sub)\
    \ >= 0)\n            return 1 + HowManyTimes(s, sub.Substring(0, sub.IndexOf(s)));\n\
    \        else\n            return 0;", "        string strCopy = str;\n      \
    \  long counter = 0;\n        if (strCopy.IndexOf(substring) >= 0) {\n       \
    \     counter++;\n        }\n        strCopy = strCopy.Substring(strCopy.IndexOf(substring)\
    \ + substring.Length);\n        if (strCopy.IndexOf(substring) >= 0) {\n     \
    \       counter++;\n        }\n        return counter;", "        if (str == null\
    \ || str.Length == 0) {\n            return 0L;\n        }\n        if (string.IsNullOrEmpty(substring))\
    \ {\n            return 0L;\n        }\n        var startIndex = 0L;\n       \
    \ var endIndex = str.Length;\n        var count = 0;\n        if (startIndex ==\
    \ 0 && string.Compare(substring, str[startIndex], true) == 0) {\n            count++;\n\
    \        }\n        while (startIndex < endIndex) {\n            while (startIndex\
    \ < endIndex && string.Compare(substring, str[startIndex], true) == 0) {\n   \
    \             count++;\n                startIndex++;\n            }\n       \
    \     if (startIndex < endIndex && string.Compare(substring, str[endIndex], true)\
    \ == 0) {\n                count++;\n                endIndex--;\n           \
    \ }\n            if (startIndex > endIndex) {\n                return count;\n\
    \            }\n            if (startIndex == endIndex) {\n                var\
    \ c = str[startIndex];\n                if (c == substring[startIndex]) {\n  \
    \                  startIndex++;\n                    count++;\n             \
    \   }\n                else {\n                    endIndex--;\n             \
    \       count--;\n                }\n            }\n            startIndex++;\n\
    \        }\n        return count;", "        int count = 0;\n        for (int\
    \ i = 0; i < str.Length; i++) {\n            if (str.IndexOf(substring, i, StringComparison.OrdinalIgnoreCase)\
    \ >= 0)\n                count++;\n        }\n        return count;", "      \
    \  long count = 0;\n        foreach (char c in str.ToCharArray()) {\n        \
    \    if (c == substring[0]) {\n                for (int i = 1; i < substring.Length;\
    \ i++) {\n                    if (c == substring[i]) {\n                     \
    \   count++;\n                    }\n                }\n            }\n      \
    \  }\n        return count;", '        return HowManyTimes(str, substring, 0,
    0);', "        return str.Length - str.Split(new char[] { 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A',\
    \ 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A', 'a', 'A", '        return str.Split().Count(x
    => x.Equals(substring));', "        long count = 0;\n        if (str == null ||\
    \ str.Length == 0 || string.IsNullOrEmpty(substring)) {\n            return count;\n\
    \        }\n\n        for (int i = 0; i < str.Length; i++) {\n            if (str.Substring(i,\
    \ substring.Length).Equals(substring)) {\n                count += 1;\n      \
    \      }\n        }\n        return count;", "        if (str.Length == 0)\n \
    \           return 0;\n        List<string> list = new List<string>();\n     \
    \   foreach (char c in str)\n            if (c == substring[0])\n            \
    \    list.Add(substring);\n            else\n                list.Add(string.Concat(new\
    \ string[] {c, substring}));\n        return list.Count(l => str.IndexOf(l) >=\
    \ 0);", '        return str.Split().Count(s => s.Equals(substring, StringComparison.OrdinalIgnoreCase))
    - (str.IndexOf(substring, StringComparison.OrdinalIgnoreCase) + substring.Length);',
  '        return str.Split(substring).Length;', "        long count = 0;\n      \
    \  // Convert string to char[]\n        char[] strArray = str.ToCharArray();\n\
    \        // Convert string to char[]\n        char[] substringArray = substring.ToCharArray();\n\
    \        Array.Sort(strArray);\n        Array.Sort(substringArray);\n        int\
    \ i = 0, j = 0;\n        // Iterate through the string\n        while (i < strArray.Length)\
    \ {\n            // If substring char is in str\n            if (strArray[i] ==\
    \ substringArray[j]) {\n                // If substring char is equal to first\
    \ char of str\n                if (i == 0)\n                    count++;\n   \
    \             // Else\n                else\n                    // Increment\
    \ count\n                    count += substringArray.Length - j - 1;\n       \
    \         // Move to next char\n                j++;\n                // If j\
    \ is out of substring length, increment i\n                if (j >= substringArray.Length)\n\
    \                    i++;\n            }\n            // If strArray is out of\
    \ chars\n            if (i >= strArray.Length)\n                break;\n     \
    \   }\n        // Return count\n        return count;", "        var result =\
    \ new List<long>();\n        foreach (var c in str.ToLowerInvariant()) {\n   \
    \         if (substring == string.Concat(new string[] { c })) {\n            \
    \    result.Add(1);\n                continue;\n            }\n            if\
    \ (c.Equals('a') && substring == string.Concat(new string[] { c.ToString(), c.ToString()\
    \ })) {\n                result.Add(2);\n                continue;\n         \
    \   }\n            if (c.Equals('a') && substring == string.Concat(new string[]\
    \ { c.ToString(), c.ToString(), c.ToString() })) {\n                result.Add(3);\n\
    \                continue;\n            }\n            if (c.Equals('a') && substring\
    \ == string.Concat(new string[] { c.ToString(), c.ToString(), c.ToString(), c.ToString()\
    \ })) {\n                result.Add(4);\n                continue;\n         \
    \   }\n            if (c.Equals('a') && substring == string.Concat(new string[]\
    \ { c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString() })) {\n\
    \                result.Add(5);\n                continue;\n            }\n  \
    \          if (c.Equals('a') && substring == string.Concat(new string[] { c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString()\
    \ })) {\n                result.Add(6);\n                continue;\n         \
    \   }\n            if (c.Equals('a') && substring == string.Concat(new string[]\
    \ { c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString() })) {\n                result.Add(7);\n\
    \                continue;\n            }\n            if (c.Equals('a') && substring\
    \ == string.Concat(new string[] { c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString() })) {\n                result.Add(8);\n                continue;\n\
    \            }\n            if (c.Equals('a') && substring == string.Concat(new\
    \ string[] { c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString() })) {\n                result.Add(9);\n\
    \                continue;\n            }\n            if (c.Equals('a') && substring\
    \ == string.Concat(new string[] { c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(), c.ToString(),\
    \ c.ToString(), c.ToString(), c.ToString(), ", "        string toReturn = \"\"\
    ;\n        int count = 0;\n        foreach (char c in str) {\n            if (c\
    \ == substring[0]) {\n                toReturn += substring[0];\n            }\n\
    \            else {\n                if (toReturn.Length > 0) {\n            \
    \        count += toReturn.Count(substring => substring == c) - toReturn.Count(substring\
    \ => substring == substring[0]);\n                }\n                toReturn\
    \ += c;\n            }\n        }\n        return count;", "        long result\
    \ = 0;\n        if (str == null || substring == null) {\n            return result;\n\
    \        }\n        // Calculate the length of substring\n        int length =\
    \ substring.Length;\n        foreach (char c in substring) {\n            length--;\n\
    \            if (length == 0) {\n                break;\n            }\n     \
    \   }\n        // If substring can be found in str, then increase the count of\
    \ substring\n        foreach (char c in str) {\n            if (length == 0) {\n\
    \                break;\n            }\n            if (c == substring[length])\
    \ {\n                result++;\n            }\n            length--;\n       \
    \ }\n        return result;", "        if (String.IsNullOrEmpty(str)\n       \
    \     || String.IsNullOrEmpty(substring)) {\n            throw new ArgumentException(\"\
    str and substring must be not null or empty\");\n        }\n        var count\
    \ = 0;\n        var lastMatchIndex = 0;\n        var startIndex = -1;\n      \
    \  foreach (var c in str) {\n            if (c == substring[0]) {\n          \
    \      ++startIndex;\n            }\n            if (startIndex != -1) {\n   \
    \             var index = str.IndexOf(substring, startIndex);\n              \
    \  if (index != -1) {\n                    var length = substring.Length;\n  \
    \                  if (index + length == str.Length) {\n                     \
    \   lastMatchIndex = index + length;\n                    } else {\n         \
    \               lastMatchIndex = index + 1;\n                    }\n         \
    \           ++count;\n                }\n                startIndex = -1;\n  \
    \          }\n        }\n        return count;", "        // Make both strings\
    \ lower case to help with case conversions\n        str = str.ToLower();\n   \
    \     substring = substring.ToLower();\n        long count = 0;\n        long\
    \ startIndex = 0;\n        long endIndex = 0;\n        long minIndex = 0;\n  \
    \      bool endOfString = false;\n\n        // Iterate from left to right of the\
    \ string\n        for (int i = 0; i < str.Length; i++) {\n            // If the\
    \ current character equals the substring stop iterating\n            if (str[i]\
    \ == substring[0]) {\n                endOfString = str[i] == substring[0];\n\
    \                endIndex++;\n                endIndex += (endOfString ? 1 : 0);\n\
    \                if (endIndex == str.Length) {\n                    count = count\
    \ + endIndex;\n                    startIndex = i + 1;\n                }\n  \
    \          } else {\n                // Iterate until we find a character that\
    \ doesn't equal the substring\n                while (endOfString && str[i] !=\
    \ substring[0]) {\n                    endIndex++;\n                }\n      \
    \          // If the substring doesn't end at the end of the string\n        \
    \        if (endOfString) {\n                    count = count + endIndex;\n \
    \                   startIndex = i + 1;\n                }\n            }\n  \
    \          // If this is the beginning of the string and the substring still hasn't\
    \ been found\n            if (startIndex == 0 && endIndex == 0) {\n          \
    \      minIndex = i;\n            }\n        }\n        // If the string is empty\
    \ don't even try to find the substring\n        if (str[0] == '\\0') {\n     \
    \       return 0;\n        }\n        // If the substring is the full length of\
    \ the string don't even try to find it\n        if (str.Length == substring.length)\
    \ {\n            return 0;\n        }\n        // Now count overlaps\n       \
    \ long overlaps = 0;\n        // This is not the best way to detect overlapping\
    \ cases but it will do for now\n        if (minIndex == 0) {\n            overlaps\
    \ = minIndex - str.Length;\n        } else {\n            overlaps = minIndex\
    \ - startIndex;\n        }\n        overlaps += endIndex - str.Length;\n     \
    \   return count;", "        long ret = 0;\n        string substr = substring.ToLower();\n\
    \n        foreach (char c in str.ToLower()) {\n            if (c == substr.FirstOrDefault())\
    \ {\n                ret++;\n                if (substr.Length > 1) {\n      \
    \              ret += HowManyTimes(str.Substring(1, str.Length - 1), substring.Substring(0,\
    \ substr.Length - 1));\n                }\n            }\n        }\n        return\
    \ ret;", "        if (str == null || substring == null)\n            return 0;\n\
    \        var len = str.Length;\n        if (len > substring.Length)\n        \
    \    len = substring.Length;\n        var ret = new List<long>();\n        var\
    \ i1 = 0, i2 = 0, i3 = 0, j1 = 0, j2 = 0, j3 = 0;\n        do {\n            if\
    \ (i1 == len) {\n                ret.Add(0);\n                i1 = 0;\n      \
    \      }\n            if (j1 == substring.Length) {\n                ret.Add(1);\n\
    \                j1 = 0;\n            }\n            if (i2 == len) {\n      \
    \          ret.Add(0);\n                i2 = 0;\n            }\n            if\
    \ (j2 == substring.Length) {\n                ret.Add(1);\n                j2\
    \ = 0;\n            }\n            if (i3 == len) {\n                ret.Add(0);\n\
    \                i3 = 0;\n            }\n            if (j3 == substring.Length)\
    \ {\n                ret.Add(1);\n                j3 = 0;\n            }\n   \
    \         int l1 = 0, l2 = 0, l3 = 0, r1 = 0, r2 = 0, r3 = 0;\n            if\
    \ (str[i1] == substring[j1])\n                l1++;\n            else\n      \
    \          l1 = 0;\n            if (str[i2] == substring[j2])\n              \
    \  l2++;\n            else\n                l2 = 0;\n            if (str[i3] ==\
    \ substring[j3])\n                l3++;\n            else\n                l3\
    \ = 0;\n            if (str[i3] != substring[j3])\n                r3++;\n   \
    \         else\n                r3 = 0;\n            if (str[i2] == substring[j2])\n\
    \                r2++;\n            else\n                r2 = 0;\n          \
    \  if (str[i1] == substring[j1])\n                r1++;\n            else\n  \
    \              r1 = 0;\n            long t = (l1 + l2 + l3) * l3 * (r1 + r2 +\
    \ r3);\n            ret.Add(t);\n            ++i1;\n            ++i2;\n      \
    \      ++i3;\n            ++j1;\n            ++j2;\n            ++j3;\n      \
    \  } while (i1 < len && i2 < len && i3 < len && j1 < substring.Length && j2 <\
    \ substring.Length && j3 < substring.Length);\n        return ret.Aggregate((t1,\
    \ t2) => t1 + t2);", "        var occurrences = new List<long>();\n        foreach\
    \ (char c in str) {\n            if (c == substring[0]) {\n                occurrences.AddRange(FindOccurrences(c,\
    \ substring, occurrences));\n            }\n        }\n\n        foreach (char\
    \ c in substring) {\n            if (c != str[str.Length - 1]) {\n           \
    \     occurrences.AddRange(FindOccurrences(c, substring, occurrences));\n    \
    \        }\n        }\n        return occurrences.Count();", "        if (string.IsNullOrEmpty(str))\n\
    \            return 0;\n        if (string.IsNullOrEmpty(substring))\n       \
    \     return 1;\n        long count = 0;\n        for (int i = 0; i < str.Length;\
    \ i++) {\n            if (str.Substring(i, 1).Equals(substring)) {\n         \
    \       count++;\n            }\n        }\n        return count;", "        int\
    \ i = str.IndexOf(substring);\n        if (i == -1) {\n            return 0L;\n\
    \        }\n        // Find the end of the substring.\n        int j = i + substring.Length;\n\
    \        // Find the end position of the original string.\n        int k = str.Length\
    \ - substring.Length;\n        // Find how many characters overlap between the\
    \ original string and substring.\n        int overlap = i - k;\n        if (overlap\
    \ > 0)\n            return overlap;\n        // Count all characters that occur\
    \ between the substring\n        // and the original string.\n        int count\
    \ = j - i;\n        // If there's a match, add it to the count.\n        if (k\
    \ > 0) {\n            int count = k - i;\n        }\n        // Return the result.\n\
    \        return count;", "        // For each letter, count how many times that\
    \ letter is in the substring.\n        long count = str.Select((c, i) => new {\
    \ c, i }).Count(i => i.c == substring);\n\n        // For each letter, count how\
    \ many times that letter is in the substring and also check how many overlapping\
    \ letters.\n        foreach (var letter in str.ToLowerInvariant()) {\n       \
    \     int count = 0;\n            int lastIndex = -1;\n            for (int i\
    \ = 0; i < str.Length; i++) {\n                if (i == 0 || str[i - 1] != letter)\
    \ continue;\n                if (str[i] == letter) count++;\n                else\
    \ if (str[i] != letter) {\n                    lastIndex = i;\n              \
    \      break;\n                }\n            }\n            if (count == substring.CompareTo(letter))\
    \ count++;\n            else if ((lastIndex >= 0) && (lastIndex < i)) {\n    \
    \            int difference = lastIndex - i;\n                if (difference >\
    \ 1) count++;\n            }\n        }\n        return count;", "        if (string.IsNullOrEmpty(str)\
    \ || string.IsNullOrEmpty(substring)) {\n            return 0;\n        }\n\n\
    \        long count = 0;\n\n        for (int i = 0; i < str.Length; i++) {\n \
    \           if (str.Substring(0, i).Equals(substring)) {\n                count++;\n\
    \            }\n        }\n\n        if (count > 0) {\n            count += str.Count(x\
    \ => x == substring);\n        }\n\n        return count;", "        // This will\
    \ be the substring we search\n        long substringIndex = 0, totalOccurrences\
    \ = 0;\n        // This will be the string we search in\n        string searchString\
    \ = str;\n        // This will be the length of the search string we are looking\
    \ for\n        int searchLength = substring.Length;\n        // Iterate over the\
    \ search string until we find a character we do not need\n        while (substringIndex\
    \ < searchLength && searchString.IndexOf(substring, substringIndex, StringComparison.InvariantCultureIgnoreCase)\
    \ >= 0) {\n            // Increment the occurrence count for this character\n\
    \            totalOccurrences++;\n            // Increment the index at which\
    \ we found this character\n            substringIndex += searchLength;\n     \
    \   }\n        // Return the occurrence count\n        return totalOccurrences;",
  "        long count = 0;\n        for (int i = 0; i < str.Length; i++) {\n     \
    \       if (str.IndexOf(substring, i, StringComparison.OrdinalIgnoreCase) >= 0)\n\
    \                count++;\n        }\n        return count;", "        char[]\
    \ arr = substring.ToCharArray();\n        string newstr = str;\n        long ret\
    \ = 0;\n        long current = 0;\n        for (int i = 0; i < arr.Length; i++)\
    \ {\n            if (newstr.Contains(arr[i])) {\n                newstr = newstr.Replace(arr[i],\
    \ \"\");\n                current++;\n            }\n            else {\n    \
    \            if (current > 0) {\n                    ret += current;\n       \
    \         }\n                current = 0;\n            }\n        }\n        if\
    \ (current > 0) {\n            ret += current;\n        }\n        return ret;",
  "        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring))\n   \
    \         return 0L;\n        if (substring.Length > str.Length)\n           \
    \ return -1L;\n        HashSet<char> sHash = new HashSet<char>(substring);\n \
    \       List<char> lHash = new List<char>(str.ToLower());\n        long ret =\
    \ 0;\n        for (int i = 0; i < str.Length; i++)\n            if (sHash.Contains(str[i]))\n\
    \                ret += 1;\n        for (int i = 0; i < lHash.Count; i++)\n  \
    \          if (sHash.Contains(lHash[i]))\n                ret += 1;\n        return\
    \ ret;", "        long count = 0;\n        int maxCount = str.Count(s => s ==\
    \ substring);\n        bool found = false;\n        for (int i = 0; i <= str.Length\
    \ - substring.Length; i++) {\n            if (found == false && str.Substring(i,\
    \ substring.Length) == substring) {\n                found = true;\n         \
    \       count += 1;\n            }\n            if (str.Substring(i, substring.Length)\
    \ != substring) {\n                found = false;\n            }\n        }\n\
    \        if (str.Length > substring.Length) {\n            count = str.Length\
    \ - substring.Length;\n        }\n        return maxCount - count;", "       \
    \ long totalCount = 0;\n\n        if (str == null || str.Length < substring.Length\
    \ || substring == null || substring.Length == 0) return 0;\n\n        long startIndex\
    \ = str.IndexOf(substring);\n        while (startIndex >= 0) {\n            totalCount++;\n\
    \            startIndex = str.IndexOf(substring, startIndex + 1);\n        }\n\
    \        return totalCount;", "        long count = (str.Length - substring.Length)\
    \ + 1;\n\n        int start = 0;\n        foreach (char c in substring) {\n  \
    \          for (int i = start; i < str.Length; i++) {\n                if (str[i]\
    \ == c) {\n                    count++;\n                }\n                else\
    \ {\n                    count = 0;\n                    break;\n            \
    \    }\n            }\n            start++;\n        }\n        return count;",
  '        return str.Split((char)0).Count(x => x.Equals(substring));', "        long\
    \ res = 0;\n        // Find the first char of the substring\n        int firstIndex\
    \ = str.IndexOf(substring);\n        if (firstIndex == -1) throw new Exception(\"\
    Substring not found\");\n        // Find the first char of the substring\n   \
    \     int lastIndex = str.LastIndexOf(substring);\n        if (lastIndex == -1)\
    \ throw new Exception(\"Substring not found\");\n        // Find the length of\
    \ the substring\n        int substringLength = substring.Length;\n        // Find\
    \ the length of the str\n        int strLength = str.Length;\n        bool firstCharWasFound\
    \ = false;\n        bool lastCharWasFound = false;\n        // Check if the substring\
    \ is found in the string\n        if (firstIndex < lastIndex) {\n            for\
    \ (int i = firstIndex; i <= lastIndex; i++) {\n                // Find if current\
    \ char is last char\n                bool currentCharIsLastChar = i == lastIndex;\n\
    \                if (str.IndexOf(substring, i, substringLength, StringComparison.CurrentCultureIgnoreCase)\
    \ >= 0) {\n                    // Check if current char is found on first position\n\
    \                    if (!firstCharWasFound) {\n                        // Count\
    \ occurences\n                        res += 1;\n                        firstCharWasFound\
    \ = true;\n                    }\n                    // Check current char and\
    \ next char\n                    else {\n                        // Count occurences\n\
    \                        res += 1;\n                    }\n                }\n\
    \                // Check if current char is last char\n                else if\
    \ (currentCharIsLastChar) {\n                    // Check if current char is found\
    \ on last position\n                    if (!lastCharWasFound) {\n           \
    \             // Count occurences\n                        res += 1;\n       \
    \                 lastCharWasFound = true;\n                    }\n          \
    \          // Check current char and previous char\n                    else {\n\
    \                        // Count occurences\n                        res += 1;\n\
    \                    }\n                }\n            }\n        }\n        //\
    \ Check if the substring is found in the string\n        else {\n            //\
    \ Check if the char is found on first position\n            if (!firstCharWasFound)\
    \ {\n                // Count occurences\n                res += 1;\n        \
    \        firstCharWasFound = true;\n            }\n            // Check if the\
    \ char is found on last position\n            else if (!lastCharWasFound) {\n\
    \                // Count occurences\n                res += 1;\n            \
    \    lastCharWasFound = true;\n            }\n        }\n        return res;",
  '        return str.Length - substring.Length + 1 + Regex.Matches(str, string.Format("^{0}.*$",
    substring)).Count;', "        if (string.IsNullOrEmpty(substring))\n         \
    \   throw new ArgumentException(\"substring can't be empty or null\");\n     \
    \   if (string.IsNullOrEmpty(str))\n            throw new ArgumentException(\"\
    str can't be empty or null\");\n\n        long result = 0;\n        foreach (char\
    \ item in str) {\n            if (substring.IndexOf(item) >= 0)\n            \
    \    result++;\n        }\n        return result;", "        long count = 0;\n\
    \        // Use a regex because this should be much faster than the brute force\
    \ approach\n        Regex regex = new Regex(substring, RegexOptions.IgnoreCase);\n\
    \        foreach (Match m in regex.Matches(str)) {\n            count++;\n   \
    \     }\n        return count;", "        int count = 0;\n        int size = str.Length;\n\
    \        int start = 0;\n        int end = 0;\n        while ((end = str.IndexOf(substring,\
    \ start, end - start)) >= 0)\n        {\n            ++count;\n            start\
    \ = end + substring.Length;\n        }\n        return count;", "        long\
    \ count = 0;\n\n        for (int i = 0; i < str.Length; i++) {\n            if\
    \ (str[i] == substring[0])\n                for (int j = 0; j < substring.Length;\
    \ j++) {\n                    int k = i;\n                    while (k < str.Length\
    \ && str[k] == substring[j]) {\n                        k++;\n               \
    \     }\n                    if (k > i) {\n                        count++;\n\
    \                        i = k;\n                    }\n                }\n  \
    \      }\n        return count;", "        long result = 0;\n        string tempStr\
    \ = str;\n        do {\n            result = str.IndexOf(substring, result) +\
    \ 1;\n            tempStr = str.Remove(result, substring.Length);\n        } while\
    \ (tempStr != \"\");\n        return result;", "        long count = 0;\n    \
    \    string lower = substring.ToLower();\n        if (lower.Contains(str)) {\n\
    \            count += 1;\n        }\n        int startIndex = 0;\n        int\
    \ len = lower.Length;\n        while (startIndex < str.Length && str.Substring(startIndex,\
    \ len).Contains(lower)) {\n            count += 1;\n            startIndex +=\
    \ len;\n        }\n        return count;"]
stop_tokens:
- "\n    }\n"
