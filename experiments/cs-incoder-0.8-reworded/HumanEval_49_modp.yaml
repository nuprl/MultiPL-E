name: HumanEval_49_modp
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> Modp((3L),\
  \ (5L))\n    // (3L)\n    // >>> Modp((1101L), (101L))\n    // (2L)\n    // >>>\
  \ Modp((0L), (101L))\n    // (1L)\n    // >>> Modp((3L), (11L))\n    // (8L)\n \
  \   // >>> Modp((100L), (101L))\n    // (1L)\n    public static long Modp(long n,\
  \ long p) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Modp((3L),\
  \ (5L)) == (3L));\n    Debug.Assert(Modp((1101L), (101L)) == (2L));\n    Debug.Assert(Modp((0L),\
  \ (101L)) == (1L));\n    Debug.Assert(Modp((3L), (11L)) == (8L));\n    Debug.Assert(Modp((100L),\
  \ (101L)) == (1L));\n    Debug.Assert(Modp((30L), (5L)) == (4L));\n    Debug.Assert(Modp((31L),\
  \ (5L)) == (3L));\n    }\n\n}\n"
completions: ["        long result = 1L;\n        do {\n            result *= n;\n\
    \            n /= p;\n        } while (n > 1);\n        return result;", "   \
    \     if (n <= p)\n            return (1L + n) % p;\n        else\n          \
    \  return Modp(n, (p - n + 1L));", '        return ((1L << n) | p) % (p + 1L);',
  "        Debug.Assert(n >= 0L && p > 0L);\n        Debug.Assert(n % p == 0L);\n\
    \        if (n == 0L)\n            return 0L;\n        if (n == 1L)\n        \
    \    return 1L;\n        if (n == p + 1L)\n            return p + 1L;\n      \
    \  long r = 1L;\n        while ((n % p == 0L) && (n / p > 2L)) {\n           \
    \ n = n / p;\n            r *= p + 1L;\n        }\n        if (n / p < 2L) {\n\
    \            while (n != 1L) {\n                n /= p + 1L;\n               \
    \ r *= p + 1L;\n            }\n        }\n        return r;", "        long r\
    \ = n; // assume n is prime\n        long s = 2;\n        bool f = true;\n   \
    \     for (long i = 1; i < p; ++i) {\n            f = f & n % i == 0;\n      \
    \      n /= i;\n            s *= i;\n        }\n        long m = n;\n        if\
    \ (n > 1) {\n            m = n % p;\n            while (f == true) {\n       \
    \         f = f & n % m == 0;\n                n /= m;\n                s *= m;\n\
    \            }\n        }\n        return r;", "        long x = ((n >> 1L) %\
    \ (p + 1));\n        if ((x > 0) && (n != ((n >> 1L) & 0x7FFF))) {\n         \
    \   x -= (p + 1);\n        }\n        return n;", '        return ((long)n) %
    p;', "        long r = 1L;\n        while (r < p) {\n            r *= 2L;\n  \
    \      }\n        while (n >= r * 2L) {\n            n -= r * 2L;\n          \
    \  r *= 2L;\n        }\n        return n;", "        long q = (long) ((n % p)\
    \ * (p - 1L));\n        if (q < p)\n            q = p + q;\n        return q;",
  "        BigInteger r = BigInteger.One;\n        while (n > 0) {\n            BigInteger\
    \ r = r.Multiply(p);\n            long x = r.ShiftLeft(BigInteger.One.Length -\
    \ n.Length);\n            n = x - n;\n        }\n        return r;", "       \
    \ int result = (int)(n >> 31);\n        if (n % p == 0) {\n            return\
    \ n - result;\n        } else {\n            return p - result;\n        }", " \
    \       long ans = 1L;\n        while (n > p) { ans = (ans * (n % p)) % p; n =\
    \ (n - ans) / p; }\n        return ans;", "        long r;\n        while ((r\
    \ =\n                   ((n % p) != 0)\n                    ? r\n            \
    \        : p - 1) >= 0) {\n            n = (n / p) * p;\n        }\n        return\
    \ r;", "        long r = 1L;\n        while (n != 0L) {\n            if (n % p\
    \ == 0L) {\n                long q = r * (n % p); // q could be 0L!\n        \
    \        if (q > p) q = p - q;\n                r = q;\n            }\n      \
    \      n /= p;\n        }\n        return r;", "        BigInteger num = BigInteger.Pow(n,\
    \ BigInteger.ValueOf(p));\n        return num.ModPow(BigInteger.ValueOf(p), p);",
  "        long k = long.MaxValue;\n        long v = 0;\n        long g = p;\n   \
    \     while (true) {\n            if (k % 2 == 0) {\n                if (k > 0)\
    \ {\n                    v = (v << 1) | 1;\n                    k--;\n       \
    \         }\n                else {\n                    v = (v << 1) | 0;\n \
    \                   k++;\n                }\n            }\n            else {\n\
    \                if (k < p) {\n                    v = (v << 1) | 0;\n       \
    \             k++;\n                }\n                else {\n              \
    \      v = (v << 1) | 1;\n                    k--;\n                }\n      \
    \      }\n            g = (g << 1) | 1;\n            if (k == 0) break;\n    \
    \    }\n        long ret = 0;\n        while (true) {\n            ret = (ret\
    \ << 1) | v;\n            if (g == 1) break;\n            v = (v << 1) | 1;\n\
    \            g--;\n        }\n        return ret;", "        long q = p - 1L;\n\
    \        long r = 1L;\n        while (n > q) {\n            r = r * q + n;\n \
    \           n = n - 1L;\n        }\n        return r;", "        long ret = (long)((1L)\
    \ << (n-1));\n        if (ret >= p)\n            ret %= p;\n        return (ret);",
  "        long a = n % p;\n        if (p < 0)\n            a = (p - a) * p + n;\n\
    \        if (a > p)\n            a = p - a;\n        return a;", "        // Fast\
    \ version (modulo p).\n        if (n == 0 || p == 0)\n            return 0;\n\
    \        if ((n & -p) == n)\n            return p;\n        if (n >> 63 == 0)\
    \ {\n            n ^= n >> 32;\n            n ^= n >> 8;\n            n ^= n >>\
    \ 4;\n            n ^= n >> 2;\n            n ^= n >> 1;\n            return n;\n\
    \        }\n        long res = n & -p;\n        long t = (long)n >> 62;\n    \
    \    while (t != 0) {\n            if (t & 1) {\n                res++;\n    \
    \        }\n            t--;\n        }\n        long m = (p + 1L) / 2;\n    \
    \    while (m != 0) {\n            if (m & 1) {\n                res++;\n    \
    \        }\n            m--;\n        }\n        return res;", "        long c\
    \ = 1L;\n        while (c < p) {\n            c *= 2L;\n        }\n        return\
    \ n - (c % p);", "        int retval = n%p;\n        if(retval >= (long)long.MaxValue)\
    \ {\n            retval = retval - (long)long.MaxValue;\n        }\n        return\
    \ retval;", "        long res = 1L;\n        long m = (1L<<32) - p; //mask\n \
    \       long mask = ((1L<<32) - p) - 1;\n\n        while (n>0) {\n           \
    \ if ((n&m) == 0)\n                res=res+p;\n            n=(n-m)&mask;\n   \
    \     }\n        return res;", "        double d = Math.Pow(2, n) % p;\n     \
    \   return Convert.ToInt64(Math.Truncate(d));", "        ulong x = (ulong)n;\n\
    \        ulong y = (ulong)p;\n        ulong r = x % y;\n        if (r == 0) return\
    \ 1;\n        if (r < 0) return Modp(r + y, p) + 1;\n        return Modp(r - y,\
    \ p) + 1;", "        var q = p % n;\n        if (q < 0) {\n            q = p +\
    \ (q * n);\n        }\n        return q;", "        long r = 1L;\n        while\
    \ (n > 0) {\n            if (n % 2 == 1) {\n                r = (r * p) % p;\n\
    \            }\n            n /= 2;\n            p *= p;\n        }\n        return\
    \ r;", "        if (n >= p)\n            return (n - p) / p;\n        else\n \
    \           return ((n - p) + p) % p;", "        long result = (long)Math.Pow(2,\
    \ n) % p;\n        if (result < 0)\n            result += (p - 1);\n        return\
    \ result;", "        var ret = n;\n        var m = new BigInteger(n);\n      \
    \  var q = new BigInteger(p);\n        var x = q.Multiply(m);\n        while (x.CompareTo(BigInteger.Zero)\
    \ < 0) {\n            ret = x.ModAdd(ret, q);\n            x = q.Multiply(m);\n\
    \        }\n        return ret;", "        if (n == 0L) {\n            return\
    \ 1L;\n        }\n        long[] x = new long[] { 1L, 1L, 1L, 1L };\n        if\
    \ (n > 0L) {\n            if (n % 2L == 1L) {\n                for (int i = 0;\
    \ i < 3; i++) {\n                    x[i] = x[i] % p + p;\n                }\n\
    \            } else {\n                for (int i = 0; i < 3; i++) {\n       \
    \             x[i] = x[i] % p + 1L;\n                }\n            }\n      \
    \  }\n        if (n >= 3L) {\n            long m = n % 3L;\n            long r1\
    \ = 0L;\n            for (int i = 0; i < 3; i++) {\n                r1 = r1 %\
    \ p;\n            }\n            long r2 = 1L;\n            for (int i = 0; i\
    \ < 3; i++) {\n                r2 = (r2 * x[i]) % p;\n            }\n        \
    \    long r3 = 1L;\n            for (int i = 0; i < 3; i++) {\n              \
    \  r3 = (r3 * x[i]) % p;\n            }\n            long r4 = x[3] * (m + r1\
    \ * r2 * r3) % p;\n            return r4 % p;\n        }\n        return 1L;",
  "        if (n == 1L) return p;\n        return ((n % p) + p) % p;", "        long\
    \ q = BitConverter.DoubleToInt64Bits(n) % p;\n        return BitConverter.Int64BitsToDouble(q);",
  "        BigInteger result = BigInteger.One;\n        while (n != 0) {\n       \
    \     result %= p;\n            result *= n;\n            n -= 1;\n        }\n\
    \        return result.ModPow(p, BigInteger.One);", '        return ((long)n)%(p);',
  "        var q = n;\n        if (q == 0)\n            return 0;\n        var r =\
    \ p;\n        while (q % r == 0) {\n            r <<= 1;\n            q = (q <<\
    \ 1) | 1;\n        }\n        return q;", "        var result = 1L;\n        long\
    \ pSquared = Pow(p, 2L);\n        while (pSquared < n) {\n            result +=\
    \ 1L;\n            pSquared = Pow(pSquared, 2L);\n        }\n        result =\
    \ result - 1L;\n        result = result % p; // result % p returns only non-negative\
    \ remainder\n        return result;", "        var result = n;\n        for (int\
    \ i = 0; i < p.N; i++) {\n            result = ((result * result) % p);\n    \
    \    }\n        return result;", '        return ((long) Math.Pow(2, n) % (long)
    p);', "        long m = (1L << (p-1)); \n        return ((n & m)) % p; ", "  \
    \      long r = 1L;\n        for (int i = 0; i < 32; i++) {\n            if (p\
    \ & 1L)\n                r = (r * n) % p;\n            n >>= 1;\n        }\n \
    \       return r;", "        long x = (1L << n) - 1;\n        long q = (1L <<\
    \ p) - 1;\n        long r = x - (q * p);\n        while (true) {\n           \
    \ long g = ((r % p) + q) % p;\n            if (r != g) {\n                long\
    \ h = ((r % p) + q) % p;\n                if (r != h) {\n                    long\
    \ i = (r % p) + q % p;\n                    if (r != i) {\n                  \
    \      long j = (r % p) + q % p;\n                        if (r != j) {\n    \
    \                        long k = (r % p) + q % p;\n                         \
    \   if (r != k) {\n                                long l = (r % p) + q % p;\n\
    \                                if (r != l) {\n                             \
    \       return r;\n                                }\n                       \
    \         return l;\n                            }\n                         \
    \   return k;\n                        }\n                        return j;\n\
    \                    }\n                    return i;\n                }\n   \
    \             return h;\n            }\n            return g;\n        }", " \
    \       if (n == 0)\n            return 1L;\n        if (p == 0)\n           \
    \ return n + 1L;\n        if (n < p * 2)\n            return Modp(n - 1L, p) +\
    \ p;\n        long t = Modp(n - 1L, (p - 1L));\n        if (t < p)\n         \
    \   return t;\n        t = Modp(t, p);\n        if (t < p)\n            return\
    \ t;\n        return (t + p) % p;", "        if (n < 0) {\n            throw new\
    \ ArgumentOutOfRangeException(\"n\");\n        }\n        if (p < 0) {\n     \
    \       throw new ArgumentOutOfRangeException(\"p\");\n        }\n        if (n\
    \ == 0) {\n            return 0;\n        }\n        long q = p;\n        while\
    \ (q < n) {\n            q *= p;\n        }\n        long r = q % p;\n       \
    \ if (q != r) {\n            throw new OverflowException(\"The greatest prime\
    \ factor does not fit into the given number\");\n        }\n        return r;",
  "        int rem = n % p;\n        return (long) (n % p + rem) % p;", "        long\
    \ ret = 1;\n        long q = p >> 1;\n        while ((n & q) != 0) {\n       \
    \     n ^= (q << 1);\n            q = (q << 1) + (q << 2);\n            ret =\
    \ ((ret << 1) + (ret << 2)) ^ (n >> 63);\n        }\n        long m = 0;\n   \
    \     if (n % 2 == 0) {\n            m = ret % p;\n        } else {\n        \
    \    ret = ret % p;\n            m = ret % p;\n        }\n        return m;",
  "        if (p < 0) {\n            throw new ArgumentException(\"p cannot be less\
    \ than 0.\");\n        }\n        if (p == 0) {\n            throw new ArgumentException(\"\
    p cannot be zero.\");\n        }\n        if ((n >> 63) == 0) {\n            return\
    \ n;\n        }\n        long a = n & (-p);\n        long b = (long)Math.Pow(2,\
    \ 32) - p;\n        if (a > b) {\n            throw new ArithmeticException(\"\
    n is not a power of 2.\");\n        }\n        return a % p;", "        long r\
    \ = n;\n        while (r < p) {\n            r <<= 1;\n        }\n        while\
    \ (r > p) {\n            r >>= 1;\n        }\n        return r;", "        long\
    \ bits = n;\n        long r = 1;\n        while (n > 1) {\n            if (bits\
    \ % 2 == 1) {\n                r = (r * p) % p;\n            }\n            bits\
    \ /= 2;\n        }\n        return r;", "        BigInteger result = BigInteger.One.ShiftLeft(n);\n\
    \        result = result.Multiply(p);\n        result = result.Mod(p);\n     \
    \   return result.Value; ", "        long x = 0;\n        long y = 0;\n      \
    \  for (int i = 0; i < 64; i++) {\n            x = x + ((p >> (63 - i)) & 1L);\n\
    \            y = y + ((p >> (63 - i)) & 1L);\n        }\n        return ((x %\
    \ p) + (y % p)) % p;", "        // http://stackoverflow.com/questions/135934/how-do-i-calculate-a-mod-pow-in-c\n\
    \        // http://stackoverflow.com/questions/247779/what-is-the-fastest-way-to-calculate-a-mod-pow-in-c\n\
    \        // https://gist.github.com/4161679\n        // http://stackoverflow.com/questions/1566602/modular-exponentiation-with-java\n\
    \        // http://www.leeholmes.com/blog/2009/05/17/the-fast-way-to-implement-modular-exponentiation/\n\
    \        // http://www.daniweb.com/software-development/csharp/threads/141686/fast-modpow-in-c\n\
    \        // http://stackoverflow.com/questions/988461/fast-mod-pow-algorithm-implementation-fast-for-small-numbers\n\
    \        // http://www.codeproject.com/Articles/334564/Fast-Mod-Pow \n       \
    \ // http://blogs.msdn.com/b/oldnewthing/archive/2004/07/09/49936.aspx\n     \
    \   // http://blogs.msdn.com/b/oldnewthing/archive/2004/07/04/96737.aspx \n  \
    \      // http://www.dreamincode.net/forums/topic/277703-fastest-modpow-implementation/\n\
    \        long q = p / 2;\n        long r = p * q % p;\n        if (q > 0) {\n\
    \            long tmp = 1;\n            while (r > 0) {\n                long\
    \ tmp2 = (r % p);\n                tmp = (tmp * tmp) % p;\n                r =\
    \ (r - tmp2) * tmp % p;\n            }\n            r = (r * tmp) % p;\n     \
    \   }\n        return r;", "        if (n == 0L)\n            return 1L;\n   \
    \     if (p == 0L)\n            return 1L;\n        BigInteger result = BigInteger.ModPow(BigInteger.One,\
    \ n, p);\n        return result.CompareTo(BigInteger.One) < 0 ? result.ToInt64()\
    \ : result.ToInt64();", "        long x = p * n;\n        long n2 = x + p;\n \
    \       n2 %= p;\n        return n2;", "        if (n <= 0)\n            throw\
    \ new ArgumentOutOfRangeException(\"n\", \"n must be positive\");\n        if\
    \ (p <= 0)\n            throw new ArgumentOutOfRangeException(\"p\", \"p must\
    \ be positive\");\n        if (p == 1)\n            return n;\n        if (n <\
    \ p)\n            return Modp(n, p - 1);\n        var r = p * n - p * n;\n   \
    \     r = r * r - p * p;\n        return r == 0 ? n : (r % p + p) % p;", '        return
    ((1L) << ((n * 8L) + p)) % (p * p) % p;', "        BigInteger m = BigInteger.One;\n\
    \        while (n.HasValue)\n            m = m.Multiply(n).Mod(p);\n        return\
    \ m.Value;", '        return ((long)Math.Pow(2, n)) % p;', "        long q = 1;\n\
    \        while ((n & p) != 0) {\n            n = n >> 1;\n            q = q <<\
    \ 1;\n        }\n        return q;", "        BigInteger m = BigInteger.Pow(BigInteger.One,\
    \ BigInteger.ValueOf(p)).Mod(BigInteger.ValueOf(n));\n        return m.ToInt64();",
  "        long res = 1L;\n        while (n != 0L) {\n            long half = (n *\
    \ n) % p;\n            if (half == 0L)\n                return res;\n        \
    \    res = (res % p + half) % p;\n            n /= p;\n        }\n        return\
    \ res;", '        return (p * n) % (p + 1);', "        if (n == 0)\n         \
    \   return 1;\n        if (n == 1)\n            return p;\n        if (p == 0)\n\
    \            return n;\n        if (p == 1)\n            return p;\n        long\
    \ m = (long) Math.Floor((double) p / (double) n);\n        return Modp(n % m,\
    \ p) % m;", "        if (n <= 0) {\n            return 0;\n        }\n       \
    \ if (n == 1) {\n            return p;\n        }\n        long x = 0;\n     \
    \   for (long i = 1; i < n; ++i) {\n            x += (p - 1) * (long) Math.Pow(2,\
    \ i);\n        }\n        x %= p;\n        return (p == 0) ? x % p : x;", "  \
    \      long ans = 1;\n        while (n-- > 0)\n            ans = (ans * p) % p;\n\
    \        return ans;", "        if (n >= p && p != 1L) {\n            long r =\
    \ 1L;\n            while ((n & p) != 0)\n                n /= p;\n           \
    \ while ((n & p) == 0)\n                n /= p;\n            if (n == 0L)\n  \
    \              return r;\n            if (r > p)\n                while (p > 0)\n\
    \                    r = (r * (1L + 1L)) % p;\n            return r;\n       \
    \ }\n        while (n > p)\n            n = (n * (1L + 1L)) % p;\n        return\
    \ n;", '        return (n * n) % p;', "        long d = (long)Math.Pow(2, n) %\
    \ p;\n        return d;", "        BigInteger result = BigInteger.Divide(BigInteger.Pow(2,\
    \ n), BigInteger.Multiply(p, BigInteger.One()));\n        return result.GetBit(result.BitLength\
    \ - 1);", "        if (n < 0)\n            throw new ArgumentException(\"n must\
    \ be non-negative\");\n        if (p < 2)\n            throw new ArgumentException(\"\
    p must be >= 2\");\n        long result = 1L;\n        while (n > 0)\n       \
    \     result *= p;\n        result = result % p;\n        return result;", " \
    \       long m = long.MaxValue;\n        for(long i=0; i<p.Length; i++) {\n  \
    \          long x = n%p[i];\n            if(x >= m) {\n                if((x-m)\
    \ > long.MaxValue) {\n                    m = x + p;\n                }\n    \
    \        } else {\n                if(x < 0) {\n                    m = x + p;\n\
    \                }\n            }\n        }\n        return m;", "        long\
    \ s = 1;\n        while (n == 0) {\n            s = s*p;\n            n = p/2;\n\
    \        }\n        long res = 1;\n        while (n/2 > 0) {\n            if (n\
    \ % 2 == 1) {\n                res*=s;\n            }\n            s/=2;\n   \
    \         n/=2;\n        }\n        return res;", "        if (n == 0)\n     \
    \       return 1L;\n        if (n == 1L)\n            return p;\n        if (p\
    \ == 0)\n            return 0;\n        return ((n % p) + (Modp(n >> 1L, p)) %\
    \ p) % p;", "        Debug.Assert(n != 0);\n        Debug.Assert(p != 0);\n  \
    \      long r = 1;\n        while (r < n) {\n            r = r * 2 + 1;\n    \
    \    }\n        return r % p;", '        return 1L << (n % p);', "        long\
    \ p = long.Parse(\"10\" + p);\n        long res = n % p;\n        if (res < 0)\n\
    \            res += p;\n        return res;", "        if (n == 0) return 1L;\n\
    \        if (n == 1) return p;\n        if (n < 0 || p < 1 || p > n) return 0L;\n\
    \        long q = n / p;\n        long r = n % p;\n        return (1L << (p-1))\
    \ ^ (q << p) ^ r;", "        long result = 0;\n        while (n > 1) {\n     \
    \       long q = n / p;\n            result += (n % p) * (p * (p-1)) / q;\n  \
    \          p = q;\n            n = p / p;\n        }\n        return result *\
    \ p;", "        if (n < 0) {\n            n += p;\n        }\n        if (n ==\
    \ 0 || n == p) {\n            return n;\n        }\n        long a = n;\n    \
    \    while ((a & 1) == 0) {\n            a >>= 1;\n            n <<= 1;\n    \
    \    }\n        return Modp(a, p) % p;", "        BigInteger n2 = BigInteger.Pow(2,\
    \ n);\n        BigInteger p2 = BigInteger.Pow(2, p);\n        return n2.Modulo(p2);",
  "        if (n == 0L)\n            return 1L;\n        if (n == 1L)\n          \
    \  return p;\n        long a = p%n;\n        if (a == 0L)\n            return\
    \ Modp(n - 1, p); \n        if (a == 1L)\n            return n;\n        if (a\
    \ == 2L)\n            return Modp((n * n - 1L) / 2, p);\n        if (a == 3L)\n\
    \            return Modp(Modp(Modp(Modp(Modp(n-1L, p), p), p), p), p);\n     \
    \   if (a == 4L)\n            return Modp(Modp(Modp(Modp(n * n - 2L, p), p), p),\
    \ p);\n        if (a == 5L)\n            return Modp(Modp((n * n - 3L) / 4, p),\
    \ p);\n        if (a == 6L)\n            return Modp(Modp(Modp((n * n - 4L) /\
    \ 2, p), p), p);\n        if (a == 7L)\n            return Modp(Modp((n * n -\
    \ 5L) / 4, p), p);\n        if (a == 8L)\n            return Modp((n * n - 6L)\
    \ / 2, p);\n        if (a == 9L)\n            return Modp((n * n - 7L) / 4, p);\n\
    \        if (a == 10L)\n            return Modp((n * n - 8L) / 2, p);\n      \
    \  if (a == 11L)\n            return Modp((n * n - 9L) / 4, p);\n        if (a\
    \ == 12L)\n            return Modp((n * n - 10L) / 2, p);\n        if (a == 13L)\n\
    \            return Modp((n * n - 11L) / 4, p);\n        if (a == 14L)\n     \
    \       return Modp((n * n - 12L) / 2, p);\n        if (a == 15L)\n          \
    \  return Modp((n * n - 13L) / 4, p);\n        if (a == 16L)\n            return\
    \ Modp((n * n - 14L) / 2, p);\n        if (a == 17L)\n            return Modp((n\
    \ * n - 15L) / 4, p);\n        if (a == 18L)\n            return Modp((n * n -\
    \ 16L) / 2, p);\n        if (a == 19L)\n            return Modp((n * n - 17L)\
    \ / 4, p);\n        if (a == 20L)\n            return Modp((n * n - 18L) / 2,\
    \ p);\n        if (a == 21L)\n            return Modp((n * n - 19L) / 4, p);\n\
    \        if (a == 22L)\n            return Modp((n * n - 20L) / 2, p);\n     \
    \   if (a == 23L)\n            return Modp((n * n - 21L) / 4, p);\n        if\
    \ (a == 24L)\n            return Modp((n * n - 22L) / 2, p);\n        if (a ==\
    \ 25L)\n            return Modp((n * n - 23L) / 4, p);\n        if (a == 26L)\n\
    \            return Modp((n * n - 24L) / 2, p);\n        if (a == 27L)", "   \
    \     int i; long x;\n        if (n < 0) return 0;\n        x = n;\n        if\
    \ ((x & (x >> i = 1L << i)) != 0) x ^= p >> (i-1);\n        while (x >= p) x =\
    \ (x & (-x)) + (x >> 1L);\n        return x & (p-1);", "        long[] x = new\
    \ long[] { 1L };\n        long ret = 1;\n        while (n > 0) {\n           \
    \ long nn = n % p;\n            n /= p;\n            x[0] = nn;\n            for\
    \ (int i = 0; i < x.Length; i++) {\n                x[i + 1] = x[i] * ret + p\
    \ * x[i + 1];\n            }\n            ret = ret % p;\n        }\n        return\
    \ ret;", '        return ((long)Math.Pow(2, n)) % p;', "        ulong n2 = n;\
    \ // n2 ^ 0xffffffffffffffffL == n\n        ulong p2 = p; // p2 ^ 0xffffffffffffffffL\
    \ == p\n        ulong r = n2 % p2;\n        // We need long for the case where\
    \ n >= 2^64 - 1.\n        // 2^64 - 1 == 0xffffffffffffffffUL.\n        if (r\
    \ == 0)\n            return 0;\n        if (r > p) {\n            // The result\
    \ is bigger than p. Thus, p + r is bigger.\n            return p + p - 1;\n  \
    \      }\n        else {\n            // The result is smaller than p. Thus, p\
    \ + r is smaller.\n            return p + r;\n        }", "        long result\
    \ = 1L;\n        while (n-- > 0)\n            result *= p;\n        return result;",
  '        return ((long) Math.Pow(2, n)) % (p % 2 == 0 ? p : p + 1);', "        long\
    \ ret = 1;\n        while (n != 0) {\n            ret *= p;\n            n -=\
    \ (n & -p);\n        }\n        return ret;", "        if (n < 0) return ((n %\
    \ p) + p) % p;\n        return (n % p) % p;", "        long r = 1;\n        while\
    \ (n != 0) {\n            long nr = n % p;\n            n /= p;\n            r\
    \ = r * nr;\n        }\n        return r;", "        long x = 0;\n        while\
    \ (n>0) {\n            if (n&1)\n                x = (x<<1) | (n&p);\n       \
    \     n>>>=1;\n        }\n        return x;", "        BigInteger n = new BigInteger(n);\n\
    \        BigInteger p = new BigInteger(p);\n        // BigInteger n = new BigInteger(n.ToString());\n\
    \        // BigInteger p = new BigInteger(p.ToString());\n        BigInteger result\
    \ = BigInteger.ModPow(n, p, p);\n        // BigInteger result = n.ModPow(p, p);\n\
    \        // BigInteger result = p.Mod(n);\n        if (result.Value > 1L) {\n\
    \            result = result - 1L;\n        }\n        // BigInteger result =\
    \ p.Mod(n);\n        return result.Value;", '        return ((long)Math.Pow(2,
    n)) % p;', "        Debug.Assert(n != 0L);\n        Debug.Assert(p != 0L);\n \
    \       long m = ((long) Math.Pow(2, n)) % p;\n        return m;", "        long\
    \ x = n;\n        long r = 1;\n        while (x >= p) {\n            x = (x %\
    \ p) + r;\n            r = (r * x) / p;\n        }\n        return r;", "    \
    \    var result = 1L;\n        while (result*p < n) {\n            result *= p;\n\
    \        }\n        while (result>n) {\n            result /= p;\n        }\n\
    \        return result;", "        if (p == 0) return n;\n        if (n < 0) return\
    \ ((n % p) + p) % p;\n        if (p <= 0) return (n % p);\n        long nr = n\
    \ % p;\n        long nr2 = nr >> 1;\n        long nr4 = nr >> 2;\n        long\
    \ nr8 = nr >> 3;\n        long nr16 = nr >> 4;\n        long nr32 = nr >> 5;\n\
    \        long nr64 = nr >> 6;\n        long nr128 = nr >> 7;\n        if (nr8\
    \ > p) nr8 -= p;\n        if (nr16 > p) nr16 -= p;\n        if (nr32 > p) nr32\
    \ -= p;\n        if (nr64 > p) nr64 -= p;\n        if (nr128 > p) nr128 -= p;\n\
    \        return (1L << p) * (1L << (nr8 + nr16 + nr32 + nr64 + nr128)) % (1L <<\
    \ p);", "        long m = n;\n        long r = m;\n        long mask = 1;\n  \
    \      while ((r&1) == 0) {\n            mask <<= 1;\n            r >>= 1;\n \
    \       }\n        while (n >= p) {\n            m += p;\n            mask %=\
    \ p;\n            while (m > p) {\n                m -= p;\n                mask\
    \ >>= 1;\n            }\n            n -= p;\n            mask >>= 1;\n      \
    \  }\n        while (n<0) {\n            m *= p;\n            mask %= p;\n   \
    \         while (m > p) {\n                m -= p;\n                mask >>= 1;\n\
    \            }\n            n += p;\n            mask >>= 1;\n        }\n    \
    \    return m;", "        if (n == 0)\n            return 1L;\n\n        var res\
    \ = 1L;\n        var q = 2L;\n        long qmod = p%q;\n        long i = 1L;\n\
    \        while (i < n) {\n            q *= qmod;\n            qmod = p%q;\n  \
    \          res += q;\n            i += 1;\n        }\n        return res;", '        return
    ((long)Math.Pow(Math.Pow(p, 2L), n)) % p;', "        if (n == 0) return n;\n \
    \       if (p == 1) return n;\n        if (p == 2) return n;\n        return ((n\
    \ % p) + p) % p;", "        long q = n >> 31;\n        long r = n % p;\n     \
    \   long t = p >> 31;\n        long m = ((p & t) << 1) | 1;\n        long m2 =\
    \ (m << 1) | 1;\n        long m4 = ((m << 4) | (m << 3) | (m << 2)) ^ m2;\n  \
    \      long m8 = ((m << 2) | (m << 3) | (m << 4)) ^ m4;\n        long m16 = ((m\
    \ << 4) | (m << 6)) ^ m8;\n        return (q ^ r) ^ (m2 ^ m4) ^ (m4 ^ m8);", " \
    \       long res = 1L;\n        while (n-- > 0) {\n            res = (res*p) %\
    \ p;\n        }\n        return res;", "        long result = n;\n        long\
    \ q = long.Parse(Math.Floor(Math.Log(n, p) / Math.Log(2)).ToString());\n     \
    \   if (q > 0) {\n            result %= p;\n        }\n        long r = long.Parse(Math.Floor(Math.Log(p,\
    \ q) / Math.Log(2)).ToString());\n        if (r > 0) {\n            result %=\
    \ q;\n        }\n        return result;", "        long gcd1 = GCD(p, n);\n  \
    \      long gcd2 = GCD(n, p);\n        long gcd3 = GCD(gcd, n);\n        long\
    \ gcd4 = GCD(gcd, p);\n        if (gcd1 == 1L) {\n            return n;\n    \
    \    }\n        if (gcd2 == 1L) {\n            return p;\n        }\n        if\
    \ (gcd3 == 2L) {\n            return n;\n        }\n        if (gcd4 == 1L) {\n\
    \            return p;\n        }\n        if (gcd3==gcd4) {\n            return\
    \ n;\n        }\n        if (gcd1==gcd2) {\n            return p;\n        }\n\
    \        if (gcd1>gcd2 && gcd1>gcd4) {\n            return Modp(gcd1, n);\n  \
    \      }\n        if (gcd2>gcd1 && gcd2>gcd3) {\n            return Modp(gcd2,\
    \ p);\n        }\n        if (gcd3>gcd1 && gcd3>gcd4) {\n            return Modp(gcd3,\
    \ n);\n        }\n        if (gcd4>gcd1 && gcd4>gcd2) {\n            return Modp(gcd4,\
    \ p);\n        }\n        throw new ApplicationException();", '        return
    ((long)Math.Pow(2, n)) % (p);', "        long res = 1;\n        while (res <=\
    \ p) {\n            res = (res*n) % p;\n        }\n        return res;", "   \
    \     long r = 1L;\n        while (r > p) {\n            r /= 2;\n        }\n\
    \        return n % r;", "        long result = 1L;\n        while (n > 0) {\n\
    \            if (n % 2 == 1) {\n                result = result * p;\n       \
    \     }\n            p = p << 1;\n            n = n >> 1;\n        }\n       \
    \ return result;", '        return ((long) n) % ((long) p);', "        long x\
    \ = 0;\n        long y = 1;\n        while (n > 0) {\n            long r = n >>\
    \ 1;\n            long q = n >> 1;\n            n = r;\n            while (q >\
    \ 0) {\n                if (y % 2 == 1) {\n                    y *= p;\n     \
    \           }\n                y /= 2;\n                q--;\n            }\n\
    \            x |= y;\n            y = x;\n        }\n        return ((x % p) !=\
    \ 0);", "        long ans = 0;\n        long mask = 1;\n        long t = 0;\n\
    \        long k = 0;\n        while (n >= p) {\n            ans = ans | ((n &\
    \ mask) << (k++));\n            mask = mask << 1;\n            t = t << 1;\n \
    \           n = n >> 1;\n        }\n        ans = ans | ((n & mask) << (k++));\n\
    \        return ans;", "        if (n == 0L) {\n            return 1L;\n     \
    \   }\n\n        long r = n;\n        while (r >= p) {\n            r = r - p;\n\
    \        }\n\n        return r;", "        long result = 1L;\n        long x =\
    \ n;\n        while (n > 0) {\n            long y = x % p;\n            x /= p;\n\
    \            result *= y;\n        }\n        return result;", "        long result\
    \ = 1L;\n        \n        while ((n % p) != 0) {\n            n /= p;\n     \
    \       result = (result * p) % p;\n        }\n\n        return n;", "       \
    \ long result = 1;\n        long x = 0;\n        long y = 0;\n        long z =\
    \ 0;\n\n        while (n >= p) {\n            x += (n / p);\n            n = n\
    \ % p;\n        }\n\n        while (x != 0) {\n            y = (x % p);\n    \
    \        result = (result * z + y) % p;\n            x = (x - (y * result)) %\
    \ p;\n            z = z * (p - y) / result;\n        }\n        return result;",
  "        if (n >= p)\n            return 1L;\n        else\n            return n\
    \ % p % Modp(n / p, p);", "        if (n == 0L) {\n            return (long)1L;\n\
    \        }\n        if (n == 1L) {\n            return p;\n        }\n       \
    \ long a = n % p;\n        if (a > 1L) {\n            return Modp(a * p, p);\n\
    \        }\n        return (long)(a * Modp(n / p, p));", "        Debug.Assert(p\
    \ > 0);\n        if (n < 0)\n            n *= -1;\n        if (n == 0)\n     \
    \       return 0;\n        var res = 0;\n        var q = n / (long)Math.Pow(2,\
    \ p);\n        var b = n % Math.Pow(2, p);\n        while (q != 0) {\n       \
    \     int t = Math.Abs(q);\n            if (t < p) {\n                res++;\n\
    \                q = Math.DivRem(q, t, out q, out b);\n            }\n       \
    \     else {\n                q *= 2;\n                if (q > 0)\n          \
    \          q--;\n                res = 1;\n            }\n        }\n        return\
    \ res;", "        if (n < 0 || p < 0)\n            throw new ArgumentOutOfRangeException(\"\
    n < 0 or p < 0\");\n\n        long x = 0;\n        while ((x << 1) <= n) {\n \
    \           x = (x << 1) | 1;\n        }\n\n        long y = (x << p) & p;\n\n\
    \        while (y > 1) {\n            y = y >> 1;\n            x = ((x & p) <<\
    \ 1) | 1;\n        }\n\n        return (x % p);", "        Debug.Assert(n >= 0\
    \ && n < p);\n        if (n == 0)\n            return 1L;\n        if (p == 1)\n\
    \            return n;\n        if (p == 0)\n            return 0;\n        if\
    \ (n == p)\n            return n;\n        long r = n % p;\n        if (n >= p)\n\
    \            return Modp(r * p, p) * Modp(r, (p - 1));\n        return Modp((p\
    \ - 1) * r, p) * (r % p);", "        var q = p / n;\n        var r = p % n;\n\
    \        var d = q * q;\n        var y = r * q;\n        var a = q;\n        var\
    \ c = r - y;\n        var b = (q * r + y) * q;\n        return (r % p) + ((a %\
    \ p) + (b % p) + (c % p)) % p;", "        if (n < 0)\n            throw new ArgumentException(\"\
    n < 0\");\n        if (p < 1L)\n            throw new ArgumentException(\"p <\
    \ 1\");\n\n        if ((n & p) == 0)\n            return n;\n        long r =\
    \ n;\n        long t;\n        do {\n            t += r / p;\n            r %=\
    \ p;\n            if (t > p)\n                t -= p;\n        } while (r != 0);\n\
    \        return t;", "        long ret = 1;\n        while (n != 0) {\n      \
    \      if (n % 2 == 1) ret = (ret * ((p % 2 == 0) ? p : p - 1)) + 1;\n       \
    \     n = n / 2;\n        }\n        return ret;", "        long r = 1L;\n   \
    \     while ((n&1) == 1) {\n            r = r * 2L;\n            n = n >> 1L;\n\
    \        }\n        while ((n&1) == 0) {\n            r = r * 2L;\n          \
    \  n = n >> 1L;\n        }\n        while ((n&1) == 1) {\n            r = r *\
    \ p;\n            n = n >> 1L;\n        }\n        while ((n&1) == 0) {\n    \
    \        r = r * p;\n            n = n >> 1L;\n        }\n        return r;",
  "        double x = 1L;\n        long ans = 0;\n        do {\n            ans =\
    \ (ans * x) % p;\n            x /= 2;\n        } while (x > 1L);\n        return\
    \ (ans * n) % p;", "        if (n == 0)\n            return 1L;\n        long\
    \ res = 1L;\n        long r = n%p;\n        while (r >= p) {\n            res\
    \ = res*p + (r%p);\n            r = r/p;\n        }\n        return res%p;", '        return
    ((1L) * (long) n) / ((2L) * (long) p);', '        return ((n%p) * (p%p)) % (p%p);',
  "        Debug.Assert(n > 0);\n        Debug.Assert(p > 0);\n        long ret =\
    \ 1;\n        while (n > 1) {\n            if (n & 1)\n                ret *=\
    \ p;\n            n >>= 1;\n            p *= p;\n        }\n        return ret;",
  "        long c = 1;\n        long m = 0;\n        while (n > 0) {\n           \
    \ c = (n * c) % p;\n            n--;\n        }\n        while (n == 1) {\n  \
    \          c = (n * c) % p;\n            n--;\n        }\n        return c;",
  "        if (n == 0)\n            return 0;\n        if (n == p)\n            return\
    \ n;\n        long c = 1;\n        long d = 2;\n        while (true) {\n     \
    \       if (n % d == 0)\n                return d;\n            d += c;\n    \
    \        c *= 10;\n        }", "        long x = 0;\n        long p = 1;\n   \
    \     while (n > p) {\n            long r1 = (n % p); // remainder 1\n       \
    \     long r2 = (n / p); // remainder 2\n            long r = r1 * r2;\n     \
    \       n = r; // modulus 1\n            p = r1; // modulus 2\n            x +=\
    \ (long)((r * p) % (p - 1L));\n        }\n        return x;", "        BigInteger\
    \ modBigInteger = new BigInteger(\"1\");\n        while (!modBigInteger.Equals(new\
    \ BigInteger(p))) {\n            modBigInteger = modBigInteger.multiply(new BigInteger(p).divide(new\
    \ BigInteger(p)));\n        }\n        return modBigInteger.remainder(n).divide(new\
    \ BigInteger(p)).longValue;", '        return ((long) 1) << ((p - 1) % p) + (((long)
    1L) >> ((p - 1) / p));', "        long c = 1;\n        long m = (n+1)/p;\n   \
    \     for(int i=1; i <= m; i++) {\n            c = (c*m) % p;\n        }\n   \
    \     return c;", "        long x = 0;\n        for (; n != 0; n >>= 1, x++) {\n\
    \            if (n % 2 == 0) {\n                x ^= p;\n            }\n     \
    \       p <<= 1;\n            if (p > p) {\n                p ^= p;\n        \
    \    }\n        }\n        return x;", "        long nToP = n % p;\n        return\
    \ (nToP > 0) ? Modp(nToP, p) : (p == 0) ? 0 : 1;", "        if (n == 0L) {\n \
    \           return 1L;\n        } else if (n >= p) {\n            return 1L;\n\
    \        }\n        long ret = 1L;\n        while (n % 2L == 0) {\n          \
    \  ret *= 2L;\n            n /= 2L;\n        }\n        while ((n % p) != 0L)\
    \ {\n            ret *= p;\n            n /= p;\n        }\n        return ret;",
  "        BigInteger res = BigInteger.Pow(2, n).Mod(p);\n        return (long)res;",
  "        if (n == 0 || n == 1L)\n            return n;\n        long x = 3L;\n \
    \       long y = p * (p + 1L);\n        if (n % 2L != 0L) {\n            x = x\
    \ % (p + 1L);\n        }\n        return ((n % 2L == 0L) ? x : ((x * x) % p))\
    \ % p + 1L;", "        BigInteger result = BigInteger.Zero;\n        for (int\
    \ i = 0; i < n; i++) {\n            result = result.Add(BigInteger.One);\n   \
    \         result = result.Multiply(p);\n        }\n        result = result.Divide(p);\n\
    \        return result.ToString();", "        long res = 1L;\n        while (n\
    \ >= p) {\n            res *= p;\n            n -= p;\n        }\n        while\
    \ (n > 1L) {\n            res %= p;\n            n >>= 1;\n        }\n       \
    \ return res;", "        if (n == 0) {\n            return 1L;\n        }\n  \
    \      if (p == 1) {\n            return n;\n        }\n        if (n == p) {\n\
    \            return n;\n        }\n        long q = 1L;\n        long r = p +\
    \ 1L;\n        while (true) {\n            q = (r * q) % p;\n            if (q\
    \ == 0L) {\n                return n;\n            }\n            r = (r * p)\
    \ % p;\n        }", "        var m = (long)p.ToLongBits() % n;\n        Debug.Assert(m\
    \ != 0L);\n        return m;", "        var result = n - (long)Math.Pow(System.Math.Pow(2,\
    \ n), p);\n        return result;", "        long q, r;\n        if (n == 0L)\n\
    \            return 1L;\n        q = ((1L) << n);\n        r = ((1L) << n) - p;\n\
    \        if (n == 0L)\n            return p;\n        return ((r * q) % p);",
  "        int r = n - 1L;\n        // r >> (n * 8L) >> r is faster than the mod operation\n\
    \        return r > 0 ? r % p : p - r % p;", "        if ((n == 0) && (p == 0))\n\
    \            return 1;\n        if ((n % p) == 0)\n            return n;\n   \
    \     else\n            return ((n % p) + p) % p;", "        long r = 1L;\n  \
    \      for(int i = 1; i >= 0; i--) {\n            r = ((r * n) % p + p) % p;\n\
    \        }\n        return r;", "        if (n < 0)\n            throw new ArgumentOutOfRangeException(\"\
    n\", \"n must be non-negative\");\n        if (p < 0)\n            throw new ArgumentOutOfRangeException(\"\
    p\", \"p must be non-negative\");\n\n        // Fast case: p = 1, n < p or n ==\
    \ p.\n        if (p == 1)\n            return n;\n\n        // Fast case: p =\
    \ 2, n < p or n == p.\n        if (p == 2)\n            return n % p;\n\n    \
    \    // Simple case: p = 3, n < p or n == p (via repeated squaring).\n       \
    \ long r = n % p;\n        if (r == 0)\n            return n;\n        if (r ==\
    \ 1)\n            return n * n;\n        r = p * r;\n        while (r % p != 0)\n\
    \            r = r / p;\n        return r;", "        // Return 2^n modulo p.\n\
    \        // >>> Modp((3L), (5L))\n        // (3L)\n        // >>> Modp((1101L),\
    \ (101L))\n        // (2L)\n        // >>> Modp((0L), (101L))\n        // (1L)\n\
    \        // >>> Modp((3L), (11L))\n        // (8L)\n        // >>> Modp((100L),\
    \ (101L))\n        // (1L)\n        long result = 1L;\n        while ((n & 1L)\
    \ == 0L) {\n            result *= p;\n            n >>= 1;\n        }\n      \
    \  result %= p;\n        if (result < 1L) {\n            result <<= 1L;\n    \
    \    } else {\n            result >>= 1L;\n        }\n        return result;",
  "        long res = 1;\n        while (n > 0) {\n            res = (res * n) % p;\n\
    \            n /= p;\n        }\n        return res;", "        long r = 1L;\n\
    \        while (n > 0L) {\n            long d = ((r * n) % p) % p;\n         \
    \   if (d != 0L) {\n                r ^= d;\n            }\n            n /= 2L;\n\
    \        }\n        if (r == 0L) {\n            r = (-1L);\n        }\n      \
    \  return r;", "        if (n < 0) return 0L;\n        if (p <= 0L) return 1L;\n\
    \        if (p >= n) return 1L;\n        if (n & 1L) n = n - 2L;\n        long\
    \ x = 0L;\n        for (long k = 0; k < p; k++) {\n            long r = n & p;\n\
    \            long y = r | (r >> 1);\n            long m = ((x << k) | (x >> 1))\
    \ | y;\n            x = m;\n        }\n        return x % p;", "        long r\
    \ = 1L;\n        while (n > 0) {\n            r %= p;\n            r *= n;\n \
    \           n /= 2;\n        }\n        return r;", "        long g = (n%p);\n\
    \        long e = 0;\n        while (g != 0) {\n            e++;\n           \
    \ g = g >> 1;\n        }\n        return (long)Math.Pow(2, ((long) e)-p);", " \
    \       BigInteger q = BigInteger.Pow(p, n, p);\n        return (long)q.ModPow(2,\
    \ p).Mod(p);", "        BigInteger big = new BigInteger(BigInteger.Pow(n, (p+1)).ToString());\n\
    \        BigInteger mod = big.Modulo(p);\n        return mod.ToString();", " \
    \       // TODO: Make me recursive.\n        // TODO: Make me efficient.\n   \
    \     long ret = 1;\n        while (n > 0) {\n            if ((n % 2) == 0) {\n\
    \                ret = (ret*(n%p)) % p;\n            }\n            n = n >> 1;\n\
    \        }\n        return ret;", "        long m = (long) Math.Pow(2, n) - 1;\n\
    \        if (m == -1)\n            return p;\n        else if (m > 0)\n      \
    \      return (p - (long) Math.Pow(p, m)) / m;\n        else\n            return\
    \ p + (long) Math.Pow(p, m);", '        return ((long) Math.Pow(2, n)) % p;',
  "        var a = (long) (1 << p);\n        return (long)(((long)(n * a)) % p);",
  '        return (long)(Math.Pow(2, n) % (p - 1));', "        BigInteger bi1 = new\
    \ BigInteger(n);\n        BigInteger bi2 = new BigInteger(p);\n        BigInteger\
    \ bi3 = new BigInteger((bi1+1));\n        bi1 = bi1.Subtract(bi3);\n        long\
    \ x = bi1.ModPow(bi2, p);\n        if (bi1.CompareTo(BigInteger.Zero) == -1) return\
    \ 0;\n        if (bi1.CompareTo(p) == 1) return x;\n        BigInteger bi4 = new\
    \ BigInteger(p);\n        BigInteger bi5 = new BigInteger((bi4+1));\n        long\
    \ y = bi4.ModPow(bi5, p);\n        if (bi4.CompareTo(BigInteger.Zero) == -1) return\
    \ 0;\n        if (bi4.CompareTo(p) == 1) return y;\n        if (bi2.CompareTo(p)\
    \ == 1) return (x+1)%p;\n        return x%p;", "        if (n == 0) return p;\n\
    \        if (n < 0) n = -n;\n        if (p > n) p = n;\n        long g = n * ((long)Math.Pow(2,\
    \ p)) % p;\n        return g;", "        long ans = 1;\n        while (n > p)\
    \ {\n            ans = (ans * (n % p)) % p;\n            n /= p;\n        }\n\
    \        if (n == 0)\n            ans = (ans * p) % p;\n        return ans;",
  "        long q = n - 1L;\n        long r = p * q;\n        long s = q << 1L;\n\
    \        long u = ((1L << p) - 1) - (((1L << q) + s) % p);\n        return (r\
    \ + (n % p)) * u;", "        if (n == 0) {\n            return 1L;\n        }\n\
    \        if (n == 1L) {\n            return p;\n        }\n        long ret =\
    \ 1L;\n        long temp = 1L;\n        while (n > 0) {\n            if (n % 2\
    \ == 0) {\n                ret *= temp;\n                ret %= p;\n         \
    \   }\n            temp = temp * temp;\n            n /= 2;\n        }\n     \
    \   return ret;", "        if (n < 0)\n            throw new ArgumentException(\"\
    n < 0\");\n        if (p < 2)\n            throw new ArgumentException(\"p < 2\"\
    );\n        long result = 1;\n        long m = p / 2;\n        while (p > 1) {\n\
    \            result *= n;\n            if (n % 2 == 1)\n                result\
    \ %= m;\n            n /= 2;\n            m /= 2;\n            p--;\n        }\n\
    \        return result;", "        long q = 0;\n        long m = 0;\n        long\
    \ r = 1L;\n        do {\n            q = r % p;\n            m = n % p;\n    \
    \        r = (r * p + m) / p;\n        } while (!((r % p) == 0));\n        return\
    \ q;", "        long res = 1L;\n        while(n>0) {\n            res = (res *\
    \ (long)(p)%n) % p;\n            n = (long)(n/(long)p);\n        }\n        return\
    \ res;", "        long q = n / p;\n        long r = n % p;\n        return (r\
    \ > 0) ? Modp(q, p) * p + r : q;", "        if (n == 0)\n            return 0;\n\
    \        if (n == 1)\n            return 1;\n        return ((long) Math.Pow(Double.Parse(Math.Pow(p.ToString(),\
    \ (n % 2L) + 1)), Double.Parse(Math.Pow(p.ToString(), (n % 2L) - 1)))) % p;",
  "        // We will take advantage of modular arithmetic.\n        // Modular arithmetic\
    \ is well known to mankind.\n        // It's a useful mathematical tool.\n\n \
    \       // To implement modular arithmetic, we will add each digit\n        //\
    \ modulo p.\n        // We will store the intermediate results.\n        long\
    \ res = 1;\n        while (n > 0) {\n            if (n % p == 0) res = (res*p\
    \ + n % p) % p;\n            n = n / p;\n        }\n        // Recall that modular\
    \ arithmetic is associative and commutative.\n        // That means that if a\
    \ = b + c + d, a < b < c < d.\n        // The order in which we do this is the\
    \ order in which we add the\n        // numbers.\n        return res;", "    \
    \    long ret = 1;\n        while (n > 0) {\n            n -= p;\n           \
    \ ret *= p;\n        }\n        return ret;", "        long q = n / p;\n     \
    \   long r = n % p;\n        if (q == 0)\n            return r;\n        long\
    \ t = q - 1;\n        long ans = r;\n        while (q > 0) {\n            long\
    \ a = p * ans;\n            long b = p * t;\n            ans = a + b;\n      \
    \      t += q;\n            q -= 1;\n        }\n        return ans;", "      \
    \  long res = 0;\n        long n4 = n * 4;\n        long p4 = p * 4;\n\n     \
    \   while (n4 >= p4) {\n            if (n4 % p4 != 0) {\n                throw\
    \ new Exception(\"modp is buggy\");\n            }\n\n            res = (res *\
    \ p + n) % p;\n            n4 /= p4;\n            p4 /= 4;\n        }\n\n    \
    \    if (n4 > 0) {\n            res = (res * n + n4) % p;\n        }\n\n     \
    \   return res;", "        if (n == 0)\n            return p;\n        if (n &\
    \ n >> 63)\n            throw new ArgumentException(\"n must be 2^63 - 1 mod p\"\
    );\n        if (p == 1)\n            return n;\n        return Modp((n & n + 1L)\
    \ * (p - 1L), p);", "        BigInteger result = BigInteger.One;\n        while\
    \ ((n % p) != 0) {\n            result = result.Multiply(p);\n            n =\
    \ n / p;\n        }\n        result = result.Multiply(p);\n        return result.ModPow(2,\
    \ n);", "        long result = 1L;\n        for (long i = 1; i < p; i++) {\n \
    \           result *= n;\n            result %= p;\n        }\n        return\
    \ result;", "        var g = Convert.ToInt64(Math.Pow(p, long.MaxValue));\n  \
    \      var r = n;\n        var h = g;\n        long x = 1;\n        var q = 0;\n\
    \        do {\n            if ((x % p) == 0) {\n                q += x;\n    \
    \        }\n            h = g - q;\n            g = x;\n            x /= p;\n\
    \        } while (!(x == 0));\n        return r;", "        long q = Math.Ceiling(n/p);\n\
    \        if (n < p * q)\n            return p;\n        else\n            return\
    \ (n % p) + q;", '        return (long)Math.Floor(Math.Pow(2, n) % p);', "   \
    \     long x = 3L;\n        long m = 1L;\n        while (x < (n-p)) {\n      \
    \      m *= x;\n            x += (long)Math.Pow(p, x);\n        }\n        if\
    \ (m == 1L)\n            return x;\n        else\n            return (n+m) % p;",
  "        long ret = 1;\n        while (n > 0) {\n            ret *= p;\n       \
    \     n -= (long)Math.Pow(p, (int)((int)n));\n        }\n        return ret;",
  "        long r = 1;\n        long m = 0;\n        while (n) {\n            if (n\
    \ & 1L) {\n                m += p;\n            }\n            r <<= 1;\n    \
    \        m += r * p;\n            n >>= 1;\n        }\n        return m % p;",
  "        long q = n / p;\n        if (q < p) return (n % p);\n        long r = q\
    \ % p;\n        return (r + (p-r))%p;", "        double r = Math.Pow(2, n) % p;\n\
    \        if (r < 0)\n            r += p; // r may go negative\n        return\
    \ Convert.ToInt64(r);", "        long res = n%p;\n        long p1 = p-1;\n   \
    \     while (p > p1) {\n            if (p%p1 == 0)\n                res = n%p1;\n\
    \            p /= p1;\n        }\n        return res;", '        return ((long)Math.Pow(2,
    n)) % (p);', "        long m = BigInteger.One;\n        for (long i = BigInteger.One;\
    \ i < p; i++) {\n            m = m.Multiply(m).Add(BigInteger.One);\n        }\n\
    \        return n % p;", "        // Use \"long long multiplication\" trick for\
    \ modular exponentiation with carry.\n        // See http://stackoverflow.com/questions/5573639/efficient-modular-exponentiation-algorithm-for-64-bit-integers-modulo-m/5574101#5574101\n\
    \        long a = 1L << 63;\n        long b = 1L << n;\n        long c = 0L;\n\
    \        long res = 1L;\n        for(int i = n-1; i >= 0; i--) {\n           \
    \ long temp = a;\n            long prod = 1L;\n            for(int j = 0; j <\
    \ i; j++) prod *= (long) p[j];\n            for(int j = 0; j < i; j++) temp =\
    \ (temp * prod) % p;\n            res = (res + temp) % p;\n        }\n       \
    \ return res;", "        if (p == 1L)\n            return n;\n        long ret\
    \ = 0L;\n        while ((n >> ret) != 0L) {\n            ret += p;\n        }\n\
    \        while (ret < 1L) {\n            ret <<= 1;\n            if (ret == 0L)\n\
    \                ret += p;\n        }\n        return ret;", "        BigInteger\
    \ n = BigInteger.Pow(n, (int)p);\n        BigInteger p = BigInteger.Pow(p, (int)p);\n\
    \        return n.Mod(p);", '        return ((long)n) % (p + 1);', "        long\
    \ bits = BitConverter.DoubleToInt64Bits(n);\n        long bits1 = BitConverter.DoubleToInt64Bits(p);\n\
    \        long bits2 = BitConverter.DoubleToInt64Bits(1L);\n        return (((bits)\
    \ * (bits2 % bits1)) - (bits2 % bits1));", "        var q = n >> 31;\n       \
    \ if (n & 0x1ffL == 0L) {\n            return q;\n        }\n        var r = 0L;\n\
    \        long bits = 1L;\n        while (true) {\n            if ((n & bits) !=\
    \ 0L) {\n                r += p;\n            }\n            if (r >= p) {\n \
    \               r -= p;\n            }\n            bits++;\n            if (bits\
    \ == 64L) {\n                bits--;\n                q = r >> 31;\n         \
    \       r = 0L;\n                if (q >= p) return q;\n            }\n      \
    \  }", '        return ((n&(p-1))|((n&p)>>31)) % p;', '        return ((long)(Math.Pow(2,
    n)) % p);']
stop_tokens:
- "\n    }\n"
