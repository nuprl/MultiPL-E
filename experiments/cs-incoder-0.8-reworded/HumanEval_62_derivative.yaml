name: HumanEval_62_derivative
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // xs represent coefficients of a polynomial.\n    // xs[0] + xs[1]\
  \ * x + xs[2] * x^2 + ....\n    // Return derivative of this polynomial in the same\
  \ form.\n    // >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L,\
  \ (long)4L, (long)5L})))\n    // (new List<long>(new long[]{(long)1L, (long)4L,\
  \ (long)12L, (long)20L}))\n    // >>> Derivative((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L})))\n    // (new List<long>(new long[]{(long)2L, (long)6L}))\n\
  \    public static List<long> Derivative(List<long> xs) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Derivative((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));\n    Debug.Assert(Derivative((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new\
  \ long[]{(long)2L, (long)6L}))));\n    Debug.Assert(Derivative((new List<long>(new\
  \ long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L,\
  \ (long)2L}))));\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L,\
  \ (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,\
  \ (long)2L, (long)0L, (long)16L}))));\n    Debug.Assert(Derivative((new List<long>(new\
  \ long[]{(long)1L}))).Equals((new List<long>())));\n    }\n\n}\n"
completions: ["        var coefficients = xs.Take(xs.Count - 1).ToList();\n      \
    \  coefficients.Add(1);\n        var f = coefficients.Select(c => (long)Math.Pow(2.0\
    \ * c, xs.Last() - xs.Count - 1)).Sum();\n        var result = new List<long>();\n\
    \        for (int i = 0; i < xs.Count - 1; i++) {\n            result.Add(f);\n\
    \        }\n        return result;", "        if (xs.Count < 2) {\n          \
    \  throw new ArgumentException(\"At least two coefficients required\");\n    \
    \    }\n        long[] result = new long[xs.Count];\n        result[0] = xs[1];\n\
    \        for (int i = 2; i <= xs.Count; i++) {\n            result[i] = result[i\
    \ - 1] * xs[i];\n        }\n        return result;", "        List<long> ret =\
    \ new List<long>();\n        for (int i = xs.Count - 1; i > 0; i--) {\n      \
    \      for (int j = 1; j < xs.Count - 1; j++) {\n                ret.Add(xs[i]\
    \ * xs[j] * pow(xs[i] - xs[j], 2));\n            }\n        }\n        return\
    \ ret;", "        var n = new List<long>();\n        var d = new List<long>();\n\
    \        for (var i = xs.Count - 1; i > 0; i--) {\n            n.Add(xs[i]);\n\
    \            for (var j = 0; j < i; j++) {\n                d.Add(n[j] * xs[j]);\n\
    \            }\n        }\n        return d;", "        // Return Derivative(xs)\
    \ when xs is 0.\n        if (xs.Count != 1) return Derivative(xs.Skip(1).ToList());\n\
    \n        // Return Derivative(xs) when xs is 1.\n        if (xs[0] == 1) return\
    \ new List<long> {xs[0]};\n\n        // Return Derivative(xs) when xs is 2.\n\
    \        if (xs[0] == 2) {\n            var d = new List<long> { xs[0] };\n  \
    \          for (int i = 1; i < xs.Count; i++) {\n                d.Add(xs[i] +\
    \ d[i-1]);\n            }\n            return d;\n        }\n\n        // Return\
    \ Derivative(xs) when xs is 3.\n        if (xs[0] == 3) {\n            var d =\
    \ new List<long> { xs[0] };\n            for (int i = 1; i < xs.Count; i++) {\n\
    \                d.Add(xs[i] + d[i-1]*x + d[i-2]*x*x + d[i-3]*x*x*x);\n      \
    \      }\n            return d;\n        }\n\n        // Return Derivative(xs)\
    \ when xs is 4.\n        if (xs[0] == 4) {\n            var d = new List<long>\
    \ { xs[0] };\n            for (int i = 1; i < xs.Count; i++) {\n             \
    \   d.Add(xs[i] + d[i-1]*x*x + d[i-2]*x*x*x + d[i-3]*x*x*x*x + d[i-4]*x*x*x*x*x);\n\
    \            }\n            return d;\n        }\n\n        // Return Derivative(xs)\
    \ when xs is 5.\n        if (xs[0] == 5) {\n            var d = new List<long>\
    \ { xs[0] };\n            for (int i = 1; i < xs.Count; i++) {\n             \
    \   d.Add(xs[i] + d[i-1]*x*x*x + d[i-2]*x*x*x*x + d[i-3]*x*x*x*x*x + d[i-4]*x*x*x*x*x*x\
    \ + d[i-5]*x*x*x*x*x*x*x);\n            }\n            return d;\n        }\n\n\
    \        // Return Derivative(xs) when xs is 6.\n        if (xs[0] == 6) {\n \
    \           var d = new List<long> { xs[0] };\n            for (int i = 1; i <\
    \ xs.Count; i++) {\n                d.Add(xs[i] + d[i-1]*x*x*x*x + d[i-2]*x*x*x*x*x\
    \ + d[i-3]*x*x*x*x*x*x + d[i-4]*x*x*x*x*x*x*x + d[i-5]*x*x*x*x*x*x*x*x + d[i-6]*x*x*x*x*x*x*x*x*x);\n\
    \            }\n            return d;\n        }\n\n        // Return Derivative(xs)\
    \ when xs is 7.\n        if (xs[0] == 7) {\n            var d = new List<long>\
    \ { xs[0] };\n            for (int i = 1; i < xs.Count; i++) {", "        int\
    \ n = (int)xs.Count;\n        List<long> der = new List<long>();\n        der[0]\
    \ = xs[0];\n        der[1] = 1;\n        for (int i = 2; i <= n - 1; ++i) {\n\
    \            der[i] = 2 * der[i - 1];\n        }\n        if (n > 0) {\n     \
    \       der[n] = 2 * der[n];\n        }\n        return der;", "        var result\
    \ = new List<long>();\n        var power = xs.Count - 1;\n        var delta =\
    \ xs[power];\n        long res = 0;\n        var x = 1;\n        for (var i =\
    \ power; i >= 0; i--) {\n            power--;\n            res = x * xs[i] + res;\n\
    \            x = power;\n        }\n        result[0] = res;\n        for (int\
    \ i = 1; i < xs.Count; i++) {\n            var j = i + 1;\n            while (j\
    \ < xs.Count) {\n                result[i] += xs[j] * result[j - 1];\n       \
    \         j++;\n            }\n            result[i] /= delta;\n        }\n  \
    \      return result;", "        if (null == xs) return null;\n        List<long>\
    \ y = new List<long>();\n        y.Add(xs[0]);\n        y.Add(xs[1]);\n      \
    \  y.Add(xs[2]);\n        y.Add(xs[3]);\n        for (int i = 4; i < xs.Count;\
    \ i++) {\n            y.Add(y[i-2] * xs[i]);\n        }\n        return y;", " \
    \       if (xs == null)\n            throw new ArgumentNullException(\"xs\");\n\
    \        if (xs.Count < 2)\n            throw new ArgumentException(\"polynomial\
    \ has only one term\");\n        double s = 1.0; // coeff of the constant term.\n\
    \        double y = xs.First();\n        List<long> ys = new List<long>(new long[xs.Count]);\n\
    \        for (long i = 1; i < xs.Count; i++) {\n            s += xs[i] * y;\n\
    \            ys[i] = s / xs[i];\n            y = ys[i];\n        }\n        return\
    \ ys;", "        // Get all terms from the polynomial:\n        List<long> terms\
    \ = new List<long>();\n        foreach (long x in xs)\n            terms.Add(1L);\n\
    \        terms.AddRange(xs);\n        // Remove duplicate terms:\n        List<long>\
    \ uniqueTerms = new List<long>();\n        foreach (long term in terms)\n    \
    \        if (!uniqueTerms.Contains(term))\n                uniqueTerms.Add(term);\n\
    \        // Find all unique exponents:\n        List<long> exponents = new List<long>();\n\
    \        foreach (long term in uniqueTerms)\n            for (int i = 1; i < term.ToString().Length;\
    \ i++)\n                exponents.Add(BigInteger.Pow(term, i));\n        // Construct\
    \ derivative:\n        List<long> derivative = new List<long>();\n        foreach\
    \ (long term in exponents)\n            derivative.Add(term);\n        derivative.Add(1L);\n\
    \        return derivative;", "        // Calculate the derivative.\n        long\
    \ product = 0;\n        for (long i = 0; i < xs.Count; i++) {\n            product\
    \ += xs[i] * xs.Count - xs[i - 1];\n        }\n        // Calculate derivative.\n\
    \        long d = 1 / (xs.Count - 1);\n        // Return the derivative.\n   \
    \     List<long> result = new List<long>();\n        for (long i = xs.Count -\
    \ 1; i > 0; i--) {\n            result.Add(i * d * product);\n        }\n    \
    \    return result;", "        var results = new List<long>();\n        var x\
    \ = xs[0];\n        var xPower = 1;\n        bool isFirst = true;\n        for\
    \ (var i = 1; i < xs.Count; i++) {\n            var nextX = x * xPower + xs[i];\n\
    \            if (isFirst) {\n                results.Add(x);\n               \
    \ isFirst = false;\n            } else {\n                results.Add(nextX);\n\
    \            }\n            xPower = xPower * x; // x^x = 1\n            x = nextX;\n\
    \        }\n        return results;", "        List<long> ret = new List<long>(0);\n\
    \        for (int i = 0; i < xs.Count - 1; i++) {\n            ret.Add(xs[i +\
    \ 1] - xs[i]);\n        }\n        return ret;", "        // For simple polynomials\
    \ of degree 1, or polynomials of degree 2 or\n        // higher with common factors\
    \ other than 1.\n        if (xs.Count < 3) return new List<long>(new long[0]);\n\
    \        long[] a = xs.Take(2).ToArray();\n        long[] b = xs.Skip(2).ToArray();\n\
    \        int[] c = new int[xs.Count - 1];\n        for (int i = 0; i < xs.Count\
    \ - 1; i++) {\n            c[i] = b[i] / a[i];\n        }\n        long[] p =\
    \ new long[xs.Count - 1];\n        for (int i = 1; i < xs.Count - 1; i++) {\n\
    \            p[i] = c[i - 1] * xs[i] - c[i - 1];\n        }\n        return new\
    \ List<long>(p.Reverse().ToArray());", "        if (xs.Count <= 1) {\n       \
    \     // Don't do anything for singular polynomials.\n            return new List<long>(new\
    \ long[0]);\n        }\n\n        List<long> der = new List<long>(new long[xs.Count]);\n\
    \        der[0] = 1;\n        for (int i = 1; i < xs.Count; i++) {\n         \
    \   der[i] = der[i - 1] * xs[i];\n        }\n\n        return der;", "       \
    \ Debug.Assert(xs.Count > 1);\n\n        BigInteger zero = BigInteger.Zero;\n\
    \        BigInteger one = BigInteger.One;\n        BigInteger two = BigInteger.Two;\n\
    \        BigInteger two3 = BigInteger.Two3;\n\n        var res = new List<long>();\n\
    \        var oneDer = one.Pow(2);\n        var twoDer = two.Pow(3);\n\n      \
    \  // Evaluate derivative of x^3 with x^2 for each x.\n        for (long i = 0;\
    \ i < xs.Count; i++) {\n            BigInteger x = xs[i];\n\n            // Evaluate\
    \ derivative of x^3 with x^2 for each x.\n            BigInteger dx3 = x.Pow(3);\n\
    \            BigInteger dx2 = x.Pow(2);\n\n            // Evaluate derivative\
    \ of x^3 with x^2 for each x.\n            BigInteger de3 = x.Pow(3);\n      \
    \      BigInteger de2 = x.Pow(2);\n\n            // Evaluate derivative of x^3\
    \ with x^2 for each x.\n            BigInteger de4 = (dx3.Subtract(dx2)).Multiply(de3);\n\
    \n            // Evaluate derivative of x^3 with x^2 for each x.\n           \
    \ BigInteger de5 = de4.Multiply(two3);\n\n            // Evaluate derivative of\
    \ x^3 with x^2 for each x.\n            BigInteger de6 = de5.Multiply(two);\n\n\
    \            // Evaluate derivative of x^3 with x^2 for each x.\n            BigInteger\
    \ de7 = de6.Multiply(oneDer);\n\n            // Evaluate derivative of x^3 with\
    \ x^2 for each x.\n            BigInteger de8 = de7.Subtract(de2);\n\n       \
    \     // Evaluate derivative of x^3 with x^2 for each x.\n            BigInteger\
    \ de9 = de8.Subtract(dx3);\n\n            // Evaluate derivative of x^3 with x^2\
    \ for each x.\n            BigInteger de10 = de9.Subtract(dx2.Pow(2));\n\n   \
    \         // Evaluate derivative of x^3 with x^2 for each x.\n            BigInteger\
    \ de11 = de10.Multiply(de7);\n\n            // Evaluate derivative of x^3 with\
    \ x^2 for each x.\n            BigInteger de12 = de11.Subtract(de2);\n\n     \
    \       // Evaluate derivative of x^3 with x^2 for each x.\n            BigInteger\
    \ de13 = de12.Multiply(de3);\n\n            // Evaluate derivative of x^3 with\
    \ x^2 for each x.\n            BigInteger de14 = de13.Subtract(de4);\n\n     \
    \       // Evaluate derivative of x^3 with x^2 for each x.\n            BigInteger\
    \ de", "        List<long> deriv = new List<long>();\n        for(int i = 1; i\
    \ < xs.Count - 1; i++) {\n            deriv.Add(xs[i] + xs[i + 1] * xs[i]);\n\
    \        }\n        return deriv;", "        int[] coeffs = xs.ToArray();\n  \
    \      int[] diffs = new int[coeffs.Length - 1];\n        for (int i = 1; i <\
    \ coeffs.Length; i++) {\n            diffs[i - 1] = coeffs[i] - coeffs[i - 1];\n\
    \        }\n        int[] der = new int[diffs.Length];\n        der[0] = diffs[0];\n\
    \        for (int i = 1; i < diffs.Length; i++) {\n            der[i] = diffs[i\
    \ - 1];\n            for (int j = 0; j < i; j++) {\n                der[i] +=\
    \ diffs[j] * der[j];\n            }\n        }\n        List<long> derXs = new\
    \ List<long>();\n        for (int i = 2; i < der.Length; i++) {\n            derXs.Add(der[i]\
    \ / xs[i]);\n        }\n        return derXs;", "        // For simplicity, use\
    \ only first two coefficients.\n        // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \        // Return derivative of this polynomial in the same form.\n        //\
    \ >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L,\
    \ (long)5L})))\n        // (new List<long>(new long[]{(long)1L, (long)4L, (long)12L,\
    \ (long)20L}))\n        long result = 0;\n        for (int i = 0; i < xs.Count;\
    \ i++) {\n            result -= xs[i] * xs[i];\n        }\n        return Enumerable.Range(0,\
    \ xs.Count - 1)\n            .Select(i => result * (xs.Count - i) + xs[i]).ToList();",
  "        // The derivative of a polynomial is the sum of \n        // all partial\
    \ derivatives of the polynomial up to a constant\n        // The constant is the\
    \ value of the first term of the polynomial.\n        // The partial derivatives\
    \ of any term are as follows:\n        // First partial derivative is the value\
    \ at the first term.\n        // Second partial derivative is the value at the\
    \ second term.\n        // Third partial derivative is the value at the third\
    \ term.\n        // and so on...\n        // This gives a sum of the partial derivatives\
    \ of the polynomial \n        // up to a constant\n        // For the first term\
    \ of polynomial (a), partial derivative:\n        // dx(0) = a\n        // Second\
    \ partial derivative:\n        // dy(0) = dx(0) * (a * x[0] + a * x[1] + a * x[2]\
    \ + a * x[3] + a * x[4] + a * x[5])\n        // Third partial derivative:\n  \
    \      // dz(0) = dx(0) * (a * x[0] + a * x[1] + a * x[2] + a * x[3] + a * x[4]\
    \ + a * x[5])\n        // For second term of polynomial (b), partial derivative:\n\
    \        // dx(1) = dx(0) * (b * x[0] + b * x[1] + b * x[2] + b * x[3] + b * x[4]\
    \ + b * x[5])\n        // Second partial derivative:\n        // dy(1) = dy(0)\
    \ * (b * x[0] + b * x[1] + b * x[2] + b * x[3] + b * x[4] + b * x[5])\n      \
    \  // Third partial derivative:\n        // dz(1) = dz(0) * (b * x[0] + b * x[1]\
    \ + b * x[2] + b * x[3] + b * x[4] + b * x[5])\n        // and so on...\n    \
    \    // Derivative of a polynomial:\n        // sum(dz(i) * x(i+1))\n        //\
    \ (dz(1) * x(0) + dz(2) * x(0) + dz(3) * x(0) + dz(4) * x(0) + dz(5) * x(0) +\
    \ dz(6) * x(0)\n        // + dz(7) * x(0) + dz(8) * x(0) + dz(9) * x(0) + dz(10)\
    \ * x(0) + dz(11) * x(0) + dz(12) * x(0)\n        // + dz(13) * x(0) + dz(14)\
    \ * x(0) + dz(15) * x(0) + dz(16) * x(0) + dz(17) * x(0) + dz(18) * x(0)\n   \
    \     // + dz(19) * x(0) + dz(20) * x(0) + dz(21) * x(0) + dz(22) * x(0", "  \
    \      int n = xs.Count;\n        if (n < 3) return xs.ToList();\n\n        List<long>\
    \ ys = new List<long>(xs.Count - 1);\n        for (int i = n - 2; i >= 0; i--)\n\
    \            ys.Add(xs[i] * xs[i + 1]);\n        return ys;", "        var derivative\
    \ = new List<long>();\n        for (int i = xs.Count - 1; i >= 0; i--) {\n   \
    \         derivative.Add(xs[i] * Derivative(xs.Take(i + 1).ToList()));\n     \
    \   }\n        return derivative;", "        List<long> ys = new List<long>();\n\
    \        foreach (long x in xs) {\n            ys.Add(1L);\n            ys.Add(x);\
    \ \n        }\n        if (ys.Count > 2) {\n            ys.Add(0L);\n        \
    \    int n = ys.Count / 2;\n            for (int i = 0; i < n; i++) {\n      \
    \          ys[i] += ys[i + n]; \n            }\n        }\n        return ys;",
  "        long x = 1;\n        List<long> der = new List<long>(new long[] {1L});\n\
    \        foreach (long y in xs) {\n            der = der * x;\n            x =\
    \ y;\n        }\n        return der;", "        if (xs.Count < 2) throw new ArgumentException(\"\
    Must have at least 2 terms.\");\n        long a = 1;\n        long b = xs[0];\n\
    \        for (int i = 1; i < xs.Count; i++) {\n            a = b * (i + 1);\n\
    \            b = a + xs[i];\n        }\n        return new List<long>() { a };",
  "        List<long> ret = new List<long>();\n        for(int i = 0; i < xs.Count;\
    \ i++) {\n            ret.Add(xs[i]);\n            ret.Add(xs[i] * xs[i]);\n \
    \           ret.Add(xs[i] * xs[i] * xs[i]);\n            ret.Add(xs[i] * xs[i]\
    \ * xs[i] * xs[i]);\n        }\n        return ret;", "        var x0 = xs[0];\n\
    \        ulong n = 0;\n        var xs = new List<long>();\n        for (var i\
    \ = 0; i < xs.Count; i++) {\n            ulong x = xs[i];\n            ulong xprime\
    \ = n * x;\n            xs.Add(xprime);\n            n = n + xprime;\n       \
    \ }\n        return xs;", "        int n = xs.Count;\n        if (n == 0)\n  \
    \          return new List<long>();\n\n        List<long> ds = new List<long>();\n\
    \n        ds.Add((long)1);\n        if (n >= 2) {\n            ds.Add(xs[1]);\n\
    \            if (n >= 3) {\n                ds.Add(xs[2]);\n                if\
    \ (n >= 4) {\n                    ds.Add(xs[3]);\n                    if (n >=\
    \ 5) {\n                        ds.Add(xs[4]);\n                    }\n      \
    \          }\n            }\n        }\n        return ds;", "        var res\
    \ = new List<long>();\n        for(int i = 0; i < xs.Count; ++i) {\n         \
    \   var x = xs[i];\n            res.Add(x * x * (res.Count - 1));\n        }\n\
    \        return res;", "        List<long> derivative = new List<long>();\n  \
    \      List<long> x2 = new List<long>();\n        double diff = Math.Pow((double)(xs[2]\
    \ - xs[0]), 2);\n        double diff2 = Math.Pow((double)(xs[2] - xs[1]), 2);\n\
    \        double diff3 = Math.Pow((double)(xs[2] - xs[2]), 2);\n        double\
    \ diff4 = Math.Pow((double)(xs[2] - xs[3]), 2);\n        double diff5 = Math.Pow((double)(xs[2]\
    \ - xs[4]), 2);\n        x2.Add(xs[0] + diff);\n        x2.Add(xs[1] + diff2);\n\
    \        x2.Add(xs[2] + diff3);\n        x2.Add(xs[3] + diff4);\n        x2.Add(xs[4]\
    \ + diff5);\n        derivative.Add((long)(2 * xs[2] * xs[0] + 6 * xs[1] * xs[1]\
    \ + 3 * xs[0] * xs[2] + xs[0] * xs[1] + xs[1] * xs[2]));\n        derivative.Add((long)(2\
    \ * xs[3] * xs[0] + 6 * xs[4] * xs[1] + 3 * xs[0] * xs[3] + xs[0] * xs[4] + xs[4]\
    \ * xs[3]));\n        derivative.Add((long)(2 * xs[0] * xs[1] + 6 * xs[4] * xs[2]\
    \ + 3 * xs[1] * xs[4] + xs[1] * xs[4] + xs[4] * xs[3]));\n        derivative.Add((long)(2\
    \ * xs[1] * xs[2] + 6 * xs[3] * xs[3] + 3 * xs[0] * xs[4] + xs[0] * xs[3] + xs[3]\
    \ * xs[4]));\n        derivative.Add((long)(2 * xs[4] + 6 * xs[2] * xs[3] + 3\
    \ * xs[1] * xs[2] + xs[1] * xs[2] + xs[2] * xs[1]));\n        return derivative;",
  "        // Derive the coefficients of this polynomial\n        var cs = new List<long>();\n\
    \        var n = xs.Count;\n        var x = 0;\n        for(var i = 1; i < n;\
    \ i++) {\n            cs.Add((xs[i - 1] * x) + xs[i]);\n            x = x * x;\n\
    \        }\n        // Derive the polynomial at x \n        var d = new List<long>();\n\
    \        for(var i = 1; i < n; i++) {\n            d.Add(xs[i - 1] * (xs[i - 1]\
    \ * cs[i - 1]) / x);\n            x = x * x;\n        }\n        return d;", " \
    \       if (xs.Count == 0)\n            throw new ArgumentException(\"Polynomial\
    \ does not have a root\");\n        long a = xs[0];\n        List<long> result\
    \ = new List<long>(xs.Count);\n        long xpow = 1;\n        foreach (long x\
    \ in xs)\n            result [result.Count - 1] += a * xpow * x;\n           \
    \ xpow /= x;\n        return result;", "        int degree = xs.Count;\n     \
    \   List<long> result = new List<long>();\n\n        for (int i = 0; i < degree\
    \ - 1; i++) {\n            result.Add(xs[i + 1] - xs[i] * xs[degree - 2]);\n \
    \       }\n        return result;", "        Debug.Assert(xs.Count > 1);\n   \
    \     long m = xs[0];\n        long m2 = m;\n        for (int i = 1; i < xs.Count;\
    \ i++) {\n            m2 += xs[i] * m;\n            m = xs[i];\n        }\n  \
    \      long x0 = m;\n        List<long> deriv_xs = new List<long>();\n       \
    \ while (m != 0) {\n            long temp = m2 + x0 * m;\n            deriv_xs.Add(temp);\n\
    \            x0 = m;\n            m = temp;\n        }\n        if (deriv_xs.Count\
    \ == 1) {\n            deriv_xs.Add(deriv_xs[0]);\n        } else if (deriv_xs.Count\
    \ > 1){\n            for (int i = 0; i < deriv_xs.Count; i++) {\n            \
    \    deriv_xs[i] = (long)((deriv_xs[i] - deriv_xs[i-1]) / (deriv_xs[i-1]));\n\
    \            }\n        }\n        return deriv_xs;", "        // The polynomial\
    \ derivative is a sum of xs[i] * (x - xs[i]), where i is zero to length of xs.\n\
    \        // We only need to compute the difference between the polynomial and\
    \ it's first derivative.\n        double delta = Math.Abs(xs[0]) - Math.Abs(xs[1]);\n\
    \        List<long> newXs = new List<long>(xs.Count);\n        for (int i = 0;\
    \ i < xs.Count; i++) {\n            newXs.Add(xs[i] + delta);\n        }\n   \
    \     return newXs;", "        List<long> dxs = new List<long>(xs.Count);\n  \
    \      for (int i = 0; i < xs.Count; i++) {\n            dxs[i] = xs[i];\n   \
    \     }\n        for (int i = xs.Count - 1; i >= 0; i--) {\n            for (int\
    \ j = 0; j < i; j++) {\n                dxs[i] *= xs[j];\n            }\n    \
    \    }\n        return dxs;", "        List<long> ds = new List<long>();\n   \
    \     for (int i = 0; i < xs.Count; i++) {\n            long d = (long)Math.Pow(xs[i],\
    \ xs.Count - 1);\n            for (int j = xs.Count - 2; j >= 0; j--) {\n    \
    \            d *= xs[j];\n            }\n            ds.Add(d);\n        }\n \
    \       return ds;", "        List<long> derivative = new List<long>();\n    \
    \    foreach (long x in xs) {\n            derivative.Add(x);\n        }\n\n \
    \       long one = 1;\n        for (int i = 1; i < xs.Count; i++) {\n        \
    \    derivative[i] = -(xs[i] - derivative[i - 1]);\n        }\n\n        return\
    \ derivative;", "        if (xs.Count < 2) return new List<long>();\n        var\
    \ der = new List<long>();\n        for (int i = 0; i < xs.Count; ++i) {\n    \
    \        if (i == 0) continue;\n            der.Add(xs[i]);\n            der.Add(0L);\n\
    \            der[i] += xs[i] / der[i - 1];\n        }\n        return der;", " \
    \       List<long> result = new List<long>();\n        for(int i = 0; i < xs.Count;\
    \ i++) {\n            double x = xs[i];\n            if (i == 0)\n           \
    \     result.Add(1);\n            else\n                result.Add(xs[i] / x);\n\
    \        }\n        return result;", "        if (xs.Count < 3) return new List<long>();\n\
    \        var results = new List<long>();\n        var pow = GetPow(xs[0], xs.Count);\n\
    \        for (int i = 1; i < xs.Count; i++) {\n            var x = pow;\n    \
    \        pow *= xs[i];\n            results.Add(x);\n        }\n        return\
    \ results;", "        long power = 0;\n        var result = new List<long>();\n\
    \        while (true) {\n            // Calculate next power.\n            power++;\n\
    \            // Add 1 at the end of an empty list\n            if (power == 0)\
    \ {\n                result.Add(1L);\n                continue;\n            }\n\
    \            // Add x to the result list.\n            while (true) {\n      \
    \          result.Add(xs[power]);\n                // If x is 0, break the loop\n\
    \                if (xs[power] == 0) {\n                    break;\n         \
    \       }\n                // Increment the power.\n                power++;\n\
    \            }\n            // Break out of the loop if power is 0.\n        \
    \    if (power == 0) {\n                break;\n            }\n        }\n   \
    \     return result;", "        long firstVal = xs[0];\n        long secondVal\
    \ = xs[1];\n        long thirdVal = xs[2];\n        // This polynomial is a linear\
    \ function of x.\n        if (thirdVal == 0) {\n            // Derivatives of\
    \ linear functions is a constant function of x.\n            return new List<long>(new\
    \ long[]{firstVal});\n        }\n\n        long result = 0;\n        long xSquare\
    \ = 0;\n        int coefficientCount = 0;\n\n        // Find coefficient count\
    \ of polynomial in terms of x.\n        while (xs[coefficientCount] == 0) {\n\
    \            coefficientCount++;\n        }\n\n        // Build up result\n  \
    \      for (long i = 0; i <= coefficientCount; i++) {\n            result += i\
    \ * xs[i];\n            xSquare = xs[i] * xs[i];\n        }\n\n        // Build\
    \ up partial derivative\n        if (firstVal == 0) {\n            return new\
    \ List<long>(new long[]{result});\n        }\n\n        List<long> derivativeResult\
    \ = new List<long>(new long[coefficientCount]);\n\n        // Calculate x^2 *\
    \ derivative\n        if (secondVal == 0) {\n            derivativeResult[0] =\
    \ result;\n            return derivativeResult;\n        }\n        double dResult\
    \ = result / secondVal;\n        double dFirstResult = firstVal * dResult;\n \
    \       double dSecondResult = secondVal * dResult;\n\n        // Calculate x^2\
    \ * derivative\n        if (thirdVal == 0) {\n            derivativeResult[0]\
    \ = dFirstResult;\n            derivativeResult[1] = dSecondResult;\n        \
    \    return derivativeResult;\n        }\n        double dThirdResult = (thirdVal\
    \ * dResult) / thirdVal;\n        double dFirstdSecondResult = dFirstResult +\
    \ dSecondResult;\n        double dFirstdThirdResult = dFirstResult + dThirdResult;\n\
    \        double dSeconddThirdResult = dSecondResult + dThirdResult;\n\n      \
    \  // Calculate x^3 * derivative\n        if (coefficientCount == 3) {\n     \
    \       derivativeResult[0] = dFirstdSecondResult;\n            derivativeResult[1]\
    \ = dFirstdThirdResult;\n            derivativeResult[2] = dSeconddThirdResult;\n\
    \            return derivativeResult;\n        }\n\n        // Calculate x^3 *\
    \ derivative\n        double dFirstdSeconddThirdResult = dFirstdSecondResult +\
    \ dSeconddThirdResult;\n\n        // Calculate x^4 * derivative\n        if (coefficientCount\
    \ == 4) {\n            derivativeResult[0] = dFirstdSeconddThirdResult;\n    \
    \        derivativeResult[1] = dSeconddThirdResult;\n            derivativeResult[2]\
    \ = dThirdResult;\n            derivativeResult[3] = dResult;\n            return\
    \ derivativeResult;\n        }\n\n        // Calculate x^4 * derivative\n    \
    \    double dFirstd", "        List<long> p = new List<long>(xs.Count - 1);\n\
    \        p.Add(0);\n        for(int i = p.Count - 2; i >= 0; i--) {\n        \
    \    p[i] = (xs[i + 1] * p[i + 1]) - (xs[i] * p[i]);\n        }\n        return\
    \ p;", "        List<long> ret = new List<long>();\n        long prev = 0;\n \
    \       long next = 1;\n        for(long i = xs.Count - 1; i >= 0; i--) {\n  \
    \          ret.Add(xs[i] + prev * next);\n            prev += xs[i];\n       \
    \     next *= xs[i];\n        }\n        return ret;", "        if (xs.Count <\
    \ 3) {\n            throw new ArgumentException(\"Polynomial must have at least\
    \ 3 coefficients.\");\n        }\n\n        int n = (int)Math.Pow(2, xs.Count);\n\
    \        BigInteger y = BigInteger.One;\n        for (int i = 1; i <= n; i++)\
    \ {\n            BigInteger term = BigInteger.One;\n            for (int j = 0;\
    \ j < i; j++) {\n                term = term.Multiply(xs[j]);\n            }\n\
    \            term = term.Multiply(y);\n            y = term.Mod(BigInteger.Two);\n\
    \        }\n        return new List<long>(xs);", "        int n = xs.Count;\n\
    \        int n = n - 1;\n        long product = 1;\n        List<long> result\
    \ = new List<long>();\n        for (int i = 1; i < n; i++) {\n            product\
    \ *= xs[i];\n        }\n        result.Add(product);\n        for (int i = n;\
    \ i >= 1; i--) {\n            product /= xs[i];\n            result.Add(product);\n\
    \        }\n        return result;", "        if (xs.Count < 1) throw new ArgumentException(\"\
    xs must have at least 1 coefficient\");\n        List<long> ret = new List<long>();\n\
    \        double sum = 0;\n        double x = 0;\n        for (long i = 0; i <\
    \ xs.Count; i++) {\n            x = xs[i];\n            sum += x;\n          \
    \  ret.Add(sum);\n        }\n        return ret;", "        int deg = xs.Count;\n\
    \        if (deg == 0)\n            return new List<long>();\n\n        long[]\
    \ values = new long[deg - 1];\n        for (int i = 1; i < deg; ++i)\n       \
    \     values[i - 1] = (long)xs[i - 1];\n\n        for (int i = 1; i < deg; ++i)\n\
    \            xs[i] += values[i - 1];\n\n        return Derivative(xs, deg - 1);",
  "        // Check number of coefficients is even.\n        if (xs.Count % 2 == 0)\
    \ {\n            throw new ArgumentException();\n        }\n        // Check coefficients\
    \ are in range.\n        if (xs.Min() < 0 || xs.Max() > 100) {\n            throw\
    \ new ArgumentException();\n        }\n        // Return new list with derivative\
    \ of each coefficient.\n        List<long> result = new List<long>(xs.Count /\
    \ 2);\n        for (int i = 0; i < (xs.Count / 2); i++) {\n            double\
    \ x = xs[i];\n            double x2 = x * x;\n            double x4 = x2 * x;\n\
    \            result[i] = x * x * ((x2 - 4L) * x - 8L);\n        }\n        return\
    \ result;", "        Debug.Assert(xs.Count > 0);\n        Debug.Assert(xs[0].Equals(xs[1]));\n\
    \        Debug.Assert(xs[0].Equals(xs[2]));\n        // Derivative of a constant\
    \ polynomial is zero.\n        // This is very important to prevent division by\
    \ zero.\n        if (xs[0].Equals((long) 0)) return new List<long>(new long[0]);\n\
    \n        // Remember all terms except the first.\n        List<long> results\
    \ = new List<long>(new long[xs.Count - 1]);\n\n        // Calculate derivative.\n\
    \        for (int i = 2; i < xs.Count; i++) {\n            results.Add(xs[i] *\
    \ (results[i - 1] - results[i - 2]));\n        }\n        return results;", " \
    \       List<long> results = new List<long>();\n        results.Add(1L);\n   \
    \     foreach (long x in xs)\n            results.Add(results[results.Count -\
    \ 1] * x);\n        return results;", "        // Check whether the size of the\
    \ input list is odd, if so, add one term for xs.Length - 1\n        if (xs.Count\
    \ % 2 == 0) {\n            xs.Add(0L);\n        }\n\n        // Set up the array\
    \ for holding the result\n        List<long> der = new List<long>();\n\n     \
    \   // Loop through the array and calculate the derivative\n        for (int i\
    \ = 0; i < xs.Count - 1; i++) {\n            // Add the first term in der to der\n\
    \            der.Add((long) xs[i] * der[i]);\n\n            // Add the second\
    \ term in the xs array to the current term in the der array\n            der[i]\
    \ += xs[i + 1];\n        }\n\n        // Return the array of derivative\n    \
    \    return der;", "        int n = xs.Count;\n        long[] xsi = new long[n\
    \ + 1];\n        for (int i = 0; i <= n; i++) {\n            xsi[i] = xs[i];\n\
    \        }\n        xsi[n] = 1;\n        List<long> dydxs = GetDerivative(xsi);\n\
    \        int k = dydxs.Count - 1;\n        for (int i = k; i >= 0; i--) {\n  \
    \          xs[i] = dydxs[i];\n        }\n        return xs;", "        // If there\
    \ are no coefficients, return zero.\n        if (xs.Count == 0) return new List<long>();\n\
    \n        // If only a constant is present, return a constant derivative.\n  \
    \      if (xs.Count == 1) return xs;\n\n        // Compute discriminant\n    \
    \    long d = Sqrt((double)xs.Last() * (double)xs.Last());\n\n        // If discriminant\
    \ is negative, return zero.\n        if (d < 0) return new List<long>();\n\n \
    \       // Compute coefficients of polynomial\n        List<long> coefs = new\
    \ List<long>();\n        coefs[0] = -xs.First();\n        coefs[1] = xs.Last();\n\
    \        long n = 3;\n        for(int i = 2; i < xs.Count; i++) {\n          \
    \  long mult = n;\n            coefs[i] = (long)((coefs[i-1] * xs.Last()) - (mult*coefs[i-2])\
    \ / (mult*mult));\n            mult *= (long)xs.Last();\n            n += 1;\n\
    \        }\n\n        // Create polynomial in terms of coefficients\n        List<long>\
    \ ret = new List<long>();\n        ret.Add(coefs[0]);\n        for(int i = 1;\
    \ i < xs.Count; i++) {\n            ret.Add((coefs[i] * xs[i-1] - ret.Last())\
    \ / (xs[i] * xs[i]));\n        }\n\n        // Return polynomial derivative\n\
    \        return ret;", "        var res = new List<long>(new long[]{1L}); // first\
    \ derivative is 1\n        for (var i = 1; i < xs.Count; i++)\n            res[i]\
    \ = xs[i] - res[i - 1] * xs[i - 1];\n        return res;", "        // Find number\
    \ of elements in list\n        int xsLength = xs.Count;\n        int[] deriv =\
    \ new int[xsLength + 1];\n\n        long product = 1;\n        for (int i = 0;\
    \ i <= xs.Count - 1; i++) {\n            deriv[i] = i;\n            for (int j\
    \ = 0; j <= i; j++) {\n                deriv[i + 1] = deriv[i] + deriv[j];\n \
    \               product *= xs[j];\n            }\n        }\n        deriv[xsLength]\
    \ = product;\n\n        deriv = new long[deriv.Length];\n        int lastIndex\
    \ = deriv.Length - 1;\n        for (int i = lastIndex; i > 0; i--) {\n       \
    \     deriv[lastIndex--] = deriv[i];\n        }\n        return deriv;", "   \
    \     int n = (int)xs.Count;\n        if (n == 0) return new List<long>(new long[0]);\n\
    \        if ((n-1) % 2 == 0) return Derivative(Revert(xs)); // Newton method.\n\
    \        // Use Horner method to calculate derivative.\n        // http://en.wikipedia.org/wiki/Horner's_method\n\
    \        List<long> ys = new List<long>(new long[(n+1)/2-1]);\n        ys[0] =\
    \ xs[0];\n        ys[1] = xs[1];\n        for (int i = 2; i < ys.Count; i++) {\n\
    \            ys[ys.Count/2-1] = xs[i-2];\n            ys[i-1] = (long) ((xs[i-1]\
    \ * ((double) ys[ys.Count/2-1]) - (double)ys[ys.Count/2-1])/(xs[i-2]*xs[i-1]));\n\
    \        }\n        return ys;", "        int n = xs.Count;\n        if (n ==\
    \ 0) return new List<long>(new long[0]);\n        if (xs.Count == 1) return new\
    \ List<long>(new long[0]);\n        List<long> result = new List<long>();\n  \
    \      result.Add(1L);\n        int i;\n        for (i = 1; i < n; i++) {\n  \
    \          long p = xs[i] / result[i];\n            long mult = 1L;\n        \
    \    for (int k = i; k > 0; k--)\n                mult *= xs[k] - result[k-1]\
    \ * p;\n            result.Add(p);\n        }\n        while (i-- > 0) result.RemoveAt(0);\n\
    \        return result;", '        return Derivative(xs, 0, new List<long>(),
    1);', "        int[] degrees = { 0, 1, 2 };\n        int[] n = new int[degrees.Length];\n\
    \        int[] d = new int[degrees.Length];\n        for (int i = 0; i < degrees.Length;\
    \ i++)\n            n[i] = (int)Math.Pow(degrees[i], (xs.Count - 1));\n      \
    \  for (int i = 0; i < degrees.Length; i++)\n            d[i] = degrees[i] - 1;\n\
    \        long[] nd = new long[n[nd.Length - 1]];\n        for (int i = degrees.Length\
    \ - 1; i >= 0; i--)\n            nd[i] = n[i];\n        List<long> ds = new List<long>(degrees.Length);\n\
    \        for (int i = degrees.Length - 1; i >= 0; i--)\n            ds.Add(new\
    \ long[d[i]]);\n        for (int i = 0; i < degrees.Length; i++)\n           \
    \ for (int j = degrees.Length - 1; j > i; j--)\n                nd[j] += nd[j\
    \ - 1];\n        List<long> dxs = new List<long>(degrees.Length);\n        for\
    \ (int i = 0; i < degrees.Length; i++)\n            dxs[i] = new long[d.Length];\n\
    \        for (int i = 0; i < degrees.Length; i++)\n            for (int j = 0;\
    \ j < degrees.Length; j++)\n                dxs[i][j] = (xs.ElementAt(i) * new\
    \ long(d[j]).Value);\n        return dxs;", "        List<long> diff = new List<long>();\n\
    \        for (int i = 0; i < xs.Count; i++) {\n            int n = i;\n      \
    \      long x = 0;\n            while (n > 1) {\n                x += (long)xs[n];\n\
    \                n--;\n            }\n            diff.Add(x);\n        }\n  \
    \      return diff;", "        var result = new List<long>();\n        // ds represents\
    \ the coefficients of the derivative of polynomial xs.\n        var ds = new List<long>();\n\
    \        // ds[degree] represents the xs[degree] coefficient.\n        // ds[degree]\
    \ is added into result if degree is odd or subtracted from result if degree is\
    \ even.\n        for (int i = 0; i < xs.Count; i++) {\n            if (i % 2 ==\
    \ 0) {\n                result.Add(xs[i]);\n            } else {\n           \
    \     result.Add(-(xs[i]));\n            }\n        }\n        Console.WriteLine(result);\n\
    \n        int n = 0;\n        for (int i = 0; i < result.Count; i++) {\n     \
    \       if (result.Count == 1) {\n                ds[n] = result[0];\n       \
    \         n++;\n            } else {\n                if (i % 2 == 0) {\n    \
    \                ds[n] = result[i];\n                    n++;\n              \
    \  } else {\n                    ds[n] = -result[i];\n                    n++;\n\
    \                }\n            }\n        }\n        // ds represent the coefficients\
    \ of the derivative of polynomial xs.\n        // n is the highest degree of the\
    \ polynomial in xs.\n        // ds represents the coefficients of derivative of\
    \ polynomial xs.\n        // For example, the highest degree of xs is 2, and the\
    \ highest degree of ds is 2.\n        // So ds[0] and ds[1] represent the coefficients\
    \ of the derivative of xs.\n        Console.WriteLine(ds);\n        return Derivative(ds,\
    \ n);", "        var d = new List<long>(new long[0]);\n        for (var i = 1;\
    \ i < xs.Count; ++i) {\n            var p = xs.Count - i;\n            d[0] +=\
    \ xs[i] * xs[i];\n            for (var j = 1; j < p; ++j) {\n                d[j]\
    \ += xs[i] * xs[j] * xs[i];\n            }\n        }\n        return d;", " \
    \       List<long> result = new List<long>();\n        for (int i = 0; i < xs.Count;\
    \ i += 2) {\n            result.Add((xs[i + 1] - xs[i]) / (i + 1));\n        }\n\
    \        return result;", "        List<long> derivs = new List<long>();\n   \
    \     int len = xs.Count;\n        if (len == 0)\n            throw new Exception(\"\
    Derivative of a zero polynomial\");\n\n        for (int i = len - 1; i >= 0; i--)\
    \ {\n            derivs.Add(xs[i] * len - 1);\n        }\n        return derivs;",
  "        var size = xs.Count;\n        if (size <= 2) {\n            return new\
    \ List<long>();\n        }\n        // To find the roots of a polynomial we start\
    \ by finding\n        // the roots by difference\n        long[] difference =\
    \ new long[size - 1];\n        long[] difference2 = new long[size - 1];\n    \
    \    for (int i = size - 2; i >= 0; i--) {\n            difference[i] = xs[i +\
    \ 1] - xs[i];\n        }\n        // Now we have the roots.\n        using (var\
    \ rng = new RNGCryptoServiceProvider()) {\n            for (int i = size - 2;\
    \ i >= 1; i--) {\n                rng.GetBytes(difference2);\n               \
    \ difference2[i] = difference2[i + 2];\n            }\n        }\n        // Now\
    \ we use the fact that:\n        // difference2[i] = (difference[i] * difference2[i\
    \ + 1]) + difference2[i + 2]\n        // to find what we want:\n        // derivative[i]\
    \ = difference[i] * difference2[i + 1] - difference2[i + 2]\n        // But first\
    \ we have to find the factor we want\n        long[] derivative = new long[size\
    \ - 1];\n        long[] derivative2 = new long[size - 1];\n        for (int i\
    \ = size - 2; i >= 1; i--) {\n            derivative[i] = difference[i] * difference2[i\
    \ + 1];\n        }\n        for (int i = size - 2; i >= 2; i--) {\n          \
    \  derivative2[i] = difference2[i];\n        }\n        // Now we take the square\
    \ of the factor.\n        using (var rng = new RNGCryptoServiceProvider()) {\n\
    \            for (int i = size - 2; i >= 1; i--) {\n                rng.GetBytes(derivative2);\n\
    \                derivative2[i] = derivative2[i] * derivative2[i];\n         \
    \   }\n        }\n        // Now we use the fact that:\n        // derivative2[i]\
    \ = (derivative[i] * derivative2[i + 1]) + derivative2[i + 2]\n        // to find\
    \ what we want:\n        // derivative[i] = derivative[i] * derivative2[i + 1]\
    \ - derivative2[i + 2]\n        // But first we have to find the factor we want\n\
    \        long[] derivative1 = new long[size - 1];\n        long[] derivative2\
    \ = new long[size - 1];\n        for (int i = size - 2; i >= 1; i--) {\n     \
    \       derivative1[i] = difference1[i] * difference2[i + 1];\n        }\n   \
    \     for (int i = size - 2; i >= 2; i--) {\n            derivative2[i] = difference2[i];\n\
    \        }\n        // Now we take the square of the factor.\n        using (var\
    \ rng = new RNGCryptoServiceProvider()) {\n            for (int i = size - 2;\
    \ i >= 1; i--) {\n                rng.GetBytes(derivative2);\n               \
    \ derivative2[i] = derivative2[i] * derivative2[i];\n            }\n        }\n\
    \        // Now we use the fact that:\n        // derivative2[i] = ", "      \
    \  var result = new List<long>();\n        result.Add((long)0);\n        for(int\
    \ i = 1; i < xs.Count; i ++) {\n            result.Add((long)xs[i] * (long)result.Last());\n\
    \        }\n        return result;", "        int n = xs.Count;\n        if (n\
    \ == 0) {\n            // No derivative.\n            return new List<long>(0);\n\
    \        }\n        List<long> ys = new List<long>(n);\n        // ys[0] = xs[0]\n\
    \        ys[0] = xs[0];\n        // ys[1] = xs[1] * x\n        for (int i = 1;\
    \ i < n; ++i) {\n            ys[i] = ys[i - 1] * xs[i];\n        }\n        //\
    \ ys[n] = xs[n] * x^n\n        for (int i = n - 2; i >= 0; --i) {\n          \
    \  ys[i] = ys[i] * xs[i] * xs[i - 1];\n        }\n        return ys;", "     \
    \   // TODO: Complete this code\n        var result = new List<long>(new long[]{1L});\n\
    \        for(int i = 0; i < xs.Count; ++i)\n        {\n            result.Add((xs[i]\
    \ * result.Last()));\n        }\n        return result;", "        List<long>\
    \ derivative = new List<long>();\n        if (xs.Count <= 1)\n            throw\
    \ new ArgumentException(\"polynomial degree must be at least 2\");\n        long\
    \ exponent = xs[0];\n        long product = 1;\n        for (int i = 1; i < xs.Count;\
    \ i++) {\n            product *= xs[i];\n            exponent--;\n        }\n\
    \        derivative.Add(product);\n        while (exponent > 1) {\n          \
    \  if (exponent % 2 == 1)\n                derivative.Add(product / 2);\n    \
    \        exponent /= 2;\n            product /= 2;\n        }\n        return\
    \ derivative;", "        // Return derivative of polynomial with given coefficients.\n\
    \        var result = new List<long>();\n        Debug.Assert(xs.Count > 1);\n\
    \        for (int i = 0; i < xs.Count; i++) {\n            result.Add(xs[i] *\
    \ (i - 1));\n        }\n        return result;", "        // This is equivalent\
    \ to the previous method but uses xs[0]\n        // instead of xs[0] + xs[1] *\
    \ x\n        var result = new List<long>();\n        for (var i = xs.Count - 1;\
    \ i >= 0; --i) {\n            result.Add(0);\n            result.Add(xs[i]);\n\
    \            result.Add(xs[i] * i);\n        }\n        return result;", "   \
    \     var n = new List<long>(new long[x.Count]);\n        for (var i = 0; i <\
    \ n.Count; i++) {\n            n[i] = 0L;\n            for (var j = 0; j < xs.Count;\
    \ j++) {\n                n[i] += xs[j] * xs[j+i];\n            }\n        }\n\
    \        return n;", "        List<long> results = new List<long>();\n       \
    \ if (xs.Count == 1) return results;\n        if (1 == xs.Count && xs[0] > 0)\
    \ return Derivative(xs.Take(1)).Concat(Derivative (xs.Skip(1)));\n        if (2\
    \ == xs.Count) return Derivative (xs.Take(2)).Concat(Derivative (xs.Skip(2)));\n\
    \        return Derivative(xs.Take(3))\n        .Concat(Derivative (xs.Skip(3)));",
  "        // Initialize derivative\n        List<long> der = new List<long>(new long[(xs.Count\
    \ + 1)]);\n        // Add 0th derivative\n        der[0] = xs[0];\n        //\
    \ Calculate derivative of xs[0]\n        for (int i = 1; i < xs.Count; i++) {\n\
    \            der[i] = ((der[i - 1] * xs[i - 1]) + xs[i]) / (xs[i] - xs[i - 1]);\n\
    \        }\n        return der;", "        double x = 0.0;\n        List<long>\
    \ result = new List<long>();\n        for (int i = 0; i < xs.Count; ++i) {\n \
    \           double temp = x / ((double)xs.Count);\n            x += xs[i] * temp;\n\
    \            result.Add(xs[i]);\n        }\n        return result;", "       \
    \ // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n        List<long> derivative = new\
    \ List<long>();\n        for (int i = 1; i <= xs.Count; i++) {\n            derivative.Add(1L);\n\
    \            derivative[i] = xs[i] * Derivative(xs.Take(i));\n        }\n    \
    \    return derivative;", '        return xs.Take(xs.Count - 1).Aggregate((acc,
    cur) => acc * xs.Last() + cur);', "        if (xs.Count == 0) {\n            return\
    \ new List<long>(new long[0]);\n        }\n        if (1 == xs.Count) {\n    \
    \        return new List<long>(new long[]{xs[0]});\n        }\n        List<long>\
    \ result = new List<long>(new long[xs.Count - 1]);\n        long prevX = 0;\n\
    \        long prevX2 = 0;\n        long prevX4 = 0;\n        long prevX5 = 0;\n\
    \        long prevX6 = 0;\n        for (int i = 0; i <= (xs.Count - 1) / 2; ++i)\
    \ {\n            long x = xs[i];\n            long x2 = x * x;\n            long\
    \ x3 = x2 * x;\n            long x4 = x3 * x;\n            long x5 = x4 * x;\n\
    \            long x6 = x5 * x;\n            long x7 = x6 * x;\n            long\
    \ x8 = x7 * x;\n            long x9 = x8 * x;\n            long x10 = x9 * x;\n\
    \            long x11 = x10 * x;\n            long x12 = x11 * x;\n          \
    \  long x13 = x12 * x;\n            long x14 = x13 * x;\n            long x15\
    \ = x14 * x;\n            long x16 = x15 * x;\n            long x17 = x16 * x;\n\
    \            long x18 = x17 * x;\n            long x19 = x18 * x;\n          \
    \  long x20 = x19 * x;\n            long x21 = x20 * x;\n            long x22\
    \ = x21 * x;\n            long x23 = x22 * x;\n            long x24 = x23 * x;\n\
    \            long x25 = x24 * x;\n            long x26 = x25 * x;\n          \
    \  long x27 = x26 * x;\n            long x28 = x27 * x;\n            long x29\
    \ = x28 * x;\n            long x30 = x29 * x;\n            long x31 = x30 * x;\n\
    \            long x32 = x31 * x;\n            long x33 = x32 * x;\n          \
    \  long x34 = x33 * x;\n            long x35 = x34 * x;\n            long x36\
    \ = x35 * x;\n            long x37 = x36 * x;\n            long x38 = x37 * x;\n\
    \            long x39 = x38 * x;\n            long x40 = x39 * x;\n          \
    \  long x41 = x40 * x;\n            long x42 = x41 * x;\n            long x43\
    \ = x42 * x;\n            long x44 = x43 * x;\n            long x45 = x44 * x;\n\
    \            long x46 = x45 * x;\n            long x47 = x46 * x;\n          \
    \  long x48", "        int n = xs.Count;\n        List<long> ys = new List<long>();\n\
    \n        for (int i = 1; i < n; i++) {\n            long x = xs[i];\n       \
    \     long y = (long)Math.Pow(x, (double)i);\n            ys.Add(y);\n       \
    \ }\n\n        // To compute the derivative, we use Horner's method.\n       \
    \ double h = xs[0];\n        for (int i = 1; i < n; i++) {\n            double\
    \ h = h * (double)i + xs[i];\n        }\n        // x^n-1 * y^n + (x^n-1 + x^n)\
    \ * y^(n-1)\n        ys.Add(h);\n        return ys;", "        // Use Ridder's\
    \ method to find dy/dx = 1/y\n        long x0 = xs.First();\n        long x1 =\
    \ xs.Skip(1).First();\n        long x2 = xs.Skip(2).First();\n        long x3\
    \ = xs.Skip(3).First();\n        long x4 = xs.Skip(4).First();\n        long x5\
    \ = xs.Skip(5).First();\n        long x6 = xs.Skip(6).First();\n        long y\
    \ = (long)Math.Pow(x0, x1);\n        y *= (long)Math.Pow(x1, x2);\n        y *=\
    \ (long)Math.Pow(x2, x3);\n        y *= (long)Math.Pow(x3, x4);\n        y *=\
    \ (long)Math.Pow(x4, x5);\n        y *= (long)Math.Pow(x5, x6);\n        return\
    \ (new List<long>() { y });", "        long[] ds = new long[1 + xs.Count];\n \
    \       ds[0] = 1;\n        for (int i = 0; i < xs.Count; i++) {\n           \
    \ ds[i + 1] = xs[i];\n        }\n        long d = 1;\n        for (int i = xs.Count\
    \ - 2; i >= 0; i--) {\n            ds[i] *= d;\n            d--;\n        }\n\
    \        return new List<long>(new long[] {ds[0], ds.Last()});", "        if (0\
    \ == xs.Count())\n            return new List<long>(new long[0]);\n        List<long>\
    \ y = new List<long>(xs);\n        List<long> ys = new List<long>();\n       \
    \ for (int i = 1; i <= xs.Count(); i++)\n            ys.Add((long)Math.Pow(y[i\
    \ - 1], i));\n        for (int i = xs.Count(); i > 0; i--)\n            ys.Add((long)Math.Pow(ys[i\
    \ - 1], i));\n        return ys;", "        List<long> derivative = new List<long>();\n\
    \        Debug.Assert(xs.Count > 1);\n        for (int i = 1; i < xs.Count; i++)\
    \ {\n            // For i = 1, it is the same as adding x[0] to the sum (which\
    \ is 1).\n            // For i = 2, it is the same as adding x[1] to the sum (which\
    \ is 2).\n            // For i = 3, it is the same as adding x[2] to the sum (which\
    \ is 3).\n            // For i = 4, it is the same as adding x[3] to the sum (which\
    \ is 5).\n            // For i = 5, it is the same as adding x[4] to the sum (which\
    \ is 7).\n            // For i = 6, it is the same as adding x[5] to the sum (which\
    \ is 15).\n            derivative.Add((long)(i + 1) * xs[i] - i * xs[i - 1]);\n\
    \        }\n        return derivative;", "        Debug.Assert(xs.Count >= 3);\n\
    \        // xs -> 3x1x2 + ...\n        // xs -> 3x1x2 + 4x3\n        // xs ->\
    \ 3x1x2 + 4x3 + 5x\n        List<long> result = new List<long>();\n        long\
    \ x0 = xs[0];\n        long x1 = xs[1];\n        long x2 = xs[2];\n        long\
    \ x3 = xs[3];\n        // Calculate x1*x2 and add it to result.\n        long\
    \ temp = x1 * x2 + x0;\n        result.Add(temp);\n        // Calculate x3*x3\
    \ and add it to result.\n        temp = x3 * x3 + x0;\n        result.Add(temp);\n\
    \        // Calculate x1*x3 and add it to result.\n        temp = x1 * x3 + x0;\n\
    \        result.Add(temp);\n        // Calculate x2*x3 and add it to result.\n\
    \        temp = x2 * x3 + x0;\n        result.Add(temp);\n        // Calculate\
    \ x1*x2*x3 and add it to result.\n        temp = x1 * x2 * x3 + x0;\n        result.Add(temp);\n\
    \        // Calculate x2*x1*x3 and add it to result.\n        temp = x2 * x1 *\
    \ x3 + x0;\n        result.Add(temp);\n        // Calculate x1*x2*x3 and add it\
    \ to result.\n        temp = x1 * x2 * x3 + x0;\n        result.Add(temp);\n \
    \       // Calculate x1*x2*x3 and add it to result.\n        temp = x1 * x2 *\
    \ x3 + x0;\n        result.Add(temp);\n        return result;", "        if (xs.Count\
    \ < 1) {\n            return null;\n        }\n        long y = (long)1;\n   \
    \     List<long> ret = new List<long>();\n        for (int i = 0; i < xs.Count\
    \ - 1; i++) {\n            long sum = xs[i];\n            sum += (long)Math.Pow(y,\
    \ i);\n            y *= xs[i + 1];\n            ret.Add(sum);\n        }\n   \
    \     return ret;", "        if (xs.Count == 0) {\n            return new List<long>();\n\
    \        }\n\n        List<long> result = new List<long>();\n        var lastX\
    \ = xs[0];\n\n        for (int i = 1; i < xs.Count; ++i) {\n            long nextX\
    \ = xs[i] + lastX * i;\n            lastX = nextX;\n            result.Add(nextX);\n\
    \        }\n\n        return result;", "        Debug.Assert(xs.Count > 0);\n\
    \        List<long> der = new List<long>(xs.Count);\n        if (1 == xs.Count)\
    \ {\n            der[0] = xs[0] * (long)Math.Pow(xs[0], xs.Count);\n         \
    \   return der;\n        }\n        for (int i = 1; i < xs.Count; i++) {\n   \
    \         der[i] = xs[i] * (long)Math.Pow(xs[i], xs.Count - i - 1);\n        }\n\
    \        return der;", "        if (xs.Count == 1)\n            return new List<long>(new\
    \ long[] { 1 });\n        if (xs.Count == 0)\n            return new List<long>(new\
    \ long[] { 0 });\n        long x0 = xs[0];\n        List<long> xs = new List<long>(new\
    \ long[] { x0 });\n        long xn = 1;\n        for (int i = 1; i < xs.Count;\
    \ i++) {\n            xn = xn * xs[i];\n            xs.Add(xn);\n        }\n \
    \       return xs;", "        double x = 0.0;\n        double result = 0.0;\n\
    \        for (int i = 0; i < xs.Count; i++) {\n            double tmp = xs[i];\n\
    \            x = i * x;\n            result += tmp;\n        }\n        result\
    \ = Math.Pow(x, 2);\n        xs.Add(result);\n        return xs;", "        var\
    \ order = xs.Count;\n        if (order < 1)\n            throw new ArgumentOutOfRangeException();\n\
    \        var coefficients = new long[order];\n        var result = new List<long>();\n\
    \        for (var i = 1; i < order; ++i) {\n            var product = 0;\n   \
    \         for (var j = 0; j < i; ++j)\n                product += xs[j] * coefficients[j];\n\
    \            coefficients[i - 1] = xs[i - 1] * product;\n            result.Add(coefficients[i\
    \ - 1]);\n        }\n        return result;", "        if (xs.Count < 1) throw\
    \ new ArgumentException(\"Derivative must have at least one term.\", \"xs\");\n\
    \        var derivative = new List<long>();\n        long x = 0;\n        for\
    \ (int i = 0; i < xs.Count - 1; i++) {\n            x += 1L;\n            derivative.Add(xs[i]);\n\
    \        }\n        derivative.Add(xs.Last());\n        return derivative;", " \
    \       if (xs.Count < 2) return xs;\n\n        var coeff = new List<long>();\n\
    \        var ncoeff = new List<long>();\n        var product = new List<long>();\n\
    \        var sum = new List<long>();\n        long n = 1;\n\n        // If xs[0]\
    \ is 1, sum[0] = 1\n        if (xs[0] == 1) sum.Add((long)1);\n\n        // Otherwise,\
    \ sum[0] = sum[xs[0]] \n        for (int i = 1; i < xs.Count; i++)\n         \
    \   sum.Add(sum[xs[i]]);\n\n        // Iterate through the rest of the list\n\
    \        for (int i = 0; i < xs.Count; i++)\n        {\n            // If xs[i]\
    \ is 1, coeff[i] = n\n            if (xs[i] == 1) coeff.Add(n);\n\n          \
    \  // Otherwise:\n            else\n            {\n                // Find the\
    \ coeff of the last term in the polynomial so far\n                // i.e. (xs[i]\
    \ - 1) * coeff[i] + coeff[i-1]\n                // and subtract it from all terms\
    \ above it that have a coeff of 1\n                long a = coeff[coeff.Count\
    \ - 1];\n                for (int j = coeff.Count - 1; j > i; j--)\n         \
    \           a = a * (xs[i] - 1) * (j - 1) + ((j == i) ? 0 : coeff[j]);\n\n   \
    \             // Set the ncoeff list to contain the coeff of the next term\n \
    \               // i.e. (xs[i] - 1) * ncoeff[i] + ncoeff[i-1]\n              \
    \  long b = ncoeff[ncoeff.Count - 1];\n                for (int j = ncoeff.Count\
    \ - 1; j > i; j--)\n                    b = b * (xs[i] - 1) * (j - 1) + ((j ==\
    \ i) ? 0 : ncoeff[j]);\n\n                // Finally, multiply ncoeff and coeff\
    \ together and store in product list\n                product.Add(a * b / n);\n\
    \            }\n            n *= xs[i];\n        }\n\n        // Return the derivative\
    \ of this polynomial with coeff, product and sum lists\n        return new List<long>\
    \ {coeff.Sum(), product.Sum(), sum.Sum()};", "        List<long> derivative =\
    \ new List<long>();\n        if (xs.Count != 1)\n            throw new Exception(\"\
    Polynomial must be single variable\");\n        double dx = xs[0] / xs.Count;\n\
    \        for(int i = 0; i < xs.Count; i++) {\n            derivative.Add(xs[i]);\n\
    \            derivative.Add(dx);\n        }\n        return derivative;", "  \
    \      var n = xs.Count;\n        if (xs.Count < 2) return new List<long>();\n\
    \        var k = n - 1;\n        var d = new List<long>();\n        var a = new\
    \ List<long>();\n        var m = new List<long>(new long[n - 2]);\n        double[]\
    \ c = new double[n];\n        double[] b = new double[n];\n        double[] x\
    \ = new double[n];\n        var p = 0.0;\n        var bp = 0.0;\n        var bm\
    \ = 0.0;\n        var xp = 0.0;\n        var xm = 0.0;\n        // x[0] = 1.0;\
    \ b[0] = 1.0; c[0] = 3.0; x[0][0] = 1.0; x[0][1] = 2.0; x[0][2] = 3.0;\n     \
    \   x[0] = xs[0]; b[0] = xs[0]; c[0] = 3.0; x[0][0] = 1.0; x[0][1] = 2.0; x[0][2]\
    \ = 3.0;\n        for (int i = 1; i < n; i++) {\n            c[i] = xs[i] - x[0];\n\
    \            x[i] = xs[i];\n        }\n        for (int i = 1; i < n - 1; i++)\
    \ {\n            p = (c[i] + c[i + 1]) * x[i + 1] - c[i + 1];\n            bm\
    \ = (x[i + 1] - x[i]) * (c[i + 1] - c[i]);\n            bm *= x[i + 1];\n    \
    \        bm *= c[i + 1];\n            b[i] += p;\n            bm *= p;\n     \
    \       b[i] = b[i] / bm;\n            b[i + 1] += bm;\n        }\n        b[0]\
    \ = b[0] / (b[0] + b[1]);\n        b[1] = b[1] / (b[0] + b[1]);\n        for (int\
    \ i = 1; i < n; i++) {\n            a[i] = xs[i] - x[0];\n            x[i] = xs[i];\n\
    \        }\n        for (int i = 1; i < n - 1; i++) {\n            p = (c[i] +\
    \ c[i + 1]) * x[i + 1] - c[i + 1];\n            ap = (x[i + 1] - x[i]) * (c[i\
    \ + 1] - c[i]);\n            ap *= x[i + 1];\n            ap *= c[i + 1];\n  \
    \          a[i + 1] += ap;\n            xp = (c[i] + c[i + 1]) * x[i + 1] - c[i];\n\
    \            xm = (x[i + 1] - x[i]) * (c[i + 1] - c[i]);\n            xm *= x[i\
    \ + 1];\n            xm *= c[i + 1];\n            xm *= x[i];\n            x[i]\
    \ -= xp;\n            xm -= xm;\n            x[i + 1] += xp;\n            xm +=\
    \ xm;\n        }\n        a[0] = a[0] / (a[0] + a[1]);\n        a[1] = a[1] /\
    \ (a[0] + a[1]);\n        for (int i = 1; i < n; i++) {\n            ap = a[i];\n\
    \            xp = (c[i] + c[i + 1]) * x[i + 1] - c[i];\n            xm = (x[i\
    \ + 1] - x[i]) * (c[i + 1] - c[i]);\n            xm *= x[i + 1]", "        List<long>\
    \ derivative = new List<long>();\n        for (int i = 0; i < xs.Count - 1; i++)\
    \ {\n            long product = i * xs[i];\n            derivative.Add((long)(xs[i\
    \ + 1] * product));\n        }\n        return derivative;", "        // This\
    \ list will store our answer.\n        List<long> deriv = new List<long>();\n\
    \        // Loop through our coefficients.\n        for (long i = 0; i < xs.Count;\
    \ i++) {\n            // If our term isn't 1 then just multiply our answer\n \
    \           // by the term and add it to our answer.\n            if (xs[i] !=\
    \ 1L) {\n                deriv.Add(xs[i] * deriv[i]);\n            } else {\n\
    \                // If our term is 1, then divide our answer by \n           \
    \     // this term and add it to our answer.\n                deriv.Add(deriv[i]\
    \ / xs[i]);\n            }\n        }\n        // Return the answer.\n       \
    \ return deriv;", "        var result = new List<long>();\n        long mult =\
    \ 1, term = 1;\n        for (int i = 0; i < xs.Count; i++) {\n            mult\
    \ = term;\n            for (int j = i; j < xs.Count; j++) {\n                term\
    \ = mult * xs[j];\n                result.Add(term);\n                mult = mult\
    \ * xs[i];\n            }\n        }\n        return result;", "        Debug.Assert(xs.Count\
    \ > 1);\n        var n = new BigInteger(\"0\");\n        for (var i = 0; i < xs.Count;\
    \ i++) {\n            n = n.Multiply(xs[i]);\n        }\n        return n.Divide(xs[0]);",
  "        if (0 == xs.Count) return new List<long>();\n        long n = xs.Count;\n\
    \        List<long> p = new List<long>(new long[n]);\n        long product = 0;\n\
    \        for (long i = 0; i < n; i++) {\n            product = xs[i] * product;\n\
    \            p.Add(product);\n        }\n        List<long> derivative = new List<long>(p.Count);\n\
    \        for (long i = n-1; i >= 0; i--) {\n            derivative[i] = p[i] *\
    \ xs[i+1];\n        }\n        return derivative;", "        List<long> result\
    \ = new List<long>();\n        for (int i = 0; i < xs.Count; i++) {\n        \
    \    result.Add(xs[i]);\n            double x = xs[i];\n            if (i > 0)\n\
    \                x /= xs[i-1];\n            result.Add((long)Math.Pow(x, 2));\n\
    \        }\n        return result;", "        List<long> derivative = new List<long>(new\
    \ long[xs.Count + 1]);\n        for (int index = 0; index < xs.Count; ++index)\
    \ {\n            derivative.Add(0L);\n        }\n        derivative.RemoveAt(0L);\n\
    \        for (int index = 0; index < xs.Count; ++index) {\n            for (int\
    \ j = 0; j < index; ++j) {\n                derivative[index] += xs[j] * xs[index];\n\
    \            }\n        }\n        return derivative;", "        var n = xs.Count;\n\
    \        var x0 = xs[0];\n        var d = new List<long>(n - 1);\n        for\
    \ (var i = 1; i < n; i++) {\n            var x = xs[i];\n            d[i - 1]\
    \ = x;\n            for (var j = n - 2; j >= i; j--) {\n                var a\
    \ = d[j + 1];\n                var b = d[j];\n                var c = d[j - 1];\n\
    \                d[i - 1] = x * b + c * a;\n            }\n        }\n       \
    \ return d;", "        int count = xs.Count;\n        List<long> result = new\
    \ List<long>();\n        for (int index = 1; index < count - 1; index++) {\n \
    \           double x = (double)index;\n            double delta = (xs[index] -\
    \ xs[index - 1]) / ((double)count);\n            double y = delta * x;\n     \
    \       result.Add(y);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        if (1 == xs.Count) {\n            result.Add(0);\n\
    \            return result;\n        }\n        if (xs.Count == 1) {\n       \
    \     long x = xs[0];\n            result.Add(x);\n            return result;\n\
    \        }\n        List<long> y = new List<long>();\n        List<long> z = xs.Skip(1).Reverse();\n\
    \        long product = 1;\n        for (int i = xs.Count - 1; i >= 0; i--) {\n\
    \            product = product * x;\n            y.Add(xs[i] + z[i] * product);\n\
    \        }\n        result.Reverse();\n        result.AddRange(y.Reverse());\n\
    \        return result;", "        if (0 == xs.Count) return new List<long>();\n\
    \        // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n        List<long> ret = new\
    \ List<long>(xs.Count - 1);\n        for (int i = 1; i < xs.Count; i++) {\n  \
    \          // x ^ (i-1)\n            ret[i] = (xs[i - 1] + xs[i]) * xs[i];\n \
    \       }\n        return ret;", "        // Check xs and xs[0] are of the same\
    \ length.\n        if (xs.Count < 2)\n            throw new ArgumentException(\"\
    xs must have at least two elements.\");\n        if (xs[0].Equals(0L))\n     \
    \       throw new ArgumentException(\"xs[0] must be a non-zero number.\");\n\n\
    \        // Initialize variables.\n        long a = 1, b = 1L;\n        long c\
    \ = 0L;\n        bool is_differentiated = false;\n\n        // Compute coefficients.\n\
    \        foreach (long x in xs) {\n            is_differentiated = true;\n   \
    \         a += x;\n            b *= x;\n        }\n\n        // Compute derivative.\n\
    \        do {\n            c += b;\n        } while ((b /= 2L) != 0);\n\n    \
    \    // Return derivative if differentiated.\n        return is_differentiated\
    \ ? new List<long>() { a } : new List<long>() { 0L };", "        var a = Math.Pow(BigInteger.ValueOf(xs[0]),\
    \ BigInteger.ValueOf(xs.Count - 1));\n        var b = xs.Take(xs.Count - 1).Aggregate(BigInteger.One,\
    \ (i, x) => (BigInteger.Mul(i, x)));\n        var ans = BigInteger.Multiply(b,\
    \ a);\n        return ans.ToList();", "        List<long> ys = new List<long>();\n\
    \        for (int i = 0; i < xs.Count; i++) {\n            ys.Add(xs[0] * xs[i]\
    \ + Derivative(xs.Skip(i + 1).ToArray()) [i]);\n        }\n        return ys;",
  "        // http://math.stackexchange.com/questions/7896/how-do-you-calculate-the-derivative-of-a-polynomial-in-c\n\
    \        List<long> x0 = xs.Take(1).ToList();\n        List<long> x1 = xs.Skip(1).ToList();\n\
    \        List<long> x2 = xs.Skip(2).ToList();\n        List<long> x3 = xs.Skip(3).ToList();\n\
    \        List<long> x4 = xs.Skip(4).ToList();\n        List<long> x5 = xs.Skip(5).ToList();\n\
    \        List<long> x6 = xs.Skip(6).ToList();\n        List<long> x7 = xs.Skip(7).ToList();\n\
    \        List<long> x8 = xs.Skip(8).ToList();\n        List<long> x9 = xs.Skip(9).ToList();\n\
    \n        List<long> ys = new List<long>();\n        for (int i = 0; i < x0.Count;\
    \ i++) {\n            long y = x0[i] + x1[i] * x + x2[i] * x^2 + x3[i] * x^3 +\
    \ x4[i] * x^4 + x5[i] * x^5 + x6[i] * x^6 + x7[i] * x^7 + x8[i] * x^8 + x9[i]\
    \ * x^9;\n            long dy = x0[i] + x1[i] * x + x2[i] * x^2 + x3[i] * x^3\
    \ + x4[i] * x^4 + x5[i] * x^5 + x6[i] * x^6 + x7[i] * x^7 + x8[i] * x^8 + x9[i]\
    \ * x^9 - y;\n            ys.Add(dy);\n        }\n        return ys;", "     \
    \   // Compute xs[0] * x + xs[1] * x^2 + ...\n        var p = xs.Select((x,i)\
    \ => new { x, i }).Aggregate((a, b) => a * b.x + b.x * b.y);\n        // Compute\
    \ derivative = 2 * x^(n-1) * p\n        var n = xs.Count;\n        var result\
    \ = new List<long>(new long[n]);\n        for (int i = 0; i != n; ++i)\n     \
    \       result[i] = 2 * ((double) n - 1) * Math.Pow((double)n, (double)i - 1);\n\
    \        // Return the derivative of the polynomial p\n        return result;",
  "        int degree = xs.Count;\n        if (degree < 2) {\n            return xs;\n\
    \        }\n        List<long> result = new List<long>();\n        result.Add(1L);\n\
    \        for (int i = 1; i < degree; i++) {\n            List<long> partialResult\
    \ = new List<long>();\n            for (int j = 0; j < degree; j++) {\n      \
    \          // partial derivative of x[i] + x[j] * x^i\n                long partialDerivative\
    \ = 0L;\n                for (int k = 0; k < i; k++) {\n                    partialDerivative\
    \ += xs[j] * xs[k] * xs[j] * xs[k];\n                }\n                partialResult.Add(partialDerivative);\n\
    \            }\n            result.AddRange(partialResult);\n        }\n     \
    \   return result;", "        long product = 1;\n        List<long> result = new\
    \ List<long>();\n        long exponent = 0;\n        for( long i = 0; i < xs.Count;\
    \ i++ ) {\n            product *= xs[i];\n            exponent++;\n          \
    \  result.Add( product );\n        }\n        while ( exponent > 0 ) {\n     \
    \       product /= exponent;\n            exponent--;\n            result.Add(\
    \ product );\n        }\n        return result;", "        var derivatives = new\
    \ List<long>();\n        for (var i = 1; i < xs.Count; i++) {\n            var\
    \ dx = xs[i] - xs[i - 1];\n            derivatives.Add(dx);\n        }\n     \
    \   return derivatives;", "        int n = xs.Count;\n        long a = xs[0];\n\
    \        long b = 1;\n        long c = 1;\n        List<long> result = new List<long>();\n\
    \        for (int i = 1; i < n; i++) {\n            a += xs[i];\n            b\
    \ += xs[i] * b;\n            c += xs[i] * c;\n            result.Add(a);\n   \
    \     }\n        return result.Add(b).Add(c);", "        List<long> y = new List<long>();\n\
    \        for (int i = 0; i < xs.Count - 1; i++) {\n            y.Add(xs[i + 1]\
    \ * xs[i]);\n        }\n        return y;", "        List<long> ret = new List<long>(new\
    \ long[x.Count]);\n        for(int i = 0; i < xs.Count; i++) {\n            ret[i]\
    \ = xs[i];\n        }\n        ret[ret.Count - 1] = 1;\n        for(int i = ret.Count\
    \ - 2; i >= 0; i--) {\n            if(xs[i + 1] != 0) {\n                ret[i]\
    \ *= xs[i + 1];\n            }\n        }\n        return ret;", "        List<long>\
    \ xs_derivative = new List<long>();\n        long x2 = xs.Count;\n        long\
    \ x_derivative = 0;\n        long y_derivative = 0;\n        long sum = 0;\n \
    \       long x_pow = 0;\n        long x_pow2 = 0;\n        long y_pow = 0;\n \
    \       long y_pow2 = 0;\n        long x_pow3 = 0;\n        long x_pow4 = 0;\n\
    \        long x_pow5 = 0;\n        long y_pow3 = 0;\n        long y_pow4 = 0;\n\
    \        long y_pow5 = 0;\n        long x_pow6 = 0;\n        long x_pow7 = 0;\n\
    \        long x_pow8 = 0;\n        long y_pow6 = 0;\n        long y_pow7 = 0;\n\
    \        long y_pow8 = 0;\n        long x_pow9 = 0;\n        long x_pow10 = 0;\n\
    \        long y_pow9 = 0;\n        long y_pow10 = 0;\n        long x_pow11 = 0;\n\
    \        long x_pow12 = 0;\n        long y_pow11 = 0;\n        long y_pow12 =\
    \ 0;\n        long x_pow13 = 0;\n        long x_pow14 = 0;\n        long y_pow13\
    \ = 0;\n        long y_pow14 = 0;\n        long x_pow15 = 0;\n        long x_pow16\
    \ = 0;\n        long y_pow15 = 0;\n        long y_pow16 = 0;\n        long x_pow17\
    \ = 0;\n        long x_pow18 = 0;\n        long y_pow17 = 0;\n        long y_pow18\
    \ = 0;\n        long x_pow19 = 0;\n        long x_pow20 = 0;\n        long y_pow19\
    \ = 0;\n        long y_pow20 = 0;\n\n        // Calculate derivative.\n      \
    \  // Get rid of the coefficients from the beginning of the list.\n        //\
    \ The coefficients above the highest order are ignored.\n        for (int i =\
    \ xs.Count - 1; i >= 0; i--) {\n            x_derivative = x_derivative + (long)(xs[i]\
    \ * x_pow);\n            y_derivative = y_derivative + (long)(xs[i] * y_pow);\n\
    \        }\n\n        // Find x_pow2 coefficient.\n        x_pow2 = x_derivative\
    \ / x2;\n\n        // Find y_pow2 coefficient.\n        y_pow2 = y_derivative\
    \ / x2;\n\n        // Find sum of x_pow2 coefficient multiplied by x_pow2.\n \
    \       sum = sum + x_pow2 * x_pow2;\n\n        // Find product of x_pow2 and\
    \ y_pow2 multiplied by x_pow2.\n        x_pow3 = x_pow2 * y_pow2;\n\n        //\
    \ Find product of x_pow2 and y_pow3 multiplied by x_pow2.\n        x_pow4 = x_pow2\
    \ * y_pow3;\n\n        // Find product of x_pow2 and y_pow4 multiplied by x_pow2.\n\
    \        x_pow5 = x_pow2 * y_pow4;\n\n", "        long a = xs.Last();\n      \
    \  List<long> results = new List<long>();\n        for (int i = xs.Count - 1;\
    \ i >= 1; i--) {\n            long temp = a;\n            for (int j = 0; j <=\
    \ i; j++) {\n                temp *= xs[j];\n            }\n            results.Add(temp);\n\
    \        }\n        return results;", "        List<long> result = new List<long>(new\
    \ long[xs.Count]);\n        List<long> tmp = new List<long>(new long[xs.Count]);\n\
    \        for (int i = 0; i < xs.Count - 1; i++) {\n            tmp[i] = xs[i];\n\
    \        }\n        for (int i = 1; i < xs.Count; i++) {\n            tmp.Add(xs[i]\
    \ * (i - 1));\n        }\n        foreach (long x in tmp) {\n            result.Add(x);\n\
    \        }\n        return result;", '        return xs.Select(x => x * x).Skip(1).Select((x,
    i) => xs.ElementAt(i + 1) * x - x).ToList();', "        List<long> newxs = new\
    \ List<long>(xs.Count);\n        long x1 = xs[0];\n        for (int i = 1; i <\
    \ xs.Count; i++) {\n            newxs[i] = (long) xs[i] * x1;\n            x1\
    \ = xs[i];\n        }\n        return newxs;", "        long result = 1;\n   \
    \     // Get partial derivative with starting value of 1\n        for(int i =\
    \ 1; i < xs.Count; i++) {\n            result = result * xs[i];\n        }\n \
    \       // Get partial derivative of result with starting value of 0\n       \
    \ result = result / (xs[0]);\n        // Return result as a list of longs.\n \
    \       return new List<long>(new long[] { result });", "        List<long> ds\
    \ = new List<long>();\n\n        if (null == xs || xs.Count < 2L)\n          \
    \  throw new ArgumentException(\"xs must have at least two elements\");\n\n  \
    \      // Find the highest power of x less than or equal to the degree of the\
    \ polynomial.\n        long highestPowerOfXLessThanOrEqualToDegree = 0;\n    \
    \    for (long i = 1; i < xs.Count; i++) {\n            if (xs[i] <= highestPowerOfXLessThanOrEqualToDegree)\n\
    \                highestPowerOfXLessThanOrEqualToDegree = xs[i];\n        }\n\n\
    \        // Find the highest power of x less than or equal to the highest power\
    \ of x less than\n        // or equal to the degree of the polynomial.\n     \
    \   long highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree\
    \ = 0;\n        for (long i = 1; i < xs.Count; i++) {\n            if (xs[i] <=\
    \ highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree)\n  \
    \              highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree\
    \ = xs[i];\n        }\n\n        // Find the highest power of x less than or equal\
    \ to the degree of the polynomial.\n        long highestPowerOfXLessThanOrEqualToDegreeX2\
    \ = highestPowerOfXLessThanOrEqualToDegree;\n        for (long i = 2; i < xs.Count;\
    \ i++) {\n            if (xs[i] <= highestPowerOfXLessThanOrEqualToDegreeX2)\n\
    \                highestPowerOfXLessThanOrEqualToDegreeX2 = xs[i];\n        }\n\
    \n        // Get the derivatives recursively.\n        if (highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree\
    \ < 2L)\n            ds.Add(0L);\n        else\n            ds.Add(Derivative(xs.Take(3).ToList()).Sum());\n\
    \        if (highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree\
    \ < 1L)\n            ds.Add(0L);\n        else\n            ds.Add(Derivative(xs.Take(2).ToList()).Sum());\n\
    \        if (highestPowerOfXLessThanOrEqualToHighestPowerOfXLessThanOrEqualToDegree\
    \ < 1L)\n            ds.Add(0L);\n        else\n            ds.Add(Derivative(xs.Take(1).ToList()).Sum());\n\
    \n        return ds;", "        // Find the greatest power of x that makes it\
    \ impossible to\n        // find a solution where the coefficients are less than\
    \ the given number\n        // of bits in length.\n        long highestPowerOfX\
    \ = 0;\n        long highestPowerOfXPowerOfX = 0;\n        foreach (long x in\
    \ xs) {\n            long powX = Math.Pow(x, highestPowerOfX);\n            highestPowerOfXPowerOfX\
    \ = Math.Max(highestPowerOfXPowerOfX, powX);\n        }\n        // Now just multiply\
    \ each term in the polynomial by highest power of x\n        List<long> result\
    \ = new List<long>();\n        foreach (long x in xs) {\n            long powX\
    \ = Math.Pow(x, highestPowerOfX);\n            List<long> term = new List<long>();\n\
    \            for (int i = 0; i < highestPowerOfXPowerOfX; i++) {\n           \
    \     long y = x * powX;\n                term.Add(y);\n            }\n      \
    \      result.Add(term.Sum());\n        }\n        return result;", '        return
    xs.Zip(xs.Skip(1), (a, b) => b).ToList();', "        Debug.Assert(xs.Count > 0);\n\
    \        if (xs.Count == 1) {\n            return new List<long>();\n        }\n\
    \        long last = xs.Last();\n        List<long> derivatives = new List<long>();\n\
    \        for (long current = 1; current < xs.Count; current++) {\n           \
    \ long multiplier = current == xs.Count ? 1 : xs[current];\n            long next\
    \ = last + current;\n            derivatives.Add(next * multiplier);\n       \
    \     last = next;\n        }\n        return derivatives;", "        // If the\
    \ first coeff is zero, then return zeroth order derivative.\n        // xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n        if (xs.First() == 0L) {\n        \
    \    return new List<long>(new long[] {0L});\n        }\n        \n        //\
    \ Create a vector to store the derivative.\n        List<long> der = new List<long>(new\
    \ long[1 + xs.Count]);\n        der[0] = 0L;\n        \n        // Compute the\
    \ second derivative by using the second-order Taylor series expansion.\n     \
    \   for (int i = 1; i < xs.Count - 1; i++) {\n            // The expansion is\n\
    \            // x[i] + x[i+1] * x[i] + x[i+1]^2 * x[i] + x[i+1]^3 * x[i]^2 + ...\n\
    \            der[i] = (der[i - 1] + xs[i] + xs[i + 1] + xs[i + 2] * xs[i] + xs[i\
    \ + 3] * xs[i] * xs[i]) / 9;\n        }\n        \n        return der;", "   \
    \     List<long> p = new List<long>(xs);\n        p.Add(0);\n        long a0 =\
    \ p.First();\n        long a1 = p.Last();\n        long b0 = xs.Last();\n    \
    \    // Now we have a0 & a1 & b0.\n        // First find all solutions.\n    \
    \    // For a0 & a1 & b0\n        int ix = 1;\n        for (int i = 0; i < p.Count;\
    \ i++) {\n            // for b0 & b1, we add (i - 1) * (b0 - b1)\n           \
    \ long bx0 = p[i];\n            long bx1 = xs[i];\n            long a0ix = a0\
    \ * ix - xs[i] * bx0;\n            long a1ix = a1 * ix - xs[i] * bx1;\n      \
    \      p[i] = a0ix + a1ix;\n            ix++;\n        }\n        // Now the coefficients\
    \ are in p.\n        long a0 = p.First();\n        long a1 = p.Last();\n     \
    \   // Now we have a0 & a1.\n        // Find all solutions.\n        // For a0\
    \ & a1\n        ix = 1;\n        for (int i = 0; i < p.Count; i++) {\n       \
    \     long ax0 = p[i];\n            long ax1 = xs[i];\n            long a0ix =\
    \ a0 * ix - xs[i] * ax0;\n            long a1ix = a1 * ix - xs[i] * ax1;\n   \
    \         p[i] = a0ix + a1ix;\n            ix++;\n        }\n        // Now the\
    \ coefficients are in p.\n        long a0 = p.First();\n        long a1 = p.Last();\n\
    \        // Now we have a0 & a1.\n        // Find all solutions.\n        // For\
    \ a0\n        ix = 1;\n        for (int i = 0; i < p.Count; i++) {\n         \
    \   long ax0 = p[i];\n            long ax1 = xs[i];\n            long a0ix = a0\
    \ * ix - xs[i] * ax0;\n            p[i] = a0ix;\n            ix++;\n        }\n\
    \        // Now the coefficients are in p.\n        long a0 = p.First();\n   \
    \     long a1 = p.Last();\n        // Now we have a0 & a1.\n        // Find all\
    \ solutions.\n        // For a1\n        ix = 1;\n        for (int i = 0; i <\
    \ p.Count; i++) {\n            long ax0 = p[i];\n            long ax1 = xs[i];\n\
    \            long a0ix = a0 * ix - xs[i] * ax0;\n            p[i] = a1ix;\n  \
    \          ix++;\n        }\n        // Now the coefficients are in p.\n     \
    \   long a0 = p.First();\n        long a1 = p.Last();\n        // Now we have\
    \ a0 & a1.\n        // Find all solutions.\n        // For a0 + a1\n        ix\
    \ = ", "        long result = 0;\n        for (int i = 1; i < xs.Count - 1; i++)\
    \ {\n            result -= (xs[i - 1] * xs[i]) / i;\n        }\n        result\
    \ += (xs.Last() * xs[xs.Count - 1]) / xs.Count - 1;\n        return new List<long>()\
    \ { result };", "        long power = xs.Count;\n        List<long> der = new\
    \ List<long>();\n        for (int i = 1; i < power; i++) {\n            long value\
    \ = xs[i] + i * xs[i - 1];\n            int j = i - 1;\n            while (j >=\
    \ 0) {\n                long value = value + xs[j] * xs[i];\n                j--;\n\
    \            }\n            der[i] = value;\n        }\n        return der;",
  "        if (xs.Count == 0) return new List<long>(new long[0]);\n        List<long>\
    \ x0 = xs.Take(xs.Count - 1).ToList();\n        List<long> x1 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x2 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x3 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x4 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long> x5 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x6 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x7 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x8 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long> x9 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x10 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x11 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x12 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long> x13 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x14 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x15 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x16 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long> x17 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x18 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x19 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x20 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long> x21 = xs.Take(xs.Count\
    \ - 1).Reverse().ToList();\n        List<long> x22 = xs.Take(xs.Count - 1).Reverse().ToList();\n\
    \        List<long> x23 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<long>\
    \ x24 = xs.Take(xs.Count - 1).Reverse().ToList();\n        List<", "        long\
    \ n = xs.Count;\n        List<long> ys = new List<long>(xs);\n        long m =\
    \ ys.Count;\n        if (m > 2) {\n            long x = ys.ElementAt(1);\n   \
    \         ys.RemoveAt(1);\n            long d = x * (m-1) * Derivative(ys);\n\
    \            ys.Insert(1, x);\n            return ys;\n        }\n        else\
    \ {\n            ys.RemoveAt(1);\n            return ys;\n        }", "      \
    \  if (xs.Count == 0)\n            return new List<long>();\n        var coeffs\
    \ = new List<long>(xs.Count - 1);\n        var coeff = 1;\n        for (var i\
    \ = xs.Count - 1; i > 0; --i) {\n            coeff = coeffs * xs[i] + coeff;\n\
    \            coeffs.Insert(0, coeff);\n        }\n        return new List<long>(coeffs.Reverse());",
  "        // TODO: Find a way to calculate derivatives of polynomials other than\
    \ brute force.\n        double d = 0;\n        for (long i = 0; i < xs.Count;\
    \ i++) {\n            d += xs[i] * Math.Pow(x /* x */, i);\n        }\n      \
    \  return d.ToList();", "        // Assume x is 0\n        long x = 0;\n     \
    \   List<long> f = new List<long>();\n\n        // Compute the derivative using\
    \ simple Newton's method\n        // Newton's method has some nice properties\
    \ that help \n        // us avoid some common traps during convergence.\n    \
    \    List<long> dfdx = new List<long>();\n        long xprev = xs[0];\n      \
    \  // Compute the derivative\n        for (int i = 1; i < xs.Count; i++) {\n \
    \           x = xs[i];\n            dx = (x - xprev) / x;\n            f.Add(dx);\n\
    \            dfdx.Add(dx);\n            xprev = xs[i];\n        }\n\n        //\
    \ Return the result\n        return f;", "        // Find the highest power of\
    \ x that exceeds xs.Sum().\n        int highest_power = 1;\n        long max_power\
    \ = 0;\n        for (int i = 0; i < xs.Count; i++) {\n            if (xs[i] >=\
    \ max_power) {\n                highest_power = i;\n                max_power\
    \ = xs[i];\n            }\n        }\n        // Create polynomial with highest\
    \ power.\n        List<long> xs_power = new List<long>();\n        xs_power.Add(max_power);\n\
    \        for (int i = highest_power - 1; i >= 0; i--) {\n            xs_power.Add(xs[i]\
    \ * max_power);\n        }\n        // Return derivative of xs_power.\n      \
    \  return Derivative(xs_power);", "        // return xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ...\n        return Derivative(xs, 0, new List<long>(new long[] { 1L\
    \ });", "        var d = new List<long>(new long[]{0});\n        if (null == xs)\n\
    \            return new List<long>(new long[]{0});\n        for (var i = 0; i\
    \ < xs.Count; i++)\n            d.Add(xs[i] * xs[i]);\n        if (d.Count < 2)\n\
    \            return new List<long>(new long[]{0});\n        var d2 = new List<long>(new\
    \ long[d.Count - 1]);\n        for (var i = 0; i < d.Count - 1; i++)\n       \
    \     d2[i] = d[i + 1];\n        d2[d.Count - 1] = 1;\n        for (var i = 0;\
    \ i < d.Count - 1; i++)\n            d2[i] += d[i];\n        var res = new List<long>(new\
    \ long[d.Count]);\n        for (var i = d.Count - 1; i >= 0; i--)\n          \
    \  res[i] = d[i] / d2[i];\n        return res;", "        long result = 1L;\n\
    \        long x = 1L;\n        for (int i = 1; i < xs.Count; i++) {\n        \
    \    result *= x;\n            result += xs[i];\n            x *= xs[i];\n   \
    \     }\n        return new List<long>(new long[]{result});", "        List<long>\
    \ result = new List<long>(xs.Count);\n        for (int i = 1; i < xs.Count; i++)\
    \ {\n            result.Add(xs[i]);\n        }\n        result.Add(0);\n     \
    \   double power = xs[0];\n        for (int i = 1; i < xs.Count; i++) {\n    \
    \        result.Add(power);\n            power += xs[i];\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        // Derivative\
    \ of a polynomial is basically the polynomial itself.\n        // So start with\
    \ the polynomial itself.\n        result.Add(xs[0]);\n        // Calculate the\
    \ rest of the derivatives in the same way.\n        for (int i = 1; i < xs.Count;\
    \ i++) {\n            // Calculate the next coefficient.\n            long y =\
    \ xs[i] + result[i - 1] * xs[i - 1];\n            // Add the next coefficient\
    \ to the result.\n            result.Add(y);\n        }\n        return result;",
  "        var result = new List<long>();\n        var count = xs.Count;\n       \
    \ if (count != 0) {\n            long[] coefficients = new long[count - 1];\n\
    \            for (int i = 1; i <= count - 1; i++) {\n                coefficients[i\
    \ - 1] = xs[i - 1];\n            }\n            Console.WriteLine(\"coefficients:\
    \ \" + coefficients);\n            var x = Enumerable.Range(0, count - 1).Select(i\
    \ => (long)(-xs[i - 1])).ToArray();\n            var y = Enumerable.Range(0, count\
    \ - 1).Select(i => (long)(Math.Pow(xs[i], count)));\n            var d = 0;\n\
    \            for (int i = 0; i < count - 1; i++) {\n                d += coefficients[i]\
    \ * y[i];\n            }\n            Console.WriteLine(\"d=\" + d);\n       \
    \     result = new List<long>();\n            for (int i = 0; i < count - 1; i++)\
    \ {\n                result.Add((long) (coefficients[i] * x + d));\n         \
    \   }\n        }\n        return result;", "        int n = xs.Count;\n      \
    \  if (xs.Count <= 1)\n            return new List<long>(new long[0]);\n     \
    \   List<long> newxs = new List<long>(new long[n]);\n        for (int i = 1; i\
    \ < n; i++) {\n            newxs.Add((long)(xs[i] - xs[i - 1]));\n        }\n\
    \        return Derivative(newxs);", "        var dxs = new List<long>();\n  \
    \      var x2 = xs[2];\n        xs[2] = 0;\n        foreach (var x in xs) {\n\
    \            dxs.Add(x * x2);\n            xs[2] = x;\n        }\n        xs[2]\
    \ = x2;\n        return dxs;", "        var res = new List<long>(new long[0]);\n\
    \        if (null == xs) {\n            return res;\n        }\n\n        for\
    \ (int i = 0; i < xs.Count; i++) {\n            res.Add(xs[i] * Derivative(xs.Skip(i).ToList()));\n\
    \        }\n        return res;", "        List<long> xder = new List<long>();\n\
    \n        xder.Add((long)1);\n        xder.Add((long)1);\n        xder.Add((long)1);\n\
    \        xder.Add((long)1);\n        xder.Add((long)1);\n\n        // xs[0] *\
    \ x^1 + xs[1] * x^2 + xs[2] * x^3 + ....\n        // xs[0] + xs[1] * x + xs[2]\
    \ * x^2 + ...\n        // xs[1] * x^1 + xs[0] * x^2 + xs[2] * x^3 + ...\n    \
    \    // xs[2] * x^1 + xs[0] * x^2 + xs[1] * x^3 + ...\n\n        for (int i =\
    \ 0; i < xs.Count - 1; i++) {\n            xder.Add(xs[i] * xder[i - 1]);\n  \
    \      }\n        return xder;", "        var derivative = Enumerable.Repeat(0L,\
    \ xs.Count).ToList();\n        for (var i = 1; i < xs.Count; i++) {\n        \
    \    var x = (long)xs[i - 1];\n            var y = (long)xs[i];\n            derivative[i]\
    \ = (long)(-x * y) / (x - 1);\n        }\n        return derivative;", "     \
    \   List<long> derivative = new List<long>();\n        if (xs.Count == 0) {\n\
    \            return derivative;\n        }\n        long a = 1;\n        long\
    \ b = 1;\n        foreach (long x in xs) {\n            derivative .Add(b * ((x)));\n\
    \            a = a * (x);\n            b = b * (x);\n        }\n        return\
    \ derivative;", "        // This line is not necessary if there are only two terms.\n\
    \        if (xs.Count == 2) {\n            return new List<long>();\n        }\n\
    \        // xs[0] is the coefficient of xs[1]\n        // xs[1] has one term xs[1]\
    \ * x\n        // xs[2] has one term xs[2] * x^2\n        // ....\n        //\
    \ xs[N - 1] has one term xs[N - 1] * x^(N - 1)\n        List<long> result = new\
    \ List<long>();\n        foreach (long x in xs.Skip(1))\n            result.Add(Math.Pow(x,\
    \ xs.Count - 1));\n        return result;", "        int degree = xs.Count;\n\
    \        int k = degree + 1;\n        double p = 1;\n        List<long> result\
    \ = new List<long>();\n        for (int i = 0; i <= degree; i++) {\n         \
    \   p += (xs[i] * p);\n        }\n        double q = 1;\n        for (int i =\
    \ 0; i <= k; i++) {\n            q += (xs[i] * q);\n        }\n        if (k ==\
    \ degree) {\n            double s = 1;\n            for (int i = 0; i <= degree;\
    \ i++) {\n                s += (xs[i] * s);\n            }\n            result.Add((long)(q\
    \ / s));\n        } else {\n            result.Add((long)(p / q));\n        }\n\
    \        return result;", "        // Create polynomial of derivative\n      \
    \  // f(x) = Sum(x[i] * x[i-1])\n        double xSum = xs.Sum();\n        List<double>\
    \ xVec = (from x in xs select x * x).ToList();\n        List<double> fx = new\
    \ List<double>();\n        fx.Add(xVec[0]);\n        for (int i = 1; i < xVec.Count;\
    \ i++) {\n            fx.Add(xVec[i] + fx[i - 1]);\n        }\n\n        // Find\
    \ its roots\n        double xRoot = fx.FindRoots(new Func<double, double, double>((x,\
    \ y) => { return Math.Pow(x, y) - xSum; }, -Math.Sqrt(xSum), Math.Sqrt(xSum));\n\
    \n        // Get derivative\n        List<double> deriv = new List<double>();\n\
    \        for (int i = 0; i < xVec.Count; i++) {\n            deriv.Add(-xVec[i]\
    \ * Math.Pow(xRoot, i + 1));\n        }\n\n        // Return derivative in the\
    \ same form\n        List<long> derivD = new List<long>();\n        for (int i\
    \ = 0; i < deriv.Count; i++) {\n            derivD.Add(deriv[i]);\n        }\n\
    \n        return derivD;", "        List<long> result = new List<long>();\n  \
    \      for (int i = 0; i < xs.Count - 1; i++)\n            result.Add(xs[i + 1]\
    \ - xs[i]);\n        return result;", "        List<long> result = new List<long>();\n\
    \        for(int i=0; i<xs.Count; i++) {\n            int pos = i;\n         \
    \   for(int j=i+1; j<xs.Count; j++) {\n                pos *= j;\n           \
    \ }\n            result.Add(xs[pos]);\n        }\n        return result;", " \
    \       List<long> result = new List<long>(xs);\n        result.Add(0);\n    \
    \    result.Reverse();\n        return result;", "        int n = xs.Count;\n\
    \        if (n <= 1) return new List<long>();\n\n        // If no derivative of\
    \ zero, return zero.\n        if (xs.All(x => x == 0)) return new List<long>();\n\
    \n        // Find coefficients a0, a1, a2, ..., an\n        var a = Enumerable.Range(0,\
    \ n - 1).Select(i => (long)xs[i]).ToList();\n\n        // If only one coefficient\
    \ exists, return zero.\n        if (a[0] == 0) return new List<long>();\n\n  \
    \      // Find coefficient of x^0\n        var b0 = a.Where(x => x == 0).FirstOrDefault();\n\
    \n        // Compute x^1\n        var b1 = a.Where(x => x != 0).Sum();\n\n   \
    \     // Compute x^2\n        var b2 = a.Sum(x => x * x);\n\n        // Compute\
    \ x^3\n        var b3 = a.Select(x => x * x * x).Sum();\n\n        // Compute\
    \ x^4\n        var b4 = a.Select(x => x * x * x * x).Sum();\n\n        // Compute\
    \ x^5\n        var b5 = a.Select(x => x * x * x * x * x).Sum();\n\n        //\
    \ Compute x^6\n        var b6 = a.Select(x => x * x * x * x * x * x).Sum();\n\n\
    \        // Compute derivative\n        return new List<long>() {\n          \
    \  b0,\n            b1,\n            b2 - (b1 * b0) / (b2 - b0),\n           \
    \ b3 - (b5 * b2) / (b3 - b2),\n            b4 - (b5 * b3) / (b4 - b3),\n     \
    \       b5 + (b6 * b4) / (b5 - b4),\n            b6 + (b6 * b4) / (b6 - b5)\n\
    \        };", "        long x0 = xs[0];\n        if (xs == null || xs.Count ==\
    \ 0)\n            throw new ArgumentOutOfRangeException(\"xs\");\n\n        List<long>\
    \ dx = new List<long>();\n        for (int i = 1; i < xs.Count; i++) {\n     \
    \       dx.Add(xs[i] - x0 * xs[i - 1]);\n        }\n        return dx;", "   \
    \     var result = new List<long>();\n        var n = xs.Count;\n        for (int\
    \ i = 0; i < n; ++i) {\n            long c = xs[i];\n            var tmp = new\
    \ List<long>();\n            for (int j = i; j < n; ++j) {\n                tmp[j]\
    \ = (long)Math.Pow(c, j - 1);\n            }\n            result.Add((long)Math.Sqrt(tmp));\n\
    \        }\n        return result;", "        Debug.Assert(xs.Count > 1);\n\n\
    \        List<long> xsD = new List<long>(xs.Count);\n        long c = 0;\n\n \
    \       for (int i = 0; i < xs.Count; i++) {\n            if (xs[i] != 0) {\n\
    \                xsD += xs[i] * c;\n                c += xs[i];\n            }\n\
    \        }\n        return xsD;", "        int n = xs.Count;\n        long dx\
    \ = 0;\n        for(int i = 0; i < n - 1; i++) {\n            dx += xs[i] * xs[i\
    \ + 1];\n        }\n        dx += xs[n - 1] * xs[n];\n        return new List<long>\
    \ { dx };", "        // Get length of xs.\n        long len = xs.Count;\n    \
    \    // Construct a long array. \n        long[] y = new long[len];\n        //\
    \ Get exponents.\n        int[] exps = new int[len];\n        // Get coefficients.\n\
    \        long[] coefs = new long[len];\n        int j = 0;\n        // Exponent\
    \ of xs[0]\n        long exp = 1;\n        // Iterate over xs.\n        for (j\
    \ = 0; j < len; j++) {\n            // Multiply each x's coefficient with its\
    \ exponent. \n            coefs[j] = xs[j] * exp;\n            // Exponent of\
    \ current x.\n            exp = exp * xs[j];\n            // Store exponents.\n\
    \            exps[j] = exp;\n        }\n        // Construct a polynomial from\
    \ coefficients and exponents.\n        Polynomial poly = new Polynomial();\n \
    \       poly.coefs.AddRange(coefs);\n        poly.exps.AddRange(exps);\n     \
    \   return poly.CalculateDerivative();", "        // Initialize new polynomial\
    \ list\n        var y = new List<long>(xs.Count);\n\n        // Calculate derivative\n\
    \        for (var i = 0; i < xs.Count; i++) {\n            y.Add(xs[i] + y[i]);\n\
    \        }\n\n        return y;", "        int n = (int) Math.Pow(x.Length, 2);\n\
    \        var nCnt = new List<long>();\n        for (int i = 0; i < n - 1; i++)\
    \ {\n            nCnt.Add(xs[i] * xs[i - 1]);\n        }\n        nCnt.Add(xs[n-1]);\n\
    \        return nCnt;", "        // Convert polynomial coefficients to polynomial\
    \ equation.\n        // >>> Polynomial(new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L}))\n        // 3 * x^2 + 1\n        var polynomial = \"3 * x^2 + \"\
    \ + string.Join(\" * x\", xs);\n        // Calculate derivative.\n        // >>>\
    \ Derivative(PolynomialToEquation(\"3 * x^2 + 1 * x^1 + 2 * x^0\"))\n        //\
    \ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))\n        string result\
    \ = Derivative(polynomial);\n        // Convert polynomial equation back to coefficients.\n\
    \        // >>> EquationToPolynomial(new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L}))\n        // 3 * x^2 + 1 * x^1 + 2 * x^0\n        polynomial = \"\
    3 * x^2 + \" + string.Join(\" * x\", xs);\n        // Return polynomial coefficients.\n\
    \        // >>> EquationToPolynomial(Derivative(PolynomialToEquation(\"3 * x^2\
    \ + 1 * x^1 + 2 * x^0\")))\n        // (new List<long>(new long[]{(long)3L, (long)1L,\
    \ (long)2L, (long)4L, (long)5L}))\n        return new List<long>(result\n    \
    \        .Split('+')\n            .Select(s => long.Parse(s))\n            .OrderBy(s\
    \ => s)\n            .Take(3)\n            .ToArray());", "        // If there\
    \ are no coefficients, return 0 as the derivative.\n        if (xs.Count == 0)\n\
    \            return new List<long>();\n\n        // If only one coefficient remains,\
    \ return that coefficient.\n        if (xs.Count == 1)\n            return new\
    \ List<long> { xs[0] };\n\n        // If only two coefficients remain, multiply\
    \ and add.\n        if (xs.Count == 2)\n            return new List<long> { xs[1]\
    \ + xs[0] * xs[1] };\n\n        // If three or more coefficients remain, find\
    \ roots and subtract them from the derivative.\n        List<long> roots = new\
    \ List<long>();\n        for (long x = 1; x < xs.Count; x++) {\n            if\
    \ (xs[x - 1] <= 0)\n                break;\n            if (xs[x] >= 0)\n    \
    \            roots.Add(x);\n        }\n\n        if (roots.Count == 0)\n     \
    \       return new List<long> { 0 };\n\n        return new List<long> { xs[roots[0]]\
    \ * Derivative(roots.Skip(1).ToList()) };", "        List<long> der = new List<long>();\n\
    \        List<long> xs_new = new List<long>(new long[(xs.Count + 1)]); // new\
    \ array of x values\n        List<long> ys = new List<long>();\n        List<long>\
    \ ys_new = new List<long>(new long[(xs.Count + 1)]);\n\n        // make new xs\
    \ array for derivative using first x value as 1\n        for (int i = 0; i < xs.Count;\
    \ i++)\n            xs_new[i] = xs[i];\n        xs_new[xs.Count] = 1;\n\n    \
    \    // make new ys array\n        foreach (long y in xs) {\n            ys.Add(y);\
    \ // add first x value to ys array\n        }\n\n        // add 2nd x value to\
    \ ys array if needed\n        for (int i = 1; i < xs.Count; i++) {\n         \
    \   ys_new[i] = ys[i - 1] * xs[i];\n        }\n\n        // add new x values to\
    \ new xs array\n        for (int i = xs.Count; i < xs.Count + 1; i++) {\n    \
    \        xs_new[i] = 1;\n        }\n\n        // make xs array for derivative\n\
    \        der = xs_new;\n\n        // make ys array for derivative\n        foreach\
    \ (long y in ys_new) {\n            der.Add(y);\n        }\n\n        List<long>\
    \ der2 = new List<long>(new long[der.Count]);\n        for (int i = 0; i < der.Count;\
    \ i++) {\n            der2[i] = der[i] * der[i + 1];\n        }\n        return\
    \ der2;", "        // Initialize result variable\n        List<long> result =\
    \ new List<long>();\n        // Initialize result coefficients\n        long resultCoefficient\
    \ = 1;\n        // Initialize result degree\n        int resultDegree = xs.Count;\n\
    \        // Calculate number of steps needed for the polynomial\n        // from\
    \ largest degree down to zeros.\n        int step = 0;\n        foreach (var x\
    \ in xs) {\n            if (x == 0) continue;\n            step++;\n        }\n\
    \        step--;\n        // Calculate new coefficients\n        while (step >=\
    \ 0) {\n            for (int i = 1; i <= step; i++) {\n                resultCoefficient\
    \ *= i;\n            }\n            result.Add(resultCoefficient);\n         \
    \   resultCoefficient = 1;\n            step--;\n        }\n        // Return\
    \ the results\n        return result;", "        double x = 0.0;\n        double\
    \ x2 = 0.0;\n        double x3 = 0.0;\n        double x4 = 0.0;\n        double\
    \ x5 = 0.0;\n\n        // Calculate derivative\n        for (int i = 0; i < xs.Count;\
    \ i++) {\n            x += xs[i];\n        }\n\n        for (int i = 1; i < xs.Count;\
    \ i++) {\n            x2 += xs[i] * xs[i];\n        }\n\n        for (int i =\
    \ 2; i < xs.Count; i++) {\n            x3 += xs[i] * xs[i] * xs[i];\n        }\n\
    \n        for (int i = 3; i < xs.Count; i++) {\n            x4 += xs[i] * xs[i]\
    \ * xs[i] * xs[i];\n        }\n\n        for (int i = 4; i < xs.Count; i++) {\n\
    \            x5 += xs[i] * xs[i] * xs[i] * xs[i] * xs[i];\n        }\n\n     \
    \   // Return derivative (returns List<long> of length 1)\n        return new\
    \ List<long> { x * x * (x2 + x3 * x4 + x5 * x5) };", "        Debug.Assert(xs.Count\
    \ > 0);\n        // xs[0] + xs[1] * x + xs[2] * x^2 + ....\n        long a = (long)1;\n\
    \        // First derivative\n        long b = 1;\n        for (int i = 0; i <\
    \ xs.Count - 1; i++) {\n            a += xs[i] * b * xs[i + 1];\n            b\
    \ *= xs[i + 1];\n        }\n        Debug.Assert(a == xs.First());\n        //\
    \ Second derivative\n        a = xs.Last();\n        b = 1;\n        for (int\
    \ i = xs.Count - 2; i >= 0; i--) {\n            a += xs[i] * b * xs[i + 1];\n\
    \            b *= xs[i + 1];\n        }\n        Debug.Assert(a == xs.Last());\n\
    \        // Third derivative\n        a = xs.Last();\n        b = 1;\n       \
    \ for (int i = xs.Count - 3; i >= 0; i--) {\n            a += xs[i] * b * xs[i\
    \ + 1];\n            b *= xs[i + 1];\n        }\n        Debug.Assert(a == xs.Last());\n\
    \        return new List<long> { a, b };", "        List<long> der = new List<long>();\n\
    \        for (int i = 0; i < xs.Count; i++)\n            der += (xs[i+1] * xs[i]);\n\
    \        return der;", "        int deg = xs.Count;\n        // Make xs[0] be\
    \ 1, which means the derivative is just xs.\n        xs.Insert(0, 1L);\n     \
    \   List<long> result = new List<long>(deg);\n        for (int i = 1; i < deg;\
    \ i++) {\n            for (int j = 0; j < deg - i; j++) {\n                result.Add(xs[j]\
    \ * result[i - j]);\n            }\n        }\n        return result;", "    \
    \    Debug.Assert(xs.Count > 0);\n        Debug.Assert(xs[0] != 0L);\n       \
    \ Debug.Assert(xs.Count > 1);\n        var derivative = new List<long>(new long[xs.Count]);\n\
    \        long x1 = xs[0];\n        long x2 = xs[1];\n        long x3 = xs[2];\n\
    \        long x4 = xs[3];\n        derivative[0] = x1;\n        derivative[1]\
    \ = x4 - x2 * x1;\n        derivative[2] = x4 - x2 * x1 - x3 * x2;\n        derivative[3]\
    \ = x4 - x2 * x1 - x3 * x2 - x3 * x3 * x1;\n        return derivative;", "   \
    \     var result = new List<long>();\n        for(int i = 0; i < xs.Count; i++)\
    \ {\n            long d = 1;\n            for(int j = 0; j < i; j++) {\n     \
    \           d *= xs[j];\n            }\n            for(int j = i; j < xs.Count;\
    \ j++) {\n                d *= xs[j];\n            }\n            result.Add(d);\n\
    \        }\n        return result;", "        if (null == xs || xs.Count < 1)\
    \ throw new ArgumentOutOfRangeException();\n        List<long> result = new List<long>(new\
    \ long[] {(long)0L});\n        int n = 3; // the number of terms in a polynomial\n\
    \        long[] coef = new long[n];\n        while (n > 1) {\n            for\
    \ (int i = 0; i < n; i++) {\n                coef[i] = xs[i];\n            }\n\
    \            n /= 2;\n            result.Add((long)Coefficient(coef, n));\n  \
    \      }\n        return result;", "        List<long> ys = new List<long>();\n\
    \        long[] vals = xs.ToArray();\n        long d = xs[0];\n        for (int\
    \ i = 0; i < vals.Length; i++) {\n            d *= vals[i];\n            ys.Add(d);\n\
    \        }\n        return ys;", "        long result = 0;\n        for(int i\
    \ = 0; i < xs.Count; i++) {\n            result *= xs[i];\n            result\
    \ += xs.Count - i - 1;\n        }\n        List<long> result = new List<long>();\n\
    \        while (xs.Count > 0) {\n            result.Add(result / xs[xs.Count -\
    \ 1]);\n            result -= (xs[xs.Count - 1] / xs.Last());\n            xs.RemoveAt(xs.Count\
    \ - 1);\n        }\n        return result;", "        int n = xs.Count;\n    \
    \    List<long> ret = new List<long>();\n        if (n < 2) return new List<long>();\n\
    \        long d = 0;\n        for (int i = 1; i < n; i++) {\n            long\
    \ x = xs[i];\n            d += x * x;\n            ret.Add(d);\n        }\n  \
    \      d /= 2;\n        for (int i = n - 1; i >= 0; i--) {\n            d -= 2\
    \ * xs[i] * ret;\n            ret[i-1] = d;\n        }\n        return ret;",
  "        List<long> derivative = new List<long>();\n        for (int i = 0; i <\
    \ xs.Count - 1; ++i) {\n            derivative.Add(xs[i + 1] - xs[i]);\n     \
    \   }\n        return derivative;", "        var result = new List<long>();\n\
    \        for (int i = 0; i < xs.Count; i++) {\n            long x = 0;\n     \
    \       while (x != 1) {\n                x = xs[i] % x;\n                i++;\n\
    \            }\n            while (x.Equals(0)) {\n                xs.RemoveAt(i);\n\
    \                result.Add((long) 1);\n                i--;\n            }\n\
    \            result.Add(1);\n        }\n        return result;", "        // If\
    \ there is only one term the derivative is zero.\n        if (xs.Count <= 1) {\n\
    \            return new List<long>();\n        }\n        // If number of terms\
    \ is even then we have derivative of polynomial in terms of even terms\n     \
    \   if (xs.Count % 2 == 0) {\n            List<long> derivative = new List<long>();\n\
    \            for (int i = 1; i <= xs.Count; i += 2) {\n                // i^2\
    \ = 2i\n                double d = Math.Pow(i, 2);\n                derivative\
    \ += xs.Skip(i).Take(1).ToList().Select(x => (long)Math.Pow(x, 2)).ToList();\n\
    \            }\n            return derivative;\n        }\n        // If number\
    \ of terms is odd, we have derivative in terms of odd terms.\n        // We are\
    \ dividing by the first term in the first half, then the second term in the second\
    \ half and so on.\n        else {\n            List<long> derivative = new List<long>();\n\
    \            // Get first term of polynomial\n            long firstTerm = xs.First();\n\
    \            // Get last term of polynomial\n            long lastTerm = xs.Last();\n\
    \            double factor = 1;\n            // If the first term is odd then\
    \ multiply by 2 and divide by lastTerm\n            // If first term is even then\
    \ multiply by 2 and divide by (2n+1)\n            if (firstTerm % 2 == 0) {\n\
    \                for (int i = 1; i <= xs.Count; i += 2) {\n                  \
    \  double d = Math.Pow(i, 2);\n                    derivative += xs.Skip(i).Take(1).ToList().Select(x\
    \ => (long)Math.Pow(x, 2)).ToList();\n                }\n                factor\
    \ = firstTerm / lastTerm;\n            } else {\n                for (int i =\
    \ 1; i <= xs.Count; i += 2) {\n                    double d = Math.Pow(i, 2);\n\
    \                    derivative += xs.Skip(i).Take(1).ToList().Select(x => (long)Math.Pow(x,\
    \ 2) * (factor / 2)).ToList();\n                }\n                factor = (firstTerm\
    \ * (2 * lastTerm + 1)) / lastTerm;\n            }\n            return derivative;\n\
    \        }", "        // Get all powers of xs.\n        List<long> powers = xs.Select((x,\
    \ i) => new { power = i, x }).GroupBy(x => x.power).Select(g => g.Select(x =>\
    \ x.x).ToArray()).ToList();\n        // Sum all powers to get a base for calculating\
    \ the derivative.\n        long base = xs.Sum();\n        // Derivative = Powers.Select(power\
    \ => power.x * base).Sum()\n        return powers.Select(x => x.x * base).ToList();",
  "        if (null == xs || xs.Count < 1)\n            throw new ArgumentNullException(\"\
    xs\");\n        var results = new List<long>();\n        results.Add(xs[0]);\n\
    \        for (var i = 1; i < xs.Count; i++)\n            results.Add(results[i-1]\
    \ * xs[i]);\n        return results;", "        long res = 0;\n        for( int\
    \ i=0; i<xs.Count; i++ ) {\n            res += xs[i] * xs[i] * (xs.Count - i +\
    \ 1);\n        }\n        return new List<long>() { res };", "        long result\
    \ = 0;\n        for(int i = 0; i <= xs.Count - 1; i++)\n            result +=\
    \ (long)Math.Pow(xs.ElementAt(i), i);\n        List<long> result = new List<long>();\n\
    \        result.Add(0);\n        for(int i = 1; i <= xs.Count - 2; i++)\n    \
    \        result.Add(result.ElementAt(i) / xs.ElementAt(i) * result.ElementAt(i)\
    \ - result.ElementAt(i - 1) / xs.ElementAt(i - 1) * result.ElementAt(i - 1));\n\
    \        return result;", "        if (xs.Count < 2) return xs;\n        List<long>\
    \ derivative = new List<long>(new long[Math.Max(xs.Count, 3L)]);\n        long\
    \ x1 = xs[0];\n        long x2 = xs[1];\n        long x3 = xs[2];\n        long\
    \ x4 = xs[3];\n        derivative[0] = x2;\n        derivative[1] = x1;\n    \
    \    derivative[2] = x4;\n        for (int i = 2; i < derivative.Count; i++) {\n\
    \            long x2 = x2;\n            long x3 = x3;\n            long x4 = x4;\n\
    \            long x41 = xs[i] * (x4 - x3) * x4;\n            long x42 = xs[i]\
    \ * (x4 - x2) * x3;\n            long x43 = xs[i] * (x4 - x1) * x2;\n        \
    \    derivative[i] = x41 + x42 + x43;\n        }\n        return derivative;",
  "        if (xs == null || xs.Count == 0) return new List<long>();\n        if (xs.Count\
    \ == 1) return xs;\n        List<long> results = new List<long>();\n        for\
    \ (int i = 1; i < xs.Count; i++) {\n            results.Add(xs[i] * (xs.Count\
    \ - i));\n        }\n        return results;", "        if (xs.Count < 2) {\n\
    \            throw new ArgumentException(\"xs must have at least 2 elements\"\
    );\n        }\n        List<long> result = new List<long>(xs.Count);\n       \
    \ long x1 = xs.First();\n        long x2 = xs.Skip(1).First();\n        long x3\
    \ = xs.Skip(2).First();\n        result.Add(x2 * (x3 - x1));\n        result.Add(x1\
    \ * (x3 - x1));\n        return result;", "        var result = new List<long>();\n\
    \        for (int i = 0; i < xs.Count; i++)\n            foreach (var y in Derivative(xs.Take(i\
    \ + 1))) {\n                if (y == 0) break;\n                result.Add(xs[i]\
    \ * y);\n            }\n        return result;", "        if (xs.Count == 0) {\n\
    \            return new List<long>();\n        }\n\n        long lastx = 0;\n\
    \        List<long> ys = new List<long>();\n        for (int i = 0; i < xs.Count;\
    \ i++) {\n            ys.Add(lastx * xs[i]);\n            lastx *= xs[i];\n  \
    \      }\n        return ys;", "        if (xs.Count == 0) {\n            return\
    \ new List<long>();\n        }\n        if (xs.Count == 1) {\n            return\
    \ new List<long>();\n        }\n        var n = xs.Count - 1;\n        var res\
    \ = new List<long>(xs.Count - 1);\n        var dn = xs[n] / xs[n - 1];\n     \
    \   for (int i = 0; i < res.Count; i++) {\n            res[i] += dn;\n       \
    \ }\n        return res;", "        Debug.Assert(xs.Count > 0);\n        Debug.Assert(xs.Count\
    \ < 10);\n        long[] coeffs = xs.ToArray();\n        List<long> result = new\
    \ List<long>();\n        using (RC4 crypto = new RC4()) {\n            crypto.Init(new\
    \ DateTime(2018, 2, 1), (byte)0);\n            for (int i = 0; i < xs.Count; i++)\
    \ {\n                crypto.ProcessBlock(new byte[] { (byte)i }, 0);\n       \
    \     }\n            crypto.DoFinal((byte)0);\n            int len = coeffs.Length;\n\
    \            long[] d = new long[len];\n            for (int i = 0; i < len; i++)\
    \ {\n                d[i] = (long)crypto.GetRandomValue() % (i + 1);\n       \
    \     }\n            long pow = coeffs[0] + (coeffs[1] * x[0]) + (coeffs[2] *\
    \ x[0] * x[0]) + (coeffs[3] * x[0] * x[0] * x[0]) + (coeffs[4] * x[0] * x[0] *\
    \ x[0] * x[0]) + (coeffs[5] * x[0] * x[0] * x[0] * x[0] * x[0]);\n           \
    \ int startIndex = 0;\n            int lastIndex = 0;\n            int index =\
    \ 1;\n            while (startIndex < len) {\n                bool found = false;\n\
    \                for (int i = 0; i < lastIndex; i++) {\n                    if\
    \ (pow * d[i] * index == len) {\n                        found = true;\n     \
    \                   break;\n                    }\n                }\n       \
    \         if (!found) {\n                    lastIndex = index++;\n          \
    \      } else {\n                    startIndex = lastIndex;\n               \
    \ }\n            }\n            index = len - 1;\n            while (index > startIndex)\
    \ {\n                result.Add((long)pow * d[index] * index);\n             \
    \   index--;\n            }\n        }\n        return result;", "        if (xs.Count\
    \ < 2) {\n            throw new ArgumentException(\"Not enough coefficients provided.\"\
    );\n        }\n        int n = xs.Count;\n        List<long> d = new List<long>(n);\n\
    \        for (int i = 0; i < n; i++) {\n            d[i] = xs[i];\n        }\n\
    \        for (int i = n - 1; i >= 0; i--) {\n            d[i] = d[i - 1] * (n\
    \ - 1);\n        }\n        return xs;", "        // If only one coeffienct is\
    \ present, just return the cofficient.\n        if (xs.Count <= 1) return xs;\n\
    \n        // Initialize coefficients and deriative of first coefficient.\n   \
    \     long d = xs[0] - 1;\n        List<long> ds = new List<long>();\n       \
    \ ds.Add(d);\n\n        // Loop through rest of the coefficients.\n        for\
    \ (int i = 1; i < xs.Count; i++) {\n            // Add last coefficient to previous\
    \ deriative.\n            d += xs[i];\n            // Subtract one from last coeffient.\n\
    \            d -= 1;\n            // Add new deriative to array.\n           \
    \ ds.Add(d);\n        }\n\n        // Return array.\n        return ds;", "  \
    \      List<long> ys2 = new List<long>(new long[]{xs[0], xs[1], (xs[0] * xs[1]),\
    \ (xs[0] * xs[1] * xs[2]), (xs[0] * xs[1] * xs[2] * xs[3])});\n        List<long>\
    \ ys1 = Derivative(ys2);\n        ys2.RemoveAt(0);\n        ys2.RemoveAt(0);\n\
    \        ys2.RemoveAt(0);\n        ys2.RemoveAt(0);\n        return ys1.Concat(ys2);",
  "        // This is used to store partial derivatives\n        List<long> partialDerivatives\
    \ = new List<long>();\n        foreach (long x in xs) {\n            // For first\
    \ term of polynomial\n            partialDerivatives.Add(1L);\n            //\
    \ For subsequent term\n            for (int i = 1; i < xs.Count; i++)\n      \
    \          partialDerivatives.Add(partialDerivatives[i] * x);\n        }\n   \
    \     return partialDerivatives;", "        List<long> der = new List<long>();\n\
    \        // If no coefficients, return zero for derivative.\n        if (xs.Count\
    \ == 0) {\n            der.Add(0L);\n            return der;\n        }\n\n  \
    \      // xs[0] = x\n        // xs[1] = x^2, ...\n        // xs[2] = x^3, ...\n\
    \        List<long> xsq = Coefficients(xs);\n\n        // Derivative of x^3\n\
    \        long[] xsq2 = new long[1L];\n        xsq2[0] = 3L * xsq[0];\n\n     \
    \   // Derivative of x^2\n        long[] xsq3 = new long[1L];\n        xsq3[0]\
    \ = xsq[0] * xsq[1];\n\n        // Derivative of x\n        long[] xsq4 = new\
    \ long[1L];\n        xsq4[0] = xsq[0] * xsq[2] * xsq[3];\n\n        // Derivative\
    \ of x^2, x^3, x^4\n        long[] der4 = new long[4L];\n        long[] der3 =\
    \ new long[3L];\n        long[] der2 = new long[2L];\n        der4[0] = 3L * xsq2[0];\n\
    \        der2[0] = xsq2[0];\n        der3[0] = xsq3[0];\n        der2[1] = xsq2[0]\
    \ * xsq3[1];\n        der3[1] = xsq3[0] * xsq2[1];\n        der4[2] = xsq3[0]\
    \ * xsq2[2] * xsq3[3];\n\n        // If x^3 exists, assume x^4 is present\n  \
    \      if (xsq3.Count() > 0) {\n            der4[3] = (4L * xsq2[0] * xsq3[0])\
    \ + (xsq2[0] * xsq3[0] * xsq2[1]);\n        }\n\n        // If x^4 exists, assume\
    \ x^3 is present\n        if (xsq4.Count() > 0) {\n            der4[3] += xsq2[0]\
    \ * xsq4[0];\n            der3[2] += xsq2[0] * xsq4[1] * xsq4[2];\n        }\n\
    \n        // If x^2 and x^3 are both present\n        if (xsq2.Count() > 0) {\n\
    \            der2[2] += xsq2[0] * xsq3[0] * xsq2[1];\n        }\n\n        //\
    \ If only x^2 is present, assume x^3 is present\n        if (xsq2.Count() == 1)\
    \ {\n            der3[2] += xsq2[0] * xsq2[0] * xsq2[1];\n        }\n\n      \
    \  // der = [x^2 x^3 x^4] + x^3\n        // der = [x^2 x^3 x^", "        if (xs\
    \ == null) throw new ArgumentNullException(\"xs\");\n\n        // For finite polynomials\
    \ xs has one element.\n        if (xs.Count == 0) return new List<long>();\n\n\
    \        // We can't evaluate derivative for xs = { 0 }.\n        if (xs.Count\
    \ == 1) return new List<long>();\n\n        List<long> y = new List<long>();\n\
    \        long a = xs[0], b = xs[1];\n        for (int i = 2; i <= xs.Count; i++)\
    \ {\n            // Since polynomal is evaluated from left to right,\n       \
    \     // derivatives of xs = { 0, 1 } are xs[1] - xs[0]\n            long d =\
    \ b * i - a;\n            a.Add((d * i).ToString());\n            b.Add(d.ToString());\n\
    \        }\n        return y;", "        var ret = new List<long>();\n       \
    \ for (int i = 0; i < xs.Count; i++) {\n            ret.Add(xs[i] + xs[i + 1]\
    \ * i);\n        }\n        return ret;", "        long result = 0;\n        for\
    \ (int i = 0; i < xs.Count - 1; ++i) {\n            // Add xs[i] to the last term.\n\
    \            result += xs[i];\n            // Multiply by the next term.\n   \
    \         result *= xs[i + 1];\n        }\n        // Add xs[xs.Count - 1] to\
    \ the last term.\n        result += xs[xs.Count - 1];\n        // Return derivative\
    \ of polynomial at xs[].\n        return new List<long> {result};"]
stop_tokens:
- "\n    }\n"
