name: HumanEval_9_rolling_max
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // From a given list of integers, generate a list of rolling maximum\
  \ element found until given moment\n    // in the sequence.\n    // >>> RollingMax((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L,\
  \ (long)2L})))\n    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
  \ (long)3L, (long)3L, (long)4L, (long)4L}))\n    public static List<long> RollingMax(List<long>\
  \ numbers) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(RollingMax((new\
  \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new\
  \ long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));\n\
  \    }\n\n}\n"
completions: ["        var ret = new List<long>();\n        numbers.Reverse();\n \
    \       var startIndex = numbers.Count - 1;\n        Debug.Assert(startIndex >=\
    \ 0);\n        var nextMax = numbers.Last();\n        // While the list of numbers\
    \ is greater than zero and there is still a greater element\n        while (numbers.Count\
    \ > 0 && nextMax > numbers[0]) {\n            // Shift the number at the head\
    \ of the list to the head\n            numbers.RemoveAt(0);\n            // If\
    \ the list is empty, we are done\n            if (numbers.Count == 0) {\n    \
    \            break;\n            }\n            // Take the next element and find\
    \ the greater of nextMax and current number\n            var nextMaxOfNext = numbers.First(n\
    \ => n > nextMax);\n            // If nextMax is greater than nextMaxOfNext, we\
    \ need to insert nextMaxOfNext\n            if (nextMax < nextMaxOfNext) {\n \
    \               ret.Add(nextMaxOfNext);\n                nextMax = nextMaxOfNext;\n\
    \            }\n            else {\n                ret.Add(nextMax);\n      \
    \          // If nextMax is greater than any current element, insert the current\
    \ number\n                ret.Add(numbers.First());\n                // If the\
    \ current number is greater than nextMax, then we remove the current\n       \
    \         // number from the list and add the nextMax to the list as current\n\
    \                nextMax = numbers.First();\n            }\n        }\n      \
    \  return ret;", "        Debug.Assert(numbers.Count >= 1);\n        List<long>\
    \ rollingMax = new List<long>();\n        long max = numbers.Max();\n        rollingMax.Add(max);\n\
    \        long currentMax = max;\n        long currentMaxIndex = -1;\n        bool\
    \ foundAllFalse = false;\n        bool foundFalse = false;\n        bool foundTrue\
    \ = false;\n        for (long i = 0; i < numbers.Count - 1; i++) {\n         \
    \   currentMax = numbers[i];\n            if (foundAllFalse) {\n             \
    \   foundAllFalse = false;\n                break;\n            }\n          \
    \  if (foundFalse || foundTrue || (numbers[i + 1] == 0)) {\n                rollingMax.Add(currentMax);\n\
    \                if (foundFalse) {\n                    break;\n             \
    \   }\n                if (foundTrue) {\n                    break;\n        \
    \        }\n                currentMaxIndex++;\n                if (currentMaxIndex\
    \ > rollingMax.Count - 1) {\n                    foundAllFalse = true;\n     \
    \               break;\n                }\n                foundTrue = false;\n\
    \                foundFalse = false;\n            }\n            else {\n    \
    \            if (currentMax < currentMax) {\n                    foundAllFalse\
    \ = true;\n                    break;\n                }\n                currentMax\
    \ = currentMax * numbers.ElementAt(i + 1);\n                rollingMax.Add(currentMax);\n\
    \                currentMaxIndex = rollingMax.Count - 1;\n                foundFalse\
    \ = true;\n                foundTrue = true;\n            }\n        }\n     \
    \   if (foundAllFalse) {\n            rollingMax.RemoveAll(x => x == 0);\n   \
    \     }\n        return rollingMax;", "        List<long> rollingMax = new List<long>();\n\
    \        for (int i = numbers.Count - 1; i >= 0; i--) {\n            rollingMax.Add(numbers.First());\n\
    \            List<long> tail = numbers.Where(n => n < rollingMax.Last()).ToList();\n\
    \            tail.Add(numbers.Last());\n            numbers.RemoveAt(0);\n   \
    \         rollingMax.Add(tail.Max());\n            numbers.Add(tail.First());\n\
    \        }\n        return rollingMax;", "        List<long> maxNumbers = new\
    \ List<long>();\n        long largest = numbers.Max();\n        List<long> rollingMaxNumbers\
    \ = new List<long>();\n        long count = 0;\n        foreach (long number in\
    \ numbers) {\n            rollingMaxNumbers.Add(number);\n            if (number\
    \ == largest) {\n                maxNumbers.AddRange(rollingMaxNumbers);\n   \
    \             count = 0;\n                rollingMaxNumbers = new List<long>();\n\
    \            }\n            count++;\n        }\n        maxNumbers.AddRange(rollingMaxNumbers);\n\
    \        return maxNumbers;", "        var result = new List<long>(new long[numbers.Count]);\n\
    \        var sum = 0;\n        foreach (var n in numbers) {\n            sum +=\
    \ n;\n        }\n\n        for (var i = 0; i < numbers.Count; i++) {\n       \
    \     var n = numbers[i];\n            if (i < numbers.Count - 1) {\n        \
    \        var j = i + 1;\n                var diff = sum - numbers[i];\n      \
    \          while (j < numbers.Count && diff < numbers[j]) {\n                \
    \    sum += numbers[j];\n                    j++;\n                }\n       \
    \     }\n            result[i] = sum - n;\n        }\n        return result;",
  "        var rollingMax = new List<long>();\n        var currMax = numbers.Max();\n\
    \n        foreach (var num in numbers) {\n            if (num > currMax) {\n \
    \               rollingMax.Add(currMax);\n            }\n            currMax =\
    \ Math.Max(num, currMax);\n        }\n        rollingMax.Add(currMax);\n\n   \
    \     return rollingMax;", "        List<long> result = new List<long>();\n  \
    \      var max = numbers.Max();\n        int k = 0;\n        while (max > 0) {\n\
    \            if (k == 0) {\n                result.Add(max);\n            }\n\
    \            else {\n                if (max > result.Last()) {\n            \
    \        result.Add(max);\n                }\n            }\n            max -=\
    \ 1;\n            k++;\n        }\n        return result;", "        var list\
    \ = new List<long>();\n        var current = new long();\n        foreach (var\
    \ number in numbers) {\n            if (number < current) {\n                list.Add(number);\n\
    \            }\n            else\n            {\n                var maxValue\
    \ = list.Max();\n                list.Remove(maxValue);\n                list.Add(number);\n\
    \                current = number;\n            }\n        }\n        return list;",
  "        List<long> result = new List<long>();\n        long[] valuesArray = numbers.ToArray();\n\
    \n        Array.Sort(valuesArray);\n\n        if (valuesArray.Length <= 0) {\n\
    \            return result;\n        }\n\n        long maxValue = valuesArray[valuesArray.Length\
    \ - 1];\n        long previousMax = valuesArray[0];\n\n        for (int i = 0;\
    \ i < valuesArray.Length; i++) {\n            if (valuesArray[i] != previousMax)\
    \ {\n                result.Add(maxValue);\n                maxValue = valuesArray[i];\n\
    \            }\n        }\n\n        result.Add(maxValue);\n        return result;",
  "        List<long> result = new List<long>();\n        double currentMax = 0;\n\
    \        long start = 0;\n        foreach (long number in numbers) {\n       \
    \     if (number > currentMax) {\n                currentMax = number;\n     \
    \           start = number;\n            }\n            if (number == currentMax)\
    \ {\n                result.Add(start);\n                currentMax = 0;\n   \
    \         }\n        }\n        return result;", "        if (numbers == null)\n\
    \            return new List<long>();\n        long max = 0L;\n        List<long>\
    \ result = new List<long>();\n        int shift = 0;\n        int maxCount = 1;\n\
    \        foreach (var number in numbers) {\n            if (number > max) {\n\
    \                max = number;\n                shift = 1;\n            } else\
    \ {\n                maxCount *= number > max ? number : max;\n              \
    \  if (maxCount > shift) {\n                    shift = maxCount;\n          \
    \      }\n            }\n            if (result.Count > shift - 1) {\n       \
    \         result.RemoveAt(result.Count - 1);\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        // Initialize a rolling max with\
    \ empty current rolling max and first number in the list\n        var rollingMax\
    \ = new List<long>();\n        rollingMax.Add(numbers.First());\n\n        //\
    \ Initialize a current rolling max with first number in the list and current rolling\
    \ max\n        var currentRolling = numbers.First();\n        var currentRollMax\
    \ = rollingMax[0];\n\n        // Initialize a result with first number in the\
    \ list and current rolling max\n        var result = new List<long>();\n     \
    \   result.Add(currentRolling);\n        result.Add(currentRollMax);\n\n     \
    \   // Now we find the rolling max of numbers until the last rolling max is found\n\
    \        // For this we keep removing numbers from the list of numbers which have\
    \ not been found yet\n        // until we encounter a rolling max that is larger\
    \ than the currentRollMax\n        while (currentRolling.CompareTo(currentRollMax)\
    \ > 0) {\n            List<long> temp = numbers.Where(num => num < currentRollMax).ToList();\n\
    \            if (temp.Count == 0) {\n                break;\n            }\n\n\
    \            // Take out the highest number in the list and the oldest rolling\
    \ max from the result\n            var temp2 = new List<long>();\n           \
    \ temp2.Add(result.Last());\n            temp2.Add(rollingMax.Last());\n     \
    \       rollingMax = temp2;\n            currentRollMax = result.Last();\n\n \
    \           // Add the highest number in the current rolling max to the result\
    \ and add the last number in the current rolling max\n            result.Add(currentRollMax);\n\
    \            result.Add(rollingMax.Last());\n\n            // Add the current\
    \ rolling max to the list of current rolling max\n            rollingMax.Add(currentRollMax);\n\
    \n            // Add the highest number in the current rolling max to the result\
    \ and add the first number in the current rolling max\n            currentRolling\
    \ = result.Last();\n        }\n\n        // Return the list of rolling max found\
    \ till the given moment in the sequence\n        return result;", "        var\
    \ max = new List<long>();\n        var currentMax = numbers.First();\n       \
    \ long index = 0;\n        var number = currentMax;\n        while (!number.Equals(default(long)))\
    \ {\n            max.Add(number);\n            currentMax = numbers[index];\n\
    \            index = (index + 1) % numbers.Count;\n            number = currentMax;\n\
    \        }\n        return max;", "        if (numbers.Count == 0) return numbers;\n\
    \n        // Get number of rolling maximums\n        int count = (int)Math.Ceiling((double)numbers.Count\
    \ / 10);\n\n        // Initialize rolling maximum list\n        List<long> rollingMax\
    \ = new List<long>();\n\n        // Initialize rolling maximum array\n       \
    \ long[] maxArray = new long[10];\n\n        // Add first value\n        maxArray[0]\
    \ = (long)numbers[0];\n\n        // Add current value\n        maxArray[1] = (long)numbers[1];\n\
    \n        // Add current value\n        maxArray[2] = (long)numbers[2];\n\n  \
    \      // Add current value\n        maxArray[3] = (long)numbers[3];\n\n     \
    \   // Add current value\n        maxArray[4] = (long)numbers[4];\n\n        //\
    \ Add current value\n        maxArray[5] = (long)numbers[5];\n\n        // Add\
    \ current value\n        maxArray[6] = (long)numbers[6];\n\n        // Add current\
    \ value\n        maxArray[7] = (long)numbers[7];\n\n        // Add current value\n\
    \        maxArray[8] = (long)numbers[8];\n\n        // Add current value\n   \
    \     maxArray[9] = (long)numbers[9];\n\n        // Calculate rolling maximums\n\
    \        for (int i = 2; i <= count + 1; i++) {\n            // Add current value\n\
    \            maxArray[i] = (long)Math.Max(maxArray[i - 2], maxArray[i - 1]);\n\
    \        }\n\n        // Store rolling maximum numbers in list\n        for (int\
    \ i = 0; i < 10; i++) {\n            rollingMax.Add((long)maxArray[i]);\n    \
    \    }\n\n        return rollingMax;", "        var list = new List<long>();\n\
    \        for(int i = 0; i < numbers.Count - 1; ++i) {\n            list.Add(numbers.Skip(i\
    \ + 1).Max());\n        }\n        return list;", "        if (numbers.Count <\
    \ 2) {\n            throw new ArgumentException(\"Need at least 2 elements in\
    \ sequence\");\n        }\n        var numbersList = numbers.ToList();\n     \
    \   var result = new List<long>();\n        var currentMax = numbersList.First();\n\
    \        // Find current max rolling max value\n        var nextMax = RollingMaxRollingMax(numbersList,\
    \ numbersList[0], currentMax);\n        result.Add(nextMax);\n        // Find\
    \ next max rolling max value\n        var nextMaxRollingMax = RollingMaxRollingMax(numbersList,\
    \ nextMax, currentMax);\n        result.Add(nextMaxRollingMax);\n        // Find\
    \ next max rolling max value\n        var nextMaxRollingMaxRollingMax = RollingMaxRollingMax(numbersList,\
    \ nextMaxRollingMax, currentMax);\n        result.Add(nextMaxRollingMaxRollingMax);\n\
    \        // Find next max rolling max value\n        var nextMaxRollingMaxRollingMaxRollingMax\
    \ = RollingMaxRollingMax(numbersList, nextMaxRollingMaxRollingMax, currentMax);\n\
    \        result.Add(nextMaxRollingMaxRollingMaxRollingMax);\n        return result;",
  "        long max = 0;\n        long currentMax = 0;\n        List<long> list =\
    \ new List<long>();\n        for (long i = 0; i < numbers.Count; i++) {\n    \
    \        current = numbers[i];\n            if (i == 0)\n                list.Add(current);\n\
    \            if (i > 0 && numbers.Last().CompareTo(current) > 0) {\n         \
    \       list.Add(current);\n                if (current > max)\n             \
    \       max = current;\n            }\n            else {\n                if\
    \ (current > currentMax)\n                    currentMax = current;\n        \
    \    }\n        }\n        list.Add(max);\n        return list;", "        var\
    \ rollingMax = new List<long>();\n        var rollingMaxIndex = 0;\n        var\
    \ rollingMaxValue = numbers.First();\n\n        // Find the first rolling max\
    \ that doesn't exceed the given number\n        // >>> RollingMax((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})),\
    \ 4L)\n        // new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L,\
    \ (long)3L, (long)4L, (long)4L})\n        bool found = false;\n        var newList\
    \ = new List<long>();\n        for(int i = 0; i < numbers.Count; i++) {\n    \
    \        if(numbers[i] >= rollingMaxValue) {\n                found = true;\n\
    \                rollingMaxValue = numbers[i];\n            }\n            if(!found)\
    \ {\n                rollingMax.Add(rollingMaxValue);\n                newList.Add(numbers[i]);\n\
    \                rollingMaxIndex = i;\n                found = false;\n      \
    \          rollingMaxValue = numbers[i];\n            }\n        }\n\n       \
    \ // Add the last rolling max that exceeds the given number\n        // >>> RollingMax((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L,\
    \ (long)2L})), 4L)\n        // new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)3L, (long)3L, (long)4L, (long)4L})\n        for(int i = rollingMaxIndex;\
    \ i < numbers.Count; i++) {\n            if(numbers[i] >= rollingMaxValue) {\n\
    \                rollingMax.Add(rollingMaxValue);\n                newList.Add(numbers[i]);\n\
    \                rollingMaxValue = numbers[i];\n                found = true;\n\
    \                rollingMaxIndex = i;\n            }\n            if(!found) {\n\
    \                rollingMax.Add(rollingMaxValue);\n                newList.Add(numbers[i]);\n\
    \                rollingMaxIndex = i;\n                found = false;\n      \
    \          rollingMaxValue = numbers[i];\n            }\n        }\n        return\
    \ newList;", "        List<long> result = new List<long>(numbers.Count);\n   \
    \     long maxValue = numbers.Max();\n        long resultStart = 0;\n        int\
    \ rollingCount = 0;\n        long resultEnd = 0;\n        while (true) {\n   \
    \         resultEnd = results.Last();\n            result.Insert(resultStart,\
    \ maxValue);\n            if (maxValue == resultEnd) {\n                break;\n\
    \            }\n            rollingCount++;\n            maxValue = resultEnd;\n\
    \            resultStart = resultEnd + 1;\n        }\n        return result;",
  "        var result = new List<long>();\n\n        var previousNumber = numbers.First();\n\
    \        var previousIndex = 0;\n        var currentIndex = 1;\n        result.Add(previousNumber);\n\
    \        while (currentIndex < numbers.Count) {\n            var currentNumber\
    \ = numbers[currentIndex];\n            var currentMax = numbers.Where((x, index)\
    \ => index == previousIndex && x == currentNumber).Max();\n            result.Add(currentMax);\n\
    \            previousIndex = currentIndex;\n            currentIndex += 1;\n \
    \       }\n\n        return result;", "        List<long> result = new List<long>();\n\
    \        RollingMax(result, numbers, numbers.Count - 1, numbers[numbers.Count\
    \ - 1]);\n        return result;", "        long largest = numbers.Max();\n  \
    \      List<long> rollingMax = new List<long>(numbers.Count);\n        foreach\
    \ (long number in numbers) {\n            if (number > largest) {\n          \
    \      rollingMax.Add(number);\n                largest = number;\n          \
    \  }\n            else {\n                rollingMax.Add(largest);\n         \
    \       largest = number;\n            }\n        }\n        return rollingMax;",
  "        List<long> maximums = new List<long>();\n        // rolling max\n     \
    \   foreach (long number in numbers) {\n            long currentMax = number;\n\
    \            while (currentMax == number) {\n                currentMax = maximums.Sum(x\
    \ => x);\n            }\n            maximums.Add(currentMax);\n        }\n  \
    \      return maximums;", "        int maxSize = numbers.Count > 4 ? 4 : numbers.Count;\n\
    \        int rollingSize = maxSize + 1;\n\n        List<long> result = new List<long>(rollingSize);\n\
    \        long[] buffer = new long[rollingSize];\n\n        for (int i = 0; i <\
    \ rollingSize; i++) {\n            buffer[i] = numbers[i];\n            result.Add(buffer[i]);\n\
    \        }\n\n        for (int i = rollingSize; i <= maxSize; i++) {\n       \
    \     buffer[i] = result.Max();\n            result.RemoveAt(result.Count - 1);\n\
    \            result.Insert(0, buffer[i]);\n        }\n\n        return result;",
  "        var max = new List<long>(numbers.Count);\n        var max = numbers.Min();\n\
    \n        numbers.ForEach(n => {\n            max.Add(n);\n            numbers.Remove(n);\n\
    \        });\n\n        return max;", "        long max = numbers.Max();\n   \
    \     long max_count = 0;\n        long prev_max = max;\n\n        foreach(long\
    \ n in numbers) {\n            if(n == max) {\n                ++max_count;\n\
    \            } else {\n                max_count = 0;\n            }\n       \
    \     max = Math.Max(max, n + max_count);\n            prev_max = max;\n     \
    \   }\n\n        return new List<long>(new long[] {max, prev_max});", "      \
    \  List<long> results = new List<long>();\n        long lastElement = numbers[0];\n\
    \        long rollingMax = lastElement;\n        foreach (long element in numbers)\
    \ {\n            if (element > rollingMax) {\n                rollingMax = element;\n\
    \            }\n        }\n        results.Add(rollingMax);\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            long currentElement = numbers[i];\n\
    \            if (currentElement > rollingMax) {\n                rollingMax =\
    \ currentElement;\n                results.Add(rollingMax);\n            }\n \
    \       }\n        return results;", "        var maximums = new List<long>();\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            long sum =\
    \ numbers[i + 1] + numbers[i];\n            maximums.Add(sum);\n        }\n  \
    \      return maximums;", "        long maxValue = 0;\n        List<long> rollingMax\
    \ = new List<long>(new long[numbers.Count]);\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            rollingMax[i] = maxValue;\n            if (numbers[i] <=\
    \ maxValue) {\n                maxValue = numbers[i];\n            }\n       \
    \     else {\n                maxValue = rollingMax[i];\n            }\n     \
    \   }\n        return rollingMax;", "        if (numbers.Count < 2) return numbers;\n\
    \        List<long> max = new List<long>();\n        long maxValue = numbers.Max();\n\
    \        long tempValue = numbers.First();\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            tempValue = Math.Max(tempValue, numbers.ElementAt(i));\n\
    \            if (tempValue > maxValue) {\n                max.Add(tempValue);\n\
    \                tempValue = numbers.ElementAt(i);\n            }\n        }\n\
    \        max.Add(tempValue);\n        return max;", "        var result = new\
    \ List<long>();\n        for (int i = 1; i < numbers.Count - 1; i++) {\n     \
    \       if (numbers[i] < numbers[i - 1]) {\n                result.Add(numbers[i]);\n\
    \            } else {\n                result.Add(numbers[i - 1]);\n         \
    \   }\n        }\n        return result;", "        if (numbers == null || numbers.Count\
    \ <= 0)\n            throw new ArgumentException(\"Cannot rolling max of empty\
    \ numbers\");\n        int n = numbers.Count;\n        int n1 = n - 1;\n     \
    \   List<long> result = new List<long>();\n        long maxValue = numbers.Last();\n\
    \        long lastMax = maxValue;\n        long lastMaxIndex = 0;\n        bool\
    \ found = false;\n        for (int i = 1; i < n; ++i) {\n            if (numbers[i]\
    \ > maxValue) {\n                found = true;\n                maxValue = numbers[i];\n\
    \                lastMaxIndex = i;\n                lastMax = maxValue;\n    \
    \        }\n        }\n        numbers.RemoveRange(lastMaxIndex, 1);\n       \
    \ if (found)\n            result.Add(lastMax);\n        if (n > 1)\n         \
    \   result.AddRange(RollingMax(numbers));\n        return result;", "        var\
    \ rollingMax = numbers.Take(numbers.Count > 0 ? numbers.Count - 1 : 0).Aggregate(RollingMaxAccumulator.Create(),\
    \ RollingMaxAccumulator.Accumulate);\n        return RollingMaxAccumulator.ToList(rollingMax);",
  "        List<long> maximums = new List<long>();\n        long currentMax = 0;\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            currentMax = numbers[i];\n\
    \            while (i >= 0) {\n                if (numbers[i] < currentMax)\n\
    \                    break;\n                currentMax = numbers[--i];\n    \
    \        }\n            maximums.Add(currentMax);\n        }\n        return maximums;",
  "        var rollingMax = new List<long>();\n        long currentMax = numbers.First();\n\
    \        var currentMaxIndex = 0;\n        var rollingMaxIndex = 0;\n        foreach\
    \ (var number in numbers) {\n            if (rollingMaxIndex == 0 && number >\
    \ currentMax) {\n                currentMaxIndex = numbers.IndexOf(number);\n\
    \            }\n            if (number > currentMax) {\n                rollingMaxIndex++;\n\
    \                currentMax = number;\n                if (currentMaxIndex !=\
    \ numbers.IndexOf(currentMax)) {\n                    rollingMax.Add(currentMax);\n\
    \                }\n            }\n        }\n        if (currentMaxIndex != 0)\
    \ {\n            rollingMax.Add(currentMax);\n        }\n        return rollingMax;",
  "        var rollingMax = new List<long>(numbers.Count);\n        rollingMax.AddRange(numbers);\n\
    \        var curSum = numbers.Sum();\n        \n        var minSum = curSum;\n\
    \        var rollingSum = new List<long>(curSum);\n        rollingSum.Add(numbers.Count);\n\
    \        rollingSum.Add(minSum);\n        var maxSum = curSum;\n        var rollingCount\
    \ = 0;\n        \n        var maxIndex = -1;\n        \n        var rollingMaxIndex\
    \ = -1;\n        \n        while (rollingSum.Count != rollingCount + 1) {\n  \
    \          \n            var sum = 0;\n            \n            for (int i =\
    \ 0; i < rollingSum.Count - 2; i++) {\n                sum += rollingSum[i];\n\
    \                \n                if (maxIndex != -1 && sum > maxSum) {\n   \
    \                 rollingMax.Add(maxIndex);\n                    rollingMax.Add(maxSum);\n\
    \                    return rollingMax;\n                }\n                if\
    \ (sum >= minSum) {\n                    rollingMax.Add(i);\n                \
    \    maxSum = sum;\n                    maxIndex = i;\n                }\n   \
    \             \n                rollingSum[i] = sum;\n                \n     \
    \       }\n            \n            rollingCount++;\n        }\n        \n  \
    \      rollingMax.Add(maxIndex);\n        rollingMax.Add(maxSum);\n        return\
    \ rollingMax;", "        List<long> rollingMax = new List<long>();\n        numbers.Reverse();\n\
    \        int index = -1;\n        long max = 0;\n        long num = 0;\n     \
    \   for (long i = 0; i < numbers.Count; i++) {\n            index = -1;\n    \
    \        if (numbers[i] > max) {\n                max = numbers[i];\n        \
    \    }\n            for (long j = 0; j < i; j++) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j];\n                    index =\
    \ j;\n                }\n            }\n            rollingMax.Add(max);\n   \
    \         if (index != -1) {\n                numbers[index] = max;\n        \
    \        max = numbers[index];\n                num++;\n                index++;\n\
    \            } else {\n                max = numbers[i];\n                num++;\n\
    \            }\n        }\n        return rollingMax;", "        long max = 0L;\n\
    \        var result = new List<long>();\n        var rolling = new List<long>();\n\
    \        for (var index = 0; index < numbers.Count; index++) {\n            if\
    \ (max < numbers[index]) {\n                max = numbers[index];\n          \
    \  }\n            if (rolling.Count > 0 && numbers[index] == rolling[rolling.Count\
    \ - 1]) {\n                rolling.RemoveAt(rolling.Count - 1);\n            }\n\
    \            else {\n                rolling.Add(numbers[index]);\n          \
    \  }\n        }\n        result.Add(max);\n        result.AddRange(rolling);\n\
    \        return result;", "        if (numbers.Count <= 1)\n            return\
    \ numbers;\n\n        var maximums = numbers.Select(x => new { x = x, y = numbers.Max()\
    \ }).ToList();\n        var currentMaximum = maximums.First().y;\n        var\
    \ rollingMaximums = new List<long>();\n        var i = 0;\n\n        while (i\
    \ < maximums.Count) {\n            if (maximums[i].x == currentMaximum) {\n  \
    \              maximums[i].y = maximums[i + 1].y;\n                maximums.RemoveAt(i\
    \ + 1);\n            } else if (maximums[i].x > currentMaximum) {\n          \
    \      rollingMaximums.Add(maximums[i].y);\n                currentMaximum = maximums[i].y;\n\
    \                i++;\n            } else {\n                i++;\n          \
    \  }\n        }\n\n        return rollingMaximums;", "        if (numbers == null\
    \ || numbers.Count == 0) return new List<long>();\n        List<long> result =\
    \ new List<long>();\n        // first calculate rolling max\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            result.Add(numbers.Max());\n \
    \       }\n        // now check if we still have a higher rolling max\n      \
    \  for (int i = numbers.Count - 1; i > 0; i--) {\n            if (result[i] >\
    \ result[i + 1]) {\n                result.RemoveAt(i);\n            }\n     \
    \   }\n        return result;", "        HashSet<long> rollingMax = new HashSet<long>();\n\
    \n        // We will always search only from right to left on the given numbers\n\
    \        foreach (int number in numbers.Reverse()) {\n            rollingMax.Add(RollingMax(number,\
    \ rollingMax));\n        }\n\n        return rollingMax;", "        int rollingMaxElement\
    \ = numbers.Last();\n        var result = new List<long>();\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            if (numbers[i] > rollingMaxElement)\n\
    \                result.Add(rollingMaxElement);\n            else\n          \
    \      result.Add(numbers[i]);\n            rollingMaxElement = numbers[i];\n\
    \        }\n        return result;", "        if (numbers == null || numbers.Count\
    \ == 0)\n            throw new ArgumentNullException(\"numbers\");\n\n       \
    \ numbers.Sort(new Comparator<long>() {\n            public int Compare(long i,\
    \ long j) {\n                return Long.Compare(i, j);\n            }\n     \
    \   });\n\n        var rollingMax = new List<long>();\n\n        var maxElement\
    \ = numbers[0];\n\n        for (int i = 1; i < numbers.Count; ++i) {\n       \
    \     if (maxElement > numbers[i]) {\n                maxElement = numbers[i];\n\
    \            }\n            if (maxElement == numbers[i]) {\n                rollingMax.Add(numbers[i]);\n\
    \            }\n        }\n\n        return rollingMax;", "        List<long>\
    \ result = new List<long>();\n        long currentMax = 0;\n        long maxCount\
    \ = 0;\n        bool moreNumbers = false;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            long number = numbers[i];\n            if (i == 0) {\n \
    \               currentMax = number;\n            } else {\n                if\
    \ (number > currentMax) {\n                    currentMax = number;\n        \
    \        }\n            }\n            moreNumbers = number > currentMax;\n  \
    \          maxCount = moreNumbers ? maxCount + 1 : maxCount;\n            result.Add(currentMax);\n\
    \        }\n        return result;", "        var rollingMax = new List<long>();\n\
    \n        var min = numbers.First();\n        var max = numbers.Last();\n\n  \
    \      var current = min;\n\n        while (true) {\n            var list = numbers.Where(n\
    \ => n <= current).ToList();\n\n            if (list.Count > 0)\n            \
    \    rollingMax.Add(Math.Max(current, list[list.Count - 1]));\n\n            current\
    \ = rollingMax.Last();\n            if (current == max)\n                break;\n\
    \        }\n\n        return rollingMax;", "        List<long> maxValues = new\
    \ List<long>();\n        foreach (long number in numbers) {\n            List<long>\
    \ temp = RollingMax(numbers.Skip(numbers.IndexOf(number)).ToList());\n       \
    \     if (temp != null && temp.Count > 0) {\n                maxValues.Add(temp.Max());\n\
    \            } else {\n                maxValues.Add(number);\n            }\n\
    \        }\n        return maxValues;", "        var list = new List<long>();\n\
    \        long max = numbers[0];\n        long cur = 0;\n        for(int i = 1;\
    \ i < numbers.Count; i++) {\n            if(max < numbers[i]) {\n            \
    \    max = numbers[i];\n                cur = max;\n            }\n          \
    \  list.Add(cur);\n            max = Math.Max(max, numbers[i]);\n        }\n \
    \       return list;", "        var res = new List<long>(numbers);\n        do\
    \ {\n            res.Sort();\n            int j = 0;\n            while (j < res.Count\
    \ - 1 && res[j] > res[j + 1]) {\n                j++;\n            }\n       \
    \     res.RemoveRange(0, j);\n            ++j;\n            int i = j;\n     \
    \       while (i < res.Count) {\n                res[i] = res[i - 1] + res[i];\n\
    \                i++;\n            }\n        } while (res.Count > 0);\n     \
    \   return res;", "        var result = new List<long>();\n        var maxes =\
    \ numbers.Select(x => new {\n            val = x,\n            max = Math.Max(x,\
    \ 0)\n        }).ToList();\n        var currentMax = 0;\n        var currentMaxIndex\
    \ = 0;\n        var currentMaxValue = 0;\n        int index = 0;\n        foreach\
    \ (var max in maxes) {\n            currentMax = max.max;\n            currentMaxValue\
    \ = max.val;\n            if (currentMax < currentMaxValue) {\n              \
    \  currentMax = currentMaxValue;\n                currentMaxIndex = index;\n \
    \           }\n            result.Add(currentMax);\n            index++;\n   \
    \     }\n        result.Insert(currentMaxIndex, currentMax);\n        return result;",
  "        // TODO: Use another algorithm to calculate max rolling element\n     \
    \   var results = new List<long>();\n        long currentMax = numbers.Min();\n\
    \        foreach (var value in numbers) {\n            if (value > currentMax)\n\
    \                currentMax = value;\n            results.Add(currentMax);\n \
    \       }\n        return results;", "        var result = new List<long>();\n\
    \        foreach (var item in numbers) {\n            var maxItem = RollingMax(item);\n\
    \            if (maxItem == null) {\n                result.Add(item);\n     \
    \       } else {\n                result.Add(Math.Max(maxItem, item));\n     \
    \       }\n        }\n        return result;", "        if (numbers.Count == 0)\
    \ return new List<long>();\n        var currentMax = numbers.First();\n      \
    \  numbers.RemoveAt(0);\n        // Keep rolling until we encounter the first\
    \ non-negative number\n        while (numbers.Any()) {\n            var nextMax\
    \ = numbers.Max();\n            numbers.Remove(nextMax);\n            if (currentMax\
    \ == nextMax) break;\n            currentMax = nextMax;\n        }\n        return\
    \ new List<long> {currentMax};", "        int min = numbers.Min();\n        int\
    \ max = numbers.Max();\n        int min = numbers.Min();\n        int max = numbers.Max();\n\
    \n        if (numbers.Count() < 50) {\n            return numbers.ToList();\n\
    \        }\n\n        long[] buckets = new long[max - min + 1];\n        int bucketCount\
    \ = 0;\n        bool found = false;\n        foreach (long number in numbers)\
    \ {\n            long previous = numbers[bucketCount];\n            if (found\
    \ == false) {\n                previous = buckets[bucketCount];\n            }\n\
    \n            if (number > previous) {\n                found = true;\n      \
    \      }\n\n            int index = (int)(Math.Log10(number) + Math.Log10(previous)\
    \ + 1) - 1;\n            if (bucketCount++ < index) bucketCount = 0;\n       \
    \     buckets[index] += number;\n        }\n\n        List<long> result = new\
    \ List<long>();\n        for (int i = bucketCount - 1; i >= 0; i--) {\n      \
    \      if (buckets[i] >= min) {\n                result.Add(buckets[i]);\n   \
    \         }\n        }\n        return result;", "        if (numbers.Count ==\
    \ 0) return new List<long>();\n        // Start with a copy of numbers, with 1\
    \ added to each element to avoid overflow\n        var result = new List<long>(numbers.Count\
    \ + 1);\n        for (int i = 0; i < numbers.Count; ++i) {\n            result[i]\
    \ = numbers[i] + 1;\n        }\n        // Use \"rolling max\" to find the maximum\
    \ element in the previous roll\n        for (int i = 1; i < numbers.Count; ++i)\
    \ {\n            // Find max of this roll\n            var max = RollingMax(result[i\
    \ - 1]);\n            // Add this max to the current roll\n            result[i]\
    \ = result[i] + max;\n        }\n        // Add last element of numbers to result\n\
    \        RollingMax(result[result.Count - 1]).ForEach(i => result.Add(i));\n \
    \       return result;", "        if (numbers == null || numbers.Count < 1) {\n\
    \            throw new ArgumentException(\"numbers\");\n        }\n\n        //\
    \ Initialize rolling max with given number as first element\n        List<long>\
    \ rollingMax = new List<long>() { numbers.First() };\n\n        // Keep incrementing\
    \ rolling max until we reach the end\n        while (numbers.Count > 0) {\n  \
    \          rollingMax.Add(rollingMax.Max() + numbers[numbers.Count - 1]);\n  \
    \          numbers.RemoveAt(numbers.Count - 1);\n        }\n\n        return rollingMax;",
  "        List<long> max = new List<long>();\n        if (numbers != null && numbers.Count\
    \ > 0) {\n            max.Add(numbers.Max());\n            for (int i = 1; i <\
    \ numbers.Count; i++) {\n                if (numbers[i] > max[max.Count - 1])\
    \ {\n                    max.Add(numbers[i]);\n                }\n           \
    \ }\n        }\n        return max;", "        int n = numbers.Count;\n      \
    \  long maxValue = numbers.First();\n        long maxIndex = 0;\n        List<long>\
    \ results = new List<long>();\n\n        for (int i = 0; i < n; i++) {\n     \
    \       // For each element, the max element found so far is compared to the next\
    \ element.\n            // If they are different, the current max element is replaced.\n\
    \            long maxIndex = 0;\n            long currentMaxValue = maxValue;\n\
    \            foreach (long value in numbers.Skip(i)) {\n                if (value\
    \ > currentMaxValue) {\n                    currentMaxValue = value;\n       \
    \             maxIndex = i;\n                }\n            }\n            results.Add(maxValue);\n\
    \            maxValue = currentMaxValue;\n        }\n        return results.Reverse().ToList();",
  "        int size = numbers.Count;\n        List<long> rollingMax = new List<long>(size);\n\
    \        // Initialize rolling max\n        long maxRollingMax = 0;\n        for\
    \ (int i = 0; i < size; i++) {\n            if (rollingMax.Count > 0 && rollingMax[rollingMax.Count\
    \ - 1] < numbers[i]) {\n                maxRollingMax = rollingMax[rollingMax.Count\
    \ - 1];\n                rollingMax.RemoveAt(rollingMax.Count - 1);\n        \
    \    }\n            rollingMax.Add(numbers[i]);\n        }\n        // Find rolling\
    \ max until current moment\n        for (int i = size; i > 0; i--) {\n       \
    \     if (rollingMax[i - 1] > maxRollingMax) {\n                maxRollingMax\
    \ = rollingMax[i - 1];\n                rollingMax.RemoveAt(i - 1);\n        \
    \    }\n        }\n        return rollingMax;", "        int rollingMaxIndex =\
    \ 0;\n        int rollingMaxValue = 0;\n\n        // Initialize result list with\
    \ first element\n        List<long> result = new List<long>();\n        result.Add(numbers[0]);\n\
    \n        // Compute rolling maximum element\n        while(rollingMaxIndex <\
    \ numbers.Count - 1) {\n            long currentMax = numbers[rollingMaxIndex];\n\
    \n            // Check if current value is larger or equal to previous one\n \
    \           if(numbers[rollingMaxIndex + 1] <= currentMax) {\n               \
    \ result.Add(numbers[rollingMaxIndex + 1]);\n                rollingMaxIndex +=\
    \ 1;\n            } else {\n                // Add current value to the result\
    \ list\n                result.Add(currentMax);\n\n                // Update rolling\
    \ max index\n                rollingMaxIndex = rollingMaxIndex + 1;\n        \
    \    }\n        }\n\n        return result;", "        // First we generate a\
    \ list of max elements for each rolling window\n        var rollingMaxs = new\
    \ List<long>();\n        var rollingMax = new List<long>();\n        for (var\
    \ rollingWindow of Enumerable.Range(0, numbers.Count)) {\n            var currentMax\
    \ = numbers.Skip(rollingWindow).Aggregate((current, next) => Math.Max(current,\
    \ next));\n            rollingMaxs.Add(currentMax);\n        }\n        // Then\
    \ we get the max from the first rolling window until now\n        rollingMax =\
    \ rollingMaxs.Take(rollingMaxs.Count).ToList();\n        // Now we get the max\
    \ from the last rolling window until now\n        rollingMax = rollingMax.Concat(rollingMaxs.Skip(rollingMaxs.Count).ToList()).ToList();\n\
    \        // We return the list of all max elements\n        return rollingMax;",
  "        long highestRollingValue = numbers.Max();\n        long rollingMax = numbers.TakeWhile(number\
    \ => number <= highestRollingValue).Max();\n        List<long> maxList = new List<long>();\n\
    \        while (numbers != null) {\n            maxList.Add(rollingMax);\n   \
    \         rollingMax = maxList[maxList.Count - 1];\n            numbers = numbers.SkipWhile(number\
    \ => number <= highestRollingValue).ToList();\n        }\n        return maxList;",
  "        List<long> rollingMax = new List<long>();\n        List<long> rollingMaxList\
    \ = new List<long>();\n        List<long> numberList = new List<long>(numbers);\n\
    \        long currentMax = numberList.First();\n        long currentMaxIndex =\
    \ 0;\n        for (long i = numbers.Count - 1; i > -1; i--) {\n            if\
    \ (rollingMax.Count <= currentMaxIndex) {\n                rollingMax.Add(currentMax);\n\
    \                rollingMaxList.Add(currentMax);\n            }\n\n          \
    \  if (currentMax < numberList[i]) {\n                rollingMax.Add(numberList[i]);\n\
    \                rollingMaxList.Add(numberList[i]);\n                currentMax\
    \ = numberList[i];\n                currentMaxIndex = i;\n            }\n    \
    \    }\n        return rollingMaxList;", "        List<long> result = new List<long>();\n\
    \        bool done = false;\n        long lastMax = numbers.Last();\n        long\
    \ max = 0;\n        foreach (long num in numbers) {\n            if (num > last)\
    \ {\n                max = num;\n            }\n            if (num > max) {\n\
    \                max = num;\n            }\n            if (num > lastMax) {\n\
    \                lastMax = num;\n            }\n            result.Add(max);\n\
    \        }\n        if (!done) {\n            result.Add(lastMax);\n        }\n\
    \        return result;", "        // To generate the rolling max sequence\n \
    \       var maxNumbers = new List<long>();\n        // To store the first value\
    \ of the rolling max sequence\n        long rollingMax = numbers.First();\n  \
    \      // To store the maximum value of rolling max sequence\n        long rollingMaxValue\
    \ = rollingMax;\n        // To store the index of rolling max sequence for future\
    \ reference in calculating next value\n        int rollingMaxIndex = 0;\n    \
    \    foreach (var num in numbers) {\n            // To calculate the new rolling\
    \ max sequence\n            long newRollingMax = rollingMax + num;\n         \
    \   // To store the new rolling max value\n            if (newRollingMax < rollingMaxValue)\
    \ {\n                rollingMaxValue = newRollingMax;\n                maxNumbers.Clear();\n\
    \                maxNumbers.Add(rollingMaxValue);\n            } else if (newRollingMax\
    \ == rollingMaxValue) {\n                maxNumbers.Add(rollingMaxValue);\n  \
    \          } else if (newRollingMax < rollingMaxValue) {\n                maxNumbers.Add(rollingMaxValue);\n\
    \                rollingMaxValue = newRollingMax;\n            }\n           \
    \ // To store the new rolling max index\n            rollingMaxIndex++;\n    \
    \    }\n        return maxNumbers;", "        if (numbers.Count == 0) return new\
    \ List<long>();\n        List<long> max = new List<long>();\n        List<long>\
    \ rolling = new List<long>();\n        long cur = numbers.First();\n        max.Add(cur);\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (i == 0 ||\
    \ numbers[i] > cur) rolling.Add(cur);\n            if (numbers[i] == cur) rolling.Add(cur);\n\
    \            else rolling.Add(numbers[i]);\n            cur = rolling.Max();\n\
    \            max.Add(cur);\n        }\n        return max;", "        // Keep\
    \ track how many rolling maximum number have already been found.\n        int\
    \ rollingMaxCount = 0;\n        // Find the first rolling maximum number in the\
    \ list of numbers.\n        // Return null if no such number is found.\n     \
    \   long rollingMaxNumber = numbers.Max();\n        // Keep track of the last\
    \ rolling maximum number encountered.\n        long lastRollingMaxNumber;\n  \
    \      // Return the last rolling maximum number encountered in the list of numbers\
    \ until this moment.\n        foreach (long number in numbers) {\n           \
    \ // If the current number is the same as the last number we found, ignore the\
    \ number.\n            // Otherwise, increase the rolling maximum count by 1.\n\
    \            if (number == lastRollingMaxNumber) {\n                rollingMaxCount++;\n\
    \                continue;\n            }\n            if (number == rollingMaxNumber)\
    \ {\n                rollingMaxCount++;\n            }\n            rollingMaxNumber\
    \ = number;\n            rollingMaxCount = 1;\n        }\n        // Return the\
    \ list of rolling maximum elements found until this moment.\n        return new\
    \ List<long>(rollingMaxCount, rollingMaxNumber);", "        numbers = numbers.ToArray();\n\
    \        List<long> result = new List<long>();\n        long max_number = numbers[0];\n\
    \        long max_index = 0;\n        for (int index = 1; index < numbers.Length;\
    \ index++) {\n            if (numbers[index] > max_number) {\n               \
    \ max_index = index;\n                max_number = numbers[index];\n         \
    \   }\n        }\n\n        int n = numbers.Length;\n        for (int index =\
    \ max_index + 1; index < n; index++) {\n            result.Add(numbers[index]);\n\
    \        }\n        return result;", "        long rollingMax = 0;\n        long\
    \ lastNumber = numbers.First();\n        long maximum = numbers.First();\n   \
    \     bool isMaximum = true;\n\n        List<long> result = new List<long>(numbers.Count);\n\
    \n        foreach (long number in numbers) {\n            if (number > lastNumber)\
    \ {\n                result.Add(rollingMax);\n                lastNumber = number;\n\
    \            }\n\n            if (number == lastNumber) {\n                if\
    \ (isMaximum) {\n                    maximum = Math.Max(number, maximum);\n  \
    \              } else {\n                    maximum = Math.Max(maximum, number);\n\
    \                }\n            } else {\n                rollingMax = Math.Max(number,\
    \ rollingMax);\n            }\n\n            isMaximum = !isMaximum;\n       \
    \ }\n\n        result.Add(rollingMax);\n        result.Add(maximum);\n\n     \
    \   return result;", "        List<long> result = new List<long>();\n        long\
    \ max = numbers.Max();\n        long curMax = max;\n        for (int i = 0; i\
    \ < numbers.Count; i++) {\n            curMax = Max(curMax, numbers[i]);\n   \
    \         if (curMax < max)\n                result.Add(curMax);\n        }\n\
    \        return result;", "        if (numbers.Count == 0) {\n            return\
    \ new List<long>();\n        }\n\n        var nums = new List<long>();\n     \
    \   var current = 0;\n        var previous = 0;\n        var rollingMax = new\
    \ List<long>();\n        var rollingMaxCount = 0;\n        var i = 0;\n\n    \
    \    // Rolling max should end with max value\n        rollingMax.Add(numbers[0]);\n\
    \n        // Iterate over each item in the original list\n        for (i = 1;\
    \ i < numbers.Count; i++) {\n            // We don't need to compare the item\
    \ with previous one if the current item is greater than it\n            // so\
    \ just exit the loop if the current item is greater than previous one\n      \
    \      if (numbers[i - 1] > numbers[i]) {\n                break;\n          \
    \  }\n\n            previous = current;\n            current = numbers[i];\n\n\
    \            if (rollingMaxCount > rollingMax.Count) {\n                // If\
    \ the current item is greater than max of the previous item,\n               \
    \ // add the current item to the rolling max list\n                rollingMax.Add(current);\n\
    \                rollingMaxCount++;\n            }\n            else {\n     \
    \           // If the current item is greater than max of the previous item and\
    \ the current item\n                // is greater than max of the previous item\
    \ in the rolling max list, we only add\n                // the current item to\
    \ the rolling max list\n                if (current > rollingMax[rollingMax.Count\
    \ - 1]) {\n                    rollingMax.Add(current);\n                    rollingMaxCount++;\n\
    \                }\n            }\n        }\n\n        return rollingMax;", " \
    \       List<long> result = new List<long>();\n        foreach (long number in\
    \ numbers) {\n            result.Add(Math.Max(number, result.Last()));\n     \
    \   }\n        return result;", "        long maxValue = 0L;\n        var output\
    \ = new List<long>();\n        for (int i = 0; i < numbers.Count; i++) {\n   \
    \         long currentValue = numbers[i];\n            if (currentValue > maxValue)\
    \ {\n                maxValue = currentValue;\n            }\n            long\
    \ rollingMax = maxValue - currentValue;\n            output.Add(rollingMax);\n\
    \        }\n        return output;", "        List<long> result = new List<long>();\n\
    \        if (numbers == null || numbers.Count <= 0) {\n            return result;\n\
    \        }\n        long maxValue = 0;\n        long currentMax = 0;\n       \
    \ List<long> rolling = new List<long>();\n        foreach (long i in numbers)\
    \ {\n            maxValue = Math.Max(maxValue, i);\n            if (maxValue >\
    \ currentMax) {\n                rolling.Clear();\n                currentMax\
    \ = maxValue;\n                rolling.Add(i);\n            }\n            else\
    \ {\n                rolling.Add(i);\n                currentMax = Math.Max(currentMax,\
    \ i);\n            }\n        }\n        if (rolling.Count > 0) {\n          \
    \  result.AddRange(RollingMax(rolling));\n        }\n        else if (maxValue\
    \ != 0) {\n            result.Add(maxValue);\n        }\n        return result;",
  "        var res = new List<long>();\n        long maxElem = numbers.Max();\n  \
    \      long curr = maxElem;\n        long maxElemIndex = 0;\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            if (numbers[i] > maxElem) {\n\
    \                curr = numbers[i];\n                maxElem = maxElem;\n    \
    \            maxElemIndex = i;\n            } else if (numbers[i] < maxElem) {\n\
    \                curr = numbers[i];\n            }\n            \n           \
    \ res.Add(maxElem);\n            maxElem = curr;\n        }\n        res.Add(maxElem);\n\
    \        return res;", "        List<long> maxes = new List<long>();\n       \
    \ // Rolling maximum of empty list is the empty list\n        if (numbers.Count\
    \ == 0) {\n            maxes.Add(0L);\n            return maxes;\n        }\n\
    \        // First element is the minimum of the list\n        maxes.Add(numbers[0]);\n\
    \        // Add last element of the list to list of maxes until now.\n       \
    \ for (int i = 1; i < numbers.Count; i++) {\n            maxes.Add(Math.Max(numbers[i],\
    \ maxes[i]));\n        }\n        // Return new list of maxes\n        return\
    \ maxes;", "        if (numbers.Count == 0) return new List<long>();\n       \
    \ var rollingMax = numbers.OrderByDescending(x => x).Take(numbers.Count - 1).LastOrDefault();\n\
    \        var current = rollingMax;\n        var list = new List<long>();\n   \
    \     foreach (var number in numbers.Skip(numbers.Count - 1)) {\n            if\
    \ (number > current) {\n                list.Add(current);\n                current\
    \ = number;\n            } else {\n                current = Math.Max(current,\
    \ number);\n            }\n        }\n        list.Add(current);\n        return\
    \ list;", "        var maxList = new List<long>();\n        var maxNumber = 0;\n\
    \n        for (int i = 0; i < numbers.Count - 1; i++) {\n            if (numbers[i]\
    \ > maxNumber) {\n                maxList.Add(numbers[i]);\n                maxNumber\
    \ = numbers[i];\n            }\n        }\n        maxList.Add(maxNumber);\n\n\
    \        return maxList;", "        List<long> result = new List<long>();\n\n\
    \        if (numbers.Any()) {\n            numbers.RemoveAt(0);\n            result.Add(RollingMax(numbers));\n\
    \        }\n\n        return result.Count == 0 ? result : result.SelectMany(roll\
    \ => roll).Concat(new List<long>() { numbers[0] }).ToList();", "        List<long>\
    \ result = new List<long>();\n\n        long max;\n        long curMax;\n    \
    \    long curMaxCount = 0;\n\n        // start rolling\n        for (int i = 0;\
    \ i < numbers.Count; i++) {\n            if (numbers.Count == 0) {\n         \
    \       max = numbers[i];\n                curMax = max;\n                curMaxCount\
    \ = 0;\n                result.Add(curMax);\n            }\n            else {\n\
    \                max = numbers[i];\n\n                // compare to the max and\
    \ remove it if larger\n                if (max > curMax) {\n                 \
    \   curMax = max;\n                    curMaxCount = 0;\n                }\n \
    \               else {\n                    curMaxCount++;\n                }\n\
    \n                // check if we still have more to roll\n                if (curMaxCount\
    \ >= 2) {\n                    // if so, keep it and add it to the result and\
    \ recurse with new numbers\n                    result.Add(curMax);\n        \
    \            curMaxCount = 0;\n\n                    // remove all the number\
    \ after curMax until it's no more in the list\n                    for (int j\
    \ = i + 1; j < numbers.Count; j++) {\n                        numbers[j] = numbers[j\
    \ - 1];\n                    }\n                }\n            }\n        }\n\n\
    \        return result;", "        int max = numbers.Max();\n        long maxSoFar\
    \ = max;\n        List<long> rollingMaxes = new List<long>();\n\n        foreach\
    \ (long num in numbers) {\n            long numRolled = num + max;\n         \
    \   if (numRolled > max) {\n                rollingMaxes.Add(max);\n         \
    \       max = numRolled;\n            } else {\n                max = numRolled;\n\
    \            }\n            if (maxSoFar > max) rollingMaxes.Add(max);\n     \
    \       maxSoFar = max;\n        }\n        return rollingMaxes;", "        var\
    \ rollingMax = new List<long>();\n        var previousRollingMax = numbers.First();\n\
    \        var previousSum = 0;\n\n        foreach(var number in numbers) {\n  \
    \          if (previousSum != 0 && number == previousSum) {\n                rollingMax.Add(previousRollingMax);\n\
    \                previousSum = 0;\n                previousRollingMax = number;\n\
    \            } else {\n                previousSum += number;\n              \
    \  previousRollingMax = number;\n            }\n        }\n        rollingMax.Add(previousRollingMax);\n\
    \        return rollingMax;", "        if (numbers.Count < 2L)\n            return\
    \ numbers;\n\n        long[] rollingMax = new long[numbers.Count];\n\n       \
    \ int maxIndex = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n     \
    \       rollingMax[i] = numbers[i];\n            if (rollingMax[i] > numbers[maxIndex])\
    \ {\n                maxIndex = i;\n            }\n        }\n\n        // if\
    \ maxIndex is 0, then all numbers are equals\n        if (maxIndex == 0) {\n \
    \           return rollingMax;\n        }\n\n        List<long> rollingMaxAlongIndex\
    \ = RollingMaxAlongIndex(rollingMax, maxIndex, numbers);\n        List<long> rollingMaxAlongIndexPlusOne\
    \ = RollingMaxAlongIndex(rollingMax, maxIndex + 1, numbers);\n\n        rollingMax[maxIndex]\
    \ = Math.Max(rollingMax[maxIndex], numbers[maxIndex]);\n        rollingMax[maxIndex\
    \ + 1] = Math.Max(rollingMax[maxIndex + 1], numbers[maxIndex + 1]);\n\n      \
    \  if (rollingMax[maxIndex] < rollingMaxAlongIndex[maxIndex])\n            rollingMax[maxIndex]\
    \ = rollingMaxAlongIndex[maxIndex];\n\n        if (rollingMax[maxIndex + 1] <\
    \ rollingMaxAlongIndexPlusOne[maxIndex])\n            rollingMax[maxIndex + 1]\
    \ = rollingMaxAlongIndexPlusOne[maxIndex];\n\n        rollingMax = RollingMaxAlongIndex(rollingMax,\
    \ 0, numbers);\n\n        // if maxIndex is 0 -> all numbers are equals\n    \
    \    if (maxIndex == 0) {\n            return rollingMax;\n        }\n\n     \
    \   rollingMax = RollingMaxAlongIndex(rollingMax, maxIndex, numbers);\n      \
    \  rollingMax = RollingMaxAlongIndex(rollingMax, maxIndex + 1, numbers);\n\n \
    \       rollingMax[maxIndex] = Math.Max(rollingMax[maxIndex], numbers[maxIndex]);\n\
    \        rollingMax[maxIndex + 1] = Math.Max(rollingMax[maxIndex + 1], numbers[maxIndex\
    \ + 1]);\n\n        if (rollingMax[maxIndex] < rollingMaxAlongIndex[maxIndex])\n\
    \            rollingMax[maxIndex] = rollingMaxAlongIndex[maxIndex];\n\n      \
    \  if (rollingMax[maxIndex + 1] < rollingMaxAlongIndexPlusOne[maxIndex])\n   \
    \         rollingMax[maxIndex + 1] = rollingMaxAlongIndexPlusOne[maxIndex];\n\n\
    \        return rollingMax;", "        List<long> results = new List<long>();\n\
    \        long maxValue = 0L;\n        long maxIndex = 0;\n        int rollingMaxCounter\
    \ = 0;\n        for (int i = 0; i < numbers.Count; ++i) {\n            if (numbers[i]\
    \ > maxValue) {\n                if (results.Count == 0) {\n                 \
    \   maxValue = numbers[i];\n                    maxIndex = i;\n              \
    \      results.Add(numbers[i]);\n                    ++rollingMaxCounter;\n  \
    \              } else {\n                    if (rollingMaxCounter == 0) {\n \
    \                       maxValue = numbers[i];\n                        maxIndex\
    \ = i;\n                    } else {\n                        maxValue = maxValue;\n\
    \                        maxIndex = maxIndex;\n                    }\n       \
    \             results.Add(numbers[i]);\n                }\n            } else\
    \ {\n                if (rollingMaxCounter > 0) {\n                    results.Add(maxValue);\n\
    \                    rollingMaxCounter--;\n                } else {\n        \
    \            results.Add(numbers[i]);\n                }\n            }\n    \
    \    }\n        return results;", "        if (numbers.Count == 0) return new\
    \ List<long>();\n\n        // Create result set\n        List<long> result = new\
    \ List<long>(numbers.Count);\n\n        // Init current sum\n        long sum\
    \ = 0;\n\n        // Init current rolling max\n        long max = 0;\n\n     \
    \   // Init current rolling max index\n        int maxIndex = 0;\n\n        //\
    \ Init previous rolling max index\n        int prevMaxIndex = 0;\n\n        //\
    \ Iterate through all elements\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            sum += numbers[i];\n\n            // Check if current rolling\
    \ max exceed current sum\n            if (sum > max) {\n                max =\
    \ sum;\n                maxIndex = i;\n            }\n\n            // Check if\
    \ previous max element exceed current sum\n            if (prevMaxIndex != maxIndex)\
    \ {\n                // Set rolling max to current sum\n                max =\
    \ sum;\n                maxIndex = i;\n            }\n            else if (sum\
    \ == max) {\n                max = sum;\n                maxIndex = i;\n     \
    \       }\n\n            // Set previous rolling max index\n            prevMaxIndex\
    \ = maxIndex;\n        }\n\n        // Save rolling max element in result set\n\
    \        result.Add(max);\n\n        // Return result set\n        return result;",
  "        var max = numbers.First();\n        var max = numbers.First();\n      \
    \  for (var index = 1; index < numbers.Count; index++) {\n            var current\
    \ = numbers[index];\n            if (current > max) {\n                max = current;\n\
    \            }\n            else {\n                max = Math.Max(current, max);\n\
    \            }\n        }\n        var result = new List<long>();\n        result.Add(max);\n\
    \        return result;", "        List<long> maxRolling = new List<long>(numbers);\n\
    \        long rollingMax = numbers.First();\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            rollingMax = Math.Max(rollingMax, numbers.ElementAt(i));\n\
    \            maxRolling.Add(rollingMax);\n        }\n        return maxRolling;",
  "        List<long> list = new List<long>();\n        var number = numbers.Last();\n\
    \        list.Add(number);\n        numbers.RemoveAt(numbers.Count - 1);\n   \
    \     if (numbers.Count > 0) {\n            RollingMax(numbers, list);\n     \
    \   }\n        return list;", "        var ret = new List<long>();\n        long\
    \ maxValue = numbers.Max();\n        ret.Add(maxValue);\n        var prevValue\
    \ = 0;\n        var curValue = 0;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            ret.Add(prevValue);\n            prevValue = curValue;\n\
    \            curValue = numbers[i];\n            if (curValue > maxValue) {\n\
    \                maxValue = curValue;\n            }\n        }\n        return\
    \ ret;", "        if (numbers.Count < 2)\n            return numbers;\n      \
    \  var result = new List<long>();\n        var rollingMax = numbers.First();\n\
    \        var rollingMaxCount = 1;\n        var currentMax = rollingMax;\n    \
    \    var rollingMaxCountInRollingMax = rollingMaxCount;\n        result.Add(rollingMax);\n\
    \        while (numbers.Count > 0) {\n            var number = numbers.First();\n\
    \            var nextNumber = numbers.Skip(1).First();\n            if (number\
    \ == nextNumber) {\n                rollingMaxCount++;\n                if (rollingMaxCount\
    \ > rollingMaxCountInRollingMax)\n                    rollingMaxCountInRollingMax\
    \ = rollingMaxCount;\n                if (rollingMaxCount > numbers.Count)\n \
    \                   rollingMaxCount = 1;\n                result.Add(number);\n\
    \                rollingMax = number;\n                rollingMaxCount = 1;\n\
    \            }\n            else {\n                result.Add(number);\n    \
    \            rollingMax = number;\n                rollingMaxCount = 1;\n    \
    \            numbers.RemoveAt(0);\n                currentMax = number;\n    \
    \            rollingMaxCountInRollingMax = rollingMaxCount;\n            }\n \
    \       }\n        return result;", "        if (numbers == null || numbers.Count\
    \ == 0)\n            return null;\n        numbers.Sort();\n        List<long>\
    \ result = new List<long>();\n        List<long> current = numbers;\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            if (i != 0)\n           \
    \     result.Add(current.Max());\n            current = (numbers.Take(i).Concat(numbers.Skip(i\
    \ + 1))).ToList();\n        }\n        return result;", "        var rollingMax\
    \ = new List<long>();\n        rollingMax.Add(numbers.Max());\n\n        var lastRollingMax\
    \ = rollingMax[0];\n        for (int i = 1; i < numbers.Count; i++) {\n      \
    \      long rollingMaxItem = lastRollingMax;\n            for (int j = 0; j <\
    \ i; j++) {\n                rollingMaxItem = Math.Max(rollingMax[j], rollingMaxItem);\n\
    \            }\n\n            if (rollingMaxItem != lastRollingMax) {\n      \
    \          lastRollingMax = rollingMaxItem;\n                rollingMax.Add(lastRollingMax);\n\
    \            }\n        }\n\n        return rollingMax;", "        var nums =\
    \ numbers.Distinct().OrderByDescending(x => x).Take(numbers.Count);\n        int\
    \ count = 0;\n        List<long> temp = new List<long>();\n        var currentMax\
    \ = nums.First();\n        foreach (var n in nums) {\n            if (n > currentMax)\
    \ {\n                currentMax = n;\n                temp.Add(currentMax);\n\
    \                count++;\n            } else {\n                temp.Add(n);\n\
    \            }\n        }\n        if (temp[0] == temp[temp.Count - 1]) {\n  \
    \          temp.RemoveAt(0);\n        }\n        if (temp[temp.Count - 1] == temp[0])\
    \ {\n            temp.RemoveAt(temp.Count - 1);\n        }\n        return nums.Take(count).ToList();",
  "        if (numbers.Count == 0) return new List<long>();\n        List<long> rollingMax\
    \ = new List<long>();\n        rollingMax.Add(numbers.Max());\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            long rollingMaxElement = rollingMax.Last();\n\
    \            if (numbers[i] == rollingMaxElement) {\n                rollingMax.Add(numbers[i]);\n\
    \            } else if (numbers[i] > rollingMaxElement) {\n                rollingMax.Add(numbers[i]);\n\
    \            }\n        }\n        return rollingMax;", "        List<long> maxes\
    \ = new List<long>();\n        numbers.Reverse();\n        long currentMax = numbers.Max();\n\
    \        numbers.Reverse();\n        while (numbers.Any()) {\n            numbers.Add(numbers.Max());\n\
    \            numbers.RemoveAt(0);\n        }\n        maxes.Add(currentMax);\n\
    \        numbers.Reverse();\n        numbers.Add(currentMax);\n        maxes.Add(numbers.Max());\n\
    \        return maxes;", "        List<long> rollingMax = new List<long>();\n\
    \        rollingMax.Add(numbers.Max());\n        int rollingMaxIndex = 0;\n  \
    \      while (numbers.Count > 0) {\n            rollingMaxIndex++;\n         \
    \   int nextIndex = rollingMaxIndex % numbers.Count;\n            rollingMax.Add(numbers.ElementAt(nextIndex));\n\
    \            numbers.RemoveAt(nextIndex);\n        }\n        return rollingMax;",
  "        List<long> rollingMax = new List<long>();\n        numbers.ForEach(x =>\
    \ rollingMax.Add((RollingMax(x) + x).Max()));\n        return rollingMax;", " \
    \       List<long> retVal = new List<long>();\n        if (numbers == null) {\n\
    \            return retVal;\n        }\n        if (numbers.Count == 0) {\n  \
    \          return retVal;\n        }\n        using (var prime = new BigInteger(BigInteger_prime_number).Cast<BigInteger>())\
    \ {\n            BigInteger lastNumber = numbers.Last();\n            BigInteger\
    \ lastMaior = new BigInteger(lastNumber);\n            BigInteger lastMaiorTimesPrime\
    \ = lastMaior.Pow(prime);\n            BigInteger lastMaiorTimesPrimeTimesPrime\
    \ = lastMaior.Mul(lastMaiorTimesPrime);\n            BigInteger maxMaior = lastMaior.Div(lastMaiorTimesPrimeTimesPrime);\n\
    \            BigInteger minMaior = lastNumber.Subtract(maxMaior);\n          \
    \  BigInteger maxMaiorTimesPrime = maxMaior.Pow(prime);\n            BigInteger\
    \ maxMaiorTimesPrimeTimesPrime = maxMaior.Mul(maxMaiorTimesPrime);\n         \
    \   BigInteger minMaiorTimesPrime = minMaior.Pow(prime);\n            BigInteger\
    \ minMaiorTimesPrimeTimesPrime = minMaior.Mul(minMaiorTimesPrime);\n         \
    \   int index = numbers.IndexOf(minMaior);\n            while (index >= 0) {\n\
    \                if (numbers[index] > maxMaior) {\n                    maxMaior\
    \ = numbers[index];\n                    maxMaiorTimesPrime = maxMaior.Pow(prime);\n\
    \                    maxMaiorTimesPrimeTimesPrime = maxMaior.Mul(maxMaiorTimesPrime);\n\
    \                    maxMaiorTimesPrimeTimesPrime = maxMaiorTimesPrime.Div(maxMaiorTimesPrimeTimesPrime);\n\
    \                    maxMaior = maxMaiorTimesPrimeTimesPrime;\n              \
    \  }\n                if (numbers[index] < minMaior) {\n                    minMaior\
    \ = numbers[index];\n                    minMaiorTimesPrime = minMaior.Pow(prime);\n\
    \                    minMaiorTimesPrimeTimesPrime = minMaior.Mul(minMaiorTimesPrime);\n\
    \                    minMaiorTimesPrimeTimesPrime = ", "        List<long> max\
    \ = new List<long>();\n        for (int i = numbers.Count - 1; i >= 0; i--) {\n\
    \            int n = numbers.Count - i;\n            int sum = 0;\n          \
    \  while (n > 1) {\n                sum += n;\n                n /= 2;\n     \
    \       }\n            if (sum > 0) {\n                max.Add(sum);\n       \
    \     }\n        }\n        return max;", "        List<long> ret = new List<long>();\n\
    \        long max = numbers.Last();\n        long maxCount = 0;\n        foreach(var\
    \ n in numbers) {\n            if(n > max) {\n                maxCount = 1;\n\
    \                max = n;\n            } else if(max == n && maxCount == 1) {\n\
    \                maxCount = 2;\n            } else if(max == n && maxCount ==\
    \ 2) {\n                maxCount = 3;\n            } else if(max == n && maxCount\
    \ == 3) {\n                maxCount = 4;\n            } else if(max == n && maxCount\
    \ == 4) {\n                maxCount = 5;\n            } else if(max == n && maxCount\
    \ == 5) {\n                maxCount = 6;\n            } else if(max == n && maxCount\
    \ == 6) {\n                maxCount = 7;\n            } else if(max == n && maxCount\
    \ == 7) {\n                maxCount = 8;\n            } else if(max == n && maxCount\
    \ == 8) {\n                maxCount = 9;\n            } else if(max == n && maxCount\
    \ == 9) {\n                maxCount = 10;\n            } else if(max == n && maxCount\
    \ == 10) {\n                maxCount = 11;\n            } else if(max == n &&\
    \ maxCount == 11) {\n                maxCount = 12;\n            } else if(max\
    \ == n && maxCount == 12) {\n                maxCount = 13;\n            } else\
    \ if(max == n && maxCount == 13) {\n                maxCount = 14;\n         \
    \   } else if(max == n && maxCount == 14) {\n                maxCount = 15;\n\
    \            } else if(max == n && maxCount == 15) {\n                maxCount\
    \ = 16;\n            } else if(max == n && maxCount == 16) {\n               \
    \ maxCount = 17;\n            } else if(max == n && maxCount == 17) {\n      \
    \          maxCount = 18;\n            } else if(max == n && maxCount == 18) {\n\
    \                maxCount = 19;\n            } else if(max == n && maxCount ==\
    \ 19) {\n                maxCount = 20;\n            } else if(max == n && maxCount\
    \ == 20) {\n                maxCount = 21;\n            } else if(max == n &&\
    \ maxCount == 21) {\n                maxCount = 22;\n            } else if(max\
    \ == n && maxCount == 22) {\n                maxCount = 23;\n            } else\
    \ if(max == n && maxCount == 23) {\n                maxCount = 24;\n         \
    \   } else if(max == n && maxCount == 24) {\n                maxCount = 25;\n\
    \            } else if(max == n && maxCount == 25) {\n                maxCount\
    \ = 26;\n            } else if(max == n && maxCount == 26) {\n", "        var\
    \ max = numbers.Min();\n        var rollingMax = new List<long>();\n        for\
    \ (var i = numbers.Count - 1; i >= 0; i--) {\n            if (numbers[i] == max)\n\
    \                rollingMax.Add(numbers[i]);\n            else\n             \
    \   rollingMax.Add(max);\n            max = numbers[i];\n        }\n        return\
    \ rollingMax;", "        // Find the smallest number larger than any of our elements\n\
    \        long largest = numbers.Min();\n        List<long> rollingMaxes = new\
    \ List<long>();\n        while (numbers.Count > 0) {\n            long lastNumber\
    \ = numbers.Last();\n            if (largest < lastNumber) {\n               \
    \ // We found a larger number than we were looking for\n                // Add\
    \ the largest number to our rolling max\n                rollingMaxes.Add(largest);\n\
    \                // We found a new largest number\n                largest = lastNumber;\n\
    \            } else {\n                // We found a number smaller than our largest\
    \ number\n                // Remove the last element and add it to the rolling\
    \ max\n                rollingMaxes.Add(lastNumber);\n                // We found\
    \ a new smallest number\n                largest = lastNumber;\n            }\n\
    \            numbers.RemoveAt(numbers.Count - 1);\n        }\n        // Add the\
    \ largest number we were looking for\n        rollingMaxes.Add(largest);\n   \
    \     return rollingMaxes;", "        List<long> result = new List<long>();\n\
    \        RollingMax(result, numbers.First());\n        return result;", "    \
    \    List<long> result = new List<long>();\n        long maxValue = numbers.Min();\n\
    \        long lastMaxValue = maxValue;\n        long currentMaxValue = maxValue;\n\
    \        bool continueRolling = true;\n        while (continueRolling) {\n   \
    \         List<long> currentElement = new List<long>();\n            for (long\
    \ number = numbers.Count; number > 0; number--) {\n                long number\
    \ = numbers[number - 1];\n                if (number > lastMaxValue) {\n     \
    \               currentMaxValue = currentMaxValue + currentElement[currentElement.Count\
    \ - 1];\n                    currentElement.RemoveAt(currentElement.Count - 1);\n\
    \                }\n                currentElement.Add(number);\n            \
    \    if (number > maxValue) {\n                    maxValue = number;\n      \
    \              lastMaxValue = number;\n                }\n            }\n    \
    \        result.Add(currentMaxValue);\n            continueRolling = false;\n\
    \        }\n        return result;", "        HashSet<long> set = new HashSet<long>();\n\
    \        // Create a list of rolling maxima that starts with the largest element\
    \ in the input list\n        List<long> rollingMax = new List<long>();\n     \
    \   long max = 0;\n        int i = 0;\n        int rollingMaxIndex = 0;\n    \
    \    // Iterate over each element in the input list and compare with the current\
    \ rolling max\n        foreach (long element in numbers) {\n            if (set.Contains(element))\
    \ {\n                rollingMax.Add(max);\n                rollingMaxIndex++;\n\
    \            }\n            // Add the new rolling max to the list of rolling\
    \ maxima\n            if (set.Add(element)) {\n                max = element;\n\
    \                i++;\n            } else {\n                rollingMax.Add(max);\n\
    \                rollingMaxIndex++;\n            }\n        }\n        // Add\
    \ the final rolling max\n        rollingMax.Add(max);\n        // Return the rolling\
    \ maxima\n        return new List<long>(rollingMax);", "        Debug.Assert(numbers\
    \ != null);\n        Debug.Assert(numbers.Count > 0);\n        List<long> rollingMax\
    \ = new List<long>();\n        long rollingMaxIndex = numbers.Count - 1;\n   \
    \     // We use a fixed size array here for efficiency, because we know the max\
    \ number of rolling max\n        // numbers is constant.\n        long[] currentMax\
    \ = new long[numbers.Count];\n        currentMax[0] = 0;\n        // Reach the\
    \ max number of rolling max numbers at this moment\n        while (rollingMaxIndex\
    \ >= 0) {\n            // Generate new rolling max numbers for the next rolling\
    \ max index \n            for (int i = 0; i < currentMax.Length; i++) {\n    \
    \            long current = numbers[rollingMaxIndex--];\n                currentMax[i]\
    \ = Math.Max(currentMax[i], current);\n            }\n            // Push them\
    \ to the result array\n            foreach (long n in currentMax) {\n        \
    \        rollingMax.Add(n);\n            }\n            // Set current max array\
    \ to new rolling max numbers from now\n            currentMax = rollingMax;\n\
    \        }\n        return rollingMax;", "        List<long> answer = new List<long>();\n\
    \        long lastMax = numbers.Max();\n        long newMax = 0;\n        long\
    \ sum = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n            newMax\
    \ = numbers.ElementAt(i);\n            sum = 0;\n            while (sum != newMax\
    \ && newMax < lastMax) {\n                sum += newMax;\n                answer.Add(newMax);\n\
    \                newMax = sum - newMax;\n            }\n            lastMax =\
    \ newMax;\n        }\n        return answer;", "        var results = new List<long>();\n\
    \        var current = numbers.First();\n        var max = current;\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i] == current)\
    \ {\n                max = numbers[i];\n                results.Add(max);\n  \
    \          }\n            else {\n                var rollingMax = RollingMax(new\
    \ List<long>(results.Take(results.Count - i)));\n                max = rollingMax.Where(x\
    \ => x > max).First();\n                results.Add(max);\n            }\n   \
    \         current = numbers.ElementAt(i);\n        }\n        return results;",
  "        var rollingMax = new List<long>();\n        rollingMax.AddRange(numbers);\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            rollingMax[i]\
    \ = Math.Max(rollingMax[i], numbers[i]);\n        }\n        return rollingMax;",
  "        var max = new List<long>(numbers);\n        for (int i = numbers.Count\
    \ - 1; i >= 0; i--) {\n            numbers.RemoveAt(0);\n            for (int\
    \ j = 0; j < numbers.Count; j++) {\n                var current = numbers[j];\n\
    \                numbers.RemoveAt(j);\n                numbers.Insert(0, current);\n\
    \                if (numbers[j] > max[j]) {\n                    max[j] = numbers[j];\n\
    \                }\n            }\n        }\n        return max;", "        var\
    \ numberGroups = numbers.GroupBy(n => n / Math.Pow(2, n));\n        List<long>\
    \ result = new List<long>();\n        foreach (var g in numberGroups) {\n    \
    \        long maxValue = g.Max();\n            long nextMaxValue = maxValue +\
    \ 1;\n            result.AddRange(g.Select(n => n < nextMaxValue ? n : nextMaxValue));\n\
    \        }\n        return result;", "        int size = numbers.Count;\n    \
    \    int rollingMax = numbers.Max();\n        long rollingMaxElement = rollingMax;\n\
    \        List<long> rollingMaxElements = numbers.Where(x => x == rollingMax).ToList();\n\
    \        while (rollingMaxElements.Count != size) {\n            rollingMaxElement\
    \ = rollingMaxElements.Max();\n            rollingMaxElements.RemoveAll(x => x\
    \ == rollingMax);\n            rollingMaxElements.Add(rollingMaxElement);\n  \
    \      }\n        return rollingMaxElements;", "        List<long> result = new\
    \ List<long>();\n        long maxElement = numbers.Max();\n        result.Add(maxElement);\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            result.Add(Math.Max(maxElement,\
    \ numbers[i]));\n        }\n        return result;", "        var max = new List<long>();\n\
    \        for (int i = numbers.Count - 1; i > 0; i--) {\n            max.Add(numbers.Max());\n\
    \            numbers.Remove(numbers.Max());\n        }\n        return max;",
  "        var rollingMax = new List<long>();\n        var lastRollingMax = numbers.First();\n\
    \        var rollingMaxOffset = numbers.Count - 1;\n        rollingMax.Add(lastRollingMax);\n\
    \        rollingMaxOffset--;\n        var previousRollingMax = lastRollingMax;\n\
    \        while (true) {\n            if (rollingMaxOffset == 0) {\n          \
    \      rollingMax.Add(previousRollingMax);\n                break;\n         \
    \   }\n            var nextRollingMax = numbers[rollingMaxOffset];\n         \
    \   if (previousRollingMax < nextRollingMax) {\n                rollingMax.Add(nextRollingMax);\n\
    \                lastRollingMax = nextRollingMax;\n                previousRollingMax\
    \ = nextRollingMax;\n                rollingMaxOffset--;\n            } else {\n\
    \                previousRollingMax = nextRollingMax;\n                rollingMaxOffset--;\n\
    \            }\n        }\n        return rollingMax;", "        // Rolling maximum\
    \ element found until given moment in the sequence.\n        var maxElement =\
    \ numbers.First();\n        var result = new List<long>(numbers.Count);\n    \
    \    numbers.ForEach(n => {\n            if (n > maxElement) {\n             \
    \   // Keep rolling until current time stamp is equal to the timestamp\n     \
    \           // of given element.\n                var lastElement = result;\n\
    \                result.Clear();\n                result.Add(n);\n           \
    \     numbers.Where(x => x == maxElement).ToList().ForEach(n => {\n          \
    \          result.Add(n);\n                    if (lastElement.Count == 1)\n \
    \                       result.Add(lastElement[0]);\n                    else\
    \ if (lastElement.Count > 1)\n                        result.Add(lastElement[lastElement.Count\
    \ - 1]);\n                });\n            }\n            else\n             \
    \   result.Add(n);\n            maxElement = n;\n        });\n        return result;",
  "        HashSet<long> max = new HashSet<long>();\n        HashSet<long> temp =\
    \ new HashSet<long>();\n        for (int i = numbers.Count - 1; i >= 0; i--) {\n\
    \            long sum = numbers.Skip(i).Take(numbers.Count - i).Sum();\n     \
    \       if (!max.Contains(sum)) {\n                max.Add(sum);\n           \
    \     temp.Add(sum);\n            }\n        }\n        List<long> result = new\
    \ List<long>();\n        foreach (long s in temp) {\n            if (result.Count\
    \ > 0 || s == numbers.First()) {\n                result.Add(s);\n           \
    \ }\n        }\n        return result;", "        // Use the same list for rolling\
    \ max results as for input\n        List<long> maxList = new List<long>();\n \
    \       numbers.Remove(numbers.Max());\n        numbers.Remove(numbers.Min());\n\
    \        foreach (long number in numbers) {\n            List<long> rollingMaxList\
    \ = new List<long>();\n            while (number > 1) {\n                rollingMaxList.Add(number\
    \ % 2);\n                number /= 2;\n            }\n            maxList.AddRange(rollingMaxList);\n\
    \        }\n        return maxList;", "        var rollingMax = new List<long>();\n\
    \        var rollingMaxValue = rollingMax.Count + 1;\n\n        foreach (var number\
    \ in numbers) {\n            if (rollingMaxValue > rollingMax.Count) {\n     \
    \           rollingMax.Add(number);\n            } else {\n                var\
    \ foundNumbers = numbers.Take(rollingMaxValue).ToList();\n                foundNumbers.Add(number);\n\
    \                var index = foundNumbers.FindIndex(c => c > number);\n      \
    \          if (index >= 0) {\n                    rollingMax[rollingMaxValue +\
    \ index - 1] = number;\n                }\n            }\n            rollingMaxValue++;\n\
    \        }\n\n        return rollingMax;", "        long[] vals = new long[numbers.Count];\n\
    \        for (int i = 0; i < vals.Length; i++) {\n            vals[i] = numbers[i];\n\
    \        }\n        long[] maxs = new long[vals.Length];\n        int i = 0;\n\
    \        while (vals.Length > i) {\n            int j = 0;\n            while\
    \ (j < vals.Length && vals[j] > vals[i]) {\n                maxs[i] = maxs[i]\
    \ > vals[j] ? maxs[i] : vals[j];\n                j++;\n            }\n      \
    \      if (j == vals.Length) {\n                maxs[i] = vals[i];\n         \
    \   }\n            i++;\n        }\n        return new List<long>(maxs);", " \
    \       List<long> res = new List<long>();\n        numbers.ForEach(n => {\n \
    \           res.AddRange(numbers.Where(i => i <= n).Take(numbers.Where(i => i\
    \ >= n).Count()).ToList());\n        });\n        return res;", "        // Check\
    \ argument\n        if (numbers == null || numbers.Count <= 0) return null;\n\n\
    \        // Initialize maxCount\n        long maxCount = 1;\n\n        // Initialize\
    \ result list\n        List<long> result = new List<long>();\n\n        // Iterate\
    \ numbers\n        foreach (long number in numbers) {\n\n            // Roll maxCount\n\
    \            long rollMaxCount = maxCount;\n\n            // Iterate until rolling\
    \ maxCount reached number \n            while (number > rollMaxCount) {\n    \
    \            // Get previous maxCount\n                rollMaxCount = result.LastOrDefault();\n\
    \n                // Add number\n                result.Add(rollMaxCount);\n \
    \           }\n\n            // Update maxCount\n            maxCount = rollMaxCount;\n\
    \        }\n\n        // Return the result\n        return result;", "       \
    \ long rollingMax = 0;\n        long lastElement = numbers.Last();\n        foreach\
    \ (long element in numbers) {\n            if (element > rollingMax) {\n     \
    \           rollingMax = element;\n            }\n            else if (element\
    \ == lastElement) {\n                rollingMax++;\n            }\n        }\n\
    \        return new List<long>() { rollingMax };", "        var result = new List<long>();\n\
    \        numbers.ToList().ForEach(x => result.Add(Math.Max(x, result.Last())));\n\
    \        return result;", "        List<long> maxes = new List<long>();\n    \
    \    numbers.Reverse();\n        long current = numbers.First();\n        long\
    \ maxValue = current;\n        numbers.Remove(current);\n        numbers.Reverse();\n\
    \        while (numbers.Any()) {\n            if (numbers.First() > maxValue)\
    \ {\n                maxValue = numbers.First();\n            }\n            current\
    \ = (current * 2L) + numbers.First();\n            numbers.Remove(numbers.First());\n\
    \            numbers.Add(current);\n            numbers.Reverse();\n         \
    \   if (numbers.First() > maxValue)\n                maxValue = numbers.First();\n\
    \        }\n        maxes.Add(maxValue);\n        return maxes;", "        //\
    \ Initialize max to smallest number in collection\n        long max = numbers.Min();\n\
    \        // For each number in the collection, compare it to the current max\n\
    \        foreach (long number in numbers) {\n            if (number > max) max\
    \ = number;\n        }\n        // Add max to result\n        List<long> result\
    \ = new List<long>();\n        result.Add(max);\n        // For each number in\
    \ the collection, compare it to the current max\n        foreach (long number\
    \ in numbers) {\n            if (number > max) {\n                // If the current\
    \ number is the same as current max...\n                if (number == max) {\n\
    \                    // Remove the max from the rolling result\n             \
    \       List<long> rest = result.RemoveAt(0);\n                    // Add all\
    \ remaining numbers to the rolling result\n                    rest = result.Concat(new\
    \ List<long>(numbers)).ToList();\n                    // Append the remaining\
    \ rolling result to the final result\n                    result.AddRange(rest);\n\
    \                    // Append the max to the rolling result\n               \
    \     result.Add(number);\n                }\n                // If the current\
    \ number is larger than current max, replace it with the max number\n        \
    \        else {\n                    result.Add(number);\n                }\n\
    \            }\n        }\n        return result;", "        // Sort given list\
    \ first (so that it could be easily processed using recursion)\n        numbers.Sort();\n\
    \n        // Current index of rolling max (rolling max is found at index 0)\n\
    \        int rollingMaxIndex = 0;\n        // Current rolling max\n        long\
    \ rollingMaxValue = numbers[0];\n        // Current list of rolling max\n    \
    \    List<long> rollingMax = new List<long>();\n\n        // Iterate through all\
    \ remaining numbers\n        for (int i = 1; i < numbers.Count; i++) {\n     \
    \       // New rolling max found\n            if (numbers[i] > rollingMaxValue)\
    \ {\n                // Update rolling max value and index\n                rollingMaxValue\
    \ = numbers[i];\n                rollingMaxIndex = i;\n            }\n       \
    \     // Update rolling max list\n            rollingMax.Add(rollingMaxValue);\n\
    \        }\n\n        // Return rolling max list\n        return rollingMax;",
  "        List<long> max = new List<long>();\n        long rollingMax = -1;\n\n \
    \       // We start by considering all numbers and recording the largest rolling\
    \ maximum found\n        foreach (long number in numbers) {\n            if (number\
    \ > rollingMax) {\n                rollingMax = number;\n                max.Clear();\n\
    \                max.Add(number);\n            } else if (number == rollingMax)\
    \ {\n                max.Add(number);\n            }\n        }\n\n        //\
    \ Now we consider every possible sequence of numbers and keep adding numbers to\
    \ the\n        // current rolling maximum until it reaches the end or the sequence\
    \ is exhausted.\n        List<long> sequence = new List<long>();\n\n        for\
    \ (long i = 0; i < numbers.Count; i++) {\n            sequence.add(numbers[i]);\n\
    \n            for (int j = i + 1; j < numbers.Count; j++) {\n                //\
    \ The current number could go from i to j, so we check that\n                if\
    \ (numbers[j] >= sequence[sequence.Count - 1]) {\n                    sequence[j]\
    \ = sequence[sequence.Count - 1];\n                } else {\n                \
    \    sequence[j] += sequence[i];\n                    if (j == numbers.Count -\
    \ 1) {\n                        // If the last number reaches the end, add it\
    \ to the list of rolling max\n                        max.Add(sequence[j]);\n\
    \                    } else {\n                        sequence[j + 1] = sequence[j];\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  return max;", "        if (numbers == null || numbers.Count <= 0) {\n     \
    \       return new List<long>();\n        }\n        // Keep a rolling max of\
    \ first number\n        long rollingMax = numbers.First();\n        // Keep a\
    \ count of last element seen\n        long lastElementSeen = numbers[0];\n   \
    \     // Track how many rolling maxes we have\n        long numRollingMax = 0;\n\
    \        // Keep a list of all rolling maxes\n        List<long> rollingMaxes\
    \ = new List<long>();\n        foreach (long number in numbers.Skip(1)) {\n  \
    \          if (number > rollingMax) {\n                numRollingMax++;\n    \
    \            rollingMax = number;\n            }\n            if (number == lastElementSeen)\
    \ {\n                rollingMaxes.Add(rollingMax);\n            }\n          \
    \  lastElementSeen = number;\n        }\n        return rollingMaxes;", "    \
    \    if (numbers.Count == 0) {\n            return new List<long>();\n       \
    \ }\n\n        // Store current max number in result and move to next number\n\
    \        var result = new List<long>();\n        long curMax = numbers[0];\n \
    \       foreach (var n in numbers.Skip(1)) {\n            long newMax = n;\n \
    \           while (newMax < curMax) {\n                result.Add(curMax);\n \
    \               newMax = result.LastOrDefault();\n            }\n            curMax\
    \ = newMax;\n        }\n\n        return result;", "        List<long> rollingMaxElements\
    \ = new List<long>();\n        long previousMax = 0;\n        foreach (long number\
    \ in numbers) {\n            rollingMaxElements.Add(Math.Max(previousMax, number));\n\
    \            previousMax = number;\n        }\n        return rollingMaxElements;",
  "        List<long> maxes = new List<long>();\n        List<long> rollingMaxes =\
    \ new List<long>();\n        int maxNumber = 0;\n        bool foundFirst = false;\n\
    \n        int i = 0;\n        while (i<numbers.Count) {\n            int number\
    \ = numbers[i];\n            if (number > maxNumber) {\n                rollingMaxes.Clear();\n\
    \                maxNumber = number;\n                rollingMaxes.Add(number);\n\
    \                if (foundFirst == false)\n                    maxes.Add(number);\n\
    \                foundFirst = true;\n            } else {\n                rollingMaxes.Add(number);\n\
    \                if (foundFirst == false)\n                    maxes.Add(number);\n\
    \            }\n            i++;\n        }\n        return rollingMaxes;", " \
    \       if (numbers.Count < 2) {\n            return numbers.ToList();\n     \
    \   }\n\n        // We start with 0\n        int maxIndex = -1;\n        long\
    \ maxValue = numbers[0];\n\n        // We will iterate over the numbers, until\
    \ we find one which is bigger than our current\n        // max value. As soon\
    \ as we find one bigger, we update our max value. Also, we update our\n      \
    \  // index where we found the biggest number\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            long currentValue = numbers[i];\n            if (currentValue\
    \ > maxValue) {\n                maxIndex = i;\n                maxValue = currentValue;\n\
    \            }\n        }\n\n        // If we have a bigger number, we start over\
    \ from the max index\n        while (maxIndex + 1 < numbers.Count) {\n       \
    \     numbers.RemoveAt(maxIndex + 1);\n            maxIndex++;\n            maxValue\
    \ = numbers[maxIndex];\n\n            // If we remove the last element from the\
    \ list, we check if it is the biggest one we found\n            // and if yes,\
    \ we break the loop and return our list of rolling max numbers.\n            if\
    \ (maxIndex == numbers.Count - 1) {\n                if (maxValue > maxValue)\
    \ {\n                    break;\n                } else {\n                  \
    \  numbers.RemoveAt(maxIndex);\n                }\n            }\n        }\n\n\
    \        return numbers.ToList();", "        List<long> rollingMax = new List<long>(numbers.Count);\n\
    \n        for (int i = 0; i < numbers.Count; i++) {\n            rollingMax.Add(numbers.Max()\
    \ - numbers[i]);\n        }\n\n        return rollingMax;", "        // Initialize\n\
    \        List<long> maxElement = new List<long>();\n\n        // Find the first\
    \ max number \n        long maxValue = numbers.First();\n        foreach (var\
    \ num in numbers) {\n            if (num > maxValue) {\n                maxValue\
    \ = num;\n            }\n        }\n        maxElement.Add(maxValue);\n\n    \
    \    // Find the last max number\n        long rollingMaxValue = maxElement;\n\
    \        for (long i = numbers.Count; i > 1; i--) {\n            rollingMaxValue\
    \ = maxElement.Take(i).Aggregate(rollingMaxValue, (current, num) => Math.Max(current,\
    \ num));\n        }\n        maxElement.Add(rollingMaxValue);\n\n        // Return\
    \ the result\n        return maxElement;", "        if (numbers.Count < 2) return\
    \ numbers;\n\n        long currentMax = numbers.Max();\n        long currentMaxIndex\
    \ = numbers.IndexOf(currentMax);\n        List<long> rollingMaxes = new List<long>();\n\
    \n        for (int i = numbers.Count - 1; i > 1; i--) {\n            long rollingMaxIndex\
    \ = currentMaxIndex - i;\n            if (rollingMaxIndex < 0) continue;\n\n \
    \           long rollingMax = numbers[rollingMaxIndex];\n            long currentMax\
    \ = numbers[currentMaxIndex];\n\n            if (rollingMax < currentMax) {\n\
    \                rollingMaxes.Add(rollingMax);\n                numbers[rollingMaxIndex]\
    \ = currentMax;\n                currentMaxIndex = rollingMaxIndex;\n        \
    \        currentMax = numbers[currentMaxIndex];\n            }\n        }\n  \
    \      rollingMaxes.Add(currentMax);\n        return rollingMaxes;", "       \
    \ List<long> rollingMax = new List<long>();\n        long maxRolling = 0;\n  \
    \      long currentNumber = 0;\n        foreach (long number in numbers) {\n \
    \           currentNumber = number;\n            rollingMax.Clear();\n       \
    \     while (currentNumber > 0) {\n                rollingMax.Add(currentNumber);\n\
    \                currentNumber -= (currentNumber % 2 == 0 ? 1 : 2);\n        \
    \    }\n            rollingMax = rollingMax.OrderBy(i => i).ToList();\n      \
    \      if (rollingMax.Count == 1) maxRolling = 0;\n            else if (rollingMax.Count\
    \ > 1) maxRolling = rollingMax.Max();\n        }\n        rollingMax = rollingMax.OrderBy(i\
    \ => i).ToList();\n        return rollingMax;", "        List<long> result = new\
    \ List<long>();\n        numbers.Sort();\n        foreach (long n in numbers)\
    \ {\n            result.Add(n);\n            result.RemoveAt(0);\n        }\n\
    \        return result;", "        Debug.Assert(numbers.Count != 0);\n       \
    \ // Store each element in \"rollingMaxElements\".\n        // For each number,\
    \ we record the max number found in the rolling window.\n        var rollingMaxElements\
    \ = new List<long>();\n\n        // Loop through numbers to record rolling max\
    \ element found.\n        // We assume that the numbers are given in the ascending\
    \ order and will not\n        // contain duplicates.\n        long rollingMax\
    \ = numbers.First();\n        long currentMax = rollingMax;\n        long currentMaxIndex\
    \ = -1;\n\n        // Loop through numbers again to update \"rollingMaxElements\"\
    .\n        for (int i = 1; i < numbers.Count; i++) {\n            long current\
    \ = numbers[i];\n\n            // If current element is the same as rolling max\
    \ element, then we have\n            // found a new max element and record the\
    \ index of \"rollingMax\".\n            if (current == rollingMax) {\n       \
    \         if (currentMaxIndex == -1)\n                    currentMaxIndex = i;\n\
    \                else {\n                    // We have found two max element\
    \ in a row, so we should stop recording.\n                    break;\n       \
    \         }\n            } else {\n                // If current element is not\
    \ the same as rolling max element, then we have\n                // found a new\
    \ max element and record its index. We need to check the\n                // next\
    \ element if it is smaller than current element. If it is smaller, then\n    \
    \            // the current element becomes the new max element and we record\
    \ the new index\n                // of \"rollingMax\".\n                if (current\
    \ > rollingMax) {\n                    if (currentMaxIndex == -1) {\n        \
    \                currentMaxIndex = i;\n                        currentMax = current;\n\
    \                    } else {\n                        // We have found two max\
    \ element in a row, so we should stop recording.\n                        break;\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  // We have found a rolling max element. Let's return it.\n        if (currentMaxIndex\
    \ != -1) {\n            rollingMaxElements.Add(currentMax);\n            rollingMaxElements.AddRange(numbers.Take(currentMaxIndex).Select(x\
    \ => (long)x));\n        }\n        return rollingMaxElements;", "        var\
    \ result = new List<long>(new long[0]);\n        var maxValue = numbers.Max();\n\
    \        var maxIndex = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n\
    \            if (maxValue == numbers[i]) {\n                result.Add(maxValue);\n\
    \                maxIndex++;\n            } else {\n                maxValue =\
    \ numbers[i];\n                maxIndex = i;\n            }\n        }\n     \
    \   if (maxIndex > 0)\n            result.AddRange(numbers.GetRange(maxIndex +\
    \ 1, numbers.Count - maxIndex - 1));\n        return result;", "        if (numbers\
    \ == null || numbers.Count == 0) return new List<long>();\n        List<long>\
    \ max = numbers.Take(numbers.Count - 1).ToList();\n        long maxValue = numbers.ElementAt(numbers.Count\
    \ - 1);\n        long prevValue = numbers.ElementAt(0);\n        int count = 1;\n\
    \        foreach (long n in numbers.Skip(1)) {\n            if (n > maxValue)\
    \ {\n                maxValue = n;\n                max = new List<long>(max);\n\
    \            }\n            if (n == prevValue) count++;\n            else { //\
    \ new max\n                max.Add(count);\n                count = 1;\n     \
    \       }\n            prevValue = n;\n        }\n        max.Add(count); // last\
    \ max\n        return max;", "        var maxes = new List<long>();\n        var\
    \ maxIndex = 0;\n        var currentMax = 0;\n        var currentMaxIndex = 0;\n\
    \        foreach (var i in numbers) {\n            if (i == currentMax) {\n  \
    \              maxIndex += 1;\n                maxes.Add(currentMax);\n      \
    \      } else if (maxIndex < currentMaxIndex) {\n                currentMax =\
    \ maxes.Last();\n                currentMaxIndex = maxes.Count - 1;\n        \
    \    }\n            currentMax = i;\n            currentMaxIndex = maxIndex;\n\
    \        }\n        return maxes;", "        long maxNumber = numbers.Max();\n\
    \        long sumOfAllElements = numbers.Sum();\n        if (maxNumber == sumOfAllElements)\n\
    \            return new List<long>();\n        List<long> result = new List<long>();\n\
    \        List<long> currentElements = new List<long>(new long[] { maxNumber });\n\
    \        long currentElementSum = maxNumber;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            long currentElementNumber = currentElements.Last();\n  \
    \          currentElements.Add(numbers[i]);\n            long currentElementSumOfElements\
    \ = currentElements.Sum();\n            if (currentElementSumOfElements > maxNumber)\
    \ {\n                result.Add(currentElementNumber);\n                if (currentElementSum\
    \ == currentElementSumOfElements)\n                    currentElements.Clear();\n\
    \                currentElementSum = currentElementSumOfElements;\n          \
    \  }\n            currentElements.Add(numbers[i]);\n        }\n        return\
    \ result;", "        int maxIndex = -1;\n        int rollingMax = numbers.Max();\n\
    \        int rollingIndex = 0;\n        List<long> list = new List<long>();\n\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ <= rollingMax && maxIndex == -1)\n                maxIndex = i;\n\n        \
    \    if (rollingMax <= numbers[i] && maxIndex != -1)\n                list.Add(numbers[maxIndex]);\n\
    \            else if (maxIndex != -1) {\n                maxIndex = -1;\n    \
    \            rollingMax = numbers[maxIndex];\n                rollingIndex = 0;\n\
    \            }\n            rollingMax = numbers[rollingIndex];\n            rollingIndex++;\n\
    \        }\n\n        return list;", "        List<long> answer = new List<long>();\n\
    \        numbers.RemoveAll(x => x == numbers.Min());\n        answer.Add(numbers.Max());\n\
    \        RollingMax(numbers, answer, numbers.Min());\n        return answer;",
  "        // Find length of list\n        int listSize = numbers.Count;\n\n     \
    \   // Initialize maximum to first value\n        long maximum = numbers.First();\n\
    \n        // Initialize result list\n        List<long> result = new List<long>();\n\
    \n        // For each value in the current list add it to the list\n        //\
    \ of rolling maximum elements found until the current time\n        for (int i\
    \ = 1; i < listSize; i++) {\n            // The current maximum of all rolling\
    \ elements\n            long rollingMax = maximum;\n\n            // For each\
    \ element in the list, check if it is a maximum\n            // and if it is,\
    \ set it to the current rolling maximum.\n            for (int j = 0; j < i; j++)\
    \ {\n                if (numbers.ElementAt(j) > maximum)\n                   \
    \ maximum = numbers.ElementAt(j);\n            }\n\n            // If there is\
    \ a rolling maximum at this point, add it\n            // to the result list.\n\
    \            if (maximum > rollingMax)\n                result.Add(maximum);\n\
    \        }\n\n        return result;", "        Debug.Assert(numbers.Count > 0);\n\
    \        List<long> result = new List<long>();\n        long max = 0;\n      \
    \  long current = 0;\n        foreach (long n in numbers) {\n            current\
    \ = n;\n            max = Math.Max(max, current);\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> rollingMax = new List<long>();\n\
    \        long rollingMaxValue = numbers.Last();\n        foreach (long number\
    \ in numbers) {\n            if (number > rollingMaxValue) {\n               \
    \ rollingMax.Add(number);\n            } else if (number == rollingMaxValue) {\n\
    \                rollingMax.Add(number);\n            } else {\n             \
    \   if (rollingMaxValue - number >= rollingMax.Last() - number) {\n          \
    \          rollingMax.Add(rollingMaxValue);\n                    rollingMaxValue\
    \ = number;\n                } else {\n                    rollingMaxValue = number;\n\
    \                }\n            }\n        }\n        return rollingMax;", " \
    \       List<long> maxes = new List<long>();\n        long rollingMax = numbers.First();\n\
    \        foreach (long x in numbers) {\n            rollingMax = Math.Max(rollingMax,\
    \ x);\n            maxes.Add(rollingMax);\n        }\n        return maxes;",
  "        // initialize result list\n        var results = new List<long>();\n  \
    \      // initialize rolling max variables\n        var max = new long();\n  \
    \      var curr = new long();\n        // initialize current index variable\n\
    \        var index = 0;\n        // initialize number of rolling max variables\
    \ to 1\n        var num = new long();\n        // initialize number of rolling\
    \ max variables larger than number of numbers in list\n        var larger = new\
    \ long();\n        // initialize number of rolling max variables smaller than\
    \ number of numbers in list\n        var smaller = new long();\n        // loop\
    \ through numbers list\n        foreach (long n in numbers) {\n            //\
    \ update current index to point to next number in list\n            index++;\n\
    \            // initialize max value\n            max = (n > max) ? n : max;\n\
    \            // reset rolling max variables\n            num = 1;\n          \
    \  larger = 0;\n            smaller = 0;\n            // loop through rolling\
    \ max variables\n            for (int i = 0; i < num; i++) {\n               \
    \ // check if max element is smaller than current number in list\n           \
    \     if (max < numbers[index]) {\n                    // increment number of\
    \ rolling max variables greater than current number in list\n                \
    \    larger++;\n                }\n                // check if max element is\
    \ larger than current number in list\n                else if (max > numbers[index])\
    \ {\n                    // increment number of rolling max variables smaller\
    \ than current number in list\n                    smaller++;\n              \
    \  }\n                // check if max element is equal to current number in list\n\
    \                else if (max == numbers[index]) {\n                    // increment\
    \ number of rolling max variables that equal current number in list\n        \
    \            num++;\n                }\n            }\n            // if number\
    \ of rolling max variables are equal to number of numbers in list\n          \
    \  if (num == numbers.Count) {\n                // add max value to the list\n\
    \                results.Add(max);\n                // reset max value\n     \
    \           max = 0;\n            }\n            // if number of rolling max variables\
    \ are greater than number of numbers in list\n            else if (num > numbers.Count)\
    \ {\n                // if the number of rolling max variables are greater than\
    \ or equal to number of numbers in list\n                if (larger == larger)\
    \ {\n                    // add max value to the list\n                    results.Add(max);\n\
    \                    // reset max value\n                    max = 0;\n      \
    \          }\n                // if the number of rolling max variables are greater\
    \ than or equal to number of numbers in list\n                else {\n       \
    \             // add max value to the list\n                    results.Add(numbers[index]);\n\
    \                    // reset max value\n                    max = numbers[index];\n\
    \                }\n            }\n            // if number of rolling max variables\
    \ are smaller than number of numbers in list\n            else if (num < numbers.Count)\
    \ {\n                // if the number of rolling max variables are greater than\
    \ or equal to number of numbers in list\n                if (larger == smaller)\
    \ {\n                    // add max value to the list\n                    results.Add(max);\n\
    \                    // reset max value\n                    ", "        List<long>\
    \ list = new List<long>();\n        long max = 0;\n        long currentSum = 0;\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (i == numbers.Count\
    \ - 1) {\n                // if last one just add current to list \n         \
    \       list.Add(currentSum);\n            } else if (max < numbers[i]) {\n  \
    \              // If current element bigger than previous max add it to list \n\
    \                max = numbers[i];\n            } else if (max > numbers[i]) {\n\
    \                // If current element smaller than previous max add it to list\n\
    \                max = numbers[i];\n                list.Add(max);\n         \
    \       currentSum = max;\n            }\n        }\n        return list;", " \
    \       long rollingMax = numbers.Max();\n        long rollingMaxCounter = 0;\n\
    \        List<long> maxList = new List<long>();\n        foreach (long element\
    \ in numbers) {\n            rollingMaxCounter++;\n            if (rollingMaxCounter\
    \ >= rollingMax) {\n                maxList.Add(element);\n                rollingMaxCounter\
    \ = 1;\n            } else {\n                rollingMaxCounter++;\n         \
    \   }\n        }\n        return maxList;", "        if (numbers.Count == 0)\n\
    \            return null;\n        long max = numbers[0];\n        List<long>\
    \ maxes = new List<long>();\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            if (numbers[i] > max)\n                max = numbers[i];\n      \
    \      if (max <= numbers.Count)\n                break;\n            else\n \
    \               maxes.Add(max);\n        }\n        return maxes;", "        long\
    \ maxValue = 0L;\n        long currentSum = 0L;\n        List<long> result = new\
    \ List<long>();\n        \n        numbers.ForEach(number => { // For each element\
    \ in the list, compute the rolling maximum value\n            currentSum += number;\n\
    \            if (currentSum > maxValue) { // if the current sum is greater than\
    \ the rolling maximum, then\n                // update the rolling maximum\n \
    \               maxValue = currentSum;\n            }\n        });\n        result.Add(maxValue);\
    \ // add the rolling maximum to the final result\n        \n        return result;",
  "        var max = new List<long>();\n        var maxIndex = 0;\n        var maxValue\
    \ = numbers.Max();\n        foreach (var n in numbers) {\n            max.Add(Math.Max(n,\
    \ maxValue));\n            maxIndex++;\n            if (maxIndex > numbers.Count\
    \ - 1) {\n                break;\n            }\n            else if (maxIndex\
    \ == numbers.Count - 1 && maxValue > numbers[maxIndex]) {\n                maxValue\
    \ = Math.Max(n, maxValue);\n                maxIndex++;\n            }\n     \
    \       else if (maxIndex == numbers.Count - 1 && maxValue == numbers[maxIndex]\
    \ && n > maxValue) {\n                break;\n            }\n        }\n     \
    \   return max;", "        Debug.Assert(numbers != null && numbers.Count > 0);\n\
    \        List<long> result = new List<long>();\n        if (numbers.Count == 1)\
    \ return numbers.ToList();\n        var maxNumber = numbers.Max();\n        foreach\
    \ (var number in numbers.Skip(1))\n            if (number > maxNumber) {\n   \
    \             maxNumber = number;\n                result.Add(maxNumber);\n  \
    \          }\n        else result.Add(maxNumber);\n        return result;", " \
    \       // Calculate first rolling maximum\n        var maximum = numbers.LastOrDefault();\n\
    \        // Keep rolling until the last number or the maximum number has been\
    \ reached\n        while (numbers.Any()) {\n            // Compute the maximum\
    \ of each previous element and the current element\n            var currentMax\
    \ = numbers.TakeWhile((i) => i <= maximum).Max();\n            // Add the current\
    \ maximum number to the list of rolling maximum numbers\n            maximum =\
    \ currentMax;\n            // Remove the element from the list\n            numbers\
    \ = numbers.Skip(1).ToList();\n        }\n        // Return the list of rolling\
    \ maximum numbers\n        return new List<long>() { maximum };", "        long\
    \ max = new List<long>(numbers).Max();\n        List<long> result = new List<long>();\n\
    \        int currentIndex = 0;\n        int sum = 1;\n        while (currentIndex\
    \ < numbers.Count && currentIndex + 1 < numbers.Count) {\n            if (sum\
    \ > numbers[currentIndex]) {\n                sum += numbers[currentIndex];\n\
    \                result.Add(sum);\n            } else {\n                currentIndex++;\n\
    \                sum += numbers[currentIndex];\n            }\n        }\n   \
    \     result.Add(max);\n        return result;", "        List<long> rollingMax\
    \ = new List<long>();\n\n        // First we find the rolling max\n        long\
    \ rollingMaxNumber = 0;\n        bool found = false;\n        bool isRollingMax\
    \ = false;\n        for (int i = 0; i < numbers.Count; i++) {\n            if\
    \ (numbers[i] >= rollingMaxNumber) {\n                found = true;\n        \
    \        isRollingMax = true;\n                rollingMaxNumber = numbers[i];\n\
    \            } else if (numbers[i] == rollingMaxNumber && !isRollingMax) {\n \
    \               rollingMax.Add(numbers[i]);\n                rollingMaxNumber\
    \ = numbers[i];\n                found = true;\n                isRollingMax =\
    \ true;\n            } else if (numbers[i] == rollingMaxNumber) {\n          \
    \      rollingMax.Add(numbers[i]);\n                rollingMaxNumber = numbers[i];\n\
    \                found = true;\n                isRollingMax = true;\n       \
    \     } else {\n                rollingMaxNumber = numbers[i];\n             \
    \   found = false;\n                isRollingMax = false;\n            }\n   \
    \     }\n\n        // Now we add the last number if it's still a rolling max\n\
    \        if (isRollingMax) {\n            rollingMax.Add(rollingMaxNumber);\n\
    \        }\n\n        return rollingMax;", "        List<long> max = new List<long>();\n\
    \        long maxElement = numbers.Max();\n        long currentMaxElement = maxElement;\n\
    \        foreach (long n in numbers) {\n            if (n > maxElement) {\n  \
    \              max.Add(currentMaxElement);\n                currentMaxElement\
    \ = maxElement;\n            }\n            currentMaxElement = n;\n        }\n\
    \        max.Add(currentMaxElement);\n        return max;", "        // Initialize\
    \ max to the first number\n        var max = numbers.First();\n        // Initialize\
    \ an accumulator to 0\n        var accumulator = 0;\n        // Initialize an\
    \ array to store rolling max values\n        var rollingMax = new List<long>();\n\
    \        // Roll over numbers and add them to the rolling max list\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            // Accumulator\n        \
    \    accumulator += numbers[i];\n            // If this number is the bigger than\
    \ the max, set it as the max\n            if (accumulator >= max) {\n        \
    \        max = accumulator;\n            }\n            // If the number is the\
    \ bigger than the max and we are still in the same rolling max list\n        \
    \    // Add this number to the list\n            else if (numbers.Skip(i).TakeWhile(x\
    \ => accumulator < x).Count() > 0) {\n                rollingMax.Add(max);\n \
    \               max = accumulator;\n            }\n            // If the number\
    \ is not the bigger than the max, remove it from the list\n            else {\n\
    \                rollingMax.Add(numbers.Skip(i).TakeWhile(x => accumulator < x).First());\n\
    \            }\n        }\n        // If the last number in the list is the bigger\
    \ than the max, add it to the list\n        if (accumulator > max) {\n       \
    \     rollingMax.Add(max);\n        }\n        // Return the list\n        return\
    \ rollingMax;", "        // The max seen so far is in position 0\n        long\
    \ max = numbers.ElementAt(0);\n        // Rolling maxes are all equal to their\
    \ greatest value\n        List<long> rollingMaxes = new List<long>();\n      \
    \  rollingMaxes.Add(max);\n        // Find the next max that isn't smaller than\
    \ the current max\n        for (int i = 1; i < numbers.Count; i++) {\n       \
    \     if (max < numbers.ElementAt(i)) {\n                // The current max is\
    \ larger than all numbers already seen\n                max = numbers.ElementAt(i);\n\
    \                // The next max is larger than the current max\n            \
    \    rollingMaxes.Add(max);\n            } else {\n                // The current\
    \ max is smaller than all numbers already seen, continue searching\n         \
    \   }\n        }\n        return rollingMaxes;", "        // Find the largest\
    \ number in the given sequence\n        long maxNumber = 0;\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            if (numbers[i] > maxNumber) {\n\
    \                maxNumber = numbers[i];\n            }\n        }\n        //\
    \ Initialize a list to store all rolling maximums\n        List<long> rollingMax\
    \ = new List<long>();\n        // If current number is larger than all previous\
    \ ones, add it to rolling list\n        if (maxNumber < numbers.First()) {\n \
    \           rollingMax.Add(maxNumber);\n        }\n        // Starting from the\
    \ second number, add the rolling maximum\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            if (numbers[i] > maxNumber) {\n                rollingMax.Add(maxNumber);\n\
    \            }\n            // Add current number to rolling list, if larger than\
    \ current rolling maximum\n            if (numbers[i] > rollingMax.Last()) {\n\
    \                rollingMax.Add(numbers[i]);\n            }\n        }\n     \
    \   return rollingMax;", "        if (numbers == null || numbers.Count == 0) {\n\
    \            return new List<long>();\n        }\n        IEnumerator<long> enumerator\
    \ = numbers.GetEnumerator();\n        long previous = 0, result = 0;\n       \
    \ while (enumerator.MoveNext()) {\n            previous = result;\n          \
    \  result = Math.Max(result, enumerator.Current);\n        }\n        return new\
    \ List<long> {previous};", "        var max = 0;\n        var rollingMax = new\
    \ List<long>(numbers);\n        for (int i = 0; i < numbers.Count; i++) {\n  \
    \          var m = numbers[i];\n            while (m > max) {\n              \
    \  var maxValue = rollingMax[rollingMax.Count - 1];\n                rollingMax.RemoveAt(rollingMax.Count\
    \ - 1);\n                rollingMax.Add(maxValue);\n            }\n          \
    \  max = m;\n        }\n        return rollingMax;", "        var maxList = new\
    \ List<long>();\n        List<long> rolling = new List<long>();\n        foreach\
    \ (var number in numbers) {\n            rolling.Add(number);\n            while\
    \ (rolling.Count > maxList.Count) {\n                maxList.Add(rolling.Max());\n\
    \                rolling.Remove(rolling.Max());\n            }\n        }\n  \
    \      return maxList;", "        List<long> rollingMax = new List<long>();\n\
    \        var rollingMaxSoFar = 0;\n        long maxSoFar = numbers.First();\n\n\
    \        long currentSum = 0;\n        var currentSumSoFar = 0;\n\n        foreach\
    \ (long number in numbers) {\n            currentSum += number;\n            currentSumSoFar\
    \ += currentSum;\n            if (rollingMaxSoFar >= maxSoFar) {\n           \
    \     rollingMax.Add(maxSoFar);\n            } else if (currentSumSoFar > maxSoFar)\
    \ {\n                rollingMax.Add(maxSoFar);\n                rollingMaxSoFar\
    \ = currentSumSoFar;\n                maxSoFar = currentSum;\n            }\n\
    \        }\n        rollingMax.Add(maxSoFar);\n        return rollingMax;", " \
    \       // TODO: Implement this function\n        return null;", "        if (numbers.Count\
    \ <= 0) {\n            return numbers;\n        }\n\n        List<long> max =\
    \ new List<long>();\n        List<long> temp = new List<long>();\n        long\
    \ maxIndex = 0;\n        int maxIndexCount = 0;\n\n        for (int i = 0; i <\
    \ numbers.Count; i++) {\n            // Get the next element from list\n     \
    \       long number = numbers[i];\n\n            if (temp == null) {\n       \
    \         temp.Add(number);\n            } else {\n                temp.Add(number);\n\
    \                if (number > temp[temp.Count - 1]) {\n                    temp.Add(number);\n\
    \                }\n            }\n\n            // If temp is full and max is\
    \ empty\n            if (temp.Count == maxIndexCount) {\n                max.Add(temp[maxIndex]);\n\
    \                maxIndex++;\n                maxIndexCount = 0;\n           \
    \     temp.Clear();\n            } else if (temp.Count > maxIndexCount) {\n  \
    \              maxIndexCount++;\n            }\n        }\n\n        return max;",
  "        List<long> list = new List<long>();\n        int index = 0;\n        int\
    \ sum = 0;\n        bool flag = true;\n        do {\n            int sumIndex\
    \ = sum - index;\n            if (sumIndex >= 0) {\n                list.Add(numbers[index]\
    \ + sumIndex);\n                index++;\n            } else {\n             \
    \   index++;\n            }\n            if (index >= numbers.Count) {\n     \
    \           flag = false;\n            }\n        } while (flag);\n        return\
    \ list;", "        if (numbers == null || numbers.Count == 0)\n            return\
    \ null;\n        List<long> maxValues = new List<long>();\n        double sum\
    \ = 0;\n        double rollingMax = 0;\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            if (numbers.Count > 1) {\n                sum += numbers[i];\n\
    \            }\n            if (sum >= rollingMax) {\n                rollingMax\
    \ = sum;\n                maxValues.Add(rollingMax);\n            }\n        }\n\
    \        return maxValues;", "        List<long> maxElements = new List<long>();\n\
    \        long currentMax = 0;\n        long maxCounter = 0;\n        bool isMaximal\
    \ = false;\n        for (int i = 0; i < numbers.Count; i++) {\n            if\
    \ (numbers.Count - 1 == i) {\n                currentMax = numbers[i];\n     \
    \           maxCounter = 1;\n                isMaximal = true;\n             \
    \   maxElements.Add(currentMax);\n            } else if (isMaximal) {\n      \
    \          currentMax = Math.Max(currentMax, numbers[i]);\n                maxCounter++;\n\
    \                maxElements.Add(currentMax);\n            } else {\n        \
    \        currentMax = numbers[i];\n                maxCounter = 1;\n         \
    \       isMaximal = true;\n                maxElements.Add(currentMax);\n    \
    \        }\n        }\n        return maxElements;", "        List<long> rollingMax\
    \ = new List<long>();\n        List<long> lastRollingMax = new List<long>();\n\
    \        foreach (long element in numbers) {\n            if (rollingMax.Count\
    \ > 0 && element > rollingMax.Last()) {\n                lastRollingMax = new\
    \ List<long>();\n                rollingMax.Clear();\n            }\n        \
    \    rollingMax.Add(element);\n            if (element > rollingMax.Last()) {\n\
    \                lastRollingMax.Add(element);\n            }\n        }\n    \
    \    if (lastRollingMax.Count > 0) {\n            rollingMax.AddRange(lastRollingMax);\n\
    \        }\n        return rollingMax;", "        if (numbers.Count < 3) {\n \
    \           throw new ArgumentOutOfRangeException(\"numbers\", \"The length of\
    \ the list should be grater than 3.\");\n        }\n        long maxSum = 0;\n\
    \        for (int i = 0; i < numbers.Count - 1; i++) {\n            long currentSum\
    \ = 0;\n            for (int j = i; j < numbers.Count - 1; j++) {\n          \
    \      currentSum += numbers[j];\n            }\n            maxSum = Math.Max(currentSum,\
    \ maxSum);\n        }\n        List<long> result = new List<long>();\n       \
    \ for (int i = numbers.Count - 1; i > 0; i--) {\n            long currentSum =\
    \ 0;\n            for (int j = i; j < numbers.Count - 1; j++) {\n            \
    \    currentSum += numbers[j];\n            }\n            if (maxSum < currentSum)\
    \ {\n                result.Add(maxSum);\n                maxSum = 0;\n      \
    \      } else {\n                maxSum = Math.Max(maxSum, currentSum);\n    \
    \        }\n        }\n        return result;", "        long maxValue = numbers.Max();\n\
    \        int length = numbers.Count;\n        List<long> rollingMax = new List<long>();\n\
    \        rollingMax.Add(maxValue);\n\n        for (int i = length - 1; i >= 0;\
    \ i--) {\n            if (numbers[i] <= maxValue) {\n                maxValue\
    \ = numbers.RemoveAt(i);\n                rollingMax.Add(maxValue);\n        \
    \    } else {\n                break;\n            }\n        }\n        return\
    \ rollingMax;", "        var rollingMax = new List<long>();\n        rollingMax.Add(0);\n\
    \n        // We go through all numbers, adding it to rollingMax until rollingMax\
    \ >= number\n        // For each number, we check whether rollingMax is greater\
    \ than number, and if so\n        // we update rollingMax to number\n        for\
    \ (var i = 0; i < numbers.Count; i++) {\n            var rollingMaxElement = rollingMax.Last();\n\
    \n            rollingMax.Add(Math.Max(rollingMaxElement, numbers[i]));\n     \
    \   }\n\n        return rollingMax;", "        if (numbers == null) return null;\n\
    \        List<long> result = new List<long>();\n        long rollingMax = numbers.First();\n\
    \        result.Add(rollingMax);\n        result.AddRange(numbers.Skip(numbers.Count\
    \ - 1).TakeWhile((x) => x <= rollingMax).Select(x => x + 1));\n        return\
    \ result;", "        HashSet<long> numberSet = new HashSet<long>();\n        numbers.ForEach(numberSet.Add);\n\
    \        long maxNum = numberSet.Count;\n\n        List<long> results = new List<long>();\n\
    \        long currentIndex = 0;\n\n        List<long> currentResults = new List<long>();\n\
    \        while (currentIndex < numbers.Count - 1) {\n            long currentValue\
    \ = numbers[currentIndex];\n            currentResults.Add(currentValue);\n\n\
    \            int rollingIndex = 0;\n            while (rollingIndex < maxNum -\
    \ currentValue + 1) {\n                if (currentResults[rollingIndex] < currentValue)\
    \ {\n                    currentResults[rollingIndex] = currentValue;\n      \
    \              break;\n                }\n                rollingIndex++;\n  \
    \          }\n\n            if (currentResults.Last() == currentValue) {\n   \
    \             results.Add(currentValue);\n                currentIndex++;\n  \
    \          } else {\n                currentIndex++;\n            }\n        }\n\
    \n        return results;", "        long maxElement = numbers.Max();\n      \
    \  long currElement = maxElement;\n        List<long> result = new List<long>(numbers);\n\
    \        while (currElement > numbers.Min()) {\n            currElement = numbers.Max();\n\
    \            result.Remove(numbers.Max());\n            for (long rollingMax :\
    \ result) {\n                numbers.Add(rollingMax + 1);\n            }\n   \
    \         result.Add(numbers.Max());\n        }\n        return result;", "  \
    \      List<long> result = new List<long>();\n        for (int i = 0; i < numbers.Count;\
    \ ++i) {\n            long min = numbers[i];\n            long max = 0;\n    \
    \        for (int j = i; j < numbers.Count; ++j) {\n                if (numbers[j]\
    \ >= min) {\n                    min = numbers[j];\n                }\n      \
    \          if (numbers[j] > max) {\n                    max = numbers[j];\n  \
    \              }\n            }\n            result.Add(max);\n        }\n   \
    \     return result;", "        if (numbers.Count < 3) {\n            return numbers;\n\
    \        }\n\n        var rollingMax = new List<long>();\n        var rollingMaxIndex\
    \ = 0;\n        var currentMax = numbers.Max();\n\n        // Get the max element\
    \ before the given moment\n        var maxBefore = numbers.ElementAt(numbers.Count\
    \ - 1);\n        rollingMax.Add(maxBefore);\n\n        // While we haven't found\
    \ the max element after the given moment\n        while (maxBefore < currentMax)\
    \ {\n            // Get the max element after the given moment\n            maxBefore\
    \ = numbers.ElementAt(rollingMaxIndex + 1);\n\n            // If we've reached\
    \ the given moment\n            if (maxBefore == currentMax) {\n             \
    \   rollingMax.Add(currentMax);\n            }\n            else {\n         \
    \       // Update the last element in the list\n                rollingMax[rollingMax.Count\
    \ - 1] = maxBefore;\n            }\n        }\n\n        return rollingMax;",
  "        List<long> max = new List<long>();\n        long prev = numbers.First();\n\
    \        long max = prev;\n        long tmp;\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            tmp = numbers[i];\n            if (tmp > max) {\n      \
    \          max = tmp;\n            }\n            if (tmp == prev) {\n       \
    \         max.Add(tmp);\n            }\n        }\n        max.Add(prev);\n  \
    \      return max;", "        // Start with rolling max of first number\n    \
    \    var currentMax = numbers.First();\n\n        // Iterate until we find bigger\
    \ rolling max\n        for (var i = 1; i < numbers.Count; ++i) {\n           \
    \ var nextMax = currentMax;\n\n            // Find bigger one from current rolling\
    \ max and new number\n            if (numbers[i] > currentMax) {\n           \
    \     currentMax = numbers[i];\n            } else {\n                nextMax\
    \ = numbers[i];\n            }\n\n            // If new number is bigger, then\
    \ store it in our rolling max\n            if (nextMax > currentMax) {\n     \
    \           currentMax = nextMax;\n            }\n        }\n\n        // Return\
    \ rolling max found\n        return new List<long> {currentMax};", "        List<long>\
    \ rollingMax = new List<long>();\n        // Find rolling maximum by rolling down\
    \ from current rolling max\n        // and compare with each element\n       \
    \ for (int i = 0; i < numbers.Count - 1; i++) {\n            if (numbers.ElementAt(i)\
    \ > numbers.ElementAt(i + 1)) {\n                rollingMax.Add(numbers.ElementAt(i));\n\
    \                // Roll down from current rolling max to next rolling max\n \
    \               // and compare with each element\n            } else {\n     \
    \           rollingMax.Add(numbers.ElementAt(i + 1));\n                // Roll\
    \ down from current rolling max to next rolling max\n                // and compare\
    \ with each element\n            }\n        }\n        return rollingMax;", " \
    \       if (numbers == null)\n            throw new ArgumentNullException(\"numbers\"\
    );\n        List<long> rolledNumbers = new List<long>();\n        foreach (long\
    \ n in numbers)\n            rolledNumbers.Add(RollingMax(n));\n        return\
    \ rolledNumbers;", "        // Find the maximum element\n        long maxIndex\
    \ = numbers.Count() - 1;\n        long maxValue = numbers[maxIndex];\n       \
    \ long previousElement = maxValue;\n        long rollingMax = maxValue;\n    \
    \    for (long index = maxIndex - 1; index >= 0; index--) {\n            long\
    \ currentElement = numbers[index];\n            if (previousElement > currentElement)\
    \ {\n                rollingMax = previousElement;\n                break;\n \
    \           }\n            previousElement = currentElement;\n        }\n    \
    \    return numbers;", "        List<long> result = new List<long>();\n      \
    \  int size = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n        \
    \    size += numbers[i];\n            result.Add(numbers[i]);\n            if\
    \ (i == numbers.Count - 1) {\n                for (int j = size - 1; j < size;\
    \ j++) {\n                    result.Add(numbers[j]);\n                }\n   \
    \         }\n        }\n        return result;", "        int rollingMax = numbers.Max();\n\
    \        List<long> result = new List<long>(new long[] { rollingMax });\n    \
    \    for (int i = 0; i < numbers.Count; i++) {\n            rollingMax = Math.Max(numbers[i],\
    \ rollingMax);\n            result.Add(rollingMax);\n        }\n        return\
    \ result;", "        if (numbers.Count < 1) {\n            throw new ArgumentOutOfRangeException(\"\
    numbers\", \"numbers.Count must be greater than 0.\");\n        }\n\n        //\
    \ Find out the first number that exceeds max rolling range\n        long rollingMaxValue\
    \ = numbers[0];\n        long rollingMaxIndex = -1;\n\n        for (int i = 1;\
    \ i < numbers.Count; i++) {\n            long value = numbers[i];\n\n        \
    \    if (value > rollingMaxValue) {\n                rollingMaxValue = value;\n\
    \                rollingMaxIndex = i;\n            }\n        }\n\n        //\
    \ Initialize max rolling range\n        long rollingMaxEnd = rollingMaxIndex +\
    \ 1;\n\n        // Initialize max rolling rolling range\n        long rollingMaxRollingEnd\
    \ = rollingMaxValue + 1;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart = 0;\n\n        // Initialize max rolling\
    \ rolling range\n        long rollingMaxRollingStart2 = rollingMaxRollingEnd -\
    \ 1;\n\n        // Initialize max rolling rolling range\n        long rollingMaxRollingStart3\
    \ = rollingMaxRollingEnd - 2;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart4 = rollingMaxRollingEnd - 3;\n\n        //\
    \ Initialize max rolling rolling range\n        long rollingMaxRollingStart5 =\
    \ rollingMaxRollingEnd - 4;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart6 = rollingMaxRollingEnd - 5;\n\n        //\
    \ Initialize max rolling rolling range\n        long rollingMaxRollingStart7 =\
    \ rollingMaxRollingEnd - 6;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart8 = rollingMaxRollingEnd - 7;\n\n        //\
    \ Initialize max rolling rolling range\n        long rollingMaxRollingStart9 =\
    \ rollingMaxRollingEnd - 8;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart10 = rollingMaxRollingEnd - 9;\n\n       \
    \ // Initialize max rolling rolling range\n        long rollingMaxRollingStart11\
    \ = rollingMaxRollingEnd - 10;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart12 = rollingMaxRollingEnd - 11;\n\n      \
    \  // Initialize max rolling rolling range\n        long rollingMaxRollingStart13\
    \ = rollingMaxRollingEnd - 12;\n\n        // Initialize max rolling rolling range\n\
    \        long rollingMaxRollingStart14 = rollingMaxRollingEnd - 13;\n\n      \
    \  // Initialize max ", "        var rollingMax = new List<long>();\n\n      \
    \  var max = numbers.Max();\n        var currentMax = max;\n\n        rollingMax.Add(max);\n\
    \n        for (int i = 1; i < numbers.Count; i++) {\n            var currentElement\
    \ = numbers[i];\n\n            if (currentElement > max) {\n                max\
    \ = currentElement;\n                currentMax = max;\n            } else {\n\
    \                max = currentMax;\n                currentMax = currentElement;\n\
    \            }\n            rollingMax.Add(max);\n        }\n\n        return\
    \ rollingMax;", "        if (numbers.Count <= 0)\n            return numbers;\n\
    \n        long[] firstElements = numbers.Take(numbers.Count - 1).ToArray();\n\n\
    \        long[] firstMax = RollingMax(firstElements);\n        long firstMaxElement\
    \ = firstMax.Max();\n\n        long[] lastElements = numbers.Skip(numbers.Count\
    \ - 1).ToArray();\n\n        long[] lastMax = RollingMax(lastElements);\n    \
    \    long lastMaxElement = lastMax.Max();\n\n        long[] currentElements =\
    \ firstMax.Concat(lastMax).ToArray();\n\n        long[] maxElements = RollingMax(currentElements);\n\
    \        long maxElementElement = maxElements.Max();\n\n        List<long> rolledMaxElements\
    \ = new List<long>();\n        long maxIndex = 0;\n        while (maxIndex < numbers.Count)\
    \ {\n            rolledMaxElements.Add(numbers[maxIndex]);\n            maxIndex++;\n\
    \            if (maxIndex == numbers.Count)\n                break;\n        }\n\
    \        if (maxIndex != numbers.Count)\n            rolledMaxElements.Add(maxElementElement);\n\
    \n        return rolledMaxElements;", "        List<long> result = new List<long>();\n\
    \        if (numbers == null || numbers.Count <= 0) {\n            return result;\n\
    \        }\n        long maxElement = numbers.First();\n        for (int i = 1;\
    \ i < numbers.Count; ++i) {\n            long element = numbers[i];\n        \
    \    if (element > maxElement) {\n                maxElement = element;\n    \
    \        }\n            result.Add(maxElement);\n        }\n        return result;",
  "        var result = new List<long>();\n        var max = new long();\n       \
    \ foreach (var number in numbers) {\n            var newMax = RollingMax(numbers);\n\
    \            if (newMax.Count > 0 && newMax.Max() < number) {\n              \
    \  max = number;\n            }\n            result.Add(number);\n        }\n\
    \        return result;", "        if (numbers == null) return null;\n\n     \
    \   // Initialize rolling max with first number\n        List<long> rollingMax\
    \ = new List<long> { numbers.First() };\n        int rollingMaxIdx = 0;\n\n  \
    \      // Find rolling max in each successive number\n        foreach (long number\
    \ in numbers.Skip(1)) {\n            // Rolling max is maximum of current number\
    \ and its successor until current moment\n            rollingMax.Add(Math.Max(rollingMax[rollingMaxIdx],\
    \ number));\n            // Move to next rolling max position\n            rollingMaxIdx\
    \ = rollingMaxIdx + 1;\n        }\n\n        // Return rolling max\n        return\
    \ rollingMax;", "        if (numbers.Count == 0) {\n            return new List<long>();\n\
    \        }\n        if (numbers.Count == 1) {\n            return new List<long>\
    \ {numbers[0]};\n        }\n        List<long> max = numbers.OrderByDescending(i\
    \ => i).First();\n        List<long> result = new List<long> {max};\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            max = numbers.OrderByDescending(i\
    \ => i).First();\n            if (max == numbers[i]) {\n                result.Add(max);\n\
    \            } else {\n                result.Add(max);\n            }\n     \
    \   }\n        return result;", "        Debug.Assert(numbers != null);\n    \
    \    if (numbers.Count == 0) return new List<long>();\n        var rollingMax\
    \ = numbers.OrderBy(n => n).Last();\n        var max = new List<long>();\n   \
    \     var maxIndex = 0;\n        var isMax = true;\n        for (int i = 0; i\
    \ < numbers.Count; i++) {\n            if (i == maxIndex) continue;\n        \
    \    if (numbers[i] == rollingMax) {\n                isMax = true;\n        \
    \        maxIndex = i;\n            }\n            if (isMax) {\n            \
    \    max.Add(numbers[i]);\n                isMax = false;\n            }\n   \
    \     }\n        return max;", "        var rollingMax = new List<long>();\n \
    \       var currentMax = numbers.First();\n        var currentPosition = 0;\n\
    \        foreach (var number in numbers) {\n            if (currentMax < number)\
    \ {\n                rollingMax.Add(currentMax);\n                currentMax =\
    \ number;\n                currentPosition = 0;\n            }\n            else\
    \ {\n                currentMax -= number;\n                currentPosition +=\
    \ 1;\n            }\n        }\n        rollingMax.Add(currentMax);\n        return\
    \ rollingMax;", "        var rollingMax = new List<long>();\n        var currentMax\
    \ = numbers.Min();\n        var currentMaxIndex = numbers.FindIndex(n => n > currentMax);\n\
    \        while (currentMaxIndex != -1) {\n            rollingMax.Add(currentMax);\n\
    \            currentMax = numbers[currentMaxIndex];\n            currentMaxIndex\
    \ = numbers.FindIndex(n => n > currentMax);\n        }\n        return rollingMax;",
  "        var result = new List<long>();\n        numbers.Add(numbers.First());\n\
    \        for (var index = 1; index < numbers.Count; index++) {\n            var\
    \ current = numbers[index];\n            var previous = numbers.Last();\n    \
    \        result.Add(Math.Max(current, previous));\n            numbers[index]\
    \ = current + 1;\n        }\n        return result;", "        List<long> max\
    \ = new List<long>();\n        long[] maxValues = new long[numbers.Count];\n\n\
    \        int count = 0;\n        foreach (long num in numbers) {\n           \
    \ maxValues[count++] = num;\n        }\n        long[] rollingMaxValues = new\
    \ long[maxValues.Length];\n\n        for (int i = 0; i < maxValues.Length; i++)\
    \ {\n            rollingMaxValues[i] = 0;\n        }\n\n        int lastCount\
    \ = 0;\n        long lastNum = maxValues[lastCount];\n\n        for (int i = 0;\
    \ i < maxValues.Length; i++) {\n            rollingMaxValues[i] = maxValues[i];\n\
    \n            if (i == maxValues.Length - 1) {\n                rollingMaxValues[i]\
    \ = num;\n            } else {\n                long num = maxValues[i + 1];\n\
    \                if (lastNum > num) {\n                    rollingMaxValues[i]\
    \ = num;\n                } else {\n                    rollingMaxValues[i] =\
    \ lastNum;\n                }\n            }\n\n            lastCount = i;\n \
    \           lastNum = maxValues[lastCount];\n        }\n\n        rollingMaxValues[rollingMaxValues.Length\
    \ - 1] = num;\n        max = rollingMaxValues.Where(a => a == rollingMaxValues.Max()).ToList();\n\
    \n        return max;", "        List<long> ret = new List<long>();\n\n      \
    \  for (int i = 0; i < numbers.Count; i++) {\n            long maxSum = numbers[i];\n\
    \            int startIndex = 0;\n\n            // Scan the given numbers up to\
    \ the given moment\n            for (int j = i; j < numbers.Count; j++) {\n  \
    \              long sum = numbers[j];\n\n                // Add the number in\
    \ the current position\n                maxSum = maxSum + sum;\n\n           \
    \     // Check if there is a number greater than the previous one\n          \
    \      if (sum > maxSum) {\n                    // If there is a number greater\
    \ than the previous one\n                    startIndex = j;\n               \
    \ }\n            }\n\n            ret.Add(maxSum);\n        }\n\n        return\
    \ ret;"]
stop_tokens:
- "\n    }\n"
