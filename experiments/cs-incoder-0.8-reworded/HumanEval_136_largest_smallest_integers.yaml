name: HumanEval_136_largest_smallest_integers
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that returns a tuple (a, b), where 'a' is\n\
  \    // the largest of negative integers, and 'b' is the smallest\n    // of positive\
  \ integers in a list.\n    // If there is no negative or positive integers, return\
  \ them as null.\n    // Examples:\n    // >>> LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))\n    //\
  \ Tuple.Create((Nullable<long>)null, 1L)\n    // >>> LargestSmallestIntegers((new\
  \ List<long>()))\n    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n\
  \    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))\n  \
  \  // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n    public static\
  \ Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestSmallestIntegers((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L,\
  \ (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L,\
  \ (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L,\
  \ (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L,\
  \ (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null,\
  \ (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L,\
  \ 1L)));\n    }\n\n}\n"
completions: ["        if (lst.Count == 0)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        // Sort the list from lowest to highest\n\
    \        lst.Sort();\n\n        long largest = lst[0];\n        long smallest\
    \ = lst[0];\n        bool posOrNeg = true;\n\n        // Iterate through list,\
    \ checking for negative and positive values\n        foreach (var val in lst)\
    \ {\n            if (val < smallest || (smallest < 0 && !posOrNeg)) {\n      \
    \          smallest = val;\n            }\n            else if (val > largest\
    \ || (largest > 0 && !posOrNeg)) {\n                largest = val;\n         \
    \   }\n            else {\n                // This number is either both negative\
    \ or positive\n                posOrNeg = !posOrNeg;\n            }\n        }\n\
    \        // If there were no negative and positive numbers, then return them as\
    \ null\n        if (!posOrNeg)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        // We must return a tuple with either the smallest or largest\
    \ positive integer\n        // as the value, or null if none exist.\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>((long)smallest, (long)largest);",
  "        long largest = Long.MinValue;\n        long smallest = Long.MaxValue;\n\
    \        foreach (long i in lst) {\n            if (i < 0) {\n               \
    \ smallest = Long.MaxValue;\n            } else if (i > 0) {\n               \
    \ largest = Long.MinValue;\n            } else {\n                smallest = Long.MaxValue;\n\
    \                largest = Long.MinValue;\n            }\n        }\n        return\
    \ Tuple.Create<Nullable<long>, Nullable<long>>(smallest, largest);", "       \
    \ double maxNum = lst.Max();\n        double minNum = lst.Min();\n        bool\
    \ hasNegatives = lst.Any(x => x < 0);\n        bool hasPositives = lst.Any(x =>\
    \ x > 0);\n        if (maxNum == minNum) {\n            return Tuple.Create((Nullable<long>)null,\
    \ maxNum);\n        }\n        if (maxNum < minNum) {\n            if (maxNum\
    \ > 0) {\n                return Tuple.Create((Nullable<long>)null, maxNum);\n\
    \            } else {\n                return Tuple.Create((Nullable<long>)null,\
    \ minNum);\n            }\n        }\n        double maxInt = 0;\n        double\
    \ minInt = Math.Abs(minNum);\n        if (hasNegatives) {\n            maxInt\
    \ = Math.Abs(maxNum);\n        }\n        if (hasPositives) {\n            minInt\
    \ = Math.Abs(minNum);\n        }\n        if (maxInt < minInt) {\n           \
    \ return Tuple.Create((Nullable<long>)null, minInt);\n        }\n        long\
    \ maxNumAsLong = maxNum;\n        long minNumAsLong = minNum;\n        if (hasNegatives)\
    \ {\n            maxNumAsLong = maxNum < 0 ? 0L : maxNum;\n        }\n       \
    \ if (hasPositives) {\n            minNumAsLong = minNum < 0 ? 0L : minNum;\n\
    \        }\n        long maxNumAsLong2 = maxNumAsLong;\n        long minNumAsLong2\
    \ = minNumAsLong;\n        if (hasNegatives) {\n            maxNumAsLong2 = Math.Abs(maxNumAsLong);\n\
    \        }\n        if (hasPositives) {\n            minNumAsLong2 = Math.Abs(minNumAsLong);\n\
    \        }\n        if (maxNumAsLong2 < minNumAsLong2) {\n            return Tuple.Create((Nullable<long>)null,\
    \ minNumAsLong2);\n        }\n        long maxNumAsLong3 = maxNumAsLong2;\n  \
    \      long minNumAsLong3 = minNumAsLong2;\n        if (hasNegatives) {\n    \
    \        maxNumAsLong3 = Math.Max(maxNumAsLong, 0L);\n        }\n        if (hasPositives)\
    \ {\n            minNumAsLong3 = Math.Max(minNumAsLong, 0L);\n        }\n    \
    \    if (maxNumAsLong3 < minNumAsLong3) {\n            return Tuple.Create((Nullable<long>)null,\
    \ minNumAsLong3);\n        }\n        long maxNumAsLong4 = maxNumAsLong3;\n  \
    \      long minNumAsLong4 = minNumAsLong3;\n        if (hasNegatives) {", "  \
    \      if (lst.Count == 0)\n            return Tuple.Create(null, null);\n   \
    \     var largest = -1000000000000L;\n        var smallest = 1000000000000L;\n\
    \        foreach (var num in lst) {\n            if (num < smallest || smallest\
    \ < -num || smallest < largest)\n                return Tuple.Create((Nullable<long>)null,\
    \ null);\n            else if (smallest > num && num < largest)\n            \
    \    smallest = num;\n            else if (largest < num && num > largest)\n \
    \               largest = num;\n        }\n        return Tuple.Create((Nullable<long>)largest,\
    \ (Nullable<long>)smallest);", "        // Solution 1. Using LINQ\n        if\
    \ (lst.Any()) { // if any items in the list\n            var result = lst.Where(x\
    \ => x < 0).Max(); // find the maximum value in the list that is less than 0\n\
    \            if (result.HasValue) {\n                return Tuple.Create(Nullable<long>.GetValueOrDefault(result.Value),\
    \ lst.Where(x => x < 0).Min());\n            }\n        }\n        // Solution\
    \ 2. Using recursion\n        if (lst.Any()) { // if any items in the list\n \
    \           return LargestSmallestIntegers(lst.Where(x => x < 0).ToList()).Select(x\
    \ => x.Item1).Concat(LargestSmallestIntegers(lst.Where(x => x > 0).ToList()).Select(x\
    \ => x.Item1)).ToList().Max();\n        }\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);", "        int aMax = lst.Max();\n        int aMin\
    \ = lst.Min();\n        Nullable<long> aMaxNullable = Nullable.GetUnderlyingType(aMax.GetType()).GetField(\"\
    _valid\", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(aMax);\n  \
    \      Nullable<long> aMinNullable = Nullable.GetUnderlyingType(aMin.GetType()).GetField(\"\
    _valid\", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(aMin);\n  \
    \      if (aMax == 0)\n        {\n            return Tuple.Create(aMaxNullable,\
    \ aMinNullable);\n        }\n        else if (aMin == 0)\n        {\n        \
    \    return Tuple.Create(aMaxNullable, aMinNullable);\n        }\n        else\n\
    \        {\n            return Tuple.Create(aMaxNullable, aMinNullable);\n   \
    \     }", "        double largest = Math.Max(lst);\n        int largestInt = (int)Math.Abs(largest);\n\
    \        if (largest == 0 || largest == 1)\n            return Tuple.Create((Nullable<long>)null,\
    \ largestInt);\n        else\n            return LargestSmallestIntegers(lst.FindAll(i\
    \ => Math.Abs(i) < largest));", "        long largest = lst.Where((long x) =>\
    \ x < 0).OrderByDescending(x => x).FirstOrDefault();\n        long smallest =\
    \ lst.Where((long x) => x >= 0).OrderBy(x => x).FirstOrDefault();\n        if\
    \ (largest == 0 && smallest == 0)\n            return Tuple.Create<Nullable<long>>(null,\
    \ null);\n        else\n            return Tuple.Create<Nullable<long>>(largest,\
    \ smallest);", "        if (lst.Count <= 0)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        var smallest = lst.Min();\n        var\
    \ largest = lst.Max();\n        var ints = new List<long>();\n        var infinity\
    \ = new long[] { long.MaxValue, long.MinValue };\n        for (var i = -1; i <\
    \ 1; i++)\n            for (long n in lst) {\n                var nCopy = n;\n\
    \                if (n == 0)\n                    continue;\n                if\
    \ (n == -1 || n == 1)\n                    continue;\n                if (n <\
    \ 0) {\n                    nCopy = -n;\n                }\n                var\
    \ isNegativeNegative = (lst.Contains(nCopy) == false);\n                if (isNegativeNegative)\n\
    \                    continue;\n                var n = isNegativeNegative ? Math.Abs(nCopy)\
    \ : nCopy;\n                if (n < 0) {\n                    n += infinity[i];\n\
    \                }\n                ints.Add(n);\n            }\n        if (ints.Count\
    \ > 0)\n            ints.Sort();\n        smallest = ints.Min();\n        largest\
    \ = ints.Max();\n        if (smallest < 0)\n            smallest = null;\n   \
    \     if (largest > 0)\n            largest = null;\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(smallest, largest);", "        if (lst.Count == 0) {\n     \
    \       return null;\n        }\n        long[] vals = lst.ToArray();\n      \
    \  long[] diffs = new long[vals.Length];\n        int n = 0;\n        for (int\
    \ i = 0; i < vals.Length; ++i) {\n            diffs[i] = vals[i] - vals[i - 1];\n\
    \            if (diffs[i] > 0) {\n                ++n;\n            }\n      \
    \  }\n        if (n > 0) {\n            int i = 0;\n            int j = vals.Length\
    \ - 1;\n            int k = -1;\n            while (i < j) {\n               \
    \ k = i;\n                if (diffs[i] > diffs[j]) {\n                    k =\
    \ j;\n                }\n                if (diffs[i] == diffs[k]) {\n       \
    \             int l = i;\n                    if (diffs[k] > diffs[l]) {\n   \
    \                     k = l;\n                    }\n                }\n     \
    \           i++;\n                j--;\n            }\n            diffs[n - 1]\
    \ = 0;\n            return new Tuple<Nullable<long>, Nullable<long>>(null, diffs[n\
    \ - 1]);\n        }\n        int i = n-1;\n        int j = vals.Length - 1;\n\
    \        int k = -1;\n        while (i >= j) {\n            k = i;\n         \
    \   if (diffs[i] > diffs[j]) {\n                k = j;\n            }\n      \
    \      if (diffs[i] == diffs[k]) {\n                int l = i;\n             \
    \   if (diffs[k] > diffs[l]) {\n                    k = l;\n                }\n\
    \            }\n            i--;\n            j--;\n        }\n        diffs[n\
    \ - 1] = 0;\n        return new Tuple<Nullable<long>, Nullable<long>>(null, diffs[n\
    \ - 1]);", "        // Create two arrays to hold positive and negative values.\n\
    \        long[] positiveIntegersArray = new long[lst.Count];\n        long[] negativeIntegersArray\
    \ = new long[lst.Count];\n        int positiveIntegerCount = 0;\n        int negativeIntegerCount\
    \ = 0;\n        long largestPositive = long.MinValue;\n        long smallestNegative\
    \ = long.MaxValue;\n        foreach (long number in lst) {\n            if (number\
    \ >= 0) {\n                positiveIntegersArray[positiveIntegerCount++] = number;\n\
    \            }\n            else {\n                negativeIntegersArray[negativeIntegerCount++]\
    \ = number;\n            }\n        }\n        if (positiveIntegerCount > negativeIntegerCount)\
    \ {\n            largestPositive = positiveIntegersArray[0];\n            smallestNegative\
    \ = negativeIntegersArray[0];\n        }\n        else if (negativeIntegerCount\
    \ > positiveIntegerCount) {\n            largestPositive = negativeIntegersArray[0];\n\
    \            smallestNegative = positiveIntegersArray[0];\n        }\n       \
    \ else {\n            largestPositive = positiveIntegersArray[0];\n          \
    \  smallestNegative = positiveIntegersArray[0];\n        }\n        return new\
    \ Tuple<Nullable<long>, Nullable<long>>(largestPositive, smallestNegative);",
  "        if (lst?.Any() == false) return null;\n        var negatives = lst?.Where(x\
    \ => x < 0L);\n        if (negatives == null) throw new ArgumentException(\"No\
    \ negatives found\");\n        var positives = lst?.Where(x => x >= 0L);\n   \
    \     if (positives == null) throw new ArgumentException(\"No positives found\"\
    );\n        var largest = negatives?.Max() ?? 0L;\n        var smallest = positives?.Min()\
    \ ?? 0L;\n        return Tuple.Create(largest, smallest);", "        long largest\
    \ = 0;\n        long smallest = int.MaxValue;\n        if (lst.Any()) {\n    \
    \        lst.Sort();\n            var index = lst.Count - 1;\n            while\
    \ (index >= 0) {\n                if (lst[index] < smallest)\n               \
    \     smallest = lst[index];\n                index--;\n            }\n      \
    \      int index2 = lst.Count;\n            while (index2 > 0) {\n           \
    \     if (lst[index2] > largest)\n                    largest = lst[index2];\n\
    \                index2--;\n            }\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        long? max = lst.Aggregate(0, (max, x) => max\
    \ < x ? max : x);\n        if (max.HasValue) {\n            return Tuple.Create(max,\
    \ lst.Aggregate((max, x) => max > x ? max : x));\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        // TODO: Implement the body of the function\
    \ here.\n        if (lst.Count == 0) return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        if (lst.Count == 1) return new Tuple<Nullable<long>,\
    \ Nullable<long>>((Nullable<long>)lst[0], (Nullable<long>)null);\n        if (lst.Count()\
    \ <= 1) return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long largest = lst.Max();\n        long smallest\
    \ = lst.Min();\n        bool isLarger = largest > smallest;\n        foreach (long\
    \ n in lst) {\n            if (isLarger) {\n                isLarger = largest\
    \ > n;\n            } else {\n                isLarger = smallest < n;\n     \
    \       }\n        }\n        if (isLarger) return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)largest,\
    \ (Nullable<long>)smallest);\n        else return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        if (lst==null) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n\n        long[] arr = lst.ToArray();\n\
    \        long? a = (long?)null;\n        long? b = (long?)null;\n        for (int\
    \ i=0;i<arr.Length;i++) {\n            if (arr[i] < 0 && !(arr.Length > 1 && arr[i]>arr[i-1]))\
    \ {\n                a = arr[i];\n            }\n            else if (arr[i] >\
    \ 0 && !(arr.Length > 1 && arr[i]>arr[i-1])) {\n                b = arr[i];\n\
    \            }\n        }\n        return Tuple.Create(a, b);", "        long\
    \ largest = lst.Max();\n        long smallest = lst.Min();\n        if (largest\
    \ < smallest)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        return new Tuple<Nullable<long>, Nullable<long>>(null, (long)smallest);",
  "        if (lst == null || lst.Count == 0) {\n            return null;\n      \
    \  }\n        // If there are more than one element, find the largest of all\n\
    \        // negative values.\n        long maxNegative = 0;\n        foreach (long\
    \ x in lst) {\n            if (x < 0) {\n                maxNegative = x;\n  \
    \          }\n        }\n        // If there are more than one element, find the\
    \ smallest of all\n        // positive values.\n        long minPositive = long.MaxValue;\n\
    \        foreach (long x in lst) {\n            if (x > 0) {\n               \
    \ minPositive = x;\n            }\n        }\n        // Now return the largest\
    \ and smallest of these.\n        // The function returns a tuple (a, b), where\
    \ 'a' is the\n        // largest of negative integers, and 'b' is the smallest\n\
    \        // of positive integers in a list.\n        return (Tuple.Create(maxNegative,\
    \ minPositive), null);", "        long max = 0;\n        long min = -2;\n    \
    \    foreach (long i in lst) {\n            if (i > max) {\n                max\
    \ = i;\n            }\n            else if (i < min) {\n                min =\
    \ i;\n            }\n        }\n        if (max == min) {\n            return\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        }\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>(max == 0 ? null : (long?)max, min);",
  "        long smallest = lst.Min();\n        long largest = lst.Max();\n       \
    \ var negatives = new List<long>();\n        var positives = new List<long>();\n\
    \n        if (largest == 0)\n            return null;\n        if (smallest <\
    \ 0)\n            smallest *= -1;\n        if (smallest == largest)\n        \
    \    return null;\n        if (smallest > largest)\n            smallest = largest;\n\
    \        if (smallest < 0)\n            smallest *= -1;\n        if (smallest\
    \ < 0)\n            smallest *= -1;\n        foreach (var i in lst) {\n      \
    \      if (i < 0)\n                negatives.Add(i);\n            else if (i >\
    \ 0) {\n                positives.Add(i);\n                if (smallest > i)\n\
    \                    smallest = i;\n                if (largest < i)\n       \
    \             largest = i;\n            }\n        }\n        return Tuple.Create(smallest,\
    \ largest);", "        Nullable<long> largest = null, smallest = null;\n     \
    \   foreach (var item in lst) {\n            if (item < 0) {\n               \
    \ largest = item;\n            } else {\n                smallest = item;\n  \
    \          }\n        }\n        return largest.IsNull ? smallest : (smallest.IsNull\
    \ ? largest : new Tuple<Nullable<long>, Nullable<long>>(largest, smallest));",
  "        long positiveMin = Long.MinValue;\n        long negativeMin = Long.MaxValue;\n\
    \        long positiveMax = Long.MaxValue;\n        long negativeMax = Long.MinValue;\n\
    \        foreach (long i in lst) {\n            if (i < 0) {\n               \
    \ if (negativeMin > i)\n                    negativeMin = i;\n            }\n\
    \            if (i > 0) {\n                if (positiveMax < i)\n            \
    \        positiveMax = i;\n            }\n        }\n        return Tuple.Create(\n\
    \            new Nullable<long>((long)negativeMin),\n            new Nullable<long>((long)positiveMax));",
  "        int min = lst.Min();\n        int max = lst.Max();\n        if ((min <\
    \ 0) && (max > 0)) {\n            return Tuple.Create(null, max);\n        } else\
    \ if ((min > 0) || (max < 0)) {\n            return Tuple.Create(min, null);\n\
    \        }\n        return Tuple.Create(null, null);", "        long[] nums =\
    \ new long[lst?.Count ?? 0];\n        if (lst.Count == 0) return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        foreach(long x in lst) nums[lst.IndexOf(x)]\
    \ = x;\n        int[] counts = new int[nums.Length];\n        for(int i = 0; i\
    \ < counts; ++i) ++counts[nums.Length - 1 - i];\n        Array.Sort(nums, (x,\
    \ y) => counts[lst.IndexOf(x)] - counts[lst.IndexOf(y)]);\n        if (nums[0]\
    \ < 0) return Tuple.Create<Nullable<long>, Nullable<long>>(null, null); \n   \
    \     if (nums.Length <= 1) return Tuple.Create<Nullable<long>, Nullable<long>>(nums[0],\
    \ nums[0]);\n        long min = nums[0];\n        int minIndex = nums.Length -\
    \ 1;\n        for(int i = 1; i < nums.Length; ++i) {\n            if (nums[i]\
    \ < min) {\n                min = nums[i];\n                minIndex = i;\n  \
    \          }\n        }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(nums[minIndex],\
    \ min);", "        if (lst.Count == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long min = 0;\n        long max = 0;\n     \
    \   for (int i = 0; i < lst.Count; ++i) {\n            int j = (int)lst[i];\n\
    \            if (j >= 0)\n                max = Math.Max(max, j);\n          \
    \  else\n                min = Math.Min(min, j);\n        }\n        return Tuple.Create((Nullable<long>)max,\
    \ (Nullable<long>)min);", "        if (lst == null || lst.Count == 0)\n      \
    \      return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n    \
    \    int minVal = lst.Min();\n        int maxVal = lst.Max();\n        if (minVal\
    \ < 0 && maxVal >= 0)\n            return Tuple.Create((Nullable<long>)null, minVal);\n\
    \        if (minVal >= 0 && maxVal < 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ maxVal);\n        if (minVal >= 0 && maxVal >= 0) {\n            Nullable<long>\
    \ min = null;\n            foreach (var v in lst)\n                if (v < 0 &&\
    \ v.CompareTo(minVal) > 0)\n                    min = v;\n            Nullable<long>\
    \ max = null;\n            foreach (var v in lst)\n                if (v >= 0\
    \ && v.CompareTo(maxVal) < 0)\n                    max = v;\n            return\
    \ Tuple.Create(min, max);\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        IEnumerable<long> nums = lst;\n        int\
    \ highest = lst.Count() > 0 ? lst.Max() : 0;\n        int smallest = lst.Count()\
    \ > 0 ? lst.Min() : 0;\n        bool neg = false;\n        for (int i = 0; i <\
    \ lst.Count(); i++) {\n            if (nums[i] < 0) {\n                neg = true;\n\
    \                continue;\n            }\n            if (neg) {\n          \
    \      if (nums[i] <= smallest) {\n                    smallest = nums[i];\n \
    \               }\n            } else {\n                if (nums[i] > highest)\
    \ {\n                    highest = nums[i];\n                }\n            }\n\
    \        }\n        if (neg) {\n            return Tuple.Create(null, smallest);\n\
    \        } else {\n            return Tuple.Create((Nullable<long>)highest, (Nullable<long>)smallest);\n\
    \        }", "        long largest = -lst.Min();\n        long smallest = -lst.Max();\n\
    \        if(smallest == -1) return null;\n        if(largest == -1) return null;\n\
    \        if (largest < smallest) {\n            long tmp = largest;\n        \
    \    largest = smallest;\n            smallest = tmp;\n        }\n        return\
    \ Tuple.Create(smallest == 0, largest == 0);", "        List<long> negative =\
    \ new List<long>();\n        List<long> positive = new List<long>();\n       \
    \ foreach (long i in lst) {\n            if (i < 0) {\n                negative.Add(i);\n\
    \            } else {\n                positive.Add(i);\n            }\n     \
    \   }\n        int n1 = negative.Count;\n        int n2 = positive.Count;\n  \
    \      if (n1 < n2) {\n            n1 = n2;\n        }\n        var result = Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        if (n1 > 0) {\n            result.Item1\
    \ = negative.Max();\n            result.Item2 = positive.Min();\n        }\n \
    \       return result;", "        long maxLong = Int64.MinValue;\n        long\
    \ minLong = Int64.MaxValue;\n        foreach (long val in lst) {\n           \
    \ if (val > maxLong) {\n                maxLong = val;\n            } else if\
    \ (val < minLong) {\n                minLong = val;\n            }\n        }\n\
    \        return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)maxLong,\
    \ (Nullable<long>)minLong);", "        IEnumerable<long> vals = lst;\n       \
    \ vals.Sort();\n        Nullable<long> a = vals.FirstOrDefault(i => i < 0);\n\
    \        Nullable<long> b = vals.FirstOrDefault(i => i >= 0);\n        if (a.HasValue\
    \ && b.HasValue) {\n            return Tuple.Create(a, b);\n        } else if\
    \ (a.HasValue) {\n            return Tuple.Create(a, null);\n        } else {\n\
    \            return Tuple.Create(null, (Nullable<long>)null);\n        }", " \
    \       if (lst.Count <= 0) return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        var maxNegative = lst\n            .Where(n => n < 0)\n    \
    \        .OrderByDescending(n => n)\n            .FirstOrDefault();\n        var\
    \ minPositive = lst\n            .Where(n => n >= 0)\n            .OrderBy(n =>\
    \ n)\n            .FirstOrDefault();\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(maxNegative, minPositive);", "        // Write your code here\n\
    \        if (lst.Count < 1) return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        if (lst.Sum() < 0) return LargestSmallestIntegers(lst.Where(x\
    \ => x < 0).ToList());\n        if (lst.Sum() >= 0) return LargestSmallestIntegers(lst.Where(x\
    \ => x >= 0).ToList());\n        return null;", "        long max = 0; long min\
    \ = 0;\n        foreach (var num in lst) {\n            if (num < 0) min = Math.Min(num,\
    \ min);\n            if (num > 0) max = Math.Max(num, max);\n        }\n     \
    \   if (max != 0) return Tuple.Create(max == min ? null : (long?)max, min);\n\
    \        return null;", "        if (lst.Count == 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n\n        long min = 0L;\n        long\
    \ max = 0L;\n\n        foreach (long n in lst) {\n            min = Math.Min(n,\
    \ min);\n            max = Math.Max(n, max);\n        }\n\n        if (min ==\
    \ max) {\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n\n        var result = new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n\n        if (min < 0) {\n            result.Item1 = Nullable<long>.Parse(min.ToString());\n\
    \        } else if (min > 0) {\n            result.Item1 = Nullable<long>.Parse(max.ToString());\n\
    \        } else {\n            result.Item1 = result.Item2 = null;\n        }\n\
    \n        return result;", "        long smallest = 0;\n        long largest =\
    \ Int64.MaxValue;\n        foreach (long number in lst) {\n            if (number\
    \ < smallest) {\n                smallest = number;\n            }\n         \
    \   if (number > largest) {\n                largest = number;\n            }\n\
    \        }\n        if (smallest == Int64.MinValue && largest == Int64.MaxValue)\
    \ {\n            return null;\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(smallest, largest);", "        var positives = new List<long>();\n\
    \        var negatives = new List<long>();\n        foreach (var item in lst)\
    \ {\n            if (item > 0) {\n                positives.Add(item);\n     \
    \       } else if (item < 0) {\n                negatives.Add(item);\n       \
    \     }\n        }\n        if (positives.Count > 0 && negatives.Count > 0) {\n\
    \            return Tuple.Create((Nullable<long>)null, null);\n        }\n   \
    \     if (positives.Count > 0 && negatives.Count == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ positives.Max());\n        }\n        if (positives.Count == 0 && negatives.Count\
    \ > 0) {\n            return Tuple.Create((Nullable<long>)null, negatives.Min());\n\
    \        }\n        if (positives.Count == 0 && negatives.Count == 0) {\n    \
    \        return Tuple.Create((Nullable<long>)null, null);\n        }\n       \
    \ return null;", "        foreach (long i in lst) {\n            if (i < 0L) return\
    \ Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n            if (i\
    \ > 0L) return Tuple.Create<Nullable<long>, Nullable<long>>(null, i);\n      \
    \  }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(null, (Nullable<long>)null);",
  "        var ret = new Tuple<Nullable<long>, Nullable<long>>();\n        if (lst?.Count\
    \ > 0)\n            ret.Item1 = lst.OrderByDescending(i => i < 0L ? 1L : 0L).First();\n\
    \        if (lst?.Count > 1)\n            ret.Item2 = lst.OrderBy(i => i < 0L\
    \ ? 1L : 0L).First();\n        if (ret.Item1 == null && ret.Item2 == null)\n \
    \           return ret;\n        else\n            return ret;", "        if (lst.Count\
    \ == 0) return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n      \
    \  if (lst.All(x => x % 2L == 0L)) {\n            long[] a = lst.Where(x => x\
    \ < 0L).ToArray();\n            long[] b = lst.Where(x => x > 0L).ToArray();\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(\n             \
    \   a.Max() == 0L ? null : (Nullable<long>)a.Max(),\n                b.Min() ==\
    \ 0L ? null : (Nullable<long>)b.Min());\n        }\n        return null;", " \
    \       bool hasNegative = false;\n        bool hasPositive = false;\n       \
    \ long largest = null;\n        long smallest = null;\n        foreach (long i\
    \ in lst) {\n            if (i < 0L) {\n                hasNegative = true;\n\
    \            }\n            if (i > 0L) {\n                hasPositive = true;\n\
    \            }\n            if (largest == null || i > largest) {\n          \
    \      largest = i;\n            }\n            if (smallest == null || i < smallest)\
    \ {\n                smallest = i;\n            }\n        }\n        if (hasNegative\
    \ && hasPositive) {\n            return Tuple.Create(null, smallest);\n      \
    \  }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        if (lst.Count == 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        var smallest = lst[0];\n  \
    \      var largest = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n\
    \            smallest = Math.Min(smallest, lst[i]);\n            largest = Math.Max(largest,\
    \ lst[i]);\n        }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(smallest\
    \ == null ? null : (long?)smallest, largest == null ? null : (long?)largest);",
  "        long max;\n        long min;\n\n        // If there are no integers in\
    \ the list, return null for the largest and smallest integers.\n        if (lst.Count\
    \ <= 0) {\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n\n        // Get maximum and minimum in the list.\n     \
    \   max = lst.Max();\n        min = lst.Min();\n\n        // If there is only\
    \ one integer in the list, return its values.\n        if (lst.Count == 1) {\n\
    \            return Tuple.Create<Nullable<long>, Nullable<long>>(max, min);\n\
    \        }\n\n        // Return null to indicate there is no negative or positive\
    \ integer in the list.\n        if (max <= 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n\n        if (min >= 0) {\n       \
    \     return Tuple.Create<Nullable<long>, Nullable<long>>(max, min);\n       \
    \ }\n\n        // If there are no negative or positive integers in the list, return\
    \ null for the largest and smallest integers.\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);", "        if (lst.Count == 0) return Tuple.Create<Nullable<long>>(null,\
    \ null);\n        long greatest = lst.First();\n        long lowest = lst.First();\n\
    \        for (int i = 1; i < lst.Count; ++i) {\n            long current = lst[i];\n\
    \            if (current < lowest) lowest = current;\n            if (current\
    \ > greatest) greatest = current;\n        }\n        return Tuple.Create<Nullable<long>>(null,\
    \ greatest);", "        var negInts = lst.Where(l => l < 0L).ToArray();\n    \
    \    var posInts = lst.Where(l => l > 0L).ToArray();\n        if (negInts.Length\
    \ == 0 || posInts.Length == 0) return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        var ints = negInts.Concat(posInts).ToArray();\n\
    \        if (ints.Length < 2) return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        var largest = ints.Max();\n        var smallest\
    \ = ints.Min();\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        IEnumerable<long> negatives = lst.Where(i => i < 0);\n\
    \        if (negatives.Count() > 0) {\n            Nullable<long> b = null;\n\
    \            foreach (long n in negatives.OrderByDescending()) {\n           \
    \     if (b == null || n < b.Value) {\n                    b = n;\n          \
    \      }\n            }\n            if (b != null) {\n                return\
    \ Tuple.Create(b, lst.Min());\n            } else {\n                return Tuple.Create<long>(null\
    \ as Nullable<long>, (long)lst.Min());\n            }\n        }\n        IEnumerable<long>\
    \ positives = lst.Where(i => i >= 0);\n        if (positives.Count() > 0) {\n\
    \            Nullable<long> a = null;\n            foreach (long n in positives.OrderBy(n\
    \ => n)) {\n                if (a == null || n > a.Value) {\n                \
    \    a = n;\n                }\n            }\n            if (a != null) {\n\
    \                return Tuple.Create(a, lst.Max());\n            } else {\n  \
    \              return Tuple.Create<long>(null as Nullable<long>, (long)lst.Max());\n\
    \            }\n        }\n        return Tuple.Create<long>(null as Nullable<long>,\
    \ (long)lst.Max());", "        if (lst.Count == 0)\n            return null;\n\
    \n        int largestIndex = -1;\n        long largestValue = lst[0];\n      \
    \  for (int i = 0; i < lst.Count; i++)\n        {\n            long curValue =\
    \ lst[i];\n            if (curValue > largestValue)\n            {\n         \
    \       largestValue = curValue;\n                largestIndex = i;\n        \
    \    }\n        }\n\n        // If there are no negative numbers, return null\n\
    \        if (largestValue < 0)\n            return null;\n\n        int smallestIndex\
    \ = -1;\n        long smallestValue = lst[0];\n        for (int i = 0; i < lst.Count;\
    \ i++)\n        {\n            long curValue = lst[i];\n            if (curValue\
    \ < smallestValue)\n            {\n                smallestValue = curValue;\n\
    \                smallestIndex = i;\n            }\n        }\n\n        // If\
    \ there are no positive numbers, return null\n        if (smallestValue < 0)\n\
    \            return null;\n\n        // If we're at the end, both should be null\n\
    \        if (smallestIndex == lst.Count && largestIndex == lst.Count)\n      \
    \      return null;\n\n        // Otherwise use tuple\n        return Tuple.Create(Nullable<long>((long)smallestValue),\
    \ (long)largestValue);", "        long a = null;\n        long b = null;\n   \
    \     if (lst == null) return null;\n        for (int i = 0; i < lst.Count; i++)\
    \ {\n            long x = lst[i];\n            if (x < 0) {\n                if\
    \ (a < 0) a = x;\n            } else {\n                if (b < x) b = x;\n  \
    \          }\n        }\n        if (a > b) return Tuple.Create((Nullable<long>)null,\
    \ b);\n        else return Tuple.Create((Nullable<long>)null, a);", "        //\
    \ Get the list of negative numbers from lst\n        var negLst = lst.Where(x\
    \ => x < 0L).ToList();\n        // Get the list of positive numbers from lst\n\
    \        var posLst = lst.Where(x => x >= 0L).ToList();\n\n        if (negLst.Count\
    \ == 0 && posLst.Count == 0)\n            return null;\n\n        // Get the max\
    \ and min of negative and positive numbers\n        var negMax = negLst.Max();\n\
    \        var negMin = negLst.Min();\n        var posMax = posLst.Max();\n    \
    \    var posMin = posLst.Min();\n\n        // If there is only a single number\
    \ in the list, return a null tuple\n        if (negLst.Count == 1 && posLst.Count\
    \ == 1)\n            return null;\n\n        // If there are only negative numbers\
    \ in the list, return a tuple containing (Nullable<long>)null and a number equal\
    \ to negMax\n        if (negLst.Count == 0)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, negMax);\n\n        // If there are only positive numbers\
    \ in the list, return a tuple containing (Nullable<long>)null and a number equal\
    \ to posMax\n        if (posLst.Count == 0)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, posMax);\n\n        // If there are both negative and\
    \ positive numbers in the list, return a tuple containing (Nullable<long>)null\
    \ and a number equal to the min between negMax and posMax\n        return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, Math.Min(negMax, posMax));", " \
    \       var min = lst.Min();\n        var max = lst.Max();\n        var minValues\
    \ = lst.Where(x => x < min);\n        var maxValues = lst.Where(x => x > max);\n\
    \        if (minValues.Count() == 0 || maxValues.Count() == 0)\n            return\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        var minMaxValues\
    \ = minValues.Concat(maxValues);\n        if (minMaxValues.Count() == 0)\n   \
    \         return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n    \
    \    long max = 0;\n        long min = Long.MaxValue;\n        foreach (var i\
    \ in minMaxValues)\n        {\n            if (i > max)\n            {\n     \
    \           max = i;\n            }\n            if (i < min)\n            {\n\
    \                min = i;\n            }\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(\n            min.HasValue ? min.Value : null,\n           \
    \ max.HasValue ? max.Value : null);", "        // Solution 1: Sort the list\n\
    \        //var sortedLst = lst.OrderBy(l => l, System.Collections.Generic.SortOrder.Descending).ToList();\n\
    \        //if (sortedLst.Count == 0) { return null; } // no negative number\n\
    \        //return sortedLst[0].CompareTo(sortedLst[sortedLst.Count - 1]) == 1\
    \ ? null : sortedLst[sortedLst.Count - 1].CompareTo(sortedLst[0]) > 0 ? new Tuple<Nullable<long>,\
    \ Nullable<long>>(sortedLst[0], sortedLst[sortedLst.Count - 1]) : new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        \n        // Solution 2: Quick sort\n\
    \        var pivot = lst.Max();\n        var middleIndex = lst.IndexOf(pivot);\n\
    \        var left = lst.Take(middleIndex);\n        var right = lst.Skip(middleIndex).Take(1);\n\
    \        if (left.Count() == 0 && right.Count() == 0) {\n            return null;\
    \ // no negative number\n        }\n        if (left.Count() == 0) {\n       \
    \     return new Tuple<Nullable<long>, Nullable<long>>(null, right.CompareTo(pivot)\
    \ < 0 ? null : right);\n        }\n        if (right.Count() == 0) {\n       \
    \     return new Tuple<Nullable<long>, Nullable<long>>(left, null); // no positive\
    \ number\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(left[0].CompareTo(pivot)\
    \ < 0 ? null : left[0], right[0].CompareTo(pivot) < 0 ? null : right[0]);", " \
    \       Nullable<long> max = null;\n        Nullable<long> min = null;\n     \
    \   foreach (var i in lst) {\n            if (i > max) {\n                max\
    \ = i;\n            }\n            if (i < min) {\n                min = i;\n\
    \            }\n        }\n        if (min == null) {\n            return Tuple.Create(Nullable<long>.None,\
    \ Nullable<long>.None);\n        }\n        if (max == null) {\n            return\
    \ Tuple.Create(min, null);\n        }\n        return Tuple.Create(min, max);",
  "        Nullable<long> nul = null;\n        Nullable<long> un = null;\n       \
    \ Nullable<long> nl = null;\n        Nullable<long> nn = null;\n        Nullable<long>\
    \ nnnl = null;\n        Nullable<long> nnnnn = null;\n        foreach (long i\
    \ in lst) {\n            if (i < 0) {\n                if (nul == null) nul =\
    \ i;\n                else un = i;\n            } else {\n                if (nl\
    \ == null) nl = i;\n                else nn = i;\n            }\n        }\n \
    \       if (nul != null) un = nul;\n        if (nl != null) nn = nl;\n       \
    \ if (nn != null) nnnl = nn;\n        if (nnnl != null) nnnnn = nnnl;\n      \
    \  return Tuple.Create(un, nn);", "        long[] lstAsArray = lst.ToArray();\n\
    \        long[] lstAsArraySorted = lstAsArray.OrderBy(x => x).ToArray();\n   \
    \     if (lstAsArraySorted.Length > 0) {\n            long aMinusBiggest = lstAsArraySorted[0];\n\
    \            long bMinusSmallst = lstAsArray[0];\n            foreach (long x\
    \ in lstAsArraySorted) {\n                if (x < aMinusBiggest) {\n         \
    \           aMinusBiggest = x;\n                }\n                else if (x\
    \ > bMinusSmallst) {\n                    bMinusSmallst = x;\n               \
    \ }\n            }\n            return Tuple.Create<Nullable<long>, Nullable<long>>(\n\
    \                new Nullable<long>(aMinusBiggest),\n                new Nullable<long>(bMinusSmallst)\n\
    \            );\n        }\n        else {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }", "        var max = lst.Max();\n  \
    \      var min = lst.Min();\n\n        if (max == min)\n            return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, null);\n        else if (max < 0)\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(null, min);\n  \
    \      else\n            return new Tuple<Nullable<long>, Nullable<long>>(max,\
    \ null);", "        // Solution 1:\n        var sorted = lst.OrderBy(x => x).ToList();\n\
    \        var minPos = sorted.IndexOf(sorted[0]);\n        var maxPos = sorted.IndexOf(sorted[lst.Count-1]);\n\
    \        return Tuple.Create(\n            sorted[minPos <= maxPos ? minPos :\
    \ maxPos].HasValue ? sorted[minPos <= maxPos ? minPos : maxPos].Value : null,\
    \ \n            sorted[maxPos >= minPos ? maxPos : minPos].HasValue ? sorted[maxPos\
    \ >= minPos ? maxPos : minPos].Value : null);", "        \n        // Start out\
    \ with an empty set.\n        var negativeSet = new HashSet<long>();\n       \
    \ var positiveSet = new HashSet<long>();\n\n        // Add the smallest and largest\
    \ integer to the set.\n        lst.ForEach(num =>\n        {\n            if (num\
    \ < 0) negativeSet.Add(num);\n            if (num > 0) positiveSet.Add(num);\n\
    \        });\n\n        // Return the first one in the set.\n        if (negativeSet.Count\
    \ > 0) return Tuple.Create(null, negativeSet.First());\n        if (positiveSet.Count\
    \ > 0) return Tuple.Create(null, positiveSet.First());\n        return Tuple.Create(null,\
    \ null);", "        // TODO: Write the code here.\n        return null;", "  \
    \      long largest = lst.Max();\n        long smallest = lst.Min();\n\n     \
    \   if (largest < smallest)\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n\n        if (largest == 0)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, smallest);", "        if (lst.Count == 0)\n          \
    \  return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        var\
    \ list = lst.ToArray();\n        var sortedList = list.OrderBy(i => (long)i).ToArray();\n\
    \        var maxPos = -1;\n        var minPos = 1;\n        for (var i = 0; i\
    \ < sortedList.Length; i++) {\n            if (sortedList[i] > maxPos) {\n   \
    \             maxPos = sortedList[i];\n            }\n            if (sortedList[i]\
    \ < minPos) {\n                minPos = sortedList[i];\n            }\n      \
    \  }\n        if (minPos == 0)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)maxPos,\
    \ (Nullable<long>)minPos);", "        long maxNegative = 0;\n        long maxPositive\
    \ = 0;\n        long minNegative = 0;\n        long minPositive = 0;\n       \
    \ foreach (long n in lst) {\n            if (n < 0) maxNegative = n;\n       \
    \     else if (n > 0) maxPositive = n;\n            else {\n                if\
    \ (n < minNegative) minNegative = n;\n                else if (n > minPositive)\
    \ minPositive = n;\n            }\n        }\n        if (minNegative >= minPositive)\
    \ return Tuple.Create((Nullable<long>)null, minNegative);\n        return Tuple.Create((Nullable<long>)null,\
    \ maxPositive);", "        var list = lst\n            .Where(x => x != 0)\n \
    \           .OrderBy(x => x);\n        var firstNum = list.FirstOrDefault();\n\
    \        var secondNum = list.LastOrDefault();\n        if ((firstNum == default(long))\
    \ && (secondNum == default(long)))\n            return Tuple.Create((Nullable<long>)null,\
    \ null);\n        else if ((firstNum == default(long)) && (secondNum != default(long)))\n\
    \            return Tuple.Create((Nullable<long>)null, secondNum);\n        else\
    \ if ((firstNum != default(long)) && (secondNum == default(long)))\n         \
    \   return Tuple.Create(firstNum, (Nullable<long>)null);\n        else\n     \
    \       return Tuple.Create(firstNum, secondNum);", "        long largest = 0;\n\
    \        long smallest = Long.MaxValue;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            long num = lst[i];\n            if (num < 0) {\n       \
    \         largest = num;\n                if (smallest > num) {\n            \
    \        smallest = num;\n                }\n            } else if (num > 0) {\n\
    \                largest = largest;\n                smallest = smallest;\n  \
    \          }\n        }\n        return Tuple.Create(largest, smallest);", " \
    \       var negative = lst.Where(x => x < 0);\n        var positive = lst.Where(x\
    \ => x >= 0);\n        if (negative.Count() > 0)\n            return Tuple.Create(null,\
    \ negative.Max());\n        if (positive.Count() > 0)\n            return Tuple.Create(null,\
    \ positive.Min());\n        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);",
  "        var res = lst.Aggregate((max, cur) => {\n            if (cur < 0) max =\
    \ cur;\n            if (cur > 0) min = cur;\n            return max;\n       \
    \ });\n        if (res == 0) return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        return new Tuple<Nullable<long>, Nullable<long>>(res, Math.Min(res,\
    \ lst[0]));", "        // Your code here\n        long largest = lst.First();\n\
    \        long smallest = lst.Last();\n        if (lst.Count > 1) {\n         \
    \   foreach (var i in lst) {\n                if (i > largest && i < smallest)\
    \ {\n                    largest = i;\n                }\n                if (i\
    \ < largest && i > smallest) {\n                    smallest = i;\n          \
    \      }\n            }\n        }\n        if (largest == 0) {\n            return\
    \ new Tuple<long?, long?>(null, null);\n        }\n        if (smallest < 0) {\n\
    \            return new Tuple<long?, long?>(null, smallest);\n        }\n    \
    \    return new Tuple<long?, long?>(largest, null);", "        long largest =\
    \ long.MaxValue;\n        long smallest = long.MinValue;\n        bool first =\
    \ true;\n        foreach (long n in lst) {\n            if (n < 0)\n         \
    \       throw new ArgumentOutOfRangeException();\n            if (first) {\n \
    \               smallest = n;\n                largest = n;\n                first\
    \ = false;\n            } else {\n                if (n < smallest)\n        \
    \            smallest = n;\n                if (n > largest)\n               \
    \     largest = n;\n            }\n        }\n        if (smallest == long.MinValue)\n\
    \            return Tuple.Create<Nullable<long>, Nullable<long>>((Nullable<long>)null,\
    \ null);\n        if (largest == long.MaxValue)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>((Nullable<long>)null, null);\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(smallest, largest);", "        long largest = lst.FirstOrDefault();\n\
    \        long smallest = lst.LastOrDefault();\n        if (largest < smallest)\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(null, smallest);\n\
    \        if (largest > 0)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ largest);\n        \n        Nullable<long> largestNegative = new Nullable<long>();\n\
    \        Nullable<long> smallestPositive = new Nullable<long>();\n        if (lst.Any(x\
    \ => x < 0))\n            largestNegative = lst.First(x => x < 0);\n        if\
    \ (lst.Any(x => x > 0))\n            smallestPositive = lst.Last(x => x > 0);\n\
    \        if (largestNegative == null && smallestPositive == null)\n          \
    \  return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        if (largestNegative\
    \ == null)\n            return new Tuple<Nullable<long>, Nullable<long>>(smallestPositive,\
    \ null);\n        if (smallestPositive == null)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, largestNegative);\n        \n        if (largest < smallestPositive)\n\
    \            smallest = smallestPositive;\n        if (largest > smallestPositive)\n\
    \            largest = largestPositive;\n        if (largest < smallestNegative)\n\
    \            smallest = smallestNegative;\n        if (largest > smallestNegative)\n\
    \            largest = largestNegative;\n        \n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        int maxNegative, minPositive;\n\
    \        long maxNegativeLong = 0, minPositiveLong = lst[0], positiveMax = lst[0];\n\
    \        foreach (long i in lst) {\n            bool negative = (i < 0);\n   \
    \         long currentLong = i;\n            if (negative) {\n               \
    \ currentLong = -i;\n            }\n            if (currentLong > maxNegativeLong)\
    \ {\n                maxNegativeLong = currentLong;\n            }\n         \
    \   if (currentLong < minPositiveLong) {\n                minPositiveLong = currentLong;\n\
    \            }\n            if (negative && (currentLong > positiveMax)) {\n \
    \               positiveMax = currentLong;\n            }\n        }\n       \
    \ if (maxNegativeLong > 0) {\n            maxNegative = (int)maxNegativeLong;\n\
    \        } else {\n            maxNegative = (int)0;\n        }\n        if (minPositiveLong\
    \ < positiveMax) {\n            minPositive = (int)positiveMax;\n        } else\
    \ {\n            minPositive = (int)0;\n        }\n        return Tuple.Create(maxNegative,\
    \ minPositive);", "        long[] numbers = lst.ToArray();\n        int minPositive\
    \ = -1;\n        long maxNegative = long.MinValue;\n        bool flag = false;\n\
    \        for (int i = 0; i < numbers.Length; i++) {\n            long number =\
    \ numbers[i];\n            if (number < 0 && number > maxNegative) {\n       \
    \         maxNegative = number;\n                flag = true;\n            } else\
    \ if (number > 0 && number < minPositive) {\n                minPositive = number;\n\
    \            }\n        }\n        if (minPositive > maxNegative) {\n        \
    \    return null;\n        }\n        if (minPositive == maxNegative) {\n    \
    \        return Tuple.Create(null, minPositive);\n        }\n        return Tuple.Create((Nullable<long>)maxNegative,\
    \ (Nullable<long>)minPositive);", "        int? largestNegativeInteger = lst.Aggregate((a,\
    \ b) => a > b ? a : b);\n        if (largestNegativeInteger == null) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n\n        long? largestPositiveInteger = lst.Aggregate((a,\
    \ b) => a < b ? a : b);\n        if (largestPositiveInteger == null) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n\n        int? smallestNegativeInteger = lst.Aggregate((a,\
    \ b) => a < b ? a : b);\n        if (smallestNegativeInteger == null) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n\n        long? smallestPositiveInteger = lst.Aggregate((a,\
    \ b) => a > b ? a : b);\n        if (smallestPositiveInteger == null) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n\n        Tuple<Nullable<long>, Nullable<long>> result\
    \ = Tuple.Create(largestNegativeInteger, smallestPositiveInteger);\n        return\
    \ result;", "        if (lst?.Any() ?? false == true) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        long largestNegativeInteger = long.MaxValue;\n\
    \        long smallestPositiveInteger = long.MinValue;\n        long? largestNegativeIntegerOrNull\
    \ = null;\n        long? smallestPositiveIntegerOrNull = null;\n        bool positiveIntegersExist\
    \ = false;\n        bool negativeIntegersExist = false;\n        foreach (long\
    \ x in lst) {\n            if (x < 0L) {\n                if (largestNegativeInteger\
    \ < 0L) {\n                    largestNegativeInteger = x;\n                 \
    \   largestNegativeIntegerOrNull = x;\n                }\n                else\
    \ {\n                    largestNegativeIntegerOrNull = largestNegativeInteger;\n\
    \                    largestNegativeInteger = x;\n                }\n        \
    \    }\n            if (x > 0L) {\n                if (smallestPositiveInteger\
    \ > 0L) {\n                    smallestPositiveInteger = x;\n                \
    \    smallestPositiveIntegerOrNull = x;\n                }\n                else\
    \ {\n                    smallestPositiveIntegerOrNull = smallestPositiveInteger;\n\
    \                    smallestPositiveInteger = x;\n                }\n       \
    \     }\n            if (x < 0L && x > 0L) {\n                positiveIntegersExist\
    \ = true;\n            }\n            if (x < 0L || x > 0L) {\n              \
    \  negativeIntegersExist = true;\n            }\n        }\n        if (negativeIntegersExist\
    \ && smallestPositiveInteger > largestNegativeInteger) {\n            return Tuple.Create((Nullable<long>)null,\
    \ smallestPositiveInteger);\n        }\n        if (positiveIntegersExist && smallestPositiveInteger\
    \ < largestNegativeInteger) {\n            return Tuple.Create((Nullable<long>)null,\
    \ largestNegativeInteger);\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ largestNegativeIntegerOrNull);", '        return LargestSmallestIntegers(lst,
    0);', "        if (lst.Count == 0) {\n            return null;\n        }\n  \
    \      long largest = -9223372036854775808L;\n        long smallest = 9223372036854775807L;\n\
    \        bool foundNegative = false;\n        bool foundPositive = false;\n  \
    \      foreach (var item in lst) {\n            if (item < 0) {\n            \
    \    if (!foundNegative) {\n                    largest = item;\n            \
    \        foundNegative = true;\n                } else {\n                   \
    \ return null;\n                }\n            } else if (item > 0) {\n      \
    \          if (!foundPositive) {\n                    smallest = item;\n     \
    \               foundPositive = true;\n                } else {\n            \
    \        return null;\n                }\n            } else {\n             \
    \   return null;\n            }\n        }\n        return Tuple.Create(smallest,\
    \ largest);", "        long[] ints = lst.ToArray();\n        if (ints.Length <\
    \ 1 || ints.Length > 256) {\n            return Tuple.Create<Nullable<long>>(null,\
    \ null);\n        }\n\n        // Get smallest and largest int\n        long smallest\
    \ = ints[0];\n        long largest = ints[0];\n        for (int i = 1; i < ints.Length;\
    \ i++) {\n            if (ints[i] < smallest) {\n                smallest = ints[i];\n\
    \            }\n            if (ints[i] > largest) {\n                largest\
    \ = ints[i];\n            }\n        }\n\n        // If smallest or largest are\
    \ null, return them as null\n        if (smallest == 0 || largest == 0) {\n  \
    \          return Tuple.Create<Nullable<long>>(null, null);\n        }\n\n   \
    \     // Get max of negative and positive values\n        long min = Int32.MinValue;\n\
    \        long max = Int32.MaxValue;\n        for (int i = 0; i < ints.Length;\
    \ i++) {\n            if (ints[i] < 0) {\n                if (Int32.TryParse(Math.Abs(ints[i]).ToString(),\
    \ out int intAbs)) {\n                    if (intAbs > min) {\n              \
    \          min = intAbs;\n                    }\n                }\n         \
    \   } else {\n                if (Int32.TryParse(Math.Abs(ints[i]).ToString(),\
    \ out int intAbs)) {\n                    if (intAbs < max) {\n              \
    \          max = intAbs;\n                    }\n                }\n         \
    \   }\n        }\n\n        // If min and max are equal, return them as null\n\
    \        if (min == max) {\n            return Tuple.Create<Nullable<long>>(null,\
    \ null);\n        }\n\n        // Get tuple with largest (min) and smallest (max)\
    \ value\n        long maxSmallest = Int32.MaxValue;\n        long minLargest =\
    \ Int32.MinValue;\n        for (int i = 0; i < ints.Length; i++) {\n         \
    \   if (ints[i] < minLargest) {\n                minLargest = ints[i];\n     \
    \       }\n            if (ints[i] > maxSmallest) {\n                maxSmallest\
    \ = ints[i];\n            }\n        }\n        long maxLargest = Int32.MaxValue;\n\
    \        for (int i = 0; i < ints.Length; i++) {\n            if (ints[i] < maxLargest)\
    \ {\n                maxLargest = ints[i];\n            }\n        }\n       \
    \ return Tuple.Create<Nullable<long>>(maxSmallest, minLargest);", "        var\
    \ negative = new List<long>();\n        var positive = new List<long>();\n   \
    \     if (lst.Any()) {\n            var max = lst.Max();\n            var min\
    \ = lst.Min();\n            if (max < 0) {\n                negative.Add(max);\n\
    \            }\n            if (min > 0) {\n                positive.Add(min);\n\
    \            }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(\n\
    \            negative.Any() ? new Nullable<long>(negative.Max()) : null,\n   \
    \         positive.Any() ? new Nullable<long>(positive.Min()) : null);", "   \
    \     if (lst.Count < 2)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n\n        var a = lst[0];\n        var b = lst[1];\n\n        if (a\
    \ < 0)\n            a = null;\n\n        if (b > 0)\n            b = null;\n\n\
    \        return Tuple.Create(a, b);", "        if (lst.Count == 0) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        var largest = lst[0];\n        var smallest\
    \ = lst[0];\n        for (int i = 1; i < lst.Count; ++i) {\n            var num\
    \ = lst[i];\n            if (num < smallest) smallest = num;\n            if (num\
    \ > largest) largest = num;\n        }\n        return Tuple.Create((Nullable<long>)largest,\
    \ (Nullable<long>)smallest);", "        // If there are no items, return the empty\
    \ tuple\n        if (lst.Count == 0) {\n            return Tuple.Create(new Nullable<long>(),\
    \ new Nullable<long>());\n        }\n        // Find the minimum and maximum items\
    \ in the list\n        long minValue = lst.Min();\n        long maxValue = lst.Max();\n\
    \        // If there are no positive integers in the list, return them as null\n\
    \        if (minValue == 0) {\n            return Tuple.Create(new Nullable<long>(),\
    \ new Nullable<long>());\n        }\n        // If there are no negative integers\
    \ in the list, return them as null\n        if (maxValue < 0) {\n            return\
    \ Tuple.Create(new Nullable<long>(), new Nullable<long>());\n        }\n     \
    \   // If there are two items, return them as (null, null)\n        if (lst.Count\
    \ == 1) {\n            return Tuple.Create(new Nullable<long>(), new Nullable<long>());\n\
    \        }\n        // Find the largest negative integer in the list\n       \
    \ long maxNeg = 0;\n        foreach (long value in lst) {\n            // If the\
    \ value is negative, find the largest negative integer so far\n            if\
    \ (value < 0) {\n                if (maxNeg == 0) {\n                    maxNeg\
    \ = value;\n                }\n                else {\n                    maxNeg\
    \ = Math.Max(maxNeg, value);\n                }\n            }\n        }\n  \
    \      // If there are no negative integers in the list, return them as null\n\
    \        if (maxNeg == 0) {\n            return Tuple.Create(new Nullable<long>(),\
    \ new Nullable<long>());\n        }\n        // Find the smallest positive integer\
    \ in the list\n        long minPos = 0;\n        foreach (long value in lst) {\n\
    \            // If the value is positive, find the smallest positive integer so\
    \ far\n            if (value > 0) {\n                if (minPos == 0) {\n    \
    \                minPos = value;\n                }\n                else {\n\
    \                    minPos = Math.Min(minPos, value);\n                }\n  \
    \          }\n        }\n        // If there are no positive integers in the list,\
    \ return them as null\n        if (minPos == 0) {\n            return Tuple.Create(new\
    \ Nullable<long>(), new Nullable<long>());\n        }\n        // Return the tuple\
    \ (maxNeg, maxPos) as (Nullable<long>, Nullable<long>)\n        return Tuple.Create(new\
    \ Nullable<long>(maxNeg), new Nullable<long>(maxPos));", "        long[] nums\
    \ = new long[lst.Count];\n        nums.CopyTo(nums, 0);\n        int signCount\
    \ = 0, negativeCount = 0;\n        foreach (long n in nums)\n        {\n     \
    \       long m = n;\n            if (n < 0L)\n            {\n                if\
    \ (signCount == 0)\n                {\n                    signCount = 1;\n  \
    \              }\n                negativeCount++;\n            }\n          \
    \  else if (m > 0L)\n            {\n                signCount++;\n           \
    \ }\n        }\n\n        int positiveCount = lst.Count - negativeCount;\n   \
    \     if (positiveCount != lst.Count)\n        {\n            throw new InvalidOperationException(\"\
    There should be no duplicates in the list.\");\n        }\n\n        long[] neg\
    \ = new long[negativeCount];\n        long[] pos = new long[positiveCount];\n\
    \        int i = 0;\n        foreach (long n in nums)\n        {\n           \
    \ if (n < 0L)\n            {\n                neg[i++] = n;\n            }\n \
    \           else if (m > 0L)\n            {\n                pos[i++] = n;\n \
    \           }\n        }\n\n        Array.Sort(pos);\n        Array.Sort(neg);\n\
    \n        // We now have two lists: pos and neg. Return the smaller one.\n   \
    \     if (pos.Length > neg.Length)\n        {\n            Tuple<Nullable<long>,\
    \ Nullable<long>> tuple = Tuple.Create((Nullable<long>)null, pos[pos.Length -\
    \ 1]);\n            return tuple;\n        }\n        else if (pos.Length < neg.Length)\n\
    \        {\n            Tuple<Nullable<long>, Nullable<long>> tuple = Tuple.Create((Nullable<long>)null,\
    \ neg[neg.Length - 1]);\n            return tuple;\n        }\n        else\n\
    \        {\n            Tuple<Nullable<long>, Nullable<long>> tuple = Tuple.Create((Nullable<long>)null,\
    \ pos[pos.Length - 1]);\n            return tuple;\n        }", "        if (lst.Any())\n\
    \        {\n            var maxNegative = lst.Max(x => x.CompareTo(new long?(-x)))\
    \ ?? new long?(-0);\n            var minPositive = lst.Min(x => x.CompareTo(new\
    \ long?(x))) ?? new long?(0);\n            if (maxNegative.HasValue || minPositive.HasValue)\n\
    \                return Tuple.Create(maxNegative, minPositive);\n        }\n \
    \       return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);", " \
    \       if (lst.Count == 0) return null;\n        var largest = lst.Max();\n \
    \       var smallest = lst.Min();\n        if (smallest < 0 && largest > 0) return\
    \ null;\n        if (smallest > 0 && largest < 0) return null;\n        return\
    \ Tuple.Create(smallest, largest);", "        long min = 0;\n        long max\
    \ = 0;\n        foreach (long n in lst) {\n            if (n < min) {\n      \
    \          min = n;\n            }\n            else if (n > max) {\n        \
    \        max = n;\n            }\n        }\n        return Tuple.Create(min <\
    \ 0, max > 0);", "        if (lst.Count == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        long[] arr = new long[lst.Count];\n\
    \        lst.CopyTo(arr, 0);\n        if (arr[0] < 0L) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        int min = 0;\n        int max = arr.Length\
    \ - 1;\n        while (min < max) {\n            int mid = (min + max) >>> 1;\n\
    \            if (arr[mid] < 0L) {\n                min = mid + 1;\n          \
    \  }\n            else if (arr[mid] > 0L) {\n                max = mid - 1;\n\
    \            }\n            else {\n                min = mid;\n             \
    \   long max = arr[max];\n                for (int i = min; i <= max; i++) {\n\
    \                    arr[max] = arr[i];\n                }\n                arr[min]\
    \ = -arr[min];\n                if (arr[min] > 0L) {\n                    max\
    \ = min;\n                }\n                else {\n                    min =\
    \ 0;\n                    long min = arr[min];\n                    for (int i\
    \ = max; i >= min; i--) {\n                        arr[i] = arr[i^1];\n      \
    \              }\n                    arr[max] = -arr[max];\n                \
    \    if (arr[max] < 0L) {\n                        min = max + 1;\n          \
    \          }\n                }\n                return Tuple.Create((Nullable<long>)(long)Math.Abs(arr[min]),\
    \ (Nullable<long>)Math.Abs(arr[max]));\n            }\n        }\n        return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);", "        if (lst.Count\
    \ < 1) {\n            return null;\n        }\n\n        long minLargest = lst[0];\n\
    \        long maxLargest = lst[0];\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            long largest = lst[i];\n            long largestSmallest = lst[i\
    \ - 1];\n            if (largest < minLargest || largest > maxLargest) {\n   \
    \             if (largest < minLargest) {\n                    minLargest = largest;\n\
    \                }\n\n                if (largest > maxLargest) {\n          \
    \          maxLargest = largest;\n                }\n            }\n         \
    \   else if (largest == largestSmallest) {\n                if (largest < minLargest)\
    \ {\n                    minLargest = largest;\n                }\n\n        \
    \        if (largest > maxLargest) {\n                    maxLargest = largest;\n\
    \                }\n            }\n            else {\n                if (largest\
    \ > largestSmallest) {\n                    largestSmallest = largest;\n     \
    \           }\n            }\n        }\n\n        return Tuple.Create<Nullable<long>>(null,\
    \ minLargest);", "        if (lst == null || lst.Count == 0) {\n            return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        }\n     \
    \   Nullable<long> max;\n        Nullable<long> min;\n        long largest = 0;\n\
    \        long smallest = 0;\n        foreach (var value in lst) {\n          \
    \  if (value.CompareTo(largest) < 0) {\n                largest = value;\n   \
    \         }\n            if (value.CompareTo(smallest) > 0) {\n              \
    \  smallest = value;\n            }\n        }\n        if (largest == null) {\n\
    \            return LargestSmallestIntegers(lst.Where(x => x.CompareTo(smallest)\
    \ == 0));\n        }\n        if (smallest == null) {\n            return LargestSmallestIntegers(lst.Where(x\
    \ => x.CompareTo(largest) == 0));\n        }\n        if (largest > smallest)\
    \ {\n            return LargestSmallestIntegers(lst.Where(x => x.CompareTo(smallest)\
    \ == 0));\n        }\n        if (largest < smallest) {\n            return LargestSmallestIntegers(lst.Where(x\
    \ => x.CompareTo(largest) == 0));\n        }\n        return LargestSmallestIntegers(lst.Where(x\
    \ => x != largest));", "        if (lst.Count <= 0)\n            return null;\n\
    \        var result = new List<long>();\n        bool isNegative = true;\n   \
    \     var maxNegative = long.MinValue;\n        var maxPositive = long.MaxValue;\n\
    \        var minNegative = long.MinValue;\n        var minPositive = long.MaxValue;\n\
    \        foreach (long value in lst) {\n            if (isNegative && (value <\
    \ 0L)) {\n                isNegative = false;\n                minNegative = long.MaxValue;\n\
    \                minPositive = long.MinValue;\n            }\n            else\
    \ if (isNegative && (value < minNegative)) {\n                minNegative = value;\n\
    \            }\n            else if (isNegative && (value < maxNegative)) {\n\
    \                maxNegative = value;\n            }\n            if (isPositive\
    \ && (value > 0L)) {\n                isPositive = false;\n                minPositive\
    \ = long.MaxValue;\n                minNegative = long.MinValue;\n           \
    \ }\n            else if (isPositive && (value < minPositive)) {\n           \
    \     minPositive = value;\n            }\n            else if (isPositive &&\
    \ (value > maxPositive)) {\n                maxPositive = value;\n           \
    \ }\n            result.Add(value);\n        }\n        var tuple = Tuple.Create((Nullable<long>)null,\
    \ maxPositive);\n        return tuple;", "        long[] ints = lst.ToArray();\n\
    \        long[] signs = new long[ints.Length];\n        long max = 0;\n      \
    \  long min = 0;\n        long maxAbs = 0;\n        long minAbs = 0;\n       \
    \ for (int i = 0; i < ints.Length; i++) {\n            if (ints[i] < 0)\n    \
    \            signs[i] = 1;\n            else\n                signs[i] = -1;\n\
    \            if (ints[i] > maxAbs)\n                maxAbs = ints[i];\n      \
    \      if (ints[i] < minAbs)\n                minAbs = ints[i];\n        }\n \
    \       if (maxAbs < minAbs)\n            return Tuple.Create(null, null);\n \
    \       if (maxAbs == minAbs)\n            return Tuple.Create((int?) null, (int?)\
    \ null);\n        if (maxAbs > minAbs) {\n            max = maxAbs;\n        \
    \    min = minAbs;\n            int i = 0;\n            for (i = 0; i < signs.Length;\
    \ i++)\n                if (signs[i] != 0)\n                    break;\n     \
    \       if (i == signs.Length)\n                return Tuple.Create((int?) null,\
    \ (int?) null);\n            for (i = 0; i < signs.Length; i++)\n            \
    \    if (signs[i] == 0)\n                    signs[i] = -1;\n            for (i\
    \ = 0; i < ints.Length; i++)\n                if (signs[i] == 1)\n           \
    \         ints[i] = -lints[i];\n                else\n                    ints[i]\
    \ = -(ints[i]);\n        }\n        if (maxAbs < minAbs)\n            return Tuple.Create((int?)\
    \ null, (int?) null);\n        max = maxAbs;\n        min = minAbs;\n        ints[ints.Length\
    \ - 1] = 0;\n        long temp = max;\n        temp = max / temp;\n        max\
    \ = temp;\n        temp = min;\n        temp = min / temp;\n        min = temp;\n\
    \        ints[ints.Length - 1] = max;\n        ints = ints.Select(o => (long)\
    \ o).ToArray();\n        Array.Sort(ints);\n        ints[ints.Length - 1] = min;\n\
    \        ints = ints.Select(o => (long) o).ToArray();\n        Array.Sort(ints);\n\
    \        long result = long.MinValue;\n        long resultAbs = 0;\n        for\
    \ (int i = 0; i < ints.Length; i++)\n            resultAbs += ints[i];\n     \
    \   for (int i = ints.Length - 1; i >= 0; i--) {\n            if (ints[i] < 0)\n\
    \                resultAbs += ints[i];\n            else {\n                result\
    \ = resultAbs;\n                resultAbs = ints[i];\n                break;\n\
    \            }\n        }\n        if (resultAbs != 0)\n            result = result\
    \ / resultAbs;\n        return Tuple.Create(result, (long) min);", "        if\
    \ (lst.Count > 0)\n        {\n            long a = 0;\n            long b = 0;\n\
    \            bool negative = (lst[0] < 0);\n            bool positive = (lst[0]\
    \ > 0);\n\n            for (int i = 0; i < lst.Count; ++i)\n            {\n  \
    \              if (negative)\n                {\n                    if (lst[i]\
    \ < a)\n                        a = lst[i];\n                }\n             \
    \   else\n                {\n                    if (lst[i] > b)\n           \
    \             b = lst[i];\n                }\n            }\n            return\
    \ Tuple.Create(a < b ? a : b, a > b ? b : a);\n        }\n        else\n     \
    \   {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }", "        var largest = lst.OrderByDescending(n => n).FirstOrDefault();\n\
    \        var smallest = lst.OrderBy(n => n).FirstOrDefault();\n\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);", "        long[]\
    \ numbers = new long[lst];\n        int len = lst.Count;\n        for (int i =\
    \ 0; i < len; i++) {\n            numbers[i] = lst[i];\n        }\n        Array.Sort(numbers);\n\
    \        int minIndex = numbers.Length - 1;\n        int maxIndex = 0;\n     \
    \   int minValue = 0;\n        int maxValue = numbers.Length;\n        if (numbers[minIndex]\
    \ < 0) {\n            minIndex--;\n        }\n        if (numbers[maxIndex] >\
    \ 0) {\n            maxIndex++;\n        }\n        if (minIndex > maxIndex) {\n\
    \            return null;\n        }\n        while (maxIndex > 0) {\n       \
    \     if (numbers[maxIndex] < minValue) {\n                minValue = numbers[maxIndex];\n\
    \            }\n            else if (numbers[maxIndex] > maxValue) {\n       \
    \         maxValue = numbers[maxIndex];\n            }\n            maxIndex--;\n\
    \        }\n        return Tuple.Create((Nullable<long>)maxValue, minValue);",
  "        // Write your code here\n        long result = 0;\n        foreach (var\
    \ item in lst) {\n            if (item < 0)\n                result = item;\n\
    \        }\n        return new Tuple<Nullable<long>, Nullable<long>>(result, lst.Min());",
  "        var max = lst.Max();\n        var min = lst.Min();\n        var maxNegative\
    \ = (lst.Where(num => num < 0L).Count()) > 0;\n        var minPositive = (lst.Where(num\
    \ => num > 0L).Count()) > 0;\n        return Tuple.Create<Nullable<long>, Nullable<long>>(max\
    \ < 0L ? null : max, min > 0L ? null : min);", "        if (lst.Any()) {\n   \
    \         if (lst.Count > 1) {\n                long[] arr = lst.ToArray();\n\
    \                if (arr[0] < 0) arr[0] = arr[0] * (-1);\n                if (arr[1]\
    \ > 0) arr[1] = arr[1] * (-1);\n\n                if (arr.Length > 2) {\n    \
    \                long[] arr2 = new long[2];\n                    for (int i =\
    \ 1; i < arr.Length; i++) {\n                        if (arr[i] < 0) {\n     \
    \                       arr2[0] = arr2[0] * -1;\n                            arr2[1]\
    \ = arr2[1] * -1;\n                        } else if (arr[i] > 0) {\n        \
    \                    arr2[0] = arr2[0] * -1;\n                            arr2[1]\
    \ = arr2[1] * -1;\n                        } else {\n                        \
    \    arr2[0] = arr2[0] * (-1);\n                            arr2[1] = arr2[1]\
    \ * (-1);\n                        }\n                    }\n                \
    \    if (arr2[0] > arr2[1]) {\n                        return Tuple.Create(arr2[0],\
    \ arr2[1]);\n                    } else {\n                        return Tuple.Create(arr2[1],\
    \ arr2[0]);\n                    }\n                } else {\n               \
    \     return Tuple.Create(arr[0], arr[0]);\n                }\n            } else\
    \ {\n                return Tuple.Create((long)0L, (long)0L);\n            }\n\
    \        } else {\n            return Tuple.Create((long)0L, (long)0L);\n    \
    \    }", "        // Create a variable to hold the two largest integers.\n   \
    \     long max1 = lst.Max();\n        long max2 = lst.Min();\n\n        // If\
    \ the list's length is 0, return it as null\n        if (lst.Count == 0) return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\n        // If the\
    \ list's length is 1, return the largest integer as\n        // the 'a' and the\
    \ smallest integer as the 'b'\n        if (lst.Count == 1) return Tuple.Create((Nullable<long>)lst,\
    \ max1);\n\n        // Otherwise...\n        long min1 = lst.Min();\n        long\
    \ min2 = lst.Max();\n\n        // Loop through each element, starting from the\
    \ second element\n        // and find the max and min between the current and\
    \ previous values.\n        for (int i = 2; i < lst.Count; i++) {\n          \
    \  if (lst[i - 1] < min1 || min1 == min2) min1 = lst[i];\n            if (lst[i]\
    \ > max2 || max2 == max1) max2 = lst[i];\n        }\n\n        // Return a tuple\
    \ containing the largest and smallest values.\n        return Tuple.Create((Nullable<long>)max1,\
    \ (Nullable<long>)min2);", "        var negativeMinusMax = new long[] { };\n \
    \       var positiveMinusMax = new long[] { };\n        foreach (long value in\
    \ lst) {\n            if (value < 0L) {\n                negativeMinusMax.Add(value);\n\
    \            }\n            else {\n                positiveMinusMax.Add(value);\n\
    \            }\n        }\n\n        if (negativeMinusMax.Count() > 0) {\n   \
    \         return Tuple.Create((Nullable<long>)null, Max(negativeMinusMax));\n\
    \        }\n        if (positiveMinusMax.Count() > 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ Min(positiveMinusMax));\n        }\n\n        return null;", "        if (lst.Count\
    \ == 0) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n\n        var largest = lst.Max();\n        var smallest = lst.Min();\n\
    \n        if (largest < smallest) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n\n        // If there are only positive integers,\
    \ return them both.\n        if (lst.Count == 1 && (smallest == lst.Min() || largest\
    \ == lst.Max())) {\n            return Tuple.Create((Nullable<long>)lst.First(),\
    \ (Nullable<long>)lst.First());\n        }\n\n        // Else find the largest\
    \ and smallest in two halves.\n        var middle = lst.Count / 2;\n        var\
    \ left = new List<long>(lst.Take(middle));\n        var right = new List<long>(lst.Skip(middle));\n\
    \n        var largestLeft = LargestSmallestIntegers(left);\n        var smallestLeft\
    \ = LargestSmallestIntegers(left.Reverse());\n        var largestRight = LargestSmallestIntegers(right);\n\
    \        var smallestRight = LargestSmallestIntegers(right.Reverse());\n\n   \
    \     if (largestLeft.Item1.HasValue && smallestRight.Item1.HasValue) {\n    \
    \        return Tuple.Create(largestLeft.Item1, smallestRight.Item1);\n      \
    \  }\n\n        if (largestLeft.Item1.HasValue && largestRight.Item1.HasValue)\
    \ {\n            return Tuple.Create(largestLeft.Item1, largestRight.Item1);\n\
    \        }\n\n        if (smallestLeft.Item1.HasValue && smallestRight.Item1.HasValue)\
    \ {\n            return Tuple.Create(largestLeft.Item1, smallestLeft.Item1);\n\
    \        }\n\n        return Tuple.Create(largest.Value, smallest.Value);", " \
    \       var result = new Tuple<Nullable<long>, Nullable<long>>(null, null);\n\
    \        if (lst.Count == 0) return result;\n        var positive = new List<long>();\n\
    \        var negative = new List<long>();\n        foreach (var x in lst) {\n\
    \            if (x < 0) negative.Add(x);\n            else    positive.Add(x);\n\
    \        }\n        if (negative.Count == 0) return result;\n        if (positive.Count\
    \ > negative.Count) result = new Tuple<Nullable<long>, Nullable<long>>(null, null);\n\
    \        else if (positive.Count < negative.Count) result = new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        else if (positive.Count == 0) result =\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        else    result\
    \ = new Tuple<Nullable<long>, Nullable<long>>(positive.Max(), negative.Min());\n\
    \        return result;", '        return LargestSmallestIntegers(lst, 0);', " \
    \       long maxPos = 0;\n        long minNeg = 0;\n        long minPos = 0;\n\
    \        bool isNeg = false;\n        long maxNeg = 0;\n        foreach (var i\
    \ in lst) {\n            if (i == 0) {\n                isNeg = false;\n     \
    \           continue;\n            }\n            if (isNeg) {\n             \
    \   maxNeg = Math.Max(maxNeg, i);\n                if (i < 0) {\n            \
    \        minNeg = Math.Min(minNeg, i);\n                } else {\n           \
    \         minPos = Math.Min(minPos, i);\n                }\n            } else\
    \ {\n                maxPos = Math.Max(maxPos, i);\n                if (i < 0)\
    \ {\n                    minNeg = Math.Min(minNeg, i);\n                } else\
    \ {\n                    minPos = Math.Min(minPos, i);\n                }\n  \
    \          }\n            isNeg = !isNeg;\n        }\n        if (maxNeg < 0)\
    \ maxNeg = 0;\n        if (maxPos < 0) maxPos = 0;\n        if (minNeg < 0) minNeg\
    \ = 0;\n        if (minPos < 0) minPos = 0;\n        if (maxNeg > maxPos) maxPos\
    \ = maxNeg;\n        if (minNeg > minPos) minPos = minNeg;\n        return Tuple.Create(maxPos,\
    \ minPos);", "        long max;\n        long min;\n        if (lst.Any()) {\n\
    \            max = lst.Max();\n            min = lst.Min();\n        } else {\n\
    \            return Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n\
    \        }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(max <\
    \ 0, min > 0 ? max : min);", "        Nullable<long> max = null;\n        Nullable<long>\
    \ min = null;\n        int count = lst.Count;\n        if (count < 2) {\n    \
    \        if (count == 0) {\n                return null;\n            }\n    \
    \        else {\n                return Tuple.Create<long>(max, min);\n      \
    \      }\n        }\n        else {\n            long max = lst.Max();\n     \
    \       long min = lst.Min();\n            long temp = null;\n            for\
    \ (int i = 0; i < count; ++i) {\n                temp = lst[i];\n            \
    \    if (temp < min) {\n                    min = temp;\n                }\n \
    \               else if (temp > max) {\n                    max = temp;\n    \
    \            }\n            }\n            return Tuple.Create<long>(max, min);\n\
    \        }", "        if (lst == null) return null;\n        long a = Math.Max(-1L,\
    \ lst.Min());\n        long b = Math.Min(1L, lst.Max());\n        return Tuple.Create<long?>(a\
    \ > b ? a : null, b > a ? b : null);", "        Debug.Assert(lst.Count > 0);\n\
    \        if (lst.Count < 1) return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        var largest = lst.OrderByDescending(x => x).FirstOrDefault();\n\
    \        if (largest == -1) return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        var smallest = lst.OrderBy(x => x).FirstOrDefault();\n     \
    \   if (smallest == -1) return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        if (largest < smallest) return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(largest, null);\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, smallest);", "        List<long> Negatives = lst.Where(x\
    \ => x < 0).ToList();\n        if (Negatives.Count > 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ Negatives.Min());\n        List<long> Positives = lst.Where(x => x > 0).ToList();\n\
    \        if (Positives.Count > 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ Positives.Max());\n        return Tuple.Create((Nullable<long>)null, null);",
  "        long largest = lst.Min();\n        long smallest = lst.Max();\n       \
    \ if (largest < smallest) {\n            largest = smallest;\n        }\n    \
    \    return Tuple.Create((long?)largest, (long?)smallest);", "        List<long>\
    \ positive = new List<long>();\n        List<long> negative = new List<long>();\n\
    \        long maxNum = double.MinValue;\n        long minNum = double.MaxValue;\n\
    \        foreach (long x in lst) {\n            if (x < 0) {\n               \
    \ negative.Add(x);\n                maxNum = x;\n            } else {\n      \
    \          positive.Add(x);\n                minNum = x;\n            }\n    \
    \    }\n        if (negative.Count == 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        if (positive.Count == 0) {\n\
    \            return Tuple.Create<Nullable<long>, Nullable<long>>(null, maxNum);\n\
    \        }\n        long maxNumPositive = 0;\n        long minNumPositive = 0;\n\
    \        long maxNumNegative = 0;\n        long minNumNegative = 0;\n        foreach\
    \ (long x in positive) {\n            if (x >= maxNum) {\n                maxNumPositive\
    \ = x;\n            } else {\n                maxNumPositive = maxNum;\n     \
    \       }\n            if (x <= minNum) {\n                minNumPositive = x;\n\
    \            } else {\n                minNumPositive = minNum;\n            }\n\
    \        }\n        foreach (long x in negative) {\n            if (x >= maxNum)\
    \ {\n                maxNumNegative = x;\n            } else {\n             \
    \   maxNumNegative = maxNum;\n            }\n            if (x <= minNum) {\n\
    \                minNumNegative = x;\n            } else {\n                minNumNegative\
    \ = minNum;\n            }\n        }\n        Nullable<long> maxNumPositiveNullable\
    \ = new Nullable<long>(maxNumPositive);\n        Nullable<long> maxNumNegativeNullable\
    \ = new Nullable<long>(maxNumNegative);\n        Nullable<long> minNumPositiveNullable\
    \ = new Nullable<long>(minNumPositive);\n        Nullable<long> minNumNegativeNullable\
    \ = new Nullable<long>(minNumNegative);\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(maxNumPositiveNullable, maxNumNegativeNullable);", "       \
    \ IEnumerable<long> a = lst.Where(x => x < 0);\n        IEnumerable<long> b =\
    \ lst.Where(x => x > 0);\n\n        if (a != null && b != null)\n            return\
    \ Tuple.Create(a, Math.Min(b));\n        else if (a != null)\n            return\
    \ Tuple.Create(null, Math.Min(a));\n        else if (b != null)\n            return\
    \ Tuple.Create(null, (long)b.Min());\n        else\n            return Tuple.Create(null,\
    \ null);", "        if (lst.Count == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        bool isNegative = false;\n      \
    \  long largest = 0;\n        long smallest = 0;\n        foreach (var num in\
    \ lst) {\n            if (num < 0) {\n                isNegative = true;\n   \
    \         }\n            if (num > 0) {\n                if (!isNegative) {\n\
    \                    largest = num;\n                }\n                if (smallest\
    \ == 0 || num < smallest) {\n                    smallest = num;\n           \
    \     }\n            }\n        }\n        if (isNegative) {\n            return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        }\n     \
    \   if (largest == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        if (smallest == 0) {\n          \
    \  return Tuple.Create(largest, 0);\n        }\n        return Tuple.Create(largest,\
    \ smallest);", "        var smallest = lst.Min();\n        var largest = lst.Max();\n\
    \        var negative = lst.Where(x => x < 0).Select(x => new Nullable<long>(x))\n\
    \                            .Where(x => !x.HasValue).Select(x => null);\n   \
    \     var positive = lst.Where(x => x > 0).Select(x => new Nullable<long>(x))\n\
    \                            .Where(x => !x.HasValue).Select(x => null);\n   \
    \     var maxNegative = negative.Max();\n        var minPositive = positive.Min();\n\
    \        if (maxNegative == null && minPositive == null)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        return Tuple.Create(maxNegative, minPositive);",
  "        long[] intArr = lst.Select(i => (long)i).ToArray();\n        int nMin =\
    \ int.MaxValue;\n        int nMax = int.MinValue;\n        for (int i = 0; i <\
    \ intArr.Length; i++) {\n            if (intArr[i] < nMin) {\n               \
    \ nMin = intArr[i];\n            }\n            if (intArr[i] > nMax) {\n    \
    \            nMax = intArr[i];\n            }\n        }\n        if (nMin < nMax)\
    \ {\n            return Tuple.Create<Nullable<long>>(null, nMin);\n        } else\
    \ {\n            return Tuple.Create<Nullable<long>>(null, nMax);\n        }",
  "        \n        Nullable<long> smallest = null;\n        Nullable<long> largest\
    \ = null;\n\n        int largestValue = lst[0];\n        int smallestValue = lst[0];\n\
    \        for (int i = 1; i < lst.Count; i++)\n        {\n            int nextValue\
    \ = lst[i];\n            if (nextValue > largestValue)\n            {\n      \
    \          largestValue = nextValue;\n                largest = smallest;\n  \
    \          }\n            else if (nextValue < smallestValue)\n            {\n\
    \                smallestValue = nextValue;\n                smallest = largest;\n\
    \            }\n        }\n\n        return Tuple.Create(smallest, largest);",
  "        // TODO: Fill in the code below.\n        List<long> min = new List<long>();\n\
    \        List<long> max = new List<long>();\n        long largestNegative;\n \
    \       long largestPositive;\n        foreach (long i in lst) {\n           \
    \ if (i < 0) {\n                min.Add(i);\n                largestNegative =\
    \ i;\n            } else if (i > 0) {\n                max.Add(i);\n         \
    \       largestPositive = i;\n            }\n        }\n        if (largestNegative\
    \ < 0L && largestPositive > 0L) {\n            return Tuple.Create(new Nullable<long>(),\
    \ new Nullable<long>());\n        } else if (largestNegative < 0L) {\n       \
    \     return Tuple.Create(new Nullable<long>(), largestPositive);\n        } else\
    \ if (largestPositive > 0L) {\n            return Tuple.Create(largestNegative,\
    \ new Nullable<long>());\n        }\n        return Tuple.Create(largestNegative,\
    \ largestPositive);", "        int iMax = lst.Count(x => x < 0);\n        int\
    \ iMin = lst.Count(x => x > 0);\n        if ((iMax < iMin) || ((iMax <= 0) &&\
    \ (iMin <= 0))) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        long[] vals = new long[iMax + 1];\n        for (int\
    \ i = 0; i < vals.Length; i++) {\n            vals[i] = lst[i % lst.Count()];\n\
    \        }\n        long max = 0;\n        int i = 0;\n        long min = 0;\n\
    \        while (i < vals.Length && vals[i] != 0) {\n            max = vals[i];\n\
    \            if (vals[i] < 0) {\n                max = -max;\n            }\n\
    \            if (max > min) {\n                break;\n            }\n       \
    \     i++;\n        }\n        while (i < vals.Length && vals[i] != 0) {\n   \
    \         min = vals[i];\n            if (vals[i] > 0) {\n                min\
    \ = min;\n            }\n            if (min < max) {\n                break;\n\
    \            }\n            i++;\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(\n            new Nullable<long>(min), new Nullable<long>(max));",
  "        if (lst.Count() == 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n\n        var biggest = new Nullable<long>(0);\n\
    \        var smallest = lst.First();\n        foreach (var a in lst) {\n     \
    \       if (a < 0) {\n                biggest = a.IsNull() ? null : a;\n     \
    \       } else if (a > 0) {\n                smallest = a;\n            }\n  \
    \      }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(biggest,\
    \ smallest);", "        long largest = long.MinValue;\n        long smallest =\
    \ long.MaxValue;\n        foreach(var x in lst) {\n            if(x < 0) {\n \
    \               if(x > largest) {\n                    largest = x;\n        \
    \        }\n            } else if(x > 0) {\n                if(x < smallest) {\n\
    \                    smallest = x;\n                }\n            }\n       \
    \ }\n        return Tuple.Create(lst.Count == 0 ? null : smallest, lst.Count ==\
    \ 0 ? null : largest);", "        IEnumerable<long> negatives = lst.Where(i =>\
    \ i < 0L);\n        IEnumerable<long> positives = lst.Where(i => i >= 0L);\n \
    \       if (negatives.Count() == 0 || positives.Count() == 0)\n            return\
    \ Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n        long maxNegative\
    \ = negatives.Max();\n        long minPositive = positives.Min();\n        return\
    \ Tuple.Create<Nullable<long>, Nullable<long>>(\n            new Nullable<long>(maxNegative),\n\
    \            new Nullable<long>(minPositive));", "        long minNegative = lst[0];\n\
    \        long maxPositive = lst[0];\n        foreach (long n in lst) {\n     \
    \       if (n < minNegative) {\n                minNegative = n;\n           \
    \ }\n            else if (n > maxPositive) {\n                maxPositive = n;\n\
    \            }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(\n\
    \            minNegative,\n            maxPositive\n        );", "        var\
    \ negatives = new List<long>();\n        var positives = new List<long>();\n \
    \       foreach (var l in lst) {\n            if (l < 0) {\n                negatives.Add(l);\n\
    \            }\n            else {\n                positives.Add(l);\n      \
    \      }\n        }\n        if (negatives.Count == 0 || positives.Count == 0)\
    \ {\n            return null;\n        }\n        var largestNegative = negatives.Max();\n\
    \        var smallestPositive = positives.Min();\n        var largestPositive\
    \ = positives.Max();\n        return Tuple.Create(largestNegative, smallestPositive);",
  "        long largest = lst?.Max();\n        long smallest = lst?.Min();\n     \
    \   return largest == smallest ? null : Tuple.Create(smallest, largest);", " \
    \       long[] numbers = lst.ToArray();\n        long[] negatives = new long[numbers.Length];\n\
    \        long[] positives = new long[numbers.Length];\n        for (int i = 0;\
    \ i < numbers.Length; i++) {\n            if (numbers[i] > 0) {\n            \
    \    positives[i] = numbers[i];\n            } else {\n                negatives[i]\
    \ = numbers[i];\n            }\n        }\n        int maxNegatives = numbers.Length\
    \ - negatives.Length;\n        int maxPositives = numbers.Length - positives.Length;\n\
    \        if (maxNegatives <= 0 && maxPositives <= 0) {\n            return Tuple.Create(null,\
    \ null);\n        }\n        int maxNegativesIndex = Math.Max(maxNegatives, 0);\n\
    \        int maxPositivesIndex = Math.Max(maxPositives, 0);\n        long largestNegative\
    \ = (long) negatives[maxNegativesIndex];\n        long smallestPositive = (long)\
    \ positives[maxPositivesIndex];\n        return Tuple.Create(largestNegative,\
    \ smallestPositive);", "        var mins = lst.TakeWhile(x => x < 0).ToArray();\n\
    \        var maxes = lst.SkipWhile(x => x < 0).TakeWhile(x => x >= 0).ToArray();\n\
    \        if (mins.Length == 0 && maxes.Length == 0) {\n            return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, null);\n        }\n        if (mins.Length\
    \ > 0) {\n            return new Tuple<Nullable<long>, Nullable<long>>(maxes.Min(),\
    \ mins.Max());\n        }\n        if (maxes.Length > 0) {\n            return\
    \ new Tuple<Nullable<long>, Nullable<long>>(mins.Min(), maxes.Max());\n      \
    \  }\n        return new Tuple<Nullable<long>, Nullable<long>>(null, null);",
  "        if (lst.Count < 2) return Tuple.Create<Nullable<long>, Nullable<long>>(Nullable<long>.Parse(\"\
    null\"), Nullable<long>.Parse(\"null\"));\n        long largest = lst.Min();\n\
    \        long smallest = lst.Max();\n        foreach (long value in lst) {\n \
    \           if (value < 0 && largest < value) largest = value;\n            if\
    \ (value > 0 && smallest > value) smallest = value;\n        }\n        if (largest\
    \ < 0) largest = Nullable<long>.Parse(\"null\");\n        if (smallest < 0) smallest\
    \ = Nullable<long>.Parse(\"null\");\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        if (lst == null || lst.Count\
    \ == 0) return null;\n        long largest = lst[0];\n        long smallest =\
    \ lst[0];\n        foreach (long num in lst) {\n            if (num < 0) {\n \
    \               largest = num;\n            }\n            if (num > 0) {\n  \
    \              smallest = num;\n            }\n        }\n        return Tuple.Create(smallest,\
    \ largest);", "        Tuple<Nullable<long>, Nullable<long>> maxMin = null;\n\
    \        if (lst.Count <= 1) {\n            return maxMin;\n        }\n      \
    \  Nullable<long> smallest = lst[0];\n        Nullable<long> largest = lst[0];\n\
    \        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] > largest)\
    \ {\n                largest = lst[i];\n            }\n            if (lst[i]\
    \ < smallest) {\n                smallest = lst[i];\n            }\n        }\n\
    \        maxMin = Tuple.Create(smallest, largest);\n        return maxMin;", " \
    \       // TODO: Create a function that returns (a) as the largest negative\n\
    \        // integer, and (b) as the smallest positive integer\n        // TODO:\
    \ Create a function that returns (a,b) as a tuple where 'a' is\n        // the\
    \ largest of negative integers, and 'b' is the smallest of\n        // positive\
    \ integers in a list\n        Tuple<Nullable<long>, Nullable<long>> t = Tuple.Create<Nullable<long>>(null,\
    \ null);\n        if (lst.Count() > 0) {\n            long largest = lst[0];\n\
    \            long smallest = lst[0];\n            for (int i = 1; i < lst.Count();\
    \ i++) {\n                if (lst[i] > largest) {\n                    largest\
    \ = lst[i];\n                } else if (lst[i] < smallest) {\n               \
    \     smallest = lst[i];\n                }\n            }\n            t.Item1\
    \ = (Nullable<long>)null;\n            t.Item2 = (Nullable<long>)null;\n     \
    \       if (smallest > 0)\n                t.Item1 = smallest;\n            else\n\
    \                t.Item2 = (Nullable<long>)null;\n        }\n        return t;",
  "        var smallest = lst.Min();\n        var largest = lst.Max();\n\n       \
    \ if (smallest < 0 || smallest > largest)\n            return Tuple.Create((Nullable<long>)null,\
    \ smallest);\n\n        if (largest < 0 || largest < smallest)\n            return\
    \ Tuple.Create((Nullable<long>)null, smallest);\n\n        return Tuple.Create((Nullable<long>)null,\
    \ largest);", "        if (lst.Count == 0)\n            return null;\n\n     \
    \   var negative = lst.Where(i => i < 0).Max();\n        if (negative == lst.First())\n\
    \            return null;\n\n        var positive = lst.Where(i => i >= 0).Min();\n\
    \        if (positive == lst.Last())\n            return null;\n\n        if (positive.Equals(negative))\n\
    \            return Tuple.Create((Nullable<long>)null, positive);\n\n        if\
    \ (lst.Where(i => i > 0 && i < 0).Count() < lst.Where(i => i < 0).Count() * lst.Where(i\
    \ => i > 0).Count())\n            return Tuple.Create((Nullable<long>)null, negative);\n\
    \n        return Tuple.Create((Nullable<long>)null, positive);", "        if (lst.Count\
    \ == 0)\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        if (lst.Count > int.MaxValue)\n            return LargestSmallestIntegers(lst.Take(int.MaxValue)).FirstOrDefault();\n\
    \        if (lst.Count < int.MinValue)\n            return LargestSmallestIntegers(lst.Take(int.MinValue)).FirstOrDefault();\n\
    \        long largest = lst.Max();\n        long smallest = lst.Min();\n     \
    \   bool bothNegative = lst\n            .Where(x => x < 0)\n            .Count()\
    \ > 0;\n        if (bothNegative)\n            return LargestSmallestIntegers(lst.Where(x\
    \ => x < 0).Take(int.MaxValue));\n        bool bothPositive = lst\n          \
    \  .Where(x => x > 0)\n            .Count() > 0;\n        if (bothPositive)\n\
    \            return LargestSmallestIntegers(lst.Where(x => x > 0).Take(int.MinValue));\n\
    \        if (largest < smallest)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        else\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        if (lst==null)\n            return\
    \ new Tuple<Nullable<long>, Nullable<long>>(null,null);\n        long a = lst.Max()\
    \ - lst.Min();\n        if (a < 0)\n            throw new Exception(\"No negative\
    \ integers in list\");\n        long b = lst.Min();\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(a < b ? null : a , b < 0 ? null : b);", "        long largest\
    \ = lst.Max();\n        long smallest = lst.Min();\n        Nullable<long> result1\
    \ = largest < 0 ? (Nullable<long>)null : largest;\n        Nullable<long> result2\
    \ = smallest > 0 ? (Nullable<long>)null : smallest;\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(result1, result2);", "        Nullable<long> a = null;\n   \
    \     Nullable<long> b = null;\n        if (lst.Any()) {\n            var positive\
    \ = lst.Where(x => x < 0).Count();\n            if (positive > 0)\n          \
    \      a = lst.Where(x => x < 0).OrderByDescending(x => x).First();\n        \
    \    var negative = lst.Where(x => x >= 0).Count();\n            if (negative\
    \ > 0)\n                b = lst.Where(x => x >= 0).OrderBy(x => x).First();\n\
    \        }\n        return Tuple.Create(a, b);", "        Nullable<long> max =\
    \ null;\n        Nullable<long> min = null;\n        foreach (var item in lst)\
    \ {\n            if (IsNegative(item)) {\n                if (max == null) {\n\
    \                    max = item;\n                }\n                else {\n\
    \                    if (item > max) {\n                        max = item;\n\
    \                    }\n                }\n            }\n            else if\
    \ (IsPositive(item)) {\n                if (min == null) {\n                 \
    \   min = item;\n                }\n                else {\n                 \
    \   if (item < min) {\n                        min = item;\n                 \
    \   }\n                }\n            }\n        }\n        return Tuple.Create((max\
    \ == null ? null : max), (min == null ? null : min));", "        var smallest\
    \ = lst[0];\n        var largest = lst[0];\n        foreach (var i in lst) {\n\
    \            if (i < smallest)\n                smallest = i;\n            if\
    \ (i > largest)\n                largest = i;\n        }\n        if (smallest.HasValue)\
    \ {\n            return Tuple.Create(smallest.Value, largest.Value);\n       \
    \ }\n        else\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);",
  "        if (lst.Count == 0) return null;\n        int min = -9223372036854775808;\
    \ // Long.MinValue;\n        int max = 9223372036854775807; // Long.MaxValue;\n\
    \        long? maxNegative = null;\n        long? minPositive = null;\n      \
    \  foreach (long i in lst) {\n            if (i < 0) {\n                maxNegative\
    \ = i;\n                if (maxNegative > max) max = maxNegative;\n          \
    \  } else if (i > 0) {\n                minPositive = i;\n                if (minPositive\
    \ < min) min = minPositive;\n            }\n        }\n        return Tuple.Create((Nullable<long>)max,\
    \ (Nullable<long>)min);", "        long largest = 0;\n        long smallest =\
    \ 0;\n        foreach (long i in lst) {\n            if (i >= 0) {\n         \
    \       smallest = i;\n            }\n            else {\n                largest\
    \ = i;\n            }\n        }\n        if (largest == 0 && smallest == 0) {\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n \
    \       }\n        return new Tuple<Nullable<long>, Nullable<long>>(\n       \
    \     smallest > 0 ? smallest : null,\n            largest < 0 ? largest : null\n\
    \        );", "        if (lst.Count == 0) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long maxI = 0;\n        long minI = 1;\n   \
    \     bool negative = lst[0] < 0;\n        foreach (long i in lst) {\n       \
    \     if (negative == true) maxI = i;\n            else             minI = i;\n\
    \            if (i >= 0) negative = false;\n        }\n        if (maxI < minI)\
    \ return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        if\
    \ (maxI == minI) return Tuple.Create((Nullable<long>)maxI, (Nullable<long>)null);\n\
    \n        if (negative == false) return Tuple.Create((Nullable<long>)maxI, (Nullable<long>)minI);\n\
    \        if (negative == true) return Tuple.Create((Nullable<long>)null, (Nullable<long>)minI);",
  "        if (lst.Count == 0) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        long largestPositive = lst.FirstOrDefault();\n\
    \        long largestNegative = lst.FirstOrDefault();\n        for (int i = lst.Count\
    \ - 1; i >= 0; i--) {\n            if (lst[i] < 0 && lst[i] > largestPositive)\
    \ {\n                largestPositive = lst[i];\n            }\n            if\
    \ (lst[i] > 0 && lst[i] < largestNegative) {\n                largestNegative\
    \ = lst[i];\n            }\n        }\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(largestPositive, largestNegative);", "        if (lst.Count\
    \ == 0) return Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n\n \
    \       int[] min = new int[lst.Count];\n        int[] max = new int[lst.Count];\n\
    \n        // Get the minimums and maximums for the entire list.\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            if (lst[i] > 0) min[i] = i;\n    \
    \        if (lst[i] < 0) max[i] = i;\n        }\n\n        // If any min/max was\
    \ uninitialized, return nulls.\n        for (int i = 0; i < lst.Count; i++) {\n\
    \            if (min[i] == -1 && max[i] == -1) continue;\n\n            // Otherwise,\
    \ just return the best of both min/max.\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(lst[min[i]], lst[max[i]]);\n        }\n\n        // Otherwise,\
    \ return the single best of both min/max.\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(lst[min[0]], lst[max[0]]);", "        var largest = new Nullable<long>();\n\
    \        var smallest = new Nullable<long>();\n        if (lst == null)\n    \
    \        return Tuple.Create(largest, smallest);\n        var minMax = lst.Min(m\
    \ => m);\n        if (minMax.Equals(0L))\n            return Tuple.Create(largest,\
    \ smallest);\n        var maxNegative = lst.Max(m => m > 0L ? 0L : -1L);\n   \
    \     if (maxNegative.Equals(-1L))\n            return Tuple.Create(largest, smallest);\n\
    \        var minPositive = lst.Min(m => m > -1L ? -1L : 0L);\n        if (minPositive.Equals(0L))\n\
    \            return Tuple.Create(largest, smallest);\n        // Largest integers\
    \ are always greater than or equal to the minimum integer\n        largest = maxNegative;\n\
    \        smallest = minPositive;\n        // If there are positive and negative\
    \ numbers, find them by sorting\n        var positiveValues = lst.Where(n => n\
    \ > 0L).OrderBy(n => n).ToList();\n        var negativeValues = lst.Where(n =>\
    \ n < 0L).OrderByDescending(n => n).ToList();\n        if (positiveValues.Count\
    \ > 0 && negativeValues.Count > 0) {\n            var positiveMin = positiveValues.Min(m\
    \ => m);\n            var positiveMax = positiveValues.Max(m => m);\n        \
    \    var negativeMin = negativeValues.Min(m => m);\n            var negativeMax\
    \ = negativeValues.Max(m => m);\n            if (positiveMin < negativeMin &&\
    \ positiveMax > negativeMax) {\n                largest = positiveMin;\n     \
    \           smallest = negativeMin;\n            }\n            else if (positiveMax\
    \ > negativeMax && positiveMin < negativeMin) {\n                largest = positiveMax;\n\
    \                smallest = negativeMax;\n            }\n            else if (positiveMin\
    \ == negativeMin) {\n                largest = positiveMin;\n                smallest\
    \ = positiveMax;\n            }\n            else if (positiveMax == negativeMax)\
    \ {\n                largest = positiveMax;\n                smallest = positiveMin;\n\
    \            }\n        }\n        return Tuple.Create(largest, smallest);", " \
    \       // Your code here.\n        long min = 0;\n        long max = 0;\n   \
    \     long? minNull = null;\n        long? maxNull = null;\n        foreach (var\
    \ i in lst) {\n            if (i < 0) {\n                if (minNull == null)\
    \ {\n                    minNull = i;\n                    min = i;\n        \
    \        } else if (i == minNull) {\n                    min = Math.Min(min, i);\n\
    \                } else if (i == maxNull) {\n                    max = Math.Max(max,\
    \ i);\n                }\n            } else if (i > 0 && i <= max) {\n      \
    \          if (i == min) {\n                    min = i;\n                }\n\
    \                else if (i == max) {\n                    max = i;\n        \
    \        }\n            }\n        }\n\n        if (minNull == null)\n       \
    \     return null;\n        else if (maxNull == null)\n            return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, minNull);\n\n        return new\
    \ Tuple<Nullable<long>, Nullable<long>>(maxNull, max);", "        int minVal =\
    \ lst.Min();\n        int maxVal = lst.Max();\n        if (minVal > maxVal)\n\
    \            return null;\n        else\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(\n                null,\n                lst.FindIndex(item\
    \ => item > maxVal)\n            );", "        long max = 0;\n        long min\
    \ = 0;\n        foreach (long i in lst) {\n            if (i < 0)\n          \
    \      max = i;\n            else\n                min = i;\n        }\n     \
    \   return Tuple.Create(min < 0 ? null : min, (max < 0 ? null : max));", "   \
    \     if (lst.Count == 0) return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        long largest = lst.Max();\n        long smallest = lst.Min();\n     \
    \   if (smallest > largest) {\n            List<long> newlst = new List<long>(lst);\n\
    \            newlst.Sort();\n            largest = newlst[lst.Count - 1];\n  \
    \          smallest = newlst[0];\n        }\n        return Tuple.Create((Nullable<long>)largest,\
    \ (Nullable<long>)smallest);", "        var minValue = long.MaxValue;\n      \
    \  var maxValue = long.MinValue;\n        var negCount = 0;\n        var posCount\
    \ = 0;\n        var negMin = long.MaxValue;\n        var negMax = long.MinValue;\n\
    \        var posMin = long.MaxValue;\n        var posMax = long.MinValue;\n  \
    \      var values = new List<long>();\n        foreach (var val in lst) {\n  \
    \          if (val < 0) {\n                if (negCount < 0 || negMin > val) {\n\
    \                    negCount = negCount + 1;\n                    negMax = val;\n\
    \                }\n            } else {\n                if (posCount < 0 ||\
    \ posMax < val) {\n                    posCount = posCount + 1;\n            \
    \        posMin = val;\n                }\n            }\n            values.Add(val);\n\
    \        }\n        if (negCount == 0) {\n            return Tuple.Create(Nullable.GetUnderlyingType(lst.GetType()).IsValueType\
    \ ? default(Nullable<long>) : null, (Nullable<long>)null);\n        }\n      \
    \  if (posCount == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        if (negMax < minValue) {\n      \
    \      minValue = negMax;\n        }\n        if (negMin > maxValue) {\n     \
    \       maxValue = negMin;\n        }\n        if (posMax < minValue) {\n    \
    \        minValue = posMax;\n        }\n        if (posMin > maxValue) {\n   \
    \         maxValue = posMin;\n        }\n        return Tuple.Create((Nullable<long>)minValue,\
    \ maxValue);", "        long max = long.MinValue;\n        long min = long.MaxValue;\n\
    \        bool negative = false;\n        foreach (var item in lst) {\n       \
    \     if (item < 0 && min >= 0) {\n                min = 0;\n            }\n \
    \           if (item > 0 && max <= 0) {\n                max = 0;\n          \
    \  }\n            if (item < 0) {\n                negative = true;\n        \
    \    }\n            if (item > max) {\n                max = item;\n         \
    \   }\n            if (item < min) {\n                min = item;\n          \
    \  }\n        }\n        if (negative) {\n            return Tuple.Create(null,\
    \ min);\n        }\n        return Tuple.Create(max, null);", "        int MaxNegative\
    \ = lst\n            .Where(x => x < 0)\n            .OrderByDescending(x => x)\n\
    \            .FirstOrDefault();\n\n        if (MaxNegative == -1) {\n        \
    \    return Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n      \
    \  }\n\n        int MinPositive = lst\n            .Where(x => x >= 0)\n     \
    \       .OrderBy(x => x)\n            .FirstOrDefault();\n\n        if (MinPositive\
    \ == -1) {\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n\n        int MaxPositive = lst\n            .Where(x =>\
    \ x >= 0 && x <= MaxNegative)\n            .OrderBy(x => x)\n            .FirstOrDefault();\n\
    \n        if (MaxPositive == -1) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(MaxNegative, MinPositive);", "        Nullable<long> largest\
    \ = null;\n        Nullable<long> smallest = null;\n\n        // Scan all negative\
    \ numbers to find the largest\n        // number encountered so far.\n       \
    \ if (lst.Any()) {\n            var firstNegIndex = lst.FindIndex(x => x < 0);\n\
    \            if (firstNegIndex != -1) {\n                var firstNeg = lst[firstNegIndex];\n\
    \                largest = firstNeg;\n\n                // Scan all positive numbers\
    \ to find the smallest.\n                for (var index = firstNegIndex + 1; index\
    \ < lst.Count; index++)\n                {\n                    var currentPos\
    \ = lst[index];\n                    if (currentPos > smallest) {\n          \
    \              smallest = currentPos;\n                    }\n               \
    \ }\n            }\n        }\n\n        // Return tuple (a, b).\n        if (smallest\
    \ == null)\n            return Tuple.Create(null, null);\n\n        if (largest\
    \ == null)\n            return Tuple.Create(smallest, null);\n\n        return\
    \ Tuple.Create(largest, smallest);", "        long largest = 0;\n        long\
    \ smallest = long.MaxValue;\n        foreach (long i in lst) {\n            if\
    \ (i < 0) {\n                if (largest < 0)\n                    largest = i;\n\
    \            }\n            else if (i > 0)\n                smallest = i;\n \
    \       }\n        if (largest == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ null);\n        if (smallest == long.MaxValue)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        return Tuple.Create((Nullable<long>)largest,\
    \ (Nullable<long>)smallest);", "        int minVal = lst[0];\n        int maxVal\
    \ = lst[0];\n\n        // Get the smallest and largest integers from the list\
    \ \n        foreach (var item in lst) {\n            if (item > maxVal) {\n  \
    \              maxVal = item;\n            }\n            if (item < minVal) {\n\
    \                minVal = item;\n            }\n        }\n        // Create the\
    \ result tuple \n        return Tuple.Create((Nullable<long>)null, minVal);",
  "        Nullable<long> largest = null;\n        Nullable<long> smallest = null;\n\
    \        foreach (long i in lst) {\n            if (i > 0 && (largest == null\
    \ || i > largest.Value)) {\n                largest = i;\n            }\n    \
    \        if (i < 0 && (smallest == null || i < smallest.Value)) {\n          \
    \      smallest = i;\n            }\n        }\n        return Tuple.Create(largest,\
    \ smallest);", "        var negatives = lst.Where(i => i < 0);\n        var positives\
    \ = lst.Where(i => i >= 0);\n\n        if (negatives.Count() > 0) {\n        \
    \    var b = negatives.Min();\n            var a = negatives.Max();\n\n      \
    \      return Tuple.Create((Nullable<long>)null, a < 0L?null:b);\n        }\n\
    \        else if (positives.Count() > 0) {\n            var a = positives.Min();\n\
    \            var b = positives.Max();\n\n            return Tuple.Create((Nullable<long>)null,\
    \ a < 0L?null:b);\n        }\n        else\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        var large = Enumerable.Range(0, lst.Count).Aggregate(new\
    \ List<long>(), (acc, i) => {\n            if (lst[i] > 0 && acc.Count > 0) {\n\
    \                return acc;\n            }\n            if (lst[i] < 0 && acc.Count\
    \ > 0) {\n                acc.Add(lst[i]);\n            }\n            return\
    \ acc;\n        });\n        var small = Enumerable.Range(0, lst.Count).Aggregate(new\
    \ List<long>(), (acc, i) => {\n            if (lst[i] < 0 && acc.Count > 0) {\n\
    \                return acc;\n            }\n            if (lst[i] > 0 && acc.Count\
    \ > 0) {\n                acc.Add(lst[i]);\n            }\n            return\
    \ acc;\n        });\n\n        return Tuple.Create(large.Count > 0 ? large.Max()\
    \ : null, small.Count > 0 ? small.Min() : null);", "        if (lst.Count == 0)\
    \ return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        long[]\
    \ lstAsArray = new long[lst];\n        lst.CopyTo(lstAsArray, 0);\n        int\
    \ maxIndex = 0;\n        long maxValue = lstAsArray[maxIndex];\n        for (int\
    \ i = 1; i < lstAsArray.Length; i++) {\n            if (lstAsArray[i] > maxValue)\
    \ maxIndex = i;\n            if (lstAsArray[i] < maxValue) break;\n        }\n\
    \        return Tuple.Create((Nullable<long>)null, maxIndex);", "        if (lst.Count\
    \ == 0) {\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        long largest = 0;\n        long smallest = 0;\n \
    \       bool negative = true;\n        bool positive = true;\n        foreach\
    \ (var num in lst) {\n            if (num < 0) {\n                negative = true;\n\
    \                smallest = 0;\n            }\n            if (num > 0) {\n  \
    \              positive = true;\n                smallest = 0;\n            }\n\
    \            if (negative && positive && (largest <= num)) {\n               \
    \ largest = num;\n            }\n            else if (negative && (largest < num))\
    \ {\n                largest = num;\n            }\n            else if (positive\
    \ && (smallest >= num)) {\n                smallest = num;\n            }\n  \
    \          else if (positive && (smallest > num)) {\n                smallest\
    \ = num;\n            }\n            else if (negative && (smallest < num)) {\n\
    \                smallest = num;\n            }\n            else if (negative\
    \ && (smallest > num)) {\n                smallest = num;\n            }\n   \
    \     }\n        if (smallest == 0 && largest == 0) {\n            return null;\n\
    \        }\n        var result = (null, null);\n        if (negative && smallest\
    \ > 0) {\n            result = Tuple.Create<Nullable<long>, Nullable<long>>(smallest,\
    \ null);\n        }\n        else if (positive && largest < 0) {\n           \
    \ result = Tuple.Create<Nullable<long>, Nullable<long>>(null, largest);\n    \
    \    }\n        else if (negative && (smallest < 0) && (largest >= 0)) {\n   \
    \         result = Tuple.Create<Nullable<long>, Nullable<long>>(null, largest);\n\
    \        }\n        else if (positive && (smallest > 0) && (largest <= 0)) {\n\
    \            result = Tuple.Create<Nullable<long>, Nullable<long>>(smallest, null);\n\
    \        }\n        else if (negative && (smallest >= 0) && (largest <= 0)) {\n\
    \            result = Tuple.Create<Nullable<long>, Nullable<long>>(null, largest);\n\
    \        }\n        return result;", "        // TODO: Your code here\n      \
    \  long largest = lst[0];\n        long smallest = lst[0];\n        for (int i\
    \ = 0; i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n         \
    \       smallest = lst[i];\n            }\n            if (lst[i] > largest) {\n\
    \                largest = lst[i];\n            }\n        }\n        return Tuple.Create(smallest\
    \ == 0 ? null : smallest, largest == 0 ? null : largest);", "        Nullable<long>\
    \ a = null, b = null;\n        List<long> positives = new List<long>();\n    \
    \    List<long> negatives = new List<long>();\n        foreach(long num in lst)\
    \ {\n            if (num < 0L) {\n                negatives.Add(num);\n      \
    \      }\n            else\n            {\n                positives.Add(num);\n\
    \            }\n        }\n        if (negatives.Count == 0)\n        {\n    \
    \        a = null;\n        }\n        else\n        {\n            a = negatives.Max();\n\
    \        }\n        if (positives.Count == 0)\n        {\n            b = null;\n\
    \        }\n        else\n        {\n            b = positives.Min();\n      \
    \  }\n        return Tuple.Create((a, b));", "        if (lst.Count == 0) {\n\
    \            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        var smallest = new List<long>();\n        var largest = new\
    \ List<long>();\n        var min = new long(1);\n        var max = new long(-1);\n\
    \        foreach (var item in lst) {\n            if (item < min)\n          \
    \      min = item;\n            else if (item > max)\n                max = item;\n\
    \            if (item < 0 && item > max)\n                smallest.Add(item);\n\
    \            else if (item > 0 && item < min)\n                largest.Add(item);\n\
    \        }\n        if (smallest.Count == 0 && largest.Count == 0) {\n       \
    \     return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n     \
    \   }\n        var result1 = smallest.Count > 0 ? smallest.Last() : largest.Last();\n\
    \        var result2 = largest.Count > 0 ? largest.First() : smallest.First();\n\
    \        return Tuple.Create((Nullable<long>)result2, (Nullable<long>)result1);",
  "        if (lst.Count < 1) {\n            return null;\n        }\n        long\
    \ maxNegative = (long)long.MinValue;\n        long minPositive = (long)long.MaxValue;\n\
    \        foreach (var i in lst) {\n            if (i < 0) {\n                if\
    \ (maxNegative < (long)i) {\n                    maxNegative = (long)i;\n    \
    \            }\n            } else {\n                if (minPositive > i) {\n\
    \                    minPositive = (long)i;\n                }\n            }\n\
    \        }\n        if (maxNegative < 0) {\n            return null;\n       \
    \ }\n        if (minPositive > 0) {\n            return null;\n        }\n   \
    \     return Tuple.Create(maxNegative, minPositive);", "        if (lst.Count\
    \ == 0) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        long largest = lst[0];\n        long smallest = lst[0];\n\
    \        bool isNegative = true;\n        foreach (long n in lst) {\n        \
    \    if (n < 0 ^ isNegative) {\n                isNegative = !isNegative;\n  \
    \              if (n < 0) largest = n;\n                if (n > 0) smallest =\
    \ n;\n            }\n        }\n        return Tuple.Create((largest), (smallest));",
  "        var largest = lst.OrderByDescending(i => i).FirstOrDefault();\n       \
    \ var smallest = lst.OrderBy(i => i).FirstOrDefault();\n        if(smallest ==\
    \ null) return Tuple.Create((Nullable<long>)null, largest);\n        if(largest\
    \ == null) return Tuple.Create((Nullable<long>)null, smallest);\n        if(largest\
    \ > smallest && lst.Count > 1) return LargestSmallestIntegers(lst.Skip(1).ToList());\n\
    \        if(largest < smallest && lst.Count > 1) return LargestSmallestIntegers(lst.Take(1).ToList());\n\
    \        return Tuple.Create((Nullable<long>)null, smallest);", "        var result\
    \ = new List<long>();\n\n        foreach (var item in lst) {\n            if (item\
    \ > 0 && item < 0)\n                result.Add(item);\n            else\n    \
    \            return Tuple.Create<long>(null, item);\n        }\n        return\
    \ Tuple.Create<long>(null, result.Min());", "        var lsm = new List<long>();\n\
    \        var lsmIndex = new List<long>();\n        var lsmIndexCount = new List<long>();\n\
    \        var maxVal = -2;\n        var minVal = int.MaxValue;\n        var maxIndex\
    \ = 0;\n        var minIndex = 0;\n        lst.ForEach(i => {\n            if\
    \ (i > maxVal) {\n                maxVal = i;\n                maxIndex = lsmIndexCount[lsmIndex.Count-1];\n\
    \            }\n            if (i < minVal) {\n                minVal = i;\n \
    \               minIndex = lsmIndexCount[lsmIndex.Count-1];\n            }\n \
    \           lsmIndex.Add(i);\n            lsmIndexCount.Add(lsmIndex.Count);\n\
    \        });\n        if (lsmIndexCount.Count == 0) {\n            return null;\n\
    \        }\n        if (lsmIndex.Count == 1) {\n            return Tuple.Create((Nullable<long>)null,\
    \ lsm[0]);\n        }\n        if (lsmIndex.Count == 2) {\n            return\
    \ Tuple.Create((Nullable<long>)null, lsm[0]);\n        }\n        if (lsmIndex.Count\
    \ > 2) {\n            var minLsm = lsm[lsmIndexCount[0]];\n            var maxLsm\
    \ = lsm[lsmIndexCount[1]-1];\n            if (minLsm > maxLsm) {\n           \
    \     return Tuple.Create((Nullable<long>)null, minLsm);\n            } else {\n\
    \                return Tuple.Create((Nullable<long>)null, maxLsm);\n        \
    \    }\n        }\n        if (lsmIndex.Count == 4) {\n            return Tuple.Create((Nullable<long>)null,\
    \ lsm[lsmIndexCount[2]]);\n        }\n        if (lsmIndex.Count == 8) {\n   \
    \         return Tuple.Create((Nullable<long>)null, lsm[lsmIndexCount[4]]);\n\
    \        }\n        if (lsmIndex.Count == 16) {\n            return Tuple.Create((Nullable<long>)null,\
    \ lsm[lsmIndexCount[8]]);\n        }\n        if (lsmIndex.Count == 32) {\n  \
    \          return Tuple.Create((Nullable<long>)null, lsm[lsmIndexCount[16]]);\n\
    \        }\n        if (lsmIndex.Count == 64) {\n            return Tuple.Create((Nullable<long>)null,\
    \ lsm[lsmIndexCount[32]]);\n        }\n        if (lsmIndex.Count == 128) {\n\
    \            return Tuple.Create((Nullable<long>)null, lsm[lsmIndexCount[64]]);\n\
    \        }\n        if (lsmIndex.Count == 256) {\n            return ", "    \
    \    if (lst.Count == 0) return Tuple.Create((Nullable<long>)null, null);\n\n\
    \        // Sort list using quicksort to find the min/max elements.\n        long[]\
    \ sorted = lst.OrderBy(x => x).ToArray();\n\n        // Return null if there are\
    \ no negative or positive integers.\n        if (sorted.Any(x => (x > 0) == (x\
    \ < 0)))\n            return Tuple.Create((Nullable<long>)null, null);\n\n   \
    \     long min = sorted[0];\n        long max = sorted[0];\n\n        // If there\
    \ are negative integers, look for the min.\n        if (sorted[1] < 0)\n     \
    \       min = sorted[1];\n        // If there are positive integers, look for\
    \ the max.\n        if (sorted[1] > 0)\n            max = sorted[1];\n\n     \
    \   for (int i = 1; i < lst.Count; i++)\n            if (sorted[i] < min)\n  \
    \              min = sorted[i];\n            else if (sorted[i] > max)\n     \
    \           max = sorted[i];\n\n        // Return the min/max values as nullables.\n\
    \        return Tuple.Create((Nullable<long>)min, (Nullable<long>)max);", "  \
    \      // Write your solution here\n        if (lst.Count == 0) return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        long max = lst.FirstOrDefault();\n   \
    \     long min = lst.LastOrDefault();\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] > max) {\n                max = lst[i];\n   \
    \         }\n            if (lst[i] < min) {\n                min = lst[i];\n\
    \            }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(max,\
    \ min);", "        // Sort our list from largest to smallest.\n        lst.Sort();\n\
    \        long largest_int = long.MaxValue;\n        long smallest_int = long.MinValue;\n\
    \n        // If our list contains no positive integers,\n        // return our\
    \ tuples with our nullable values.\n        // Otherwise, get the two largest\
    \ and smallest integers.\n        if (lst.Any(l => l < 0)) return Tuple.Create<Nullable<long>>(null,\
    \ null);\n        long i = 0;\n        for (i = lst.Count - 1; i >= 0; i--) {\n\
    \            if (lst[i] > largest_int) {\n                largest_int = lst[i];\n\
    \            }\n            if (lst[i] < smallest_int) {\n                smallest_int\
    \ = lst[i];\n            }\n        }\n        return Tuple.Create<Nullable<long>>(smallest_int,\
    \ largest_int);", "        long largestPositive = lst.Sum(x => x > 0 ? x : 0);\n\
    \        long largestNegative = lst.Sum(x => x < 0 ? x : 0);\n        Nullable<long>\
    \ largest = (largestPositive > largestNegative ? largestPositive : largestNegative);\n\
    \        Nullable<long> smallest = lst.Sum(x => x < 0 ? x : 0);\n        return\
    \ Tuple.Create(largest, smallest);", "        double largestDouble = double.MinValue;\n\
    \        double smallestDouble = double.MaxValue;\n        foreach (var item in\
    \ lst) {\n            if (item < 0) {\n                if (Math.Abs(item) > largestDouble)\
    \ {\n                    largestDouble = Math.Abs(item);\n                }\n\
    \            } else {\n                if (item > smallestDouble) {\n        \
    \            smallestDouble = item;\n                }\n            }\n      \
    \  }\n        return Tuple.Create(largestDouble == double.MinValue ? null : new\
    \ Nullable<long>(largestDouble), smallestDouble == double.MaxValue ? null : new\
    \ Nullable<long>(smallestDouble));", "        if (lst.Count == 0) return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        long largest = lst.Min();\n        long\
    \ smallest = lst.Max();\n        foreach (long num in lst) {\n            if (num\
    \ < 0) largest = Math.Max(largest, num);\n            else smallest = Math.Min(smallest,\
    \ num);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        int maxIndex = 0;\n        long maxValue = 0L;\n     \
    \   int minIndex = 0;\n        long minValue = Long.MinValue;\n\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            long num = lst[i];\n            if\
    \ (num < 0)\n                num = -num;\n            if (num > maxValue) {\n\
    \                maxValue = num;\n                maxIndex = i;\n            }\n\
    \            if (num < minValue) {\n                minValue = num;\n        \
    \        minIndex = i;\n            }\n        }\n        if (maxIndex < minIndex)\n\
    \            return null;\n        return new Tuple<Nullable<long>, Nullable<long>>((long?)maxValue,\
    \ (long?)minValue);", "        Nullable<long> largestNegative = null;\n      \
    \  Nullable<long> largestPositive = null;\n        foreach (var i in lst) {\n\
    \            if (i < 0)\n                largestNegative = i;\n            else\
    \ if (i > 0)\n                largestPositive = i;\n        }\n        return\
    \ largestNegative == null ? null : new Tuple<Nullable<long>, Nullable<long>>(largestNegative,\
    \ largestPositive);", "        // Your code here\n        Nullable<long> a = null;\n\
    \        Nullable<long> b = null;\n        bool isNegative = false;\n        foreach\
    \ (var item in lst) {\n            if (isNegative) {\n                if (item\
    \ < 0)\n                    isNegative = false;\n                else\n      \
    \              b = item;\n            } else if(item > 0) {\n                if\
    \ (a != null)\n                    if (a > item)\n                        a =\
    \ item;\n                    else\n                        isNegative = true;\n\
    \                else\n                    a = item;\n            }\n        }\n\
    \        return Tuple.Create<long>(a, b);", "        // Return null if there are\
    \ no integers\n        if (!lst.Any()) return null;\n        var minNeg = new\
    \ Nullable<long>();\n        var maxPos = new Nullable<long>();\n        // Loop\
    \ through each element and find the min and max values\n        for (int i = 0;\
    \ i < lst.Count; ++i) {\n            // If the current value is negative, use\
    \ minNeg\n            if (lst[i] < 0) {\n                minNeg = lst[i];\n  \
    \          }\n            // If the current value is positive, use maxPos\n  \
    \          else if (lst[i] > 0) {\n                maxPos = lst[i];\n        \
    \    }\n            // If the current value is zero, we've found a new min and\
    \ max\n            else {\n                minNeg = maxPos = null;\n         \
    \   }\n        }\n        // Return the min/max\n        return Tuple.Create(minNeg,\
    \ maxPos);", "        long largest = lst.Max(i => i);\n        long smallest =\
    \ lst.Min(i => i);\n        return Tuple.Create(largest, smallest);", "      \
    \  if (lst.Any()) {\n            long largest = lst.Min();\n            long smallest\
    \ = lst.Max();\n            if (smallest > largest) {\n                foreach\
    \ (long i in lst) {\n                    if (i < smallest && i > largest) {\n\
    \                        smallest = i;\n                    }\n              \
    \  }\n            }\n            return Tuple.Create(smallest, largest);\n   \
    \     } else {\n            return Tuple.Create<Nullable<long>>(null, null);\n\
    \        }", "        var min = new Nullable<long>();\n        var max = new Nullable<long>();\n\
    \        foreach (long i in lst) {\n            if (i > max) max = i;\n      \
    \      if (i < min) min = i;\n        }\n        return Tuple.Create(min, max);",
  "        var largest = new Nullable<long>();\n        var smallest = new Nullable<long>();\n\
    \        if (lst.Count <= 0) return Tuple.Create(null, null);\n        var max\
    \ = lst.Max();\n        var min = lst.Min();\n        if (max <= 0) return Tuple.Create(null,\
    \ null);\n        if (min >= 0) return Tuple.Create(null, min);\n        if (min\
    \ > max) return Tuple.Create((long)0, (long)0);\n        for (int i = 1; i < lst.Count;\
    \ i++) {\n            long value = lst[i];\n            if (value >= 0) smallest\
    \ = value.GetValueOrDefault();\n            else if (value < 0) largest = value.GetValueOrDefault();\n\
    \            else return Tuple.Create(null, null);\n        }\n        return\
    \ Tuple.Create(largest, smallest);", "        if (lst.Count > 0) {\n         \
    \   List<long> negatives = new List<long>();\n            foreach (long n in lst)\
    \ {\n                if (n < 0) negatives.Add(n);\n            }\n           \
    \ if (negatives.Count > 0) {\n                long minNegative = negatives.Min();\n\
    \                long maxNegative = negatives.Max();\n                long minPositive\
    \ = lst.Min();\n                long maxPositive = lst.Max();\n              \
    \  return Tuple.Create(Nullable<long>.MaxValue, Nullable<long>.MinValue);\n  \
    \          } else {\n                long minPositive = lst.Min();\n         \
    \       long maxPositive = lst.Max();\n                return Tuple.Create(minPositive,\
    \ maxPositive);\n            }\n        } else {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }", "        long largestPosInt;\n        long\
    \ largestNegInt;\n        long smallestPosInt;\n        long smallestNegInt;\n\
    \        foreach (long i in lst) {\n            if (i < 0) {\n               \
    \ largestNegInt = i;\n            }\n            else if (i > 0)\n           \
    \     largestPosInt = i;\n            else {\n                largestPosInt =\
    \ i;\n                smallestNegInt = i;\n            }\n            if (i ==\
    \ 0) {\n                smallestPosInt = i;\n                smallestNegInt =\
    \ i;\n            }\n        }\n        return Tuple.Create((largestPosInt > 0)\
    \ ? new Nullable<long>(largestPosInt) : null, smallestNegInt > 0 ? new Nullable<long>(smallestNegInt)\
    \ : null);", "        if (lst.Count == 0) return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        var min = (long)lst[0];\n        var max\
    \ = (long)lst[0];\n        for (var i = 1; i < lst.Count; i++) {\n           \
    \ var v = (long)lst[i];\n            if (v < min) min = v;\n            if (v\
    \ > max) max = v;\n        }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(\n\
    \            Tuple.Create<long>(min),\n            Tuple.Create<long>(max));",
  "        long a = 0, b = 0, c = 0, d = 0, e = 0;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            int sign = (lst[i] < 0) ? 1 : 0;\n            if (sign ==\
    \ 0) break;\n            int x = sign * lst[i];\n            if (x == 0) break;\n\
    \            a = Math.Max(a, x);\n            c = Math.Min(c, x);\n          \
    \  int y = sign * (lst[i] < 0) ? -1 : 1;\n            if (sign == 1 && x == 0)\
    \ break;\n            b = Math.Max(b, y);\n            d = Math.Min(d, y);\n \
    \           int z = sign * lst[i];\n            if (z == 0) break;\n         \
    \   e = Math.Max(e, z);\n        }\n        if (a == 0 && b == 0 && c == 0 &&\
    \ d == 0 && e == 0) return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        if (a > 0) return Tuple.Create((Nullable<long>)a, (Nullable<long>)b);\n\
    \        return Tuple.Create((Nullable<long>)null, (Nullable<long>)d);", "   \
    \     return lst\n            .Where(i => i >= 0)\n            .OrderByDescending(i\
    \ => i)\n            .FirstOrDefault()\n            .GetValueOrDefault();", " \
    \       Nullable<long> max = null;\n        Nullable<long> min = null;\n     \
    \   bool first = true;\n        int numOfNegative = 0;\n        foreach (long\
    \ i in lst) {\n            if (i < 0) {\n                numOfNegative++;\n  \
    \              if (first == true) {\n                    max = i;\n          \
    \          first = false;\n                }\n                else {\n       \
    \             if (numOfNegative > 1) {\n                        max = i;\n   \
    \                 }\n                }\n            }\n            else\n    \
    \        {\n                first = false;\n                if (first == false)\
    \ {\n                    min = i;\n                }\n            }\n        }\n\
    \        return Tuple.Create(min, max);", "        // Scan the list and create\
    \ dictionaries\n        // for storing positive and negative integers\n      \
    \  Dictionary<long, bool> positive = new Dictionary<long, bool>();\n        Dictionary<long,\
    \ bool> negative = new Dictionary<long, bool>();\n\n        // If there are no\
    \ numbers then return null\n        if (lst.Count == 0)\n            return Tuple.Create(Nullable<long>.Null,\
    \ Nullable<long>.Null);\n        else\n            // Scan the list to find positive\
    \ and negative numbers and store them\n            foreach (long num in lst) {\n\
    \                if (num > 0) {\n                    positive[num] = true;\n \
    \               } else {\n                    negative[num] = true;\n        \
    \        }\n            }\n\n            // Find the largest negative number and\
    \ the smallest positive number\n            long largestNegative = -1;\n     \
    \       long smallestPositive = Int32.MaxValue;\n\n            // If the number\
    \ of negative numbers is less than or equal to the number of positive numbers\n\
    \            if (negative.Count <= positive.Count) {\n                // Sort\
    \ the positive numbers and store them in 'smallestPositive'\n                foreach\
    \ (long num in positive.Keys) {\n                    if (num < smallestPositive)\
    \ {\n                        smallestPositive = num;\n                    }\n\
    \                }\n                // Sort the negative numbers and store them\
    \ in 'largestNegative'\n                foreach (long num in negative.Keys) {\n\
    \                    if (num > largestNegative) {\n                        largestNegative\
    \ = num;\n                    }\n                }\n                // Compare\
    \ the negative number with the positive number\n                if (largestNegative\
    \ > smallestPositive) {\n                    return Tuple.Create(largestNegative,\
    \ smallestPositive);\n                } else {\n                    return Tuple.Create(Nullable<long>.Null,\
    \ Nullable<long>.Null);\n                }\n            } else {\n           \
    \     return Tuple.Create(Nullable<long>.Null, Nullable<long>.Null);\n       \
    \     }", "        if (lst.Count == 0) return null;\n        long largest = lst.Max();\n\
    \        long smallest = lst.Min();\n        if (largest < 0 && smallest > 0)\
    \ {\n            return null;\n        }\n        if (largest < 0 && smallest\
    \ < 0) {\n            return Tuple.Create(null, smallest);\n        }\n      \
    \  if (largest > 0 && smallest < 0) {\n            return Tuple.Create(null, largest);\n\
    \        }\n        return Tuple.Create(largest, smallest);", "        if (lst==null)\n\
    \            return Tuple.Create<long>(null, null);\n        if (lst.Any()==false)\
    \ return Tuple.Create<long>(null, null);\n        \n        long negative = 0;\n\
    \        long positive = 0;\n        long largest = long.MaxValue;\n        long\
    \ smallest = long.MinValue;\n\n        foreach (long num in lst) {\n         \
    \   if (num < 0)\n                negative += num;\n            else\n       \
    \         positive += num;\n            if (num > largest)\n                largest\
    \ = num;\n            if (num < smallest)\n                smallest = num;\n \
    \       }\n\n        if (negative > 0)\n            return Tuple.Create<long>(null,\
    \ null);\n        if (positive > 0)\n            return Tuple.Create<long>(null,\
    \ null);\n\n        if (negative < 0)\n            return Tuple.Create<long>(null,\
    \ smallest);\n        if (positive < 0)\n            return Tuple.Create<long>(null,\
    \ largest);\n\n        if (negative == 0)\n            return Tuple.Create<long>(null,\
    \ largest);\n        if (positive == 0)\n            return Tuple.Create<long>(null,\
    \ smallest);\n\n        // if (positive < largest)\n        //     return Tuple.Create<long>(null,\
    \ positive);\n        // if (positive > smallest)\n        //     return Tuple.Create<long>(null,\
    \ positive);\n        // if (negative < smallest)\n        //     return Tuple.Create<long>(null,\
    \ negative);\n        // if (negative > largest)\n        //     return Tuple.Create<long>(null,\
    \ negative);\n\n        decimal ratio = decimal.Divide(largest, smallest);\n \
    \       return Tuple.Create<long>(null, smallest/ratio);", "        if (lst==null\
    \ || lst.Count == 0) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        long largest = lst.FirstOrDefault();\n        long\
    \ smallest = lst.LastOrDefault();\n        long sign = 1;\n        if (largest\
    \ < smallest) {\n            sign = -1;\n        }\n        long[] arr = lst.ToArray();\n\
    \        long[] ret = new long[2];\n        int i = 0;\n        while (i < arr.Length)\
    \ {\n            long current = arr[i];\n            if (current >= 0) {\n   \
    \             ret[0] = (Nullable<long>)current;\n            } else {\n      \
    \          ret[1] = (Nullable<long>)current;\n            }\n            if (ret[0].HasValue\
    \ && ret[1].HasValue) {\n                i++;\n            }\n        }\n    \
    \    if (ret[0].HasValue && ret[1].HasValue) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(sign * ret[0].Value, sign * ret[1].Value);\n        }\n    \
    \    return null;", "        if (lst.Count == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long a = lst.FirstOrDefault();\n        long\
    \ b = lst.LastOrDefault();\n        long c = lst.Sum();\n        long d = lst.Select(x\
    \ => (long)Math.Abs(x - a)).Min();\n        long e = lst.Select(x => (long)Math.Abs(x\
    \ - b)).Max();\n        return Tuple.Create((Nullable<long>)c, (Nullable<long>)d);",
  "        if (lst.Count == 0) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n\n        // Sort descending to find the first negative and\
    \ first positive number\n        List<long> descendingSortedList = new List<long>(lst.OrderByDescending(x\
    \ => x));\n\n        // Find the first negative and first positive number\n  \
    \      long firstNegative = descendingSortedList[0];\n        long firstPositive\
    \ = descendingSortedList[0];\n\n        // Find the smallest positive number\n\
    \        for (int i = 0; i < descendingSortedList.Count; i++) {\n            if\
    \ (descendingSortedList[i] <= firstPositive) {\n                firstPositive\
    \ = descendingSortedList[i];\n            }\n        }\n\n        // Find the\
    \ smallest negative number\n        for (int i = 0; i < descendingSortedList.Count;\
    \ i++) {\n            if (descendingSortedList[i] < firstNegative) {\n       \
    \         firstNegative = descendingSortedList[i];\n            }\n        }\n\
    \n        return new Tuple<Nullable<long>, Nullable<long>>(\n            null,\n\
    \            firstNegative);", "        long? largest = null;\n        long? smallest\
    \ = null;\n        foreach (var num in lst)\n        {\n            if (num <\
    \ 0)\n            {\n                if (largest == null) largest = num;\n   \
    \             else\n                {\n                    if (num > largest)\
    \ largest = num;\n                }\n            }\n            else\n       \
    \     {\n                if (smallest == null) smallest = num;\n             \
    \   else\n                {\n                    if (num < smallest) smallest\
    \ = num;\n                }\n            }\n        }\n        return largest.IsValid\
    \ ? Tuple.Create(largest, smallest) : null;", "        long maxNegative = 0, minPositive\
    \ = 0;\n        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i]\
    \ < 0) {\n                if (maxNegative < lst[i])\n                    maxNegative\
    \ = lst[i];\n            } else {\n                if (minPositive > lst[i])\n\
    \                    minPositive = lst[i];\n            }\n        }\n       \
    \ if (maxNegative == 0) return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        if (minPositive == 0) return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        return Tuple.Create((Nullable<long>)maxNegative, (Nullable<long>)minPositive);",
  "        if (lst == null || lst.Count == 0)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        List<long> negativeInts = new List<long>();\n\
    \        List<long> positiveInts = new List<long>();\n        foreach (long i\
    \ in lst) {\n            if (i < 0)\n                negativeInts.Add(i);\n  \
    \          else\n                positiveInts.Add(i);\n        }\n        int\
    \ negativeMin = negativeInts.Min();\n        int positiveMax = positiveInts.Max();\n\
    \        if (positiveMax == negativeMin)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        return Tuple.Create<Nullable<long>, Nullable<long>>(positiveMax,\
    \ negativeMin);", "        if (lst.Count == 0)\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        long? max = null;\n        long? min =\
    \ null;\n        foreach (long item in lst) {\n            if (Math.Abs(item)\
    \ > 0) {\n                if (max != null || item < 0)\n                    max\
    \ = item;\n            } else {\n                if (min != null || item > 0)\n\
    \                    min = item;\n            }\n        }\n        if (max ==\
    \ null && min == null)\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        return Tuple.Create<Nullable<long>, Nullable<long>>(max, min);",
  "        bool negatives = false;\n        bool zeros = false;\n        bool positives\
    \ = false;\n\n        long largest = (long)0;\n        long smallest = (long)0;\n\
    \n        foreach (long x in lst) {\n            if (x < 0) {\n              \
    \  negatives = true;\n            } else if (x == 0) {\n                zeros\
    \ = true;\n            } else if (x > 0) {\n                positives = true;\n\
    \            } else {\n                continue;\n            }\n        }\n\n\
    \        if (negatives && zeros && positives) {\n            largest = lst[0];\n\
    \            smallest = lst[0];\n            for (int i = 1; i < lst.Count; i++)\
    \ {\n                if (lst[i] > largest) {\n                    largest = lst[i];\n\
    \                } else if (lst[i] < smallest) {\n                    smallest\
    \ = lst[i];\n                }\n            }\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, (long)smallest);\n        } else if (negatives && zeros)\
    \ {\n            largest = lst[0];\n            smallest = lst[0];\n         \
    \   for (int i = 1; i < lst.Count; i++) {\n                if (lst[i] > largest)\
    \ {\n                    largest = lst[i];\n                } else if (lst[i]\
    \ == 0) {\n                    zeros = true;\n                }\n            }\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(null, (long)largest);\n\
    \        } else if (negatives && positives) {\n            largest = lst[0];\n\
    \            smallest = lst[0];\n            for (int i = 1; i < lst.Count; i++)\
    \ {\n                if (lst[i] > largest) {\n                    largest = lst[i];\n\
    \                } else if (lst[i] == 0) {\n                    zeros = true;\n\
    \                } else if (lst[i] < smallest) {\n                    smallest\
    \ = lst[i];\n                }\n            }\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, (long)smallest);\n        } else if (zeros) {\n      \
    \      largest = lst[0];\n            smallest = lst[0];\n            for (int\
    \ i = 1; i < lst.Count; i++) {\n                if (lst[i] == 0) {\n         \
    \           zeros = true;\n                }\n            }\n            return\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, (long)largest);\n        } else\
    \ if (positives) {\n            largest = lst[0];\n            smallest = lst[0];\n\
    \            for (int i = 1; i < lst.Count; i++) {\n                if (lst[i]\
    \ > largest) {\n                    largest = lst[i];\n                } else\
    \ if (lst[i] < smallest) {\n                    smallest = lst[i];\n         \
    \       }\n            }\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ (long)smallest);\n        }\n        return null;", "        var ans = new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        var isNeg = new bool[lst?.Count ?? 0];\n\
    \        for (var j = 0; j < isNeg.Length; j++) {\n            isNeg[j] = lst?.ElementAt(j)\
    \ ?? false;\n        }\n        for (var i = 0; i < isNeg.Length; i++) {\n   \
    \         var maxVal = lst?.ElementAt(i) ?? 0L;\n            if (isNeg[i]) {\n\
    \                maxVal = -maxVal;\n            }\n            for (var j = i\
    \ + 1; j < isNeg.Length; j++) {\n                if (isNeg[j]) {\n           \
    \         continue;\n                }\n                var minVal = lst?.ElementAt(j)\
    \ ?? 0L;\n                if (maxVal < minVal) {\n                    ans = Tuple.Create<Nullable<long>>(maxVal,\
    \ minVal);\n                }\n            }\n        }\n        return ans;",
  "        Nullable<long> max;\n        Nullable<long> min;\n        if (lst.Count\
    \ <= 0) {\n            max = min = null;\n            return Tuple.Create(max,\
    \ min);\n        }\n        List<long> longs = new List<long>();\n        foreach\
    \ (var item in lst) {\n            if (item < 0) {\n                longs.Add(item);\n\
    \            }\n            else {\n                min = item < min ? item :\
    \ min;\n            }\n        }\n        if (longs.Count == 0) {\n          \
    \  max = min = null;\n            return Tuple.Create(max, min);\n        }\n\
    \        if (min == longs[0]) {\n            max = min = null;\n        }\n  \
    \      else {\n            longs.Sort();\n            max = longs[longs.Count\
    \ - 1];\n            min = longs[0];\n        }\n        return Tuple.Create(max,\
    \ min);", "        long min = (long)0;\n        long max = (long)0;\n        foreach\
    \ (long i in lst) {\n            if (i < min) min = i;\n            if (i > max)\
    \ max = i;\n        }\n        return Tuple.Create((Nullable<long>)min, (Nullable<long>)max);",
  "        long largest = lst.Max();\n        long smallest = lst.Min();\n       \
    \ if (largest < smallest) \n            return Tuple.Create((Nullable<long>)null,\
    \ smallest);\n        if (largest > 0) \n            return Tuple.Create(null,\
    \ (Nullable<long>)largest);\n        return Tuple.Create((Nullable<long>)null,\
    \ null);", "        long[] array = new long[lst.Count];\n        int i = 0;\n\
    \        foreach (long val in lst)\n            array[i++] = val;\n        Array.Sort(array);\n\
    \n        Nullable<long> largest = null;\n        Nullable<long> smallest = null;\n\
    \        foreach (long val in array) {\n            if (largest == null || val\
    \ > largest) {\n                largest = val;\n            }\n            if\
    \ (smallest == null || val < smallest) {\n                smallest = val;\n  \
    \          }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        bool allNegatives = true;\n        bool allPositives =\
    \ true;\n        long min = 0;\n        long max = 0;\n        long largestOfNegatives\
    \ = -100000L;\n        long smallestOfPositives = 100000L;\n        foreach (long\
    \ i in lst) {\n            if (i < 0)\n                allNegatives = false;\n\
    \            if (i < 0)\n                allPositives = false;\n            if\
    \ (min > i)\n                min = i;\n            if (max < i)\n            \
    \    max = i;\n            if (smallestOfPositives > i)\n                smallestOfPositives\
    \ = i;\n            if (largestOfNegatives < i)\n                largestOfNegatives\
    \ = i;\n        }\n        Tuple<Nullable<long>, Nullable<long>> ret;\n      \
    \  if (allNegatives) {\n            ret = Tuple.Create(null, (Nullable<long>)null);\n\
    \        } else if (allPositives) {\n            ret = Tuple.Create((Nullable<long>)null,\
    \ smallestOfPositives);\n        } else {\n            ret = Tuple.Create((Nullable<long>)null,\
    \ largestOfNegatives);\n        }\n        return ret;"]
stop_tokens:
- "\n    }\n"
