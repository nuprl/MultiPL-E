name: HumanEval_30_get_positive
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return only positive numbers in the list.\n    // >>> GetPositive((new\
  \ List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))\n\
  \    // (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))\n    // >>> GetPositive((new\
  \ List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L,\
  \ (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))\n    // (new List<long>(new\
  \ long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))\n\
  \    public static List<long> GetPositive(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetPositive((new\
  \ List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new\
  \ List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));\n    Debug.Assert(GetPositive((new\
  \ List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L,\
  \ (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new\
  \ long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L,\
  \ (long)1L}))));\n    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L,\
  \ (long)-2L}))).Equals((new List<long>())));\n    Debug.Assert(GetPositive((new\
  \ List<long>())).Equals((new List<long>())));\n    }\n\n}\n"
completions: ['        return l.Where(x => x >= 0).ToList();', "        List<long>\
    \ positive = new List<long>();\n        for (int i = l.Count - 1; i >= 0; i--)\
    \ {\n            if (l[i] > 0) positive.Add(l[i]);\n        }\n        return\
    \ positive;", "        var list = new List<long>(l.Count);\n        foreach (var\
    \ n in l)\n            if (n > 0)\n                list.Add(n);\n        return\
    \ list;", "        var res = new List<long>();\n        foreach (var i in l) {\n\
    \            if (i >= 0)\n                res.Add(i);\n        }\n        return\
    \ res;", "        l.RemoveAll(l => l < 0);\n        return l.Where(l => l >= 0).ToList();",
  '        return l.Where(x => x > 0).ToList();', "        var s = l.ToString() +\
    \ \"\";\n        var r = new StringBuilder(s);\n        for (int i = 0; i < r.Length;\
    \ i++) {\n            if (r[i] != \"+\" && r[i] != \"-\") {\n                r[i]\
    \ = \"0\";\n            }\n        }\n        return l.Where(x => x >= 0L).Select(x\
    \ => Convert.ToInt64(x.ToString())).ToList();", "        List<long> ret = new\
    \ List<long>();\n        foreach (long n in l)\n            if (n >= 0L)\n   \
    \             ret.Add(n);\n        return ret;", "        List<long> v = new List<long>();\n\
    \        if (l.Count > 0) {\n            v.AddRange(l.Where(x => x >= 0L));\n\
    \            v.Sort();\n            v.AddRange(l.Where(x => x < 0L));\n      \
    \      v.Sort();\n        }\n        return v;", "        var r = new List<long>(l.Count);\n\
    \        r.AddRange(l.Where(x => x >= 0L));\n        return r;", "        var\
    \ positives = new List<long>();\n        foreach (long x in l) {\n           \
    \ if (x > 0) positives.Add(x);\n        }\n        return positives;", '        return
    l.Where(i => i >= 0).ToList();', "        if (l == null || l.Count <= 0) {\n \
    \           return new List<long>();\n        }\n        var res = new List<long>();\n\
    \        var maxVal = l.Max();\n        foreach (var i in l) {\n            if\
    \ (i > 0) {\n                res.Add(i);\n            }\n        }\n        if\
    \ (res.Count == 1) {\n            return res;\n        }\n        List<long> res;\n\
    \        if (maxVal < 0) {\n            res = GetPositive(GetPositive(res));\n\
    \        } else {\n            res = GetPositive(GetPositive(GetPositive(res)));\n\
    \        }\n        if (res.Count > 1) {\n            var m = (long)((1L << 31)\
    \ - 1L);\n            var b = maxVal - m;\n            var s = GetPositive(res);\n\
    \            while (b.GetHashCode() > 0) {\n                var hash = ((long)1\
    \ << 31) - b;\n                var t = s + hash;\n                res.Add(t);\n\
    \                b--;\n            }\n        }\n        return res;", "     \
    \   if (l.Count == 0)\n            return new List<long>();\n        List<long>\
    \ positives = new List<long>(l);\n        IEnumerable<long> positivesAsEnumerable\
    \ = positives;\n        IEnumerable<long> negativesAsEnumerable = positivesAsEnumerable\n\
    \            .Where(x => x == 0);\n        IEnumerable<long> negativesAsEnumerable2\
    \ = negativesAsEnumerable\n            .Where(x => x != 0);\n        IEnumerable<long>\
    \ positivesAsEnumerable3 = positivesAsEnumerable2\n            .Where(x => x !=\
    \ 0);\n        IEnumerable<long> positivesAsEnumerable4 = positivesAsEnumerable3\n\
    \            .Where(x => x != 0);\n        IEnumerable<long> positivesAsEnumerable5\
    \ = positivesAsEnumerable4\n            .Where(x => x != 0);\n        IEnumerable<long>\
    \ positivesAsEnumerable6 = positivesAsEnumerable5\n            .Where(x => x !=\
    \ 0);\n        IEnumerable<long> positivesAsEnumerable7 = positivesAsEnumerable6\n\
    \            .Where(x => x != 0);\n        IEnumerable<long> positivesAsEnumerable8\
    \ = positivesAsEnumerable7\n            .Where(x => x != 0);\n        IEnumerable<long>\
    \ positivesAsEnumerable9 = positivesAsEnumerable8\n            .Where(x => x !=\
    \ 0);\n        IEnumerable<long> positivesAsEnumerable10 = positivesAsEnumerable9\n\
    \            .Where(x => x != 0);\n        IEnumerable<long> positivesAsEnumerable11\
    \ = positivesAsEnumerable10\n            .Where(x => x != 0);\n        IEnumerable<long>\
    \ positivesAsEnumerable12 = positivesAsEnumerable11\n            .Where(x => x\
    \ != 0);\n        IEnumerable<long> positivesAsEnumerable13 = positivesAsEnumerable12\n\
    \            .Where(x => x != 0);\n        IEnumerable<long> positivesAsEnumerable14\
    \ = positivesAsEnumerable13\n            .Where(x => x != 0);\n        IEnumerable<long>\
    \ positivesAsEnumerable15 = positivesAsEnumerable14\n            .Where(x => x\
    \ != 0);\n        IEnumerable<long> positivesAsEnumerable16 = positivesAsEnumerable15\n\
    \            .Where(x => x != 0);\n        IEnumerable<long> positivesAsEnumerable17\
    \ = positivesAsEnumerable16\n            .Where(", '        return l.Where(x =>
    x >= 0).ToList();', "        if (l.Count == 0) return new List<long>();\n    \
    \    var positives = new List<long>();\n        var negs = new List<long>();\n\
    \        foreach (var n in l) {\n            if (n > 0) {\n                positives.Add(n);\n\
    \            } else {\n                negs.Add(n);\n            }\n        }\n\
    \        // Add the remaining positive numbers.\n        positives.AddRange(GetPositive(negs));\n\
    \        return positives;", '        return l.Where(x => x >= 0L).ToList();',
  "        var list = l.ToList();\n        list.Sort();\n        var result = (from\
    \ n in list where n > 0 select n).ToList();\n        return result;", '        return
    l.Where(x => x > 0).ToList();', '        return l.Where(x => x >= 0L).ToList();',
  "        long positive = Long.MinValue;\n        foreach (long n in l)\n       \
    \     if (n > positive)\n                positive = n;\n        List<long> result\
    \ = new List<long>();\n        foreach (long n in l)\n            if (n > positive)\n\
    \                result.Add(n);\n        return result;", '        return l.Where(n
    => n >= 0L).ToList();', "        List<long> out = new List<long>();\n        foreach\
    \ (long n in l)\n            if (n > 0)\n                out.Add(n);\n       \
    \ return out;", "        List<long> res = new List<long>();\n        foreach (var\
    \ v in l) {\n            if (v > 0) res.Add(v);\n        }\n        return res;",
  "        List<long> positive = new List<long>();\n        foreach (long n in l)\
    \ {\n            if (n > 0) {\n                positive.Add(n);\n            }\n\
    \        }\n        return positive;", '        return l.Where(x => (x > 0)).ToList();',
  '        return l.Where(x => x >= 0).ToList();', '        return l.Where(a => a
    >= 0L).ToList();', "        List<long> positive = new List<long>();\n        foreach\
    \ (long i in l) {\n            if (i >= 0)\n                positive.Add(i);\n\
    \        }\n        return positive;", "        List<long> newlist = new List<long>(l.Count);\n\
    \        foreach (long x in l) {\n            if (x > 0)\n                newlist.Add(x);\n\
    \        }\n        return newlist;", "        var positives = new List<long>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            if (l[i] > 0)\n    \
    \            positives.Add(l[i]);\n        }\n        return positives;", "  \
    \      // Sort the list to remove duplicates.\n        l.Sort();\n        // Initialize\
    \ a boolean array.\n        bool[] bools = new bool[l.Count];\n        // Set\
    \ up the initial state.\n        bool initial = true;\n        // Loop through\
    \ each number in the list to compute boolean values for\n        // the boolean\
    \ array.\n        for (int i = 0; i < l.Count; i++) {\n            // If current\
    \ number is negative, set the state accordingly.\n            if (l[i] < 0) {\n\
    \                initial = false;\n            }\n            // If current number\
    \ is non-negative, set the state accordingly.\n            else {\n          \
    \      bools[i] = initial;\n            }\n        }\n        // Return only the\
    \ positive numbers in the list.\n        return new List<long>(l.Where(x => bools.Contains(x)).OrderBy(x\
    \ => x));", "        var r = new List<long>();\n        foreach (var x in l) {\n\
    \            if (x >= 0) r.Add(x);\n        }\n        return r;", "        var\
    \ positive = l.Where(l => l > 0L).ToList();\n        positive.ForEach(l => l.Dump());\n\
    \        return positive;", "        List<long> positive = new List<long>();\n\
    \        foreach (long x in l)\n            if (x >= 0) positive.Add(x);\n   \
    \     return positive;", "        List<long> res = new List<long>();\n       \
    \ foreach (long val in l)\n            if (val >= 0)\n                res.Add(val);\n\
    \        return res;", "        var list = new List<long>(l);\n        list.RemoveAll(n\
    \ => n < 0);\n        return list.Take(list.Count - list.Count % 2).ToList();",
  "        var result = new List<long>();\n        foreach (var item in l) {\n   \
    \         if (item > 0) {\n                result.Add(item);\n            }\n\
    \        }\n        return result;", "        List<long> positive = new List<long>();\n\
    \        foreach (long k in l) {\n            if (k >= 0)\n                positive.Add(k);\n\
    \        }\n        return positive;", "        List<long> ret = new List<long>();\n\
    \        foreach (var i in l) {\n            if (i >= 0) {\n                ret.Add(i);\n\
    \            }\n        }\n        return ret;", "        List<long> rv = l.Where(x\
    \ => x >= 0).ToList();\n        r.Reverse(rv);\n        return rv;", "       \
    \ List<long> ret = new List<long>();\n        foreach (long i in l) {\n      \
    \      if (i >= 0) ret.Add(i);\n        }\n        return ret;", "        var\
    \ res = new List<long>();\n        foreach (var n in l.OfType<long>().Where(x\
    \ => x > 0L)) {\n            res.Add(n);\n        }\n        return res;", " \
    \       var ret = new List<long>();\n        foreach (long n in l)\n        {\n\
    \            if (n > 0)\n                ret.Add(n);\n        }\n        return\
    \ ret;", "        List<long> positive = new List<long>();\n        foreach (var\
    \ n in l) {\n            if (n > 0) positive.Add(n);\n        }\n        return\
    \ positive;", "        var positive = l.Where(x => x > 0).ToList();\n        if\
    \ (positive.Count == l.Count) return positive;\n        return null;", "     \
    \   var positive = l.Where(x => x > 0).ToList();\n        return positive;", " \
    \       List<long> result = new List<long>();\n        foreach(long x in l) {\
    \ if (x > 0) result.Add(x); }\n        return result;", "        long negative\
    \ = Long.MinValue;\n        List<long> positive = new List<long>();\n        for\
    \ (int i = 0; i < l.Count; i++) {\n            if (l[i] > negative) {\n      \
    \          negative = l[i];\n            }\n            if (l[i] < 0) {\n    \
    \            negative = -l[i];\n            }\n            if (l[i] > 0) {\n \
    \               positive.Add(l[i]);\n            }\n        }\n        return\
    \ positive;", "        l.Sort();\n        return l.Where(x => x >= 0).ToList();",
  "        var result = new List<long>();\n        foreach (var item in l) {\n   \
    \         if (item > 0) result.Add(item);\n        }\n        return result;",
  "        if (l == null || l.Count == 0)\n            return l;\n        List<long>\
    \ res = new List<long>();\n        foreach (long x in l) {\n            if (x\
    \ >= 0)\n                res.Add(x);\n        }\n        return res;", "     \
    \   var positive = new List<long>();\n        foreach (var item in l)\n      \
    \  {\n            if (item > 0)\n            {\n                positive.Add(item);\n\
    \            }\n        }\n        return positive;", "        List<long> positive\
    \ = new List<long>();\n        foreach (long i in l) {\n            if (i >= 0)\
    \ {\n                positive.Add(i);\n            }\n        }\n        return\
    \ positive;", '        return l.Where(x => x >= 0).ToList();', "        if (l.Count\
    \ == 0) {\n            return l;\n        }\n        var positive = new List<long>(l.Count);\n\
    \        foreach (var x in l) {\n            if (x >= 0) {\n                positive.Add(x);\n\
    \            }\n        }\n        return positive;", "        var result = new\
    \ List<long>();\n        if (l == null)\n            return result;\n        foreach\
    \ (var item in l) {\n            int positive = 0;\n            while (item >\
    \ 0) {\n                item = item / 10;\n                positive++;\n     \
    \       }\n            if (positive > 0)\n                result.Add(item);\n\
    \        }\n        return result;", "        l.Sort();\n        var positive\
    \ = new List<long>();\n        foreach (var x in l) {\n            if (x >= 0)\n\
    \                positive.Add(x);\n        }\n        return positive;", '        return
    l.Where(x => x >= 0).ToList();', "        List<long> positive = new List<long>();\n\
    \        foreach (long n in l) {\n            if (n > 0L) {\n                positive.Add(n);\n\
    \            }\n        }\n        return positive;", "        var res = new List<long>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            if (l[i] >= 0) {\n \
    \               res.Add(l[i]);\n            }\n        }\n        return res;",
  "        List<long> res = new List<long>();\n        foreach (long l in l)\n   \
    \         if (l > 0)\n                res.Add(l);\n        return res;", "   \
    \     // Add 'l' to the list.\n        var res = new List<long>();\n        res.AddRange(l.ToList());\n\
    \        // Find 'l' as a positive number in the list.\n        var found = false;\n\
    \        for (long i = 0; i < res.Count; i++) {\n            if (res[i] > 0) {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        // Remove all positive numbers in the list.\n        if (found)\
    \ {\n            for (int i = res.Count - 1; i >= 0; i--) {\n                if\
    \ (res[i] > 0) {\n                    res.RemoveAt(i);\n                }\n  \
    \          }\n        }\n        return res;", "        var c = new List<long>();\n\
    \        foreach (var x in l)\n            if (x > 0)\n                c.Add(x);\n\
    \        return c;", "        List<long> r = new List<long>();\n        foreach\
    \ (long n in l) {\n            if (n >= 0) {\n                r.Add(n);\n    \
    \        }\n        }\n        return r;", "        List<long> result = new List<long>(l.Count);\n\
    \        foreach (long a in l)\n            if (a > 0)\n                result.Add(a);\n\
    \        return result;", '        return l.Where(x => x > 0).ToList();', '        return
    l.Where(x => x >= 0L).ToList();', "        // Use a binary search to find the\
    \ first positive number.\n        int lo = 0;\n        int hi = l.Count - 1;\n\
    \        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n          \
    \  if (l[mid] > 0) {\n                lo = mid;\n            } else {\n      \
    \          hi = mid - 1;\n            }\n        }\n        // Reverse the sorted\
    \ list and return the result.\n        List<long> result = new List<long>();\n\
    \        for (int i = hi - 1; i >= lo; i--) {\n            result.Add(l[i]);\n\
    \        }\n        result.Reverse();\n        return result;", "        List<long>\
    \ ret = new List<long>();\n        foreach (long n in l) {\n            if (n\
    \ > 0L) {\n                ret.Add(n);\n            }\n        }\n        return\
    \ ret;", "        List<long> result = new List<long>();\n        bool foundNegative\
    \ = true;\n        foreach (long num in l) {\n            if (num < 0 && !foundNegative)\
    \ {\n                foundNegative = true;\n                result.Add(num);\n\
    \            } else if (num > 0) {\n                foundNegative = false;\n \
    \               result.Add(num);\n            }\n        }\n        return result;",
  "        var l2 = l.Where(o => o > 0).ToList();\n        return l2.Count > 0 ? l2\
    \ : l;", "        if (l.Count == 0) { return l; }\n        if (l.Count < 2) {\
    \ return l; }\n        List<long> rs = new List<long>();\n        long minVal\
    \ = l.Min();\n        bool minLess = l.Min() <= 0;\n        long maxVal = l.Max();\n\
    \        bool maxLess = l.Max() >= 0;\n        bool allLess = minLess && maxLess;\n\
    \        bool allEqual = minVal == maxVal;\n        if (allLess) {\n         \
    \   foreach (long v in l) {\n                if (v < 0) {\n                  \
    \  Debug.Fail(\"Negative value found\");\n                }\n                if\
    \ (!minLess && v < minVal) {\n                    minVal = v;\n              \
    \  }\n                if (!maxLess && v > maxVal) {\n                    maxVal\
    \ = v;\n                }\n                Debug.Assert(!allEqual);\n        \
    \        rs.Add(v);\n            }\n        }\n        else {\n            for\
    \ (int i = 0; i < l.Count; i++) {\n                long v = l[i];\n          \
    \      if (minLess && v < minVal) {\n                    minVal = v;\n       \
    \         }\n                if (maxLess && v > maxVal) {\n                  \
    \  maxVal = v;\n                }\n                Debug.Assert(!allEqual);\n\
    \                rs.Add(v);\n            }\n        }\n        return allEqual\
    \ ? rs : new List<long>(new long[]{minVal, maxVal});", "        var positives\
    \ = new List<long>();\n        foreach (long n in l) {\n            if (n > 0)\
    \ positives.Add(n);\n        }\n        return positives;", "        List<long>\
    \ positives = new List<long>();\n        foreach (var i in l) {\n            if\
    \ (i > 0) positives.Add(i);\n        }\n        return positives;", "        var\
    \ positive = new List<long>();\n        foreach (var i in l) {\n            if\
    \ (i > 0) positive.Add(i);\n        }\n        return positive;", '        return
    l.Where(n => n >= 0).ToList();', "        var r = new List<long>();\n        foreach\
    \ (var x in l) if (x > 0) r.Add(x);\n        return r;", '        return l.Where(i
    => i >= 0).ToList();', '        return l.Where(x => x > 0).ToList();', "     \
    \   List<long> res = new List<long>();\n        foreach (long l in l) {\n    \
    \        if (l > 0) {\n                res.Add(l);\n            }\n        }\n\
    \        return res;", "        var positives = new List<long>();\n        foreach\
    \ (var n in l) {\n            if (n >= 0)\n                positives.Add(n);\n\
    \        }\n        return positives;", "        List<long> positive = new List<long>();\n\
    \        foreach(var item in l) {\n            if(item > 0)\n                positive.Add(item);\n\
    \        }\n        return positive;", "        List<long> r = new List<long>(l.Count);\n\
    \        long c = long.MinValue;\n        foreach (long x in l)\n            if\
    \ (x >= 0) c = Math.Min(x, c);\n            else\n                r.RemoveAt(r.Count-1);\n\
    \        return r;", "        if (l.Count < 2) return l;\n        l.Sort();\n\
    \        int pos = 0;\n        int neg = l.Count - 1;\n        List<long> result\
    \ = new List<long>();\n        while (pos < l.Count && neg > 0) {\n          \
    \  long value = l[pos] + l[neg];\n            if (value > 0) result.Add(value);\n\
    \            if (value == 0) result.Add(-l[neg]);\n            pos++;\n      \
    \      neg--;\n        }\n        return result;", "        var positive = new\
    \ List<long>();\n        foreach (var i in l) {\n            if (i >= 0) {\n \
    \               positive.Add(i);\n            }\n        }\n        return positive;",
  "        var results = new List<long>();\n        foreach (var i in l) {\n     \
    \       if (i > 0)\n                results.Add(i);\n        }\n        return\
    \ results;", "        List<long> ret = new List<long>();\n        foreach (long\
    \ i in l) {\n            if ((i > 0) && (i < 100)) {\n                ret.Add(i);\n\
    \            }\n        }\n        return ret;", "        var ret = new List<long>();\n\
    \        l.ForEach(delegate (long x) {\n            if (x >= 0) ret.Add(x);\n\
    \        });\n        return ret;", "        Debug.Assert(l != null);\n      \
    \  List<long> r = new List<long>();\n        r.AddRange(l);\n        int index\
    \ = r.IndexOf(0L);\n        while (r[index] > 0L && index < r.Count - 1) {\n \
    \           r.RemoveAt(index);\n            r.Insert(index + 1, 0);\n        \
    \    index = r.IndexOf(0L);\n        }\n        while (r[index] > 0L) {\n    \
    \        r.RemoveAt(index);\n            index--;\n        }\n        return r;",
  "        foreach (var i in l)\n        {\n            if (i > 0)\n            {\n\
    \                return l;\n            }\n        }\n        return new List<long>();",
  "        List<long> positive = new List<long>();\n        long temp = 0;\n     \
    \   for (int i = 0; i < l.Count; i++) {\n            temp = l[i];\n          \
    \  if (temp >= 0) {\n                positive.Add(temp);\n            }\n    \
    \    }\n        return positive;", '        return l.Where(x => x >= 0).ToList();',
  "        var positives = l.Where(p => p > 0);\n        return positives.ToList();",
  "        var result = new List<long>();\n        foreach (var n in l)\n        \
    \    if (n >= 0L)\n                result.Add(n);\n        return result;", " \
    \       l.Sort();\n        var r = new List<long>();\n        long lastValue =\
    \ l.First();\n        foreach (long x in l)\n        {\n            if (x < lastValue)\
    \ r.Add(x);\n            lastValue = x;\n        }\n        return r;", "    \
    \    var ans = new List<long>();\n        for (int i = 0; i < l.Count; ++i) {\n\
    \            if (l[i] > 0)\n                ans.Add(l[i]);\n        }\n      \
    \  return ans;", "        var l2 = new List<long>();\n        var n = l.Count;\n\
    \        long sum = 0;\n        long max = 0;\n        long sum2 = 1L;\n     \
    \   for (int i = 0; i < n; i++) {\n            sum = sum + l[i];\n           \
    \ if (sum > max) {\n                max = sum;\n            }\n        }\n   \
    \     for (int i = 0; i < n; i++) {\n            sum2 = sum2 * l[i];\n       \
    \     if (sum2 > max) {\n                max = sum2;\n            }\n        }\n\
    \        for (int i = 0; i < n; i++) {\n            if (l[i] <= 0) {\n       \
    \         l2.Add(0);\n            } else {\n                l2.Add((int)Math.Ceiling(max\
    \ * l[i] / sum));\n            }\n        }\n        return l2;", "        long\
    \ maxVal = 0;\n        List<long> ret = new List<long>();\n\n        foreach(long\
    \ x in l) \n        {\n            if(x >= 0) \n            {\n              \
    \  ret.Add(x);\n            }\n            else\n            {\n             \
    \   // Find max value\n                long maxX = x;\n                foreach(long\
    \ y in ret) \n                {\n                    if(maxX >= y) \n        \
    \            {\n                        maxX = y;\n                    }\n   \
    \             }\n                // Remove max value from list\n             \
    \   ret.Remove(maxX);\n            }\n        }\n        return ret;", "     \
    \   var negatives = new List<long>();\n        foreach (var i in l) if (i < 0)\
    \ negatives.Add(i);\n        return negatives;", "        var result = l.ToList();\n\
    \        foreach (var v in result) {\n            if (v > 0) {\n             \
    \   result.Remove(v);\n            }\n        }\n        return result.ToList();",
  '        return l.Where(i => i >= 0L).ToList();', "        List<long> ret = new\
    \ List<long>();\n        foreach (var item in l) {\n            if (item > 0)\
    \ {\n                ret.Add(item);\n            }\n        }\n        return\
    \ ret;", "        List<long> positives = new List<long>();\n        foreach (long\
    \ n in l) {\n            if (n > 0) {\n                positives.Add(n);\n   \
    \         }\n        }\n        return positives;", '        return l.Where(x
    => x > 0L).ToList();', "        if (l.Count < 1) throw new ArgumentException(\"\
    l must not be empty.\", \"l\");\n        if (l.Count == 1) return l;\n       \
    \ List<long> result = new List<long>();\n        foreach (var i in l)\n      \
    \      if (i >= 0) result.Add(i);\n        return result;", "        var result\
    \ = new List<long>();\n        foreach (var i in l) {\n            if (i.Equals(0)\
    \ || i.Equals(1) || i.Equals(-1L)) {\n                result.Add(i);\n       \
    \     }\n            else {\n                result.Add((long) Math.Max(i, 0));\n\
    \            }\n        }\n        return result;", "        l.Sort();\n     \
    \   var positive = new List<long>();\n        for (int i = 0; i < l.Count(); ++i)\
    \ {\n            if (l[i] > 0)\n                positive.Add(l[i]);\n        }\n\
    \        return positive;", "        if (l.Count == 0) return new List<long>();\n\
    \        var newList = new List<long>(l);\n        long l = newList[0];\n    \
    \    for (int i = 1; i < l.Count; i++) {\n            if (l[i] > l[i - 1]) continue;\n\
    \            newList.RemoveAt(i - 1);\n            l[i - 1] = 0;\n           \
    \ l = newList[i];\n        }\n        return newList;", '        return l.Where(x
    => x >= 0).ToList();', '        return l.Where(x => x > 0).ToList();', "     \
    \   var positives = new List<long>();\n        foreach (var num in l)\n      \
    \  {\n            if (num > 0L)\n            {\n                positives.Add(num);\n\
    \            }\n        }\n        return positives;", "        if (l == null\
    \ || l.Count == 0) return null;\n        var r = new List<long>();\n        foreach\
    \ (var i in l) {\n            if (i.CompareTo(1L) == 0) r.Add(i);\n        }\n\
    \        return r;", '        return l.Where(n => n > 0).ToList();', "       \
    \ long temp = 0;\n        foreach (long n in l)\n        {\n            if (n\
    \ > 0L)\n            {\n                temp = n;\n                break;\n  \
    \          }\n        }\n        return new List<long>(l.Where((n) => n > 0L).ToArray());",
  "        // Build list of non-negative integers.\n        List<long> n = new List<long>();\n\
    \        foreach (long x in l)\n            if (x >= 0)\n                n.Add(x);\n\
    \n        // Sort the list.\n        n.Sort();\n\n        // Return non-negative\
    \ numbers in ascending order.\n        List<long> ret = new List<long>();\n  \
    \      for (int i = 0; i < n.Count - 1; i++)\n            if (n[i] < n[i + 1])\n\
    \                ret.Add(n[i]);\n            else\n                ret.Add(n[i\
    \ + 1]);\n\n        // Return only positive numbers.\n        return ret;", " \
    \       if (l == null) return null;\n        var ret = new List<long>();\n   \
    \     foreach (var item in l) {\n            if (item > 0) ret.Add(item);\n  \
    \      }\n        return ret;", "        Debug.Assert(l != null, \"GetPositive\
    \ called with null list.\");\n        List<long> result = new List<long>();\n\
    \        foreach (long l in l) {\n            if (l >= 0) result.Add(l);\n   \
    \     }\n        return result;", "        List<long> positive = new List<long>();\n\
    \        foreach (long n in l) {\n            if (n > 0) {\n                positive.Add(n);\n\
    \            }\n        }\n        return positive;", "        List<long> positive\
    \ = new List<long>();\n        if (l.Any()) {\n            var r = l.TakeWhile(x\
    \ => x >= 0);\n            positive.AddRange(r);\n        }\n        return positive;",
  "        // Sort the list first.\n        l.Sort();\n\n        // Start with the\
    \ first element of the list as the minimum.\n        var minValue = l.First();\n\
    \n        // For each element, subtract the next value from the minimum.\n   \
    \     for (int i = 1; i < l.Count; i++) {\n            var minIndex = i;\n   \
    \         var minValue = l[minIndex];\n\n            // If this element is the\
    \ minimum, then skip to next element\n            if (minValue == minIndex) {\n\
    \                i++;\n                continue;\n            }\n\n          \
    \  // Find the index at which this value is greater than the minimum.\n      \
    \      for (int j = minIndex; j < l.Count; j++) {\n                var elementValue\
    \ = l[j];\n\n                // If the element is greater than the minimum, then\
    \ we're done.\n                if (elementValue > minValue)\n                \
    \    break;\n\n                // If the element is less than the minimum, then\
    \ we know that\n                // we can't skip any further elements because\
    \ we haven't reached\n                // the minimum yet, so set minValue to that\
    \ element.\n                else {\n                    minValue = elementValue;\n\
    \                    minIndex = j;\n                }\n            }\n\n     \
    \       // Set the min element to the value at this index.\n            l[minIndex]\
    \ = minValue;\n        }\n\n        // Return the result.\n        return l;",
  "        var l2 = l.Where(n => n > 0L).ToList();\n        return new List<long>(l2);",
  "        l.Sort();\n        List<long> r = new List<long>();\n        List<long>\
    \ t = new List<long>();\n        while (l.Count > 0) {\n            r.Add(l.First());\n\
    \            l.RemoveAt(0);\n        }\n        for (int i = 0; i < r.Count; i++)\
    \ {\n            t.Add(r[i]);\n            for (int j = i + 1; j < r.Count; j++)\
    \ {\n                if (r[j] < 0) {\n                    r.RemoveAt(j);\n   \
    \                 r.Insert(i, r[j]);\n                    break;\n           \
    \     }\n            }\n        }\n        return r;", '        return l.Where(i
    => i > 0).ToList();', '        return l.Where(l => l > 0).ToList();', "      \
    \  List<long> r = new List<long>();\n        foreach (long n in l)\n        {\n\
    \            if (n > 0)\n            {\n                r.Add(n);\n          \
    \  }\n        }\n        return r;", "        var positive = new List<long>();\n\
    \        l.ForEach(x => {\n            if (x >= 0L)\n                positive.Add(x);\n\
    \        });\n        return positive;", '        return l.Where(x => x >= 0).ToList();',
  "        List<long> positive = new List<long>();\n        foreach (var el in l)\n\
    \            if (el >= 0)\n                positive.Add(el);\n        return positive;",
  "        var list = new List<long>();\n        foreach(var value in l) {\n     \
    \       if(value > 0) {\n                list.Add(value);\n            }\n   \
    \     }\n        return list;", "        if (l.Count == 0)\n            throw\
    \ new ArgumentException(\"Input list cannot be empty.\");\n        var r = new\
    \ List<long>();\n        foreach (var n in l)\n            r.Add((n < 0L) ? 0L\
    \ : n);\n        return r;", "        List<long> ret = new List<long>();\n   \
    \     foreach (long i in l) {\n            if ((i < 0) == false) {\n         \
    \       ret.Add(i);\n            }\n        }\n        return ret;", "       \
    \ var positive = new List<long>(l.Count);\n        var i = l.Count - 1;\n    \
    \    while (i >= 0) {\n            if (l[i] > 0) {\n                positive.Add(l[i]);\n\
    \                i--;\n            }\n        }\n        return positive;", '        return
    l.Where(d => d > 0).ToList();', "        long[] values = new long[l.Count];\n\
    \        l.CopyTo(values, 0);\n        Array.Sort(values);\n        List<long>\
    \ result = new List<long>();\n        bool first = true;\n        for (int i =\
    \ 0; i < values.Length; i++) {\n            if (!first) {\n                if\
    \ (values[i] > 0)\n                    result.Add(values[i]);\n            }\n\
    \            first = false;\n        }\n        return result;", "        List<long>\
    \ positive = new List<long>();\n        foreach (long i in l) {\n            if\
    \ (i >= 0) {\n                positive.Add(i);\n            }\n        }\n   \
    \     return positive;", "        if (l.Count == 0) return new List<long>();\n\
    \        var result = new List<long>();\n        // Scan the numbers in descending\
    \ order.\n        var list = l.OrderByDescending(x => x).ToList();\n        //\
    \ Find the first number greater than zero.\n        var firstNonZero = list.TakeWhile(x\
    \ => x != 0);\n        foreach (var x in firstNonZero) {\n            if (x >\
    \ 0) result.Add(x);\n            list.remove(x);\n        }\n        return result;",
  "        List<long> ret = new List<long>();\n        foreach (var n in l) {\n  \
    \          if (n > 0L) ret.Add(n);\n        }\n        return ret;", "       \
    \ // Sort the list from greatest to least so that we don't get duplicates.\n \
    \       l.Sort();\n        var positives = new List<long>();\n        foreach\
    \ (var number in l) {\n            // If the number is negative or zero, move\
    \ onto the next number.\n            if (number < 0) {\n                continue;\n\
    \            }\n            // If the number is positive, add it to the list.\n\
    \            if (number > 0) {\n                positives.Add(number);\n     \
    \       }\n        }\n        // Return the list with only positive numbers.\n\
    \        return positives;", '        return l.Where((i) => i >= 0).ToList();',
  "        var result = new List<long>();\n        foreach (long n in l) {\n     \
    \       if (n > 0) {\n                result.Add(n);\n            }\n        }\n\
    \        return result;", "        List<long> res = new List<long>();\n      \
    \  foreach (long n in l) {\n            if (n > 0) {\n                res.Add(n);\n\
    \            }\n        }\n        return res;", '        return l.Where(x =>
    x > 0).ToList();', '        return l.Where(x => x > 0).ToList();', "        List<long>\
    \ result = new List<long>();\n        var positive = l.Where(n => n > 0);\n  \
    \      foreach (long n in positive) {\n            result.Add(n);\n        }\n\
    \        return result;", "        var positives = new List<long>();\n       \
    \ foreach (var item in l) {\n            if (item > 0) positives.Add(item);\n\
    \        }\n        return positives;", "        if (l.Count == 0) {\n       \
    \     throw new ArgumentException(\"l is empty.\");\n        }\n        var r\
    \ = new List<long>();\n        foreach (var num in l) {\n            if (num >\
    \ 0) {\n                r.Add(num);\n            }\n        }\n        return\
    \ r;", "        if (l == null || l.Count < 1)\n            throw new ArgumentNullException(nameof(l));\n\
    \        var ret = l.Where(x => x > 0).OrderBy(x => x).ToList();\n        if (ret.Count\
    \ != l.Count)\n            throw new InvalidOperationException(\"GetPositive:\
    \ ret = {0}, l = {1}\", ret, l);\n        return ret;", "        l.Sort(delegate(long\
    \ x, long y) { return (long)((int)Math.Sign(x)-(int)Math.Sign(y)) * (int)Math.Sign(x-y)\
    \ });\n        List<long> result = new List<long>(l);\n        int i = 1;\n  \
    \      while (i < result.Count) {\n            if (result[i] - result[i-1] !=\
    \ 1L) {\n                result.RemoveAt(i-1);\n            }\n            i++;\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        // Keep the list sorted.\n        l.Sort();\n        for (int i = 0;\
    \ i < l.Count - 1; ++i) {\n            if (l[i] > 0 && l[i + 1] > 0) {\n     \
    \           result.Add(l[i]);\n                ++i;\n            } else if (l[i]\
    \ > 0) {\n                result.Add(l[i]);\n            }\n        }\n      \
    \  return result;", "        List<long> positives = new List<long>();\n      \
    \  foreach (long num in l) {\n            if (num > 0)\n                positives.Add(num);\n\
    \        }\n        return positives;", "        l.Sort();\n        return l.Where(x\
    \ => x > 0).ToList();", '        return l.Where(x => x > 0).ToList();', '        return
    l.Where(x => x > 0).ToList();', "        List<long> result = new List<long>();\n\
    \        foreach (long x in l)\n            if (x >= 0)\n                result.Add(x);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     foreach (long n in l) {\n            if (n >= 0L) {\n                result.Add(n);\n\
    \            }\n        }\n        return result;", '        return l.Where(x
    => x > 0L).ToList();', "        var result = new List<long>();\n        foreach\
    \ (long x in l) {\n            if (x > 0) result.Add(x);\n        }\n        return\
    \ result;", "        List<long> positive = new List<long>();\n        foreach\
    \ (long item in l) {\n            if (item > 0) {\n                positive.Add(item);\n\
    \            }\n        }\n        return positive;", "        var positives =\
    \ new List<long>(l.Where(n => n >= 0));\n        // For a fixed list of integers,\
    \ there will be some integers which are not positive, and some positive integers\
    \ \n        // which are not positive. Let's find out which of them are missing.\
    \ This can be done by finding out what integers\n        // are repeated in `l`\
    \ and then subtracting the repeating ones from `l`.\n        var repeatedIntegers\
    \ = l.GroupBy(n => n).Where(n => n.Count() > 1).Select(n => n.Key);\n        foreach\
    \ (var r in repeatedIntegers)\n        {\n            l.Remove(r);\n        }\n\
    \        return positives;", '        return l.Where(n => n > 0).ToList();', '        return
    l.Where(n => n > 0).ToList();', "        // Create a list that only holds positive\
    \ numbers.\n        List<long> m = new List<long>(l.Where(x => x >= 0L).ToList());\n\
    \        if (m.Count == 0) {\n            // This should never happen.\n     \
    \       throw new Exception(\"GetPositive: No positive numbers in the list.\"\
    );\n        }\n        return m;", "        List<long> res = new List<long>();\n\
    \        foreach (long x in l)\n        {\n            if (x >= 0)\n         \
    \   {\n                res.Add(x);\n            }\n        }\n        return res;",
  "        List<long> result = new List<long>();\n        // Keep adding numbers,\
    \ keeping track of the biggest one.\n        long biggest = -10000000L;\n    \
    \    foreach(long n in l) {\n            if(n > biggest) {\n                biggest\
    \ = n;\n            }\n            if(!result.Contains(n)) {\n               \
    \ result.Add(n);\n            }\n        }\n        return result;", "       \
    \ l.Sort();\n        var positives = l.Where(x => (x >= 0L)).ToArray();\n    \
    \    l.Clear();\n        l.AddRange(positives);\n        return l;", '        return
    l.Where(n => n > 0).ToList();', "        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long x in l) {\n            if (x > 0) set.Add(x);\n       \
    \ }\n        return new List<long>(set.ToArray());", "        List<long> positives\
    \ = new List<long>();\n        foreach (long x in l) {\n            if (x > 0)\n\
    \                positives.Add(x);\n        }\n        return positives;", " \
    \       List<long> positive = new List<long>();\n        foreach (long value in\
    \ l) {\n            if (value > 0) {\n                positive.Add(value);\n \
    \           }\n        }\n        return positive;", "        List<long> result\
    \ = new List<long>();\n        foreach (long item in l) {\n            if (item\
    \ > 0)\n                result.Add(item);\n        }\n        return result;",
  "        var result = new List<long>();\n        foreach (var i in l) {\n      \
    \      result += (i * i);\n        }\n        long temp = 0;\n        foreach\
    \ (var i in result) {\n            temp = i;\n            if (temp < 0)\n    \
    \            break;\n        }\n        List<long> tempList = new List<long>();\n\
    \        do {\n            tempList.Add(temp--);\n        } while (temp > 0);\n\
    \        return tempList;", "        var ret = new List<long>();\n        var\
    \ positive = true;\n        foreach (var i in l) {\n            if (i >= 0) {\n\
    \                positive = true;\n                ret.Add(i);\n            }\n\
    \            else if (positive) {\n                ret.Add(i);\n            }\n\
    \            else {\n                positive = false;\n            }\n      \
    \  }\n        if (positive) {\n            return ret;\n        }\n        return\
    \ null;", "        List<long> result = new List<long>();\n        foreach (long\
    \ n in l) {\n            if (n > 0) {\n                result.Add(n);\n      \
    \      }\n        }\n        return result;", "        var r = new List<long>();\n\
    \        foreach(var i in l) {\n            if (i >= 0)\n                r.Add(i);\n\
    \        }\n        return r;", "        List<long> r = new List<long>();\n  \
    \      foreach (var item in l) {\n            if (item > 0)\n                r.Add(item);\n\
    \        }\n        return r;", "        List<long> positive = new List<long>();\n\
    \        foreach (var x in l)\n            if (x >= 0)\n                positive.Add(x);\n\
    \        return positive;", "        List<long> positive = new List<long>();\n\
    \        foreach(long value in l)\n            if(value>0)\n                positive.Add(value);\n\
    \        return positive;", "        List<long> res = new List<long>();\n    \
    \    foreach (var item in l)\n            if (item > 0)\n                res.Add(item);\n\
    \        return res;", "        List<long> res = new List<long>();\n        foreach\
    \ (long val in l) {\n            if (val >= 0) {\n                res.Add(val);\n\
    \            }\n        }\n        return res;", '        return l.Where(x =>
    x >= 0).ToList();', "        var pos = l.Where(x => x > 0).ToList();\n       \
    \ return pos.Where(x => x < 0).ToList();", "        List<long> ret = new List<long>();\n\
    \        foreach (long x in l) {\n            if (x > 0) ret.Add(x);\n       \
    \ }\n        return ret;", "        List<long> positive = new List<long>();\n\
    \        foreach (long n in l) {\n            if (n > 0) {\n                positive.Add(n);\n\
    \            }\n        }\n        return positive;", "        var positive =\
    \ new List<long>();\n        foreach (var num in l)\n            if (num > 0)\n\
    \                positive.Add(num);\n        return positive;", "        if (l.Any())\
    \ {\n            l.RemoveAll((p) => p == 0);\n            int pos = l.Count();\n\
    \            l.Sort();\n            List<long> ret = new List<long>(pos);\n  \
    \          for (int i = 0; i < pos; i++) {\n                if (l[i] > 0) {\n\
    \                    ret.Add(l[i]);\n                }\n            }\n      \
    \      return ret;\n        }\n        return new List<long>();", "        l.Sort();\n\
    \        var result = new List<long>();\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            if (l[i] > 0)\n                result.Add(l[i]);\n     \
    \   }\n        return result;", '        return l.Where(x => x > 0).ToList();',
  "        var ret = new List<long>();\n        foreach (var n in l)\n        {\n\
    \            if (n != 0)\n            {\n                ret.Add(n);\n       \
    \     }\n        }\n        return ret;", "        List<long> positives = new\
    \ List<long>();\n        for (int i = 0; i < l.Count; ++i) {\n            if (l[i]\
    \ >= 0)\n                positives.Add(l[i]);\n        }\n        return positives;",
  '        return l.Where(x => x >= 0).ToList();', "        var pos = l.Where(x =>\
    \ x >= 0L).Select(x => x).ToList();\n        return pos;", "        if (l == null)\
    \ throw new ArgumentNullException(\"l\");\n        return l.Where(i => i >= 0L).ToList();",
  "        List<long> result = new List<long>();\n        foreach (long value in l)\n\
    \            if (value > 0) {\n                result.Add(value);\n          \
    \  }\n        return result;", '        return l.Where(x => x > 0).ToList();',
  "        if (l.Count == 0) {\n            throw new InvalidOperationException(\"\
    List cannot be empty.\");\n        }\n        List<long> positive = new List<long>(l.Count);\n\
    \        foreach (long number in l) {\n            if (number >= 0) {\n      \
    \          positive.Add(number);\n            }\n        }\n        return positive;",
  "        var positive = new List<long>();\n        foreach(var v in l) {\n     \
    \       if (v > 0) {\n                positive.Add(v);\n            }\n      \
    \  }\n        return positive;", "        List<long> result = new List<long>();\n\
    \        foreach (long n in l) {\n            if (n >= 0) {\n                result.Add(n);\n\
    \            }\n        }\n        return result;", '        return l.Where(n
    => n > 0).ToList();', "        var r = new List<long>();\n        foreach (var\
    \ t in l) {\n            if (t >= 0) r.Add(t);\n        }\n        return r;"]
stop_tokens:
- "\n    }\n"
