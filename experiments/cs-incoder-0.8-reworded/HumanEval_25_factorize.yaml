name: HumanEval_25_factorize
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return list of prime factors of given integer in the order from\
  \ smallest to largest.\n    // Each of the factors should be listed number of times\
  \ corresponding to how many times it appeares in factorization.\n    // Input number\
  \ should be equal to the product of all factors\n    // >>> Factorize((8L))\n  \
  \  // (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))\n    // >>> Factorize((25L))\n\
  \    // (new List<long>(new long[]{(long)5L, (long)5L}))\n    // >>> Factorize((70L))\n\
  \    // (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))\n    public static\
  \ List<long> Factorize(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Factorize((2L)).Equals((new\
  \ List<long>(new long[]{(long)2L}))));\n    Debug.Assert(Factorize((4L)).Equals((new\
  \ List<long>(new long[]{(long)2L, (long)2L}))));\n    Debug.Assert(Factorize((8L)).Equals((new\
  \ List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));\n    Debug.Assert(Factorize((57L)).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)19L}))));\n    Debug.Assert(Factorize((3249L)).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));\n    Debug.Assert(Factorize((185193L)).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));\n\
  \    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L,\
  \ (long)19L, (long)19L, (long)19L}))));\n    Debug.Assert(Factorize((18L)).Equals((new\
  \ List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));\n    }\n\n}\n"
completions: ["        // Generate list of prime numbers for n.\n        List<long>\
    \ primes = new List<long>();\n        long n = n;\n        for (long i = 2; i\
    \ <= Math.Sqrt(n); i++) {\n            if (n % i == 0)\n                primes.Add(i);\n\
    \        }\n\n        List<long> factors = new List<long>();\n        for (long\
    \ prime : primes) {\n            while (n % prime == 0) {\n                factors.Add(prime);\n\
    \                n /= prime;\n            }\n        }\n\n        if (n > 1) {\n\
    \            factors.Add(n);\n        }\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        // Loop through the primes below n, testing\
    \ them for factors.\n        for (int i = 3; i <= n / i; i++) {\n            if\
    \ (n % i == 0) {\n                factors.Add(i);\n                // If this\
    \ factor appears more than once, then it cannot be prime, break from loop.\n \
    \               if (factors.Count(x => x == i) > 1) break;\n            }\n  \
    \      }\n        return factors;", "        long highestFactor = 1;\n       \
    \ long factor = 2;\n        List<long> factors = new List<long>();\n\n       \
    \ do {\n            if (n % factor == 0) {\n                factors.Add(factor);\n\
    \                n /= factor;\n            }\n            factor *= 2;\n     \
    \   } while (n > 1);\n\n        while (n > 1) {\n            while (n % factor\
    \ == 0) {\n                factors.Add(factor);\n                n /= factor;\n\
    \            }\n            factor *= 2;\n        }\n        highestFactor = 1;\n\
    \        for (long factor in factors) {\n            highestFactor *= factor;\n\
    \        }\n        factors.Sort();\n        return factors;", "        Debug.Assert(n\
    \ >= 2L);\n        List<long> result = new List<long>();\n        var primes =\
    \ new List<long>(new long[]{2L});\n        // find all prime numbers larger than\
    \ or equal to n\n        for (var i = 2; i <= Math.Sqrt(n); i++) {\n         \
    \   if (n % i == 0) {\n                primes.Add(i);\n            }\n       \
    \ }\n        // find all factors of n\n        while (n % primes.Count > 0) {\n\
    \            var prime = primes[primes.Count - 1];\n            if (n % prime\
    \ == 0) {\n                result.Add(prime);\n                n = n / prime;\n\
    \            } else {\n                primes.RemoveAt(primes.Count - 1);\n  \
    \          }\n        }\n        // add remaining prime factors of n\n       \
    \ while (n % primes.Count > 0) {\n            result.Add(primes[primes.Count -\
    \ 1]);\n            n = n / primes[primes.Count - 1];\n        }\n        return\
    \ result;", "        var factors = new List<long>();\n        \n        BigInteger\
    \ original = BigInteger.ValueOf(n);\n        var factorsCount = 1;\n        \n\
    \        while (original.Divide(2, BigIntegerDivide.RoundDown) == 0) {\n     \
    \       factorsCount++;\n            \n            if (factorsCount > 1000) {\n\
    \                factors.Add(original);\n                return factors;\n   \
    \         }\n            \n            factors.Add(original.Divide(2, BigIntegerDivide.RoundDown));\n\
    \            \n            original = original.Divide(2, BigIntegerDivide.RoundDown);\n\
    \        }\n        \n        factors.Add(original);\n        return factors;",
  "        bool isPrime = true;\n        List<long> factors = new List<long>();\n\
    \        long p = 2L;\n        while (p <= n) {\n            bool checkPrime =\
    \ true;\n            for (long i = 0; i < factors.Count; i++) {\n            \
    \    if (n % p == 0) checkPrime = false;\n            }\n            if (checkPrime)\
    \ {\n                factors.Add(p);\n                if (p * p > n) break;\n\
    \            }\n            p++;\n        }\n        if (isPrime && factors.Count\
    \ > 2) {\n            factors.RemoveAt(1);\n        }\n        return factors;",
  "        List<long> factors = new List<long>();\n\n        // This could be done\
    \ faster if we could get all factors simultaneously\n        // For now we go\
    \ through every number from 2 up to half of the number\n        for (long i =\
    \ 1; i <= n / 2; i++) {\n            // If we divided this number by each of its\
    \ factors\n            // we also add it to our list of factors\n            if\
    \ (n % i == 0) {\n                factors.Add(i);\n                // and remove\
    \ it from the number (because we divided it)\n                n /= i;\n      \
    \      }\n        }\n\n        // We need to remove any remainders and add the\
    \ number itself to our list if it was a factor\n        if (n > 1) { factors.Add(n);\
    \ }\n\n        return factors;", "        bool flag = false;\n        long p =\
    \ n;\n        List<long> factors = new List<long>();\n        while (p > 1) {\n\
    \            long q = p / 2;\n            if (flag) {\n                p = q;\n\
    \                factors.Add(p);\n            }\n            if (p == q) {\n \
    \               factors.Add(p);\n                p = q;\n                flag\
    \ = false;\n            } else {\n                flag = true;\n            }\n\
    \        }\n        return factors;", "        bool isPrime = true;\n        long\
    \ factor = 2L;\n        List<long> result = new List<long>(new long[]{2L});\n\
    \        while (factor < n) {\n            isPrime = true;\n            for (long\
    \ i = 3L; i <= Math.Sqrt(factor); i += 2L) {\n                if ((factor % i)\
    \ == 0)\n                    isPrime = false;\n            }\n            if (isPrime)\n\
    \                result.Add(factor);\n            factor = factor * 2L;\n    \
    \    }\n        return result;", "        if (n < 2L) {\n            return new\
    \ List<long>(new long[] { 2L });\n        }\n        List<long> factors = new\
    \ List<long>();\n        int div = 2;\n        while (n >= div) {\n          \
    \  while (n % div == 0) {\n                factors.Add(div);\n               \
    \ n /= div;\n            }\n            div++;\n        }\n        factors.Reverse();\n\
    \        return factors;", "        long factorizationCount = 0;\n        long\
    \ next = 1;\n        long i = 1;\n        long maxFactorizationCount = Math.Sqrt(n)\
    \ + 1;\n\n        while (true) {\n            factorizationCount = factorizationCount\
    \ + next;\n\n            // This should never happen since we should be checking\
    \ that next*next is less than n\n            if (factorizationCount > maxFactorizationCount)\
    \ {\n                Debug.Assert(false);\n                return null;\n    \
    \        }\n\n            next = 2;\n            i = 2;\n\n            // Only\
    \ need to factor upto sqrt(n) to find factors of length 2\n            // i.e.\
    \ no more than sqrt(n) factors\n            while (factorizationCount < maxFactorizationCount\
    \ &&\n                   n / i != factorizationCount) {\n                next\
    \ = next * i;\n                i = i + 2;\n                factorizationCount\
    \ = factorizationCount + next;\n            }\n\n            if (next == 1) {\n\
    \                Debug.Assert(i == n);\n                Debug.Assert(next*next\
    \ <= n);\n                return new List<long>();\n            }\n\n        \
    \    // Add the current factor to the list\n            List<long> factors = new\
    \ List<long>(new long[]{n, i});\n            return factors;\n        }", "  \
    \      List<long> factors = new List<long>();\n        while (n != 1L) {\n   \
    \         long m = n % 2L;\n            if (m == 0L)\n                return factors;\n\
    \            factors.Add(2L * m);\n            n /= 2L;\n        }\n        return\
    \ factors;", "        long fact = n;\n        long[] primes = new long[8];\n \
    \       fact = fact - 1;\n        // Sieve of Eratosthenes\n        long limit\
    \ = fact / 2;\n        long[] primeFactors = new long[8];\n        primeFactors[0]\
    \ = 1;\n        while (limit < Math.Sqrt(fact)) {\n            primeFactors[limit]\
    \ = 1;\n            limit = limit + limit;\n            while (limit < Math.Sqrt(fact))\
    \ {\n                fact = fact - limit;\n                limit = limit + limit;\n\
    \            }\n        }\n        primeFactors[limit - 1] = factor(fact);\n \
    \       primeFactors = Arrays.ConvertAll(primeFactors, n => n * n);\n        primeFactors\
    \ = primeFactors.Distinct().ToArray();\n        List<long> factors = new List<long>();\n\
    \        foreach (long prime in primeFactors) {\n            for (int i = 2; i\
    \ <= prime; i++) {\n                if (prime % i == 0) {\n                  \
    \  factors.Add(i);\n                    for (int j = prime - 1; j > primeFactors[i\
    \ - j - 1]; j--) {\n                        if (j % i == 0) {\n              \
    \              factors.Add(i);\n                            factors.Add(j);\n\
    \                            break;\n                        }\n             \
    \       }\n                    break;\n                }\n            }\n    \
    \    }\n        return factors;", "        // Using this instead of BigInteger\
    \ allows us to handle very large numbers (without catastrophic performance degradation)\n\
    \        long product = 1;\n        List<long> factorization = new List<long>();\n\
    \        while (product != n) {\n            long temp = product;\n          \
    \  int divisor = 1;\n            while (temp % divisor != 0) {\n             \
    \   divisor += 1;\n            }\n            temp /= divisor;\n            factorization.Add(divisor);\n\
    \            product *= divisor;\n        }\n        return factorization;", " \
    \       // Sort all factors\n        List<long> factors = FactorizeRecursive(n);\n\
    \        return factors.OrderBy(d => d).ToList();", "        long factorization[]\
    \ = new long[(int)Math.Sqrt(n) + 1];\n        for (int i = 1; i <= Math.Sqrt(n);\
    \ i++) {\n            for (int j = 0; j < i; j++) {\n                if (n % i\
    \ == 0) {\n                    factorization[i] = factorization[i] + 1;\n    \
    \                n = n / i;\n                }\n            }\n        }\n   \
    \     factorization[(int)Math.Sqrt(n)] = 1;\n        return new List<long>(factorization.OrderBy(x=>x).ToArray());",
  "        int k = Math.Sqrt(n);\n        List<long> factors = new List<long>();\n\
    \n        for (int i = 2; i <= k; i++) {\n            if (n % i == 0) {\n    \
    \            int count = 0;\n                while (n % i == 0) {\n          \
    \          n /= i;\n                    count++;\n                }\n        \
    \        factors.Add(new long[] { i, count });\n            }\n        }\n\n \
    \       if (n > 1) factors.Add(new long[] { n, 1 });\n\n        return factors;",
  "        if (n == 1)\n            return new List<long>(new long[]{1});\n      \
    \  List<long> factors = new List<long>();\n        long[] factorization = GetFactors(n);\n\
    \        foreach (long factor in factorization) {\n            factors.Add(factor);\n\
    \            factors = Factorize(factor);\n        }\n        return factors;",
  "        List<long> res = new List<long>();\n\n        long base;\n        long\
    \ maxBase = n % 2 == 1 ? 3L * n : n; // First prime candidate is 3.\n        long\
    \ maxBase3 = maxBase;\n        while (maxBase3 >= 3L) {\n            long maxBase2\
    \ = maxBase3 / 2L;\n            long maxBase1 = maxBase2 - maxBase3;\n       \
    \     long maxBase5 = maxBase1 + maxBase2;\n            maxBase3 = maxBase5;\n\
    \            long maxBase7 = maxBase3 + maxBase4;\n            long maxBase11\
    \ = maxBase7 + maxBase8;\n            maxBase7 = maxBase11;\n            maxBase11\
    \ = maxBase11;\n            maxBase8 = maxBase8;\n            maxBase2 = maxBase2;\n\
    \            maxBase1 = maxBase1;\n            maxBase = maxBase1;\n        }\n\
    \n        long maxBase2 = maxBase * 2L;\n        long maxBase5 = maxBase2 * 2L;\n\
    \        maxBase3 = maxBase5;\n        long maxBase7 = maxBase3 + maxBase4;\n\
    \        long maxBase11 = maxBase7 + maxBase8;\n        maxBase7 = maxBase11;\n\
    \        maxBase11 = maxBase11;\n        maxBase8 = maxBase8;\n        maxBase2\
    \ = maxBase2;\n        maxBase1 = maxBase1;\n        maxBase = maxBase1;\n\n \
    \       if (n == 1L)\n            return new List<long>(new long[] { 1L });\n\
    \        while (n > 1L) {\n            if (n % maxBase == 0) {\n             \
    \   res.Add(maxBase);\n                n /= maxBase;\n            }\n        \
    \    if (n % maxBase3 == 0)\n            {\n                res.Add(maxBase3);\n\
    \                n /= maxBase3;\n            }\n            if (n % maxBase2 ==\
    \ 0)\n            {\n                res.Add(maxBase2);\n                n /=\
    \ maxBase2;\n            }\n            if (n % maxBase5 == 0)\n            {\n\
    \                res.Add(maxBase5);\n                n /= maxBase5;\n        \
    \    }\n            if (n % maxBase7 == 0)\n            {\n                res.Add(maxBase7);\n\
    \                n /= maxBase7;\n            }\n            if (n % maxBase11\
    \ == 0)\n            {\n                res.Add(maxBase11);\n                n\
    \ /= maxBase11;\n            }\n            if (n % maxBase8 == 0)\n         \
    \   {\n                res.Add(maxBase8);\n                n /= maxBase8;\n  \
    \          }\n            if (n % maxBase2 == 0)\n            {\n            \
    \    res.Add(maxBase2);\n                n /= maxBase2;\n            }\n     \
    \       if (n % maxBase1 == 0)\n            {\n                res.Add(maxBase1);\n\
    \                n /= maxBase", "        var result = new List<long>();\n    \
    \    Factorize(n, result);\n        return result;", "        List<long> factors\
    \ = new List<long>(n.ToString().ToCharArray().Select(c => (long)Math.Pow(10,(int)c)-1));\n\
    \        List<long> primes = new List<long>();\n\n        for(int i = 0; i < factors.Count;\
    \ i++) {\n            for(int j = 0; j < factors.Count; j++) {\n             \
    \   if(i != j) {\n                    if(factors[i] * factors[j] == n) {\n   \
    \                     factors[i] += 1L;\n                        factors[j] -=\
    \ 1L;\n                        i = j;\n                    }\n               \
    \ }\n            }\n        }\n\n        for(int i = 0; i < factors.Count; i++)\
    \ {\n            if(factors[i] == 1) {\n                primes.Add(1L);\n    \
    \        }\n            else if(primes.Count > 0) {\n                if(factors[i]\
    \ > primes[primes.Count - 1]) {\n                    primes.Add(factors[i]);\n\
    \                }\n                else {\n                    primes[primes.Count\
    \ - 1] = factors[i];\n                }\n            }\n            else {\n \
    \               primes.Add(factors[i]);\n            }\n        }\n\n        return\
    \ primes;", "        List<long> factors = new List<long>();\n        if (n ==\
    \ 1)\n            factors.Add(1);\n        else {\n            long m = Math.Sqrt(n);\n\
    \            long g = Primes.GetNext(n);\n            while (n % g == 0) {\n \
    \               factors.Add(g);\n                n = n / g;\n                g\
    \ = Primes.GetNext(n);\n            }\n            while (n % g != 0) {\n    \
    \            factors.Add(g);\n                n = n / g;\n            }\n    \
    \    }\n        return factors;", "        long m = n;\n        List<long> factors\
    \ = new List<long>();\n        while (m != 1) {\n            m = m / 2;\n    \
    \        factors.Add(m);\n        }\n        return factors;", "        List<long>\
    \ list = new List<long>();\n\n        // Use Sieve of Atkin\n        bool isPrime\
    \ = false;\n        long prime = 2;\n        while (true) {\n            isPrime\
    \ = true;\n            for (int i = 2; i * i <= n; i++) {\n                if\
    \ (n % i == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            if (isPrime) {\n              \
    \  list.Add(prime);\n                prime++;\n                if (prime > Math.Sqrt(n))\n\
    \                    break;\n            }\n        }\n\n        return list;",
  "        var factorization = new List<long>();\n        double d = (double)n;\n\
    \        for (int i = 1; i <= (int)Math.Sqrt(d); i++) {\n            while (n\
    \ % i == 0) {\n                factorization.Add((long)i);\n                n\
    \ = n / i;\n            }\n        }\n        if (n != 1) factorization.Add((long)n);\n\
    \        return factorization;", "        long result = 1;\n        long p = 2;\n\
    \        while (n > 1) {\n            if (n % p == 0) result *= p;\n         \
    \   n /= p;\n            p++;\n        }\n        return new List<long>(new long[]\
    \ { result });", "        List<long> factors = new List<long>();\n        factors.AddRange(Factorize2(n));\n\
    \        factors.AddRange(Factorize3(n));\n        return factors;", "       \
    \ var factors = new List<long>();\n        if (n < 2) {\n            factors.Add(n);\n\
    \            return factors;\n        }\n        var root = (int)Math.Sqrt(n);\n\
    \        while (n % 2 == 0) {\n            factors.Add(2);\n            n /= 2;\n\
    \        }\n        var i = 2;\n        do {\n            while ((n % i) == 0)\
    \ {\n                factors.Add(i);\n                n /= i;\n            }\n\
    \            i += 2;\n        } while (i < root);\n        return factors;", " \
    \       long product = (long) Math.Sqrt(n);\n        List<long> factors = new\
    \ List<long>();\n        while (n % product != 0) {\n            while (n % product\
    \ != 0) {\n                product = product / 2;\n            }\n           \
    \ factors.Add(product);\n            n = product * product;\n        }\n     \
    \   factors.Add(n);\n        return factors;", "        // Step 1: get factors\
    \ of n\n        List<long> factors = new List<long>();\n        long next, curr\
    \ = n, prev;\n        while (curr != 1) {\n            next = curr / 2;\n    \
    \        while (next != 1) {\n                prev = next;\n                next\
    \ = next * prev;\n            }\n            factors.Add(prev);\n            curr\
    \ = prev;\n        }\n\n        // Step 2: convert factors to primes, starting\
    \ from smallest factor to largest\n        List<long> primes = new List<long>();\n\
    \        factors.Reverse();\n        for (int i = 0; i < factors.Count; i++) {\n\
    \            long factor = factors[i];\n            while (factor != 1) {\n  \
    \              if (primes.Contains(factor)) {\n                    break;\n  \
    \              } else {\n                    primes.Add(factor);\n           \
    \     }\n                factor = factor * factor;\n            }\n        }\n\
    \        return primes;", "        // Prime numbers <= 32 have no factors\n  \
    \      if (n < 2) return new List<long>();\n        // List of factors found\n\
    \        List<long> factors = new List<long>();\n        // Use Sieve of Eratosthenes\n\
    \        // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n        // http://blogs.msdn.com/b/ericlippert/archive/2011/02/28/gimvy-why-is-100-000-faster-than-general-prime-tests-part-three.aspx\n\
    \        List<bool> primes = new List<bool>();\n        primes.Add(true);\n  \
    \      primes.AddRange(new bool[(int)((double)n + 1) / 2]);\n        primes.Add(true);\n\
    \        for (int i = 2; i <= n; i+=2) {\n            if (primes[i]) factors.Add(i);\n\
    \            for (int j = i * i; j < n; j += i) {\n                primes[j] =\
    \ false;\n            }\n        }\n        return factors;", "        if (n <\
    \ 2) return new List<long>();\n        List<long> result = new List<long>();\n\
    \        long a = n;\n        long b = 2;\n        while (a != 0) {\n        \
    \    while (a % b == 0) {\n                result.Add(b);\n                a /=\
    \ b;\n            }\n            b <<= 1;\n        }\n        return result;",
  "        var factors = new List<long>();\n        factors.Add(2);\n\n        //\
    \ Add only factors of prime numbers larger than n.\n        factors.AddRange(factorsOfPrimes(n,\
    \ factors));\n\n        // Add the number itself if it is a factor.\n        if\
    \ (n != 1) {\n            factors.Add(n);\n        }\n\n        return factors;",
  "        if (n == 1) return new List<long>(new long[] {n});\n        var primes\
    \ = new List<long>();\n        primes.AddRange(Factorize(n, new long[]{0}));\n\
    \        if (primes.Count == 0) { return new List<long>(new long[]{n}); }\n  \
    \      primes.Sort();\n        var newPrimes = new List<long>();\n        bool\
    \ isPrime = true;\n        long divisor = 1;\n        for (int i = 0; i < primes.Count;\
    \ i++) {\n            if (primes[i] == 1) {\n                divisor = n;\n  \
    \              isPrime = false;\n            }\n            while (divisor <=\
    \ n && isPrime) {\n                if (n % divisor == 0) {\n                 \
    \   isPrime = false;\n                    break;\n                }\n        \
    \        divisor++;\n            }\n            if (isPrime)\n               \
    \ newPrimes.Add(divisor);\n        }\n        newPrimes.Sort();\n        return\
    \ newPrimes;", "        var q = new Queue<long>();\n        var r = new Queue<long>();\n\
    \        var s = new Queue<long>();\n        var t = 0;\n        while (n != 1)\
    \ {\n            while (n % 2 == 0) {\n                q.Enqueue(2);\n       \
    \         n /= 2;\n            }\n            while (n % 3 == 0) {\n         \
    \       q.Enqueue(3);\n                n /= 3;\n            }\n            while\
    \ (n % 5 == 0) {\n                q.Enqueue(5);\n                n /= 5;\n   \
    \         }\n            while (n % 7 == 0) {\n                q.Enqueue(7);\n\
    \                n /= 7;\n            }\n            while (n % 11 == 0) {\n \
    \               q.Enqueue(11);\n                n /= 11;\n            }\n    \
    \        while (n % 13 == 0) {\n                q.Enqueue(13);\n             \
    \   n /= 13;\n            }\n            while (n % 17 == 0) {\n             \
    \   q.Enqueue(17);\n                n /= 17;\n            }\n            while\
    \ (n % 19 == 0) {\n                q.Enqueue(19);\n                n /= 19;\n\
    \            }\n            if (n > 1) {\n                q.Enqueue(n);\n    \
    \        }\n            while (q.Count != 0) {\n                r = new Queue<long>();\n\
    \                while (q.Count != 0) {\n                    t = q.Dequeue();\n\
    \                    if (t.IsPrime())\n                    {\n               \
    \         r.Enqueue(t);\n                        break;\n                    }\n\
    \                    else\n                    {\n                        r.Enqueue(t);\n\
    \                    }\n                }\n                s = r.Distinct();\n\
    \                if (s.Count != 0) {\n                    n /= s.First();\n  \
    \              }\n            }\n        }\n        return q.ToList();", "   \
    \     var factorization = Factorization(n);\n        if (factorization.Count()\
    \ == 0)\n            return new List<long>();\n        factorization.Sort();\n\
    \        var result = new List<long>();\n        var factors = new long[factorization.Count()];\n\
    \        var index = 0;\n        for (int i = 1; i < factorization.Count(); i++)\
    \ {\n            var f = factorization[i];\n            if (factors[index] ==\
    \ 0) {\n                factors[index] = f;\n                index++;\n      \
    \      }\n            else\n                factors[index] += f;\n        }\n\
    \        for (int i = 0; i < factors.Length; i++) {\n            if (factors[i]\
    \ == 0)\n                result.Add(0);\n            else\n                result.Add(factors[i]);\n\
    \        }\n        return result;", "        List<long> factors = new List<long>();\n\
    \        long i = 2;\n        while (n % i != 0) {\n            factors.Add(i);\n\
    \            n = n / i;\n        }\n        while (n > 2) {\n            factors.Add(n);\n\
    \            n = n / 2;\n        }\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        long[] factorization = new long[n];\n \
    \       for (int i = 1; i < factorization.Length; i++) {\n            if (n %\
    \ i == 0) {\n                factorization[i] = i;\n                while (n %\
    \ i == 0) {\n                    factors.Add(i);\n                    n /= i;\n\
    \                }\n            }\n        }\n        return factors;", "    \
    \    // TODO: implement me\n        return new List<long>();", "        long largestFactor\
    \ = n; //(Math.Sqrt(n) + 1);\n        List<long> primeFactors = new List<long>();\n\
    \        long factor = 2;\n        while (factor < largestFactor) {\n        \
    \    while (n % factor == 0) {\n                n /= factor;\n               \
    \ primeFactors.Add(factor);\n            }\n            factor++;\n        }\n\
    \        return primeFactors;", "        long s = n;\n        long t = 0;\n  \
    \      List<long> factors = new List<long>();\n        while (s % 2 == 0) {\n\
    \            factors.Add(2);\n            s /= 2;\n        }\n        int counter\
    \ = 1;\n        while (s > 1) {\n            t = s;\n            while (t % 2\
    \ == 0) {\n                factors.Add(2);\n                t /= 2;\n        \
    \    }\n            s /= 2;\n            counter++;\n        }\n        return\
    \ factors;", "        // Calculate prime factorization\n        long factorization\
    \ = factorization(n);\n        // Find the primes\n        return primes(factorization).OrderByDescending(x\
    \ => x).ToList();", "        // Primes are represented as a collection of distinct\
    \ prime factors, \n        // sorted by whether they are larger than n (the least\
    \ positive).\n        // The smallest prime (2) is represented by 2 and all of\
    \ its prime factors, \n        // 3 is represented by 3 and all of its prime factors,\
    \ and so forth.\n        // In fact, the largest prime (10) is represented by\
    \ 10 and all of its prime factors.\n        // For instance, the prime factorization\
    \ of 10 is [2, 5] and [2, 10].\n        List<long> factors = new List<long>();\n\
    \        bool isPrime = true;\n        int i = 2;\n        while (i < n && isPrime)\
    \ {\n            isPrime = IsPrime(i);\n            factors.Add(i);\n        \
    \    i += isPrime;\n        }\n        Debug.Assert(n >= 2); // Should only be\
    \ called for non-negative integers\n        return factors;", "        if (n <\
    \ 2L) return new List<long>(new long[]{2L});\n        var f = new List<long>();\n\
    \        long a = n + 1L;\n        while (a != 1L) {\n            if (a % 2L ==\
    \ 0) return new List<long>(new long[]{2L});\n            long s = a;\n       \
    \     a = s / 2L;\n            while (s != 1L) {\n                if (s % 2L ==\
    \ 0) return new List<long>(new long[]{s});\n                s = s / 2L;\n    \
    \        }\n            f.Add(a);\n        }\n        return f;", "        List<long>\
    \ factors = new List<long>();\n        BigInteger i = BigInteger.DivideByOne(n);\n\
    \        BigInteger p = BigInteger.DivideByInt(n);\n        while (p.CompareTo(BigInteger.One)\
    \ >= 0) {\n            BigInteger temp = i;\n            BigInteger pDiv = p;\n\
    \            while (temp.CompareTo(pDiv) >= 0) {\n                if (temp.Multiply(temp).CompareTo(n)\
    \ == 0) {\n                    factors.Add(temp);\n                }\n       \
    \         temp = temp.Multiply(temp);\n            }\n            pDiv = pDiv.Add(BigInteger.One);\n\
    \            i = i.Add(BigInteger.One);\n            p = p.Add(BigInteger.One);\n\
    \        }\n        return factors;", "        List<long> factors = new List<long>();\n\
    \        long factor = 1;\n        while (n > 1) {\n            factor = 2;\n\
    \            while (n == factor * factor) {\n                factor++;\n     \
    \       }\n            factors.Add(factor);\n            n /= factor;\n      \
    \  }\n        return factors;", "        var primes = new List<long>();\n    \
    \    for (int i = 2; i <= Math.Sqrt(n); i++)\n            if (n % i == 0) {\n\
    \                while (n % i == 0)\n                    n /= i;\n           \
    \     primes.Add(i);\n            }\n        return new List<long>(primes);",
  "        List<long> factors = new List<long>();\n        if (n == 1L) return factors;\n\
    \        if (n % 2 == 0L) {\n            factors.Add(2L);\n        }\n       \
    \ long sqrtn = Math.Sqrt(n);\n        long n1 = (long)sqrtn;\n        long n2\
    \ = n - 1;\n        for (long m = 2; m <= n2; m++) {\n            if (n % m ==\
    \ 0L) {\n                factors.Add(m);\n                n = n / m;\n       \
    \         long n11 = n % m;\n                long n12 = n - n11;\n           \
    \     if (n12 == m) {\n                    factors.Add(n11);\n               \
    \ }\n            }\n        }\n        return factors;", "        long maxFactor\
    \ = 2;\n        long factor = 1;\n        long fact = n;\n        while (fact\
    \ != 1) {\n            while (fact % maxFactor == 0) {\n                fact =\
    \ fact / maxFactor;\n                factor++;\n            }\n            maxFactor\
    \ *= factor;\n        }\n        List<long> result = new List<long>(new long[]\
    \ { maxFactor });\n        while (fact != 1) {\n            if (fact % maxFactor\
    \ == 0) {\n                fact = fact / maxFactor;\n                result.Add(maxFactor);\n\
    \            }\n            maxFactor *= factor;\n        }\n        return result;",
  "        if (n == 1L) {\n            return new List<long>(new long[] { n });\n\
    \        }\n        List<long> factors = new List<long>();\n        long maxFactor\
    \ = n;\n        for (long i = 2; i <= maxFactor; i++) {\n            if (n % i\
    \ == 0) {\n                maxFactor = i + (n - i) / i;\n                factors.Add(i);\n\
    \            }\n        }\n        if (factors.Count != 1) {\n            factors.Add(n);\n\
    \        }\n        return factors;", "        var isPrime = new bool[n - 1];\n\
    \n        // Generate array of prime numbers from 1 to n\n        for (int i =\
    \ 0; i < isPrime.Length; i++) {\n            if (n % i == 0) {\n             \
    \   isPrime[i] = false;\n            }\n            else {\n                isPrime[i]\
    \ = true;\n            }\n        }\n\n        var primes = new List<long>();\n\
    \        // Generate the array of factors by using Sieve of Eratosthenes algorithm\n\
    \        for (int i = 2; i <= n; i++) {\n            if (isPrime[i]) {\n     \
    \           primes.Add(i);\n                int j = i;\n                while\
    \ (!isPrime[j]) {\n                    j += i;\n                }\n          \
    \      isPrime[j] = false;\n            }\n        }\n        return primes;",
  "        long factorization = 1;\n        long factorization2 = 2;\n        bool\
    \ isPrime;\n        List<long> factors = new List<long>();\n        while (factorization\
    \ <= n) {\n            isPrime = true;\n            factorization2 = factorization;\n\
    \            while (factorization % factorization2 != 0) {\n                isPrime\
    \ = false;\n                factorization2 += factorization2;\n            }\n\
    \            if (isPrime) {\n                factors.Add(factorization2);\n  \
    \              factorization += factorization2;\n            }\n        }\n  \
    \      return factors;", "        var factors = new List<long>();\n        var\
    \ factorization = Factorization(n);\n        foreach (var f in factorization)\
    \ {\n            for (int i = 0; i < factors.Count; ++i) {\n                if\
    \ (factors[i] == f) {\n                    factors.RemoveAt(i);\n            \
    \        break;\n                }\n            }\n            factors.Add(f);\n\
    \        }\n        return factors;", "        bool isPrime = true;\n        List<long>\
    \ result = new List<long>();\n        for (long i = 2; i <= n / 2; i++) {\n  \
    \          if (n % i == 0) {\n                isPrime = false;\n             \
    \   break;\n            }\n        }\n        if (isPrime) {\n            result.Add(n);\n\
    \            int limit = n / 2;\n            while (limit > 1) {\n           \
    \     if (n % limit == 0) {\n                    result.Add(limit);\n        \
    \            limit /= 2;\n                } else {\n                    break;\n\
    \                }\n            }\n        }\n        return result;", "     \
    \   if (n < 2L) {\n            return new List<long>();\n        }\n        var\
    \ factors = new List<long>();\n        Factorize(n, 2L, factors);\n        return\
    \ factors;", "        List<long> factorization = new List<long>();\n        long\
    \ smallestFactor = 2 L;\n        long factor = 1;\n        long smallestFactor2\
    \ = 2 L;\n        long factor2 = 1;\n        do {\n            factorization =\
    \ new List<long>();\n            if (n % factor == 0)\n            {\n       \
    \         factorization = new List<long>();\n                factorization.Add(factor);\n\
    \                factor2 = n / factor;\n            }\n            while (n %\
    \ factor == 0 && n % factor2 == 0) {\n                factor2 = n / factor2;\n\
    \                factorization.Add(factor2);\n                factor *= factor2;\n\
    \            }\n            smallestFactor2 = smallestFactor;\n            smallestFactor\
    \ = factorization[factorization.Count - 1]; \n        } while (factor != smallestFactor);\n\
    \        return factorization;", "        List<long> factors = new List<long>();\n\
    \        factors.Add(2);\n        for (long d = 2; d * d <= n; d += 2) {\n   \
    \         for (int i = 2; i <= n / d; i++) {\n                if (n % i == 0)\
    \ {\n                    long j = (long) Math.Floor(n / i);\n                \
    \    while (j % d == 0) {\n                        factors.Add(j);\n         \
    \               n /= i;\n                    }\n                }\n          \
    \  }\n        }\n        return factors;", "        List<long> factors = new List<long>();\n\
    \        long factor = 1;\n        while (n > 1) {\n            factor = 1;\n\
    \            long i = 0;\n            while (n % factor == 0) {\n            \
    \    n /= factor;\n                i++;\n            }\n            factors.Add(factor);\n\
    \            if (i != 1) factors.Add(i);\n        }\n        return factors;",
  "        List<long> factors = new List<long>();\n        long squareRoot = n.Sqrt(n);\n\
    \        while (squareRoot != 1) {\n            long r = squareRoot;\n       \
    \     long g = n - r;\n            squareRoot = g.Sqrt(g);\n            if (g\
    \ > 1) {\n                factors.Add(r);\n                factors.Add(g);\n \
    \           }\n            n = r;\n        }\n        return factors;", "    \
    \    long[] factors = new long[(int) Math.Sqrt(n)];\n        long sq = n * n;\n\
    \        long limit = BigInteger.Sqrt(sq);\n        \n        for (int i = 1;\
    \ i <= limit; i++)\n        {\n            while (sq > i * i)\n            {\n\
    \                sq -= i * i;\n            }\n\n            if (sq == i)\n   \
    \         {\n                factors[(int) i] = (long) i;\n            }\n   \
    \     }\n        \n        List<long> list = new List<long>(factors.Length);\n\
    \        for (int i = 0; i < factors.Length; i++)\n        {\n            list.Add(factors[i]);\n\
    \        }\n        return list;", "        List<long> factors = new List<long>();\n\
    \        int n = GetFactorization(n);\n        bool flag = true;\n        long\
    \ i = 2;\n        while (flag) {\n            if (n % i == 0) {\n            \
    \    factors.Add(i);\n                n /= i;\n                flag = false;\n\
    \                i++;\n            } else {\n                flag = true;\n  \
    \          }\n        }\n        return factors;", "        // Sieve of Eratosthenes\n\
    \        long[] primes = new long[(int) Math.Sqrt(n + 1)];\n        // Fill with\
    \ 2\n        primes[0] = 2;\n        // Fill with remaining odd numbers\n    \
    \    for (int i = 3; i <= Math.Sqrt(n); i += 2)\n            primes[i] = (long)\
    \ i;\n        // Cycle through primes testing if each is divisible by any larger\
    \ prime\n        for (int prime = primes.Length - 1; prime >= 1; prime--) {\n\
    \            if (primes[prime] % prime == 0) {\n                for (int test\
    \ = (prime << 1) + 1; test <= prime; test += prime) {\n                    if\
    \ (test > prime)\n                        continue;\n                    if (primes[test]\
    \ % prime == 0)\n                        primes[prime] = test;\n             \
    \   }\n            }\n        }\n        // Get factors of n that are greater\
    \ than 1 and in ascending order of frequency\n        List<long> factors = new\
    \ List<long>();\n        while (n > 1) {\n            if (n % 2 == 0)\n      \
    \          factors.Add(2);\n            while (n > 2) {\n                if (n\
    \ % prime == 0)\n                    factors.Add(prime * 2);\n               \
    \ n /= prime;\n            }\n        }\n        // Sort factors in descending\
    \ order of frequency\n        factors.Sort((a, b) => b - a);\n        return factors;",
  "        List<long> factors = new List<long>();\n        double d = (int)Math.Sqrt(n);\n\
    \        for(int x = 2; x <= (int)Math.Floor(d); x++) {\n            if(n % x\
    \ == 0) {\n                factors.Add(x);\n                n /= x;\n        \
    \    }\n        }\n        factors.Add(n);\n        return factors;", "      \
    \  long fact = 1;\n        bool isPrime = true;\n        List<long> factors =\
    \ new List<long>();\n\n        for (long i = 1; i < n; i++)\n        {\n     \
    \       if (n % i == 0)\n            {\n                isPrime = false;\n   \
    \             fact = fact * i;\n            }\n        }\n\n        if (isPrime)\n\
    \        {\n            factors.Add(fact);\n        }\n\n        factors = FactorizePrimes(factors);\n\
    \n        return factors;", "        bool check = true;\n        long n = n;\n\
    \        int count = 1;\n        List<long> result = new List<long>();\n     \
    \   for (int i = 1; i < Math.Sqrt(n); i++) {\n            while (n % i == 0) {\n\
    \                if (check) {\n                    count++;\n                }\n\
    \                else {\n                    break;\n                }\n     \
    \       }\n            if (count == 2) {\n                result.Add(i);\n   \
    \             n = n / i;\n                count = 0;\n            }\n        \
    \    else if (count == 1) {\n                result.Add(i);\n                n\
    \ = n / i;\n                count = 0;\n            }\n        }\n        return\
    \ result;", "        BigInteger bi = new BigInteger(n.ToString());\n        List<long>\
    \ result = new List<long>();\n        List<long> factors = BigInteger.Factorize(bi);\n\
    \        foreach (var item in factors) {\n            int count = 1;\n       \
    \     BigInteger temp = item;\n            while (temp.ToString().Contains(\"\
    0\")) {\n                count++;\n                temp = temp.Divide(BigInteger.Pow(2,\
    \ count));\n            }\n            result.Add(temp);\n        }\n        return\
    \ result;", "        List<long> factors = new List<long>();\n        long factor\
    \ = 2;\n        while (factor <= n) {\n            if (n % factor == 0) {\n  \
    \              factors.Add(factor);\n                while (factor <= n / factor)\
    \ {\n                    factor *= factor;\n                    if (n % factor\
    \ == 0) {\n                        factors.Add(factor);\n                    \
    \    factor++;\n                    }\n                }\n                n =\
    \ n / factor;\n            }\n            factor++;\n        }\n        return\
    \ factors;", "        List<long> result = new List<long>();\n        long maxFactor\
    \ = n; // initial candidate\n        while (maxFactor >= 2) {\n            //\
    \ If divisor is 2, skip\n            if (maxFactor % 2 == 0) {\n             \
    \   maxFactor = maxFactor / 2;\n                result.Add(maxFactor);\n     \
    \           continue;\n            }\n            \n            // Try all odd\
    \ divisors from 2 to sqrt(maxFactor)\n            long next = 2;\n           \
    \ int prime = 1;\n            long factor = maxFactor;\n            while (next\
    \ <= maxFactor) {\n                prime++;\n                long temp = (long)Math.Sqrt(maxFactor);\n\
    \                if (temp % next == 0) {\n                    factor = maxFactor;\n\
    \                    break;\n                }\n                next++;\n    \
    \        }\n            \n            // Check if current divisor is prime\n \
    \           while (factor * factor < maxFactor) {\n                long temp =\
    \ maxFactor;\n                while (temp % factor != 0) {\n                 \
    \   temp--;\n                }\n                if (temp >= 2) {\n           \
    \         result.Add(factor);\n                    factor++;\n               \
    \ }\n                maxFactor = temp;\n            }\n        }\n        return\
    \ result;", "        if (n % 2 == 0) {\n            Factorize(n * 2);\n      \
    \  } else {\n            long m = n / 2;\n            long[] factors = Factorize(m);\n\
    \            for (int i = 0; i < factors.Length; i++) {\n                if (m\
    \ % factors[i] == 0) {\n                    factors[i] = factors[i] + 1;\n   \
    \                 break;\n                }\n            }\n            factors[factors.Length\
    \ - 1] = n;\n            return factors;\n        }\n        return new List<long>();",
  "        List<long> list = new List<long>();\n        if (n == 1) {\n          \
    \  return list;\n        }\n        list.Add(1);\n        for (int i = 2; i <=\
    \ n; i++) {\n            while (n % i == 0) {\n                list.Add(i);\n\
    \                n /= i;\n            }\n        }\n        if (n != 1) {\n  \
    \          list.Add(n);\n        }\n        return list;", "        bool isPrime\
    \ = true;\n        long numFactor = 1;\n        List<long> factors = new List<long>();\n\
    \        for (long factor = 2; factor <= Math.Sqrt(n); factor++) {\n         \
    \   if (n % factor == 0) {\n                factors.Add(factor);\n           \
    \     n /= factor;\n            } else {\n                isPrime = false;\n \
    \               break;\n            }\n        }\n        if (isPrime) {\n   \
    \         factors.Add(n);\n        }\n        return factors;", "        // Prime\
    \ factorization of number must not contain number itself (otherwise it's trivial\
    \ factorization)\n        List<long> factors = new List<long>();\n        BigInteger\
    \ number = new BigInteger(n);\n        BigInteger number = new BigInteger(n);\n\
    \        BigInteger one = new BigInteger(1);\n        // Iterate over all prime\
    \ factors of number until it cannot be divided by all remaining factors\n    \
    \    while (number.Divide(one) != one) {\n            // Add this prime factor\
    \ to list of factors\n            factors.Add(number.Divide(one));\n         \
    \   number = number.Divide(one);\n        }\n        // Return list of factors\n\
    \        return factors;", "        // Find prime factorization of given number\n\
    \        int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53 };\n        int[] factors = { 1, 1, 1, 3 };\n        long factorization\
    \ = n;\n        List<long> factorizations = new List<long>();\n        BigInteger\
    \ bigFactor = new BigInteger(factorization);\n        for (int i = 0; i < factors.Length;\
    \ i++) {\n            BigInteger bigFactorMinusRemainder = new BigInteger(factorization).Subtract(BigInteger.Divide(bigFactor,\
    \ primes[i]));\n            if (bigFactorMinusRemainder < 1) {\n             \
    \   factors.RemoveAt(i);\n                factorizations.Add(BigInteger.Divide(bigFactor,\
    \ primes[i]));\n            }\n        }\n        factorizations.Add(BigInteger.Divide(bigFactor,\
    \ primes[factors.Length]));\n        return factorizations;", "        List<long>\
    \ factors = new List<long>();\n        Factorise(factors, n, new long[0]);\n \
    \       return factors;", "        // Initialize factorization result list\n \
    \       List<long> result = new List<long>();\n        // Initialize list of factors\n\
    \        long[] factors = new long[(int)Math.Ceiling(Math.Log(n, 2)) + 1];\n \
    \       // Enumerate all prime factors\n        double factor = 1;\n        for\
    \ (int i = 2; i <= Math.Sqrt(n); i++) {\n            // If current factor is less\
    \ than or equal to square root of current number\n            // then only current\
    \ number is prime factor\n            if (factor <= Math.Sqrt(n)) {\n        \
    \        // If current factor is equal to square root of current number\n    \
    \            // then current number is a prime number\n                if (Math.Sqrt(n)\
    \ % i == 0) {\n                    // Add to factorization list\n            \
    \        factors[(int)factor]++;\n                }\n            }\n         \
    \   // Update current factor\n            factor++;\n        }\n        // Add\
    \ number as factor to factorization list\n        factors[(int)factor]++;\n  \
    \      // Iterate through factorization list and add to result list\n        for\
    \ (int i = 0; i < factors.Length; i++) {\n            result.Add((long)factors[i]);\n\
    \        }\n        return result;", "        // Factor number\n        long factor\
    \ = n;\n        // Factor number by 2\n        while (factor > 1) {\n        \
    \    factor /= 2;\n        }\n        // Calculate prime factorization of number\n\
    \        long[] factorization = Factorization(factor);\n        // Remove factors\
    \ from factorization until they become equal to the number itself\n        List<long>\
    \ result = new List<long>();\n        while (factorization.Contains(factor)) {\n\
    \            factorization.Remove(factor);\n            result.Add(factor);\n\
    \            factor = n / factor;\n        }\n        return result;", "     \
    \   Debug.Assert(n != 0);\n        List<long> res = new List<long>();\n      \
    \  long sqrt = Math.Sqrt(n);\n        while (n > 0) {\n            long factor\
    \ = ((n - 1) % sqrt + 1) / sqrt;\n            long p = Math.Floor(factor);\n \
    \           if (p != factor)\n                res.Add(p);\n            n = (n\
    \ - p * sqrt) / sqrt;\n        }\n        return res;", "        var factors =\
    \ new List<long>();\n        long factor = 0;\n        for (long i = 1; i <= n;\
    \ i++) {\n            while (n % i == 0) {\n                factor++;\n      \
    \          n /= i;\n            }\n            factors.Add(factor);\n        }\n\
    \        return factors;", "        List<long> factors = new List<long>();\n \
    \       long max = 2;\n        long m = 2;\n        while (n % m != 0) {\n   \
    \         if (n % m == 0) {\n                factors.Add(m);\n               \
    \ n /= m;\n            } else {\n                factors.Add(m);\n           \
    \     m = m * 2;\n            }\n        }\n        if (n != 1) {\n          \
    \  factors.Add(n);\n        }\n        return factors;", "        // If n is even,\
    \ no need to factorize\n        if (n & 1L == 0) {\n            return new List<long>(new\
    \ long[] { (long)n });\n        }\n\n        // Find prime factors up to sqrt(n)\n\
    \        List<long> factors = new List<long>();\n        while (n > 0) {\n   \
    \         long p = 2;\n            long q = 1;\n            long r = n;\n\n  \
    \          while (r > 0) {\n                long r = r >> 1;\n               \
    \ if ((n & r) == 0L) {\n                    q *= p;\n                    n /=\
    \ r;\n                }\n                p++;\n            }\n            factors.Add(q);\n\
    \        }\n        return factors;", "        List<long> f = new List<long>();\n\
    \        List<long> p = new List<long>();\n        p.Add(1);\n        long sq\
    \ = n;\n        long factor = 1;\n        bool check = false;\n        while (sq\
    \ != 1) {\n            if (sq % factor == 0) {\n                sq /= factor;\n\
    \                p.Add(factor);\n                if (factor == 2) {\n        \
    \            check = true;\n                    f.Add(2);\n                }\n\
    \            } else {\n                sq /= 2;\n            }\n            factor++;\n\
    \        }\n        if (check) {\n            f.Add(sq);\n        }\n        foreach\
    \ (long a in p) {\n            p.Remove(a);\n            f.Add(a);\n        }\n\
    \        return f;", "        var factors = new List<long>();\n        var divisors\
    \ = Divisors(n);\n        foreach (var d in divisors) {\n            if (n % d\
    \ == 0) {\n                factors.Add(d);\n                n /= d;\n        \
    \    }\n        }\n        factors.Add(n);\n        return factors;", "      \
    \  Debug.Assert(n > 1);\n        Debug.Assert(n % 2 == 0);\n\n        // Factor\
    \ by squaring n\n        long square = n * n;\n        Debug.Assert(square % 2\
    \ == 0);\n        Debug.Assert(square % 3 != 0);\n        Debug.Assert(square\
    \ % 5 == 0);\n        Debug.Assert(square % 7 == 0);\n\n        // Factor by dividing\
    \ by 3 5 7 -> 2 5 2\n        long count = 3;\n        long last = 2; \n      \
    \  long squareSqrt = square * square;\n        long lastHalf = squareSqrt - square;\n\
    \        long half = lastHalf / 2;\n\n        // factor by dividing by 5\n   \
    \     while (half != lastHalf) {\n            if (square % last % 2 == 0) {\n\
    \                count++;\n            }\n\n            last += 2;\n         \
    \   lastHalf = squareSqrt - square;\n            half = lastHalf / 2;\n      \
    \  }\n\n        // factor by dividing by 7\n        while (half != lastHalf) {\n\
    \            if (square % last % 5 == 0) {\n                count++;\n       \
    \     }\n\n            last += 5;\n            lastHalf = squareSqrt - square;\n\
    \            half = lastHalf / 2;\n        }\n\n        return new List<long>()\
    \ { count, last };", "        bool isPrime = true;\n        long lastDivisor =\
    \ n;\n        List<long> factors = new List<long>();\n        while (isPrime)\
    \ {\n            isPrime = false;\n            long nextDivisor = 1;\n       \
    \     for (long divisor = lastDivisor; divisor != 1; divisor = nextDivisor) {\n\
    \                if (n % divisor == 0) {\n                    nextDivisor = divisor\
    \ * 2;\n                    isPrime = true;\n                    break;\n    \
    \            }\n            }\n            if (isPrime)\n                factors.Add(lastDivisor);\n\
    \            lastDivisor = nextDivisor;\n        }\n        return factors;",
  "        List<long> factors = new List<long>();\n\n        while (n > 1) {\n   \
    \         long m = n % 10;\n            while (m != 0) {\n                if (m\
    \ % 2 == 0) break;\n                m /= 2;\n            }\n            if (m\
    \ == 1) factors.Add(m);\n            n /= 10;\n        }\n\n        return factors;",
  "        int i = 0;\n        List<long> factors = new List<long>();\n        long\
    \ sq = n;\n        bool isPrime = true;\n        while (sq > 1) {\n          \
    \  while (sq % 2 == 0) {\n                factors.Add(2);\n                sq\
    \ /= 2;\n            }\n            while (sq % 3 == 0) {\n                factors.Add(3);\n\
    \                sq /= 3;\n            }\n            while (sq % 5 == 0) {\n\
    \                factors.Add(5);\n                sq /= 5;\n            }\n  \
    \          while (sq % 7 == 0) {\n                factors.Add(7);\n          \
    \      sq /= 7;\n            }\n            while (sq % 11 == 0) {\n         \
    \       factors.Add(11);\n                sq /= 11;\n            }\n         \
    \   while (sq % 13 == 0) {\n                factors.Add(13);\n               \
    \ sq /= 13;\n            }\n            while (sq % 17 == 0) {\n             \
    \   factors.Add(17);\n                sq /= 17;\n            }\n            while\
    \ (sq % 19 == 0) {\n                factors.Add(19);\n                sq /= 19;\n\
    \            }\n            while (sq % 23 == 0) {\n                factors.Add(23);\n\
    \                sq /= 23;\n            }\n            while (sq % 29 == 0) {\n\
    \                factors.Add(29);\n                sq /= 29;\n            }\n\
    \            while (sq % 37 == 0) {\n                factors.Add(37);\n      \
    \          sq /= 37;\n            }\n            while (sq % 53 == 0) {\n    \
    \            factors.Add(53);\n                sq /= 53;\n            }\n    \
    \        while (sq % 59 == 0) {\n                factors.Add(59);\n          \
    \      sq /= 59;\n            }\n            while (sq % 67 == 0) {\n        \
    \        factors.Add(67);\n                sq /= 67;\n            }\n        \
    \    while (sq % 71 == 0) {\n                factors.Add(71);\n              \
    \  sq /= 71;\n            }\n            while (sq % 79 == 0) {\n            \
    \    factors.Add(79);\n                sq /= 79;\n            }\n            while\
    \ (sq % 89 == 0) {\n                factors.Add(89);\n                sq /= 89;\n\
    \            }\n            while (sq % 97 == 0) {\n                factors.Add(97);\n\
    \                sq /= 97;\n            }\n            while (sq % 105 == 0) {\n\
    \                factors.Add(105);\n                sq /= 105;\n            }\n\
    \            while (sq % 111 == 0) {\n                factors.Add(111);\n    \
    \            sq /= 111;\n            }\n            while (sq % 121 == 0) {\n\
    \                factors.Add(121);\n                sq /= 121;\n            }\n\
    \            while (sq % 131 == 0) {\n                ", "        // Compute factorization\
    \ for n.\n        var factorization = Enumerable.Range(1, int.MaxValue).Where(x\
    \ => n%x == 0).ToList();\n\n        // Compute prime factors.\n        var primeFactors\
    \ = factorization.Select(x => 2).Where(x => factorization.Contains(x)).ToList();\n\
    \n        // Filter out repeated factors.\n        factorization.RemoveAll(x =>\
    \ factorization.Contains(x));\n\n        // Sort factors.\n        factorization.Sort();\n\
    \n        // Return list of prime factors.\n        return primeFactors;", " \
    \       long product = n;\n        List<long> factors = new List<long>();\n  \
    \      while (true) {\n            long fact = GetFact(product);\n           \
    \ if (fact == 1) {\n                factors.Add(1);\n                break;\n\
    \            }\n            if (product % fact == 0) {\n                product\
    \ /= fact;\n                factors.Add(fact);\n            } else {\n       \
    \         break;\n            }\n        }\n        return factors;", "      \
    \  if (n < 2)\n            return new List<long>(new long[]{1L});\n        long\
    \ factor = 2;\n        List<long> factors = new List<long>();\n        while (true)\
    \ {\n            if (n / factor >= 2)\n                factors.Add(factor);\n\
    \            else\n                break;\n            factor = factor * 2;\n\
    \        }\n        if (factors.Count == 0)\n            factors.Add(1);\n   \
    \     return factors;", "        Debug.Assert(n > 0);\n        long factorization[]\
    \ = new long[n + 1];\n        factorization[0] = 1L;\n        long i = 2L;\n \
    \       while (i <= n) {\n            for (; i <= n / i; i++) {\n            \
    \    factorization[i] = factorization[i - 1] * i;\n            }\n           \
    \ i = i + 2;\n        }\n        return factorization.Take(factorization.Length\
    \ - 1).ToList();", "        int factor = 0;\n        List<long> result = new List<long>();\n\
    \        bool isPrime = true;\n        long prime = 3L;\n        while (factor\
    \ < Math.Sqrt(n)) {\n            while (n % prime == 0) {\n                if\
    \ (prime != n) {\n                    isPrime = false;\n                    break;\n\
    \                }\n                prime++;\n            }\n            if (isPrime)\
    \ {\n                result.Add(prime);\n                n /= prime;\n       \
    \     }\n            factor++;\n        }\n        return result;", "        List<long>\
    \ factorization = new List<long>();\n        double divisor = Double.PositiveInfinity;\n\
    \        while (n % 2 == 0) {\n            divisor = 2;\n            factorization.Add(2);\n\
    \            while (n % divisor == 0) {\n                factorization.Add(divisor);\n\
    \                n /= divisor;\n            }\n            if (n != 1) { divisor\
    \ = 2; factorization.Add(2); }\n        }\n\n        if (n > 1) { divisor = 3;\
    \ factorization.Add(3); }\n        while (n % 3 == 0) {\n            factorization.Add(3);\n\
    \            n /= 3;\n        }\n\n        if (n > 1) { divisor = 4; factorization.Add(4);\
    \ }\n        while (n % 4 == 0) {\n            factorization.Add(4);\n       \
    \     n /= 4;\n        }\n\n        if (n > 1) { divisor = 5; factorization.Add(5);\
    \ }\n        while (n % 5 == 0) {\n            factorization.Add(5);\n       \
    \     n /= 5;\n        }\n\n        if (n > 1) { divisor = 6; factorization.Add(6);\
    \ }\n        while (n % 6 == 0) {\n            factorization.Add(6);\n       \
    \     n /= 6;\n        }\n\n        if (n > 1) { divisor = 7; factorization.Add(7);\
    \ }\n        while (n % 7 == 0) {\n            factorization.Add(7);\n       \
    \     n /= 7;\n        }\n\n        if (n > 1) { divisor = 8; factorization.Add(8);\
    \ }\n        while (n % 8 == 0) {\n            factorization.Add(8);\n       \
    \     n /= 8;\n        }\n\n        if (n > 1) { divisor = 9; factorization.Add(9);\
    \ }\n        while (n % 9 == 0) {\n            factorization.Add(9);\n       \
    \     n /= 9;\n        }\n\n        if (n > 1) { divisor = 10; factorization.Add(10);\
    \ }\n        while (n % 10 == 0) {\n            factorization.Add(10);\n     \
    \       n /= 10;\n        }\n\n        if (n > 1) { divisor = 11; factorization.Add(11);\
    \ }\n        while (n % 11 == 0) {\n            factorization.Add(11);\n     \
    \       n /= 11;\n        }\n\n        if (n > 1) { divisor = 12; factorization.Add(12);\
    \ }\n        while (n % 12 == 0) {\n            factorization.Add(12);\n     \
    \       n /= 12;\n        }\n\n        if (n > 1) { divisor = 13; factorization.Add(13);\
    \ }\n        while (n % 13 == 0) {\n            factorization.Add(13);\n     \
    \       n /= 13;\n        }\n\n        if (n > 1) { divisor = 14; factorization.Add(14);\
    \ }\n        while (n % 14 == 0) {\n            factorization.Add(14);\n     \
    \       n /= 14;\n        }\n\n        if (n > 1) { divisor = 15; factorization.Add(15);\
    \ }\n        while (n % 15 == 0) {\n            factorization.Add(15);\n     \
    \       n /= 15;\n        }\n\n        if (n > 1) { divisor = 16; factorization.Add(16);\
    \ }\n        while (n % 16 == 0) {\n            factorization.Add(16);\n     \
    \       n /= 16;\n        }\n\n        if (", "        List<long> result = new\
    \ List<long>();\n        long number = n;\n        long factor = 1;\n        while\
    \ (number > 1) {\n            while (number % factor == 0) {\n               \
    \ result.Add(factor);\n                number /= factor;\n            }\n    \
    \        factor++;\n        }\n        if (number > 1) {\n            result.Add(number);\n\
    \        }\n        return result;", "        if (n == 1 || n == 2) {\n      \
    \      return new List<long>(new long[]{1L});\n        }\n\n        HashSet<long>\
    \ p = new HashSet<long>();\n        p.Add(2);\n        long x = n;\n\n       \
    \ for (int i = 3; i * i <= n; i = i + 2) {\n            while (n % i == 0) {\n\
    \                if (p.Contains(i)) {\n                    p.Add(i);\n       \
    \             x = x / i;\n                    p.Remove(i);\n                }\n\
    \            }\n        }\n        return new List<long>(p);", "        List<long>\
    \ factors = new List<long>();\n        factors.Add(1);\n        long factor =\
    \ n;\n        while(true) {\n            while(factor % 2 == 0) {\n          \
    \      factors.Add(2);\n                factor /= 2;\n            }\n        \
    \    while(factor % 3 == 0) {\n                factors.Add(3);\n             \
    \   factor /= 3;\n            }\n            while(factor % 5 == 0) {\n      \
    \          factors.Add(5);\n                factor /= 5;\n            }\n    \
    \        while(factor % 7 == 0) {\n                factors.Add(7);\n         \
    \       factor /= 7;\n            }\n            if(factor == 1)\n           \
    \     break;\n        }\n        return factors;", "        bool foundPrime =\
    \ true;\n        long factor = 2;\n\n        List<long> factors = new List<long>();\n\
    \        while (foundPrime) {\n            foundPrime = false;\n            while\
    \ (n % factor == 0) {\n                if (factor > 2) {\n                   \
    \ factors.Add(factor);\n                }\n                n = n / factor;\n \
    \               foundPrime = true;\n                factor = 2;\n            }\n\
    \            if (factor == 2) {\n                factors.Add(factor);\n      \
    \      }\n            factor++;\n        }\n\n        return factors;", "    \
    \    // Create array to hold factors (factors repeated multiple times count as\
    \ multiple factors)\n        List<long> factors = new List<long>();\n        //\
    \ If number n is 1, return 1 factor\n        if (n == 1) {\n            factors.Add(1);\n\
    \            return factors;\n        }\n        // Find prime factors of n\n\
    \        List<long> primeFactors = BigInteger.Sieve.PrimeFactors(n);\n       \
    \ // Go through every prime factor and multiply it by every power of that factor\n\
    \        foreach (long p in primeFactors) {\n            // If this factor hasn't\
    \ been seen yet, add it as the first factor\n            if (factors.IndexOf(p)\
    \ == -1) {\n                factors.Add(p);\n            }\n            // If\
    \ this factor has been seen before, add it to the list of factors repeated as\
    \ many times as its been seen before\n            else if (factors.Count(p / p)\
    \ == factors.IndexOf(p)) {\n                factors[factors.IndexOf(p)] += p;\n\
    \            }\n        }\n        // Return factors\n        return factors;",
  "        int[] factors = new int[n - 1];\n        int i = 2;\n        while (i <\
    \ n) {\n            while (n % i == 0) {\n                factors[i++] = i;\n\
    \                n /= i;\n            }\n            i++;\n        }\n       \
    \ if (n > 1) {\n            factors[n - 1] = n;\n        }\n        return new\
    \ List<long>(factors);", "        // Store factorization for number n, to avoid\
    \ redoing it every time.\n        List<long> factorization = new List<long>();\n\
    \        factorization.Add(n);\n        // Find prime factors.\n        long product\
    \ = n;\n        factorization.RemoveAll(p => p <= product);\n        while (factorization.Any())\
    \ {\n            factorization.RemoveAll(p => p == 1);\n            long factor\
    \ = 1;\n            foreach (long p in factorization) {\n                if (product\
    \ % p == 0) {\n                    factor *= p;\n                    product /=\
    \ p;\n                }\n            }\n            factorization.Add(factor);\n\
    \        }\n        return factorization;", "        List<long> factors = new\
    \ List<long>();\n        // Initialize list of prime numbers. To increase speed\
    \ of algorithm,\n        // we should store prime numbers in some data structure\
    \ (instead of searching them over and over again).\n        List<long> primes\
    \ = new List<long>() { 2, 3 };\n        // Compute factorization of given number\
    \ in loop\n        for (long current = 2; current <= Math.Sqrt(n); current++)\
    \ {\n            bool isPrime = true;\n            // Compute prime factorization\
    \ of current number\n            int num = 0;\n            for (int i = 0; i <\
    \ primes.Count; i++) {\n                if (current % primes[i] == 0) {\n    \
    \                isPrime = false;\n                    break;\n              \
    \  }\n            }\n            // If number is prime, add it to the list of\
    \ factors\n            if (isPrime) {\n                factors.Add(current);\n\
    \            }\n            // If current number is smaller than the smallest\
    \ possible factor,\n            // remove smallest factor (if any) to keep list\
    \ size as small as possible.\n            if (current < factors.Min()) {\n   \
    \             factors.Remove(factors.Min());\n            }\n            // If\
    \ current number is greater than the largest possible factor,\n            //\
    \ remove largest factor (if any) to keep list size as small as possible.\n   \
    \         if (current > factors.Max()) {\n                factors.Remove(factors.Max());\n\
    \            }\n        }\n        return factors;", "        int bitCount = 0;\n\
    \        long max = (long)Math.Sqrt(n) + 1;\n        List<long> factors = new\
    \ List<long>();\n        for (long i = 2; i <= max; i++) {\n            while\
    \ (n % i == 0) {\n                factors.Add(i);\n                n /= i;\n \
    \               bitCount++;\n            }\n        }\n        if (bitCount ==\
    \ 0) factors.Add(1L);\n        return factors;", "        if (n < 2)\n       \
    \     return new List<long>(new long[]{(long)2L});\n        long m = n;\n    \
    \    List<long> primes = new List<long>();\n        List<long> factors = new List<long>();\n\
    \        while (m) {\n            long f = 2;\n            while ((f <= m) &&\
    \ ((n % f) == 0))\n                f *= 2;\n            if (f > m) break;\n  \
    \          factors.Add(f);\n            n /= f;\n        }\n        primes.AddRange(factors);\n\
    \        return primes;", "        long factors[] = Factorize(n);\n        List<long>\
    \ factorsL = new List<long>(factors);\n        factorsL.Sort();\n        return\
    \ factorsL;", "        List<long> factors = new List<long>();\n        long i\
    \ = 1;\n        long limit = n;\n        while (i <= limit) {\n            long\
    \ temp = i;\n            i = i * 2;\n            if (temp <= limit) {\n      \
    \          while (i <= limit) {\n                    if (n % i == 0) {\n     \
    \                   factors.Add(i);\n                        break;\n        \
    \            }\n                    i += 2;\n                }\n            }\n\
    \        }\n        return factors;", "        Debug.Assert(n % 2 == 0, \"Input\
    \ number should be even\");\n\n        long limit = (long)Math.Sqrt(n);\n    \
    \    long[] primes = new long[limit];\n        long[] factors = new long[limit\
    \ + 1];\n\n        // Sieve of Erastosthenes: finding first prime > sqrt(n)\n\
    \        int limit2 = (int)limit;\n        for (int i = 3; i <= limit2; i += 2)\
    \ {\n            long f = i;\n            while (f < limit) {\n              \
    \  if (n % f == 0) {\n                    f++;\n                    break;\n \
    \               }\n                else {\n                    f++;\n        \
    \        }\n            }\n            if (f > limit) {\n                break;\n\
    \            }\n            primes[(int)f] = 1;\n        }\n\n        // Prime\
    \ numbers, if possible\n        for (int i = 3; i <= limit; i += 2) {\n      \
    \      if (primes[i] == 0) {\n                for (int j = i + i; j <= limit;\
    \ j += i) {\n                    primes[j] = 1;\n                }\n         \
    \   }\n        }\n\n        // Calculate factors\n        for (int i = 3; i <=\
    \ limit; i++) {\n            if (primes[i] == 0) {\n                factors[(int)i]\
    \ = 1;\n                for (int j = i + i; j <= limit; j += i) {\n          \
    \          factors[(int)j] = i * factors[(int)i];\n                }\n       \
    \     }\n        }\n\n        return new List<long>(factors);", "        var factors\
    \ = new List<long>();\n        factors.Add(n);\n        long current = n;\n  \
    \      while (current != 1) {\n            current = current / 2;\n          \
    \  if (current != 1)\n                factors.Add(current);\n        }\n     \
    \   while (factors.Count != 2) {\n            factors.Remove(factors.Last());\n\
    \        }\n        while (factors.Count > 2) {\n            var product = factors.Aggregate(1,\
    \ (a, b) => a * b); // (a * b) is equivalent of (a * b) + a\n            for (int\
    \ i = 0; i < factors.Count; i++) {\n                factors.Remove(product);\n\
    \            }\n        }\n        return factors;", "        if (n <= 1) return\
    \ new List<long>(new long[]{n});\n        long[] primes = new long[(int) Math.Floor((double)\
    \ Math.Sqrt(n) + 0.5D)];\n        primes[0] = n;\n        for (int i = 1; i <\
    \ primes.Length; i++) {\n            for (int j = i; j < primes.Length; j++)\n\
    \                if (primes[j] * primes[i] == n)\n                    break;\n\
    \            if (j == primes.Length)\n                primes[i] = (int)Math.Floor((double)\
    \ Math.Sqrt(n) + 0.5D);\n            else j++;\n        }\n        return new\
    \ List<long>(primes.Where((prime) => prime > 1).OrderByDescending(prime => prime).ToArray());",
  "        List<long> factors = new List<long>();\n        long factorsCount = 1;\n\
    \        long lastFactor = n;\n        long previousFactor = 1;\n        while\
    \ (lastFactor != 1) {\n            bool isPrime = true;\n            long nextFactor\
    \ = lastFactor;\n            while (true) {\n                if (n % nextFactor\
    \ == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n                nextFactor++;\n            }\n           \
    \ if (isPrime) {\n                factorsCount *= previousFactor;\n          \
    \      factors.Add(previousFactor);\n                lastFactor = nextFactor;\n\
    \            }\n            else {\n                previousFactor++;\n      \
    \      }\n        }\n        if (factors.Count != 1) {\n            factors.Add(factorsCount);\n\
    \        }\n        factors.Reverse();\n        return factors;", "        List<long>\
    \ primes = new List<long>();\n        List<long> factors = new List<long>();\n\
    \        primes.Add(1);\n        while (n > 1) {\n            long product = n\
    \ * primes[0];\n            primes.RemoveAt(0);\n            while (product %\
    \ primes[0] == 0) {\n                product /= primes[0];\n                factors.Add(primes[0]);\n\
    \                primes.RemoveAt(0);\n            }\n            primes.Add(product);\n\
    \            n = product;\n        }\n        return factors;", "        List<long>\
    \ result = new List<long>();\n        while (n % 2 == 0) {\n            result.Add(2);\n\
    \            n /= 2;\n        }\n        int k = Math.Floor(Math.Log(n, 2)) +\
    \ 1;\n        while (k >= 2) {\n            if (n % k == 0) {\n              \
    \  result.Add(k);\n                n /= k;\n            }\n            k--;\n\
    \        }\n        return result;", "        DivideAndConquer(n, 2);\n      \
    \  return new List<long>(factorizations);", "        List<long> factors = new\
    \ List<long>();\n        while (n > 0) {\n            long factor = 1;\n     \
    \       while (n % factor == 0) {\n                factor *= factor;\n       \
    \         factor++;\n            }\n            factors.Add(factor);\n       \
    \     n /= factor;\n        }\n        return factors;", "        var factorization\
    \ = new List<long>();\n        bool isPrime = true;\n        long factor = 2;\n\
    \        while (factor <= n) {\n            if (n % factor == 0) {\n         \
    \       isPrime = false;\n                break;\n            }\n            factorization.Add(factor);\n\
    \            factor++;\n        }\n        if (isPrime)\n            factorization.Add(n);\n\
    \        return factorization;", "        List<long> factors = new List<long>();\n\
    \        List<long> primes = new List<long>();\n        // Find all prime numbers\
    \ <= given number\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n    \
    \        if (n % i == 0) {\n                primes.Add(i);\n                while\
    \ (n % i == 0) {\n                    n = n / i;\n                    factors.Add(i);\n\
    \                }\n            }\n        }\n        if (n > 1) {\n         \
    \   primes.Add(n);\n            while (n > 1) {\n                n = n / 2;\n\
    \                factors.Add(n);\n            }\n        }\n        return factors;",
  "        List<long> factors = new List<long>();\n        long x = n;\n        long\
    \ factor = x;\n        while (factor != 1) {\n            factor *= x;\n     \
    \       x = 1 / x;\n            if (x != 1) {\n                factor++;\n   \
    \             x = x / factor;\n            }\n        }\n        factors.Add(factor);\n\
    \        return factors;", "        Debug.Assert(n > 0);\n        List<long> result\
    \ = new List<long>();\n        for (long i = 1; i <= n; i++)\n        {\n    \
    \        if (n % i == 0)\n            {\n                result.Add(i);\n    \
    \            n /= i;\n            }\n        }\n        return result;", "   \
    \     List<long> factors = new List<long>();\n        factors.Add(2);\n      \
    \  factors.Add(1);\n        \n        int sqrt_n = Math.Sqrt(n);\n        \n \
    \       while (n > 2) {\n            if (n % 2 == 0) {\n                factors.Add(2);\n\
    \            }\n            else {\n                for (int i = 3; i <= sqrt_n;\
    \ i = i * 2 + 1) {\n                    if (n % i == 0) {\n                  \
    \      factors.Add(i);\n                        n = n / i;\n                 \
    \       break;\n                    }\n                }\n            }\n    \
    \    }\n        \n        return factors;", "        if (n == 1)\n           \
    \ return new List<long>(new long[]{1L});\n        List<long> factors = new List<long>();\n\
    \        factors.AddRange(FactorizeFloor(n));\n        factors.AddRange(FactorizeCeiling(n));\n\
    \        return factors;", "        // Compute and store factors of n\n      \
    \  List<long> factors = new List<long>(new long[(int) Math.Floor(Math.Sqrt(n)\
    \ + 1)]);\n        long curr = n;\n        int i = 1; // Index in factors list\n\
    \        while (curr != 1) {\n            long p = curr / 2;\n            factors[i++]\
    \ = p;\n            if (p != 1 && n % (long) p != 0) {\n                factors[++i]\
    \ = 1;\n            }\n            curr = p;\n        }\n        // Remove factors\
    \ of n from factors list\n        while (n > 1 && factors[0] == n) {\n       \
    \     factors.RemoveAt(0);\n            n = n / 2;\n        }\n        // Return\
    \ factors\n        return factors;", "        BigInteger bigInt = BigInteger.ValueOf(n);\n\
    \        List<BigInteger> factors = new List<BigInteger>();\n        Factorize(bigInt,\
    \ factors);\n        return factors;", "        BigInteger i = BigInteger.ValueOf(n);\n\
    \        List<long> factors = new List<long>();\n        factors.Add(BigInteger.ValueOf(2));\n\
    \        BigInteger i0 = i;\n        BigInteger i1 = BigInteger.ValueOf(n);\n\
    \        BigInteger j = 0;\n        for (BigInteger k = BigInteger.ValueOf(2);\
    \ k <= i1; k = k.Multiply(BigInteger.ValueOf(2))) {\n            if (i0.Divide(k).Equals(BigInteger.ValueOf(0))\
    \ || i0.Multiply(k).Equals(BigInteger.ValueOf(0))) continue;\n            if (k.Divide(i0).Equals(BigInteger.ValueOf(0)))\
    \ continue;\n            if (i1.Multiply(k).Equals(i0)) break;\n            for\
    \ (j = k.Divide(i0).Add(BigInteger.ValueOf(1)); j.CompareTo(i1) <= 0; j = j.Add(BigInteger.ValueOf(1)))\
    \ {\n                i0 = i0.Multiply(k).Divide(i0);\n                factors.Add(j.Value);\n\
    \            }\n        }\n        return factors;", "        long[] primeFactorization\
    \ = new long[n + 1];\n        long sqrtN = Convert.ToInt64((long)Math.Sqrt(n));\n\
    \        primeFactorization[0] = n;\n        primeFactorization[1] = 1;\n    \
    \    primeFactorization[2] = 2;\n        long j = 3;\n        while (j < sqrtN)\
    \ {\n            long k = j + 2;\n            while (k < sqrtN && n % k == 0)\
    \ {\n                k = k + 1;\n            }\n            primeFactorization[j]\
    \ = k;\n            j = k;\n        }\n        List<long> factors = new List<long>();\n\
    \        for (int i = 2; i <= n; i++) {\n            bool isPrime = true;\n  \
    \          for (int j = 2; j < primeFactorization[i]; j++) {\n               \
    \ if (i % primeFactorization[j] == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPrime)\n                factors.Add(i);\n        }\n        return factors;",
  "        // Sieve of Atkin\n        var primes = new List<long>();\n        for\
    \ (int p = 2; p < n; p++)\n        {\n            if (primes.Contains(p)) continue;\n\
    \            if (n % p == 0) {\n                for (int i = p * p; i <= n; i\
    \ += p)\n                    primes.Add(i);\n            }\n        }\n      \
    \  return primes.Select(p => p).ToList();", "        // Get prime factors of given\
    \ number.\n        // Return empty list if given number is prime number.\n   \
    \     List<long> factors = new List<long>();\n        double sqrtOfN = Math.Sqrt(n);\n\
    \        int sqrtOfN2 = (int)sqrtOfN;\n\n        // Find factors of given number.\n\
    \        for (int i = 0; i <= sqrtOfN2; i++) {\n            while (n % i == 0)\
    \ {\n                factors.Add(i);\n                n /= i;\n            }\n\
    \        }\n\n        // If number is not prime, add it to the list.\n       \
    \ if (n == 1) {\n            factors.Add(1);\n        }\n\n        // Add 1 to\
    \ final list if number is not prime.\n        if (sqrtOfN != 1) {\n          \
    \  factors.Add(sqrtOfN);\n        }\n\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        // Sieve of Eratosthenes\n        // http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/sievingEratothenes.html\n\
    \        long[] primes = new long[] { 1, 1 };\n        long n = n; // for debugging\n\
    \        for (long p = 2; p <= Math.Sqrt(n); p++) {\n            // Skip even\
    \ numbers\n            if (n % p == 0) {\n                continue;\n        \
    \    }\n            for (long q = 0; q * p <= n; q++) {\n                if (n\
    \ % q == 0) {\n                    break;\n                }\n               \
    \ // Found factor\n                factors.Add(p);\n                n /= p;\n\
    \            }\n            // Update list of primes\n            primes[p / 2]\
    \ = primes[p / 2] + 1;\n        }\n        return factors;", "        Debug.Assert(n>0);\n\
    \        List<long> f = new List<long>();\n        while (true) {\n          \
    \  long p = 2L;\n            int n1 = (int)n;\n            if (n1 < (1L<<32))\
    \ {\n                while (p < (1L<<32) && (n%p) == 0) {\n                  \
    \  n1 /= p;\n                }\n                f.Add(p);\n            }\n   \
    \         if (n1 == (long)n) break;\n            for (int c = 1; c < 32; c++)\
    \ {\n                p *= (1L<<c);\n                if (n%p == 0) {\n        \
    \            f.Add(p);\n                    n /= p;\n                }\n     \
    \       }\n        }\n        return f;", "        List<long> factors = new List<long>();\n\
    \        factors.AddRange(new List<long>(new long[] { 2L }));\n        while (n\
    \ > 1L) {\n            factors.AddRange(new List<long>(factors.TakeWhile(f =>\
    \ f <= n).Select(f => n * f)));\n            n /= 2L;\n        }\n        return\
    \ factors;", "        var ret = new List<long>();\n\n        var small = Divisors(n);\n\
    \        var big = new List<long>();\n\n        // Prime factorizations will use\
    \ two types of primes:\n        // - Largest prime factors -- those smaller than\
    \ current number\n        // - Smaller prime factors -- those larger than current\
    \ number\n        foreach (var prime in small) {\n            foreach (var f in\
    \ big) {\n                if (prime > f)\n                    big.Add(prime);\n\
    \                else\n                    ret.Add(prime);\n            }\n  \
    \      }\n\n        foreach (var f in big)\n            ret.Add(f);\n\n      \
    \  return ret;", "        var primes = new List<long>();\n        var factors\
    \ = new List<long>();\n        var primeFactors = new List<long>();\n        //\
    \ Initialize prime list.\n        for (var i = 2; i <= Math.Sqrt(n); i++)\n  \
    \          if (n % i == 0)\n                primes.Add(i);\n        // Initialize\
    \ factor list.\n        for (var i = 2; i <= n; i++)\n            if (!primes.Contains(i))\n\
    \                factors.Add(i);\n        // Find prime factorization.\n     \
    \   for (var i = 0; i < factors.Count; i++)\n            for (var j = i + 1; j\
    \ < factors.Count; j++)\n                if (factors[i] * factors[j] == n) {\n\
    \                    primeFactors.Add(factors[i]);\n                    primeFactors.Add(factors[j]);\n\
    \                    factors.Remove(factors[j]);\n                    break;\n\
    \                }\n        // Check factors of prime factorization.\n       \
    \ for (var i = primeFactors.Count - 1; i >= 0; i--)\n            for (var j =\
    \ 0; j < factors.Count; j++) {\n                var p = factors.ElementAt(j);\n\
    \                if (p * primeFactors[i] == n) {\n                    primes.Add(primeFactors[i]);\n\
    \                    factors.Remove(p);\n                    break;\n        \
    \        }\n            }\n        return primes.Count == 0 ? factors : new List<long>(primes.ToArray());",
  "        var factors = new List<long>();\n        while (n > 1) {\n            factors.Add(1);\n\
    \            while (n % 2 == 0) {\n                factors.Add(2);\n         \
    \       n /= 2;\n            }\n            while (n % 3 == 0) {\n           \
    \     factors.Add(3);\n                n /= 3;\n            }\n            while\
    \ (n % 5 == 0) {\n                factors.Add(5);\n                n /= 5;\n \
    \           }\n            while (n % 7 == 0) {\n                factors.Add(7);\n\
    \                n /= 7;\n            }\n        }\n        return factors.Reverse().ToList();",
  "        var factors = new List<long>();\n\n        // Compute factors recursively\n\
    \        var x = Factors(n);\n\n        // Sort factors by decreasing power\n\
    \        // i.e. x[0] = n! / (n! * n! * n!)\n        Array.Reverse(x.ToArray());\n\
    \        factors = x.Select(p => new long[] { p, n}).ToList();\n\n        // Filter\
    \ out factors whose powers equal to their multiples\n        return factors.Where(p\
    \ => Factorize(p[0]).SequenceEqual(p)).ToList();", "        List<long> factors\
    \ = new List<long>();\n        for (int i = 2; i <= Math.Sqrt(n); i++) {\n   \
    \         while (n % i == 0) {\n                factors.Add(i);\n            \
    \    n /= i;\n            }\n        }\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        foreach (long factor in Factorization(n))\
    \ {\n            factors.Add(factor);\n        }\n        return factors;", " \
    \       long number = n;\n        bool isPrime;\n        bool hasFactor = false;\n\
    \        List<long> factors = new List<long>();\n\n        while(number > 1) {\n\
    \            isPrime = true;\n            foreach (long f in factors)\n      \
    \          if (number % f == 0)\n                    isPrime = false;\n      \
    \      if (isPrime)\n                factors.Add(number);\n            else\n\
    \                number = number / 2;\n        }\n        return factors;", " \
    \       List<long> ret = new List<long>();\n        List<long> factors = new List<long>();\n\
    \        while (n != 1) {\n            while (n % 2 == 0) {\n                factors.Add(2);\n\
    \                n /= 2;\n            }\n            while (n % 3 == 0) {\n  \
    \              factors.Add(3);\n                n /= 3;\n            }\n     \
    \       while (n % 5 == 0) {\n                factors.Add(5);\n              \
    \  n /= 5;\n            }\n            if (n > 1) {\n                factors.Add(n);\n\
    \                n = 1;\n            }\n            ret.AddRange(factors);\n \
    \       }\n        return ret;", "        Debug.Assert(n > 1);\n        List<long>\
    \ factorization = new List<long>();\n        BigInteger p = BigInteger.ValueOf(1);\n\
    \        do {\n            BigInteger q = p.Multiply(p);\n            factorization.Add(q);\n\
    \            p = q.Multiply(p);\n        } while (p * p < n);\n        return\
    \ factorization;", "        bool prime = true;\n        List<long> factors = new\
    \ List<long>();\n        long current = n;\n        while (current > 1) {\n  \
    \          for (int i = 0; prime && (i < factors.Count); i++) {\n            \
    \    current /= factors[i];\n                prime = (current == 1);\n       \
    \     }\n            factors.Add(current);\n        }\n        return factors;",
  "        var factors = new List<long>();\n        for (long i = 2; i <= n; i++)\
    \ {\n            long j = 1;\n            while (j <= n / i) {\n             \
    \   if (n % i == 0) {\n                    factors.Add(i);\n                 \
    \   n /= i;\n                    break;\n                }\n                j++;\n\
    \            }\n        }\n        if (n > 1) factors.Add(n);\n        return\
    \ factors;", "        long factor = 1;\n        List<long> factors = new List<long>(new\
    \ long[]{1});\n        while (n > 1) {\n            factor = 2;\n            while\
    \ (factor <= n / 2) {\n                if (n % factor == 0) {\n              \
    \      factor = (n/divisorFactor(factor));\n                    break;\n     \
    \           }\n                factor++;\n            }\n            factors.Add(factor);\n\
    \            n--;\n        }\n        return factors;", "        if (n == 1) return\
    \ new List<long>(new long[]{n});\n        List<long> primeFactors = new List<long>();\n\
    \        var maxFactor = n;\n        foreach (var f in Factors(maxFactor)) {\n\
    \            long factor = f;\n            while (factor != 1) {\n           \
    \     if (n % factor == 0) {\n                    maxFactor = n / factor;\n  \
    \                  break;\n                }\n                factor++;\n    \
    \        }\n            if (factor == 1) primeFactors.Add(factor);\n        }\n\
    \        return primeFactors;", "        List<long> factors = new List<long>();\n\
    \        bool isPrime = true;\n        bool isDivisor = true;\n        bool isMultiple\
    \ = false;\n        bool isPowerOfTwo = true;\n        long current;\n       \
    \ long count;\n        for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n\
    \            current = i;\n            while (current % 2 == 0) {\n          \
    \      current /= 2;\n            }\n            while (current % 3 == 0) {\n\
    \                current /= 3;\n            }\n            while (current % 5\
    \ == 0) {\n                current /= 5;\n            }\n            while (current\
    \ % 7 == 0) {\n                current /= 7;\n            }\n            while\
    \ (current % 11 == 0) {\n                current /= 11;\n            }\n     \
    \       while (current % 13 == 0) {\n                current /= 13;\n        \
    \    }\n            while (current % 17 == 0) {\n                current /= 17;\n\
    \            }\n            while (current % 19 == 0) {\n                current\
    \ /= 19;\n            }\n            if (current == 1) {\n                isPrime\
    \ = false;\n                break;\n            }\n            isDivisor = true;\n\
    \            while (current % 2 == 0) {\n                current /= 2;\n     \
    \           isDivisor = false;\n            }\n            while (current % 3\
    \ == 0) {\n                current /= 3;\n                isDivisor = false;\n\
    \            }\n            while (current % 5 == 0) {\n                current\
    \ /= 5;\n                isDivisor = false;\n            }\n            while\
    \ (current % 7 == 0) {\n                current /= 7;\n                isDivisor\
    \ = false;\n            }\n            while (current % 11 == 0) {\n         \
    \       current /= 11;\n                isDivisor = false;\n            }\n  \
    \          while (current % 13 == 0) {\n                current /= 13;\n     \
    \           isDivisor = false;\n            }\n            while (current % 17\
    \ == 0) {\n                current /= 17;\n                isDivisor = false;\n\
    \            }\n            while (current % 19 == 0) {\n                current\
    \ /= 19;\n                isDivisor = false;\n            }\n            if (current\
    \ == 1) {\n                isPrime = false;\n                break;\n        \
    \    }\n            isMultiple = true;\n            while (current % 2 == 0) {\n\
    \                current /= 2;\n                isMultiple = false;\n        \
    \    }\n            while (current % 3 == 0) {\n                current /= 3;\n\
    \                isMultiple = false;\n            }\n            while (current\
    \ % 5 == 0) {\n                current /= 5;\n                isMultiple = false;\n\
    \            }\n            while (current % 7 == 0) {\n                current\
    \ /= 7;\n                isMultiple = false;\n            }\n            while\
    \ (current % 11 == 0) {\n                current /= 11;\n                isMultiple\
    \ = false;\n            }\n            while (current % 13 == 0) {\n         \
    \       current /= 13;\n                isMultiple = false;\n            }\n \
    \           while (current % 17 == 0) {\n                current /= 17;\n    \
    \            isMultiple = false;", "        List<long> factors = new List<long>();\n\
    \        long numOfFactors = FactorizeHelper(n, factors, factors.Count);\n   \
    \     return factors;", "        long m = n; //(long)Math.Sqrt(n);\n        List<long>\
    \ factors = new List<long>(); // list of factors found\n        long[] factorization\
    \ = new long[] {1};\n        \n        List<long> primes = new List<long>() {\
    \ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997});\n        \n        while (m < n) {\n            factorization[0]\
    \ *= m; //long m = n * m;\n            long a = factorization[0]; //long a = n;\n\
    \            long d = 1; //long d = 1;\n            long m = n; //long m = n;\n\
    \            \n            for (int i = 1; i < factorization.Length; i++) {\n\
    \                long tmp = factorization[i];\n                factorization[i]\
    \ = m * tmp;\n                m = tmp;\n            }\n            \n        \
    \    for (int i = 0; i < factorization.Length; i++) {\n                long tmp\
    \ = factorization[i];\n                while (tmp % a == 0) {\n              \
    \      factors.Add(tmp / a);\n                    tmp += a;\n                }\n\
    \            }\n            \n            for (int i = 0; i < primes.Count; i++)\
    \ {\n                long tmp = factor", "        if (n < 2)\n            throw\
    \ new ArgumentOutOfRangeException(\"Factorize\", \"n should be greater than 2\"\
    );\n        long maxFactor = 1;\n        long minFactor = Long.MaxValue;\n   \
    \     for (long f = 2; f <= Math.Sqrt(n); f++) {\n            if (n % f == 0)\
    \ {\n                maxFactor = f;\n                minFactor = f;\n        \
    \    }\n            if (maxFactor == minFactor)\n                break;\n    \
    \    }\n        var factors = new List<long>();\n        for (long f = 2; f <=\
    \ maxFactor; f++) {\n            if (n % f == 0) {\n                factors.Add(f);\n\
    \                while (n % f == 0) {\n                    n /= f;\n         \
    \           factors.Add(f);\n                }\n            }\n        }\n   \
    \     if (n > 1) {\n            factors.Add(n);\n        }\n        Debug.Assert(n\
    \ == 1L || n > 1L);\n        return factors;", "        List<long> factors = new\
    \ List<long>();\n        if (n < 2) {\n            factors.Add(1);\n         \
    \   return factors;\n        }\n        BigInteger bigN = new BigInteger(n.ToString());\n\
    \        BigInteger bigSqr = bigN.Sqrt(BigInteger.One);\n        BigInteger bigM\
    \ = new BigInteger(bigSqr.ToString());\n        int stepCount = bigN.Divide(bigM).ToInt();\n\
    \        int start = 2;\n        while (step < stepCount) {\n            BigInteger\
    \ factor = bigN.Multiply(start).Divide(bigM);\n            factors.Add(factor);\n\
    \            start = factor + 1;\n            step++;\n        }\n        return\
    \ factors;", "        List<long> primeFactors = new List<long>();\n        primeFactors.Add(2);\n\
    \n        // For each possible prime factor, test if n has that factor.\n    \
    \    // If it does not, add it to the list of factors.\n        for (int i = 3;\
    \ i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n              \
    \  primeFactors.Add(i);\n                n /= i;\n            }\n        }\n \
    \       primeFactors.Add(n);\n        return primeFactors;", "        // Initialise\
    \ factorization\n        var factorization = new List<long>();\n        var isPrime\
    \ = new bool[(int)Math.Sqrt(n)];\n\n        // Scan factorization for all divisors\
    \ of n\n        for (int d = 0; d < (int)Math.Sqrt(n); d++) {\n            var\
    \ i = (int)Math.Floor(d / n);\n\n            // If divisor is primeness, add it\
    \ to the factorization\n            if (n % i == 0) {\n                factorization.Add(i);\n\
    \                isPrime[(int)i] = true;\n            }\n        }\n\n       \
    \ // Return factorization sorted by how many times it appears in factorization\n\
    \        return factorization.OrderBy(d => factorization.IndexOf(d)).Select(d\
    \ => new long() {\n            Fact = d,\n            Count = factorization.Count(f\
    \ => f == d)\n        }).ToList();", "        long m = n;\n        if (m == 1)\
    \ return (new List<long>(new long[]{m}));\n        if (m % 2 == 0) return Factorize((m\
    \ >> 1L)); else return Factorize(m >> 1L);", "        long factorization = (long)Math.Sqrt(n);\n\
    \        long factors = factorization;\n        long[] factorizations = new long[factors+1];\n\
    \        factorizations[0] = 1;\n        for (int i = 1; i <= factors; i++) {\n\
    \            factorizations[i] = factorization/i;\n        }\n        List<long>\
    \ result = new List<long>();\n        for (int i = 0; i <= factors; i++) {\n \
    \           if (factorizations[i] > 0) {\n                long p = i;\n      \
    \          long q = 1;\n                while (q*i <= factorizations[i]) {\n \
    \                   q++;\n                }\n                result.Add(p);\n\
    \                result.AddRange(Factorize(factorizations[i]/q));\n          \
    \  }\n        }\n        return result;", "        List<long> factors = new List<long>();\n\
    \n        // Check if given number is a prime number\n        if (n <= 1)\n  \
    \          return factors;\n        if (n == 2)\n            factors.Add(2);\n\
    \        else if (n % 2 == 0)\n            factors.Add(2);\n        else {\n \
    \           // Iterate through all possible factors of given number\n        \
    \    for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n                if (n % i ==\
    \ 0) {\n                    factors.Add(i);\n                    n /= i;\n   \
    \                 break;\n                }\n            }\n        }\n\n    \
    \    // If the number is still not prime then try to go up to 10^8\n        long\
    \ limit = (long)Math.Pow(10, 9L);\n        while (n > limit) {\n            factors.Add(1);\n\
    \            n /= 1;\n        }\n\n        return factors;", "        if (n ==\
    \ 1)\n            return new List<long>(new long[]{n});\n        long result =\
    \ n;\n        List<long> primes = new List<long>();\n        for (long factor\
    \ = 2; factor <= n; factor++) {\n            if ((n % factor) == 0) {\n      \
    \          long divisor = n / factor;\n                primes.Add((long)factor);\n\
    \                result += divisor;\n                while ((n % divisor) == 0)\
    \ {\n                    result += divisor;\n                    n /= divisor;\n\
    \                }\n            }\n        }\n        if (n == 1)\n          \
    \  return new List<long>(new long[]{n});\n        primes.Add((long)n);\n     \
    \   long product = result;\n        while (primes.Count != 0) {\n            if\
    \ (primes.First() == result)\n                break;\n            product = product;\n\
    \            primes.RemoveAt(0);\n        }\n        return new List<long>(new\
    \ long[]{product});", "        List<long> result = new List<long>();\n       \
    \ // Create all prime numbers less than or equal to n\n        long largest =\
    \ Math.Sqrt(n);\n        BigInteger factorization = new BigInteger(n.ToString());\n\
    \        while (true) {\n            if (factorization.IsPrime) {\n          \
    \      result.Add(factorization.ToString());\n                factorization =\
    \ new BigInteger(factorization.ToString());\n            } else {\n          \
    \      factorization = new BigInteger(factorization.ToString()+1);\n         \
    \   }\n            if (factorization.ToString() == largest.ToString()) {\n   \
    \             break;\n            }\n        }\n        return result;", "   \
    \     List<long> result = new List<long>();\n        long product = n; \n    \
    \    long max = n / 2L; \n        bool prime = true; \n\n        while (prime)\
    \ {\n            result.Clear();\n            List<long> factors = new List<long>();\n\
    \            while (n > max) {\n                long factor = product / max;\n\
    \                if (factors.Contains(factor)) factors.Remove(factor);\n     \
    \           else factors.Add(factor);\n                n /= max;\n           \
    \ }\n            if (factors.Count > 0) {\n                prime = false;\n  \
    \              foreach (long factor in factors) {\n                    result.Add(factor);\n\
    \                }\n                product = factors.Sum(x => (long) (x * x));\
    \ // product of factors\n            }\n        }\n        return result;", " \
    \       List<long> factors = new List<long>();\n        // Set up array to store\
    \ factors while factoring\n        long[] factored = new long[n];\n        //\
    \ Keep track of factors while factoring\n        long factor = 1;\n        //\
    \ Test all factors of given number\n        while (factor < n) {\n           \
    \ // If the number is divisible by factor\n            if (n % factor == 0) {\n\
    \                // Add factor to list if its not yet in list and is not already\
    \ in list\n                if (!factors.Contains(factor) || factors.Contains(factors,\
    \ factor)) {\n                    factors.Add(factor);\n                }\n  \
    \              // Add factor to array as it is already in array\n            \
    \    factored[factors.Count - 1]++;\n            }\n            // Add factor\n\
    \            factor++;\n        }\n        // Return list of factors\n       \
    \ return factors;", "        List<long> factors = new List<long>();\n        long\
    \ factorization, prime;\n        // Set up initial factorization to largest prime\
    \ factor\n        factorization = n;\n        while(true) {\n            prime\
    \ = 2;\n            // Set up boolean array of which factors to check\n      \
    \      bool[] factorArray = new bool[100];\n            // Set up boolean flag\
    \ for whether number is prime or not (for speed)\n            bool primeFlag =\
    \ false;\n            // Set up boolean flag for whether number is divisible by\
    \ any prime numbers (for speed)\n            bool divisorFlag = false;\n     \
    \       // Set up boolean flag for whether number is divisible by any composite\
    \ numbers (for speed)\n            bool compositeFlag = false;\n            //\
    \ Set up boolean flag for whether number is divisible by any composite numbers\
    \ (for speed)\n            bool compositeFlag2 = false;\n            // Set up\
    \ boolean flag for whether number is divisible by any composite numbers (for speed)\n\
    \            bool compositeFlag3 = false;\n            while(prime <= factorization)\
    \ {\n                // Set up boolean array of which factors to check\n     \
    \           factorArray[prime-1] = true;\n                // Set up boolean flag\
    \ for whether number is prime or not (for speed)\n                primeFlag =\
    \ true;\n                while(prime * prime <= factorization) {\n           \
    \         if(prime * prime == factorization) {\n                        primeFlag\
    \ = false;\n                        break;\n                    }\n          \
    \          if(factorization%prime == 0) {\n                        factorization\
    \ = factorization / prime;\n                        factors.Add(prime);\n    \
    \                    factorArray[prime-1] = false;\n                        primeFlag\
    \ = true;\n                        break;\n                    }\n           \
    \         prime++;\n                }\n                if(primeFlag == false)\
    \ {\n                    factorization = factorization / prime;\n            \
    \        factors.Add(prime);\n                    factorArray[prime-1] = false;\n\
    \                    break;\n                }\n            }\n            if(factorization%2\
    \ == 0 && factorization%3 == 0) {\n                factorization = factorization\
    \ / 2;\n                factors.Add(2);\n            }\n            if(factorization%5\
    \ == 0 && factorization%7 == 0) {\n                factorization = factorization\
    \ / 5;\n                factors.Add(5);\n            }\n            if(factorization%2\
    \ == 0 && factorization%5 == 0) {\n                factorization = factorization\
    \ / 2;\n                factors.Add(2);\n            }\n            if(factorization%7\
    \ == 0 && factorization%11 == 0) {\n                factorization = factorization\
    \ / 7;\n                factors.Add(7);\n            }\n            if(factorization%11\
    \ == 0 && factorization%17 == 0) {\n                factorization = factorization\
    \ / 11;\n                factors.Add(11);\n            }\n            if(factorization%17\
    \ == 0 && factorization%23", "        if (n < 2) return new List<long>();\n  \
    \      long sqr = Math.Sqrt(n);\n        if (sqr == n || sqr == n-1) return new\
    \ List<long>();\n        List<long> factors = new List<long>();\n        while\
    \ (sqr > 1) {\n            if (n % sqr != 0) {\n                factors.Add(sqr);\n\
    \                n /= sqr;\n            }\n            else {\n              \
    \  long q = (long) (Math.Floor(sqr / 2.0));\n                long r = sqr - q;\n\
    \                if (r > 2) {\n                    long qq = q * q;\n        \
    \            if (qq >= n && qq <= sqr) {\n                        factors.Add(q);\n\
    \                        n -= qq;\n                    }\n                }\n\
    \            }\n        }\n        return factors;", "        // Initialization\n\
    \        bool isPrime = true;\n        long factor = 1;\n        List<long> factors\
    \ = new List<long>();\n        long sqroot = Math.Sqrt(n);\n        long half\
    \ = (int)Math.Floor(sqroot + 0.5);\n        long sqrtn = Math.Sqrt(n);\n     \
    \   bool even = true;\n\n        while (isPrime) {\n            // Prime check\n\
    \            for (int i = 2; i <= sqrtn; i++) {\n                if (n % i ==\
    \ 0) {\n                    isPrime = false;\n                    break;\n   \
    \             }\n            }\n\n            // If it is not prime, check if\
    \ it can be evenly divided by all numbers up to half of the number\n         \
    \   if (!isPrime) {\n                if (sqrtn == half) {\n                  \
    \  for (int i = 2; i <= sqrtn; i++) {\n                        if (n % i == 0)\
    \ {\n                            even = false;\n                            break;\n\
    \                        }\n                    }\n                } else {\n\
    \                    for (int i = (int)half; i > 1; i--) {\n                 \
    \       if (n % i == 0) {\n                            even = false;\n       \
    \                     break;\n                        }\n                    }\n\
    \                }\n            }\n\n            // Factorization\n          \
    \  if (even) {\n                while (n % 2 == 0) {\n                    factor\
    \ = 2;\n                    n /= 2;\n                    factors.Add(factor);\n\
    \                }\n            } else {\n                while (n % 3 == 0) {\n\
    \                    factor = 3;\n                    n /= 3;\n              \
    \      factors.Add(factor);\n                }\n            }\n        }\n   \
    \     return factors;", "        var result = new List<long>();\n\n        if\
    \ (n == 1L)\n            result.Add(n);\n\n        var d = 2;\n        var q =\
    \ n;\n\n        while (q > d) {\n            if (n % d == 0) {\n             \
    \   if (q % d == 0)\n                    result.Add(d);\n                else\
    \ {\n                    result.Add(d + (q % d));\n                    q = q /\
    \ d;\n                }\n            }\n            d++;\n        }\n        return\
    \ result;", "        if (n == 0 || n == 1) return new List<long>(new long[]{n});\n\
    \        var factors = FactorizeHelper(n, 1);\n        return factors.Count ==\
    \ 0 ? new List<long>(new long[]{n}) : factors;", "        if (n <= 1) return new\
    \ List<long>();\n        long[] factors = new long[n + 1];\n        factors[0]\
    \ = 1;\n        factors[1] = 1;\n        // Sieve of Eratosthenes\n        for\
    \ (int i = 2; i <= Math.Sqrt(n); i++) {\n            if (factors[i >> 1] != 0)\
    \ continue;\n            for (int j = i * i; j <= n; j += i) {\n             \
    \   factors[j / i] = 1;\n            }\n        }\n        List<long> result =\
    \ new List<long>();\n        for (int i = 2; i <= n; i++) {\n            if (factors[i]\
    \ == 0) result.Add(i);\n        }\n        return result;", "        List<long>\
    \ factors = new List<long>();\n        List<long> factorList = Factorize(n);\n\
    \        // Find first factor\n        long firstFactor = factorList.FirstOrDefault();\n\
    \        // Find first factor - for now only first factor is needed\n        factors.Add(firstFactor);\n\
    \        // Add all other factors\n        foreach (long f in factorList) {\n\
    \            if (f != firstFactor) {\n                factors.Add(f);\n      \
    \      }\n        }\n        return factors;", "        List<long> result = new\
    \ List<long>();\n        for (long divisor = 2L; divisor <= n; divisor++) {\n\
    \            if (n % divisor == 0L) {\n                while (n % divisor == 0L)\
    \ {\n                    n = n / divisor;\n                    result.Add(divisor);\n\
    \                }\n            }\n        }\n        return result;", "     \
    \   var result = new List<long>();\n        var divisor = 2;\n        while (divisor\
    \ < n / 2) {\n            // skip even numbers\n            if (n % divisor ==\
    \ 0) divisor++;\n            else {\n                var count = 0;\n        \
    \        while (n % divisor == 0) {\n                    count += 1;\n       \
    \             n = n / divisor;\n                }\n                if (count >\
    \ 1) {\n                    result.Add((long)divisor);\n                    while\
    \ (n > 0) {\n                        result.Add((long)n);\n                  \
    \      n = n / divisor;\n                    }\n                    break;\n \
    \               }\n            }\n        }\n        return result;", "      \
    \  List<long> factors = new List<long>();\n        double d = n / 2;\n       \
    \ long i = 2;\n        while (d * i <= n) {\n            while (d * i <= n &&\
    \ i * d < n) {\n                factors.Add(i * d);\n                i += 1;\n\
    \                d *= i;\n            }\n            i++;\n            d = n /\
    \ i;\n        }\n        return factors;", "        if (n == 1L)\n           \
    \ return new List<long>() { n };\n\n        var factors = new List<long>(); //\
    \ List of factors of given number.\n        var factorization = Factorization(factors,\
    \ n, 1L, 1L);\n        if (factorization.Count > 1) {\n            for (var i\
    \ = 0; i < factorization.Count; i++)\n                factors.Add(factorization[i]);\
    \ // Add factors to list of factors\n            return factors;\n        }\n\
    \        return new List<long>() { n };", "        List<long> factors = new List<long>();\n\
    \        List<long> factorization = FactorizeSieve(n);\n        for (int i = 0;\
    \ i < factorization.Count; i++) {\n            factors.Add(factorization[i]);\n\
    \        }\n        return factors;", "        long factorization = 1;\n     \
    \   long limit = (long)Math.Sqrt(n) + 1;\n        long counter = 1;\n        while\
    \ (factorization <= limit) {\n            if (n % factorization == 0) {\n    \
    \            counter++;\n                factorization = n * counter;\n      \
    \      }\n            else {\n                factorization = factorization +\
    \ 1;\n            }\n        }\n        List<long> primes = new List<long>();\n\
    \        long currentLimit = factorization;\n        while (currentLimit <= limit)\
    \ {\n            while (n % currentLimit == 0) {\n                primes.Add(currentLimit);\n\
    \                n = n / currentLimit;\n            }\n            currentLimit\
    \ = currentLimit + 1;\n        }\n        return primes;", "        var factors\
    \ = new List<long>();\n        for (int i = 2; i <= Math.Sqrt(n); ++i)\n     \
    \       if (n % i == 0) {\n                factors.Add(i);\n                n\
    \ /= i;\n            }\n\n        if (n > 1)\n            factors.Add(n);\n\n\
    \        return factors;", "        BigInteger bigN = BigInteger.Abs(n);\n   \
    \     BigInteger bigP = BigInteger.ValueOf(2);\n        BigInteger bigDivisor;\n\
    \        BigInteger bigFactors;\n        BigInteger bigNumberToDivisor;\n    \
    \    BigInteger bigRemainder;\n        List<long> factors = new List<long>();\n\
    \        BigInteger bigFactorsCount = BigInteger.One;\n        bool bigIsPrime\
    \ = false;\n        while (n != 0) {\n            bigDivisor = BigInteger.Divide(bigN,\
    \ bigP);\n            bigRemainder = BigInteger.Mod(bigN, BigInteger.ValueOf(bigDivisor));\n\
    \            if (bigRemainder.Equals(BigInteger.Zero)) {\n                factors.Add(bigDivisor.ToString());\n\
    \                n = BigInteger.Subtract(n, BigInteger.ValueOf(bigDivisor));\n\
    \            } else {\n                bigIsPrime = true;\n                bigFactors\
    \ = BigInteger.ValueOf(bigDivisor).ToString();\n                while (bigRemainder\
    \ != BigInteger.Zero) {\n                    bigNumberToDivisor = BigInteger.Divide(bigN,\
    \ bigDivisor);\n                    bigFactorsCount = BigInteger.Add(bigFactorsCount,\
    \ BigInteger.ValueOf(Math.Pow(bigNumberToDivisor, bigRemainder)));\n         \
    \           bigRemainder = BigInteger.Mod(bigN, BigInteger.ValueOf(bigNumberToDivisor));\n\
    \                }\n                if (bigIsPrime) {\n                    factors.Add(bigFactors);\n\
    \                    n = BigInteger.Subtract(n, BigInteger.ValueOf(bigDivisor));\n\
    \                } else {\n                    factors.Add(bigFactors);\n    \
    \            }\n            }\n        }\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        while (n > 0) {\n            factors.Add(n\
    \ % 10);\n            n /= 10;\n        }\n        factors.Reverse();\n      \
    \  return factors;", "        if (n < 1) {\n            throw new ArgumentOutOfRangeException(\"\
    Number must be greater than 0\");\n        }\n        // find prime factors\n\
    \        var factors = new List<long>();\n        var smallPrimes = Primes(n /\
    \ 2);\n        var bigPrimes = Primes(n - smallPrimes.Count() - 1);\n        if\
    \ (n < 4) {\n            // if input is less than 4 then there are 2 cases:\n\
    \            // a) input is 1\n            // b) input is bigger that 2 ^ 2 *\
    \ 5 ^ 7\n            return new List<long>() { (long)n };\n        }\n\n     \
    \   // case a) input is 1\n        if (n == 1)\n            return new List<long>()\
    \ { (long)n };\n\n        // case b) input is bigger that 2 ^ 2 * 5 ^ 7\n    \
    \    if (n > 70) {\n            // we cannot calculate factorization for number\
    \ that big\n            throw new ArgumentException(\"Number too big!\");\n  \
    \      }\n        // find factors of n\n        foreach (var s in smallPrimes)\
    \ {\n            if (n % s == 0) {\n                var fs = Factorize(s);\n \
    \               foreach (var b in bigPrimes) {\n                    if (n % b\
    \ == 0) {\n                        var fb = Factorize(b);\n                  \
    \      foreach (var f in fs) {\n                            if (f != fb)\n   \
    \                             factors.Add(f);\n                        }\n   \
    \                 }\n                }\n            }\n        }\n        return\
    \ factors;", "        List<long> factors = new List<long>();\n        long n =\
    \ n;\n        long counter = 1;\n        while (n > 2) {\n            // If factorization\
    \ hasn't reached limit and n is prime\n            if (factors.Count == 1000)\
    \ {\n                factors.Add(n);\n                factors.Add(1);\n      \
    \          factors.Add(2);\n                return factors;\n            }\n \
    \           // If factorization hasn't reached limit and n isn't prime\n     \
    \       if (factors.Count == 1000) {\n                factors.Add(n);\n      \
    \          return factors;\n            }\n            // Find next prime factor\
    \ of n\n            long k = n;\n            for (int i = 0; i < 3; i++) {\n \
    \               if (k%2 == 0) {\n                    k /= 2;\n               \
    \ }\n                else {\n                    k = (long) Math.Sqrt(k);\n  \
    \              }\n                if (k == 1) {\n                    break;\n\
    \                }\n                counter++;\n            }\n            factors.Add(n);\n\
    \            factors.Add(counter);\n            n /= counter;\n        }\n   \
    \     return factors;", "        var factorization = new List<long>();\n     \
    \   // Generate prime factorization for given number\n        long primeFactorization\
    \ = GCD(n, 2);\n        // Iteration through primeFactorization starting from\
    \ 2\n        for (long x = 2; x < primeFactorization; x++) {\n            // If\
    \ n divided by any prime number from primeFactorization is equal to 1\n      \
    \      if (n % x == 0) {\n                // We have found a factor\n        \
    \        factorization.Add(x);\n                // We divide n by each prime from\
    \ prime factorization\n                n /= x;\n                // If n is now\
    \ equal to 1 then stop\n                if (n == 1) break;\n            }\n  \
    \      }\n        // If we reached this point then n is prime\n        factorization.Add(n);\n\
    \        // Return list of prime factors\n        return factorization;", "  \
    \      if (n == 1L)\n            return new List<long>();\n        if (n % 2L\
    \ == 1L)\n            return Factorize(n / 2L);\n        if (n % 3L == 1L)\n \
    \           return Factorize(n / 3L);\n        if (n % 5L == 1L)\n           \
    \ return Factorize(n / 5L);\n        List<long> factors = new List<long>();\n\
    \        for (int i = 7; i <= Math.Sqrt(n); i += 7) {\n            if ((n % i)\
    \ == 0L)\n                continue;\n            long tmp = Math.Floor(n / i);\n\
    \            if (tmp == i)\n                tmp++;\n            factors.Add(tmp);\n\
    \            if (tmp > 1L)\n                factors.Add(tmp);\n        }\n   \
    \     if (factors.Count > 1)\n            factors.Add(factors.Count);\n      \
    \  return factors;", "        if (n < 2) {\n            return new List<long>();\n\
    \        }\n        var factorization = new List<long>();\n        var factors\
    \ = FactorizeHelper(n);\n        factorization.AddRange(factors);\n        return\
    \ factorization;", "        Debug.Assert(n>0, \"n can't be zero.\");\n       \
    \ List<long> factors = new List<long>();\n        factors.Add((long)n);\n    \
    \    while (n > 1) {\n            long a = n;\n            long b = n % a;\n \
    \           if (b > 0) {\n                factors.Add(b);\n                n =\
    \ a / b;\n            }\n        }\n        return factors;", "        List<long>\
    \ factors = new List<long>();\n        long n = Math.Abs(n);\n        // Start\
    \ from 1 to sqrt(n)\n        long r = 1;\n        while (Math.Sqrt(r) < n) {\n\
    \            if (n % r == 0) {\n                factors.Add(r);\n            \
    \    n /= r;\n            }\n            r++;\n        }\n        return factors;",
  "        long factor = 2L;\n        var result = new List<long>();\n        while\
    \ (factor <= n) {\n            if (n % factor == 0) {\n                result.Add(factor);\n\
    \                n /= factor;\n            }\n            else {\n           \
    \     if (n % 2 == 0) {\n                    result.Add(2);\n                \
    \    n /= 2;\n                }\n                else {\n                    result.Add(1);\n\
    \                    n /= 2;\n                }\n            }\n        }\n  \
    \      return result;", "        bool isPrime = true;\n        List<long> result\
    \ = new List<long>();\n        for (long i = 2; i <= n / 2; i++) {\n         \
    \   if (n % i == 0) {\n                isPrime = false;\n                break;\n\
    \            }\n        }\n        if (isPrime) {\n            result.Add(n);\n\
    \        }\n        for (long i = 3; i <= Math.Sqrt(n); i += 2) {\n          \
    \  if (n % i == 0) {\n                long p = i;\n                for (long j\
    \ = 2; j <= (n / i); j++) {\n                    if (n % p == 0) {\n         \
    \               isPrime = false;\n                        break;\n           \
    \         }\n                    p++;\n                }\n                if (isPrime)\
    \ {\n                    result.Add(i);\n                }\n            }\n  \
    \      }\n        return result;", "        long[] factorization = new long[n];\n\
    \        // First loop finds factorization\n        for (long i = 3; i <= n; i\
    \ += 2) {\n            while (n % i == 0) {\n                factorization[i /\
    \ 2] = i;\n                n /= i;\n            }\n        }\n        // Second\
    \ loop counts how many times each of the factors appeared in factorization\n \
    \       long nFactor = 1;\n        for (long i = 0; i < n; i++) {\n          \
    \  nFactor *= factorization[i];\n        }\n        List<long> result = new List<long>(new\
    \ long[nFactor]);\n        for (long i = 0; i < nFactor; i++) {\n            result.Add(n);\n\
    \            n /= factorization[i];\n        }\n        return result;", "   \
    \     List<long> result = new List<long>();\n        long p = 1;\n        long\
    \ q = n;\n\n        while (q > p) {\n            for (; p <= q; p++) {\n     \
    \           bool isPrime = true;\n                for (; q % p == 0; q/= p) {\n\
    \                    isPrime = false;\n                }\n                if (isPrime)\n\
    \                    result.Add(p);\n            }\n        }\n        return\
    \ result;", "        List<long> factors = new List<long>();\n        if (n <=\
    \ 1)\n            return factors;\n        long div = n;\n        while (n % div\
    \ == 0)\n            div = div / 2;\n        int count = 1;\n        while (n\
    \ % div != 0) {\n            factors.Add(div);\n            count++;\n       \
    \     div = div / 2;\n        }\n        return factors;", "        int divisor\
    \ = 2, count = 0;\n        int sqrt_divisor = MathHelper.Sqrt(divisor);\n    \
    \    List<long> factorization = new List<long>();\n        while ((n % divisor)\
    \ != 0) {\n            divisor++;\n            count += 1;\n            sqrt_divisor\
    \ = MathHelper.Sqrt(divisor);\n        }\n        if (sqrt_divisor != divisor)\
    \ {\n            factorization.Add(divisor);\n            factorization.Add(sqrt_divisor);\n\
    \        }\n        while ((n % sqrt_divisor) != 0) {\n            sqrt_divisor++;\n\
    \            count += 1;\n            divisor = sqrt_divisor;\n            sqrt_divisor\
    \ = MathHelper.Sqrt(divisor);\n        }\n        if (sqrt_divisor != divisor)\
    \ {\n            factorization.Add(divisor);\n            factorization.Add(sqrt_divisor);\n\
    \        }\n        if (n < divisor) {\n            factorization.Add(divisor);\n\
    \        }\n        return factorization.OrderBy(f => f).ToList();", "       \
    \ long num = 1;\n        List<long> factors = new List<long>();\n\n        while\
    \ (n > 1) {\n            while (n % num != 0) {\n                factors.Add(num);\n\
    \            }\n\n            n = n / num;\n            num++;\n        }\n\n\
    \        return factors;", "        List<long> result = new List<long>();\n  \
    \      long factor = 1;\n        while (factor != 1 && n != 1) {\n           \
    \ if (n % factor == 0) {\n                n /= factor;\n                result.Add(factor);\n\
    \            } else {\n                factor++;\n            }\n        }\n \
    \       if (n != 1) {\n            result.Add(n);\n        }\n        return result;",
  "        // Calculate primes up to sqrt(n) using Sieve of Eratosthenes\n       \
    \ // Sieve of Eratosthenes is O(n) time and O(n) space\n        BitArray sieve\
    \ = new BitArray(Primes.Sieve.Count);\n        for (int i = 0; Primes.Sieve.Length\
    \ > i; i++) {\n            sieve[i] = Primes.Sieve[i];\n        }\n        int\
    \ primeFactorCount = 1;\n        for (int i = 0; i <= n / Primes.Sieve.Count;\
    \ i++) {\n            if (!sieve[i]) {\n                primeFactorCount *= i;\n\
    \                for (long j = i * i; j < n / i; j += i) {\n                 \
    \   sieve[j] = true;\n                }\n            }\n        }\n        List<long>\
    \ primeFactors = new List<long>(Primes.Sieve.Count - primeFactorCount);\n    \
    \    for (int i = 0; Primes.Sieve.Count > i; i++) {\n            long primeFactor\
    \ = Primes.Sieve[i];\n            if (primeFactorCount % primeFactor == 0) {\n\
    \                primeFactors.Add(primeFactor);\n            }\n        }\n  \
    \      return primeFactors;", "        List<long> factors = new List<long>();\n\
    \        long p = n;\n        while (n > 1) {\n            while (n % 2 == 0)\
    \ {\n                n = n / 2;\n                factors.Add(2L);\n          \
    \  }\n            long q = 3;\n            while (q <= n / 3) {\n            \
    \    if (n % q == 0) {\n                    n = n / q;\n                    factors.Add(q);\n\
    \                }\n                q++;\n            }\n            long t =\
    \ q;\n            while (t <= n) {\n                if (n % t == 0) {\n      \
    \              n = n / t;\n                    factors.Add(t);\n             \
    \   }\n                t++;\n            }\n        }\n        return factors;",
  "        if (n % 2 == 0) return new List<long>(new long[] { n / 2 });\n        if\
    \ (n < 2) return new List<long>(new long[] { 2 });\n        long p = 2, q = (long)\
    \ (Math.Sqrt(n));\n        while (p <= q) {\n            bool isPrime = true;\n\
    \            long i = p;\n            while ((i + (q / i)) <= q && isPrime) {\n\
    \                isPrime = ((n % i) == 0);\n                i++;\n           \
    \ }\n            if (isPrime)\n                return new List<long>(new long[]\
    \ { p });\n            p++;\n        }\n        return new List<long>(new long[]\
    \ { n });", "        var factors = new List<long>();\n        var factorsCount\
    \ = 2;\n        while (n % 2 == 0) {\n            factors.Add(2);\n          \
    \  factorsCount++;\n            n /= 2;\n        }\n        while (factorsCount\
    \ < 2) {\n            if (factorsCount < 2) {\n                factorsCount =\
    \ 2;\n            }\n            for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n\
    \                if (n % i == 0) {\n                    factors.Add(i);\n    \
    \                factorsCount += 1;\n                    n /= i;\n           \
    \     }\n            }\n        }\n        factors.Add(n);\n        return factors;",
  "        List<long> factors = new List<long>();\n        if (n < 0) {\n        \
    \    throw new ArgumentException(\"Given number should be non-negative.\");\n\
    \        }\n        long factorization = 1;\n        long lastFactor = n - 1;\n\
    \        while (n > 1) {\n            while (n % factorization == 0) {\n     \
    \           factors.Add(factorization);\n                lastFactor = factorization;\n\
    \                n /= factorization;\n            }\n            factorization++;\n\
    \        }\n        factors.Add(lastFactor);\n        return factors;", "    \
    \    List<long> factors = new List<long>();\n        // Create an array to store\
    \ found factors.\n        long[] factorization = new long[long.MaxValue + 1];\n\
    \        // Create an array to store found factorization's factors multiple.\n\
    \        long[] factorizationMulti = new long[long.MaxValue + 1];\n        //\
    \ Create an array to store found factorization's factors multiple.\n        long[]\
    \ product = new long[long.MaxValue + 1];\n        // Generate factorization array\
    \ from given number.\n        long nFactorization = CalculateFactorization(n);\n\
    \        // Copy factorization array into new array.\n        long[] factorizationCopy\
    \ = factorization.Clone() as long[];\n        // Create variable for counting\
    \ number to be tested for factors.\n        long factorsTested = nFactorization;\n\
    \        // Count factors of original number.\n        for (long i = 2; i <= nFactorization;\
    \ i++) {\n            if (n % i == 0) {\n                factorsTested = i;\n\
    \                factorization[factorizationCopy.Length] = i;\n              \
    \  // Calculate factor multiplication array for each found factor.\n         \
    \       factorizationMulti[factorizationCopy.Length] = CalculateFactorMultiplication(i,\
    \ factorsTested);\n                // Calculate product array for each found factor.\n\
    \                product[factorizationCopy.Length] = CalculateProduct(i, factorsTested);\n\
    \                // Increase factorizationCopy array length.\n               \
    \ factorizationCopy.Length++;\n            }\n        }\n        // Return factors.\n\
    \        return factors;", "        List<long> result = new List<long>();\n  \
    \      if (n == 1) {\n            long f = 3L;\n            result.Add((long)f);\n\
    \            return result;\n        }\n        long f = 2L;\n        while (f\
    \ * f <= n) {\n            while (n % f == 0) {\n                result.Add((long)\
    \ f);\n                n /= f;\n            }\n            if (n > 1) {\n    \
    \            long g = 2L;\n                while ((n / g) * g <= f) {\n      \
    \              if (n % g == 0) {\n                        result.Add((long) g);\n\
    \                        n /= g;\n                    }\n                    g++;\n\
    \                }\n            }\n            f++;\n        }\n        if (n\
    \ > 1) {\n            long g = 2L;\n            while ((n / g) * g <= f) {\n \
    \               if (n % g == 0) {\n                    result.Add((long) g);\n\
    \                    n /= g;\n                }\n                g++;\n      \
    \      }\n        }\n        return result;", "        List<long> factors = new\
    \ List<long>();\n\n        // Factor out first half of number\n        for (long\
    \ i = 2; i <= n; i += 2) {\n            if (n % i == 0) {\n                factors.Add(i);\n\
    \                n /= i;\n            }\n        }\n\n        // If remainder\
    \ is not zero, add 1 to factors and divide by it\n        if (n != 1) factors.Add(n);\n\
    \n        return factors;", "        // Use prime numbers to find factorization\n\
    \        var p = new List<long>() { 2 };\n        foreach (var s in Divisors(n))\
    \ {\n            while (n % s == 0) {\n                p.Add(s);\n           \
    \     n /= s;\n            }\n        }\n        p.Reverse();\n        n.ToList().ForEach(x\
    \ => { Console.WriteLine(x); });\n        return p;", "        List<long> result\
    \ = new List<long>();\n        List<long> primes = new List<long>() { 2L, 3L,\
    \ 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L,\
    \ 67L, 71L, 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 111L, 113L, 127L\
    \ };\n        List<long> factorization = new List<long>();\n        while (n >\
    \ 1) {\n            factorization.Add(n);\n            n = n / primes.SingleOrDefault(x\
    \ => n % x == 0);\n        }\n        result = factorization.Zip(factorization.Skip(1),\
    \ (x, y) => x * y).ToList();\n        return result;", "        var factors =\
    \ new List<long>();\n        var factorization = Factorization(n);\n        factors.AddRange(factorization.Select(f\
    \ => (long)f));\n        return factors;", "        long a = 1;\n        long\
    \ b = n;\n        int counter = 0;\n\n        while (b != 1) {\n            //\
    \ If number is divisable by 2, then check if dividing by 3 gives\n           \
    \ // a smaller number than dividing by 2\n            if (b % 2 == 0) {\n    \
    \            if (b % 3 == 0)\n                    counter++;\n               \
    \ // If divisable by 2, but dividing by 3 gives a number less\n              \
    \  // than 2, then check if dividing by 5 gives a smaller number\n           \
    \     // than dividing by 2\n                else\n                    counter++;\n\
    \            }\n            // If number is divisable by 3, then check if dividing\
    \ by 5 gives\n            // a smaller number than dividing by 3\n           \
    \ else {\n                if (b % 5 == 0)\n                    counter++;\n  \
    \              // If divisable by 3, but dividing by 5 gives a number less\n \
    \               // than 3, then check if dividing by 7 gives a smaller number\n\
    \                // than dividing by 3\n                else\n               \
    \     counter++;\n            }\n            // If number is divisable by 5, then\
    \ check if dividing by 7 gives\n            // a smaller number than dividing\
    \ by 5\n            else {\n                if (b % 7 == 0)\n                \
    \    counter++;\n                // If divisable by 5, but dividing by 7 gives\
    \ a number less\n                // than 5, then check if dividing by 11 gives\
    \ a smaller number\n                // than dividing by 5\n                else\n\
    \                    counter++;\n            }\n            b = b / 2;\n     \
    \       a++;\n        }\n        List<long> primes = new List<long>();\n     \
    \   for (int i = 1; i < counter; i++)\n            primes.Add(a);\n        return\
    \ primes;", "        long factorization = n;\n        List<long> primeFactors\
    \ = new List<long>();\n\n        while (true) {\n            while (factorization\
    \ % 2 == 0) {\n                factorization /= 2;\n                primeFactors.Add(2);\n\
    \            }\n\n            long r = Math.Sqrt(factorization);\n           \
    \ bool isPrime = true;\n\n            for (long i = 2; i <= r; i++) {\n      \
    \          if (factorization == i) {\n                    break;\n           \
    \     }\n\n                if (factorization % i == 0) {\n                   \
    \ isPrime = false;\n                    break;\n                }\n          \
    \  }\n\n            if (isPrime) {\n                primeFactors.Add(factorization);\n\
    \                factorization = 1;\n            } else {\n                factorization\
    \ /= 2;\n            }\n        }\n\n        return primeFactors;", "        List<long>\
    \ result = new List<long>();\n        long largest = n;\n        while (n > 1)\
    \ {\n            while (n % 2 == 0) n /= 2;\n            while (n % 3 == 0) n\
    \ /= 3;\n            while (n % 5 == 0) n /= 5;\n            while (n % 7 == 0)\
    \ n /= 7;\n            while (n % 11 == 0) n /= 11;\n            result.Add(n);\n\
    \            largest = n;\n        }\n        return result;", "        // Generate\
    \ factorization for all numbers from 2 to sqrt(n)\n        // We don't need to\
    \ check numbers from 1 to n since they are degenerate from 2\n        List<long>\
    \ factors = new List<long>();\n        long factor = 1;\n        long limit =\
    \ (long)Math.Sqrt(n);\n        for (long i = 2; i <= limit; i++) {\n         \
    \   if (n % i == 0) {\n                factor *= i;\n                while (n\
    \ % i == 0) {\n                    n /= i;\n                }\n              \
    \  factors.Add(factor);\n                factor = 1;\n            }\n        }\n\
    \        // Return factors in order from smallest to largest\n        return factors;"]
stop_tokens:
- "\n    }\n"
