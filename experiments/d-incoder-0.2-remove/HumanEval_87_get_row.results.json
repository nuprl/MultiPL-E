{
  "language": "d",
  "name": "HumanEval_87_get_row",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.lenght-1) {\n        foreach(j : 0..lst[i].lenght-1) {\n            if(lst[i][j] == x) {\n                res = append(res, Tuple!(i, j));\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_hy5cq3j.d(20): Error: no identifier for declarator `i`\n/tmp/tmp_hy5cq3j.d(20): Error: found `:` when expecting `;`\n/tmp/tmp_hy5cq3j.d(21): Error: no identifier for declarator `j`\n/tmp/tmp_hy5cq3j.d(21): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_hy5cq3j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[](row_index, column_index);\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9tczzy77.d(21): Error: no identifier for declarator `row`\n/tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `;`\n/tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `)`\n/tmp/tmp9tczzy77.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp9tczzy77.d(23): Error: no identifier for declarator `column`\n/tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `;`\n/tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `)`\n/tmp/tmp9tczzy77.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9tczzy77.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1, row)];\n                break;\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res[1], res[1]);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw0_hsc4o.d(21): Error: no identifier for declarator `row`\n/tmp/tmpw0_hsc4o.d(21): Error: found `:` when expecting `;`\n/tmp/tmpw0_hsc4o.d(21): Error: found `:` when expecting `)`\n/tmp/tmpw0_hsc4o.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpw0_hsc4o.d(23): Error: no identifier for declarator `col`\n/tmp/tmpw0_hsc4o.d(23): Error: found `:` when expecting `;`\n/tmp/tmpw0_hsc4o.d(23): Error: found `:` when expecting `)`\n/tmp/tmpw0_hsc4o.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0_hsc4o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                result = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwmo2m3n0.d(20): Error: no identifier for declarator `row`\n/tmp/tmpwmo2m3n0.d(20): Error: found `:` when expecting `;`\n/tmp/tmpwmo2m3n0.d(20): Error: found `:` when expecting `)`\n/tmp/tmpwmo2m3n0.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpwmo2m3n0.d(22): Error: no identifier for declarator `col`\n/tmp/tmpwmo2m3n0.d(22): Error: found `:` when expecting `;`\n/tmp/tmpwmo2m3n0.d(22): Error: found `:` when expecting `)`\n/tmp/tmpwmo2m3n0.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwmo2m3n0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe7_qe_rr.d(29): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe7_qe_rr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1] == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res = Tuple!(long, long)[(0, 0)];\n    for(long i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[rows] = Tuple!(long, long)[lst[i][1], lst[i][0]];\n            rows++;\n        }\n        if(lst[i][1] == x){\n            res[rows] = Tuple!(long, long)[lst[i][0], lst[i][1]];\n            cols--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfp5yr9ip.d(29): Error: Using the result of a comma expression is not allowed\n/tmp/tmpfp5yr9ip.d(29): Error: need `this` for `__expand_field_0` of type `long`\n/tmp/tmpfp5yr9ip.d(32): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpfp5yr9ip.d(36): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfp5yr9ip.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, m, n;\n    long[][] coords = new long[n][2];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                coords[i][0] = 0;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == 0)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == i)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n                coords[i][1] = j;\n                break;\n            }\n        }\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjqpd4__z.d(153): Error: found `unittest` instead of statement\n/tmp/tmpjqpd4__z.d(164): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjqpd4__z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzp9m6nd5.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpzp9m6nd5.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpzp9m6nd5.d(27): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzp9m6nd5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                result.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) -> a.first < b.first ? -1 : a.first > b.first ? 1 : 0);\n    result.sort(function(a, b) -> a.second > b.second ? -1 : a.second < b.second ? 1 : 0);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb1vygrqt.d(21): Error: no identifier for declarator `i`\n/tmp/tmpb1vygrqt.d(21): Error: found `:` when expecting `;`\n/tmp/tmpb1vygrqt.d(23): Error: no identifier for declarator `j`\n/tmp/tmpb1vygrqt.d(23): Error: found `:` when expecting `;`\n/tmp/tmpb1vygrqt.d(32): Error: missing `{ ... }` for function literal\n/tmp/tmpb1vygrqt.d(32): Error: expression expected, not `>`\n/tmp/tmpb1vygrqt.d(32): Error: found `a` when expecting `,`\n/tmp/tmpb1vygrqt.d(33): Error: missing `{ ... }` for function literal\n/tmp/tmpb1vygrqt.d(33): Error: expression expected, not `>`\n/tmp/tmpb1vygrqt.d(33): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1vygrqt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 = m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n    long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n    long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n    long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n    long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n    long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n    long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n    long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n    long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n    long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n    long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n    long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n    long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n    long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n    long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknmqfrj2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] + 1);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_qw_i73u.d(114): Error: found `unittest` when expecting `;` following statement\n/tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_qw_i73u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppwde7bkg.d(22): Error: no identifier for declarator `long`\n/tmp/tmppwde7bkg.d(22): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppwde7bkg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    long row = 0;\n    long col = 0;\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] < x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] < x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col++;\n            }\n        }\n    }\n    \n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa44plfxs.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpa44plfxs.d(138): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa44plfxs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    foreach(row: lst, i: 0)\n    {\n        foreach(col: row, j: 0)\n        {\n            if(col == x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    foreach(row: lst, i: 0)\n    {\n        foreach(col: row, j: 0)\n        {\n            if(col != x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7g3pxtcj.d(21): Error: no identifier for declarator `row`\n/tmp/tmp7g3pxtcj.d(21): Error: found `:` when expecting `;`\n/tmp/tmp7g3pxtcj.d(21): Error: found `:` when expecting `)`\n/tmp/tmp7g3pxtcj.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp7g3pxtcj.d(23): Error: no identifier for declarator `col`\n/tmp/tmp7g3pxtcj.d(23): Error: found `:` when expecting `;`\n/tmp/tmp7g3pxtcj.d(23): Error: found `:` when expecting `)`\n/tmp/tmp7g3pxtcj.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmp7g3pxtcj.d(32): Error: no identifier for declarator `row`\n/tmp/tmp7g3pxtcj.d(32): Error: found `:` when expecting `;`\n/tmp/tmp7g3pxtcj.d(32): Error: found `:` when expecting `)`\n/tmp/tmp7g3pxtcj.d(32): Error: found `)` when expecting `;` following statement\n/tmp/tmp7g3pxtcj.d(34): Error: no identifier for declarator `col`\n/tmp/tmp7g3pxtcj.d(34): Error: found `:` when expecting `;`\n/tmp/tmp7g3pxtcj.d(34): Error: found `:` when expecting `)`\n/tmp/tmp7g3pxtcj.d(34): Error: found `)`",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                return Tuple!(long, long)[Tuple!(i-1, j), Tuple!(i, j-1)];\n            }\n        }\n    }\n    return Tuple!(long, long)[Tuple!(n, m)];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tpdldgr.d(29): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(n, m)` cannot use local `n` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(n, m)` cannot use local `m` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmp_tpdldgr.d(33): Error: template instance `tmp_tpdldgr.get_row.Tuple!(n, m)` error instantiating\nFailed: [\"dmd\", \"-unittest\",",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp7p6are4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy4ax7p7k.d(149): Error: found `unittest` when expecting `)`\n/tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy4ax7p7k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                ans = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n            }\n        }\n    }\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col > x)\n            {\n                ans = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfuzbt45x.d(21): Error: no identifier for declarator `lst`\n/tmp/tmpfuzbt45x.d(21): Error: found `)` when expecting `;`\n/tmp/tmpfuzbt45x.d(23): Error: no identifier for declarator `row`\n/tmp/tmpfuzbt45x.d(23): Error: found `)` when expecting `;`\n/tmp/tmpfuzbt45x.d(31): Error: found `}` when expecting `)`\n/tmp/tmpfuzbt45x.d(33): Error: no identifier for declarator `lst`\n/tmp/tmpfuzbt45x.d(33): Error: found `)` when expecting `;`\n/tmp/tmpfuzbt45x.d(35): Error: no identifier for declarator `row`\n/tmp/tmpfuzbt45x.d(35): Error: found `)` when expecting `;`\n/tmp/tmpfuzbt45x.d(43): Error: found `}` when expecting `)`\n/tmp/tmpfuzbt45x.d(47): Error: found `unittest` when expecting `)`\n/tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `)`\n/tmp/tmpfuzbt45x.d(58): Error: found `End of File` instead of statement\n/tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `}` following compound sta",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4xst1tj3.d(20): Error: no identifier for declarator `lst`\n/tmp/tmp4xst1tj3.d(20): Error: found `)` when expecting `;`\n/tmp/tmp4xst1tj3.d(22): Error: no identifier for declarator `row`\n/tmp/tmp4xst1tj3.d(22): Error: found `)` when expecting `;`\n/tmp/tmp4xst1tj3.d(30): Error: found `}` when expecting `)`\n/tmp/tmp4xst1tj3.d(33): Error: found `unittest` when expecting `)`\n/tmp/tmp4xst1tj3.d(44): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4xst1tj3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptjlq8vs3.d(27): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptjlq8vs3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                res[i] = Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmp8rch3q06.d(30): Error: template instance `tmp8rch3q06.get_row.Tuple!(i, j)` error instantiating\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8rch3q06.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                row[j] = (lst[i][0], lst[i][1]);\n            }\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphd09hvs3.d(78): Error: expression expected, not `unittest`\n/tmp/tmphd09hvs3.d(79): Error: found `{` when expecting `)` following template argument list\n/tmp/tmphd09hvs3.d(80): Error: found `alias` when expecting `;` following statement\n/tmp/tmphd09hvs3.d(89): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmphd09hvs3.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphd09hvs3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = lst.length;\n    long cols = lst[0].length;\n    long[] res = new long[rows*cols];\n    for(int i = 0; i < rows; i++)\n    {\n        for(int j = 0; j < cols; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i*cols + j] = i;\n                res[i*cols + j + 1] = j;\n            }\n        }\n    }\n    Arrays.sort(res);\n    return Tuple!(long, long)[](res, rows);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp99_heczy.d(33): Error: undefined identifier `Arrays`\n/tmp/tmp99_heczy.d(34): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp99_heczy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a[0] > b[0])\n            return 1;\n        if(a[0] < b[0])\n            return -1;\n        return 0;\n    });\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a[1] > b[1])\n            return 1;\n        if(a[1] < b[1])\n            return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7b95cc5n.d(34): Error: expression expected, not `>`\n/tmp/tmp7b95cc5n.d(34): Error: found `{` when expecting `,`\n/tmp/tmp7b95cc5n.d(35): Error: expression expected, not `if`\n/tmp/tmp7b95cc5n.d(36): Error: found `return` when expecting `,`\n/tmp/tmp7b95cc5n.d(36): Error: found `;` when expecting `,`\n/tmp/tmp7b95cc5n.d(37): Error: expression expected, not `if`\n/tmp/tmp7b95cc5n.d(38): Error: found `return` when expecting `,`\n/tmp/tmp7b95cc5n.d(38): Error: found `;` when expecting `,`\n/tmp/tmp7b95cc5n.d(39): Error: expression expected, not `return`\n/tmp/tmp7b95cc5n.d(39): Error: found `0` when expecting `,`\n/tmp/tmp7b95cc5n.d(39): Error: expression expected, not `;`\n/tmp/tmp7b95cc5n.d(40): Error: found `}` when expecting `,`\n/tmp/tmp7b95cc5n.d(42): Error: expression expected, not `>`\n/tmp/tmp7b95cc5n.d(42): Error: found `{` when expecting `,`\n/tmp/tmp7b95cc5n.d(43): Error: expression expected, not `if`\n/tmp/tmp7b95cc5n.d(44): Error: found `return` when expecting `,`\n/tmp/tmp7b95cc5n.d(44): Error: found `;` ",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row) \n    {\n        foreach(column: row, column: column) \n        {\n            if(column == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp01jm0614.d(21): Error: no identifier for declarator `row`\n/tmp/tmp01jm0614.d(21): Error: found `:` when expecting `;`\n/tmp/tmp01jm0614.d(21): Error: found `:` when expecting `)`\n/tmp/tmp01jm0614.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp01jm0614.d(23): Error: no identifier for declarator `column`\n/tmp/tmp01jm0614.d(23): Error: found `:` when expecting `;`\n/tmp/tmp01jm0614.d(23): Error: found `:` when expecting `)`\n/tmp/tmp01jm0614.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp01jm0614.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = null;\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n            {\n                res = new Tuple!(long, long)[](i, j);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7r4gd6yt.d(30): Error: too many arguments for array\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7r4gd6yt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    Arrays.sort(ret);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb_wblo27.d(25): Error: variable `lst` cannot be read at compile time\n/tmp/tmpb_wblo27.d(25): Error: variable `lst` cannot be read at compile time\n/tmp/tmpb_wblo27.d(29): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_wblo27.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp83xzmj8v.d(20): Error: no identifier for declarator `row`\n/tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `;`\n/tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `)`\n/tmp/tmp83xzmj8v.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp83xzmj8v.d(22): Error: no identifier for declarator `col`\n/tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `;`\n/tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `)`\n/tmp/tmp83xzmj8v.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83xzmj8v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpodyznd6l.d(20): Error: no identifier for declarator `lst`\n/tmp/tmpodyznd6l.d(20): Error: found `)` when expecting `;`\n/tmp/tmpodyznd6l.d(22): Error: no identifier for declarator `row`\n/tmp/tmpodyznd6l.d(22): Error: found `)` when expecting `;`\n/tmp/tmpodyznd6l.d(30): Error: found `if` when expecting `)`\n/tmp/tmpodyznd6l.d(31): Error: found `break` when expecting `;` following statement\n/tmp/tmpodyznd6l.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpodyznd6l.d(33): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpodyznd6l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n            for(long j = 0; j < lst[i].length; ++j)\n            {\n                row[j] = (i, lst[i][j]);\n            }\n            sort(row, true);\n            sort(row, false);\n            for(long j = 0; j < row.length; ++j)\n            {\n                res[res.length] = row[j];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptl32udx5.d(27): Error: Using the result of a comma expression is not allowed\n/tmp/tmptl32udx5.d(27): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(long)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmptl32udx5.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmptl32udx5.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptl32udx5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][1] < x){\n            for(int j = i; j < lst.length; j++){\n                if(lst[j][1] > x){\n                    swap(lst[i], lst[j]);\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][1] < x){\n            for(int j = i; j < lst.length; j++){\n                if(lst[j][1] > x){\n                    swap(lst[i], lst[j]);\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm1qxw0rx.d(111): Error: found `unittest` instead of statement\n/tmp/tmpm1qxw0rx.d(122): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm1qxw0rx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp = i;\n                i = j;\n                j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa_dse2ot.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpa_dse2ot.d(154): Error: found `unittest` instead of statement\n/tmp/tmpa_dse2ot.d(165): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa_dse2ot.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.len) \n    {\n        foreach(j : 0..lst[i].len) \n        {\n            if(lst[i][j] == x) \n            {\n                res = append(res, Tuple!(i, j));\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu2py5z9p.d(20): Error: no identifier for declarator `i`\n/tmp/tmpu2py5z9p.d(20): Error: found `:` when expecting `;`\n/tmp/tmpu2py5z9p.d(22): Error: no identifier for declarator `j`\n/tmp/tmpu2py5z9p.d(22): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2py5z9p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n        if(lst[i][0] == x)\n        {\n            res = lst[i];\n            break;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2vgaoxvg.d(20): Error: no identifier for declarator `i`\n/tmp/tmp2vgaoxvg.d(20): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2vgaoxvg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg7sgbuvt.d(20): Error: no identifier for declarator `lst`\n/tmp/tmpg7sgbuvt.d(20): Error: found `)` when expecting `;`\n/tmp/tmpg7sgbuvt.d(22): Error: no identifier for declarator `row`\n/tmp/tmpg7sgbuvt.d(22): Error: found `)` when expecting `;`\n/tmp/tmpg7sgbuvt.d(29): Error: found `}` when expecting `)`\n/tmp/tmpg7sgbuvt.d(32): Error: found `unittest` when expecting `)`\n/tmp/tmpg7sgbuvt.d(43): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg7sgbuvt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[Tuple!((row_index, column_index)), Tuple!((row_index, column_index + 1))];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6xv8xj89.d(20): Error: no identifier for declarator `row`\n/tmp/tmp6xv8xj89.d(20): Error: found `:` when expecting `;`\n/tmp/tmp6xv8xj89.d(20): Error: found `:` when expecting `)`\n/tmp/tmp6xv8xj89.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp6xv8xj89.d(22): Error: no identifier for declarator `column`\n/tmp/tmp6xv8xj89.d(22): Error: found `:` when expecting `;`\n/tmp/tmp6xv8xj89.d(22): Error: found `:` when expecting `)`\n/tmp/tmp6xv8xj89.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xv8xj89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) => b - a);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        res[i] = new Tuple!(long, long)(i, res[i]);\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdsfq67y.d(32): Error: undefined identifier `Arrays`\n/tmp/tmppdsfq67y.d(33): Error: undefined identifier `Arrays`\n/tmp/tmppdsfq67y.d(35): Error: declaration `tmppdsfq67y.get_row.res` is already defined\n/tmp/tmppdsfq67y.d(38): Error: cannot implicitly convert expression `new Tuple!(long, long)(cast(long)i, res[cast(ulong)i])` of type `Tuple!(long, long)*` to `long`\n/tmp/tmppdsfq67y.d(41): Error: cannot implicitly convert expression `res` of type `long[]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdsfq67y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    long i, j;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n            {\n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k - 1];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k + 1];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n                }\n                \n                for(k = j; k < \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz_5j5o8q.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpz_5j5o8q.d(118): Error: expression expected, not `unittest`\n/tmp/tmpz_5j5o8q.d(119): Error: found `{` when expecting `;` following `for` condition\n/tmp/tmpz_5j5o8q.d(120): Error: expression expected, not `alias`\n/tmp/tmpz_5j5o8q.d(120): Error: found `candidate` when expecting `)`\n/tmp/tmpz_5j5o8q.d(120): Error: found `=` instead of statement\n/tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_5j5o8q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                foreach(coord: row, coord: coord) \n                {\n                    result.push(Tuple!(coord, row));\n                }\n                break;\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col > x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col < x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col == x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col > x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col < x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \n            {\n                if(col == x) \n                {\n                    result.push(Tuple!(col, row));\n                }\n            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col: row, col: col) \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgltp4run.d(21): Error: no identifier for declarator `row`\n/tmp/tmpgltp4run.d(21): Error: found `:` when expecting `;`\n/tmp/tmpgltp4run.d(21): Error: found `:` when expecting `)`\n/tmp/tmpgltp4run.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpgltp4run.d(23): Error: no identifier for declarator `col`\n/tmp/tmpgltp4run.d(23): Error: found `:` when expecting `;`\n/tmp/tmpgltp4run.d(23): Error: found `:` when expecting `)`\n/tmp/tmpgltp4run.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpgltp4run.d(27): Error: no identifier for declarator `coord`\n/tmp/tmpgltp4run.d(27): Error: found `:` when expecting `;`\n/tmp/tmpgltp4run.d(27): Error: found `:` when expecting `)`\n/tmp/tmpgltp4run.d(27): Error: found `)` when expecting `;` following statement\n/tmp/tmpgltp4run.d(36): Error: no identifier for declarator `coord`\n/tmp/tmpgltp4run.d(36): Error: found `:` when expecting `;`\n/tmp/tmpgltp4run.d(36): Error: found `:` when expecting `)`\n/tmp/tmpgltp4run.d(36): Error: found",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    long[][] result = new long[n][m];\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuldxoir2.d(91): Error: found `unittest` when expecting `,`\n/tmp/tmpuldxoir2.d(102): Error: found `void` when expecting `,`\n/tmp/tmpuldxoir2.d(102): Error: found `{` when expecting `,`\n/tmp/tmpuldxoir2.d(102): Error: expression expected, not `}`\n/tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `,`\n/tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `)`\n/tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `;` following statement\n/tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuldxoir2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(column: row, column: column) \n        {\n            if(column == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkbc6cxuz.d(20): Error: no identifier for declarator `row`\n/tmp/tmpkbc6cxuz.d(20): Error: found `:` when expecting `;`\n/tmp/tmpkbc6cxuz.d(20): Error: found `:` when expecting `)`\n/tmp/tmpkbc6cxuz.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpkbc6cxuz.d(22): Error: no identifier for declarator `column`\n/tmp/tmpkbc6cxuz.d(22): Error: found `:` when expecting `;`\n/tmp/tmpkbc6cxuz.d(22): Error: found `:` when expecting `)`\n/tmp/tmpkbc6cxuz.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkbc6cxuz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq2jq9cut.d(20): Error: no identifier for declarator `i`\n/tmp/tmpq2jq9cut.d(20): Error: found `:` when expecting `;`\n/tmp/tmpq2jq9cut.d(22): Error: no identifier for declarator `j`\n/tmp/tmpq2jq9cut.d(22): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq2jq9cut.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppwde7bkg.d(22): Error: no identifier for declarator `long`\n/tmp/tmppwde7bkg.d(22): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppwde7bkg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp83xzmj8v.d(20): Error: no identifier for declarator `row`\n/tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `;`\n/tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `)`\n/tmp/tmp83xzmj8v.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp83xzmj8v.d(22): Error: no identifier for declarator `col`\n/tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `;`\n/tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `)`\n/tmp/tmp83xzmj8v.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83xzmj8v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6zvo7mx9.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp6zvo7mx9.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp6zvo7mx9.d(27): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zvo7mx9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a.first > b.first)\n            return 1;\n        if(a.first < b.first)\n            return -1;\n        return 0;\n    });\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a.second > b.second)\n            return 1;\n        if(a.second < b.second)\n            return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr8nbgw3u.d(28): Error: expression expected, not `>`\n/tmp/tmpr8nbgw3u.d(28): Error: found `{` when expecting `,`\n/tmp/tmpr8nbgw3u.d(29): Error: expression expected, not `if`\n/tmp/tmpr8nbgw3u.d(30): Error: found `return` when expecting `,`\n/tmp/tmpr8nbgw3u.d(30): Error: found `;` when expecting `,`\n/tmp/tmpr8nbgw3u.d(31): Error: expression expected, not `if`\n/tmp/tmpr8nbgw3u.d(32): Error: found `return` when expecting `,`\n/tmp/tmpr8nbgw3u.d(32): Error: found `;` when expecting `,`\n/tmp/tmpr8nbgw3u.d(33): Error: expression expected, not `return`\n/tmp/tmpr8nbgw3u.d(33): Error: found `0` when expecting `,`\n/tmp/tmpr8nbgw3u.d(33): Error: expression expected, not `;`\n/tmp/tmpr8nbgw3u.d(34): Error: found `}` when expecting `,`\n/tmp/tmpr8nbgw3u.d(36): Error: expression expected, not `>`\n/tmp/tmpr8nbgw3u.d(36): Error: found `{` when expecting `,`\n/tmp/tmpr8nbgw3u.d(37): Error: expression expected, not `if`\n/tmp/tmpr8nbgw3u.d(38): Error: found `return` when expecting `,`\n/tmp/tmpr8nbgw3u.d(38): Error: found `;` ",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: long in\n        enumerate(row))\n    {\n        foreach(col: row, col_index: long in\n            enumerate(col))\n        {\n            if(col_index == x)\n            {\n                result = Tuple!(long, long)[Tuple!(0, row_index)];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6yyyoapf.d(20): Error: no identifier for declarator `row`\n/tmp/tmp6yyyoapf.d(20): Error: found `:` when expecting `;`\n/tmp/tmp6yyyoapf.d(20): Error: found `:` when expecting `)`\n/tmp/tmp6yyyoapf.d(20): Error: no identifier for declarator `long`\n/tmp/tmp6yyyoapf.d(20): Error: found `in` instead of statement\n/tmp/tmp6yyyoapf.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6yyyoapf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    sort(res);\n    for(i = 0; i < n; i++)\n    {\n        res[i] = res[i].swap;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp940r8cz3.d(29): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmp940r8cz3.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp940r8cz3.d(37): Error: no property `swap` for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp940r8cz3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) => a[0] - b[0]);\n    Arrays.sort(res, (a, b) => a[1] - b[1]);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8ml0pg6o.d(19): Error: variable `lst` cannot be read at compile time\n/tmp/tmp8ml0pg6o.d(31): Error: undefined identifier `Arrays`\n/tmp/tmp8ml0pg6o.d(32): Error: undefined identifier `Arrays`\n/tmp/tmp8ml0pg6o.d(34): Error: cannot implicitly convert expression `res` of type `long[][]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ml0pg6o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            \n            for(long j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j] > x)\n                {\n                    row.Add(lst[i][j], j);\n                }\n            }\n            \n            row.Sort();\n            \n            for(long j = 0; j < row.Length; j++)\n            {\n                result.Add(row[j], i);\n            }\n        }\n    }\n    \n    result.Sort();\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpem9gpbx2.d(21): Error: no property `Length` for type `long[][]`\n/tmp/tmpem9gpbx2.d(27): Error: no property `Length` for type `long[]`\n/tmp/tmpem9gpbx2.d(31): Error: no property `Add` for type `Tuple!(long, long)[]`\n/tmp/tmpem9gpbx2.d(35): Error: no property `Sort` for type `Tuple!(long, long)[]`\n/tmp/tmpem9gpbx2.d(37): Error: no property `Length` for type `Tuple!(long, long)[]`\n/tmp/tmpem9gpbx2.d(39): Error: no property `Add` for type `Tuple!(long, long)[]`\n/tmp/tmpem9gpbx2.d(44): Error: no property `Sort` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpem9gpbx2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, lst.length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr39b5vlh.d(31): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr39b5vlh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp7p6are4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_7dty2p3.d(28): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_7dty2p3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n        foreach(long x, y)\n        {\n            if(x != x)\n            {\n                cols++;\n            }\n            else\n            {\n                rows++;\n            }\n        }\n    }\n    \n    Tuple!(long, long)[] result = new Tuple!(long, long)[rows];\n    \n    foreach(long y, lst)\n    {\n        foreach(long x, y)\n        {\n            if(x != x)\n            {\n                result[rows] = new Tuple!(long, long)(x, y);\n            }\n        }\n    }\n    \n    foreach(long y, lst)\n    {\n        foreach(long x, y)\n        {\n            if(x != x)\n            {\n                result[rows] = new Tuple!(long, long)(x, y);\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5get54nd.d(22): Error: no identifier for declarator `lst`\n/tmp/tmp5get54nd.d(22): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(24): Error: no identifier for declarator `y`\n/tmp/tmp5get54nd.d(24): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(35): Error: found `}` when expecting `)`\n/tmp/tmp5get54nd.d(39): Error: no identifier for declarator `lst`\n/tmp/tmp5get54nd.d(39): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(41): Error: no identifier for declarator `y`\n/tmp/tmp5get54nd.d(41): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(48): Error: found `}` when expecting `)`\n/tmp/tmp5get54nd.d(50): Error: no identifier for declarator `lst`\n/tmp/tmp5get54nd.d(50): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(52): Error: no identifier for declarator `y`\n/tmp/tmp5get54nd.d(52): Error: found `)` when expecting `;`\n/tmp/tmp5get54nd.d(59): Error: found `}` when expecting `)`\n/tmp/tmp5get54nd.d(63): Error: found `unittest` when expecting `)`\n/tmp/tmp5get54nd.d(74): Err",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long row = 0;\n    long col = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                return Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return Tuple!(long, long)[](row, col);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqo49fp9_.d(31): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\n/tmp/tmpqo49fp9_.d(35): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqo49fp9_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (int)i;\n                    temp[k][1] = (int)j;\n                }\n                Arrays.sort(temp, (x, y) -> {\n                    return y[0] - x[0];\n                });\n                \n                Tuple!(long, long)[] res = new Tuple!(long, long)[temp.length];\n                for(int k = 0; k < temp.length; k++)\n                {\n                    res[k] = new Tuple!(long, long)[temp[k].length];\n                    res[k][0] = (long)temp[k][0];\n                    res[k][1] = (long)temp[k][1];\n                }\n                return res;\n            }\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprq2zleo6.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmprq2zleo6.d(39): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmprq2zleo6.d(42): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmprq2zleo6.d(43): Error: C style cast illegal, use `cast(int)j`\n/tmp/tmprq2zleo6.d(45): Error: expression expected, not `>`\n/tmp/tmprq2zleo6.d(45): Error: found `{` when expecting `,`\n/tmp/tmprq2zleo6.d(46): Error: expression expected, not `return`\n/tmp/tmprq2zleo6.d(46): Error: found `y` when expecting `,`\n/tmp/tmprq2zleo6.d(46): Error: found `;` when expecting `,`\n/tmp/tmprq2zleo6.d(47): Error: expression expected, not `}`\n/tmp/tmprq2zleo6.d(53): Error: C style cast illegal, use `cast(long)temp[k][0]`\n/tmp/tmprq2zleo6.d(54): Error: C style cast illegal, use `cast(long)temp[k][1]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprq2zleo6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprw5vp7ay.d(33): Error: expression expected, not `>`\n/tmp/tmprw5vp7ay.d(33): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprw5vp7ay.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long[], long[])[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgk5ild6u.d(28): Error: function expected before `()`, not `Tuple!(long[], long[])[]` of type `Tuple!(long[], long[])[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgk5ild6u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] row = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length; i++)\n    {\n        row[i] = lst[0][i];\n    }\n    \n    for(int i = 0; i < lst[0].Length; i++)\n    {\n        if(row[i] == x)\n        {\n            Tuple!(long, long)[] res = new Tuple!(long, long)[lst[0].Length];\n            for(int j = 0; j < lst[0].Length; j++)\n            {\n                res[j] = (i, j);\n            }\n            return res;\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_d51wbdr.d(19): Error: no property `Length` for type `long[]`\n/tmp/tmp_d51wbdr.d(20): Error: no property `Length` for type `long[]`\n/tmp/tmp_d51wbdr.d(25): Error: no property `Length` for type `long[]`\n/tmp/tmp_d51wbdr.d(29): Error: no property `Length` for type `long[]`\n/tmp/tmp_d51wbdr.d(30): Error: no property `Length` for type `long[]`\n/tmp/tmp_d51wbdr.d(32): Error: Using the result of a comma expression is not allowed\n/tmp/tmp_d51wbdr.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(int)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_d51wbdr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n            {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n        }\n    }\n    \n    for(int \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjy54nyq5.d(129): Error: no identifier for declarator `int`\n/tmp/tmpjy54nyq5.d(129): Error: expression expected, not `unittest`\n/tmp/tmpjy54nyq5.d(130): Error: found `{` when expecting `;` following `for` condition\n/tmp/tmpjy54nyq5.d(131): Error: expression expected, not `alias`\n/tmp/tmpjy54nyq5.d(131): Error: found `candidate` when expecting `)`\n/tmp/tmpjy54nyq5.d(131): Error: found `=` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjy54nyq5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpf4lzgs77.d(26): Error: template instance `tmpf4lzgs77.get_row.Tuple!(i, j)` error instantiating\n/tmp/tmpf4lzgs77.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittes",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        for(j = k - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j + 1];\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] - 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] + 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        for(j = k - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j + 1];\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] - 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] + 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        for(j = k - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j + 1];\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] - 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] + 1;\n        }\n    }\n    for(i = 0; i < n; i++)\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_nreqgx2.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp_nreqgx2.d(144): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_nreqgx2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[](row_index, column_index);\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg1ymobvx.d(21): Error: no identifier for declarator `row`\n/tmp/tmpg1ymobvx.d(21): Error: found `:` when expecting `;`\n/tmp/tmpg1ymobvx.d(21): Error: found `:` when expecting `)`\n/tmp/tmpg1ymobvx.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpg1ymobvx.d(23): Error: no identifier for declarator `column`\n/tmp/tmpg1ymobvx.d(23): Error: found `:` when expecting `;`\n/tmp/tmpg1ymobvx.d(23): Error: found `:` when expecting `)`\n/tmp/tmpg1ymobvx.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1ymobvx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k == m)\n        {\n            k = j;\n        }\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcmkajzos.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpcmkajzos.d(162): Error: found `unittest` instead of statement\n/tmp/tmpcmkajzos.d(173): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcmkajzos.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res[res.length] = Tuple!(row,col);\n            }\n        }\n    }\n    sort(res,fun(x1,x2)->x1.1 > x2.1);\n    sort(res,fun(x1,x2)->x1.2 > x2.2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3666a2g7.d(20): Error: no identifier for declarator `lst`\n/tmp/tmp3666a2g7.d(20): Error: found `)` when expecting `;`\n/tmp/tmp3666a2g7.d(22): Error: no identifier for declarator `row`\n/tmp/tmp3666a2g7.d(22): Error: found `)` when expecting `;`\n/tmp/tmp3666a2g7.d(29): Error: found `}` when expecting `)`\n/tmp/tmp3666a2g7.d(30): Error: expression expected, not `>`\n/tmp/tmp3666a2g7.d(30): Error: found `x1` when expecting `,`\n/tmp/tmp3666a2g7.d(30): Error: found `0.1` when expecting `,`\n/tmp/tmp3666a2g7.d(31): Error: expression expected, not `>`\n/tmp/tmp3666a2g7.d(31): Error: found `x1` when expecting `,`\n/tmp/tmp3666a2g7.d(31): Error: found `0.2` when expecting `,`\n/tmp/tmp3666a2g7.d(34): Error: found `unittest` when expecting `)`\n/tmp/tmp3666a2g7.d(45): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3666a2g7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqsihp6jy.d(19): Error: no property `Length` for type `long[][]`\n/tmp/tmpqsihp6jy.d(20): Error: no property `Length` for type `long[]`\n/tmp/tmpqsihp6jy.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqsihp6jy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long m2 = m;\n    long m3 = m;\n    long m4 = m;\n    long m5 = m;\n    long m6 = m;\n    long m7 = m;\n    long m8 = m;\n    long m9 = m;\n    long m10 = m;\n    long m11 = m;\n    long m12 = m;\n    long m13 = m;\n    long m14 = m;\n    long m15 = m;\n    long m16 = m;\n    long m17 = m;\n    long m18 = m;\n    long m19 = m;\n    long m20 = m;\n    long m21 = m;\n    long m22 = m;\n    long m23 = m;\n    long m24 = m;\n    long m25 = m;\n    long m26 = m;\n    long m27 = m;\n    long m28 = m;\n    long m29 = m;\n    long m30 = m;\n    long m31 = m;\n    long m32 = m;\n    long m33 = m;\n    long m34 = m;\n    long m35 = m;\n    long m36 = m;\n    long m37 = m;\n    long m38 = m;\n    long m39 = m;\n    long m40 = m;\n    long m41 = m;\n    long m42 = m;\n    long m43 = m;\n    long m44 = m;\n    long m45 = m;\n    long m46 = m;\n    long m47 = m;\n    long m48 = m;\n    long m49 = m;\n    long m50 = m;\n    long m51 = m;\n    long m52 = m;\n    long m53 = m;\n    long m54 = m;\n    long m55 = m;\n    long m56 = m;\n    long m57 = m;\n    long m58 = m;\n    long m59 = m;\n    long m60 = m;\n    long m61 = m;\n    long m62 = m;\n    long m63 = m;\n    long m64 = m;\n    long m65 = m;\n    long m66 = m;\n    long m67 = m;\n    long m68 = m;\n    long m69 = m;\n    long m70\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpneu64gfq.d(96): Error: semicolon expected, not `unittest`\n/tmp/tmpneu64gfq.d(96): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpneu64gfq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdm1rjjrs.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpdm1rjjrs.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpdm1rjjrs.d(27): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdm1rjjrs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == 1)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n            {\n                res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n            {\n                res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n            {\n                res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n            {\n                res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n            {\n                res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n            {\n                res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc1hf0b9j.d(158): Error: found `unittest` instead of statement\n/tmp/tmpc1hf0b9j.d(169): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1hf0b9j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                result.push((lst[i][0], lst[i][j]));\n            }\n        }\n    }\n    \n    result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a, b){return b[1] - a[1]});\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxet9k9v1.d(32): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmpxet9k9v1.d(32): Error: found `)` instead of statement\n/tmp/tmpxet9k9v1.d(33): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmpxet9k9v1.d(33): Error: found `)` instead of statement\n/tmp/tmpxet9k9v1.d(37): Error: found `unittest` when expecting `,`\n/tmp/tmpxet9k9v1.d(48): Error: found `void` when expecting `,`\n/tmp/tmpxet9k9v1.d(48): Error: found `{` when expecting `,`\n/tmp/tmpxet9k9v1.d(48): Error: expression expected, not `}`\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `,`\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `)`\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `;` following statement\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `,`\n/tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `)`\n/tm",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[m];\n    for(int i = 0; i < m; i++)\n    {\n        res[i] = 0;\n    }\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[j]++;\n            }\n        }\n    }\n    for(int i = 0; i < m; i++)\n    {\n        res[i] = res[i] / n;\n    }\n    return Tuple!(long, long)[](res, m);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphx9eav0l.d(40): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[](row_index, column_index);\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9tczzy77.d(21): Error: no identifier for declarator `row`\n/tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `;`\n/tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `)`\n/tmp/tmp9tczzy77.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp9tczzy77.d(23): Error: no identifier for declarator `column`\n/tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `;`\n/tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `)`\n/tmp/tmp9tczzy77.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9tczzy77.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long min = 0;\n    long max = 0;\n    long sum = 0;\n    long count = 0;\n    long[][] res = new long[n][m];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            sum += lst[i][j];\n            if(sum == x)\n            {\n                res[i][j] = 1;\n                count++;\n            }\n            else if(sum > x)\n            {\n                min = j;\n                break;\n            }\n            else\n            {\n                max = j;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] == 1)\n            {\n                res[i][j] = count;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n                min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n                max = res[i][j\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppxhr02m4.d(150): Error: found `unittest` when expecting `,`\n/tmp/tmppxhr02m4.d(161): Error: found `void` when expecting `,`\n/tmp/tmppxhr02m4.d(161): Error: found `{` when expecting `,`\n/tmp/tmppxhr02m4.d(161): Error: expression expected, not `}`\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `,`\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `]`\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `;` following statement\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppxhr02m4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                k = j;\n                for(; k < m; k++)\n                {\n                    if(lst[i][k] > x)\n                    {\n                        break;\n                    }\n                }\n                \n                result[i] = Tuple!(long, long)[i, k];\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi7l6w5ru.d(30): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpi7l6w5ru.d(51): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7l6w5ru.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg_0oggst.d(19): Error: no property `Length` for type `long[][]`\n/tmp/tmpg_0oggst.d(20): Error: no property `Length` for type `long[][]`\n/tmp/tmpg_0oggst.d(27): Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg_0oggst.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    for(long i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            ret.push(new Tuple!(lst[i][0], lst[i][1]));\n        }\n    }\n    \n    sort(ret, (x, y) => y._1 - x._1);\n    sort(ret, (x, y) => y._2 - x._2);\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1jsd6l74.d(24): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmp1jsd6l74.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp1jsd6l74.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1jsd6l74.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result.add(new Tuple!(lst[i][1], i));\n        }\n    }\n    \n    result.sort(function(a, b) {\n        return a.1 < b.1;\n    });\n    \n    result.sort(function(a, b) {\n        return b.1 < a.1;\n    });\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgxw7j0m6.d(30): Error: found `0.1` when expecting `;` following `return` statement\n/tmp/tmpgxw7j0m6.d(30): Error: found `<` instead of statement\n/tmp/tmpgxw7j0m6.d(34): Error: found `0.1` when expecting `;` following `return` statement\n/tmp/tmpgxw7j0m6.d(34): Error: found `<` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgxw7j0m6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == 0)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n            {\n                res[i][j] = \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpksxjtfg_.d(148): Error: expression expected, not `unittest`\n/tmp/tmpksxjtfg_.d(149): Error: found `{` when expecting `;` following statement\n/tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpksxjtfg_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n + 1) * (m + 1)];\n    long i = 0, j = 0, k = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[k] = Tuple!(i, j);\n                k++;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    Arrays.sort(res, (a, b) => Tuple!(b[0], a[0]));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmptnq_qt46.d(30): Error: template instance `tmptnq_qt46.get_row.Tuple!(i, j)` error instantiating\n/tmp/tmptnq_qt46.d(36): Error: undefined identifier `Arrays`\n/tmp/tmptnq_qt46.d(38): Error: undefined identifier `A",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => (a.0 < b.0) ? 1 : ((b.0 < a.0) ? -1 : 0));\n    Arrays.sort(result, (a, b) => (a.1 < b.1) ? 1 : ((b.1 < a.1) ? -1 : 0));\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`\n/tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `,`\n/tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`\n/tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`\n/tmp/tmp3tb5a9kh.d(28): Error: found `)` when expecting `;` following statement\n/tmp/tmp3tb5a9kh.d(28): Error: found `?` instead of statement\n/tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`\n/tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `,`\n/tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`\n/tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`\n/tmp/tmp3tb5a9kh.d(29): Error: found `)` when expecting `;` following statement\n/tmp/tmp3tb5a9kh.d(29): Error: found `?` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3tb5a9kh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i : 0..lst.len())\n    {\n        if(lst[i][0] == x)\n        {\n            result = append(result, Tuple!(long, long)[lst[i][1], lst[i][2]]);\n        }\n    }\n    \n    sort(result);\n    sort(result, 1, 2);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu65pit7m.d(21): Error: no identifier for declarator `i`\n/tmp/tmpu65pit7m.d(21): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu65pit7m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpodyznd6l.d(20): Error: no identifier for declarator `lst`\n/tmp/tmpodyznd6l.d(20): Error: found `)` when expecting `;`\n/tmp/tmpodyznd6l.d(22): Error: no identifier for declarator `row`\n/tmp/tmpodyznd6l.d(22): Error: found `)` when expecting `;`\n/tmp/tmpodyznd6l.d(30): Error: found `if` when expecting `)`\n/tmp/tmpodyznd6l.d(31): Error: found `break` when expecting `;` following statement\n/tmp/tmpodyznd6l.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpodyznd6l.d(33): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpodyznd6l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (int)i;\n                    temp[k][1] = (int)j;\n                }\n                \n                Arrays.sort(temp, (a, b) -> {\n                    if(a[0] > b[0])\n                    {\n                        return 1;\n                    }\n                    if(a[0] == b[0])\n                    {\n                        if(a[1] > b[1])\n                        {\n                            return 1;\n                        }\n                        if(a[1] == b[1])\n                        {\n                            return 0;\n                        }\n                    }\n                    return -1;\n                });\n                \n                for(int k = 0; k < m; k++)\n                {\n                    result[i][k] = temp[k][0];\n                    result[j][k] = temp[k][1];\n                }\n            }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) -> {\n        if(a[0] > b[0])\n        {\n            return 1;\n        }\n        if(a[0] == b[0])\n        {\n            if(a[1] > b[1])\n            {\n                return 1;\n            }\n            if(a[1] == b[1])\n            {\n                return 0;\n            }\n        }\n        return -1;\n    });\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                return Tuple!((long)i, (long)j);\n            }\n        }\n    }\n    return Tuple!();\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpf_vhaowb.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpf_vhaowb.d(39): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpf_vhaowb.d(42): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpf_vhaowb.d(43): Error: C style cast illegal, use `cast(int)j`\n/tmp/tmpf_vhaowb.d(46): Error: expression expected, not `>`\n/tmp/tmpf_vhaowb.d(46): Error: found `{` when expecting `,`\n/tmp/tmpf_vhaowb.d(47): Error: expression expected, not `if`\n/tmp/tmpf_vhaowb.d(48): Error: found `{` when expecting `,`\n/tmp/tmpf_vhaowb.d(49): Error: expression expected, not `return`\n/tmp/tmpf_vhaowb.d(49): Error: found `1` when expecting `,`\n/tmp/tmpf_vhaowb.d(49): Error: expression expected, not `;`\n/tmp/tmpf_vhaowb.d(50): Error: found `}` when expecting `,`\n/tmp/tmpf_vhaowb.d(51): Error: expression expected, not `if`\n/tmp/tmpf_vhaowb.d(52): Error: found `{` when expecting `,`\n/tmp/tmpf_vhaowb.d(53): Error: expression expected, not `if`\n/tmp/tmpf_vhaowb",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp7p6are4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            ans = lst[i];\n            break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3kjyhacv.d(25): Error: cannot implicitly convert expression `lst[cast(ulong)i]` of type `long[]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3kjyhacv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a, b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5n8gu1kh.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp5n8gu1kh.d(33): Error: expression expected, not `>`\n/tmp/tmp5n8gu1kh.d(33): Error: found `b` when expecting `,`\n/tmp/tmp5n8gu1kh.d(34): Error: expression expected, not `>`\n/tmp/tmp5n8gu1kh.d(34): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5n8gu1kh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n            break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n            break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqfjxdn16.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmpqfjxdn16.d(43): Error: variable `j` cannot be read at compile time\n/tmp/tmpqfjxdn16.d(43): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqfjxdn16.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                ans += 1;\n                break;\n            }\n        }\n    }\n    \n    Tuple!(long, long)[] ans = new Tuple!(long, long)[ans];\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                ans[ans].0 = i;\n                ans[ans].1 = j;\n                break;\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp58_76ry.d(43): Error: found `0.00000` when expecting `;` following statement\n/tmp/tmpp58_76ry.d(43): Error: found `=` instead of statement\n/tmp/tmpp58_76ry.d(44): Error: found `0.1` when expecting `;` following statement\n/tmp/tmpp58_76ry.d(44): Error: found `=` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp58_76ry.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 2;\n                    k--;\n                }\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 2;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5r59f5fi.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp5r59f5fi.d(146): Error: found `unittest` instead of statement\n/tmp/tmp5r59f5fi.d(157): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5r59f5fi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long, long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysk3pm85.d(25): Error: variable `i` cannot be read at compile time\n/tmp/tmpysk3pm85.d(25): Error: variable `lst` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysk3pm85.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = null;\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n                res = new Tuple!(long, long)[new Tuple!(i, j)]; \n                break;\n            }\n        }\n    }\n    \n    if(res == null) {\n        throw new Exception(\"Invalid coordinate\");\n    }\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] > x) {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k > m) {\n            k = m;\n        }\n        \n        for(; k < m; k++) {\n            res[new Tuple!(i, k)] = new Tuple!(i, k);\n        }\n    }\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] < x) {\n                k = j;\n                break;\n            }\n        }\n        \n        if(k > m) {\n            k = m;\n        }\n        \n        for(; k < m; k++) {\n            res[new Tuple!(i, k)] = new Tuple!(i, k);\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpgjasaxhx.d(27): Error: template instance `tmpgjasaxhx.get_row.Tuple!(i, j)` error instantiating\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/lin",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[(i * m) + j] = (i * m) + j;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[(i * m) + j] != (i * m) + j)\n            {\n                res[(i * m) + j] = (i * m) + j;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) -> b - a);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[(n + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[(i * m) + j] != (i * m) + j)\n            {\n                res[(i * m) + j] = (i * m) + j;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphw00exw3.d(47): Error: expression expected, not `>`\n/tmp/tmphw00exw3.d(47): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphw00exw3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_u6di9uz.d(20): Error: no identifier for declarator `row`\n/tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `;`\n/tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `)`\n/tmp/tmp_u6di9uz.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp_u6di9uz.d(22): Error: no identifier for declarator `col`\n/tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `;`\n/tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `)`\n/tmp/tmp_u6di9uz.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_u6di9uz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1tj2t4h0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res, lst.length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu2blg68w.d(27): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2blg68w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp7p6are4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!<long, long>[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl68f3vwh.d(33): Error: template argument expected following `!`\n/tmp/tmpl68f3vwh.d(33): Error: found `,` when expecting `.` following long\n/tmp/tmpl68f3vwh.d(33): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpl68f3vwh.d(33): Error: found `>` when expecting `;` following `return` statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl68f3vwh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysy2v30e.d(27): Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysy2v30e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[Tuple!((row_index, column_index), Tuple!((row_index, column_index))];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpizcb6x2_.d(21): Error: no identifier for declarator `row`\n/tmp/tmpizcb6x2_.d(21): Error: found `:` when expecting `;`\n/tmp/tmpizcb6x2_.d(21): Error: found `:` when expecting `)`\n/tmp/tmpizcb6x2_.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpizcb6x2_.d(23): Error: no identifier for declarator `column`\n/tmp/tmpizcb6x2_.d(23): Error: found `:` when expecting `;`\n/tmp/tmpizcb6x2_.d(23): Error: found `:` when expecting `)`\n/tmp/tmpizcb6x2_.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpizcb6x2_.d(27): Error: found `]` when expecting `)` following template argument list\n/tmp/tmpizcb6x2_.d(27): Error: found `;` when expecting `,`\n/tmp/tmpizcb6x2_.d(28): Error: expression expected, not `}`\n/tmp/tmpizcb6x2_.d(29): Error: found `}` when expecting `,`\n/tmp/tmpizcb6x2_.d(30): Error: expression expected, not `}`\n/tmp/tmpizcb6x2_.d(32): Error: found `return` when expecting `,`\n/tmp/tmpizcb6x2_.d(32): Error: found `;` when expecting `,`\n/tmp/tmpizcb6x2_.d(33): Error: ",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n            else\n            {\n                res[i][j] = 0;\n            }\n        }\n    }\n    return Tuple!(long, long)[](sort(res), sort(res));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsgeian2r.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmpsgeian2r.d(36): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpsgeian2r.d(36): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsgeian2r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_88sn8_3.d(20): Error: no identifier for declarator `lst`\n/tmp/tmp_88sn8_3.d(20): Error: found `)` when expecting `;`\n/tmp/tmp_88sn8_3.d(22): Error: no identifier for declarator `row`\n/tmp/tmp_88sn8_3.d(22): Error: found `)` when expecting `;`\n/tmp/tmp_88sn8_3.d(30): Error: found `}` when expecting `)`\n/tmp/tmp_88sn8_3.d(33): Error: found `unittest` when expecting `)`\n/tmp/tmp_88sn8_3.d(44): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_88sn8_3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo1f42cnd.d(22): Error: variable `lst` cannot be read at compile time\n/tmp/tmpo1f42cnd.d(22): Error: variable `lst` cannot be read at compile time\n/tmp/tmpo1f42cnd.d(25): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo1f42cnd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i][1]\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpra3dkffo.d(130): Error: found `unittest` when expecting `;` following `for` condition\n/tmp/tmpra3dkffo.d(141): Error: found `void` when expecting `)`\n/tmp/tmpra3dkffo.d(141): Error: found `{` when expecting `;` following statement\n/tmp/tmpra3dkffo.d(141): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpra3dkffo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqsihp6jy.d(19): Error: no property `Length` for type `long[][]`\n/tmp/tmpqsihp6jy.d(20): Error: no property `Length` for type `long[]`\n/tmp/tmpqsihp6jy.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqsihp6jy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_u6di9uz.d(20): Error: no identifier for declarator `row`\n/tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `;`\n/tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `)`\n/tmp/tmp_u6di9uz.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp_u6di9uz.d(22): Error: no identifier for declarator `col`\n/tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `;`\n/tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `)`\n/tmp/tmp_u6di9uz.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_u6di9uz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new long[n][m];\n    long row = 0;\n    long col = 0;\n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n                result[row][col + 1] = j;\n                row++;\n                col = 0;\n            }\n            else\n            {\n                col++;\n            }\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi3mssd_o.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpi3mssd_o.d(19): Error: no property `len` for type `long[][]`\n/tmp/tmpi3mssd_o.d(20): Error: no property `len` for type `long[]`\n/tmp/tmpi3mssd_o.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmpi3mssd_o.d(41): Error: undefined identifier `Arrays`\n/tmp/tmpi3mssd_o.d(42): Error: cannot implicitly convert expression `result` of type `long[][]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi3mssd_o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyxltz6oy.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpyxltz6oy.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpyxltz6oy.d(27): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyxltz6oy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_7dty2p3.d(28): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_7dty2p3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; i++)\n    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; j++)\n        {\n            res[i][j] = new Tuple!(long, long)[i, j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tm1axbb.d(38): Error: found `,` when expecting `]`\n/tmp/tmp_tm1axbb.d(38): Error: found `j` when expecting `;` following statement\n/tmp/tmp_tm1axbb.d(38): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tm1axbb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a, b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5n8gu1kh.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp5n8gu1kh.d(33): Error: expression expected, not `>`\n/tmp/tmp5n8gu1kh.d(33): Error: found `b` when expecting `,`\n/tmp/tmp5n8gu1kh.d(34): Error: expression expected, not `>`\n/tmp/tmp5n8gu1kh.d(34): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5n8gu1kh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                res = append(res, Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg1r06zhb.d(20): Error: no identifier for declarator `i`\n/tmp/tmpg1r06zhb.d(20): Error: found `:` when expecting `;`\n/tmp/tmpg1r06zhb.d(22): Error: no identifier for declarator `j`\n/tmp/tmpg1r06zhb.d(22): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1r06zhb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                break;\n            }\n        }\n        for(j = k; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                result[i][j] = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                result[i][j] = 0;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                result[i][j] = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                result[i][j] = 0;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                result[i][j] = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                result[i][j] = 0;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                result[i][j] = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                result[i][j] = 0;\n                break;\n            }\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1ep3hnfv.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp1ep3hnfv.d(162): Error: found `unittest` instead of statement\n/tmp/tmp1ep3hnfv.d(173): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp1ep3hnfv.d(173): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ep3hnfv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row) \n    {\n        foreach(column: row, column: column) \n        {\n            if(column == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp01jm0614.d(21): Error: no identifier for declarator `row`\n/tmp/tmp01jm0614.d(21): Error: found `:` when expecting `;`\n/tmp/tmp01jm0614.d(21): Error: found `:` when expecting `)`\n/tmp/tmp01jm0614.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp01jm0614.d(23): Error: no identifier for declarator `column`\n/tmp/tmp01jm0614.d(23): Error: found `:` when expecting `;`\n/tmp/tmp01jm0614.d(23): Error: found `:` when expecting `)`\n/tmp/tmp01jm0614.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp01jm0614.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 = m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n    long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n    long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n    long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n    long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n    long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n    long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n    long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n    long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n    long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n    long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n    long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n    long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n    long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n    long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknmqfrj2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8bxbk9or.d(19): Error: no property `lenght` for type `long[][]`\n/tmp/tmp8bxbk9or.d(20): Error: no property `lenght` for type `long[]`\n/tmp/tmp8bxbk9or.d(33): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8bxbk9or.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = 0;\n    long m2 = 0;\n    long m3 = 0;\n    long m4 = 0;\n    long m5 = 0;\n    long m6 = 0;\n    long m7 = 0;\n    long m8 = 0;\n    long m9 = 0;\n    long m10 = 0;\n    long m11 = 0;\n    long m12 = 0;\n    long m13 = 0;\n    long m14 = 0;\n    long m15 = 0;\n    long m16 = 0;\n    long m17 = 0;\n    long m18 = 0;\n    long m19 = 0;\n    long m20 = 0;\n    long m21 = 0;\n    long m22 = 0;\n    long m23 = 0;\n    long m24 = 0;\n    long m25 = 0;\n    long m26 = 0;\n    long m27 = 0;\n    long m28 = 0;\n    long m29 = 0;\n    long m30 = 0;\n    long m31 = 0;\n    long m32 = 0;\n    long m33 = 0;\n    long m34 = 0;\n    long m35 = 0;\n    long m36 = 0;\n    long m37 = 0;\n    long m38 = 0;\n    long m39 = 0;\n    long m40 = 0;\n    long m41 = 0;\n    long m42 = 0;\n    long m43 = 0;\n    long m44 = 0;\n    long m45 = 0;\n    long m46 = 0;\n    long m47 = 0;\n    long m48 = 0;\n    long m49 = 0;\n    long m50 = 0;\n    long m51 = 0;\n    long m52 = 0;\n    long m53 = 0;\n    long m54 = 0;\n    long m55 = 0;\n    long m56 = 0;\n    long m57 = 0;\n    long m58 = 0;\n    long m59 = 0;\n    long m60 = 0;\n    long m61 = 0;\n    long m62 = 0;\n    long m63 = 0;\n    long m64 = 0;\n    long m65 = 0;\n    long m66 = 0;\n    long m67 = 0;\n    long m68 = 0;\n    long m69 = 0;\n    long m70 = 0;\n    long m71 = 0;\n    long m72 = 0;\n    long m73 = 0;\n    long m74 = 0;\n    long m75 = 0;\n    long m76 = 0;\n    long m77 = 0;\n    long m78 = 0;\n    long m79 = 0;\n    long m80 = 0;\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr5wvgi4i.d(106): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr5wvgi4i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 2;\n                    k--;\n                }\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 2;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 2;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n                k = j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n                    k--;\n                }\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx49r583s.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpx49r583s.d(142): Error: found `unittest` instead of statement\n/tmp/tmpx49r583s.d(153): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpx49r583s.d(153): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx49r583s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j] > x)\n                {\n                    row.Add(lst[i][j], j);\n                }\n            }\n            res.Add(row);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2p1rnaqz.d(20): Error: no property `Length` for type `long[][]`\n/tmp/tmp2p1rnaqz.d(25): Error: no property `Length` for type `long[]`\n/tmp/tmp2p1rnaqz.d(29): Error: no property `Add` for type `Tuple!(long, long)[]`\n/tmp/tmp2p1rnaqz.d(32): Error: no property `Add` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2p1rnaqz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                row[j] = (lst[i][0], lst[i][1]);\n            }\n            sort(row);\n            sort(res);\n            res = new Tuple!(long, long)[res.length + 1];\n            res[res.length - 1] = row;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg32ngcvw.d(27): Error: Using the result of a comma expression is not allowed\n/tmp/tmpg32ngcvw.d(27): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(long)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmpg32ngcvw.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpg32ngcvw.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpg32ngcvw.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/ph",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[][] result = new long[lst.length][];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][x] != 0)\n        {\n            result[i] = new long[] {lst[i][x], i};\n        }\n    }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj6rj8kuk.d(24): Error: found `{` when expecting `;` following statement\n/tmp/tmpj6rj8kuk.d(24): Error: found `}` when expecting `;` following statement\n/tmp/tmpj6rj8kuk.d(24): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj6rj8kuk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = j;\n                break;\n            }\n        }\n    }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) -> b - a);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4uwqrofy.d(34): Error: expression expected, not `>`\n/tmp/tmp4uwqrofy.d(34): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4uwqrofy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.Length-1)\n    {\n        if(lst[i][0] == x)\n        {\n            foreach(j : 0..lst[i][1]-1)\n            {\n                res.Add(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_cjsf8qv.d(20): Error: no identifier for declarator `i`\n/tmp/tmp_cjsf8qv.d(20): Error: found `:` when expecting `;`\n/tmp/tmp_cjsf8qv.d(24): Error: no identifier for declarator `j`\n/tmp/tmp_cjsf8qv.d(24): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cjsf8qv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long result[][] = new long[n][m];\n    long j = 0;\n    for(long i = 0; i < n; i++)\n    {\n        for(long k = 0; k < m; k++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = k;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => (a[0] - b[0]) * (a[1] - b[1]));\n    Arrays.sort(result, (a, b) => (b[0] - a[0]) * (b[1] - a[1]));\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0qsmqb73.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmp0qsmqb73.d(19): Error: no property `lenght` for type `long[][]`\n/tmp/tmp0qsmqb73.d(20): Error: no property `lenght` for type `long[]`\n/tmp/tmp0qsmqb73.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmp0qsmqb73.d(35): Error: undefined identifier `Arrays`\n/tmp/tmp0qsmqb73.d(36): Error: undefined identifier `Arrays`\n/tmp/tmp0qsmqb73.d(38): Error: cannot implicitly convert expression `result` of type `long[][]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qsmqb73.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1, row)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8xyrbo4x.d(20): Error: no identifier for declarator `row`\n/tmp/tmp8xyrbo4x.d(20): Error: found `:` when expecting `;`\n/tmp/tmp8xyrbo4x.d(20): Error: found `:` when expecting `)`\n/tmp/tmp8xyrbo4x.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp8xyrbo4x.d(22): Error: no identifier for declarator `col`\n/tmp/tmp8xyrbo4x.d(22): Error: found `:` when expecting `;`\n/tmp/tmp8xyrbo4x.d(22): Error: found `:` when expecting `)`\n/tmp/tmp8xyrbo4x.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8xyrbo4x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.len) \n    {\n        foreach(j : 0..lst[i].len) \n        {\n            if(lst[i][j] == x) \n            {\n                result.add(Tuple!(i, j));\n            }\n        }\n    }\n    \n    result.sort(byRow);\n    result.sort(byCol);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvuojf2g5.d(21): Error: no identifier for declarator `i`\n/tmp/tmpvuojf2g5.d(21): Error: found `:` when expecting `;`\n/tmp/tmpvuojf2g5.d(23): Error: no identifier for declarator `j`\n/tmp/tmpvuojf2g5.d(23): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvuojf2g5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(long k = 0; k < m; k++)\n                {\n                    temp[k][0] = (int)i;\n                    temp[k][1] = (int)j;\n                }\n                \n                sort(temp, (a, b) => b[0] - a[0]);\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                }\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                }\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                }\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                }\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                }\n                \n                for(long k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n                    {\n                        swap(temp[k], temp[k - 1]);\n                    }\n                    if(temp[k][1] > j)\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpidw0mx_6.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpidw0mx_6.d(40): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpidw0mx_6.d(43): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpidw0mx_6.d(44): Error: C style cast illegal, use `cast(int)j`\n/tmp/tmpidw0mx_6.d(116): Error: found `unittest` instead of statement\n/tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpidw0mx_6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzjelr_oq.d(33): Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjelr_oq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n        if(y == x)\n        {\n            return Tuple!(long, long[])[](rows, cols);\n        }\n        \n        foreach(long x, lst)\n        {\n            if(y == x)\n            {\n                cols++;\n            }\n        }\n        rows++;\n        cols = 0;\n    }\n    \n    return Tuple!(long, long[])[](rows, cols);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbf7fkqej.d(22): Error: no identifier for declarator `lst`\n/tmp/tmpbf7fkqej.d(22): Error: found `)` when expecting `;`\n/tmp/tmpbf7fkqej.d(29): Error: no identifier for declarator `lst`\n/tmp/tmpbf7fkqej.d(29): Error: found `)` when expecting `;`\n/tmp/tmpbf7fkqej.d(36): Error: found `rows` when expecting `)`\n/tmp/tmpbf7fkqej.d(36): Error: expression expected, not `;`\n/tmp/tmpbf7fkqej.d(37): Error: found `cols` when expecting `;` following statement\n/tmp/tmpbf7fkqej.d(37): Error: found `=` instead of statement\n/tmp/tmpbf7fkqej.d(40): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbf7fkqej.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n            break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n            break;\n        }\n    }\n    Tuple!(long, long)[] result = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        result[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n            result[i][j] = new Tuple!(long, long)(i, j);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiu9undrz.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmpiu9undrz.d(43): Error: variable `j` cannot be read at compile time\n/tmp/tmpiu9undrz.d(43): Error: cannot implicitly convert expression `new Tuple!(long, long)(i, j)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu9undrz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row: lst, row: row) \n    {\n        foreach(column: row, column: column) \n        {\n            if(column == x) \n            {\n                result.push((row, column));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv_johnz8.d(21): Error: no identifier for declarator `row`\n/tmp/tmpv_johnz8.d(21): Error: found `:` when expecting `;`\n/tmp/tmpv_johnz8.d(21): Error: found `:` when expecting `)`\n/tmp/tmpv_johnz8.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpv_johnz8.d(23): Error: no identifier for declarator `column`\n/tmp/tmpv_johnz8.d(23): Error: found `:` when expecting `;`\n/tmp/tmpv_johnz8.d(23): Error: found `:` when expecting `)`\n/tmp/tmpv_johnz8.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpv_johnz8.d(32): Error: missing `{ ... }` for function literal\n/tmp/tmpv_johnz8.d(32): Error: expression expected, not `>`\n/tmp/tmpv_johnz8.d(32): Error: found `a` when expecting `,`\n/tmp/tmpv_johnz8.d(33): Error: missing `{ ... }` for function literal\n/tmp/tmpv_johnz8.d(33): Error: expression expected, not `>`\n/tmp/tmpv_johnz8.d(33): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_johnz8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe1unr_of.d(151): Error: basic type expected, not `unittest`\n/tmp/tmpe1unr_of.d(151): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe1unr_of.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    foreach(long y, lst)\n    {\n        foreach(long x, y)\n        {\n            if(x != x)\n            {\n                cols++;\n            }\n            else\n            {\n                rows++;\n            }\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    foreach(long y, lst)\n    {\n        foreach(long x, y)\n        {\n            if(x != x)\n            {\n                res[rows] = new Tuple!(long, long)(x, y);\n                rows++;\n            }\n            else\n            {\n                res[rows] = new Tuple!(long, long)(x, y);\n                cols--;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1yx_9eo_.d(21): Error: no identifier for declarator `lst`\n/tmp/tmp1yx_9eo_.d(21): Error: found `)` when expecting `;`\n/tmp/tmp1yx_9eo_.d(23): Error: no identifier for declarator `y`\n/tmp/tmp1yx_9eo_.d(23): Error: found `)` when expecting `;`\n/tmp/tmp1yx_9eo_.d(34): Error: found `}` when expecting `)`\n/tmp/tmp1yx_9eo_.d(36): Error: no identifier for declarator `lst`\n/tmp/tmp1yx_9eo_.d(36): Error: found `)` when expecting `;`\n/tmp/tmp1yx_9eo_.d(38): Error: no identifier for declarator `y`\n/tmp/tmp1yx_9eo_.d(38): Error: found `)` when expecting `;`\n/tmp/tmp1yx_9eo_.d(51): Error: found `}` when expecting `)`\n/tmp/tmp1yx_9eo_.d(54): Error: found `unittest` when expecting `)`\n/tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `)`\n/tmp/tmp1yx_9eo_.d(65): Error: found `End of File` instead of statement\n/tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `}` following compound stateme",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] > lst[i][0])\n            {\n                Tuple!(long, long)[] temp = new Tuple!(long, long)[lst[i].length];\n                for(int k = 0; k < lst[i].length; k++)\n                {\n                    temp[k] = new Tuple!(lst[i][j], k);\n                }\n                Arrays.sort(temp, (x, y) => y._1 > x._1);\n                for(int k = 0; k < temp.length; k++)\n                {\n                    result[i] = result[i].__append(temp[k]);\n                }\n            }\n        }\n    }\n    \n    Arrays.sort(result, (x, y) => y._1 > x._1);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt66vs_zw.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpt66vs_zw.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpt66vs_zw.d(37): Error: variable `lst` cannot be read at compile time\n/tmp/tmpt66vs_zw.d(39): Error: undefined identifier `Arrays`\n/tmp/tmpt66vs_zw.d(42): Error: no property `__append` for type `Tuple!(long, long)`\n/tmp/tmpt66vs_zw.d(48): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt66vs_zw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n    long x1;\n    long x2;\n    long y1;\n    long y2;\n    long z = 0;\n    long z1 = 0;\n    long z2 = 0;\n    long z3 = 0;\n    long z4 = 0;\n    long z5 = 0;\n    long z6 = 0;\n    long z7 = 0;\n    long z8 = 0;\n    long z9 = 0;\n    long z10 = 0;\n    long z11 = 0;\n    long z12 = 0;\n    long z13 = 0;\n    long z14 = 0;\n    long z15 = 0;\n    long z16 = 0;\n    long z17 = 0;\n    long z18 = 0;\n    long z19 = 0;\n    long z20 = 0;\n    long z21 = 0;\n    long z22 = 0;\n    long z23 = 0;\n    long z24 = 0;\n    long z25 = 0;\n    long z26 = 0;\n    long z27 = 0;\n    long z28 = 0;\n    long z29 = 0;\n    long z30 = 0;\n    long z31 = 0;\n    long z32 = 0;\n    long z33 = 0;\n    long z34 = 0;\n    long z35 = 0;\n    long z36 = 0;\n    long z37 = 0;\n    long z38 = 0;\n    long z39 = 0;\n    long z40 = 0;\n    long z41 = 0;\n    long z42 = 0;\n    long z43 = 0;\n    long z44 = 0;\n    long z45 = 0;\n    long z46 = 0;\n    long z47 = 0;\n    long z48 = 0;\n    long z49 = 0;\n    long z50 = 0;\n    long z51 = 0;\n    long z52 = 0;\n    long z53 = 0;\n    long z54 = 0;\n    long z55 = 0;\n    long z56 = 0;\n    long z57 = 0;\n    long z58 = 0;\n    long z59 = 0;\n    long z60 = 0;\n    long z61 = 0;\n    long z62 = 0;\n    long z63 = 0;\n    long z64 = 0;\n    long z65 = 0;\n    long z66 = 0;\n    long z67 = 0;\n    long z68 = 0;\n    long z69 = 0;\n    long z70 = 0;\n    long z71 = 0;\n    long z72 = 0;\n    long z73 = 0;\n    long z74 = 0;\n    long \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp49qvwai9.d(107): Error: no identifier for declarator `long`\n/tmp/tmp49qvwai9.d(107): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp49qvwai9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] > x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                ret = new Tuple!(long, long)[ret.length + 1];\n                ret[ret.length] = Tuple!(row, col);\n            }\n        }\n    }\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprdv2dusx.d(20): Error: no identifier for declarator `lst`\n/tmp/tmprdv2dusx.d(20): Error: found `)` when expecting `;`\n/tmp/tmprdv2dusx.d(22): Error: no identifier for declarator `row`\n/tmp/tmprdv2dusx.d(22): Error: found `)` when expecting `;`\n/tmp/tmprdv2dusx.d(30): Error: found `}` when expecting `)`\n/tmp/tmprdv2dusx.d(34): Error: found `unittest` when expecting `)`\n/tmp/tmprdv2dusx.d(45): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprdv2dusx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                for(int k = j; k < lst[i].length; k++)\n                {\n                    lst[i][k] = lst[i][k - 1];\n                }\n                lst[i][0] = x;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] < x)\n            {\n                for(int k = j; k < lst[i].length; k++)\n                {\n                    lst[i][k] = lst[i][k + 1];\n                }\n                lst[i][1] = x;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                for(int k = j; k < lst[i].length; k++)\n                {\n                    lst[i][k] = lst[i][k - 1];\n                }\n                lst[i][0] = x;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] < x)\n            {\n                for(int k = j; k < lst[i].length; k++)\n                {\n                    lst[i][k] = lst[i][k + 1];\n                }\n                lst[i][1] = x;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxqpg1lto.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpxqpg1lto.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpxqpg1lto.d(66): Error: variable `lst` cannot be read at compile time\n/tmp/tmpxqpg1lto.d(66): Error: variable `lst` cannot be read at compile time\n/tmp/tmpxqpg1lto.d(109): Error: variable `lst` cannot be read at compile time\n/tmp/tmpxqpg1lto.d(109): Error: variable `lst` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxqpg1lto.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n            break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n            break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9sdgp209.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmp9sdgp209.d(43): Error: variable `j` cannot be read at compile time\n/tmp/tmp9sdgp209.d(43): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9sdgp209.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result, (x, y) => y._1 - x._1);\n    Arrays.sort(result, (x, y) => y._2 - x._2);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1zsoesss.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp1zsoesss.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp1zsoesss.d(27): Error: undefined identifier `Arrays`\n/tmp/tmp1zsoesss.d(28): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1zsoesss.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row: lst, i: 0) {\n        foreach(col: row, j: 0) {\n            if(col == x) {\n                ret.add((i, j));\n            }\n        }\n    }\n    sort(ret);\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgf3e9_fm.d(20): Error: no identifier for declarator `row`\n/tmp/tmpgf3e9_fm.d(20): Error: found `:` when expecting `;`\n/tmp/tmpgf3e9_fm.d(20): Error: found `:` when expecting `)`\n/tmp/tmpgf3e9_fm.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpgf3e9_fm.d(21): Error: no identifier for declarator `col`\n/tmp/tmpgf3e9_fm.d(21): Error: found `:` when expecting `;`\n/tmp/tmpgf3e9_fm.d(21): Error: found `:` when expecting `)`\n/tmp/tmpgf3e9_fm.d(21): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgf3e9_fm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                for(k = 0; k < m; k++)\n                {\n                    result[i][k] = j;\n                }\n            }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => (a[0] > b[0]) ? 1 : ((b[0] > a[0]) ? -1 : 0));\n    Arrays.sort(result, (a, b) => (a[1] > b[1]) ? 1 : ((b[1] > a[1]) ? -1 : 0));\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpf4lku6fq.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpf4lku6fq.d(19): Error: no property `len` for type `long[][]`\n/tmp/tmpf4lku6fq.d(20): Error: no property `len` for type `long[]`\n/tmp/tmpf4lku6fq.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmpf4lku6fq.d(37): Error: undefined identifier `Arrays`\n/tmp/tmpf4lku6fq.d(38): Error: undefined identifier `Arrays`\n/tmp/tmpf4lku6fq.d(40): Error: cannot implicitly convert expression `result` of type `long[][]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf4lku6fq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length; i++)\n    {\n        res[i] = lst[0][i];\n    }\n    for(int i = 1; i < lst.Length; i++)\n    {\n        for(int j = 0; j < lst[i].Length; j++)\n        {\n            if(res[j] == x)\n            {\n                Tuple!(long, long)[] ret = new Tuple!(long, long)[lst[i].Length];\n                for(int k = 0; k < lst[i].Length; k++)\n                {\n                    ret[k] = Tuple!(long, long)[i, k];\n                }\n                return ret;\n            }\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpea99ak_n.d(19): Error: no property `Length` for type `long[]`\n/tmp/tmpea99ak_n.d(20): Error: no property `Length` for type `long[]`\n/tmp/tmpea99ak_n.d(24): Error: no property `Length` for type `long[][]`\n/tmp/tmpea99ak_n.d(26): Error: no property `Length` for type `long[]`\n/tmp/tmpea99ak_n.d(30): Error: no property `Length` for type `long[]`\n/tmp/tmpea99ak_n.d(31): Error: no property `Length` for type `long[]`\n/tmp/tmpea99ak_n.d(33): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpea99ak_n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n                break;\n            }\n        }\n    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) -> {\n        if(a[0] == b[0])\n            return a[1] - b[1];\n        return a[0] - b[0];\n    });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp20x2pk8h.d(34): Error: expression expected, not `>`\n/tmp/tmp20x2pk8h.d(34): Error: found `{` when expecting `,`\n/tmp/tmp20x2pk8h.d(35): Error: expression expected, not `if`\n/tmp/tmp20x2pk8h.d(36): Error: found `return` when expecting `,`\n/tmp/tmp20x2pk8h.d(36): Error: found `;` when expecting `,`\n/tmp/tmp20x2pk8h.d(37): Error: expression expected, not `return`\n/tmp/tmp20x2pk8h.d(37): Error: found `a` when expecting `,`\n/tmp/tmp20x2pk8h.d(37): Error: found `;` when expecting `,`\n/tmp/tmp20x2pk8h.d(38): Error: expression expected, not `}`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp20x2pk8h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 = m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n    long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n    long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n    long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n    long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n    long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n    long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n    long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n    long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n    long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n    long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n    long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n    long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n    long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n    long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknmqfrj2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col == x) \n            {\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxcnij5ig.d(20): Error: no identifier for declarator `row`\n/tmp/tmpxcnij5ig.d(20): Error: found `:` when expecting `;`\n/tmp/tmpxcnij5ig.d(20): Error: found `:` when expecting `)`\n/tmp/tmpxcnij5ig.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpxcnij5ig.d(22): Error: no identifier for declarator `col`\n/tmp/tmpxcnij5ig.d(22): Error: found `:` when expecting `;`\n/tmp/tmpxcnij5ig.d(22): Error: found `:` when expecting `)`\n/tmp/tmpxcnij5ig.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxcnij5ig.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_88sn8_3.d(20): Error: no identifier for declarator `lst`\n/tmp/tmp_88sn8_3.d(20): Error: found `)` when expecting `;`\n/tmp/tmp_88sn8_3.d(22): Error: no identifier for declarator `row`\n/tmp/tmp_88sn8_3.d(22): Error: found `)` when expecting `;`\n/tmp/tmp_88sn8_3.d(30): Error: found `}` when expecting `)`\n/tmp/tmp_88sn8_3.d(33): Error: found `unittest` when expecting `)`\n/tmp/tmp_88sn8_3.d(44): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_88sn8_3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] + 1);\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgt98d77h.d(25): Error: variable `lst` cannot be read at compile time\n/tmp/tmpgt98d77h.d(25): Error: variable `lst` cannot be read at compile time\n/tmp/tmpgt98d77h.d(33): Error: variable `lst` cannot be read at compile time\n/tmp/tmpgt98d77h.d(33): Error: variable `lst` cannot be read at compile time\n/tmp/tmpgt98d77h.d(41): Error: variable `lst` cannot be read at compile time\n/tmp/tmpgt98d77h.d(41): Error: variable `lst` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgt98d77h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                foreach(coor: row, coor_index: 0) \n                {\n                    if(coor_index == row_index) \n                    {\n                        result.push(Tuple!(long, long)((row_index, column_index)));\n                    }\n                }\n            }\n        }\n    }\n    \n    sort(result, (a, b) => a.1 < b.1);\n    sort(result, (a, b) => a.2 < b.2);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwgjce671.d(21): Error: no identifier for declarator `row`\n/tmp/tmpwgjce671.d(21): Error: found `:` when expecting `;`\n/tmp/tmpwgjce671.d(21): Error: found `:` when expecting `)`\n/tmp/tmpwgjce671.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmpwgjce671.d(23): Error: no identifier for declarator `column`\n/tmp/tmpwgjce671.d(23): Error: found `:` when expecting `;`\n/tmp/tmpwgjce671.d(23): Error: found `:` when expecting `)`\n/tmp/tmpwgjce671.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmpwgjce671.d(27): Error: no identifier for declarator `coor`\n/tmp/tmpwgjce671.d(27): Error: found `:` when expecting `;`\n/tmp/tmpwgjce671.d(27): Error: found `:` when expecting `)`\n/tmp/tmpwgjce671.d(27): Error: found `)` when expecting `;` following statement\n/tmp/tmpwgjce671.d(38): Error: found `0.1` when expecting `,`\n/tmp/tmpwgjce671.d(38): Error: expression expected, not `<`\n/tmp/tmpwgjce671.d(38): Error: found `b` when expecting `,`\n/tmp/tmpwgjce671.d(39): Error: found `0.",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res, (a, b) -> {\n        if(a[0] == b[0])\n        {\n            return a[1] - b[1];\n        }\n        return a[0] - b[0];\n    });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa88hs_5m.d(32): Error: expression expected, not `>`\n/tmp/tmpa88hs_5m.d(32): Error: found `{` when expecting `,`\n/tmp/tmpa88hs_5m.d(33): Error: expression expected, not `if`\n/tmp/tmpa88hs_5m.d(34): Error: found `{` when expecting `,`\n/tmp/tmpa88hs_5m.d(35): Error: expression expected, not `return`\n/tmp/tmpa88hs_5m.d(35): Error: found `a` when expecting `,`\n/tmp/tmpa88hs_5m.d(35): Error: found `;` when expecting `,`\n/tmp/tmpa88hs_5m.d(36): Error: expression expected, not `}`\n/tmp/tmpa88hs_5m.d(37): Error: found `return` when expecting `,`\n/tmp/tmpa88hs_5m.d(37): Error: found `;` when expecting `,`\n/tmp/tmpa88hs_5m.d(38): Error: expression expected, not `}`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa88hs_5m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n            break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n            break;\n        }\n    }\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        ret[i] = new Tuple!(long, long)[cols];\n    }\n    for(long i = 0; i < rows; ++i)\n    {\n        for(long j = 0; j < cols; ++j)\n        {\n            ret[i][j] = new Tuple!(long, long)();\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(long j = 0; j < cols; ++j)\n            {\n                ret[i][j] = new Tuple!(long, long)();\n            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3iny8diq.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmp3iny8diq.d(46): Error: variable `j` cannot be read at compile time\n/tmp/tmp3iny8diq.d(46): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\n/tmp/tmp3iny8diq.d(55): Error: variable `j` cannot be read at compile time\n/tmp/tmp3iny8diq.d(55): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3iny8diq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                for(int k = j + 1; k < m; k++)\n                {\n                    if(lst[i][k] > lst[i][j])\n                    {\n                        result[i][j] = lst[i][k\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi8x4llsn.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpi8x4llsn.d(141): Error: found `unittest` when expecting `,`\n/tmp/tmpi8x4llsn.d(152): Error: found `void` when expecting `,`\n/tmp/tmpi8x4llsn.d(152): Error: found `{` when expecting `,`\n/tmp/tmpi8x4llsn.d(152): Error: expression expected, not `}`\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `,`\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `]`\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `;` following statement\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi8x4llsn.d(152): Error: foun",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(m * n) + 1];\n    long i = 0, j = 0;\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n                res[i * m + j] = i;\n                res[i * m + j + 1] = j;\n            }\n        }\n    }\n    sort(res, 0, res.length);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9liflart.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp9liflart.d(32): Error: cannot implicitly convert expression `res` of type `long[]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9liflart.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8qrabkf6.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp8qrabkf6.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp8qrabkf6.d(27): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8qrabkf6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                result = Tuple!(long, long)[Tuple!(row_index, column_index)];\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph7lij41n.d(21): Error: no identifier for declarator `row`\n/tmp/tmph7lij41n.d(21): Error: found `:` when expecting `;`\n/tmp/tmph7lij41n.d(21): Error: found `:` when expecting `)`\n/tmp/tmph7lij41n.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmph7lij41n.d(23): Error: no identifier for declarator `column`\n/tmp/tmph7lij41n.d(23): Error: found `:` when expecting `;`\n/tmp/tmph7lij41n.d(23): Error: found `:` when expecting `)`\n/tmp/tmph7lij41n.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7lij41n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[](Tuple!(i + 1, j), Tuple!(i + 1, j + 1));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg43jno6d.d(20): Error: no identifier for declarator `i`\n/tmp/tmpg43jno6d.d(20): Error: found `:` when expecting `;`\n/tmp/tmpg43jno6d.d(22): Error: no identifier for declarator `j`\n/tmp/tmpg43jno6d.d(22): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg43jno6d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long j = 0; j < lst[i][1]; ++j)\n            {\n                row.push(new Tuple!(long, long)[lst[i][j]]);\n            }\n            res.push(row);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpypd73_66.d(27): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmpypd73_66.d(29): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpypd73_66.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1tj2t4h0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp24aowfi4.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp24aowfi4.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp24aowfi4.d(27): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp24aowfi4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    \n    for(int i = 0; i < lst.length; i++) \n    {\n        if(lst[i][0] == x) \n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n            for(int j = 0; j < lst[i].length; j++) \n            {\n                row[j] = (lst[i][j], j);\n            }\n            \n            Arrays.sort(row);\n            \n            for(int j = 0; j < row.length; j++) \n            {\n                res[res.length] = row[j];\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp60sak343.d(28): Error: Using the result of a comma expression is not allowed\n/tmp/tmp60sak343.d(28): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(int)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmp60sak343.d(31): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp60sak343.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] result = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        result[i] = lst[i][0];\n    }\n    Array.Sort(result);\n    Array.Sort(result, (x, y) => { return y - x; });\n    Array.Sort(result, (x, y) => { return x - y; });\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(result[i] == x)\n        {\n            return Tuple!(long[], long[])[](Tuple!(long[], long[])[](Tuple!(0, i), Tuple!(0, i + 1)), Tuple!(0, i + 1));\n        }\n    }\n    return Tuple!(long[], long[])[](Tuple!(0, 0), Tuple!(0, 0));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz6_p_xhp.d(19): Error: no property `Length` for type `long[][]`\n/tmp/tmpz6_p_xhp.d(20): Error: no property `Length` for type `long[][]`\n/tmp/tmpz6_p_xhp.d(24): Error: undefined identifier `Array`\n/tmp/tmpz6_p_xhp.d(25): Error: undefined identifier `Array`\n/tmp/tmpz6_p_xhp.d(26): Error: undefined identifier `Array`\n/tmp/tmpz6_p_xhp.d(27): Error: no property `Length` for type `long[][]`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(0, i)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpz6_p_xhp.d(31): Error: template instance `tmpz6_p_xhp.get_row.Tuple!(0, i)` error instantiating\n/tmp/t",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] < x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] < x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] < x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n                }\n            }\n        }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3fi5tcli.d(131): Error: found `unittest` instead of statement\n/tmp/tmp3fi5tcli.d(142): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3fi5tcli.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n                }\n                sort(temp, false);\n                for(int k = 0; k < m; k++)\n                {\n                    result[i][k] = temp[k][0] * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n                }\n                sort(temp, true);\n                for(int k = 0; k < m; k++)\n                {\n                    result[i][j] = temp[k][0] * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n                }\n                sort(temp, true);\n                for(int k = 0; k < m; k++)\n                {\n                    result[i][j] = temp[k][0] * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n                long temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n                }\n                sort(temp, true);\n                for(int k = 0; k < m; k++)\n                {\n                    result[i][j] = temp[k][0] * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdhq0kxwb.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpdhq0kxwb.d(39): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpdhq0kxwb.d(42): Error: C style cast illegal, use `cast(long)i`\n/tmp/tmpdhq0kxwb.d(43): Error: C style cast illegal, use `cast(long)j`\n/tmp/tmpdhq0kxwb.d(60): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpdhq0kxwb.d(63): Error: C style cast illegal, use `cast(long)i`\n/tmp/tmpdhq0kxwb.d(64): Error: C style cast illegal, use `cast(long)j`\n/tmp/tmpdhq0kxwb.d(81): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpdhq0kxwb.d(84): Error: C style cast illegal, use `cast(long)i`\n/tmp/tmpdhq0kxwb.d(85): Error: C style cast illegal, use `cast(long)j`\n/tmp/tmpdhq0kxwb.d(102): Deprecation: instead of C-style syntax, use D-style syntax `long[][] temp`\n/tmp/tmpdhq0kxwb.d(105): Error: C style cast illegal, use `cast(long)i`\n/tmp/tmpdhq0kxwb.d(106): Err",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                if(lst[i][j] == x)\n                {\n                    result.add(new Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n    result.sort(function(a, b){return b._1 - a._1});\n    result.sort(function(a, b){return a._2 - b._2});\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9de27ydd.d(35): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmp9de27ydd.d(35): Error: found `)` instead of statement\n/tmp/tmp9de27ydd.d(36): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmp9de27ydd.d(36): Error: found `)` instead of statement\n/tmp/tmp9de27ydd.d(40): Error: found `unittest` when expecting `,`\n/tmp/tmp9de27ydd.d(51): Error: found `void` when expecting `,`\n/tmp/tmp9de27ydd.d(51): Error: found `{` when expecting `,`\n/tmp/tmp9de27ydd.d(51): Error: expression expected, not `}`\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `,`\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `)`\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `,`\n/tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `)`\n/tm",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, m);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjxw1jtjj.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmpjxw1jtjj.d(32): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjxw1jtjj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkiamusgm.d(29): Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkiamusgm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv2525zfy.d(19): Error: no property `lenght` for type `long[][]`\n/tmp/tmpv2525zfy.d(20): Error: no property `lenght` for type `long[]`\n/tmp/tmpv2525zfy.d(29): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpv2525zfy.d(40): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2525zfy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                ans = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp02v615r5.d(21): Error: no identifier for declarator `i`\n/tmp/tmp02v615r5.d(21): Error: found `:` when expecting `;`\n/tmp/tmp02v615r5.d(23): Error: no identifier for declarator `j`\n/tmp/tmp02v615r5.d(23): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02v615r5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new long[n][m];\n    long i, j;\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n            {\n                result[i][j] = 1;\n                break;\n            }\n        }\n    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[result.len()];\n    \n    for (i = 0; i < result.len(); i++)\n    {\n        res[i] = new Tuple!(long, long)[result[i].len()];\n        for (j = 0; j < result[i].len(); j++)\n        {\n            res[i][j] = new Tuple!(long, long)(0, 0);\n        }\n    }\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n        {\n            if (result[i][j] == 1)\n            {\n                res[i][j] = new Tuple!(long, long)(i, j);\n            }\n        }\n    }\n    \n    sort!(res, (a, b) => (a.1, b.1), (a, b) => (a.2, b.2), (a, b) => (a.3, b.3));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwxq10u4v.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpwxq10u4v.d(58): Error: found `0.1` when expecting `)`\n/tmp/tmpwxq10u4v.d(58): Error: found `0.1` when expecting `)` following template argument list\n/tmp/tmpwxq10u4v.d(58): Error: found `)` when expecting `;` following statement\n/tmp/tmpwxq10u4v.d(58): Error: found `,` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwxq10u4v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n                break;\n            }\n        }\n        if(res != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpap6ooctk.d(20): Error: no identifier for declarator `row`\n/tmp/tmpap6ooctk.d(20): Error: found `:` when expecting `;`\n/tmp/tmpap6ooctk.d(20): Error: found `:` when expecting `)`\n/tmp/tmpap6ooctk.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpap6ooctk.d(22): Error: no identifier for declarator `col`\n/tmp/tmpap6ooctk.d(22): Error: found `:` when expecting `;`\n/tmp/tmpap6ooctk.d(22): Error: found `:` when expecting `)`\n/tmp/tmpap6ooctk.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpap6ooctk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length; i++) \n    {\n        for(int j = 0; j < lst[i].length; j++) \n        {\n            if(lst[i][j] == x) \n            {\n                res[i] = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res, res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz3qfg5o3.d(31): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz3qfg5o3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            if(lst[i][0] == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n                if(lst[i][0] == k)\n                {\n                    result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n                for(int l = 0; l < lst[i][1]; l++)\n                {\n                    if(lst[i][0] == l)\n                    {\n                        result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n                for(int l = 0; l < lst[i][1]; l++)\n                {\n                    for(int m = 0; m < lst[i][1]; m++)\n                    {\n                        if(lst[i][0] == m)\n                        {\n                            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n                for(int l = 0; l < lst[i][1]; l++)\n                {\n                    for(int m = 0; m < lst[i][1]; m++)\n                    {\n                        for(int n = 0; n < lst[i][1]; n++)\n                        {\n                            if(lst[i][0] == n)\n                            {\n                                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n                for(int l = 0; l < lst[i][1]; l\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg9uhwjm4.d(120): Error: found `unittest` when expecting `)`\n/tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg9uhwjm4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[(i * m) + j] = i;\n                res[(i * m) + j + 1] = j;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[(res.length / 2) * (res.length / 2)];\n    \n    for(int i = 0; i < res.length / 2; i++)\n    {\n        for(int j = 0; j < res.length / 2; j++)\n        {\n            res[(i * res.length / 2) + j] = new Tuple!(long, long)((res[i + j * res.length / 2]), res[i + j * res.length / 2 + 1]);\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5dpomze_.d(35): Error: undefined identifier `Arrays`\n/tmp/tmp5dpomze_.d(37): Error: declaration `tmp5dpomze_.get_row.res` is already defined\n/tmp/tmp5dpomze_.d(43): Error: cannot implicitly convert expression `new Tuple!(long, long)(res[cast(ulong)i + cast(ulong)j * res.length / 2LU], res[cast(ulong)i + cast(ulong)j * res.length / 2LU + 1LU])` of type `Tuple!(long, long)*` to `long`\n/tmp/tmp5dpomze_.d(47): Error: cannot implicitly convert expression `res` of type `long[]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5dpomze_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col == x) \n            {\n                Tuple!(long, long)[] rowRes = new Tuple!(long, long)[row.Length];\n                foreach(colRes: row, k: 0) \n                {\n                    rowRes[k] = Tuple!(long, long)[i, k];\n                }\n                res = append(res, rowRes);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl_evnzr9.d(20): Error: no identifier for declarator `row`\n/tmp/tmpl_evnzr9.d(20): Error: found `:` when expecting `;`\n/tmp/tmpl_evnzr9.d(20): Error: found `:` when expecting `)`\n/tmp/tmpl_evnzr9.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmpl_evnzr9.d(22): Error: no identifier for declarator `col`\n/tmp/tmpl_evnzr9.d(22): Error: found `:` when expecting `;`\n/tmp/tmpl_evnzr9.d(22): Error: found `:` when expecting `)`\n/tmp/tmpl_evnzr9.d(22): Error: found `)` when expecting `;` following statement\n/tmp/tmpl_evnzr9.d(27): Error: no identifier for declarator `colRes`\n/tmp/tmpl_evnzr9.d(27): Error: found `:` when expecting `;`\n/tmp/tmpl_evnzr9.d(27): Error: found `:` when expecting `)`\n/tmp/tmpl_evnzr9.d(27): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl_evnzr9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row_index, col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`\n/tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`\n/tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1tj2t4h0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprw5vp7ay.d(33): Error: expression expected, not `>`\n/tmp/tmprw5vp7ay.d(33): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprw5vp7ay.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] < x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfbxiahxe.d(30): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpfbxiahxe.d(42): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpfbxiahxe.d(54): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbxiahxe.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9hcd_co0.d(22): Error: variable `lst` cannot be read at compile time\n/tmp/tmp9hcd_co0.d(22): Error: variable `lst` cannot be read at compile time\n/tmp/tmp9hcd_co0.d(25): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9hcd_co0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2j6nu0_0.d(20): Error: no identifier for declarator `lst`\n/tmp/tmp2j6nu0_0.d(20): Error: found `)` when expecting `;`\n/tmp/tmp2j6nu0_0.d(22): Error: no identifier for declarator `row`\n/tmp/tmp2j6nu0_0.d(22): Error: found `)` when expecting `;`\n/tmp/tmp2j6nu0_0.d(30): Error: found `if` when expecting `)`\n/tmp/tmp2j6nu0_0.d(31): Error: found `break` when expecting `;` following statement\n/tmp/tmp2j6nu0_0.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp2j6nu0_0.d(33): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2j6nu0_0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => a.first > b.first);\n    Arrays.sort(result, (a, b) => a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpryfj50v9.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpryfj50v9.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmpryfj50v9.d(28): Error: undefined identifier `Arrays`\n/tmp/tmpryfj50v9.d(29): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpryfj50v9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long, long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysk3pm85.d(25): Error: variable `i` cannot be read at compile time\n/tmp/tmpysk3pm85.d(25): Error: variable `lst` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysk3pm85.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) => b[0] - a[0]);\n    \n    for(int i = 0; i < n; i++)\n    {\n        Arrays.sort(res[i], (a, b) => b[1] - a[1]);\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1oywx7d5.d(21): Error: variable `n` cannot be read at compile time\n/tmp/tmp1oywx7d5.d(33): Error: undefined identifier `Arrays`\n/tmp/tmp1oywx7d5.d(34): Error: undefined identifier `Arrays`\n/tmp/tmp1oywx7d5.d(38): Error: undefined identifier `Arrays`\n/tmp/tmp1oywx7d5.d(41): Error: cannot implicitly convert expression `res` of type `long[][]` to `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1oywx7d5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col == x) \n            {\n                ret[ret.length] = Tuple!(row_index, col_index);\n            }\n        }\n    }\n    \n    sort(ret, (x, y) => Tuple!(x._1, y._1));\n    sort(ret, (x, y) => Tuple!(y._1, x._1));\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2_7k55md.d(21): Error: no identifier for declarator `row`\n/tmp/tmp2_7k55md.d(21): Error: found `:` when expecting `;`\n/tmp/tmp2_7k55md.d(21): Error: found `:` when expecting `)`\n/tmp/tmp2_7k55md.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp2_7k55md.d(23): Error: no identifier for declarator `col`\n/tmp/tmp2_7k55md.d(23): Error: found `:` when expecting `;`\n/tmp/tmp2_7k55md.d(23): Error: found `:` when expecting `)`\n/tmp/tmp2_7k55md.d(23): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_7k55md.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(int j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j] > x)\n                {\n                    Tuple!(long, long)[] col = new Tuple!(long, long)[j];\n                    row.Add(col);\n                }\n            }\n            result.Add(row);\n        }\n    }\n    result.Sort();\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi9_g5tux.d(20): Error: no property `Length` for type `long[][]`\n/tmp/tmpi9_g5tux.d(25): Error: no property `Length` for type `long[]`\n/tmp/tmpi9_g5tux.d(30): Error: no property `Add` for type `Tuple!(long, long)[]`\n/tmp/tmpi9_g5tux.d(33): Error: no property `Add` for type `Tuple!(long, long)[]`\n/tmp/tmpi9_g5tux.d(36): Error: no property `Sort` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi9_g5tux.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long, long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmperh48nu_.d(21): Error: no identifier for declarator `i`\n/tmp/tmperh48nu_.d(21): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperh48nu_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            result.push((lst[i][1], lst[i][2]));\n        }\n    }\n    \n    result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a, b){return a[1] - b[1]});\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp95_fzljo.d(29): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmp95_fzljo.d(29): Error: found `)` instead of statement\n/tmp/tmp95_fzljo.d(30): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmp95_fzljo.d(30): Error: found `)` instead of statement\n/tmp/tmp95_fzljo.d(34): Error: found `unittest` when expecting `,`\n/tmp/tmp95_fzljo.d(45): Error: found `void` when expecting `,`\n/tmp/tmp95_fzljo.d(45): Error: found `{` when expecting `,`\n/tmp/tmp95_fzljo.d(45): Error: expression expected, not `}`\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `,`\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `)`\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `,`\n/tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `)`\n/tm",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long, long)[] res = new Tuple!(long, long)[(n*m)];\n                for(k = 0; k < n*m; k++)\n                {\n                    res[k] = new Tuple!(long, long)(i, j);\n                }\n                return res;\n            }\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn04yc8ta.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)*)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn04yc8ta.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n            break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n            break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqfjxdn16.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmpqfjxdn16.d(43): Error: variable `j` cannot be read at compile time\n/tmp/tmpqfjxdn16.d(43): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqfjxdn16.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    long row = 0;\n    long col = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[row][0] = row;\n            res[row][1] = col;\n            row++;\n        }\n        else\n        {\n            res[row][0] = row;\n            res[row][1] = col;\n            col++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphsgijfvx.d(21): Error: no property `Length` for type `long[][]`\n/tmp/tmphsgijfvx.d(35): Error: no property `Length` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphsgijfvx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res, lst.Length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdykdk0ud.d(19): Error: no property `Length` for type `long[][]`\n/tmp/tmpdykdk0ud.d(20): Error: no property `Length` for type `long[][]`\n/tmp/tmpdykdk0ud.d(27): Error: no property `Length` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdykdk0ud.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1] == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n    for(int i = 0; i < rows; i++){\n        res[i] = new Tuple!(long, long)[cols];\n        for(int j = 0; j < cols; j++){\n            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[lst[i][0]][lst[i][1]] = new Tuple!(long, long)();\n            res[lst[i][0]][lst[i][1]][0] = i;\n            res[lst[i][0]][lst[i][1]][1] = lst[i][1];\n        }\n        if(lst[i][1] == x){\n            res[lst[i][0]][lst[i][1]][2] = i;\n            res[lst[i][0]][lst[i][1]][3] = lst[i][0];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1daexifz.d(31): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmp1daexifz.d(33): Error: variable `j` cannot be read at compile time\n/tmp/tmp1daexifz.d(33): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\n/tmp/tmp1daexifz.d(38): Error: variable `lst` cannot be read at compile time\n/tmp/tmp1daexifz.d(38): Error: cannot implicitly convert expression `new Tuple!(long, long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`\n/tmp/tmp1daexifz.d(39): Error: variable `lst` cannot be read at compile time\n/tmp/tmp1daexifz.d(39): Error: only one index allow",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0imd3hx0.d(20): Error: no identifier for declarator `row`\n/tmp/tmp0imd3hx0.d(20): Error: found `:` when expecting `;`\n/tmp/tmp0imd3hx0.d(20): Error: found `:` when expecting `)`\n/tmp/tmp0imd3hx0.d(20): Error: found `)` when expecting `;` following statement\n/tmp/tmp0imd3hx0.d(22): Error: no identifier for declarator `col`\n/tmp/tmp0imd3hx0.d(22): Error: found `:` when expecting `;`\n/tmp/tmp0imd3hx0.d(22): Error: found `:` when expecting `)`\n/tmp/tmp0imd3hx0.d(22): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0imd3hx0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(ret);\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3ts8jun5.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp3ts8jun5.d(24): Error: variable `lst` cannot be read at compile time\n/tmp/tmp3ts8jun5.d(27): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ts8jun5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp3unw6iz.d(30): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmpp3unw6iz.d(42): Error: no `[]` operator overload for type `Tuple!(long, long)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3unw6iz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result, (a, b) -> {\n        return a[0] - b[0];\n    });\n    Arrays.sort(result, (a, b) -> {\n        return b[1] - a[1];\n    });\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[result.length];\n    for(int i = 0; i < result.length; i++)\n    {\n        res[i] = new Tuple!(long, long)[result[i].length];\n        for(int j = 0; j < result[i].length; j++)\n        {\n            res[i][j] = new Tuple!(long, long)();\n            res[i][j].first = 0;\n            res[i][j].second = result[i][j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzqneh_k7.d(21): Deprecation: instead of C-style syntax, use D-style syntax `long[][] result`\n/tmp/tmpzqneh_k7.d(32): Error: expression expected, not `>`\n/tmp/tmpzqneh_k7.d(32): Error: found `{` when expecting `,`\n/tmp/tmpzqneh_k7.d(33): Error: expression expected, not `return`\n/tmp/tmpzqneh_k7.d(33): Error: found `a` when expecting `,`\n/tmp/tmpzqneh_k7.d(33): Error: found `;` when expecting `,`\n/tmp/tmpzqneh_k7.d(34): Error: expression expected, not `}`\n/tmp/tmpzqneh_k7.d(35): Error: expression expected, not `>`\n/tmp/tmpzqneh_k7.d(35): Error: found `{` when expecting `,`\n/tmp/tmpzqneh_k7.d(36): Error: expression expected, not `return`\n/tmp/tmpzqneh_k7.d(36): Error: found `b` when expecting `,`\n/tmp/tmpzqneh_k7.d(36): Error: found `;` when expecting `,`\n/tmp/tmpzqneh_k7.d(37): Error: expression expected, not `}`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzqneh_k7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 = m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n    long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n    long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n    long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n    long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n    long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n    long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n    long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n    long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n    long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n    long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n    long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n    long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n    long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n    long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknmqfrj2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164641
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row,lst)\n    {\n        foreach(column,row)\n        {\n            if(column == x)\n            {\n                result = Tuple!(long, long)[](row,column);\n                break;\n            }\n        }\n        if(result != null)\n            break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpunssq57v.d(20): Error: no identifier for declarator `lst`\n/tmp/tmpunssq57v.d(20): Error: found `)` when expecting `;`\n/tmp/tmpunssq57v.d(22): Error: no identifier for declarator `row`\n/tmp/tmpunssq57v.d(22): Error: found `)` when expecting `;`\n/tmp/tmpunssq57v.d(30): Error: found `if` when expecting `)`\n/tmp/tmpunssq57v.d(31): Error: found `break` when expecting `;` following statement\n/tmp/tmpunssq57v.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpunssq57v.d(33): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpunssq57v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n            if(column_index == x) \n            {\n                foreach(tuple: result, tuple_index: 0) \n                {\n                    tuple.item1 = row_index;\n                    tuple.item2 = column_index;\n                }\n            }\n        }\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 * -1;\n        tuple.item2 = tuple.item2 * -1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp20rnkyvd.d(21): Error: no identifier for declarator `row`\n/tmp/tmp20rnkyvd.d(21): Error: found `:` when expecting `;`\n/tmp/tmp20rnkyvd.d(21): Error: found `:` when expecting `)`\n/tmp/tmp20rnkyvd.d(21): Error: found `)` when expecting `;` following statement\n/tmp/tmp20rnkyvd.d(23): Error: no identifier for declarator `column`\n/tmp/tmp20rnkyvd.d(23): Error: found `:` when expecting `;`\n/tmp/tmp20rnkyvd.d(23): Error: found `:` when expecting `)`\n/tmp/tmp20rnkyvd.d(23): Error: found `)` when expecting `;` following statement\n/tmp/tmp20rnkyvd.d(27): Error: no identifier for declarator `tuple`\n/tmp/tmp20rnkyvd.d(27): Error: found `:` when expecting `;`\n/tmp/tmp20rnkyvd.d(27): Error: found `:` when expecting `)`\n/tmp/tmp20rnkyvd.d(27): Error: found `)` when expecting `;` following statement\n/tmp/tmp20rnkyvd.d(36): Error: no identifier for declarator `tuple`\n/tmp/tmp20rnkyvd.d(36): Error: found `:` when expecting `;`\n/tmp/tmp20rnkyvd.d(36): Error: found `:` when expecting `)`\n/tmp/tmp20rnkyvd.d(36): Error: fo",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] result = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; i++)\n    {\n        result[i] = new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; j++)\n        {\n            result[i][j] = new Tuple!(long, long)(i, j);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpakycpuup.d(21): Error: no property `Length` for type `long[][]`\n/tmp/tmpakycpuup.d(35): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\n/tmp/tmpakycpuup.d(38): Error: variable `j` cannot be read at compile time\n/tmp/tmpakycpuup.d(38): Error: cannot implicitly convert expression `new Tuple!(long, long)(i, j)` of type `Tuple!(long, long)*` to `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpakycpuup.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index: long in  0 .. row.length - 1)\n    {\n        foreach(column: row[0..row.length - 1], column_index: long in  0 .. row.length - 1 - row_index)\n        {\n            if(column_index == x)\n            {\n                result = Tuple!(long, long)[](row_index, column_index);\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpted72a5c.d(21): Error: no identifier for declarator `row`\n/tmp/tmpted72a5c.d(21): Error: found `:` when expecting `;`\n/tmp/tmpted72a5c.d(21): Error: found `:` when expecting `)`\n/tmp/tmpted72a5c.d(21): Error: no identifier for declarator `long`\n/tmp/tmpted72a5c.d(21): Error: found `in` instead of statement\n/tmp/tmpted72a5c.d(30): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpted72a5c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(long j = 0; j < lst[i].length; ++j)\n            {\n                result.add((i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b){return a.0 < b.0;});\n    result.sort(function(a, b){return b.1 < a.1;});\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm6e1ue7x.d(32): Error: found `0.00000` when expecting `;` following `return` statement\n/tmp/tmpm6e1ue7x.d(32): Error: found `<` instead of statement\n/tmp/tmpm6e1ue7x.d(33): Error: found `0.1` when expecting `;` following `return` statement\n/tmp/tmpm6e1ue7x.d(33): Error: found `<` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm6e1ue7x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164642
    }
  ]
}