language: d
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCount2 = 0;\n    long factorCount3 = 0;\n    long factorCount4\
    \ = 0;\n    long factorCount5 = 0;\n    long factorCount6 = 0;\n    long factorCount7\
    \ = 0;\n    long factorCount8 = 0;\n    long factorCount9 = 0;\n    long factorCount10\
    \ = 0;\n    long factorCount11 = 0;\n    long factorCount12 = 0;\n    long factorCount13\
    \ = 0;\n    long factorCount14 = 0;\n    long factorCount15 = 0;\n    long factorCount16\
    \ = 0;\n    long factorCount17 = 0;\n    long factorCount18 = 0;\n    long factorCount19\
    \ = 0;\n    long factorCount20 = 0;\n    long factorCount21 = 0;\n    long factorCount22\
    \ = 0;\n    long factorCount23 = 0;\n    long factorCount24 = 0;\n    long factorCount25\
    \ = 0;\n    long factorCount26 = 0;\n    long factorCount27 = 0;\n    long factorCount28\
    \ = 0;\n    long factorCount29 = 0;\n    long factorCount30 = 0;\n    long factorCount31\
    \ = 0;\n    long factorCount32 = 0;\n    long factorCount33 = 0;\n    long factorCount34\
    \ = 0;\n    long factorCount35 = 0;\n    long factorCount36 = 0;\n    long factorCount37\
    \ = 0;\n    long factorCount38 = 0;\n    long factorCount39 = 0;\n    long factorCount40\
    \ = 0;\n    long factorCount41 = 0;\n    long factorCount42 = 0;\n    long factorCount43\
    \ = 0;\n    long factorCount44 = 0;\n    long factorCount45 = 0;\n    long factorCount46\
    \ = 0;\n    long factorCount47 = 0;\n    long factorCount48 = 0;\n    long factorCount49\
    \ = 0;\n    long factorCount50 = 0;\n    long factorCount51 = 0;\n    long factorCount52\
    \ = 0;\n    long factorCount53 = 0;\n    long factorCount54 = 0;\n    long factorCount55\
    \ = 0;\n    long factorCount56 = 0;\n    long factorCount57 = 0;\n    long factorCount58\
    \ = 0;\n    long factorCount59 = 0;\n    long factorCount60 = 0;\n    long factorCount61\
    \ = 0;\n    long factorCount62 = 0;\n    long factorCount63 = 0;\n    long factorCount64\
    \ = 0;\n    long factorCount65 = 0;\n    long factorCount66 = 0;\n    long factorCount67\
    \ = 0;\n    long factorCount68 = 0;\n    long factorCount69 = 0;\n    long factorCount70\
    \ = 0;\n    long factorCount71 = 0;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprmqh2nlr.d(11): Error: C style cast illegal, use cast(int)std.math.sqrt(n)\n/tmp/tmprmqh2nlr.d(84):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprmqh2nlr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[(int)std.math.factorial(n)];\n    long factorizationCount = 0;\n\
    \    for(int i = 1; i <= n; i++)\n    {\n        long factor = std.math.factorial(i);\n\
    \        if(factor > 1)\n        {\n            factorization[factorizationCount]\
    \ = factor;\n            factorizationCount++;\n        }\n    }\n    return factorization;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactorization) \n{\n    long factorization[] = new long[(int)std.math.factorial(n)];\n\
    \    long factorizationCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n  \
    \      long factor = std.math.factorial(i);\n        if(factor > 1)\n        {\n\
    \            factorization[factorizationCount] = factor;\n            factorizationCount++;\n\
    \        }\n    }\n    return factorization;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactorization, int maxFactorizationCount)\
    \ \n{\n    long factorization[] = new long[(int)std.math.factorial(n)];\n    long\
    \ factorizationCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        long\
    \ factor = std.math.factorial(i);\n        if(factor > 1)\n        {\n       \
    \     factorization[factorizationCount] = factor;\n            factorizationCount++;\n\
    \        }\n    }\n    return factorization;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactorization, int maxFactorizationCount,\
    \ int maxFactorizationCount2) \n{\n    long factorization[] = new long[(int)std.math.factorial(n)];\n\
    \    long factorizationCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n  \
    \      long factor = std.math.factorial(i);\n        if(factor > 1)\n        {\n\
    \            factorization[factorizationCount] = factor;\n            factor\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpar7kujmu.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpar7kujmu.d(32):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpar7kujmu.d(53):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpar7kujmu.d(74):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpar7kujmu.d(83):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmpar7kujmu.d(96):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpar7kujmu.d(96):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpar7kujmu.d(96):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpar7kujmu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd8eae1s3.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpd8eae1s3.d(112):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd8eae1s3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = n;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp104jau1g.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp104jau1g.d(112):
    Error: no identifier for declarator long\n/tmp/tmp104jau1g.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp104jau1g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorsProduct = 1;\n    for(int i = 0; i<factors.length; i++)\n   \
    \ {\n        factorsProduct *= factors[i];\n        factorCount++;\n    }\n  \
    \  factorsProduct /= factorCount;\n    factors[0] = factorsProduct;\n    for(int\
    \ i = 1; i<factors.length; i++)\n    {\n        factorsProduct /= factors[i];\n\
    \        factorCount--;\n        while(factorCount > 0)\n        {\n         \
    \   factorsProduct /= factors[i];\n            factorCount--;\n        }\n   \
    \     factors[i] = factorsProduct;\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9r_lumn.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9r_lumn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbad29qcj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbad29qcj.d(112):
    Error: no identifier for declarator long\n/tmp/tmpbad29qcj.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbad29qcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n%i == 0)\n        {\n            factor *= i;\n   \
    \         factors[(int)i]++;\n            n /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factor;\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        if(n%i == 0)\n        {\n            factor *= i;\n            factors[(int)i]++;\n\
    \            n /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    for(int i = 0; i\
    \ <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n       \
    \     factor *= i;\n            factors[(int)i]++;\n            n /= i;\n    \
    \    }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        if(n%i == 0)\n        {\n            factor *= i;\n            factors[(int)i]++;\n\
    \            n /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n\
    \    return factors;\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptk4fsk1q.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(13):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmptk4fsk1q.d(22): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(33): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(35): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(40): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmptk4fsk1q.d(44): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(55): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(57): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(62): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmptk4fsk1q.d(66): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(77): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(79): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(84): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmptk4fsk1q.d(88): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptk4fsk1q.d(91):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptk4fsk1q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount] = factor;\n            factorCount++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=primes,c#,algorithm |>\n<|\
    \ a |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp6l8u_iv.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp6l8u_iv.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp6l8u_iv.d(27):
    Error: Declaration expected, not \''<\''\n/tmp/tmpp6l8u_iv.d(32): Error: semicolon
    expected, not \''.\''\n/tmp/tmpp6l8u_iv.d(32): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpp6l8u_iv.d(33): Error: semicolon expected, not \''.\''\n/tmp/tmpp6l8u_iv.d(33):
    Error: no identifier for declarator .Linq\n/tmp/tmpp6l8u_iv.d(34): Error: semicolon
    expected, not \''.\''\n/tmp/tmpp6l8u_iv.d(34): Error: no identifier for declarator
    .Text\n/tmp/tmpp6l8u_iv.d(35): Error: semicolon expected, not \''.\''\n/tmp/tmpp6l8u_iv.d(35):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp6l8u_iv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[(int)i]++;\n    \
    \        n /= i;\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)+1];\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n          \
    \  factors[(int)i]++;\n            n /= i;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int factorization) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n\
    \        {\n            factors[(int)i]++;\n            n /= i;\n        }\n \
    \   }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int factorization, int factorization2)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    for(int i = 0;\
    \ i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n     \
    \       factors[(int)i]++;\n            n /= i;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max, int factorization, int factorization2, int factorization3)\
    \ \n{\n    long[] factors = new \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoznjwv6i.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(12):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(16):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpoznjwv6i.d(30): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(31): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(35): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmpoznjwv6i.d(49): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(50): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(54): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpoznjwv6i.d(68): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(69): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmpoznjwv6i.d(73): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpoznjwv6i.d(88): Error: basic type expected, not unittest\n/tmp/tmpoznjwv6i.d(88):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmpoznjwv6i.d(88): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpoznjwv6i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(n % factor == 0) {\n            factors[(int)i]++;\n \
    \           n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long\
    \ factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        while(n\
    \ % factor == 0) {\n            factors[(int)i]++;\n            n /= factor;\n\
    \        }\n        factor++;\n        if(factor > max) break;\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max, int factor) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n   \
    \     while(n % factor == 0) {\n            factors[(int)i]++;\n            n\
    \ /= factor;\n        }\n        factor++;\n        if(factor > max) break;\n\
    \        if(factor == factor) factors[(int)i]++;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int factor, int max2) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n   \
    \     while(n % factor == 0) {\n            factors[(int)i]++;\n            n\
    \ /= factor;\n        }\n        factor++;\n        if(factor > max) break;\n\
    \        if(factor == factor) factors[(int)i]++;\n        if(factor > max2) break;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given \n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp53x4dy_2.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(13):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(15):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp53x4dy_2.d(30): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(32): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(34): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmp53x4dy_2.d(50): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(52): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(54): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp53x4dy_2.d(59): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp53x4dy_2.d(71): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(73):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp53x4dy_2.d(75):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp53x4dy_2.d(80): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmp53x4dy_2.d(85): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53x4dy_2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n \
    \   {\n        factors[i] = 0;\n    }\n    for(int i=2;i<=n;i++)\n    {\n    \
    \    if(n % i == 0)\n        {\n            for(int j=i;j<=n;j+=i)\n         \
    \   {\n                factors[j] += 1;\n            }\n        }\n    }\n   \
    \ long[] result = new long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        result[i] = factors[i];\n    }\n    return result;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ max) \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n    for(int\
    \ i=0;i<factors.length;i++)\n    {\n        factors[i] = 0;\n    }\n    for(int\
    \ i=2;i<=n;i++)\n    {\n        if(n % i == 0)\n        {\n            for(int\
    \ j=i;j<=n;j+=i)\n            {\n                factors[j] += 1;\n          \
    \  }\n        }\n    }\n    long[] result = new long[(int)std.math.factorial(n)];\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        result[i] = factors[i];\n\
    \    }\n    return result;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long factors[]\
    \ = new long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        factors[i] = 0;\n    }\n    for(int i=2;i<=n;i++)\n    {\n   \
    \     if(n % i == 0)\n        {\n            for(int j=i;j<=n;j+=i)\n        \
    \    {\n                factors[j] += 1;\n            }\n        }\n    }\n  \
    \  long[] result = new long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        result[i] = factors[i];\n    }\n    return result;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ag5komn.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(26):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(41):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(56):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(71):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(86):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp4ag5komn.d(93):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ag5komn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n \
    \       factors[i] = factor;\n        factorCount++;\n        while(p % factor\
    \ == 0)\n        {\n            factor *= factor;\n            factorCount++;\n\
    \        }\n        p /= factor;\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n\
    \    factors[(int)Math.sqrt(n)+1] = factorCount;\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = n;\n    long factor = 1;\n    long factorCount = 0;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n \
    \       factorCount++;\n        while(p % factor == 0)\n        {\n          \
    \  factor *= factor;\n            factorCount++;\n        }\n        p /= factor;\n\
    \    }\n    factors[(int)Math.sqrt(n)] = factor;\n    factors[(int)Math.sqrt(n)+1]\
    \ = factorCount;\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n        while(p\
    \ % factor == 0)\n        {\n            factor *= factor;\n            factorCount++;\n\
    \        }\n        p /= factor;\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n\
    \    factors[(int)Math.sqrt(n)+1] = factorCount;\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6eof9nvo.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(26):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(27):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(42):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(53):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(54):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(65):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(69):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(80):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(81):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6eof9nvo.d(84):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6eof9nvo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.Ceiling(Math.Log(n,2))+1];\n\
    \    long factor = 1;\n    for(int i=0;i<result.length;i++)\n    {\n        while(factor*factor<=n)\n\
    \        {\n            result[i]++;\n            factor*=2;\n        }\n    \
    \    factor--;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=algorithm,primes,math,c# |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_yk3sd35.d(11): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmp_yk3sd35.d(24): Error: Declaration expected, not \''<\''\n/tmp/tmp_yk3sd35.d(29):
    Error: semicolon expected, not \''.\''\n/tmp/tmp_yk3sd35.d(29): Error: no identifier
    for declarator .Collections.Generic\n/tmp/tmp_yk3sd35.d(30): Error: semicolon
    expected, not \''.\''\n/tmp/tmp_yk3sd35.d(30): Error: no identifier for declarator
    .Linq\n/tmp/tmp_yk3sd35.d(31): Error: semicolon expected, not \''.\''\n/tmp/tmp_yk3sd35.d(31):
    Error: no identifier for declarator .Text\n/tmp/tmp_yk3sd35.d(32): Error: semicolon
    expected, not \''.\''\n/tmp/tmp_yk3sd35.d(32): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_yk3sd35.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n    for(int\
    \ i = 0; i <= factors.length; i++)\n    {\n        long p = std.math.pow(2, i);\n\
    \        long q = std.math.floor(n/p);\n        if(q > 0)\n        {\n       \
    \     factors[i] = q;\n            n -= q*p;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n\
    \    for(int i = 0; i <= factors.length; i++)\n    {\n        long p = std.math.pow(2,\
    \ i);\n        long q = std.math.floor(n/p);\n        if(q > 0)\n        {\n \
    \           factors[i] = q;\n            n -= q*p;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max, int max2) \n{\n    long[] factors = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n\
    \    for(int i = 0; i <= factors.length; i++)\n    {\n        long p = std.math.pow(2,\
    \ i);\n        long q = std.math.floor(n/p);\n        if(q > 0)\n        {\n \
    \           factors[i] = q;\n            n -= q*p;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max, int max2, int max3) \n{\n    long[] factors\
    \ = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(3))];\n    for(int\
    \ i = 0; i <= factors.length; i++)\n    {\n        long p = std.math.pow(2, i);\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9__lagjz.d(11): Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n)
    / std.math.log2(2))\n/tmp/tmp9__lagjz.d(32): Error: C style cast illegal, use
    cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(2))\n/tmp/tmp9__lagjz.d(53):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(2))\n/tmp/tmp9__lagjz.d(74):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(3))\n/tmp/tmp9__lagjz.d(78):
    Error: found \''unittest\'' instead of statement\n/tmp/tmp9__lagjz.d(91): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp9__lagjz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbad29qcj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbad29qcj.d(112):
    Error: no identifier for declarator long\n/tmp/tmpbad29qcj.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbad29qcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        while(n % factor == 0)\n        {\n\
    \            factors[factorizationOrder] = factor;\n            n /= factor;\n\
    \        }\n        factor++;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationOrder, int factorizationOrderLimit) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorizationOrder]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, int factorizationOrderLimit,\
    \ int factorizationOrderLimitLimit) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorizationOrder]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp60e4v7ma.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(13):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp60e4v7ma.d(32): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(34): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(53): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(55): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(74): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(76): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp60e4v7ma.d(87): Error:
    unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60e4v7ma.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n,2)];\n    long p = n;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(p % 2 == 0)\n        {\n            p /= 2;\n   \
    \         factors[i] = 2;\n        }\n        while(p % 3 == 0)\n        {\n \
    \           p /= 3;\n            factors[i] = 3;\n        }\n        while(p %\
    \ 5 == 0)\n        {\n            p /= 5;\n            factors[i] = 5;\n     \
    \   }\n        while(p % 7 == 0)\n        {\n            p /= 7;\n           \
    \ factors[i] = 7;\n        }\n        while(p % 11 == 0)\n        {\n        \
    \    p /= 11;\n            factors[i] = 11;\n        }\n        while(p % 13 ==\
    \ 0)\n        {\n            p /= 13;\n            factors[i] = 13;\n        }\n\
    \        while(p % 17 == 0)\n        {\n            p /= 17;\n            factors[i]\
    \ = 17;\n        }\n        while(p % 19 == 0)\n        {\n            p /= 19;\n\
    \            factors[i] = 19;\n        }\n        while(p % 23 == 0)\n       \
    \ {\n            p /= 23;\n            factors[i] = 23;\n        }\n        while(p\
    \ % 29 == 0)\n        {\n            p /= 29;\n            factors[i] = 29;\n\
    \        }\n        while(p % 31 == 0)\n        {\n            p /= 31;\n    \
    \        factors[i] = 31;\n        }\n        while(p % 37 == 0)\n        {\n\
    \            p /= 37;\n            factors[i] = 37;\n        }\n        while(p\
    \ % 41 == 0)\n        {\n            p /= 41;\n            factors[i] = 41;\n\
    \        }\n        while(p % 43 == 0)\n        {\n            p /= 43;\n    \
    \        factors[i] = 43;\n        }\n        while(p % 47 == 0)\n        {\n\
    \            p /= 47;\n            factors[i] = 47;\n        }\n        while(p\
    \ % 53 == 0)\n        {\n            p /= 53;\n            factors[i] = 53;\n\
    \        }\n        while(p % 59 == 0)\n        {\n            p /= 59;\n    \
    \        factors[i] = 59;\n        }\n        while(p % 61 == 0)\n        {\n\
    \            p /= 61;\n            factors[i] = 61;\n        }\n        while(p\
    \ % 67 == 0)\n        {\n            p /= 67;\n            factors[i] = 67;\n\
    \        }\n        while(p % 71 == 0)\n        {\n            p /= 71;\n    \
    \        factors[i] = 71;\n        }\n        while(p % 73 == 0)\n        {\n\
    \            p /= 73\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpomyget4s.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    2)\n/tmp/tmpomyget4s.d(118): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmpomyget4s.d(131): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpomyget4s.d(131): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpomyget4s.d(131):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomyget4s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i]++;\n            n /= p;\n        }\n        p++;\n\
    \        if(factors[(int)i] > maxFactors)\n        {\n            factors[(int)i]\
    \ = maxFactors;\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        while(n % p == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= p;\n        }\n        p++;\n        if(factors[(int)i] > maxFactors)\n\
    \        {\n            factors[(int)i] = maxFactors;\n        }\n        if(factors[(int)i]\
    \ > maxFactorsCount)\n        {\n            factors[(int)i] = maxFactorsCount;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount,\
    \ int maxFactorsCountCount) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp659ziaai.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp659ziaai.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp659ziaai.d(33): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp659ziaai.d(40): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmp659ziaai.d(44): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp659ziaai.d(46): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp659ziaai.d(59): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp659ziaai.d(66):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp659ziaai.d(70): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmp659ziaai.d(72): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp659ziaai.d(74): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp659ziaai.d(76): Error: C style cast illegal, use cast(int)i\n/tmp/tmp659ziaai.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp659ziaai.d(92):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp659ziaai.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n \
    \       if(n%i == 0)\n        {\n            factorCount++;\n            factors[i]\
    \ = factor;\n            factor *= i;\n        }\n        else\n        {\n  \
    \          factorCount++;\n            factor *= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factorCount;\n    return factors;\n}\n</code>\n<|/ a tags=c#,primes,math |>\n\
    <| c |>\nThis code does not work for large numbers. I tested it with number `10^9`\
    \ and it returned `10^9` as prime number. `10^9` can be divided by `10^9` only\
    \ once.\n<|/ c |>\n<| c |>\nI tested it with number `10^9` and it returned `10^9`\
    \ as prime number. `10^9` can be divided by `10^9` only once.\n<|/ c |>\n<| c\
    \ |>\nI tested it with number `10^9` and it returned `10^9` as prime number. `10^9`\
    \ can be divided by `10^9` only once.\n<|/ c |>\n<| c |>\nI tested it with number\
    \ `10^9` and it returned `10^9` as prime number. `10^9` can be divided by `10^9`\
    \ only once.\n<|/ c |>\n<| c |>\nI tested it with number `10^9` and it returned\
    \ `10^9` as prime number. `10^9` can be divided by `10^9` only once.\n<|/ c |>\n\
    <| a dscore=5 |>\nThe easiest way is to use Sieve of Eratosthenes algorithm. \n\
    <code>\npublic static bool IsPrime(long n)\n{\n    if (n == 1) return false;\n\
    \    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    long limit\
    \ = (long)Math.Sqrt(n);\n    bool[] isPrime = new bool[limit];\n    isPrime[0]\
    \ = isPrime[1] = true;\n    for (int i = 2; i <= limit; i++)\n    {\n        if\
    \ (isPrime[i])\n        {\n            for (int j = i * i; j < n; j += i)\n  \
    \          {\n                isPrime[j] = false;\n            }\n        }\n\
    \    }\n    return isPrime[n];\n}\n</code>\n<|/ a \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplq28ro53.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplq28ro53.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplq28ro53.d(29):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplq28ro53.d(32):
    Error: Declaration expected, not \''<\''\n/tmp/tmplq28ro53.d(55): Error: Declaration
    expected, not \''if\''\n/tmp/tmplq28ro53.d(56): Error: Declaration expected, not
    \''if\''\n/tmp/tmplq28ro53.d(57): Error: C style cast illegal, use cast(long)Math.Sqrt(n)\n/tmp/tmplq28ro53.d(59):
    Error: no identifier for declarator isPrime[0]\n/tmp/tmplq28ro53.d(59): Error:
    Declaration expected, not \''=\''\n/tmp/tmplq28ro53.d(60): Error: Declaration
    expected, not \''for\''\n/tmp/tmplq28ro53.d(60): Error: no identifier for declarator
    i\n/tmp/tmplq28ro53.d(60): Error: Declaration expected, not \''<=\''\n/tmp/tmplq28ro53.d(60):
    Error: no identifier for declarator i\n/tmp/tmplq28ro53.d(60): Error: Declaration
    expected, not \''++\''\n/tmp/tmplq28ro53.d(64): Error: no identifier for declarator
    j\n/tmp/tmplq28ro53.d(64): Error: Declaration expected, not \''<\''\n/tmp/tmplq28ro53.d(64):
    Error: no identifier for declarator j\n/tmp/tmplq28ro53.d(64): Error: Declaration
    expected, not \''+=\''\n/tmp/tmplq28ro53.d(67): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplq28ro53.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)];\n    std.math.factorize(n,factors);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n,long[] factors) \n{\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,long[] factors,int start) \n{\n    std.math.factorize(n,factors,start);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,long[] factors,int start,int end) \n{\n   \
    \ std.math.factorize(n,factors,start,end);\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n,long[]\
    \ factors,int start,int end,int step) \n{\n    std.math.factorize(n,factors,start,end,step);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,long[] factors,int start,int end,int step,int\
    \ max) \n{\n    std.math.factorize(n,factors,start,end,step,max);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to \nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2z3vzae6.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp2z3vzae6.d(70):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2z3vzae6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n    long p =\
    \ n;\n    for(int i = 0; i < factors.length; i++)\n    {\n        long q = p%10;\n\
    \        factors[i] = q;\n        p = p/10;\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder) \n{\n    long[] factors = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n\
    \    long p = n;\n    for(int i = 0; i < factors.length; i++)\n    {\n       \
    \ long q = p%10;\n        factors[i] = q;\n        p = p/10;\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int factorizationOrder, bool isPrime) \n{\n    long[]\
    \ factors = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n\
    \    long p = n;\n    for(int i = 0; i < factors.length; i++)\n    {\n       \
    \ long q = p%10;\n        factors[i] = q;\n        p = p/10;\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int factorizationOrder, bool isPrime, bool isPrimeOnly)\
    \ \n{\n    long[] factors = new long[(int)std.math.ceiling(std.math.log(n)/std.math.log2(2))];\n\
    \    long p = n;\n    for(int i = 0; i < factors.length; i++)\n    {\n       \
    \ long q = p%10;\n        factors[i] = q;\n        p = p/10;\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1bulilge.d(11): Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n)
    / std.math.log2(2))\n/tmp/tmp1bulilge.d(29): Error: C style cast illegal, use
    cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(2))\n/tmp/tmp1bulilge.d(47):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(2))\n/tmp/tmp1bulilge.d(65):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.log(n) / std.math.log2(2))\n/tmp/tmp1bulilge.d(75):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1bulilge.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(n\
    \ % factor == 0)\n        {\n            factors[(int)i] = factor;\n         \
    \   n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(n\
    \ % factor == 0)\n        {\n            factors[(int)i] = factor;\n         \
    \   n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(n\
    \ % factor == 0)\n        {\n            factors[(int)i] = factor;\n         \
    \   n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps8te1yg8.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps8te1yg8.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmps8te1yg8.d(32): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps8te1yg8.d(38): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmps8te1yg8.d(53): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps8te1yg8.d(59): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmps8te1yg8.d(74): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmps8te1yg8.d(80): Error: C style cast illegal,
    use cast(int)i\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8te1yg8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factor_count = 1;\n\
    \    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        while(n % i == 0)\
    \ {\n            factors[factor_count] = i;\n            n /= i;\n           \
    \ factor_count++;\n        }\n    }\n    factors[factor_count] = n;\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,c# |>\n<| c |>\nThis\
    \ code doesn't work for me. Can you please explain how it works?\n<|/ c |>\n<|\
    \ c |>\nIt works. I tested it on several numbers and it worked fine. Maybe you\
    \ missed something?\n<|/ c |>\n<| c |>\nI tested it on `n = 9` and it returned\
    \ `[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp66a_a_2v.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp66a_a_2v.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp66a_a_2v.d(24):
    Error: Declaration expected, not \''<\''\n/tmp/tmp66a_a_2v.d(27): Error: unterminated
    character constant\n/tmp/tmp66a_a_2v.d(33): Error: unterminated string constant
    starting at /tmp/tmp66a_a_2v.d(33)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp66a_a_2v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long factor = 1;\n    long\
    \ factor_count = 1;\n    long factor_index = 0;\n    while(p > 1)\n    {\n   \
    \     factors[factor_index] = p;\n        factor_index++;\n        factor++;\n\
    \        factor_count++;\n        while(p % factor == 0)\n        {\n        \
    \    p /= factor;\n            factor_count++;\n        }\n    }\n    factors[factor_index]\
    \ = p;\n    return factors;\n}\n</code>\n<|/ a tags=c#,algorithm,primes |>\n<|\
    \ c |>\nI believe this algorithm is wrong. For example, factorize(100) returns\
    \ [2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppfmi5xmh.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmppfmi5xmh.d(31):
    Error: Declaration expected, not \''<\''\n/tmp/tmppfmi5xmh.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(40): Error: Declaration expected,
    not \''assert\''\n/tmp/tmppfmi5xmh.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmppfmi5xmh.d(46): Error: Declaration expected, not \''assert\''\n/tmp/tmppfmi5xmh.d(47):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppfmi5xmh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    for(int i = 0; i <= factorCount; i++)\n\
    \    {\n        factors[i] = factors[factorCount];\n        factorCount--;\n \
    \   }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long factors[]\
    \ = new long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    for(int i = 0; i <= factorCount; i++)\n\
    \    {\n        factors[i] = factors[factorCount];\n        factorCount--;\n \
    \   }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime) \n{\n\
    \    long factors[] = new long[(int)std.math.factorial(n)];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n    \
    \    while(n % i == 0)\n        {\n            factors[factorCount] = i;\n   \
    \         factorCount++;\n            n /= i;\n        }\n    }\n    for(int i\
    \ = 0; i <= factorCount; i++)\n    {\n        factors[i] = factors[factorCount];\n\
    \        factorCount--;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationOrder,\
    \ bool isPrime, bool isPrimeOnly) \n{\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8153_0bf.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp8153_0bf.d(38):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp8153_0bf.d(65):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp8153_0bf.d(93):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp8153_0bf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n \
    \   {\n        factors[i]=1;\n    }\n    for(int i=2;i<=(int)std.math.factorial(n);i++)\n\
    \    {\n        for(int j=0;j<factors.length;j++)\n        {\n            if(factors[j]*i==n)\n\
    \            {\n                factors[j]=factors[j]+1;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n,int max) \n{\n\
    \    long factors[] = new long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        factors[i]=1;\n    }\n    for(int i=2;i<=(int)std.math.factorial(n);i++)\n\
    \    {\n        for(int j=0;j<factors.length;j++)\n        {\n            if(factors[j]*i==n)\n\
    \            {\n                factors[j]=factors[j]+1;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n,int max,int max2)\
    \ \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n    for(int\
    \ i=0;i<factors.length;i++)\n    {\n        factors[i]=1;\n    }\n    for(int\
    \ i=2;i<=(int)std.math.factorial(n);i++)\n    {\n        for(int j=0;j<factors.length;j++)\n\
    \        {\n            if(factors[j]*i==n)\n            {\n                factors[j]=factors[j]+1;\n\
    \                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n,int max,int max2,int max3) \n{\n    long factors[] = new long[(int)std.math.\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprt94emik.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(16):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(37):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(42):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(63):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(68):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmprt94emik.d(90):
    Error: identifier expected following \''.\'', not \''unittest\''\n/tmp/tmprt94emik.d(91):
    Error: C style cast illegal, use cast(int)std.math\n/tmp/tmprt94emik.d(91): Error:
    found \''{\'' when expecting \'']\''\n/tmp/tmprt94emik.d(92): Error: semicolon
    expected, not \''alias\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprt94emik.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCountMax = factors.length;\n    long factorCountMin = 1;\n   \
    \ long factorCountMinIndex = 0;\n    long factorCountMaxIndex = 0;\n    long factorCountMinIndex2\
    \ = 0;\n    long factorCountMaxIndex2 = 0;\n    long factorCountMinIndex3 = 0;\n\
    \    long factorCountMaxIndex3 = 0;\n    long factorCountMinIndex4 = 0;\n    long\
    \ factorCountMaxIndex4 = 0;\n    long factorCountMinIndex5 = 0;\n    long factorCountMaxIndex5\
    \ = 0;\n    long factorCountMinIndex6 = 0;\n    long factorCountMaxIndex6 = 0;\n\
    \    long factorCountMinIndex7 = 0;\n    long factorCountMaxIndex7 = 0;\n    long\
    \ factorCountMinIndex8 = 0;\n    long factorCountMaxIndex8 = 0;\n    long factorCountMinIndex9\
    \ = 0;\n    long factorCountMaxIndex9 = 0;\n    long factorCountMinIndex10 = 0;\n\
    \    long factorCountMaxIndex10 = 0;\n    long factorCountMinIndex11 = 0;\n  \
    \  long factorCountMaxIndex11 = 0;\n    long factorCountMinIndex12 = 0;\n    long\
    \ factorCountMaxIndex12 = 0;\n    long factorCountMinIndex13 = 0;\n    long factorCountMaxIndex13\
    \ = 0;\n    long factorCountMinIndex14 = 0;\n    long factorCountMaxIndex14 =\
    \ 0;\n    long factorCountMinIndex15 = 0;\n    long factorCountMaxIndex15 = 0;\n\
    \    long factorCountMinIndex16 = 0;\n    long factorCountMaxIndex16 = 0;\n  \
    \  long factorCountMinIndex17 = 0;\n    long factorCountMaxIndex17 = 0;\n    long\
    \ factorCountMinIndex18 = 0;\n    long factorCountMaxIndex18 = 0;\n    long factorCountMinIndex19\
    \ = 0;\n    long factorCountMaxIndex19 = 0;\n    long factorCountMinIndex20 =\
    \ 0;\n    long factorCountMaxIndex20 = 0;\n    long factorCountMinIndex21 = 0;\n\
    \    long factorCountMaxIndex21 = 0;\n    long factorCountMinIndex22 = 0;\n  \
    \  long factorCountMaxIndex22 = 0;\n    long factorCountMinIndex23 = 0;\n    long\
    \ factorCountMaxIndex23 = 0;\n    long factorCountMinIndex24 = 0;\n    long factorCountMaxIndex24\
    \ = 0;\n    long factorCountMinIndex25 = 0;\n    long factorCountMaxIndex25 =\
    \ 0;\n    long factorCountMinIndex26 = 0;\n    long factorCountMaxIndex26 = 0;\n\
    \    long factorCountMinIndex27 = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx6rjr0r9.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx6rjr0r9.d(70):
    Error: no identifier for declarator long\n/tmp/tmpx6rjr0r9.d(70): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpx6rjr0r9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long counter = 1;\n \
    \   for(int i = 0; i <= (int)std.math.gcd(n); i++)\n    {\n        factors[i]\
    \ = 0;\n    }\n    for(int i = 1; i <= (int)std.math.gcd(n); i++)\n    {\n   \
    \     while(n % i == 0)\n        {\n            factors[counter]++;\n        \
    \    n /= i;\n        }\n    }\n    for(int i = 0; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factors[i] = factors[i] * i;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorization[]) \n{\n    long factors[] = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    long counter = 1;\n    for(int i = 0; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factors[i] = 0;\n    }\n    for(int i = 1; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            factors[counter]++;\n\
    \            n /= i;\n        }\n    }\n    for(int i = 0; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factors[i] = factors[i] * i;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorization[]) \n{\n    long factors[] = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    long counter = 1;\n    for(int i = 0; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factors[i] = 0;\n    }\n    for(int i = 1; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            factors[counter]++;\n\
    \            n /= i;\n        }\n    }\n    for(int i = 0; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factors[i] = factors[i] * i;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7c9rags4.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(14):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(18):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(26):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(40):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(43):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(47):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(55):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(69):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(72):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(76):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(84):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp7c9rags4.d(90):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7c9rags4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*factor <= n)\n        {\n    \
    \        if(n % factor == 0)\n            {\n                factors[factorCount++]\
    \ = factor;\n                n /= factor;\n            }\n            else\n \
    \           {\n                factor *= factor;\n            }\n        }\n \
    \       factorProduct = factor;\n        factor = 1;\n        for(int j = 0; j<factorCount;\
    \ j++)\n        {\n            factor *= factors[j];\n        }\n        if(factorProduct\
    \ == n)\n        {\n            factors[factorCount++] = factorProduct;\n    \
    \    }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*factor <= n)\n        {\n    \
    \        if(n % factor == 0)\n            {\n                factors[factorCount++]\
    \ = factor;\n                n /= factor;\n            }\n            else\n \
    \           {\n                factor *= factor;\n            }\n        }\n \
    \       factorProduct = factor;\n        factor = 1;\n        for(int j = 0; j<factorCount;\
    \ j++)\n        {\n            factor *= factors[j];\n        }\n        if(factorProduct\
    \ == n)\n        {\n            factors[factorCount++] = factorProduct;\n    \
    \    }\n        if(factorCount == maxFactors)\n        {\n            break;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorProduct = 1;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        factorCount = 0;\n        while(factor*\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2whhz50g.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp2whhz50g.d(51):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp2whhz50g.d(95):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp2whhz50g.d(103):
    Error: expression expected, not \''unittest\''\n/tmp/tmp2whhz50g.d(104): Error:
    found \''{\'' when expecting \'')\''\n/tmp/tmp2whhz50g.d(116): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2whhz50g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            n /= i;\n            result[(int)(i-1)]++;\n\
    \        }\n    }\n    for(int i = 0; i < result.length; i++)\n    {\n       \
    \ result[i] *= factor;\n        factor *= i;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,primes |>\n<| a tags=c#,algorithm,primes |>\n<code>\n\
    using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\
    using System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpucfmd5o3.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpucfmd5o3.d(18):
    Error: C style cast illegal, use cast(int)(i - 1)\n/tmp/tmpucfmd5o3.d(28): Error:
    Declaration expected, not \''<\''\n/tmp/tmpucfmd5o3.d(33): Error: semicolon expected,
    not \''.\''\n/tmp/tmpucfmd5o3.d(33): Error: no identifier for declarator .Collections.Generic\n/tmp/tmpucfmd5o3.d(34):
    Error: semicolon expected, not \''.\''\n/tmp/tmpucfmd5o3.d(34): Error: no identifier
    for declarator .Linq\n/tmp/tmpucfmd5o3.d(35): Error: semicolon expected, not \''.\''\n/tmp/tmpucfmd5o3.d(35):
    Error: no identifier for declarator .Text\n/tmp/tmpucfmd5o3.d(36): Error: semicolon
    expected, not \''.\''\n/tmp/tmpucfmd5o3.d(36): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpucfmd5o3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n   \
    \ long factorProduct = 1;\n    long factorProductCount = 0;\n    for(int i = 0;\
    \ i <= (int)sqrt(n); i++) {\n        factors[i] = factor;\n        factorCount++;\n\
    \        factor *= i;\n        factorProductCount += factorProduct;\n        factorProduct\
    \ *= i;\n    }\n    factors[(int)sqrt(n)] = factorProductCount;\n    for(int i\
    \ = 0; i <= (int)sqrt(n); i++) {\n        factors[i] += factorCount;\n    }\n\
    \    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8wzuvyse.d(11): Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp8wzuvyse.d(16):
    Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp8wzuvyse.d(23): Error:
    C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp8wzuvyse.d(24): Error: C style
    cast illegal, use cast(int)sqrt(n)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8wzuvyse.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    std.math.factorize(n,factors);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,factors,start);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end) \n{\n\
    \    std.math.factorize(n,factors,start,end);\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, long[]\
    \ factors, int start, int end, int step) \n{\n    std.math.factorize(n,factors,start,end,step);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end, int step,\
    \ long max) \n{\n    std.math.factorize(n,factors,start,end,step,max);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appe\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf9rqorx7.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpf9rqorx7.d(70):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf9rqorx7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    long factor = 1;\n   \
    \ long counter = 1;\n    for(long i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            n /= i;\n            factors[counter++] =\
    \ i;\n        }\n    }\n    factors[counter++] = n;\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors) \n{\n    long[] factors = new long[maxFactors];\n    long\
    \ factor = 1;\n    long counter = 1;\n    for(long i = 2; i <= n; i++)\n    {\n\
    \        while(n % i == 0)\n        {\n            n /= i;\n            factors[counter++]\
    \ = i;\n        }\n    }\n    factors[counter++] = n;\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCounter) \n{\n    long[] factors = new long[maxFactors];\n\
    \    long factor = 1;\n    long counter = 1;\n    for(long i = 2; i <= n; i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            n /= i;\n          \
    \  factors[counter++] = i;\n        }\n    }\n    factors[counter++] = n;\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCounter, bool isPrime)\
    \ \n{\n    long[] factors = new long[maxFactors];\n    long factor = 1;\n    long\
    \ counter = 1;\n    for(long i = 2; i <= n; i++)\n    {\n        while(n % i ==\
    \ 0)\n        {\n            n /= i;\n            factors[counter++] = i;\n  \
    \      }\n    }\n    factors[counter++] = n;\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order \nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3qmxpmcj.d(91): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3qmxpmcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorCountMax\
    \ = 100;\n    long factorCountMin = 1;\n    long factorCountMinMax = factorCountMax;\n\
    \    long factorCountMaxMin = factorCountMax;\n    long factorCountMaxMinMax =\
    \ factorCountMax;\n    long factorCountMaxMinMaxMin = factorCountMax;\n    long\
    \ factorCountMaxMinMaxMinMax = factorCountMax;\n    long factorCountMaxMinMaxMinMaxMin\
    \ = factorCountMax;\n    long factorCountMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMin = factorCountMax;\n    long factorCountMaxMinMaxMinMaxMinMaxMinMax\
    \ = factorCountMax;\n    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMin = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n   \
    \ long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = factorCountMax;\n   \
    \ long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    \    long factorCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorCountMax;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpulomjxr5.d(39): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpulomjxr5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % i == 0)\n    \
    \    {\n            factors[p] = factor;\n            n /= i;\n            p++;\n\
    \            factor++;\n        }\n    }\n    factors[p] = factor;\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            factors[p] =\
    \ factor;\n            n /= i;\n            p++;\n            factor++;\n    \
    \    }\n        if(p > max)\n            break;\n    }\n    factors[p] = factor;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n  \
    \  for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % i ==\
    \ 0)\n        {\n            factors[p] = factor;\n            n /= i;\n     \
    \       p++;\n            factor++;\n        }\n        if(p > max)\n        \
    \    break;\n        if(p > max2)\n            break;\n    }\n    factors[p] =\
    \ factor;\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2, int max3) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor =\
    \ 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n\
    \ % i == 0)\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn16e2mhr.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(35):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(61):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(64):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(92):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn16e2mhr.d(96):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpn16e2mhr.d(109): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn16e2mhr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n \
    \       factor *= i;\n    }\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        for(int j = i + 1; j <= (int)Math.sqrt(n); j++)\n        {\n \
    \           if(n%i == 0 && n%j == 0)\n            {\n                factor *=\
    \ i;\n                factor *= j;\n                factors[i] = factor;\n   \
    \             factors[j] = factor;\n            }\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactors) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        factor *= i;\n    }\n   \
    \ for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        for(int j = i +\
    \ 1; j <= (int)Math.sqrt(n); j++)\n        {\n            if(n%i == 0 && n%j ==\
    \ 0)\n            {\n                factor *= i;\n                factor *= j;\n\
    \                factors[i] = factor;\n                factors[j] = factor;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        factor *= i;\n    }\n   \
    \ for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        for(int j = i +\
    \ 1; j <= (int)Math.sqrt(n); j++)\n        {\n            if(n%i == 0 && n%j ==\
    \ 0)\n            {\n                factor *= i;\n                factor *= j;\n\
    \                factors[i] = factor;\n                factor\nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptdayjydw.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(19):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(21):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(42):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(45):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(50):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(52):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(73):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(76):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(81):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(83):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptdayjydw.d(91):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmptdayjydw.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptdayjydw.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptdayjydw.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptdayjydw.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdayjydw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n \
    \       factors[i] = factor;\n        factorCount += factor;\n        factor *=\
    \ i;\n    }\n    factors[(int)Math.sqrt(n)] = factorCount;\n    for(int i = 0;\
    \ i <= (int)Math.sqrt(n); i++)\n    {\n        factor *= i;\n        factorCount\
    \ /= factors[i];\n        for(int j = i+1; j <= (int)Math.sqrt(n); j++)\n    \
    \    {\n            if(factors[j] == factorCount)\n            {\n           \
    \     factors[j] = factor;\n                factorCount /= factor;\n         \
    \   }\n        }\n    }\n    return factors;\n}\n</code>\n<|/ a tags=math,primes,algorithm,java\
    \ |>\n<| a tags=math,primes,algorithm,java |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf4pcdiyi.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf4pcdiyi.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf4pcdiyi.d(21):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf4pcdiyi.d(22):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf4pcdiyi.d(26):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf4pcdiyi.d(37):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpf4pcdiyi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))) + 1];\n    long\
    \ p = n;\n    long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        while(p % factor == 0)\n        {\n            factors[factors.length\
    \ - 1 - i] = factor;\n            p /= factor;\n            factor++;\n      \
    \  }\n    }\n    factors[factors.length - 1] = p;\n    return factors;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis code doesn't work. `factorize` returns `[2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpedmn4v1b.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)))\n/tmp/tmpedmn4v1b.d(26): Error: Declaration
    expected, not \''<\''\n/tmp/tmpedmn4v1b.d(29): Error: unterminated character constant\n/tmp/tmpedmn4v1b.d(29):
    Error: unterminated string constant starting at /tmp/tmpedmn4v1b.d(29)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedmn4v1b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorIndex = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        factors[factorIndex]\
    \ = i;\n        factorCount++;\n        while(factor <= n && n % factor == 0)\n\
    \        {\n            factors[factorIndex] = factor;\n            factorCount++;\n\
    \            n /= factor;\n            factor++;\n        }\n        factorIndex++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long factors[] =\
    \ new long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long factorIndex = 0;\n    for(int i = 1; i <= n; i++)\n    {\n  \
    \      factors[factorIndex] = i;\n        factorCount++;\n        while(factor\
    \ <= n && n % factor == 0)\n        {\n            factors[factorIndex] = factor;\n\
    \            factorCount++;\n            n /= factor;\n            factor++;\n\
    \        }\n        factorIndex++;\n        if(factorCount >= maxFactors)\n  \
    \          break;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long factors[] = new long[(int)std.math.gcd(n)];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n    for(int i = 1;\
    \ i <= n; i++)\n    {\n        factors[factorIndex] = i;\n        factorCount++;\n\
    \        while(factor <= n && n % factor == 0)\n        {\n            factors[factorIndex]\
    \ = factor;\n            factorCount++;\n            n /= factor;\n          \
    \  factor++;\n        }\n        factorIndex++;\n        if(factorCount >= maxFactors)\n\
    \            break;\n        if(factorCount >= maxFactorsCount)\n            break;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factor\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmx9203mn.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmx9203mn.d(38):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmx9203mn.d(67):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmx9203mn.d(90):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmx9203mn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long count = 0;\n    for(long\
    \ i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n         \
    \   factors[count] = i;\n            n /= i;\n            count++;\n        }\n\
    \    }\n    factors[count] = n;\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpptf59nru.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptf59nru.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = n;\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    while(p > 1)\n    {\n        factorCount++;\n        factors[factorCount]\
    \ = p;\n        factor *= p;\n        p /= factor;\n    }\n    factors[factorCount]\
    \ = p;\n    factors[factorCount] = 1;\n    factorCount++;\n    factors[factorCount]\
    \ = 1;\n    factors[factorCount] = 1;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long p = n;\n    long factor = 1;\n    long factorCount = 0;\n    while(p\
    \ > 1)\n    {\n        factorCount++;\n        factors[factorCount] = p;\n   \
    \     factor *= p;\n        p /= factor;\n    }\n    factors[factorCount] = p;\n\
    \    factors[factorCount] = 1;\n    factorCount++;\n    factors[factorCount] =\
    \ 1;\n    factors[factorCount] = 1;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationSize, int factorizationSizeLimit) \n{\n    long[] factors = new\
    \ long[factorizationSize];\n    long p = n;\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    while(p > 1)\n    {\n        factorCount++;\n        factors[factorCount]\
    \ = p;\n        factor *= p;\n        p /= factor;\n    }\n    factors[factorCount]\
    \ = p;\n    factors[factorCount] = 1;\n    factorCount++;\n    factors[factorCount]\
    \ = 1;\n    factors[factorCount] = 1;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factor\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6t2t58q9.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp6t2t58q9.d(88):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6t2t58q9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbad29qcj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbad29qcj.d(112):
    Error: no identifier for declarator long\n/tmp/tmpbad29qcj.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbad29qcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.factorial(n)];\n    std.math.factorize(n, factors);\n    return\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40d6obw1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.Ceiling(Math.Log(n,2))+1];\n\
    \    for(int i=0;i<result.length;i++)\n    {\n        result[i] = 0;\n    }\n\
    \    for(int i=2;i*i<=n;i++)\n    {\n        if(result[i]==0)\n        {\n   \
    \         for(int j=i*i;j<=n;j+=i)\n            {\n                result[j]++;\n\
    \            }\n        }\n    }\n    for(int i=0;i<result.length;i++)\n    {\n\
    \        if(result[i]!=0)\n        {\n            result[i]=n/result[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max) \n{\n    long[] result = new long[(int)Math.Ceiling(Math.Log(n,2))+1];\n\
    \    for(int i=0;i<result.length;i++)\n    {\n        result[i] = 0;\n    }\n\
    \    for(int i=2;i*i<=n;i++)\n    {\n        if(result[i]==0)\n        {\n   \
    \         for(int j=i*i;j<=n;j+=i)\n            {\n                result[j]++;\n\
    \            }\n        }\n    }\n    for(int i=0;i<result.length;i++)\n    {\n\
    \        if(result[i]!=0)\n        {\n            result[i]=n/result[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max,int min) \n{\n    long[] result = new\
    \ long[(int)Math.Ceiling(Math.Log(n,2))+1];\n    for(int i=0;i<result.length;i++)\n\
    \    {\n        result[i] = 0;\n    }\n    for(int i=2;i*i<=n;i++)\n    {\n  \
    \      if(result[i]==0)\n        {\n            for(int j=i*i;j<=n;j+=i)\n   \
    \         {\n                result[j]++;\n            }\n        }\n    }\n \
    \   for(int i=0;i<result.length;i++)\n    {\n        if(result[i]!=0)\n      \
    \  {\n            result[i]=n/result[i];\n        }\n    }\n    return result;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjtgpdxsr.d(11): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmpjtgpdxsr.d(43): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmpjtgpdxsr.d(75): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmpjtgpdxsr.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpjtgpdxsr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[std.math.nextpow2(n) + 1];\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdxexzdfz.d(111): Error: no identifier for declarator long\n/tmp/tmpdxexzdfz.d(111):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdxexzdfz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCount2 = 0;\n    long factorCount3 = 0;\n    long factorCount4\
    \ = 0;\n    long factorCount5 = 0;\n    long factorCount6 = 0;\n    long factorCount7\
    \ = 0;\n    long factorCount8 = 0;\n    long factorCount9 = 0;\n    long factorCount10\
    \ = 0;\n    long factorCount11 = 0;\n    long factorCount12 = 0;\n    long factorCount13\
    \ = 0;\n    long factorCount14 = 0;\n    long factorCount15 = 0;\n    long factorCount16\
    \ = 0;\n    long factorCount17 = 0;\n    long factorCount18 = 0;\n    long factorCount19\
    \ = 0;\n    long factorCount20 = 0;\n    long factorCount21 = 0;\n    long factorCount22\
    \ = 0;\n    long factorCount23 = 0;\n    long factorCount24 = 0;\n    long factorCount25\
    \ = 0;\n    long factorCount26 = 0;\n    long factorCount27 = 0;\n    long factorCount28\
    \ = 0;\n    long factorCount29 = 0;\n    long factorCount30 = 0;\n    long factorCount31\
    \ = 0;\n    long factorCount32 = 0;\n    long factorCount33 = 0;\n    long factorCount34\
    \ = 0;\n    long factorCount35 = 0;\n    long factorCount36 = 0;\n    long factorCount37\
    \ = 0;\n    long factorCount38 = 0;\n    long factorCount39 = 0;\n    long factorCount40\
    \ = 0;\n    long factorCount41 = 0;\n    long factorCount42 = 0;\n    long factorCount43\
    \ = 0;\n    long factorCount44 = 0;\n    long factorCount45 = 0;\n    long factorCount46\
    \ = 0;\n    long factorCount47 = 0;\n    long factorCount48 = 0;\n    long factorCount49\
    \ = 0;\n    long factorCount50 = 0;\n    long factorCount51 = 0;\n    long factorCount52\
    \ = 0;\n    long factorCount53 = 0;\n    long factorCount54 = 0;\n    long factorCount55\
    \ = 0;\n    long factorCount56 = 0;\n    long factorCount57 = 0;\n    long factorCount58\
    \ = 0;\n    long factorCount59 = 0;\n    long factorCount60 = 0;\n    long factorCount61\
    \ = 0;\n    long factorCount62 = 0;\n    long factorCount63 = 0;\n    long factorCount64\
    \ = 0;\n    long factorCount65 = 0;\n    long factorCount66 = 0;\n    long factorCount67\
    \ = 0;\n    long factorCount68 = 0;\n    long factorCount69 = 0;\n    long factorCount70\
    \ = 0;\n    long factorCount71 = 0;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk172wily.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpk172wily.d(84):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpk172wily.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = n;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp104jau1g.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp104jau1g.d(112):
    Error: no identifier for declarator long\n/tmp/tmp104jau1g.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp104jau1g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    for(int\
    \ i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n         \
    \   n /= i;\n            factors[counter++] = i;\n        }\n    }\n    factors[counter++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n\
    \    for(int i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n\
    \            n /= i;\n            factors[counter++] = i;\n        }\n       \
    \ if(counter == maxFactors)\n        {\n            break;\n        }\n    }\n\
    \    factors[counter++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int minFactors) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n   \
    \ long factor = 1;\n    long counter = 1;\n    for(int i = 2; i <= n; i++)\n \
    \   {\n        while(n % i == 0)\n        {\n            n /= i;\n           \
    \ factors[counter++] = i;\n        }\n        if(counter == maxFactors)\n    \
    \    {\n            break;\n        }\n        if(counter == minFactors)\n   \
    \     {\n            break;\n        }\n    }\n    factors[counter++] = n;\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int minFactors, int maxPrimes)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            n /= i;\n            factors[counter++] =\
    \ i;\n        }\n        if(\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcxu_ntm0.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcxu_ntm0.d(33):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcxu_ntm0.d(59):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcxu_ntm0.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcxu_ntm0.d(100):
    Error: expression expected, not \''unittest\''\n/tmp/tmpcxu_ntm0.d(101): Error:
    found \''{\'' when expecting \'')\''\n/tmp/tmpcxu_ntm0.d(113): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpcxu_ntm0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    std.typecons.PrimeFactors pf = std.typecons.PrimeFactors.factorize(n);\n\
    \    for(int i = 0; i < factors.length; i++)\n    {\n        factors[i] = pf.getFactor(i);\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.typecons.PrimeFactors\
    \ pf = std.typecons.PrimeFactors.factorize(n);\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        factors[i] = pf.getFactor(i);\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, long[] factors, int start) \n{\n    std.typecons.PrimeFactors pf = std.typecons.PrimeFactors.factorize(n);\n\
    \    for(int i = start; i < factors.length; i++)\n    {\n        factors[i] =\
    \ pf.getFactor(i);\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors, int start, int\
    \ end) \n{\n    std.typecons.PrimeFactors pf = std.typecons.PrimeFactors.factorize(n);\n\
    \    for(int i = start; i < end; i++)\n    {\n        factors[i] = pf.getFactor(i);\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end, int step)\
    \ \n{\n    std.typecons.PrimeFactors pf = st\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbhmd_sl7.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpbhmd_sl7.d(73):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmpbhmd_sl7.d(73): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbhmd_sl7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % i ==\
    \ 0)\n        {\n            factors[factorCount] = i;\n            n /= i;\n\
    \            factorCount++;\n        }\n    }\n    factors[factorCount] = n;\n\
    \    return factors;\n}\n</code>\n<|/ a tags=c#,algorithm,primes |>\n<| c |>\n\
    This code doesn't work. Try it for n = 100. You'll get factors = { 1, 3, 5 }.\
    \ That's not what OP wants.\n<|/ c |>\n<| c |>\nI tested it and it works. I got\
    \ factors = { 1, 3, 5 }. OP wants factors = { 1, 2, 3, 5, 7 }\n<|/ c |>\n<| c\
    \ |>\nThe OP wants factors = { 1, 2, 3, 5, 7 }. Your code returns factors = {\
    \ 1, 3, 5 }. Try it for n = 100. You'll get factors = { 1, 3, 5 }. That's not\
    \ what OP wants.\n<|/ c |>\n<| c |>\nI tested it and it works. I got factors =\
    \ { 1, 3, 5 }. OP wants factors = { 1, 2, 3, 5, 7 }\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works. I got factors = { 1, 3, 5 }. OP wants factors = { 1, 2, 3,\
    \ 5, 7 }\n<|/ c |>\n<| a dscore=2 |>\nI wrote a C# version based on this answer.\
    \ \n<code>\npublic static IEnumerable<int> GetPrimeFactors(int number)\n{\n  \
    \  if (number < 2)\n    {\n        yield break;\n    }\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmple5m7aot.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmple5m7aot.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmple5m7aot.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmple5m7aot.d(29): Error: unterminated
    character constant\n/tmp/tmple5m7aot.d(29): Error: unterminated character constant\n/tmp/tmple5m7aot.d(29):
    Error: unterminated character constant\n/tmp/tmple5m7aot.d(35): Error: unterminated
    character constant\n/tmp/tmple5m7aot.d(35): Error: unterminated character constant\n/tmp/tmple5m7aot.d(51):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmple5m7aot.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbad29qcj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbad29qcj.d(112):
    Error: no identifier for declarator long\n/tmp/tmpbad29qcj.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbad29qcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long counter = 1;\n  \
    \  long temp;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n      \
    \  temp = factor;\n        while(temp <= n)\n        {\n            if(n % temp\
    \ == 0)\n            {\n                counter++;\n                factors[(int)Math.sqrt(n)-i]\
    \ = counter;\n                n /= temp;\n            }\n            else\n  \
    \          {\n                temp++;\n            }\n        }\n        factors[(int)Math.sqrt(n)-i]\
    \ = counter;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long\
    \ factor = 1;\n    long counter = 1;\n    long temp;\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        temp = factor;\n        while(temp <=\
    \ n)\n        {\n            if(n % temp == 0)\n            {\n              \
    \  counter++;\n                factors[(int)Math.sqrt(n)-i] = counter;\n     \
    \           n /= temp;\n            }\n            else\n            {\n     \
    \           temp++;\n            }\n        }\n        factors[(int)Math.sqrt(n)-i]\
    \ = counter;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors, int start) \n\
    {\n    long factor = 1;\n    long counter = 1;\n    long temp;\n    for(int i\
    \ = start; i <= (int)Math.sqrt(n); i++)\n    {\n        temp = factor;\n     \
    \   while(temp <= n)\n        {\n            if(n % temp == 0)\n            {\n\
    \                counter++;\n                factors[(int)Math.sqrt(n)-i] = counter;\n\
    \                n /= temp;\n            }\n            else\n            {\n\
    \                temp++;\n            }\n        }\n        factors[(int)Math.sqrt(n)-i]\
    \ = counter;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all \n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0benh872.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(23):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(31):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(46):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(54):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(62):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(85):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(93):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0benh872.d(97):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0benh872.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % p == 0)\n        {\n            factors[i] =\
    \ p;\n            n /= p;\n        }\n        p++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe question was about finding prime factors, not\
    \ about finding prime numbers.\n<|/ c |>\n<| c |>\nThis code does not work. Try\
    \ it out with n = 10. You'll get factors = [1, 3, 5]. That's not what OP wants.\n\
    <|/ c |>\n<| c |>\nI didn't see that OP wanted prime factors. I thought he wanted\
    \ prime numbers. I edited my answer to include a solution for prime factors.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution for prime factors.\n\
    <|/ c |>\n<| c |>\nThe question was about finding prime factors, not about finding\
    \ prime numbers.\n<|/ c |>\n<| a tags=algorithm,c#,primes |>\n<code>\npublic static\
    \ List<int> GetPrimeFactors(int number)\n{\n    List<int> factors = new List<int>();\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7ghnihci.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp7ghnihci.d(24):
    Error: Declaration expected, not \''<\''\n/tmp/tmp7ghnihci.d(30): Error: unterminated
    character constant\n/tmp/tmp7ghnihci.d(30): Error: unterminated character constant\n/tmp/tmp7ghnihci.d(33):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp7ghnihci.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    long\
    \ temp;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        temp\
    \ = factor;\n        while(temp <= n)\n        {\n            if(n % temp == 0)\n\
    \            {\n                counter++;\n                factor *= temp;\n\
    \                break;\n            }\n            temp++;\n        }\n     \
    \   factors[i] = counter;\n        counter = 1;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,primes,factorization,java |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn3p2q4tt.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn3p2q4tt.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpn3p2q4tt.d(33):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpn3p2q4tt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    \n    while(p > 1)\n    {\n        factors[factorCount]\
    \ = p;\n        factorCount++;\n        \n        for(int i = factorCount; i >\
    \ 0; i--)\n        {\n            factor *= factors[i - 1];\n            p /=\
    \ factors[i - 1];\n        }\n    }\n    \n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long\
    \ p = n;\n    long factor = 1;\n    long factorCount = 0;\n    \n    while(p >\
    \ 1)\n    {\n        factors[factorCount] = p;\n        factorCount++;\n     \
    \   \n        for(int i = factorCount; i > maxFactors; i--)\n        {\n     \
    \       factor *= factors[i - 1];\n            p /= factors[i - 1];\n        }\n\
    \    }\n    \n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    \n    while(p > 1)\n    {\n    \
    \    factors[factorCount] = p;\n        factorCount++;\n        \n        for(int\
    \ i = factorCount; i > maxFactorsCount; i--)\n        {\n            factor *=\
    \ factors[i - 1];\n            p /= factors[i - 1];\n        }\n    }\n    \n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCount2)\
    \ \n{\n    long[] \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzxrfsxn_.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpzxrfsxn_.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpzxrfsxn_.d(65):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpzxrfsxn_.d(93):
    Error: no identifier for declarator long[]\n/tmp/tmpzxrfsxn_.d(93): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpzxrfsxn_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        factors[i] = factor;\n        factorCount++;\n        factor *=\
    \ i;\n    }\n    for(int i = factorCount; i >= 0; i--)\n    {\n        factorProduct\
    \ *= factors[i];\n        for(int j = factorCount; j > i; j--)\n        {\n  \
    \          if(factors[j] % factors[i] == 0)\n            {\n                factors[j]\
    \ = factors[j] / factors[i];\n                factorCount--;\n            }\n\
    \        }\n    }\n    for(int i = factorCount; i >= 0; i--)\n    {\n        factors[i]\
    \ *= factorProduct;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize)\
    \ \n{\n    long[] factors = new long[factorizationSize];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorProduct = 1;\n    for(int i = 0; i\
    \ <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n\
    \        factor *= i;\n    }\n    for(int i = factorCount; i >= 0; i--)\n    {\n\
    \        factorProduct *= factors[i];\n        for(int j = factorCount; j > i;\
    \ j--)\n        {\n            if(factors[j] % factors[i] == 0)\n            {\n\
    \                factors[j] = factors[j] / factors[i];\n                factorCount--;\n\
    \            }\n        }\n    }\n    for(int i = factorCount; i >= 0; i--)\n\
    \    {\n        factors[i] *= factorProduct;\n    }\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize, int factorizationMaxSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    long factorProduct = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n        factor\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8g0vfebb.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g0vfebb.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g0vfebb.d(51):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g0vfebb.d(87):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g0vfebb.d(92):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmp8g0vfebb.d(105):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp8g0vfebb.d(105):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8g0vfebb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        factors[i] = factor;\n        factorCount++;\n        factorProduct\
    \ *= factor;\n        factor++;\n    }\n    factors[(int)Math.sqrt(n)] = factorProduct;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] *=\
    \ factorCount;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long factorProduct = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n        factorProduct\
    \ *= factor;\n        factor++;\n    }\n    factors[(int)Math.sqrt(n)] = factorProduct;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] *=\
    \ factorCount;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long factorProduct = 1;\n    for(int i =\
    \ 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n     \
    \   factorCount++;\n        factorProduct *= factor;\n        factor++;\n    }\n\
    \    factors[(int)Math.sqrt(n)] = factorProduct;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] *= factorCount;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product \nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ooobw5i.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(22):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(23):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(37):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(41):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(48):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(49):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(63):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(67):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(74):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(75):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ooobw5i.d(81):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ooobw5i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)std.math.gcd(n); i++)\n    {\n        factorCount\
    \ = 0;\n        for(int j = i; j <= (int)std.math.gcd(n); j++)\n        {\n  \
    \          if(n%j == 0)\n            {\n                factorCount++;\n     \
    \           factors[j] = factorCount;\n            }\n        }\n        if(factorCount\
    \ == 1)\n        {\n            factors[i] = factorCount;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)std.math.gcd(n); i++)\n\
    \    {\n        factorCount = 0;\n        for(int j = i; j <= (int)std.math.gcd(n);\
    \ j++)\n        {\n            if(n%j == 0)\n            {\n                factorCount++;\n\
    \                factors[j] = factorCount;\n            }\n        }\n       \
    \ if(factorCount == 1)\n        {\n            factors[i] = factorCount;\n   \
    \     }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int startIndex) \n{\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    for(int i = startIndex; i <= (int)std.math.gcd(n);\
    \ i++)\n    {\n        factorCount = 0;\n        for(int j = i; j <= (int)std.math.gcd(n);\
    \ j++)\n        {\n            if(n%j == 0)\n            {\n                factorCount++;\n\
    \                factors[j] = factorCount;\n            }\n        }\n       \
    \ if(factorCount == 1)\n        {\n            factors[i] = factorCount;\n   \
    \     }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmh8pnqf7.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(14):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(17):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(42):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(45):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(70):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(73):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpmh8pnqf7.d(95):
    Error: no identifier for declarator long[]\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmh8pnqf7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2)))+1];\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i=0;i<factors.length;i++)\n   \
    \ {\n        factors[i] = factor;\n        factorCount++;\n        while(factor*factor\
    \ <= n)\n        {\n            if(n%factor == 0)\n            {\n           \
    \     factorCount--;\n                factor *= factor;\n                factors[i]\
    \ = factor;\n            }\n            else\n            {\n                factor\
    \ *= factor;\n            }\n        }\n    }\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        factors[i] *= factorCount;\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8jct2iva.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)))\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8jct2iva.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n \
    \       factors[i] = 0;\n    for(int i=0;i<factors.length;i++)\n    {\n      \
    \  for(int j=0;j<factors.length;j++)\n        {\n            if(factors[i]*factors[j]\
    \ == n)\n            {\n                factors[i]++;\n                factors[j]--;\n\
    \                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n\
    \    for(int i=0;i<factors.length;i++)\n        factors[i] = 0;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        for(int j=0;j<factors.length;j++)\n        {\n            if(factors[i]*factors[j]\
    \ == n)\n            {\n                factors[i]++;\n                factors[j]--;\n\
    \                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2) \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n\
    \    for(int i=0;i<factors.length;i++)\n        factors[i] = 0;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        for(int j=0;j<factors.length;j++)\n        {\n            if(factors[i]*factors[j]\
    \ == n)\n            {\n                factors[i]++;\n                factors[j]--;\n\
    \                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n\
    \    for(int i=0;i<factors.length;i++)\n        factors[i] = 0;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        for(int \nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppkcvkz76.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppkcvkz76.d(36):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppkcvkz76.d(61):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppkcvkz76.d(86):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppkcvkz76.d(92):
    Error: no identifier for declarator int\n/tmp/tmppkcvkz76.d(92): Error: expression
    expected, not \''unittest\''\n/tmp/tmppkcvkz76.d(93): Error: found \''{\'' when
    expecting \'';\'' following for condition\n/tmp/tmppkcvkz76.d(94): Error: expression
    expected, not \''alias\''\n/tmp/tmppkcvkz76.d(94): Error: found \''candidate\''
    when expecting \'')\''\n/tmp/tmppkcvkz76.d(94): Error: found \''=\'' instead of
    statement\n/tmp/tmppkcvkz76.d(105): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppkcvkz76.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 1; i < result.length; i++) \n    {\n  \
    \      while(n % factor == 0) \n        {\n            result[i] = factor;\n \
    \           n /= factor;\n        }\n        factor++;\n    }\n    if(n > 1) \n\
    \    {\n        result[result.length-1] = n;\n    }\n    return result;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n    long\
    \ factor = 1;\n    for(int i = 1; i < result.length; i++) \n    {\n        while(n\
    \ % factor == 0) \n        {\n            result[i] = factor;\n            n /=\
    \ factor;\n        }\n        factor++;\n    }\n    if(n > 1) \n    {\n      \
    \  result[result.length-1] = n;\n    }\n    return result;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ max, int factorization) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    for(int i = 1; i < result.length; i++) \n    {\n  \
    \      while(n % factor == 0) \n        {\n            result[i] = factor;\n \
    \           n /= factor;\n        }\n        factor++;\n    }\n    if(n > 1) \n\
    \    {\n        result[result.length-1] = n;\n    }\n    return result;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int factorization, int factorization2) \n{\n    long[] result =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 1; i < result.length;\
    \ i++) \n    {\n        while(n % factor == 0) \n        {\n            result[i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   if(n > 1) \n    {\n        result[result.length-1] = n;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_0xhxd_l.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp_0xhxd_l.d(36):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp_0xhxd_l.d(61):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp_0xhxd_l.d(86):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_0xhxd_l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    std.math.factorize(n,\
    \ factors);\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,\
    \ factors);\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,\
    \ factors, start);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors, int start, int\
    \ end) \n{\n    std.math.factorize(n, factors, start, end);\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, long[] factors, int start, int end, int step) \n{\n    std.math.factorize(n,\
    \ factors, start, end, step);\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, long[] factors,\
    \ int start, int end, int step, long max) \n{\n    std.math.factorize(n, factors,\
    \ start, end, step, max);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factor\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpubu30945.d(70): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpubu30945.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        while(n % factor ==\
    \ 0) {\n            factors[factorCount++] = factor;\n            n /= factor;\n\
    \        }\n        factor *= i;\n    }\n    factors[factorCount++] = n;\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        while(n % factor\
    \ == 0) {\n            factors[factorCount++] = factor;\n            n /= factor;\n\
    \        }\n        factor *= i;\n    }\n    factors[factorCount++] = n;\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime) \n{\n \
    \   long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n  \
    \  long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % factor == 0) {\n            factors[factorCount++] = factor;\n\
    \            n /= factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime, bool\
    \ isPrimeOnly) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(n % factor == 0) {\n            factors[factorCount++]\
    \ = factor;\n            \nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpipi37zj7.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(32):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(35):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(53):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(56):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(74):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpipi37zj7.d(81):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpipi37zj7.d(94): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpipi37zj7.d(94):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpipi37zj7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorIndex = 0;\n    long factorCount2 = 0;\n    long factorIndex2\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[factorIndex]\
    \ = factor;\n        factorCount++;\n        factorIndex++;\n        factor *=\
    \ i;\n    }\n    for(int i = factorIndex; i < (int)Math.sqrt(n); i++)\n    {\n\
    \        factors[factorIndex2] = factor;\n        factorCount2++;\n        factorIndex2++;\n\
    \        factor *= i;\n    }\n    for(int i = factorIndex2; i < (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(factors[factorIndex] == factors[factorIndex2])\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            factors[factorIndex] = factors[factorIndex2];\n         \
    \   factorCount--;\n            factorCount2--;\n        }\n    }\n    for(int\
    \ i = 0; i < (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n   \
    \     {\n            \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx40smf_x.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(17):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(24):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(31):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(40):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(49):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(58):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(67):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(76):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(85):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(94):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx40smf_x.d(99):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpx40smf_x.d(112): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpx40smf_x.d(112):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx40smf_x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/2)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorCount] = factor;\n                factorCount++;\n     \
    \           n /= factor;\n            }\n            else\n            {\n   \
    \             factor++;\n            }\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,math,c# |>\n\
    <| a tags=algorithm,primes,math,c# |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp36cc6huk.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / 2)\n/tmp/tmp36cc6huk.d(33): Error: Declaration expected, not \''<\''\n/tmp/tmp36cc6huk.d(38):
    Error: semicolon expected, not \''.\''\n/tmp/tmp36cc6huk.d(38): Error: no identifier
    for declarator .Collections.Generic\n/tmp/tmp36cc6huk.d(39): Error: semicolon
    expected, not \''.\''\n/tmp/tmp36cc6huk.d(39): Error: no identifier for declarator
    .Linq\n/tmp/tmp36cc6huk.d(40): Error: semicolon expected, not \''.\''\n/tmp/tmp36cc6huk.d(40):
    Error: no identifier for declarator .Text\n/tmp/tmp36cc6huk.d(41): Error: semicolon
    expected, not \''.\''\n/tmp/tmp36cc6huk.d(41): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36cc6huk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i] = factor;\n            n /= p;\n        }\n     \
    \   p++;\n        factor++;\n    }\n    return factors;\n}\n</code>\n<|/ a tags=c++,algorithm,primes\
    \ |>\n<| c |>\nThis code is not correct. For example, factorize(12) returns [2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeblou769.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpeblou769.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpeblou769.d(26): Error: Declaration
    expected, not \''<\''\n/tmp/tmpeblou769.d(34): Error: Declaration expected, not
    \''assert\''\n/tmp/tmpeblou769.d(35): Error: Declaration expected, not \''assert\''\n/tmp/tmpeblou769.d(36):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpeblou769.d(37): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpeblou769.d(38): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpeblou769.d(39): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpeblou769.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmpeblou769.d(41):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpeblou769.d(42): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeblou769.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long temp = 1;\n    for(int\
    \ i = 0; i < factors.length; i++)\n    {\n        while(n % factor == 0)\n   \
    \     {\n            factors[(int)i] = factor;\n            n /= factor;\n   \
    \     }\n        factor++;\n    }\n    for(int i = factors.length - 1; i >= 0;\
    \ i--)\n    {\n        while(n % factors[i] == 0)\n        {\n            factors[(int)i]\
    \ = factors[i];\n            n /= factors[i];\n        }\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpihxbmi7w.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpihxbmi7w.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpihxbmi7w.d(27): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpihxbmi7w.d(33): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpihxbmi7w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factor++;\n     \
    \       n /= i;\n            factorCount++;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors) \n{\n    long[] factors = new long[(int)std.math.factorial(n)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factor++;\n            n /= i;\n            factorCount++;\n\
    \            if(factorCount == maxFactors)\n                break;\n        }\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n\
    \    long[] factors = new long[(int)std.math.factorial(n)];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n    \
    \    while(n % i == 0)\n        {\n            factors[factorCount] = i;\n   \
    \         factor++;\n            n /= i;\n            factorCount++;\n       \
    \     if(factorCount == maxFactors && maxFactorsCount == 0)\n                break;\n\
    \            if(factorCount == maxFactors && maxFactorsCount > 0)\n          \
    \      break;\n            if(factorCount == maxFactors && maxFactorsCount > 1)\n\
    \                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 2)\n                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 3)\n                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 4)\n                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 5)\n                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 6)\n                break;\n            if(factorCount == maxFactors && maxFactorsCount\
    \ > 7)\n                break;\n            if(factorCount == \nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9z_tuzbo.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp9z_tuzbo.d(34):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp9z_tuzbo.d(59):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp9z_tuzbo.d(89):
    Error: expression expected, not \''unittest\''\n/tmp/tmp9z_tuzbo.d(90): Error:
    found \''{\'' when expecting \'')\''\n/tmp/tmp9z_tuzbo.d(102): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmp9z_tuzbo.d(102):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9z_tuzbo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[(int)i]\
    \ = factor;\n        factor *= i;\n        factorCount++;\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factor;\n    factorCount++;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        while(factorCount > 0)\n        {\n            factor *= factors[i];\n\
    \            factorCount--;\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbm79702i.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbm79702i.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbm79702i.d(16):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpbm79702i.d(20): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbm79702i.d(22): Error:
    C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbm79702i.d(32): Error:
    Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbm79702i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    std.math.factorize(n,factors);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,factors,start);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end) \n{\n\
    \    std.math.factorize(n,factors,start,end);\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, long[]\
    \ factors, int start, int end, int step) \n{\n    std.math.factorize(n,factors,start,end,step);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end, int step,\
    \ long mod) \n{\n    std.math.factorize(n,factors,start,end,step,mod);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appe\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1l5grd5w.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmp1l5grd5w.d(70):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1l5grd5w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, int factorizationMax)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long factor = 1;\n    for(int i = 0; i<factors.length; i++)\n    {\n      \
    \  while(n % p == 0)\n        {\n            factors[(int)i]++;\n            n\
    \ /= p;\n        }\n        p++;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationSize, int factorizationMax, bool isPrime) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmporhkdets.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmporhkdets.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmporhkdets.d(33): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmporhkdets.d(40): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmporhkdets.d(55): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmporhkdets.d(62): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmporhkdets.d(77): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmporhkdets.d(84): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmporhkdets.d(91): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporhkdets.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    for(int i = 1; i <= n;\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            factors[(int)std.math.gcd(n)]\
    \ += 1;\n            n /= i;\n        }\n    }\n    for(int i = 1; i <= n; i++)\n\
    \    {\n        factors[(int)std.math.gcd(n)] += factor;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder) \n{\n    long factors[] = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[(int)std.math.gcd(n)] += 1;\n    \
    \        n /= i;\n        }\n    }\n    for(int i = 1; i <= n; i++)\n    {\n \
    \       factors[(int)std.math.gcd(n)] += factor;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder, bool isPrime)\n{\n    long factors[] = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[(int)std.math.gcd(n)] += 1;\n    \
    \        n /= i;\n        }\n    }\n    for(int i = 1; i <= n; i++)\n    {\n \
    \       factors[(int)std.math.gcd(n)] += factor;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder, bool isPrime, bool isPrimeToPrime)\n{\n    long factors[]\
    \ = new long[(int)std.math.gcd(n)];\n    long factor = 1;\n    for(int i = 1;\
    \ i <= n; i++)\n    {\n        \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoj_03bg1.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(17):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(23):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(35):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(41):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(47):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(59):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(65):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(71):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(83):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpoj_03bg1.d(88):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpoj_03bg1.d(101): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpoj_03bg1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorProduct\
    \ = 1;\n    long factorProductCount = 0;\n    long factorProductCount2 = 0;\n\
    \    long factorProductCount3 = 0;\n    long factorProductCount4 = 0;\n    long\
    \ factorProductCount5 = 0;\n    long factorProductCount6 = 0;\n    long factorProductCount7\
    \ = 0;\n    long factorProductCount8 = 0;\n    long factorProductCount9 = 0;\n\
    \    long factorProductCount10 = 0;\n    long factorProductCount11 = 0;\n    long\
    \ factorProductCount12 = 0;\n    long factorProductCount13 = 0;\n    long factorProductCount14\
    \ = 0;\n    long factorProductCount15 = 0;\n    long factorProductCount16 = 0;\n\
    \    long factorProductCount17 = 0;\n    long factorProductCount18 = 0;\n    long\
    \ factorProductCount19 = 0;\n    long factorProductCount20 = 0;\n    long factorProductCount21\
    \ = 0;\n    long factorProductCount22 = 0;\n    long factorProductCount23 = 0;\n\
    \    long factorProductCount24 = 0;\n    long factorProductCount25 = 0;\n    long\
    \ factorProductCount26 = 0;\n    long factorProductCount27 = 0;\n    long factorProductCount28\
    \ = 0;\n    long factorProductCount29 = 0;\n    long factorProductCount30 = 0;\n\
    \    long factorProductCount31 = 0;\n    long factorProductCount32 = 0;\n    long\
    \ factorProductCount33 = 0;\n    long factorProductCount34 = 0;\n    long factorProductCount35\
    \ = 0;\n    long factorProductCount36 = 0;\n    long factorProductCount37 = 0;\n\
    \    long factorProductCount38 = 0;\n    long factorProductCount39 = 0;\n    long\
    \ factorProductCount40 = 0;\n    long factorProductCount41 = 0;\n    long factorProductCount42\
    \ = 0;\n    long factorProductCount43 = 0;\n    long factorProductCount44 = 0;\n\
    \    long factorProductCount45 = 0;\n    long factorProductCount46 = 0;\n    long\
    \ factorProductCount47 = 0;\n    long factorProductCount48 = 0;\n    long factorProductCount49\
    \ = 0;\n    long factorProductCount50 = 0;\n    long factorProductCount51 = 0;\n\
    \    long factorProductCount52 = 0;\n    long factorProductCount53 = 0;\n    long\
    \ factorProductCount54 = 0;\n    long factorProductCount55 = 0;\n    long factorProductCount56\
    \ = 0;\n    long factorProductCount57 = 0;\n    long factorProductCount58 = 0;\n\
    \    long factorProductCount59 = 0;\n    long factorProductCount60 = 0;\n    long\
    \ factorProductCount61 = 0;\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp764xb7mu.d(76): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp764xb7mu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long count = 0;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++) {\n        while(n % factor == 0) {\n  \
    \          factors[count++] = factor;\n            n /= factor;\n        }\n \
    \       factor++;\n    }\n    factors[count++] = n;\n    return factors;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis code doesn't work. For example, factorize(100)\
    \ returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7c2c5x4u.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp7c2c5x4u.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp7c2c5x4u.d(24):
    Error: Declaration expected, not \''<\''\n/tmp/tmp7c2c5x4u.d(27): Error: unterminated
    character constant\n/tmp/tmp7c2c5x4u.d(32): Error: Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(33):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(34): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(35): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(36): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp7c2c5x4u.d(37): Error: Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(38):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(39): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp7c2c5x4u.d(40): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7c2c5x4u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        factors[i] = factor;\n       \
    \ factor *= i;\n        while(p <= n)\n        {\n            if(n%p == 0)\n \
    \           {\n                factors[i] = factor;\n                factor *=\
    \ p;\n                break;\n            }\n            p++;\n        }\n   \
    \ }\n    return factors;\n}\n</code>\n<|/ a tags=primes,math,algorithm,java |>\n\
    <| c |>\nI like this solution, but I wonder if it will scale well for large numbers.\
    \ I suspect it won't, but I'm not sure. Also, I think it would be better to use\
    \ a `long` array rather than a `double` array for the factors.\n<|/ c |>\n<| c\
    \ |>\nI agree with you. My solution is just for educational purposes. I didn't\
    \ want to use any library for factorization. Also I didn't want to use any library\
    \ for prime number checking. My solution was just for educational purposes. I\
    \ didn't want to use any library for factorization. Also I didn't want to use\
    \ any library for prime number checking.\n<|/ c |>\n<| c |>\nI agree with you.\
    \ My solution is just for educational purposes. I didn't want to use any library\
    \ for factorization. Also I didn't want to use any library for prime number checking.\
    \ My solution was just for educational purposes. I didn't want to use any library\
    \ for factorization. Also I didn't want to use any library for prime number checking.\n\
    <|/ c |>\n<| c |>\nI agree with you. My solution is just for educational purposes.\
    \ I didn't want to use any library for factorization. Also I didn't want to use\
    \ any library for prime number checking. My solution was just for educational\
    \ purposes. I didn't want to use any library for factorization. Also I didn't\
    \ want to use any library for prime number checking.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. My solution is just for educational purposes. I didn't want to use\
    \ any library for factorization. Also I didn't want to use any library for prime\
    \ number checking. My solution was just for educational purposes. I didn't want\
    \ to use any library for factorization. Also I didn't want to use any library\
    \ for prime number checking.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a program to\
    \ find prime numbers in Java. Hope this help\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx57sap63.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpx57sap63.d(31):
    Error: Declaration expected, not \''<\''\n/tmp/tmpx57sap63.d(34): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(34): Error: unterminated character constant\n/tmp/tmpx57sap63.d(37):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(37): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(37): Error: unterminated character constant\n/tmp/tmpx57sap63.d(37):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(40): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(40): Error: unterminated character constant\n/tmp/tmpx57sap63.d(40):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(40): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(43): Error: unterminated character constant\n/tmp/tmpx57sap63.d(43):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(43): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(43): Error: unterminated character constant\n/tmp/tmpx57sap63.d(46):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(46): Error: unterminated
    character constant\n/tmp/tmpx57sap63.d(46): Error: unterminated character constant\n/tmp/tmpx57sap63.d(46):
    Error: unterminated character constant\n/tmp/tmpx57sap63.d(54): Error: Declaration
    expected, not \''assert\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx57sap63.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))+1];\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n    long\
    \ factorsSum = 0;\n    for(int i = 0; i <= (int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)));\
    \ i++) {\n        factorsSum += factor;\n        factors[factorIndex++] = factor;\n\
    \        factor *= i;\n        factorCount += 1;\n        if(factorCount > std.math.max(1,(int)std.math.log(n,2))\
    \ && factorsSum > n) {\n            factors[factorIndex++] = factorsSum;\n   \
    \         factorsSum = 1;\n            factorCount -= 1;\n        }\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))+1];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n\
    \    long factorsSum = 0;\n    for(int i = 0; i <= (int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)));\
    \ i++) {\n        factorsSum += factor;\n        factors[factorIndex++] = factor;\n\
    \        factor *= i;\n        factorCount += 1;\n        if(factorCount > maxFactors\
    \ && factorsSum > n) {\n            factors[factorIndex++] = factorsSum;\n   \
    \         factorsSum = 1;\n            factorCount -= 1;\n        }\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsSum) \n{\n \
    \   long[] factors = new long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))+1];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n\
    \    long factors\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpac0su0d_.d(11): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpac0su0d_.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, cast(int)std.math.log(n, 2)))\n/tmp/tmpac0su0d_.d(16): Error:
    C style cast illegal, use cast(int)std.math.log(n, 2)\n/tmp/tmpac0su0d_.d(16):
    Error: C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, cast(int)std.math.log(n,
    2)))\n/tmp/tmpac0su0d_.d(21): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpac0su0d_.d(37): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpac0su0d_.d(37): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, cast(int)std.math.log(n, 2)))\n/tmp/tmpac0su0d_.d(42): Error:
    C style cast illegal, use cast(int)std.math.log(n, 2)\n/tmp/tmpac0su0d_.d(42):
    Error: C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, cast(int)std.math.log(n,
    2)))\n/tmp/tmpac0su0d_.d(63): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpac0su0d_.d(63): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, cast(int)std.math.log(n, 2)))\n/tmp/tmpac0su0d_.d(68): Error:
    semicolon expected, not \''unittest\''\n/tmp/tmpac0su0d_.d(68): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpac0su0d_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factorCount] = factor;\n            factorCount++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8_vf6td5.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8_vf6td5.d(27):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8_vf6td5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long product\
    \ = n;\n    long factorization[] = new long[100];\n    long factorizationCount\
    \ = 0;\n    long temp;\n    long tempCount = 0;\n    long tempCount2 = 0;\n  \
    \  long tempCount3 = 0;\n    long tempCount4 = 0;\n    long tempCount5 = 0;\n\
    \    long tempCount6 = 0;\n    long tempCount7 = 0;\n    long tempCount8 = 0;\n\
    \    long tempCount9 = 0;\n    long tempCount10 = 0;\n    long tempCount11 = 0;\n\
    \    long tempCount12 = 0;\n    long tempCount13 = 0;\n    long tempCount14 =\
    \ 0;\n    long tempCount15 = 0;\n    long tempCount16 = 0;\n    long tempCount17\
    \ = 0;\n    long tempCount18 = 0;\n    long tempCount19 = 0;\n    long tempCount20\
    \ = 0;\n    long tempCount21 = 0;\n    long tempCount22 = 0;\n    long tempCount23\
    \ = 0;\n    long tempCount24 = 0;\n    long tempCount25 = 0;\n    long tempCount26\
    \ = 0;\n    long tempCount27 = 0;\n    long tempCount28 = 0;\n    long tempCount29\
    \ = 0;\n    long tempCount30 = 0;\n    long tempCount31 = 0;\n    long tempCount32\
    \ = 0;\n    long tempCount33 = 0;\n    long tempCount34 = 0;\n    long tempCount35\
    \ = 0;\n    long tempCount36 = 0;\n    long tempCount37 = 0;\n    long tempCount38\
    \ = 0;\n    long tempCount39 = 0;\n    long tempCount40 = 0;\n    long tempCount41\
    \ = 0;\n    long tempCount42 = 0;\n    long tempCount43 = 0;\n    long tempCount44\
    \ = 0;\n    long tempCount45 = 0;\n    long tempCount46 = 0;\n    long tempCount47\
    \ = 0;\n    long tempCount48 = 0;\n    long tempCount49 = 0;\n    long tempCount50\
    \ = 0;\n    long tempCount51 = 0;\n    long tempCount52 = 0;\n    long tempCount53\
    \ = 0;\n    long tempCount54 = 0;\n    long tempCount55 = 0;\n    long tempCount56\
    \ = 0;\n    long tempCount57 = 0;\n    long tempCount58 = 0;\n    long tempCount59\
    \ = 0;\n    long tempCount60 = 0;\n    long tempCount61 = 0;\n    long tempCount62\
    \ = 0;\n    long tempCount63 = 0;\n    long tempCount64 = 0;\n    long tempCount65\
    \ = 0;\n    long tempCount66 = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprpsevobw.d(85): Error: no identifier for declarator long\n/tmp/tmprpsevobw.d(85):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprpsevobw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factor_count = 1;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factor_count\
    \ = 1;\n        while(n % i == 0)\n        {\n            factor_count++;\n  \
    \          n /= i;\n        }\n        factors[i] = factor_count;\n        factor\
    \ *= i;\n    }\n    return factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\
    import java.util.stream.Collectors;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpynjv3wxf.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpynjv3wxf.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpynjv3wxf.d(27):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpynjv3wxf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n\
    \        {\n            factorCount++;\n            factors[i] = factor;\n   \
    \         factor *= i;\n        }\n    }\n    return factors;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf88rjq0m.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf88rjq0m.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpf88rjq0m.d(25):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpf88rjq0m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[(int)std.math.factorial(n)];\n    long factorizationCount = 0;\n\
    \    long factorizationIndex = 0;\n    long factorizationMax = 0;\n    long factorizationMin\
    \ = Long.MAX_VALUE;\n    long factorizationSum = 0;\n    long factorizationProduct\
    \ = 1;\n    long factorizationProductMin = Long.MAX_VALUE;\n    long factorizationProductMax\
    \ = Long.MIN_VALUE;\n    long factorizationProductSum = 0;\n    long factorizationProductProduct\
    \ = 1;\n    long factorizationProductProductMin = Long.MAX_VALUE;\n    long factorizationProductProductMax\
    \ = Long.MIN_VALUE;\n    long factorizationProductProductSum = 0;\n    long factorizationProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductMin = Long.MAX_VALUE;\n   \
    \ long factorizationProductProductProductMax = Long.MIN_VALUE;\n    long factorizationProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProduct = 1;\n    \n    for(int\
    \ i = 1; i <= n; i++)\n    {\n        factorization[factorizationCount] = i;\n\
    \        factorizationCount++;\n        factorizationSum += i;\n        factorizationProduct\
    \ = factorizationSum;\n        factorizationProductMin = std.math.min(factorizationProduct,\
    \ factorizationProductMin);\n        factorizationProductMax = std.math.max(factorizationProduct,\
    \ factorizationProductMax);\n        factorizationProductSum += factorizationProduct;\n\
    \        factorizationProductProduct *= factorizationProduct;\n        factorizationProductProductMin\
    \ = std.math.min(factorizationProductProduct, factorizationProductProductMin);\n\
    \        factorizationProductProductMax = std.math.max(factorizationProductProduct,\
    \ factorizationProductProductMax);\n        factorizationProductProductSum +=\
    \ factorizationProductProduct;\n        factorizationProductProductProduct *=\
    \ factorizationProductProduct;\n        factorizationProductProductProductMin\
    \ = std.math.min(factorizationProductProductProduct, factorizationProductProductProductMin);\n\
    \        factorizationProductProductProductMax = std.math.max(factorizationProductProductProduct,\
    \ factorizationProductProductProductMax);\n        factorizationProductProductProductSum\
    \ += factorizationProductProductProduct;\n        factorizationProductProductProductProduct\
    \ *= factorizationProductProductProduct;\n        factorizationProductProductProductProductMin\
    \ = std.math.min(factorizationProductProductProductProduct, factorizationProductProductProductProductMin);\n\
    \        factorizationProductProductProductProductMax = std.math.max(factorization\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5vgdzcxq.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp5vgdzcxq.d(51):
    Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmp5vgdzcxq.d(64): Error:
    found \''void\'' when expecting \'',\''\n/tmp/tmp5vgdzcxq.d(64): Error: found
    \''{\'' when expecting \'',\''\n/tmp/tmp5vgdzcxq.d(64): Error: expression expected,
    not \''}\''\n/tmp/tmp5vgdzcxq.d(64): Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp5vgdzcxq.d(64):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp5vgdzcxq.d(64): Error:
    found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmp5vgdzcxq.d(64):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp5vgdzcxq.d(64):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5vgdzcxq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n % i == 0)\n        {\n            factorCount++;\n\
    \            factor *= i;\n        }\n    }\n    for(int i = 0; i < result.length;\
    \ i++)\n    {\n        if(factorCount == 0)\n        {\n            result[i]\
    \ = factor;\n            factorCount++;\n        }\n        else\n        {\n\
    \            result[i] = factor * factorCount;\n            factorCount *= i;\n\
    \        }\n    }\n    return result;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[]\
    \ result = new long[maxFactors];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n % i\
    \ == 0)\n        {\n            factorCount++;\n            factor *= i;\n   \
    \     }\n    }\n    for(int i = 0; i < result.length; i++)\n    {\n        if(factorCount\
    \ == 0)\n        {\n            result[i] = factor;\n            factorCount++;\n\
    \        }\n        else\n        {\n            result[i] = factor * factorCount;\n\
    \            factorCount *= i;\n        }\n    }\n    return result;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCount) \n{\n    long[] result = new long[maxFactors];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n % i == 0)\n        {\n            factorCount++;\n\
    \            factor *= i;\n        }\n    }\n    for(int i = 0; i < result.length;\
    \ i++)\n    {\n        if(factorCount == 0)\n        {\n            result[i]\
    \ = factor;\n            factorCount++;\n        }\n        else\n        {\n\
    \            result[i] = factor * factorCount;\n            factorCount *= i;\n\
    \        }\n    }\n    return result;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    \nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkespf9ly.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpkespf9ly.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpkespf9ly.d(48):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpkespf9ly.d(82):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpkespf9ly.d(105):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkespf9ly.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = n;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(p % factor == 0)\n     \
    \   {\n            factors[(int)i] = factor;\n            p /= factor;\n     \
    \       factor++;\n        }\n    }\n    return factors;\n}\n</code>\n<|/ a tags=primes,java,algorithm,factorization\
    \ |>\n<| c |>\nThis code is not working with large numbers. Please suggest me\
    \ a better solution.\n<|/ c |>\n<| c |>\nThis code is not working with large numbers.\
    \ Please suggest me a better solution.\n<|/ c |>\n<| c |>\nThis code is not working\
    \ with large numbers. Please suggest me a better solution.\n<|/ c |>\n<| c |>\n\
    This code is not working with large numbers. Please suggest me a better solution.\n\
    <|/ c |>\n<| a dscore=5 |>\nI wrote a Java program to find all prime factors of\
    \ a given number in less than a second. \n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1o6f5232.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp1o6f5232.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp1o6f5232.d(25): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1o6f5232.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[std.math.factorial(n)];\n    long p = 1;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        factors[factorCount]\
    \ = i;\n        factorCount++;\n        factor *= i;\n    }\n    for(int i = 0;\
    \ i < factorCount; i++)\n    {\n        for(int j = i + 1; j < factorCount; j++)\n\
    \        {\n            if(factors[j] % factors[i] == 0)\n            {\n    \
    \            factors[j] /= factors[i];\n                factors[i] /= factors[j];\n\
    \                factors[j] = 1;\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < factorCount; i++)\n    {\n        if(factors[i] == 1)\n        {\n\
    \            factors[i] = 0;\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=c++,algorithm,primes |>\n<| c |>\nThis code is not correct. For example,\
    \ if n = 2, then factorize(2) returns [2,2] instead of [2,1]. Also, the first\
    \ for loop should be `for(int i = 0; i <= n; i++)`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out my mistakes. I fixed the code accordingly. Also I fixed the\
    \ mistake in the first for loop. Thanks again.\n<|/ c |>\n<| c |>\nThe first for\
    \ loop should be `for(int i = 0; i <= n; i++)` because `factorize(2)` returns\
    \ `[2,2]` instead of `[2,1]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I fixed the code accordingly.\n<|/ c |>\n<| c |>\nThe first for loop should\
    \ be `for(int i = 0; i <= n; i++)` because `factorize(2)` returns `[2,2]` instead\
    \ of `[2,1]`.\n<|/ c |>\n<| a dscore=4 |>\nI wrote a small program to find prime\
    \ numbers in C++.\n<code>\n#include <iostream>\n#include <math.h>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppvqii8fp.d(42): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppvqii8fp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i < result.length;\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n   \
    \         factorCount++;\n        }\n        result[i] = factorCount;\n      \
    \  factor *= i;\n    }\n    return result;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactor) \n{\n    long[]\
    \ result = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i < result.length; i++)\n    {\n        while(n % i\
    \ == 0)\n        {\n            n /= i;\n            factorCount++;\n        }\n\
    \        if(factorCount >= maxFactor)\n        {\n            break;\n       \
    \ }\n        result[i] = factorCount;\n        factor *= i;\n    }\n    return\
    \ result;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactor, bool isPrime) \n{\n    long[] result =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i < result.length; i++)\n    {\n        while(n % i == 0)\n\
    \        {\n            n /= i;\n            factorCount++;\n        }\n     \
    \   if(factorCount >= maxFactor)\n        {\n            break;\n        }\n \
    \       if(isPrime)\n        {\n            if(factorCount > 1)\n            {\n\
    \                result[i] = factorCount;\n                factor *= i;\n    \
    \        }\n            else\n            {\n                result[i] = 1;\n\
    \            }\n        }\n        else\n        {\n            if(factorCount\
    \ > 1)\n            {\n                result[i] = factorCount;\n            \
    \    factor *= i;\n            }\n            else\n            {\n          \
    \      result[i] = 1;\n            }\n        }\n    }\n    return result;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactor, bool isPri\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplh28239n.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplh28239n.d(34):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplh28239n.d(61):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmplh28239n.d(109):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplh28239n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))) + 1];\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    long factorCount2 = 0;\n    long\
    \ factorCount3 = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n\
    \    long factorCount6 = 0;\n    long factorCount7 = 0;\n    long factorCount8\
    \ = 0;\n    long factorCount9 = 0;\n    long factorCount10 = 0;\n    long factorCount11\
    \ = 0;\n    long factorCount12 = 0;\n    long factorCount13 = 0;\n    long factorCount14\
    \ = 0;\n    long factorCount15 = 0;\n    long factorCount16 = 0;\n    long factorCount17\
    \ = 0;\n    long factorCount18 = 0;\n    long factorCount19 = 0;\n    long factorCount20\
    \ = 0;\n    long factorCount21 = 0;\n    long factorCount22 = 0;\n    long factorCount23\
    \ = 0;\n    long factorCount24 = 0;\n    long factorCount25 = 0;\n    long factorCount26\
    \ = 0;\n    long factorCount27 = 0;\n    long factorCount28 = 0;\n    long factorCount29\
    \ = 0;\n    long factorCount30 = 0;\n    long factorCount31 = 0;\n    long factorCount32\
    \ = 0;\n    long factorCount33 = 0;\n    long factorCount34 = 0;\n    long factorCount35\
    \ = 0;\n    long factorCount36 = 0;\n    long factorCount37 = 0;\n    long factorCount38\
    \ = 0;\n    long factorCount39 = 0;\n    long factorCount40 = 0;\n    long factorCount41\
    \ = 0;\n    long factorCount42 = 0;\n    long factorCount43 = 0;\n    long factorCount44\
    \ = 0;\n    long factorCount45 = 0;\n    long factorCount46 = 0;\n    long factorCount47\
    \ = 0;\n    long factorCount48 = 0;\n    long factorCount49 = 0;\n    long factorCount50\
    \ = 0;\n    long factorCount51 = 0;\n    long factorCount52 = 0;\n    long factorCount53\
    \ = 0;\n    long factorCount54 = 0;\n    long factorCount55 = 0;\n    long factorCount56\
    \ = 0;\n    long factorCount57 = 0;\n    long factorCount58 = 0;\n    long factorCount59\
    \ = 0;\n    long factorCount60 = 0;\n    long factorCount61 = 0;\n    long factorCount62\
    \ = 0;\n    long factorCount63 = 0;\n    long factorCount64 = 0;\n    long factorCount65\
    \ = 0;\n    long factorCount66 = 0;\n    long factorCount67 = 0;\n    long factorCount68\
    \ = 0;\n    long factorCount\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8ak1cbt5.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)))\n/tmp/tmp8ak1cbt5.d(82): Error: semicolon
    expected, not \''unittest\''\n/tmp/tmp8ak1cbt5.d(82): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ak1cbt5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        factors[i] = factor;\n        factorCount++;\n        factorProduct =\
    \ factorProduct * factor;\n        factor++;\n    }\n    factors[factors.length-1]\
    \ = factorProduct;\n    for(int i = factors.length-2; i>=0; i--)\n    {\n    \
    \    while(factors[i] == factors[i+1])\n        {\n            factors[i]++;\n\
    \            factorCount++;\n        }\n    }\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        factors[i] = factors[i] * factorCount;\n    }\n    return\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptyxr8s8g.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyxr8s8g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= factor;\n        }\n        factor *= i;\n    }\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=c#,primes,algorithm |>\n<| a dscore=0 |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpptm2n755.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpptm2n755.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpptm2n755.d(24): Error: Declaration
    expected, not \''<\''\n/tmp/tmpptm2n755.d(29): Error: semicolon expected, not
    \''.\''\n/tmp/tmpptm2n755.d(29): Error: no identifier for declarator .Collections.Generic\n/tmp/tmpptm2n755.d(30):
    Error: semicolon expected, not \''.\''\n/tmp/tmpptm2n755.d(30): Error: no identifier
    for declarator .Linq\n/tmp/tmpptm2n755.d(31): Error: semicolon expected, not \''.\''\n/tmp/tmpptm2n755.d(31):
    Error: no identifier for declarator .Text\n/tmp/tmpptm2n755.d(32): Error: semicolon
    expected, not \''.\''\n/tmp/tmpptm2n755.d(32): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptm2n755.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = n;\n    long factor = 1;\n    for(int\
    \ i = 0; i < factors.length; i++)\n    {\n        while(p % factor == 0)\n   \
    \     {\n            factors[(int)i] = factor;\n            p /= factor;\n   \
    \         factor++;\n        }\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationOrder) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = n;\n    long factor = 1;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(p % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            p /= factor;\n            factor++;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n    long\
    \ factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n        while(p\
    \ % factor == 0)\n        {\n            factors[(int)i] = factor;\n         \
    \   p /= factor;\n            factor++;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder, bool isPrime, bool isPrimeToPrime) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n    long factor = 1;\n\
    \    for(int i = 0; i < factors.length; i++)\n    {\n        while(p % factor\
    \ == 0)\n        {\n            factors[(int)i] = factor;\n            p /= factor;\n\
    \            factor++;\n        }\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4j__wcce.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp4j__wcce.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp4j__wcce.d(33): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp4j__wcce.d(40): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmp4j__wcce.d(55): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp4j__wcce.d(62): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp4j__wcce.d(77): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmp4j__wcce.d(84): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp4j__wcce.d(91): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4j__wcce.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextpowof2(std.math.max(std.math.abs(n)))];\n    long factor =\
    \ 1;\n    long factor_count = 1;\n    for(int i = std.math.nextpowof2(std.math.max(std.math.abs(n)));\
    \ i >= 1; i--)\n    {\n        factor_count = 1;\n        for(int j = i; j >=\
    \ 1; j--)\n        {\n            if(n%j == 0)\n            {\n              \
    \  factor_count++;\n                factors[j] = factor_count;\n             \
    \   break;\n            }\n        }\n        factors[factor_count-1] = i;\n \
    \       factor++;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int factorization_type) \n{\n\
    \    long[] factors = new long[std.math.nextpowof2(std.math.max(std.math.abs(n)))];\n\
    \    long factor = 1;\n    long factor_count = 1;\n    for(int i = std.math.nextpowof2(std.math.max(std.math.abs(n)));\
    \ i >= 1; i--)\n    {\n        factor_count = 1;\n        for(int j = i; j >=\
    \ 1; j--)\n        {\n            if(n%j == 0)\n            {\n              \
    \  factor_count++;\n                factors[j] = factor_count;\n             \
    \   break;\n            }\n        }\n        factors[factor_count-1] = i;\n \
    \       factor++;\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int factorization_type, int max_factorization_size)\
    \ \n{\n    long[] factors = new long[std.math.nextpowof2(std.math.max(std.math.abs(n)))];\n\
    \    long factor = 1;\n    long factor_count = 1;\n    for(int i = std.math.nextpowof2(std.math.max(std.math.abs(n)));\
    \ i >= 1; i--)\n    {\n        factor_count = 1;\n        for(int j = i; j >=\
    \ 1; j--)\n        {\n            if(n%j == 0)\n            {\n              \
    \  factor_count++;\n                factors[j] = factor_count;\n             \
    \   break;\n            }\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpivf7o0eo.d(81): Error: found \''unittest\'' instead of statement\n/tmp/tmpivf7o0eo.d(94):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpivf7o0eo.d(94):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivf7o0eo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long product\
    \ = n;\n    long factorization[] = new long[100];\n    long factorizationCount\
    \ = 0;\n    long temp;\n    long temp2;\n    long temp3;\n    long temp4;\n  \
    \  long temp5;\n    long temp6;\n    long temp7;\n    long temp8;\n    long temp9;\n\
    \    long temp10;\n    long temp11;\n    long temp12;\n    long temp13;\n    long\
    \ temp14;\n    long temp15;\n    long temp16;\n    long temp17;\n    long temp18;\n\
    \    long temp19;\n    long temp20;\n    long temp21;\n    long temp22;\n    long\
    \ temp23;\n    long temp24;\n    long temp25;\n    long temp26;\n    long temp27;\n\
    \    long temp28;\n    long temp29;\n    long temp30;\n    long temp31;\n    long\
    \ temp32;\n    long temp33;\n    long temp34;\n    long temp35;\n    long temp36;\n\
    \    long temp37;\n    long temp38;\n    long temp39;\n    long temp40;\n    long\
    \ temp41;\n    long temp42;\n    long temp43;\n    long temp44;\n    long temp45;\n\
    \    long temp46;\n    long temp47;\n    long temp48;\n    long temp49;\n    long\
    \ temp50;\n    long temp51;\n    long temp52;\n    long temp53;\n    long temp54;\n\
    \    long temp55;\n    long temp56;\n    long temp57;\n    long temp58;\n    long\
    \ temp59;\n    long temp60;\n    long temp61;\n    long temp62;\n    long temp63;\n\
    \    long temp64;\n    long temp65;\n    long temp66;\n    long temp67;\n    long\
    \ temp68;\n    long temp69;\n    long temp70;\n    long temp71;\n    long temp72;\n\
    \    long temp73;\n    long temp74;\n    long temp75;\n    long temp76;\n    long\
    \ temp77;\n    long temp78;\n    long temp79;\n    long temp80;\n    long temp8\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpycl7omww.d(98): Error: semicolon expected, not \''unittest\''\n/tmp/tmpycl7omww.d(98):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpycl7omww.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)]; \n    for(int i=0;i<factors.length;i++) \n\
    \    {\n        factors[i]=std.math.factorial(n)/((long)std.math.factorial(i));\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max) \n{\n    long[] factors = new long[(int)std.math.factorial(n)];\
    \ \n    for(int i=0;i<factors.length;i++) \n    {\n        factors[i]=std.math.factorial(n)/((long)std.math.factorial(i));\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max,int min) \n{\n    long[] factors =\
    \ new long[(int)std.math.factorial(n)]; \n    for(int i=0;i<factors.length;i++)\
    \ \n    {\n        factors[i]=std.math.factorial(n)/((long)std.math.factorial(i));\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max,int min,int max2) \n{\n    long[] factors\
    \ = new long[(int)std.math.factorial(n)]; \n    for(int i=0;i<factors.length;i++)\
    \ \n    {\n        factors[i]=std.math.factorial(n)/((long)std.math.factorial(i));\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max,int min,int max2,int min2) \n{\n  \
    \  long[] factors = new long[(int)std.\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppv6gmbb_.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppv6gmbb_.d(14):
    Error: C style cast illegal, use cast(long)std.math.factorial(i)\n/tmp/tmppv6gmbb_.d(26):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppv6gmbb_.d(29):
    Error: C style cast illegal, use cast(long)std.math.factorial(i)\n/tmp/tmppv6gmbb_.d(41):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppv6gmbb_.d(44):
    Error: C style cast illegal, use cast(long)std.math.factorial(i)\n/tmp/tmppv6gmbb_.d(56):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmppv6gmbb_.d(59):
    Error: C style cast illegal, use cast(long)std.math.factorial(i)\n/tmp/tmppv6gmbb_.d(72):
    Error: identifier expected following \''.\'', not \''unittest\''\n/tmp/tmppv6gmbb_.d(73):
    Error: C style cast illegal, use cast(int)std\n/tmp/tmppv6gmbb_.d(73): Error:
    found \''{\'' when expecting \'']\''\n/tmp/tmppv6gmbb_.d(74): Error: semicolon
    expected, not \''alias\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppv6gmbb_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n\
    \            factors[factorCount++] = i;\n            n /= i;\n        }\n   \
    \ }\n    factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors) \n{\n    long[] factors = new long[maxFactors];\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n  \
    \      while(n % i == 0)\n        {\n            factors[factorCount++] = i;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount++] = n;\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n    long[]\
    \ factors = new long[maxFactors];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount++] = i;\n            n /= i;\n     \
    \   }\n    }\n    factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors, int maxFactorsCount, int maxFactorsCount2) \n{\n    long[] factors\
    \ = new long[maxFactors];\n    long factor = 1;\n    long factorCount = 0;\n \
    \   for(int i = 2; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n\
    \            factors[factorCount++] = i;\n            n /= i;\n        }\n   \
    \ }\n    factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpno1p0rf8.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpno1p0rf8.d(91):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpno1p0rf8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long temp = 1;\n    int i = 0;\n    while(factor <=\
    \ n)\n    {\n        while(n % factor == 0)\n        {\n            result[i++]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   while(n > 1)\n    {\n        while(n % temp == 0)\n        {\n           \
    \ result[i++] = temp;\n            n /= temp;\n        }\n        temp++;\n  \
    \  }\n    return result;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] result\
    \ = new long[factorizationSize];\n    long factor = 1;\n    long temp = 1;\n \
    \   int i = 0;\n    while(factor <= n)\n    {\n        while(n % factor == 0)\n\
    \        {\n            result[i++] = factor;\n            n /= factor;\n    \
    \    }\n        factor++;\n    }\n    while(n > 1)\n    {\n        while(n % temp\
    \ == 0)\n        {\n            result[i++] = temp;\n            n /= temp;\n\
    \        }\n        temp++;\n    }\n    return result;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize,\
    \ int factorizationLimit) \n{\n    long[] result = new long[factorizationSize];\n\
    \    long factor = 1;\n    long temp = 1;\n    int i = 0;\n    while(factor <=\
    \ n)\n    {\n        while(n % factor == 0)\n        {\n            result[i++]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   while(n > 1)\n    {\n        while(n % temp == 0)\n        {\n           \
    \ result[i++] = temp;\n            n /= temp;\n        }\n        temp++;\n  \
    \  }\n    return result;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, int factorizationLimit,\
    \ int factorizationMin) \n{\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfz25fqlq.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpfz25fqlq.d(107):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpfz25fqlq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 1; i <= (int)Math.sqrt(n); i++) {\n        factors[(int)i] = 1;\n      \
    \  while(p % i == 0) {\n            factors[(int)i] += factor;\n            p\
    \ /= i;\n            factor++;\n        }\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long\
    \ p = 1;\n    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\
    \ {\n        factors[(int)i] = 1;\n        while(p % i == 0) {\n            factors[(int)i]\
    \ += factor;\n            p /= i;\n            factor++;\n        }\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n  \
    \  for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        factors[(int)i] = 1;\n\
    \        while(p % i == 0) {\n            factors[(int)i] += factor;\n       \
    \     p /= i;\n            factor++;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++) {\n        factors[(int)i] = 1;\n        while(p % i == 0) {\n        \
    \    factors[(int)i] += factor;\n            p /= i;\n            factor++;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpulhkiu_o.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(15):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(17): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(32): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(35): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(36): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(38): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpulhkiu_o.d(53): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(56):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(57):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(59): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(74): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(77): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpulhkiu_o.d(78): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpulhkiu_o.d(80): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpulhkiu_o.d(87): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpulhkiu_o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factor *= i;\n            factors[(int)Math.sqrt(n)-i-1] = factor;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n\
    \        {\n            factor *= i;\n            factors[(int)Math.sqrt(n)-i-1]\
    \ = factor;\n        }\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n%i == 0)\n        {\n            factor *= i;\n   \
    \         factors[(int)Math.sqrt(n)-i-1] = factor;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCount2)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        if(n%i == 0)\n        {\n            factor *= i;\n            factors[(int)Math.sqrt(n)-i-1]\
    \ = factor;\n        }\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb6btr7co.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(19):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(32):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(35):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(40):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(53):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(56):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(61):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(74):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(82):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb6btr7co.d(87):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb6btr7co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCountMax = factors.length;\n    for(int i = 0; i <= factorCountMax;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorCount]\
    \ = factor;\n            factorCount++;\n            n /= factor;\n        }\n\
    \        factor = 1;\n        factorCount = 0;\n    }\n    for(int i = 0; i <=\
    \ factorCountMax; i++)\n    {\n        factors[factorCount] = factors[factorCount]\
    \ * factors[i];\n        factorCount++;\n    }\n    return factors;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/11490694)\n<|/ c |>\n<| c |>\nI added\
    \ a code example to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11490694)\n\
    <|/ c |>\n<| c |>\nI added a code example to my answer. Hope it helps.\n<|/ c\
    \ |>\n<| a tags=algorithm,primes,java |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0be2gdpy.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0be2gdpy.d(33):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp0be2gdpy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.sqrt(n)];\n    long p = n;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(p % 2 == 0)\n        {\n            p /= 2;\n   \
    \         factors[i] = 2;\n        }\n        while(p % 3 == 0)\n        {\n \
    \           p /= 3;\n            factors[i] = 3;\n        }\n        while(p %\
    \ 5 == 0)\n        {\n            p /= 5;\n            factors[i] = 5;\n     \
    \   }\n        while(p % 7 == 0)\n        {\n            p /= 7;\n           \
    \ factors[i] = 7;\n        }\n        while(p % 11 == 0)\n        {\n        \
    \    p /= 11;\n            factors[i] = 11;\n        }\n        while(p % 13 ==\
    \ 0)\n        {\n            p /= 13;\n            factors[i] = 13;\n        }\n\
    \        while(p % 17 == 0)\n        {\n            p /= 17;\n            factors[i]\
    \ = 17;\n        }\n        while(p % 19 == 0)\n        {\n            p /= 19;\n\
    \            factors[i] = 19;\n        }\n        while(p % 23 == 0)\n       \
    \ {\n            p /= 23;\n            factors[i] = 23;\n        }\n        while(p\
    \ % 29 == 0)\n        {\n            p /= 29;\n            factors[i] = 29;\n\
    \        }\n        while(p % 31 == 0)\n        {\n            p /= 31;\n    \
    \        factors[i] = 31;\n        }\n        while(p % 37 == 0)\n        {\n\
    \            p /= 37;\n            factors[i] = 37;\n        }\n        while(p\
    \ % 41 == 0)\n        {\n            p /= 41;\n            factors[i] = 41;\n\
    \        }\n        while(p % 43 == 0)\n        {\n            p /= 43;\n    \
    \        factors[i] = 43;\n        }\n        while(p % 47 == 0)\n        {\n\
    \            p /= 47;\n            factors[i] = 47;\n        }\n        while(p\
    \ % 53 == 0)\n        {\n            p /= 53;\n            factors[i] = 53;\n\
    \        }\n        while(p % 59 == 0)\n        {\n            p /= 59;\n    \
    \        factors[i] = 59;\n        }\n        while(p % 61 == 0)\n        {\n\
    \            p /= 61;\n            factors[i] = 61;\n        }\n        while(p\
    \ % 67 == 0)\n        {\n            p /= 67;\n            factors[i] = 67;\n\
    \        }\n        while(p % 71 == 0)\n        {\n            p /= 71;\n    \
    \        factors[i] = 71;\n        }\n        while(p % 73 == 0)\n        {\n\
    \            p /= 73;\n            factor\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprsd6ldbo.d(11): Error: C style cast illegal, use cast(int)std.math.sqrt(n)\n/tmp/tmprsd6ldbo.d(119):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprsd6ldbo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % i ==\
    \ 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=primes,c#,algorithm |>\n<| a dscore=0 |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp0zftufb.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp0zftufb.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp0zftufb.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpp0zftufb.d(31): Error: semicolon
    expected, not \''.\''\n/tmp/tmpp0zftufb.d(31): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpp0zftufb.d(32): Error: semicolon expected, not \''.\''\n/tmp/tmpp0zftufb.d(32):
    Error: no identifier for declarator .Linq\n/tmp/tmpp0zftufb.d(33): Error: semicolon
    expected, not \''.\''\n/tmp/tmpp0zftufb.d(33): Error: no identifier for declarator
    .Text\n/tmp/tmpp0zftufb.d(34): Error: semicolon expected, not \''.\''\n/tmp/tmpp0zftufb.d(34):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp0zftufb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = 0;\n      \
    \  for(int j = i; j < n; j++)\n        {\n            if(n%j == 0)\n         \
    \   {\n                factors[i] = factors[i]+1;\n                factor *= j;\n\
    \                break;\n            }\n        }\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factor;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i]\
    \ = factors[i]*factors[i];\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max) \n{\n\
    \    long factors[] = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long\
    \ factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n      \
    \  factors[i] = 0;\n        for(int j = i; j < n; j++)\n        {\n          \
    \  if(n%j == 0)\n            {\n                factors[i] = factors[i]+1;\n \
    \               factor *= j;\n                break;\n            }\n        }\n\
    \    }\n    factors[(int)Math.sqrt(n)] = factor;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factors[i]*factors[i];\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int max, int max2) \n{\n    long factors[] = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = 0;\n        for(int j = i; j < n; j++)\n \
    \       {\n            if(n%j == 0)\n            {\n                factors[i]\
    \ = factors[i]+1;\n                factor *= j;\n                break;\n    \
    \        }\n        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factors[i]*factors[i];\n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprx0ugstj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(27):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(28):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(42):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(45):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(58):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(59):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(73):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(76):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(90):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprx0ugstj.d(94):
    Error: found \''unittest\'' instead of statement\n/tmp/tmprx0ugstj.d(107): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprx0ugstj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd8eae1s3.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpd8eae1s3.d(112):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd8eae1s3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))+1)];\n    std.math.factorize(n,factors);\n\
    \    long[] result = new long[(int)factors.length];\n    for(int i=0;i<factors.length;i++)\n\
    \        result[i] = factors[i];\n    return result;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n,int factorization[])\
    \ \n{\n    long factors[] = new long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))+1)];\n\
    \    std.math.factorize(n,factors);\n    for(int i=0;i<factors.length;i++)\n \
    \       factorization[factors[i]] = factors[i];\n    return factorization;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n,int factorization[],int factorization_size) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))+1)];\n    std.math.factorize(n,factors);\n\
    \    for(int i=0;i<factors.length;i++)\n        factorization[factors[i]] = factors[i];\n\
    \    return factorization;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int factorization[],int factorization_size,int\
    \ factorization_index) \n{\n    long factors[] = new long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))+1)];\n\
    \    std.math.factorize(n,factors);\n    for(int i=0;i<factors.length;i++)\n \
    \       factorization[factors[i]] = factors[i];\n    return factorization;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmdxo0b7s.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)) + 1)\n/tmp/tmpmdxo0b7s.d(13): Error: C style
    cast illegal, use cast(int)factors.length\n/tmp/tmpmdxo0b7s.d(26): Error: C style
    cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, std.math.log(n, 2))
    + 1)\n/tmp/tmpmdxo0b7s.d(40): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)) + 1)\n/tmp/tmpmdxo0b7s.d(54): Error: C style
    cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, std.math.log(n, 2))
    + 1)\n/tmp/tmpmdxo0b7s.d(60): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmdxo0b7s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwyfsmazy.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpwyfsmazy.d(112):
    Error: no identifier for declarator long\n/tmp/tmpwyfsmazy.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpwyfsmazy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n\
    \    long temp;\n    \n    for(int i = 0; i <= (int)std.math.sqrt(n); i++) \n\
    \    {\n        temp = factor;\n        while(temp != 1 && temp <= n) \n     \
    \   {\n            if(n % temp == 0) \n            {\n                factors[counter]\
    \ = temp;\n                n /= temp;\n                counter++;\n          \
    \  }\n            temp++;\n        }\n        factors[counter] = factor;\n   \
    \     factor++;\n    }\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcz4z6bj2.d(11): Error: C style cast illegal, use cast(int)std.math.sqrt(n)\n/tmp/tmpcz4z6bj2.d(16):
    Error: C style cast illegal, use cast(int)std.math.sqrt(n)\n/tmp/tmpcz4z6bj2.d(34):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpcz4z6bj2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   factors[(int)factors.length] = n;\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n  \
    \      while(n % factor == 0)\n        {\n            factors[(int)i] = factor;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    factors[(int)factors.length]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, bool isPrime)\n{\n\
    \    long[] factors = new long[factorizationSize];\n    long factor = 1;\n   \
    \ for(int i = 0; i < factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[(int)i] = factor;\n            n /= factor;\n\
    \        }\n        factor++;\n    }\n    factors[(int)factors.length] = n;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, bool isPrime, bool\
    \ isPrime2)\n{\n    long[] factors = new long[factorizationSize];\n    long factor\
    \ = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n        while(n %\
    \ factor == 0)\n        {\n            factors[(int)i] = factor;\n           \
    \ n /= factor;\n        }\n        factor++;\n    }\n    factors[(int)factors.length]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8c0rjahb.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8c0rjahb.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp8c0rjahb.d(22): Error: C
    style cast illegal, use cast(int)factors.length\n/tmp/tmp8c0rjahb.d(39): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmp8c0rjahb.d(44): Error: C style cast
    illegal, use cast(int)factors.length\n/tmp/tmp8c0rjahb.d(61): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp8c0rjahb.d(66): Error: C style cast illegal,
    use cast(int)factors.length\n/tmp/tmp8c0rjahb.d(83): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp8c0rjahb.d(88): Error: C style cast illegal, use cast(int)factors.length\n/tmp/tmp8c0rjahb.d(91):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8c0rjahb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % factor == 0)\n     \
    \   {\n            factors[counter] = factor;\n            n /= factor;\n    \
    \        counter++;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=algorithm,primes,factorization,c# |>\n<| a tags=algorithm,primes,factorization,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdbly9723.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpdbly9723.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpdbly9723.d(31): Error: semicolon
    expected, not \''.\''\n/tmp/tmpdbly9723.d(31): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpdbly9723.d(32): Error: semicolon expected, not \''.\''\n/tmp/tmpdbly9723.d(32):
    Error: no identifier for declarator .Linq\n/tmp/tmpdbly9723.d(33): Error: semicolon
    expected, not \''.\''\n/tmp/tmpdbly9723.d(33): Error: no identifier for declarator
    .Text\n/tmp/tmpdbly9723.d(34): Error: semicolon expected, not \''.\''\n/tmp/tmpdbly9723.d(34):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdbly9723.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = n;\n    long r = n;\n\
    \    long s = 1;\n    long t = 0;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_estqdyg.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp_estqdyg.d(112):
    Error: no identifier for declarator long\n/tmp/tmp_estqdyg.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp_estqdyg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    long factor = 1;\n   \
    \ for(int i = 1; i < factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factors.length - i - 1] = factor;\n     \
    \       n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    for(int i = 1; i < factors.length; i++)\n    {\n  \
    \      while(n % factor == 0)\n        {\n            factors[factors.length -\
    \ i - 1] = factor;\n            n /= factor;\n        }\n        factor++;\n \
    \   }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, bool useSieve)\n{\n\
    \    long[] factors = new long[factorizationSize];\n    long factor = 1;\n   \
    \ for(int i = 1; i < factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factors.length - i - 1] = factor;\n     \
    \       n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize, bool useSieve, bool useSieve2)\n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long factor = 1;\n    for(int i = 1; i <\
    \ factors.length; i++)\n    {\n        while(n % factor == 0)\n        {\n   \
    \         factors[factors.length - i - 1] = factor;\n            n /= factor;\n\
    \        }\n        factor++;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpajowv8zf.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpajowv8zf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)std.math.gcd(n); i++)\n    {\n        factorCount\
    \ = 0;\n        while(factor <= n && n % factor == 0)\n        {\n           \
    \ factors[factorCount++] = factor;\n            n /= factor;\n            factor++;\n\
    \        }\n        if(factor > n)\n        {\n            factors[factorCount++]\
    \ = n;\n            break;\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,primes |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu36vqdwc.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpu36vqdwc.d(14):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpu36vqdwc.d(31):
    Error: Declaration expected, not \''<\''\n/tmp/tmpu36vqdwc.d(36): Error: semicolon
    expected, not \''.\''\n/tmp/tmpu36vqdwc.d(36): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpu36vqdwc.d(37): Error: semicolon expected, not \''.\''\n/tmp/tmpu36vqdwc.d(37):
    Error: no identifier for declarator .Linq\n/tmp/tmpu36vqdwc.d(38): Error: semicolon
    expected, not \''.\''\n/tmp/tmpu36vqdwc.d(38): Error: no identifier for declarator
    .Text\n/tmp/tmpu36vqdwc.d(39): Error: semicolon expected, not \''.\''\n/tmp/tmpu36vqdwc.d(39):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpu36vqdwc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))];\n    std.array.sort(factors);\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        factors[i]=std.math.pow(2,i);\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int factorization) \n{\n    long[] factors\
    \ = new long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))];\n\
    \    std.array.sort(factors);\n    for(int i=0;i<factors.length;i++)\n    {\n\
    \        factors[i]=factorization;\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n,int\
    \ factorization,int factorization2) \n{\n    long[] factors = new long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))];\n\
    \    std.array.sort(factors);\n    for(int i=0;i<factors.length;i++)\n    {\n\
    \        factors[i]=factorization;\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n,int\
    \ factorization,int factorization2,int factorization3) \n{\n    long[] factors\
    \ = new long[(int)std.math.ceil(n/std.math.max(1,(int)std.math.log(n,2)))];\n\
    \    std.array.sort(factors);\n    for(int i=0;i<factors.length;i++)\n    {\n\
    \        factors[i]=factorization;\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfqqynlo0.d(11): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpfqqynlo0.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, cast(int)std.math.log(n, 2)))\n/tmp/tmpfqqynlo0.d(27): Error:
    C style cast illegal, use cast(int)std.math.log(n, 2)\n/tmp/tmpfqqynlo0.d(27):
    Error: C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, cast(int)std.math.log(n,
    2)))\n/tmp/tmpfqqynlo0.d(43): Error: C style cast illegal, use cast(int)std.math.log(n,
    2)\n/tmp/tmpfqqynlo0.d(43): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, cast(int)std.math.log(n, 2)))\n/tmp/tmpfqqynlo0.d(59): Error:
    C style cast illegal, use cast(int)std.math.log(n, 2)\n/tmp/tmpfqqynlo0.d(59):
    Error: C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, cast(int)std.math.log(n,
    2)))\n/tmp/tmpfqqynlo0.d(67): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfqqynlo0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[100];\n    long factorizationCount = 0;\n    long factorizationCountMax\
    \ = factorizationCount;\n    long factorizationCountMin = factorizationCount;\n\
    \    long factorizationCountMinMax = factorizationCount;\n    long factorizationCountMinMax2\
    \ = factorizationCount;\n    long factorizationCountMinMax3 = factorizationCount;\n\
    \    long factorizationCountMinMax4 = factorizationCount;\n    long factorizationCountMinMax5\
    \ = factorizationCount;\n    long factorizationCountMinMax6 = factorizationCount;\n\
    \    long factorizationCountMinMax7 = factorizationCount;\n    long factorizationCountMinMax8\
    \ = factorizationCount;\n    long factorizationCountMinMax9 = factorizationCount;\n\
    \    long factorizationCountMinMax10 = factorizationCount;\n    long factorizationCountMinMax11\
    \ = factorizationCount;\n    long factorizationCountMinMax12 = factorizationCount;\n\
    \    long factorizationCountMinMax13 = factorizationCount;\n    long factorizationCountMinMax14\
    \ = factorizationCount;\n    long factorizationCountMinMax15 = factorizationCount;\n\
    \    long factorizationCountMinMax16 = factorizationCount;\n    long factorizationCountMinMax17\
    \ = factorizationCount;\n    long factorizationCountMinMax18 = factorizationCount;\n\
    \    long factorizationCountMinMax19 = factorizationCount;\n    long factorizationCountMinMax20\
    \ = factorizationCount;\n    long factorizationCountMinMax21 = factorizationCount;\n\
    \    long factorizationCountMinMax22 = factorizationCount;\n    long factorizationCountMinMax23\
    \ = factorizationCount;\n    long factorizationCountMinMax24 = factorizationCount;\n\
    \    long factorizationCountMinMax25 = factorizationCount;\n    long factorizationCountMinMax26\
    \ = factorizationCount;\n    long factorizationCountMinMax27 = factorizationCount;\n\
    \    long factorizationCountMinMax28 = factorizationCount;\n    long factorizationCountMinMax29\
    \ = factorizationCount;\n    long factorizationCountMinMax30 = factorizationCount;\n\
    \    long factorizationCountMinMax31 = factorizationCount;\n    long factorizationCountMinMax32\
    \ = factorizationCount;\n    long factorizationCountMinMax33 = factorizationCount;\n\
    \    long factorizationCountMinMax34 = factorizationCount;\n    long factorization\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp19qdox90.d(50): Error: semicolon expected, not \''unittest\''\n/tmp/tmp19qdox90.d(50):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp19qdox90.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = n;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp104jau1g.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp104jau1g.d(112):
    Error: no identifier for declarator long\n/tmp/tmp104jau1g.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp104jau1g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorCount++] = factor;\n                n /= factor;\n     \
    \       }\n            factor++;\n        }\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorCount++] = factor;\n                n /= factor;\n     \
    \       }\n            factor++;\n        }\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, int factorizationOrderLimit)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        while(factor*factor <= n)\n        {\n            if(n % factor == 0)\n\
    \            {\n                factors[factorCount++] = factor;\n           \
    \     n /= factor;\n            }\n            factor++;\n        }\n    }\n \
    \   factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationOrder,\
    \ int factorizationOrderLimit, int factorizationOrderLimitLimit) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps42cay6_.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps42cay6_.d(37):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps42cay6_.d(63):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps42cay6_.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps42cay6_.d(92):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmps42cay6_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        factors[i] = 0;\n    }\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[factor]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        factors[i] = 0;\n    }\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[factor]++;\n            n /= p;\n        }\n        p++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n    long\
    \ factor = 1;\n    for(int i = 0; i<factors.length; i++)\n    {\n        factors[i]\
    \ = 0;\n    }\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(n\
    \ % p == 0)\n        {\n            factors[factor]++;\n            n /= p;\n\
    \        }\n        p++;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount, int maxFactorsCount2) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        factors[i] = 0;\n    }\n    \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjaomkrjf.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpjaomkrjf.d(37):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpjaomkrjf.d(63):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpjaomkrjf.d(89):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpjaomkrjf.d(97):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjaomkrjf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factor *= i;\n     \
    \       factorCount++;\n            n /= i;\n        }\n        result[factorCount]\
    \ = i;\n    }\n    return result;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] result = new\
    \ long[maxFactors];\n    long factor = 1;\n    long factorCount = 0;\n    for(int\
    \ i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n         \
    \   factor *= i;\n            factorCount++;\n            n /= i;\n        }\n\
    \        result[factorCount] = i;\n    }\n    return result;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors, int maxFactorsCount) \n{\n    long[] result = new long[maxFactors];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factor *= i;\n     \
    \       factorCount++;\n            n /= i;\n        }\n        result[factorCount]\
    \ = i;\n    }\n    return result;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCount2)\
    \ \n{\n    long[] result = new long[maxFactors];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n %\
    \ i == 0)\n        {\n            factor *= i;\n            factorCount++;\n \
    \           n /= i;\n        }\n        result[factorCount] = i;\n    }\n    return\
    \ result;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp2z0wyds.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpp2z0wyds.d(95):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp2z0wyds.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.factorial(n).floor()];\n    for(int i = 0; i < std.math.factorial(n).floor();\
    \ i++)\n    {\n        long p = std.math.factorial(n).floor() / (long)i;\n   \
    \     factors[i] = p;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max) \n{\n\
    \    long[] factors = new long[std.math.factorial(n).floor()];\n    for(int i\
    \ = 0; i < std.math.factorial(n).floor(); i++)\n    {\n        long p = std.math.factorial(n).floor()\
    \ / (long)i;\n        if(p > max)\n        {\n            break;\n        }\n\
    \        factors[i] = p;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max, int\
    \ min) \n{\n    long[] factors = new long[std.math.factorial(n).floor()];\n  \
    \  for(int i = 0; i < std.math.factorial(n).floor(); i++)\n    {\n        long\
    \ p = std.math.factorial(n).floor() / (long)i;\n        if(p > max)\n        {\n\
    \            break;\n        }\n        if(p < min)\n        {\n            continue;\n\
    \        }\n        factors[i] = p;\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ max, int min, int max2) \n{\n    long[] factors = new long[std.math.factorial(n).floor()];\n\
    \    for(int i = 0; i < std.math.factorial(n).floor(); i++)\n    {\n        long\
    \ p = std.math.factorial(n).floor() / (long)i;\n        if(p > max)\n        {\n\
    \            break;\n        }\n        if(p < min)\n        {\n            continue;\n\
    \        }\n        if(p > max2)\n        {\n            break;\n        }\n \
    \       factors[i] = p;\n    }\n    return factors;\n\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_m96rw2.d(14): Error: C style cast illegal, use cast(long)i\n/tmp/tmp3_m96rw2.d(30):
    Error: C style cast illegal, use cast(long)i\n/tmp/tmp3_m96rw2.d(50): Error: C
    style cast illegal, use cast(long)i\n/tmp/tmp3_m96rw2.d(74): Error: C style cast
    illegal, use cast(long)i\n/tmp/tmp3_m96rw2.d(91): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_m96rw2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log(n))];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = std.math.nextPowerOfTwo(std.math.log(n));\
    \ i > 0; i /= 2)\n    {\n        while(n % i == 0)\n        {\n            factors[factorCount++]\
    \ = i;\n            n /= i;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwkdzsy39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i < factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n           \
    \ n /= factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=primes,c++,algorithm |>\n\
    <| c |>\nThis code is not correct. For example, factorize(100) returns [2,2,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpukzxb5b3.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpukzxb5b3.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpukzxb5b3.d(34): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(35): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpukzxb5b3.d(36): Error: Declaration expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(37):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(38): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(40): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpukzxb5b3.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmpukzxb5b3.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpukzxb5b3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    long\
    \ i = 2;\n    while(i <= n)\n    {\n        while(n % i == 0)\n        {\n   \
    \         n /= i;\n            factors[counter] = i;\n            counter++;\n\
    \        }\n        i++;\n    }\n    factors[counter] = n;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long\
    \ factor = 1;\n    long counter = 1;\n    long i = 2;\n    while(i <= n)\n   \
    \ {\n        while(n % i == 0)\n        {\n            n /= i;\n            factors[counter]\
    \ = i;\n            counter++;\n        }\n        i++;\n    }\n    factors[counter]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n\
    \    long i = 2;\n    while(i <= n)\n    {\n        while(n % i == 0)\n      \
    \  {\n            n /= i;\n            factors[counter] = i;\n            counter++;\n\
    \        }\n        i++;\n    }\n    factors[counter] = n;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long counter = 1;\n    long i = 2;\n    while(i <=\
    \ n)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n     \
    \       factors[counter] = i;\n            counter++;\n        }\n        i++;\n\
    \    }\n    factors[counter] = n;\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp_rniofl.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp_rniofl.d(36):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp_rniofl.d(61):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp_rniofl.d(86):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpp_rniofl.d(102):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp_rniofl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[(int)std.math.factorial(n)];\n    long factorizationCount = 0;\n\
    \    long factorizationIndex = 0;\n    long factorizationValue = 1;\n    long\
    \ factorizationValueCount = 0;\n    long factorizationValueIndex = 0;\n    long\
    \ factorizationValueValue = 1;\n    long factorizationValueValueCount = 0;\n \
    \   long factorizationValueValueIndex = 0;\n    long factorizationValueValueValue\
    \ = 1;\n    long factorizationValueValueValueCount = 0;\n    long factorizationValueValueValueIndex\
    \ = 0;\n    long factorizationValueValueValueValue = 1;\n    long factorizationValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValueValueIndex = 0;\n    long factorizationValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueCount = 0;\n    long factorizationValueValueValueValueIndex\
    \ = 0;\n    long factorizationValueValueValueValueValue = 1;\n    long factorizationValueValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValueValueValueIndex = 0;\n    long factorizationValueValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueValueValueCount = 0;\n    long\
    \ factorizationValueValueValueValueValueValueIndex = 0;\n    long factorizationValueValueValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueValueValueValueCount = 0;\n\
    \    long factorizationValueValueValueValueValueValueValueIndex = 0;\n    long\
    \ factorizationValueValueValueValueValueValueValueValue = 1;\n    long factorizationValueValueValueValueValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValueValueValueValueValueIndex = 0;\n\
    \    long factorizationValueValueValueValueValueValueValueValueValue = 1;\n  \
    \  long factorizationValueValueValueValueValueValueValueValueCount = 0;\n    long\
    \ factorizationValueValueValueValueValueValueValueValueIndex = 0;\n    long factorizationValueValueValueValueValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueValueValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValueValueValueValueValueValueValueIndex\
    \ = 0;\n    long factorizationValueValueValueValueValueValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueValueValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValueValueValueValueValueValueValueIndex\
    \ = 0;\n    long factorizationValueValueValueValueValueValueValueValueValueValue\
    \ = 1;\n    long factorizationValueValueValueValueValueValueValueValueValueCount\
    \ = 0;\n    long factorizationValueValueValue\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp92vqm_rp.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp92vqm_rp.d(53):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmp92vqm_rp.d(53): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp92vqm_rp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorsSum = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n \
    \   {\n        factorsSum += factor;\n        factorCount = 0;\n        for(int\
    \ j = 0; j <= i; j++)\n        {\n            if(n % i == 0)\n            {\n\
    \                factorsSum += factor;\n                factorCount++;\n     \
    \           factor *= i;\n            }\n        }\n        if(factorCount > 0)\n\
    \        {\n            factors[(int)Math.sqrt(n) - 1 - i] = factorsSum / factorCount;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long factorsSum = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        factorsSum += factor;\n        factorCount = 0;\n        for(int\
    \ j = 0; j <= i; j++)\n        {\n            if(n % i == 0)\n            {\n\
    \                factorsSum += factor;\n                factorCount++;\n     \
    \           factor *= i;\n            }\n        }\n        if(factorCount > 0)\n\
    \        {\n            factors[(int)Math.sqrt(n) - 1 - i] = factorsSum / factorCount;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsSum)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorsSum = 0;\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        factorsSum += factor;\n        factorCount\
    \ = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(n % i ==\
    \ 0)\n            {\n                factorsSum += factor;\n                factorCount++;\n\
    \                factor *= i;\n            }\n        }\n        if(factorCount\
    \ > \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpop42h1wx.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(30):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(43):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(47):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(62):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(75):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(79):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpop42h1wx.d(93):
    Error: expression expected, not \''unittest\''\n/tmp/tmpop42h1wx.d(94): Error:
    found \''{\'' when expecting \'')\''\n/tmp/tmpop42h1wx.d(106): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpop42h1wx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)];\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        factors[i] = 0;\n    }\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        for(int j = 1; i*j <= n; j++)\n        {\n            if(n % i\
    \ == 0)\n            {\n                factors[i] += 1;\n                n /=\
    \ i;\n                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)std.math.factorial(n)];\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        factors[i] = 0;\n \
    \   }\n    for(int i = 0; i<factors.length; i++)\n    {\n        for(int j = 1;\
    \ i*j <= n; j++)\n        {\n            if(n % i == 0)\n            {\n     \
    \           factors[i] += 1;\n                n /= i;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max, int\
    \ max2) \n{\n    long[] factors = new long[(int)std.math.factorial(n)];\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        factors[i] = 0;\n    }\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        for(int j = 1; i*j <= n; j++)\n\
    \        {\n            if(n % i == 0)\n            {\n                factors[i]\
    \ += 1;\n                n /= i;\n                break;\n            }\n    \
    \    }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2, int max3) \n{\n    long[]\
    \ factors = new long[(int)std.math.factorial(n)];\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        factors[i] = 0;\n    }\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyt_i3p8g.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpyt_i3p8g.d(38):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpyt_i3p8g.d(65):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpyt_i3p8g.d(92):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpyt_i3p8g.d(99):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpyt_i3p8g.d(112): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpyt_i3p8g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long factorization = 1;\n    for(int i = 0; i<result.length;\
    \ i++)\n    {\n        while(factorization%n != 0)\n        {\n            factorization\
    \ *= factor;\n        }\n        result[i] = factorization;\n        factor *=\
    \ i;\n    }\n    return result;\n}\n</code>\n<|/ a tags=primes,algorithm,c# |>\n\
    <| c |>\nThis code doesn't work for n = 7. Factorization is {1, 2, 3, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}.\
    \ Your code returns factorization as {1, 2, 3, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n<|/ c |>\n<| c |>\n\
    I tested it on n = 7 and it returned {1, 2, 3, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n<|/ c |>\n<| c |>\n\
    I tested it on n = 7 and it returned {1, 2, 3, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n<|/ c |>\n<| c |>\n\
    I tested it on n = 7 and it returned {1, 2, 3, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n<|/ c |>\n<| c |>\n\
    I tested it on n = 7 and it returned {1, 2, 3, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n<|/ c |>\n<| a dscore=2\
    \ |>\nI wrote a C# program that does this for you. \n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpziarmqg8.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpziarmqg8.d(25):
    Error: Declaration expected, not \''<\''\n/tmp/tmpziarmqg8.d(28): Error: unterminated
    character constant\n/tmp/tmpziarmqg8.d(46): Error: semicolon expected, not \''.\''\n/tmp/tmpziarmqg8.d(46):
    Error: no identifier for declarator .Collections.Generic\n/tmp/tmpziarmqg8.d(47):
    Error: semicolon expected, not \''.\''\n/tmp/tmpziarmqg8.d(47): Error: no identifier
    for declarator .Linq\n/tmp/tmpziarmqg8.d(48): Error: semicolon expected, not \''.\''\n/tmp/tmpziarmqg8.d(48):
    Error: no identifier for declarator .Text\n/tmp/tmpziarmqg8.d(49): Error: semicolon
    expected, not \''.\''\n/tmp/tmpziarmqg8.d(49): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpziarmqg8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)std.math.ceiling(std.math.sqrt(n))];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    long factorsSum = 0;\n \
    \   long factorsSumOfSquares = 0;\n    for(int i = 0; i <= (int)std.math.ceiling(std.math.sqrt(n));\
    \ i++) {\n        factorsSum += factor;\n        factorsSumOfSquares += factor\
    \ * factor;\n        factorCount++;\n        factor *= i;\n    }\n    for(int\
    \ i = 0; i <= (int)std.math.ceiling(std.math.sqrt(n)); i++) {\n        if(factorsSumOfSquares\
    \ <= n / factorsSum) {\n            result[factorCount] = factor;\n          \
    \  factorsSumOfSquares -= factor * factor;\n            factorCount--;\n     \
    \       factor *= i;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ tags=math,algorithm,primes,java |>\n<| c |>\nThis is not the best solution.\
    \ Try factorize(1000000007) and you will see that it is very slow.\n<|/ c |>\n\
    <| c |>\nI agree, this is very slow for large numbers. I added a faster solution\
    \ that is much faster than the one I posted in the original answer.\n<|/ c |>\n\
    <| a dscore=3 |>\nI wrote a Java program to find prime numbers in less than a\
    \ second. \n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfsp96bxl.d(11): Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.sqrt(n))\n/tmp/tmpfsp96bxl.d(16):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.sqrt(n))\n/tmp/tmpfsp96bxl.d(22):
    Error: C style cast illegal, use cast(int)std.math.ceiling(std.math.sqrt(n))\n/tmp/tmpfsp96bxl.d(32):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpfsp96bxl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i < factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n           \
    \ n /= factor;\n        }\n        factor++;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,math,primes,c#\
    \ |>\n<code>\npublic bool IsPrime(long number)\n{\n    long sqrtNumber = (long)\
    \ Math.Sqrt(number);\n    bool isPrime = true;\n    long factor = 2;\n    while\
    \ (factor * factor <= sqrtNumber)\n    {\n        if (number % factor == 0)\n\
    \        {\n            isPrime = false;\n            break;\n        }\n    \
    \    factor++;\n    }\n    return isPrime;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>\nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwl3oxd7r.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpwl3oxd7r.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpwl3oxd7r.d(35): Error: Declaration
    expected, not \''while\''\n/tmp/tmpwl3oxd7r.d(40): Error: Declaration expected,
    not \''break\''\n/tmp/tmpwl3oxd7r.d(41): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwl3oxd7r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factor_count = 1;\n\
    \    long factor_index = 0;\n    long factor_index2 = 0;\n    long factor_index3\
    \ = 0;\n    long factor_index4 = 0;\n    long factor_index5 = 0;\n    long factor_index6\
    \ = 0;\n    long factor_index7 = 0;\n    long factor_index8 = 0;\n    long factor_index9\
    \ = 0;\n    long factor_index10 = 0;\n    long factor_index11 = 0;\n    long factor_index12\
    \ = 0;\n    long factor_index13 = 0;\n    long factor_index14 = 0;\n    long factor_index15\
    \ = 0;\n    long factor_index16 = 0;\n    long factor_index17 = 0;\n    long factor_index18\
    \ = 0;\n    long factor_index19 = 0;\n    long factor_index20 = 0;\n    long factor_index21\
    \ = 0;\n    long factor_index22 = 0;\n    long factor_index23 = 0;\n    long factor_index24\
    \ = 0;\n    long factor_index25 = 0;\n    long factor_index26 = 0;\n    long factor_index27\
    \ = 0;\n    long factor_index28 = 0;\n    long factor_index29 = 0;\n    long factor_index30\
    \ = 0;\n    long factor_index31 = 0;\n    long factor_index32 = 0;\n    long factor_index33\
    \ = 0;\n    long factor_index34 = 0;\n    long factor_index35 = 0;\n    long factor_index36\
    \ = 0;\n    long factor_index37 = 0;\n    long factor_index38 = 0;\n    long factor_index39\
    \ = 0;\n    long factor_index40 = 0;\n    long factor_index41 = 0;\n    long factor_index42\
    \ = 0;\n    long factor_index43 = 0;\n    long factor_index44 = 0;\n    long factor_index45\
    \ = 0;\n    long factor_index46 = 0;\n    long factor_index47 = 0;\n    long factor_index48\
    \ = 0;\n    long factor_index49 = 0;\n    long factor_index50 = 0;\n    long factor_index51\
    \ = 0;\n    long factor_index52 = 0;\n    long factor_index53 = 0;\n    long factor_index54\
    \ = 0;\n    long factor_index55 = 0;\n    long factor_index56 = 0;\n    long factor_index57\
    \ = 0;\n    long factor_index58 = 0;\n    long factor_index59 = 0;\n    long factor_index60\
    \ = 0;\n    long factor_index61 = 0;\n    long factor_index62 = 0;\n    long factor_index63\
    \ = 0;\n    long factor_index64 = 0;\n    long factor_index65 = 0;\n    long factor_index66\
    \ = 0;\n    long factor_index67 = 0;\n    long factor_index68 = 0;\n    long factor_index69\
    \ = 0;\n    long factor_index70 = 0;\n    \nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy8vez7y1.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy8vez7y1.d(85):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy8vez7y1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[(int)i] = 1;\n \
    \       while(p % i == 0)\n        {\n            factors[(int)i]++;\n       \
    \     p /= i;\n        }\n    }\n    for(int i = factors.length - 1; i >= 0; i--)\n\
    \    {\n        if(factors[i] == 1)\n        {\n            factors[i] = p;\n\
    \            p *= i;\n        }\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p =\
    \ 1;\n    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        factors[(int)i] = 1;\n        while(p % i == 0)\n        {\n \
    \           factors[(int)i]++;\n            p /= i;\n        }\n    }\n    for(int\
    \ i = factors.length - 1; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n \
    \       {\n            factors[i] = p;\n            p *= i;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n  \
    \  for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[(int)i]\
    \ = 1;\n        while(p % i == 0)\n        {\n            factors[(int)i]++;\n\
    \            p /= i;\n        }\n    }\n    for(int i = factors.length - 1; i\
    \ >= 0; i--)\n    {\n        if(factors[i] == 1)\n        {\n            factors[i]\
    \ = p;\n            p *= i;\n        }\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc30n8eam.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(16):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpc30n8eam.d(19): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpc30n8eam.d(41): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(44): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(46): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpc30n8eam.d(49): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpc30n8eam.d(71): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(74):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpc30n8eam.d(76):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpc30n8eam.d(79): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpc30n8eam.d(93): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc30n8eam.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    long\
    \ count = 0;\n    long temp;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        temp = n;\n        while(temp > 1)\n        {\n            temp\
    \ = temp / factor;\n            factors[count++] = factor;\n        }\n      \
    \  factor = 1;\n        p = p * i;\n    }\n    factors[count++] = factor;\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n  \
    \  long count = 0;\n    long temp;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        temp = n;\n        while(temp > 1)\n        {\n       \
    \     temp = temp / factor;\n            factors[count++] = factor;\n        }\n\
    \        factor = 1;\n        p = p * i;\n    }\n    factors[count++] = factor;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, int factorizationOrderLimit)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long factor = 1;\n    long count = 0;\n    long temp;\n    for(int i = 0;\
    \ i <= (int)Math.sqrt(n); i++)\n    {\n        temp = n;\n        while(temp >\
    \ 1)\n        {\n            temp = temp / factor;\n            factors[count++]\
    \ = factor;\n        }\n        factor = 1;\n        p = p * i;\n    }\n    factors[count++]\
    \ = factor;\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, int factorizationOrderLimit,\
    \ int factorizationOrderLimitLimit\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqs9ogfet.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(16):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(43):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(65):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(70):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqs9ogfet.d(91):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqs9ogfet.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorsCount\
    \ = 0;\n    long factorsCount2 = 0;\n    long factorsCount3 = 0;\n    long factorsCount4\
    \ = 0;\n    long factorsCount5 = 0;\n    long factorsCount6 = 0;\n    long factorsCount7\
    \ = 0;\n    long factorsCount8 = 0;\n    long factorsCount9 = 0;\n    long factorsCount10\
    \ = 0;\n    long factorsCount11 = 0;\n    long factorsCount12 = 0;\n    long factorsCount13\
    \ = 0;\n    long factorsCount14 = 0;\n    long factorsCount15 = 0;\n    long factorsCount16\
    \ = 0;\n    long factorsCount17 = 0;\n    long factorsCount18 = 0;\n    long factorsCount19\
    \ = 0;\n    long factorsCount20 = 0;\n    long factorsCount21 = 0;\n    long factorsCount22\
    \ = 0;\n    long factorsCount23 = 0;\n    long factorsCount24 = 0;\n    long factorsCount25\
    \ = 0;\n    long factorsCount26 = 0;\n    long factorsCount27 = 0;\n    long factorsCount28\
    \ = 0;\n    long factorsCount29 = 0;\n    long factorsCount30 = 0;\n    long factorsCount31\
    \ = 0;\n    long factorsCount32 = 0;\n    long factorsCount33 = 0;\n    long factorsCount34\
    \ = 0;\n    long factorsCount35 = 0;\n    long factorsCount36 = 0;\n    long factorsCount37\
    \ = 0;\n    long factorsCount38 = 0;\n    long factorsCount39 = 0;\n    long factorsCount40\
    \ = 0;\n    long factorsCount41 = 0;\n    long factorsCount42 = 0;\n    long factorsCount43\
    \ = 0;\n    long factorsCount44 = 0;\n    long factorsCount45 = 0;\n    long factorsCount46\
    \ = 0;\n    long factorsCount47 = 0;\n    long factorsCount48 = 0;\n    long factorsCount49\
    \ = 0;\n    long factorsCount50 = 0;\n    long factorsCount51 = 0;\n    long factorsCount52\
    \ = 0;\n    long factorsCount53 = 0;\n    long factorsCount54 = 0;\n    long factorsCount55\
    \ = 0;\n    long factorsCount56 = 0;\n    long factorsCount57 = 0;\n    long factorsCount58\
    \ = 0;\n    long factorsCount59 = 0;\n    long factorsCount60 = 0;\n    long factorsCount61\
    \ = 0;\n    long factorsCount\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp79vmyfzy.d(76): Error: semicolon expected, not \''unittest\''\n/tmp/tmp79vmyfzy.d(76):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp79vmyfzy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)+1];\n\
    \    long factor = 1;\n    long factorization = 1;\n    long factorizationCount\
    \ = 0;\n    long factorizationSum = 0;\n    long factorizationProduct = 1;\n \
    \   long factorizationProductSum = 0;\n    long factorizationProductProduct =\
    \ 1;\n    long factorizationProductProductSum = 0;\n    long factorizationProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductSum = 0;\n    long factorizationProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductSum = 0;\n    long factorizationProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductSum = 0;\n    long factorizationProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductSum = 0;\n    long factorizationProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductSum = 0;\n    long factorizationProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductSum = 0;\n    long factorizationProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductSum = 0;\n  \
    \  long factorizationProductProductProductProductProductProduct = 1;\n    long\
    \ factorizationProductProductProductProductProductSum = 0;\n    long factorizationProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductSum =\
    \ 0;\n    long factorizationProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1;\n    long factorizationProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0;\n    long factorizationProductProductProductProductProductProductProductProductProductProduct\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptss8a1p2.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptss8a1p2.d(53):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmptss8a1p2.d(53): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmptss8a1p2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdsn00e9z.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpdsn00e9z.d(17):
    Error: C style cast illegal, use cast(int)i\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdsn00e9z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factor_count = 1;\n\
    \    long factor_index = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % factor == 0) {\n            factors[factor_index] = factor;\n\
    \            factor_count++;\n            n /= factor;\n            factor++;\n\
    \        }\n        factor_index++;\n    }\n    factors[factor_index] = n;\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorization_size) \n{\n    long[] factors\
    \ = new long[factorization_size];\n    long factor = 1;\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(n % factor == 0) {\n            factors[factor_index]\
    \ = factor;\n            factor_count++;\n            n /= factor;\n         \
    \   factor++;\n        }\n        factor_index++;\n    }\n    factors[factor_index]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorization_size, int factorization_index)\
    \ \n{\n    long[] factors = new long[factorization_size];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    for(int i = 0; i\
    \ <= (int)Math.sqrt(n); i++) {\n        while(n % factor == 0) {\n           \
    \ factors[factor_index] = factor;\n            factor_count++;\n            n\
    \ /= factor;\n            factor++;\n        }\n        factor_index++;\n    }\n\
    \    factors[factor_index] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorization_size,\
    \ int factorization_index, int factorization_size2) \n{\n    long[] factors =\
    \ new long[factorization_size2];\n    long factor = 1;\n\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphbjsx1vs.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmphbjsx1vs.d(15):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmphbjsx1vs.d(39):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmphbjsx1vs.d(63):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmphbjsx1vs.d(86):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmphbjsx1vs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        while(n % i == 0)\
    \ {\n            factors[factorCount] = i;\n            n /= i;\n            factorCount++;\n\
    \        }\n    }\n    factors[factorCount] = n;\n    factorCount++;\n    for(int\
    \ i = 0; i <= factorCount; i++) {\n        factor *= factors[i];\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        while(n % i\
    \ == 0) {\n            factors[factorCount] = i;\n            n /= i;\n      \
    \      factorCount++;\n        }\n    }\n    factors[factorCount] = n;\n    factorCount++;\n\
    \    for(int i = 0; i <= factorCount; i++) {\n        factor *= factors[i];\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i = start; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(n % i == 0) {\n            factors[factorCount] = i;\n\
    \            n /= i;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    factorCount++;\n    for(int i = 0; i <= factorCount; i++) {\n    \
    \    factor *= factors[i];\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, long[] factors,\
    \ int start, int end) \n{\n    long factor = 1;\n    long factorCount = 0;\n \
    \   for(int i = start; i <= end; i++) {\n        while(n % i == 0) {\n       \
    \     factors[factorCount] = i;\n            n /= \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8g5ibrhm.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g5ibrhm.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g5ibrhm.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g5ibrhm.d(62):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp8g5ibrhm.d(90):
    Error: expression expected, not \''unittest\''\n/tmp/tmp8g5ibrhm.d(91): Error:
    found \''{\'' when expecting \'';\'' following statement\n/tmp/tmp8g5ibrhm.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp8g5ibrhm.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8g5ibrhm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsbz712jy.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpsbz712jy.d(13):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpsbz712jy.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpsbz712jy.d(24): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbz712jy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long count = 0;\n    long\
    \ factorization[] = new long[(int)Math.sqrt(n)];\n    long temp;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = 0;\n    }\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        for(int j = i;\
    \ j <= (int)Math.sqrt(n); j++)\n        {\n            if(n % i == 0 && n % j\
    \ == 0)\n            {\n                factors[(int)Math.sqrt(n)] = factors[(int)Math.sqrt(n)]\
    \ + 1;\n                factorization[(int)Math.sqrt(n)] = i;\n              \
    \  factorization[(int)Math.sqrt(n) + 1] = j;\n            }\n        }\n    }\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        temp = factors[i];\n\
    \        while(temp > 0)\n        {\n            temp = temp / factorization[i];\n\
    \            factors[i] = factors[i] * factorization[i];\n        }\n    }\n \
    \   for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factors[i]\
    \ + 1;\n    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,c#\
    \ |>\n<| c |>\nThis code doesn't work for n = 10. Factorization is {1, 2, 3, 5}.\
    \ Factorization should be {1, 2, 3, 5, 7, 11, 13, 17, 19, 23}\n<|/ c |>\n<| c\
    \ |>\nIt works for me. Factorization is {1, 2, 3, 5, 7, 11, 13, 17, 19, 23}\n\
    <|/ c |>\n<| c |>\nI tested it with n = 10 and it returned {1, 2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23}\n<|/ c |>\n<| c |>\nI tested it with n = 10 and it returned\
    \ {1, 2, 3, 5, 7, 11, 13, 17, 19, 23}\n<|/ c |>\n<| c |>\nI tested it with n =\
    \ 10 and it returned {1, 2, 3, 5, 7, 11, 13, 17, 19, 23}\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyy6y4uty.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(16):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(20):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(22):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(26):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(26):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(27):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(28):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(32):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(41):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpyy6y4uty.d(47):
    Error: Declaration expected, not \''<\''\n/tmp/tmpyy6y4uty.d(50): Error: unterminated
    character constant\n/tmp/tmpyy6y4uty.d(67): Error: semicolon expected, not \''.\''\n/tmp/tmpyy6y4uty.d(67):
    Error: no identifier for declarator .Collections.Generic\n/tmp/tmpyy6y4uty.d(68):
    Error: semicolon expected, not \''.\''\n/tmp/tmpyy6y4uty.d(68): Error: no identifier
    for declarator .Linq\n/tmp/tmpyy6y4uty.d(69): Error: semicolon expected, not \''.\''\n/tmp/tmpyy6y4uty.d(69):
    Error: no identifier for declarator .Text\n/tmp/tmpyy6y4uty.d(70): Error: semicolon
    expected, not \''.\''\n/tmp/tmpyy6y4uty.d(70): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyy6y4uty.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount] = factor;\n            factorCount++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=primes,c#,factorization |>\n\
    <| c |>\nThis doesn't work for factors larger than the square root of the number.\
    \ For example, factorize(100) returns [2,2,2,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcx_5ph24.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcx_5ph24.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpcx_5ph24.d(27):
    Error: Declaration expected, not \''<\''\n/tmp/tmpcx_5ph24.d(30): Error: unterminated
    character constant\n/tmp/tmpcx_5ph24.d(35): Error: Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(36):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(37): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(38): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(39): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpcx_5ph24.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(41):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(42): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpcx_5ph24.d(43): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcx_5ph24.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)sqrt(n)+1];\n    long factor = 1;\n    long factor_count = 1;\n  \
    \  long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\n    long factor_index = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_counts[]\
    \ = new long[(int)sqrt(n)+1];\n    long factor_count = 1;\n    long factor_index\
    \ = 0;\n    long factor_counts[] = new long[(int)sqrt(n)+1];\n    long factor_count\
    \ = 1;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1_dvxk1o.d(11): Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(15):
    Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(18): Error:
    C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(21): Error: C style
    cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(24): Error: C style cast
    illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(27): Error: C style cast illegal,
    use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(30): Error: C style cast illegal, use
    cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(33): Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(36):
    Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(39): Error:
    C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(42): Error: C style
    cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(45): Error: C style cast
    illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(48): Error: C style cast illegal,
    use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(51): Error: C style cast illegal, use
    cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(54): Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(57):
    Error: C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(60): Error:
    C style cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(63): Error: C style
    cast illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(66): Error: C style cast
    illegal, use cast(int)sqrt(n)\n/tmp/tmp1_dvxk1o.d(68): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_dvxk1o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n        {\n\
    \            factors[factorCount] = i;\n            factorCount++;\n         \
    \   n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo718gecv.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo718gecv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    std.math.factorize(n,\
    \ factors);\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,\
    \ factors);\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,\
    \ factors, start);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors, int start, int\
    \ end) \n{\n    std.math.factorize(n, factors, start, end);\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, long[] factors, int start, int end, int step) \n{\n    std.math.factorize(n,\
    \ factors, start, end, step);\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, long[] factors,\
    \ int start, int end, int step, long max) \n{\n    std.math.factorize(n, factors,\
    \ start, end, step, max);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factor\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpubu30945.d(70): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpubu30945.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=algorithm,math,primes,java |>\n<| c |>\nThis algorithm\
    \ is very inefficient. `factorize` will take O(n) time where n is the number to\
    \ be factored. `factorize` will also take O(n^2) time where n is the number of\
    \ factors. In total the algorithm will take O(n^2) time where n is the number\
    \ to be factored.\n<|/ c |>\n<| c |>\nI agree with you, but I didn't want to change\
    \ his algorithm, because he asked for prime factors. I thought that he will understand\
    \ how to implement it by himself.\n<|/ c |>\n<| c |>\nI agree with you, but I\
    \ didn't want to change his algorithm, because he asked for prime factors. I thought\
    \ that he will understand how to implement it by himself.\n<|/ c |>\n<| c |>\n\
    I agree with you, but I didn't want to change his algorithm, because he asked\
    \ for prime factors. I thought that he will understand how to implement it by\
    \ himself.\n<|/ c |>\n<| c |>\nI agree with you, but I didn't want to change his\
    \ algorithm, because he asked for prime factors. I thought that he will understand\
    \ how to implement it by himself.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu8k2iaac.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpu8k2iaac.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpu8k2iaac.d(24): Error: Declaration
    expected, not \''<\''\n/tmp/tmpu8k2iaac.d(30): Error: unterminated character constant\n/tmp/tmpu8k2iaac.d(33):
    Error: unterminated character constant\n/tmp/tmpu8k2iaac.d(36): Error: unterminated
    character constant\n/tmp/tmpu8k2iaac.d(39): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8k2iaac.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbad29qcj.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpbad29qcj.d(112):
    Error: no identifier for declarator long\n/tmp/tmpbad29qcj.d(112): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbad29qcj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    long\
    \ maxFactor = n;\n    for(int i = 1; i < factors.length; i++)\n    {\n       \
    \ while(n % factor == 0)\n        {\n            factors[counter] = factor;\n\
    \            n /= factor;\n            counter++;\n        }\n        factor++;\n\
    \    }\n    factors[counter] = n;\n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        if(factors[i] == 1)\n        {\n            factors[i] = 0;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactor) \n{\n    long factors[]\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n\
    \    long maxFactor = n;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[counter] = factor;\n\
    \            n /= factor;\n            counter++;\n        }\n        factor++;\n\
    \    }\n    factors[counter] = n;\n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        if(factors[i] == 1)\n        {\n            factors[i] = 0;\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int maxFactor, int maxCounter)\
    \ \n{\n    long factors[] = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long maxFactor = n;\n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[counter]\
    \ = factor;\n            n /= factor;\n            counter++;\n        }\n   \
    \     factor++;\n    }\n    factors[counter] = n;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        if(factors[i] == 1)\n        {\n            factors[i]\
    \ = 0;\n        }\n    }\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ckzwif4.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ckzwif4.d(43):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ckzwif4.d(75):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0ckzwif4.d(99):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ckzwif4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n\
    \        {\n            factorCount++;\n            factors[factorCount] = i;\n\
    \            factor *= i;\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work. `factorize(100)` returns `[2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1pos040u.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp1pos040u.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp1pos040u.d(25):
    Error: Declaration expected, not \''<\''\n/tmp/tmp1pos040u.d(28): Error: unterminated
    character constant\n/tmp/tmp1pos040u.d(28): Error: unterminated string constant
    starting at /tmp/tmp1pos040u.d(28)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp1pos040u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factorCount++] = factor;\n            n /=\
    \ factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=math,algorithm,primes,java\
    \ |>\n<| c |>\nThis code is not correct. `factorize` returns factors in reverse\
    \ order. For example, `factorize(10)` returns `[2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt332kzbo.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt332kzbo.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpt332kzbo.d(29): Error: unterminated
    string constant starting at /tmp/tmpt332kzbo.d(29)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpt332kzbo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    long count = 0;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++) {\n        while(n % factor == 0) {\n  \
    \          factors[count++] = factor;\n            n /= factor;\n        }\n \
    \       factor *= i;\n    }\n    factors[count++] = n;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize) \n{\n    long factors[] = new long[factorizationSize];\n\
    \    long factor = 1;\n    long count = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(n % factor == 0) {\n            factors[count++] = factor;\n\
    \            n /= factor;\n        }\n        factor *= i;\n    }\n    factors[count++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, int factorizationMax)\
    \ \n{\n    long factors[] = new long[factorizationSize];\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n    \
    \    while(n % factor == 0) {\n            factors[count++] = factor;\n      \
    \      n /= factor;\n        }\n        factor *= i;\n    }\n    factors[count++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationSize, int factorizationMax)\
    \ \n{\n    long factors[] = new long[factorizationSize];\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n    \
    \    while(n % factor == 0) {\n            factors[count++] = factor;\n      \
    \      n /= factor;\n        }\n        factor *= i;\n    }\n    factors[count++]\
    \ = n;\n    return factors;\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopquem7r.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpopquem7r.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpopquem7r.d(35):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpopquem7r.d(56):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpopquem7r.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpopquem7r.d(86):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpopquem7r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = n;\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(p % factor\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n           \
    \ p /= factor;\n        }\n        factor *= i;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=primes,c#,algorithm,math |>\n<| a |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd5ekfd28.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpd5ekfd28.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpd5ekfd28.d(31): Error: semicolon
    expected, not \''.\''\n/tmp/tmpd5ekfd28.d(31): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpd5ekfd28.d(32): Error: semicolon expected, not \''.\''\n/tmp/tmpd5ekfd28.d(32):
    Error: no identifier for declarator .Linq\n/tmp/tmpd5ekfd28.d(33): Error: semicolon
    expected, not \''.\''\n/tmp/tmpd5ekfd28.d(33): Error: no identifier for declarator
    .Text\n/tmp/tmpd5ekfd28.d(34): Error: semicolon expected, not \''.\''\n/tmp/tmpd5ekfd28.d(34):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd5ekfd28.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long count = 0;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % factor == 0)\n     \
    \   {\n            factors[count++] = factor;\n            n /= factor;\n    \
    \    }\n        factor *= i;\n    }\n    factors[count++] = n;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long count = 0;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[count++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[count++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize,\
    \ bool isPrime) \n{\n    long[] factors = new long[factorizationSize];\n    long\
    \ factor = 1;\n    long count = 0;\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[count++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[count++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize,\
    \ bool isPrime, bool isPrimeOnly) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long count = 0;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[count++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[count++] = n;\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnqcky804.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnqcky804.d(93):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnqcky804.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        while(factor*factor <=\
    \ n)\n        {\n            factors[factorCount++] = factor;\n            factor\
    \ *= i;\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp58hhnt5o.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp58hhnt5o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factor++;\n     \
    \       factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factor++;\n     \
    \       factorCount++;\n            n /= i;\n            if(factorCount >= maxFactors)\n\
    \                break;\n        }\n    }\n    factors[factorCount] = n;\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n  \
    \  long[] factors = new long[(int)std.math.factorial(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factorCount] = i;\n            factor++;\n\
    \            factorCount++;\n            n /= i;\n            if(factorCount >=\
    \ maxFactors)\n                break;\n            if(factorCount >= maxFactorsCount)\n\
    \                break;\n        }\n    }\n    factors[factorCount] = n;\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCount2)\
    \ \n{\n    long[] factors = new long[(int)std.math.factorial(n)];\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7n7cr95m.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp7n7cr95m.d(35):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp7n7cr95m.d(61):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp7n7cr95m.d(89):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp7n7cr95m.d(91):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7n7cr95m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n        if(factors[(int)i]\
    \ == maxFactors)\n        {\n            break;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i\
    \ = 1; i < factors.length; i++)\n    {\n        while(n % factor == 0)\n     \
    \   {\n            factors[(int)i] = factor;\n            n /= factor;\n     \
    \   }\n        factor++;\n        if(factors[(int)i] == maxFactors && factors[(int)i]\
    \ == maxFactorsCount)\n        {\n            break;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCountCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    for(int i = 1; i < factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[(int)i] = factor;\n            n /= factor;\n\
    \        }\n        factor++;\n        if(\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps_rf18ru.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps_rf18ru.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(32): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps_rf18ru.d(38): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(42): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(57): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmps_rf18ru.d(63): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmps_rf18ru.d(67): Error: C style cast illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(67):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(82): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmps_rf18ru.d(88): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmps_rf18ru.d(93): Error: expression
    expected, not \''unittest\''\n/tmp/tmps_rf18ru.d(94): Error: found \''{\'' when
    expecting \'')\''\n/tmp/tmps_rf18ru.d(106): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmps_rf18ru.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[std.math.factorial(n).ceil()];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i < std.math.factorial(n).ceil(); i++)\n    {\n   \
    \     factors[i] = factor;\n        factor *= i;\n        factorCount++;\n   \
    \ }\n    for(int i = std.math.factorial(n).ceil() - 1; i >= 0; i--)\n    {\n \
    \       while(factorCount > 0)\n        {\n            factors[--factorCount]\
    \ = factors[factorCount];\n        }\n        factor *= i;\n        factorCount++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long factorization[]) \n{\n    long factors[]\
    \ = new long[std.math.factorial(n).ceil()];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i < std.math.factorial(n).ceil(); i++)\n    {\n   \
    \     factors[i] = factor;\n        factor *= i;\n        factorCount++;\n   \
    \ }\n    for(int i = std.math.factorial(n).ceil() - 1; i >= 0; i--)\n    {\n \
    \       while(factorCount > 0)\n        {\n            factors[--factorCount]\
    \ = factors[factorCount];\n        }\n        factor *= i;\n        factorCount++;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long factorization[]) \n{\n    long factors[]\
    \ = new long[std.math.factorial(n).ceil()];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i < std.math.factorial(n).ceil(); i++)\n    {\n   \
    \     factors[i] = factor;\n        factor *= i;\n        factorCount++;\n   \
    \ }\n    for(int i = std.math.factorial(n).ceil() - 1; i >= 0; i--)\n    {\n \
    \       while(factorCount > 0)\n        {\n            factors[--factorCount]\
    \ = factors[factorCount];\n        }\n        factor *= i;\n        factorCount++;\n\
    \    }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz4e8jbk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[std.math.factorial(n).ceil()];\n    std.math.factorize(n,factors);\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,factors,start);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end) \n{\n\
    \    std.math.factorize(n,factors,start,end);\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, long[]\
    \ factors, int start, int end, int step) \n{\n    std.math.factorize(n,factors,start,end,step);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end, int step,\
    \ long max) \n{\n    std.math.factorize(n,factors,start,end,step,max);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplutbliij.d(70): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmplutbliij.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2)))];\n    long factor\
    \ = 1;\n    long factor_count = 1;\n    for(int i = 0; i <= std.math.ceil(n/std.math.max(1,std.math.log(n,2)));\
    \ i++)\n    {\n        while(factor <= n && n % factor == 0)\n        {\n    \
    \        factors[factor_count] = factor;\n            factor_count++;\n      \
    \      n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=c++,algorithm,primes |>\n<| c |>\nThis doesn't work for\
    \ large numbers. For example, factorize(100000000) returns [2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0fixvzdj.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)))\n/tmp/tmp0fixvzdj.d(26): Error: Declaration
    expected, not \''<\''\n/tmp/tmp0fixvzdj.d(29): Error: unterminated character constant\n/tmp/tmp0fixvzdj.d(34):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(35): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(36): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(37): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp0fixvzdj.d(38): Error: Declaration expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(39):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(40): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(41): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp0fixvzdj.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fixvzdj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceiling((double)n/2)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n           \
    \ n /= factor;\n        }\n        factor++;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)std.math.ceiling((double)n/maxFactors)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount) \n{\n    long[] factors = new long[(int)std.math.ceiling((double)n/maxFactors)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount, int maxFactorsCount2) \n{\n    long[] factors = new long[(int)std.math.ceiling((double)n/maxFactors)];\n\
    \    long factor = 1;\n    long factorCount = 0;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptyi4f0fu.d(11): Error: C style cast illegal, use cast(double)n\n/tmp/tmptyi4f0fu.d(11):
    Error: C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmptyi4f0fu.d(34):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmptyi4f0fu.d(34): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmptyi4f0fu.d(57):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmptyi4f0fu.d(57): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmptyi4f0fu.d(80):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmptyi4f0fu.d(80): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmptyi4f0fu.d(83):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptyi4f0fu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    long factorSum = 0;\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        factors[i] = 0;\n    }\n    for(int\
    \ i = 1; i <= n; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n\
    \            if(n % i == 0)\n            {\n                factors[j] = factors[j]\
    \ + 1;\n                factorCount = factorCount + 1;\n            }\n      \
    \  }\n    }\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factorProduct\
    \ = factorProduct * i;\n        factorSum = factorSum + factors[i];\n    }\n \
    \   for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i]\
    \ == 0)\n        {\n            factors[i] = 1;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n  \
    \      {\n            factors[i] = factorCount;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n  \
    \      {\n            factors[i] = factorProduct;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n  \
    \      {\n            factors[i] = factorSum;\n        }\n    }\n    for(int i\
    \ = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 0)\n    \
    \    {\n            factors[i] = factors[i];\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationOrder) \n{\n    long factors[] = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    long factorProduct = 1;\n\
    \    long factorSum = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n  \
    \  {\n        factors[i] = 0;\n    }\n    for(int i = 1; i <= n; i++)\n    {\n\
    \        for(int j = 0; j < i; j++)\n        {\n            if(n % i == 0)\n \
    \           {\n                factors[j] = factors[j] + 1;\n                factorCount\
    \ = factorCount + 1;\n            }\n        }\n    }\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        factorProduct = factorProduct * i;\n\
    \        factorSum = factorSum + \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy9casc5y.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(16):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(31):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(36):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(43):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(50):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(57):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(64):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(81):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(86):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(101):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpy9casc5y.d(105):
    Error: expression expected, not \''unittest\''\n/tmp/tmpy9casc5y.d(106): Error:
    found \''{\'' when expecting \'';\'' following statement\n/tmp/tmpy9casc5y.d(118):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9casc5y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factorCount++] = factor;\n            n /=\
    \ factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a |>\n<| a tags=c#,primes,algorithm\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfy2s8z5t.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpfy2s8z5t.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpfy2s8z5t.d(31): Error: semicolon
    expected, not \''.\''\n/tmp/tmpfy2s8z5t.d(31): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpfy2s8z5t.d(32): Error: semicolon expected, not \''.\''\n/tmp/tmpfy2s8z5t.d(32):
    Error: no identifier for declarator .Linq\n/tmp/tmpfy2s8z5t.d(33): Error: semicolon
    expected, not \''.\''\n/tmp/tmpfy2s8z5t.d(33): Error: no identifier for declarator
    .Text\n/tmp/tmpfy2s8z5t.d(34): Error: semicolon expected, not \''.\''\n/tmp/tmpfy2s8z5t.d(34):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpfy2s8z5t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i] = factor;\n            n /= p;\n            p++;\n\
    \        }\n        factor++;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long\
    \ p = 1;\n    long factor = 1;\n    for(int i = 0; i<factors.length; i++)\n  \
    \  {\n        while(n % p == 0)\n        {\n            factors[(int)i] = factor;\n\
    \            n /= p;\n            p++;\n        }\n        factor++;\n       \
    \ if(factor>maxFactors)\n            break;\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCount) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long p = 1;\n    long factor = 1;\n    for(int i = 0; i<factors.length; i++)\n\
    \    {\n        while(n % p == 0)\n        {\n            factors[(int)i] = factor;\n\
    \            n /= p;\n            p++;\n        }\n        factor++;\n       \
    \ if(factor>maxFactors)\n            break;\n        if(factor>maxFactorsCount)\n\
    \            break;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount, int maxFactorsCountCount) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i<factors.length; i++)\n    {\n        while(n % p == 0)\n        {\n\
    \            factors[(int)i] = factor;\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp17mmm5b_.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp17mmm5b_.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmp17mmm5b_.d(34): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp17mmm5b_.d(41): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmp17mmm5b_.d(59): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp17mmm5b_.d(66): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmp17mmm5b_.d(86): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmp17mmm5b_.d(93): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmp17mmm5b_.d(95): Error: found \''unittest\'' instead of
    statement\n/tmp/tmp17mmm5b_.d(108): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmp17mmm5b_.d(108): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp17mmm5b_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.Ceiling(Math.Log(n,2))+1];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.Ceiling(Math.Log(n,2));\
    \ i++)\n    {\n        factorCount = 0;\n        while(n % factor == 0)\n    \
    \    {\n            factorCount++;\n            n /= factor;\n        }\n    \
    \    result[i] = factorCount;\n        factor *= i;\n    }\n    result[(int)Math.Ceiling(Math.Log(n,2))]\
    \ = n;\n    return result;\n}\n</code>\n<|/ a tags=algorithm,primes,math,c# |>\n\
    <| c |>\nThe first two lines of code are unnecessary. `Math.Log` can handle negative\
    \ numbers and `Math.Ceiling` can handle negative numbers. `Math.Log` will return\
    \ a negative number if the number is negative, `Math.Ceiling` will return a negative\
    \ number if the number is negative.\n<|/ c |>\n<| c |>\nYes, Math.Log can handle\
    \ negative numbers. Math.Ceiling can handle negative numbers. Math.Log will return\
    \ a negative number if the number is negative, Math.Ceiling will return a negative\
    \ number if the number is negative.\n<|/ c |>\n<| c |>\nThe first two lines of\
    \ code are unnecessary. Math.Log can handle negative numbers and Math.Ceiling\
    \ can handle negative numbers. Math.Log will return a negative number if the number\
    \ is negative, Math.Ceiling will return a negative number if the number is negative.\n\
    <|/ c |>\n<| c |>\nThe first two lines of code are unnecessary. Math.Log can handle\
    \ negative numbers and Math.Ceiling can handle negative numbers. Math.Log will\
    \ return a negative number if the number is negative, Math.Ceiling will return\
    \ a negative number if the number is negative.\n<|/ c |>\n<| c |>\nThe first two\
    \ lines of code are unnecessary. Math.Log can handle negative numbers and Math.Ceiling\
    \ can handle negative numbers. Math.Log will return a negative number if the number\
    \ is negative, Math.Ceiling will return a negative number if the number is negative.\n\
    <|/ c |>\n<| a tags=algorithm,primes,math,c# |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1d2hrm83.d(11): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmp1d2hrm83.d(14): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmp1d2hrm83.d(25): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmp1d2hrm83.d(28): Error: Declaration expected, not \''<\''\n/tmp/tmp1d2hrm83.d(48):
    Error: semicolon expected, not \''.\''\n/tmp/tmp1d2hrm83.d(48): Error: no identifier
    for declarator .Collections.Generic\n/tmp/tmp1d2hrm83.d(49): Error: semicolon
    expected, not \''.\''\n/tmp/tmp1d2hrm83.d(49): Error: no identifier for declarator
    .Linq\n/tmp/tmp1d2hrm83.d(50): Error: semicolon expected, not \''.\''\n/tmp/tmp1d2hrm83.d(50):
    Error: no identifier for declarator .Text\n/tmp/tmp1d2hrm83.d(51): Error: semicolon
    expected, not \''.\''\n/tmp/tmp1d2hrm83.d(51): Error: no identifier for declarator
    .Threading.Tasks\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1d2hrm83.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.factorial(n).floor()];\n    long factor = 1;\n    for(int i =\
    \ 0; i < factors.length; i++)\n    {\n        while(n % factor == 0)\n       \
    \ {\n            factors[factors.length - 1 - i] = factor;\n            n /= factor;\n\
    \        }\n        factor++;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ maxFactors) \n{\n    long[] factors = new long[maxFactors];\n    long factor\
    \ = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n        while(n %\
    \ factor == 0)\n        {\n            factors[factors.length - 1 - i] = factor;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCount) \n{\n    long[] factors = new long[maxFactors];\n\
    \    long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n  \
    \      while(n % factor == 0)\n        {\n            factors[factors.length -\
    \ 1 - i] = factor;\n            n /= factor;\n        }\n        factor++;\n \
    \   }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount, int maxFactorsCountLimit)\
    \ \n{\n    long[] factors = new long[maxFactors];\n    long factor = 1;\n    for(int\
    \ i = 0; i < factors.length; i++)\n    {\n        while(n % factor == 0)\n   \
    \     {\n            factors[factors.length - 1 - i] = factor;\n            n\
    \ /= factor;\n        }\n        factor++;\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeare\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzs8qfa4k.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpzs8qfa4k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorProduct\
    \ = 1;\n    long factorSum = 0;\n    long factorSumCount = 0;\n    long factorSumProduct\
    \ = 1;\n    long factorSumProductCount = 0;\n    long factorSumProductSum = 1;\n\
    \    long factorSumProductSumCount = 0;\n    long factorSumProductSumProduct =\
    \ 1;\n    long factorSumProductSumProductCount = 0;\n    long factorSumProductSumProductSum\
    \ = 1;\n    long factorSumProductSumProductSumCount = 0;\n    long factorSumProductSumProductSumProduct\
    \ = 1;\n    long factorSumProductSumProductSumProductCount = 0;\n    long factorSumProductSumProductSumProductSum\
    \ = 1;\n    long factorSumProductSumProductSumProductSumCount = 0;\n    long factorSumProductSumProductSumProductSumProduct\
    \ = 1;\n    long factorSumProductSumProductSumProductSumProductCount = 0;\n  \
    \  long factorSumProductSumProductSumProductSumProductSum = 1;\n    long factorSumProductSumProductSumProductSumProductSumCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProduct = 1;\n\
    \    long factorSumProductSumProductSumProductSumProductSumProductCount = 0;\n\
    \    long factorSumProductSumProductSumProductSumProductSumProductSum = 1;\n \
    \   long factorSumProductSumProductSumProductSumProductSumProductSumCount = 0;\n\
    \    long factorSumProductSumProductSumProductSumProductSumProductSum = 1;\n \
    \   long factorSumProductSumProductSumProductSumProductSumProductSumCount = 0;\n\
    \    long factorSumProductSumProductSumProductSumProductSumProductSumProduct =\
    \ 1;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductSum\
    \ = 1;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductSumProduct\
    \ = 1;\n    long factorSumProductSumProductSumProductSumProductSumProductSumProductSumProductCount\
    \ = 0;\n    long factorSumProductSumProductSumProductSumProductSumProductSum\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjcu0w7v2.d(50): Error: semicolon expected, not \''unittest\''\n/tmp/tmpjcu0w7v2.d(50):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjcu0w7v2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.factorial(n)];\n    std.math.factorize(n, factors);\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,\
    \ factors);\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,\
    \ factors, start);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, long[] factors, int start, int\
    \ end) \n{\n    std.math.factorize(n, factors, start, end);\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, long[] factors, int start, int end, int step) \n{\n    std.math.factorize(n,\
    \ factors, start, end, step);\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, long[] factors,\
    \ int start, int end, int step, long mod) \n{\n    std.math.factorize(n, factors,\
    \ start, end, step, mod);\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw_oujlt9.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmpw_oujlt9.d(70):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_oujlt9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(p % i == 0)\n       \
    \ {\n            factor *= i;\n            p /= i;\n        }\n        else\n\
    \        {\n            factors[i] = factor;\n            factor = 1;\n      \
    \  }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n    return factors;\n}\n\
    /*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long\
    \ p = n;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(p % i == 0)\n        {\n            factor *= i;\n        \
    \    p /= i;\n        }\n        else\n        {\n            factors[i] = factor;\n\
    \            factor = 1;\n        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int max, int max2) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n    long factor = 1;\n  \
    \  for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(p % i == 0)\n\
    \        {\n            factor *= i;\n            p /= i;\n        }\n       \
    \ else\n        {\n            factors[i] = factor;\n            factor = 1;\n\
    \        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int max, int max2, int max3) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = n;\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt_ov60yf.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(27):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(38):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(41):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(54):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(65):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(68):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(81):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(92):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(95):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt_ov60yf.d(96):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpt_ov60yf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0hu6c7y0.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0hu6c7y0.d(13):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0hu6c7y0.d(17):
    Error: C style cast illegal, use cast(int)i\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0hu6c7y0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long temp;\n    int count = 0;\n    for(int i = 2;\
    \ i <= n; i++)\n    {\n        temp = i;\n        while(temp % 2 == 0)\n     \
    \   {\n            temp /= 2;\n            count++;\n        }\n        if(temp\
    \ > 1)\n        {\n            for(int j = 0; j < count; j++)\n            {\n\
    \                result[count] = temp;\n                count++;\n           \
    \ }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.Scanner;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2sheqggs.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp2sheqggs.d(34):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp2sheqggs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,std.math.log(n,2))) + 1];\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    std.math.factorize(n,factors);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    std.math.factorize(n,factors,start);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end) \n{\n\
    \    std.math.factorize(n,factors,start,end);\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, long[]\
    \ factors, int start, int end, int step) \n{\n    std.math.factorize(n,factors,start,end,step);\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factors, int start, int end, int step,\
    \ long max) \n{\n    std.math.factorize(n,factors,start,end,step,max);\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7cbu_yqq.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, std.math.log(n, 2)))\n/tmp/tmp7cbu_yqq.d(70): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7cbu_yqq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long p = n;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        long q = n/p;\n        if(q == 1)\n        {\n        \
    \    factors[i] = 1;\n        }\n        else\n        {\n            factors[i]\
    \ = factorize(q);\n        }\n        p = p * factors[i];\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long p = n;\n    for(int i = 0; i < factors.length; i++)\n    {\n       \
    \ long q = n/p;\n        if(q == 1)\n        {\n            factors[i] = 1;\n\
    \        }\n        else\n        {\n            factors[i] = factorize(q, factorizationSize);\n\
    \        }\n        p = p * factors[i];\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationSize, bool useSieve)\n{\n    long[] factors = new long[factorizationSize];\n\
    \    long p = n;\n    for(int i = 0; i < factors.length; i++)\n    {\n       \
    \ long q = n/p;\n        if(q == 1)\n        {\n            factors[i] = 1;\n\
    \        }\n        else\n        {\n            factors[i] = factorize(q, factorizationSize,\
    \ useSieve);\n        }\n        p = p * factors[i];\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int factorizationSize, bool useSieve, bool useSieve2)\n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long p = n;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        long q = n/p;\n        if(q == 1)\n        {\n        \
    \    factors[i] = 1;\n        }\n        else\n        {\n            factors[i]\
    \ = factorize(q, factorizationSize, useSieve, useSie\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp30snkprm.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp30snkprm.d(98):
    Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmp30snkprm.d(111): Error:
    found \''void\'' when expecting \'',\''\n/tmp/tmp30snkprm.d(111): Error: found
    \''{\'' when expecting \'',\''\n/tmp/tmp30snkprm.d(111): Error: expression expected,
    not \''}\''\n/tmp/tmp30snkprm.d(111): Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp30snkprm.d(111):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp30snkprm.d(111): Error:
    found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmp30snkprm.d(111):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp30snkprm.d(111):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp30snkprm.d(111):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp30snkprm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n)];\n    long factor = 1;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)std.math.gcd(n)]\
    \ += 1;\n            n /= factor;\n        }\n        factor *= i;\n    }\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n  \
    \      while(n % factor == 0)\n        {\n            factors[(int)std.math.gcd(n)]\
    \ += 1;\n            n /= factor;\n        }\n        factor *= i;\n    }\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int max, int factorization) \n{\n    long[] factors\
    \ = new long[(int)std.math.gcd(n)];\n    long factor = 1;\n    for(int i = 0;\
    \ i < factors.length; i++)\n    {\n        while(n % factor == 0)\n        {\n\
    \            factors[(int)std.math.gcd(n)] += 1;\n            n /= factor;\n \
    \       }\n        factor *= i;\n    }\n    return factors;\n}\n/*\n Return list\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ max, int factorization, int factorization2) \n{\n    long[] factors = new long[(int)std.math.gcd(n)];\n\
    \    long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n  \
    \      while(n % factor == 0)\n        {\n            factors[(int)std.math.gcd(n)]\
    \ += 1;\n            n /= factor;\n        }\n        factor *= i;\n    }\n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk_lij_61.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(17):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(32):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(38):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(53):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(59):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(74):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(80):
    Error: C style cast illegal, use cast(int)std.math.gcd(n)\n/tmp/tmpk_lij_61.d(87):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_lij_61.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCount2 = 0;\n    long factorCount3 = 0;\n    long factorCount4\
    \ = 0;\n    long factorCount5 = 0;\n    long factorCount6 = 0;\n    long factorCount7\
    \ = 0;\n    long factorCount8 = 0;\n    long factorCount9 = 0;\n    long factorCount10\
    \ = 0;\n    long factorCount11 = 0;\n    long factorCount12 = 0;\n    long factorCount13\
    \ = 0;\n    long factorCount14 = 0;\n    long factorCount15 = 0;\n    long factorCount16\
    \ = 0;\n    long factorCount17 = 0;\n    long factorCount18 = 0;\n    long factorCount19\
    \ = 0;\n    long factorCount20 = 0;\n    long factorCount21 = 0;\n    long factorCount22\
    \ = 0;\n    long factorCount23 = 0;\n    long factorCount24 = 0;\n    long factorCount25\
    \ = 0;\n    long factorCount26 = 0;\n    long factorCount27 = 0;\n    long factorCount28\
    \ = 0;\n    long factorCount29 = 0;\n    long factorCount30 = 0;\n    long factorCount31\
    \ = 0;\n    long factorCount32 = 0;\n    long factorCount33 = 0;\n    long factorCount34\
    \ = 0;\n    long factorCount35 = 0;\n    long factorCount36 = 0;\n    long factorCount37\
    \ = 0;\n    long factorCount38 = 0;\n    long factorCount39 = 0;\n    long factorCount40\
    \ = 0;\n    long factorCount41 = 0;\n    long factorCount42 = 0;\n    long factorCount43\
    \ = 0;\n    long factorCount44 = 0;\n    long factorCount45 = 0;\n    long factorCount46\
    \ = 0;\n    long factorCount47 = 0;\n    long factorCount48 = 0;\n    long factorCount49\
    \ = 0;\n    long factorCount50 = 0;\n    long factorCount51 = 0;\n    long factorCount52\
    \ = 0;\n    long factorCount53 = 0;\n    long factorCount54 = 0;\n    long factorCount55\
    \ = 0;\n    long factorCount56 = 0;\n    long factorCount57 = 0;\n    long factorCount58\
    \ = 0;\n    long factorCount59 = 0;\n    long factorCount60 = 0;\n    long factorCount61\
    \ = 0;\n    long factorCount62 = 0;\n    long factorCount63 = 0;\n    long factorCount64\
    \ = 0;\n    long factorCount65 = 0;\n    long factorCount66 = 0;\n    long factorCount67\
    \ = 0;\n    long factorCount68 = 0;\n    long factorCount69 = 0;\n    long factorCount70\
    \ = 0;\n    long factorCount71 = 0;\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpemrk2dbf.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpemrk2dbf.d(85):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpemrk2dbf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factor_count = 1;\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n\
    \        {\n            factor_count++;\n            factors[i] = factor;\n  \
    \          factor *= i;\n        }\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorization) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long\
    \ factor = 1;\n    long factor_count = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n%i == 0)\n        {\n            factor_count++;\n\
    \            factors[i] = factor;\n            factor *= i;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorization, int factorization_type)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factor_count++;\n       \
    \     factors[i] = factor;\n            factor *= i;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n                \n*/\n\
    long[] factorize(long n, int factorization, int factorization_type, int factorization_type_type)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factor_count++;\n       \
    \     factors[i] = factor;\n            factor *= i;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprdhz4viw.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(33):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(36):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(55):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(58):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(80):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmprdhz4viw.d(91):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprdhz4viw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor ==\
    \ 0)\n        {\n            factors[factorCount++] = factor;\n            n /=\
    \ factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=c++,algorithm,primes |>\n\
    <| c |>\nThis code doesn't work for me. `factorize` returns `[1, 1, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmj37f5yz.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpmj37f5yz.d(26):
    Error: Declaration expected, not \''<\''\n/tmp/tmpmj37f5yz.d(29): Error: unterminated
    character constant\n/tmp/tmpmj37f5yz.d(29): Error: unterminated string constant
    starting at /tmp/tmpmj37f5yz.d(29)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmj37f5yz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorProduct\
    \ = 1;\n    long factorSum = 0;\n    long factorSum2 = 0;\n    long factorSum3\
    \ = 0;\n    long factorSum4 = 0;\n    long factorSum5 = 0;\n    long factorSum6\
    \ = 0;\n    long factorSum7 = 0;\n    long factorSum8 = 0;\n    long factorSum9\
    \ = 0;\n    long factorSum10 = 0;\n    long factorSum11 = 0;\n    long factorSum12\
    \ = 0;\n    long factorSum13 = 0;\n    long factorSum14 = 0;\n    long factorSum15\
    \ = 0;\n    long factorSum16 = 0;\n    long factorSum17 = 0;\n    long factorSum18\
    \ = 0;\n    long factorSum19 = 0;\n    long factorSum20 = 0;\n    long factorSum21\
    \ = 0;\n    long factorSum22 = 0;\n    long factorSum23 = 0;\n    long factorSum24\
    \ = 0;\n    long factorSum25 = 0;\n    long factorSum26 = 0;\n    long factorSum27\
    \ = 0;\n    long factorSum28 = 0;\n    long factorSum29 = 0;\n    long factorSum30\
    \ = 0;\n    long factorSum31 = 0;\n    long factorSum32 = 0;\n    long factorSum33\
    \ = 0;\n    long factorSum34 = 0;\n    long factorSum35 = 0;\n    long factorSum36\
    \ = 0;\n    long factorSum37 = 0;\n    long factorSum38 = 0;\n    long factorSum39\
    \ = 0;\n    long factorSum40 = 0;\n    long factorSum41 = 0;\n    long factorSum42\
    \ = 0;\n    long factorSum43 = 0;\n    long factorSum44 = 0;\n    long factorSum45\
    \ = 0;\n    long factorSum46 = 0;\n    long factorSum47 = 0;\n    long factorSum48\
    \ = 0;\n    long factorSum49 = 0;\n    long factorSum50 = 0;\n    long factorSum51\
    \ = 0;\n    long factorSum52 = 0;\n    long factorSum53 = 0;\n    long factorSum54\
    \ = 0;\n    long factorSum55 = 0;\n    long factorSum56 = 0;\n    long factorSum57\
    \ = 0;\n    long factorSum58 = 0;\n    long factorSum59 = 0;\n    long factorSum60\
    \ = 0;\n    long factorSum61 = 0;\n    long factorSum62 = 0;\n    long factorSum63\
    \ = 0;\n    long factorSum64 = 0;\n    long factorSum65 = 0;\n    long factorSum66\
    \ = 0;\n    long factorSum67 = 0;\n    long factorSum68 = 0;\n    long factorSum69\
    \ = 0;\n    long factorSum\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdfmdl0ac.d(85): Error: semicolon expected, not \''unittest\''\n/tmp/tmpdfmdl0ac.d(85):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdfmdl0ac.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long product\
    \ = n;\n    long factorization[] = new long[100];\n    long factorizationCount\
    \ = 0;\n    long factorizationProduct = 1;\n    long factorizationProductCount\
    \ = 0;\n    long factorizationProductCount2 = 0;\n    long factorizationProductCount3\
    \ = 0;\n    long factorizationProductCount4 = 0;\n    long factorizationProductCount5\
    \ = 0;\n    long factorizationProductCount6 = 0;\n    long factorizationProductCount7\
    \ = 0;\n    long factorizationProductCount8 = 0;\n    long factorizationProductCount9\
    \ = 0;\n    long factorizationProductCount10 = 0;\n    long factorizationProductCount11\
    \ = 0;\n    long factorizationProductCount12 = 0;\n    long factorizationProductCount13\
    \ = 0;\n    long factorizationProductCount14 = 0;\n    long factorizationProductCount15\
    \ = 0;\n    long factorizationProductCount16 = 0;\n    long factorizationProductCount17\
    \ = 0;\n    long factorizationProductCount18 = 0;\n    long factorizationProductCount19\
    \ = 0;\n    long factorizationProductCount20 = 0;\n    long factorizationProductCount21\
    \ = 0;\n    long factorizationProductCount22 = 0;\n    long factorizationProductCount23\
    \ = 0;\n    long factorizationProductCount24 = 0;\n    long factorizationProductCount25\
    \ = 0;\n    long factorizationProductCount26 = 0;\n    long factorizationProductCount27\
    \ = 0;\n    long factorizationProductCount28 = 0;\n    long factorizationProductCount29\
    \ = 0;\n    long factorizationProductCount30 = 0;\n    long factorizationProductCount31\
    \ = 0;\n    long factorizationProductCount32 = 0;\n    long factorizationProductCount33\
    \ = 0;\n    long factorizationProductCount34 = 0;\n    long factorizationProductCount35\
    \ = 0;\n    long factorizationProductCount36 = 0;\n    long factorizationProductCount37\
    \ = 0;\n    long factorizationProductCount38 = 0;\n    long factorizationProductCount39\
    \ = 0;\n    long factorizationProductCount40 = 0;\n    long factorizationProductCount41\
    \ = 0;\n    long factorizationProductCount42 = 0;\n    long factorizationProductCount43\
    \ = 0;\n    long factorizationProductCount44 = 0;\n    long factorizationProductCount45\
    \ = 0;\n    long factorizationProductCount46 = 0;\n    long factorizationProductCount47\
    \ = 0;\n    long factorizationProductCount48 = 0;\n    long factorizationProductCount49\
    \ = 0;\n    long factorizationProductCount50 = 0;\n    long factorizationProductCount51\
    \ = 0;\n    long factor\nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpty7yix7n.d(70): Error: semicolon expected, not \''unittest\''\n/tmp/tmpty7yix7n.d(70):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpty7yix7n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    long factor = 1;\n   \
    \ long factorCount = 0;\n    for(int i = 1; i <= std.math.log2(n); i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount] =\
    \ factor;\n            factorCount++;\n            n /= factor;\n        }\n \
    \       factor++;\n    }\n    factors[factorCount] = n;\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptepqnr3t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long count = 0;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[count] = i;\n            count++;\n            n /= i;\n\
    \        }\n    }\n    factors[count] = n;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt5450618.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpt5450618.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpt5450618.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[(int)Math.sqrt(n)];\n    long factorizationCount[] = new long[(int)Math.sqrt(n)];\n\
    \    long factorizationCountSum = 0;\n    long factorizationCountSum2 = 0;\n \
    \   long factorizationCountSum3 = 0;\n    long factorizationCountSum4 = 0;\n \
    \   long factorizationCountSum5 = 0;\n    long factorizationCountSum6 = 0;\n \
    \   long factorizationCountSum7 = 0;\n    long factorizationCountSum8 = 0;\n \
    \   long factorizationCountSum9 = 0;\n    long factorizationCountSum10 = 0;\n\
    \    long factorizationCountSum11 = 0;\n    long factorizationCountSum12 = 0;\n\
    \    long factorizationCountSum13 = 0;\n    long factorizationCountSum14 = 0;\n\
    \    long factorizationCountSum15 = 0;\n    long factorizationCountSum16 = 0;\n\
    \    long factorizationCountSum17 = 0;\n    long factorizationCountSum18 = 0;\n\
    \    long factorizationCountSum19 = 0;\n    long factorizationCountSum20 = 0;\n\
    \    long factorizationCountSum21 = 0;\n    long factorizationCountSum22 = 0;\n\
    \    long factorizationCountSum23 = 0;\n    long factorizationCountSum24 = 0;\n\
    \    long factorizationCountSum25 = 0;\n    long factorizationCountSum26 = 0;\n\
    \    long factorizationCountSum27 = 0;\n    long factorizationCountSum28 = 0;\n\
    \    long factorizationCountSum29 = 0;\n    long factorizationCountSum30 = 0;\n\
    \    long factorizationCountSum31 = 0;\n    long factorizationCountSum32 = 0;\n\
    \    long factorizationCountSum33 = 0;\n    long factorizationCountSum34 = 0;\n\
    \    long factorizationCountSum35 = 0;\n    long factorizationCountSum36 = 0;\n\
    \    long factorizationCountSum37 = 0;\n    long factorizationCountSum38 = 0;\n\
    \    long factorizationCountSum39 = 0;\n    long factorizationCountSum40 = 0;\n\
    \    long factorizationCountSum41 = 0;\n    long factorizationCountSum42 = 0;\n\
    \    long factorizationCountSum43 = 0;\n    long factorizationCountSum44 = 0;\n\
    \    long factorizationCountSum45 = 0;\n    long factorizationCountSum46 = 0;\n\
    \    long factorizationCountSum47 = 0;\n    long factorizationCountSum48 = 0;\n\
    \    long factorizationCountSum49 = 0;\n    long factorizationCountSum50 = 0;\n\
    \    long factorizationCountSum51 = 0;\n    long factorizationCountSum52 = 0;\n\
    \    long factorizationCountSum53 = 0;\n    long factorizationCountSum54 = 0;\n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqqqm42cx.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqqqm42cx.d(12):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpqqqm42cx.d(68):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqqqm42cx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceiling((double)n/2)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n           \
    \ n /= factor;\n        }\n        factor *= i;\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long factors[] =\
    \ new long[(int)std.math.ceiling((double)n/maxFactors)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount) \n{\n    long factors[] = new long[(int)std.math.ceiling((double)n/maxFactors)];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int maxFactors,\
    \ int maxFactorsCount, int maxFactorsCount2) \n{\n    long factors[] = new long[(int)std.math.ceiling((double)n/maxFactors)];\n\
    \    long factor\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm9fzflvx.d(11): Error: C style cast illegal, use cast(double)n\n/tmp/tmpm9fzflvx.d(11):
    Error: C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpm9fzflvx.d(34):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpm9fzflvx.d(34): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmpm9fzflvx.d(57):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpm9fzflvx.d(57): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmpm9fzflvx.d(80):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpm9fzflvx.d(80): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / maxFactors)\n/tmp/tmpm9fzflvx.d(82):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmpm9fzflvx.d(82): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpm9fzflvx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.ceil(n/std.math.max(1,n))];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        long p = std.math.max(1,n/factors[i]);\n        for(int j=0;j<i;j++)\n\
    \        {\n            if(p*factors[j] == n)\n            {\n               \
    \ factors[i]++;\n                break;\n            }\n        }\n    }\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)std.math.ceil(n/std.math.max(1,n))];\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        long p = std.math.max(1,n/factors[i]);\n\
    \        for(int j=0;j<i;j++)\n        {\n            if(p*factors[j] == n)\n\
    \            {\n                factors[i]++;\n                break;\n      \
    \      }\n        }\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max, int\
    \ min) \n{\n    long[] factors = new long[(int)std.math.ceil(n/std.math.max(1,n))];\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        long p = std.math.max(1,n/factors[i]);\n\
    \        for(int j=0;j<i;j++)\n        {\n            if(p*factors[j] == n)\n\
    \            {\n                factors[i]++;\n                break;\n      \
    \      }\n        }\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int max, int\
    \ min, int max2) \n{\n    long[] factors = new long[(int)std.math.ceil(n/std.math.max(1,n))];\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        long p = std.math.max(1,n/factors[i]);\n\
    \        for(int j=0;j<i;j++)\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpslfgk1p6.d(11): Error: C style cast illegal, use cast(int)std.math.ceil(n
    / std.math.max(1, n))\n/tmp/tmpslfgk1p6.d(34): Error: C style cast illegal, use
    cast(int)std.math.ceil(n / std.math.max(1, n))\n/tmp/tmpslfgk1p6.d(57): Error:
    C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, n))\n/tmp/tmpslfgk1p6.d(80):
    Error: C style cast illegal, use cast(int)std.math.ceil(n / std.math.max(1, n))\n/tmp/tmpslfgk1p6.d(85):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpslfgk1p6.d(98): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpslfgk1p6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(n % i == 0)\n  \
    \      {\n            factors[factorCount] = i;\n            factor++;\n     \
    \       factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,primes,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8e2z7ske.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmp8e2z7ske.d(27):
    Error: Declaration expected, not \''<\''\n/tmp/tmp8e2z7ske.d(32): Error: semicolon
    expected, not \''.\''\n/tmp/tmp8e2z7ske.d(32): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmp8e2z7ske.d(33): Error: semicolon expected, not \''.\''\n/tmp/tmp8e2z7ske.d(33):
    Error: no identifier for declarator .Linq\n/tmp/tmp8e2z7ske.d(34): Error: semicolon
    expected, not \''.\''\n/tmp/tmp8e2z7ske.d(34): Error: no identifier for declarator
    .Text\n/tmp/tmp8e2z7ske.d(35): Error: semicolon expected, not \''.\''\n/tmp/tmp8e2z7ske.d(35):
    Error: no identifier for declarator .Threading.Tasks\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp8e2z7ske.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.Ceiling(Math.Log(n,2))+1];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long currentFactor = 1;\n    long currentCount = 0;\n    long currentFactor2\
    \ = 1;\n    long currentCount2 = 0;\n    long currentFactor3 = 1;\n    long currentCount3\
    \ = 0;\n    long currentFactor4 = 1;\n    long currentCount4 = 0;\n    long currentFactor5\
    \ = 1;\n    long currentCount5 = 0;\n    long currentFactor6 = 1;\n    long currentCount6\
    \ = 0;\n    long currentFactor7 = 1;\n    long currentCount7 = 0;\n    long currentFactor8\
    \ = 1;\n    long currentCount8 = 0;\n    long currentFactor9 = 1;\n    long currentCount9\
    \ = 0;\n    long currentFactor10 = 1;\n    long currentCount10 = 0;\n    long\
    \ currentFactor11 = 1;\n    long currentCount11 = 0;\n    long currentFactor12\
    \ = 1;\n    long currentCount12 = 0;\n    long currentFactor13 = 1;\n    long\
    \ currentCount13 = 0;\n    long currentFactor14 = 1;\n    long currentCount14\
    \ = 0;\n    long currentFactor15 = 1;\n    long currentCount15 = 0;\n    long\
    \ currentFactor16 = 1;\n    long currentCount16 = 0;\n    long currentFactor17\
    \ = 1;\n    long currentCount17 = 0;\n    long currentFactor18 = 1;\n    long\
    \ currentCount18 = 0;\n    long currentFactor19 = 1;\n    long currentCount19\
    \ = 0;\n    long currentFactor20 = 1;\n    long currentCount20 = 0;\n    long\
    \ currentFactor21 = 1;\n    long currentCount21 = 0;\n    long currentFactor22\
    \ = 1;\n    long currentCount22 = 0;\n    long currentFactor23 = 1;\n    long\
    \ currentCount23 = 0;\n    long currentFactor24 = 1;\n    long currentCount24\
    \ = 0;\n    long currentFactor25 = 1;\n    long currentCount25 = 0;\n    long\
    \ currentFactor26 = 1;\n    long currentCount26 = 0;\n    long currentFactor27\
    \ = 1;\n    long currentCount27 = 0;\n    long currentFactor28 = 1;\n    long\
    \ currentCount28 = 0;\n    long currentFactor29 = 1;\n    long currentCount29\
    \ = 0;\n    long currentFactor30 = 1;\n    long currentCount30 = 0;\n    long\
    \ currentFactor31 = 1;\n    long currentCount31 = 0;\n    long currentFactor32\
    \ = 1;\n    long currentCount32 = 0;\n    long currentFactor33 = 1;\n    long\
    \ currentCount33 = 0;\n    long currentFactor34 = 1;\n    long currentCount34\
    \ = 0;\n    long currentFactor35 = 1;\n    long \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnlkkkxfo.d(11): Error: C style cast illegal, use cast(int)Math.Ceiling(Math.Log(n,
    2))\n/tmp/tmpnlkkkxfo.d(84): Error: no identifier for declarator long\n/tmp/tmpnlkkkxfo.d(84):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnlkkkxfo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            n = n/i;\n        }\n    }\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i]++;\n            \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq2q9_0ym.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(22): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(26): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(30): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(34): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(38): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(42): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpq2q9_0ym.d(46): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(50):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(54): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(58): Error:
    C style cast illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(62): Error: C style cast
    illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(66): Error: C style cast
    illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(70): Error: C style cast illegal,
    use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(74): Error: C style cast illegal,
    use cast(int)i\n/tmp/tmpq2q9_0ym.d(78): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(82):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpq2q9_0ym.d(86): Error: C
    style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpq2q9_0ym.d(90): Error:
    C style cast illegal, use cast(int)i\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpq2q9_0ym.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorCount2 = 0;\n    long factorCount3 = 0;\n    long factorCount4\
    \ = 0;\n    long factorCount5 = 0;\n    long factorCount6 = 0;\n    long factorCount7\
    \ = 0;\n    long factorCount8 = 0;\n    long factorCount9 = 0;\n    long factorCount10\
    \ = 0;\n    long factorCount11 = 0;\n    long factorCount12 = 0;\n    long factorCount13\
    \ = 0;\n    long factorCount14 = 0;\n    long factorCount15 = 0;\n    long factorCount16\
    \ = 0;\n    long factorCount17 = 0;\n    long factorCount18 = 0;\n    long factorCount19\
    \ = 0;\n    long factorCount20 = 0;\n    long factorCount21 = 0;\n    long factorCount22\
    \ = 0;\n    long factorCount23 = 0;\n    long factorCount24 = 0;\n    long factorCount25\
    \ = 0;\n    long factorCount26 = 0;\n    long factorCount27 = 0;\n    long factorCount28\
    \ = 0;\n    long factorCount29 = 0;\n    long factorCount30 = 0;\n    long factorCount31\
    \ = 0;\n    long factorCount32 = 0;\n    long factorCount33 = 0;\n    long factorCount34\
    \ = 0;\n    long factorCount35 = 0;\n    long factorCount36 = 0;\n    long factorCount37\
    \ = 0;\n    long factorCount38 = 0;\n    long factorCount39 = 0;\n    long factorCount40\
    \ = 0;\n    long factorCount41 = 0;\n    long factorCount42 = 0;\n    long factorCount43\
    \ = 0;\n    long factorCount44 = 0;\n    long factorCount45 = 0;\n    long factorCount46\
    \ = 0;\n    long factorCount47 = 0;\n    long factorCount48 = 0;\n    long factorCount49\
    \ = 0;\n    long factorCount50 = 0;\n    long factorCount51 = 0;\n    long factorCount52\
    \ = 0;\n    long factorCount53 = 0;\n    long factorCount54 = 0;\n    long factorCount55\
    \ = 0;\n    long factorCount56 = 0;\n    long factorCount57 = 0;\n    long factorCount58\
    \ = 0;\n    long factorCount59 = 0;\n    long factorCount60 = 0;\n    long factorCount61\
    \ = 0;\n    long factorCount62 = 0;\n    long factorCount63 = 0;\n    long factorCount64\
    \ = 0;\n    long factorCount65 = 0;\n    long factorCount66 = 0;\n    long factorCount67\
    \ = 0;\n    long factorCount68 = 0;\n    long factorCount69 = 0;\n    long factorCount70\
    \ = 0;\n    long factorCount71 = 0;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk172wily.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpk172wily.d(84):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpk172wily.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd8eae1s3.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpd8eae1s3.d(112):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd8eae1s3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.ceiling((double)n/2)];\n    std.math.factorize(n,factors);\n\
    \    long[] result = new long[(int)std.math.ceiling((double)n/2)];\n    for(int\
    \ i=0;i<result.length;i++)\n    {\n        result[i] = factors[i];\n    }\n  \
    \  return result;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n,int max) \n{\n    long factors[] = new long[(int)std.math.ceiling((double)n/2)];\n\
    \    std.math.factorize(n,factors,max);\n    long[] result = new long[(int)std.math.ceiling((double)n/2)];\n\
    \    for(int i=0;i<result.length;i++)\n    {\n        result[i] = factors[i];\n\
    \    }\n    return result;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,int max,int max2) \n{\n    long factors[] =\
    \ new long[(int)std.math.ceiling((double)n/2)];\n    std.math.factorize(n,factors,max,max2);\n\
    \    long[] result = new long[(int)std.math.ceiling((double)n/2)];\n    for(int\
    \ i=0;i<result.length;i++)\n    {\n        result[i] = factors[i];\n    }\n  \
    \  return result;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n,int max,int max2,int max3) \n{\n    long factors[]\
    \ = new long[(int)std.math.ceiling((double)n/2)];\n    std.math.factorize(n,factors,max,max2,max3);\n\
    \    long[] result = new long[(int)std.math.ceiling((double)n/2)];\n    for(int\
    \ i=0;i<result.length;i++)\n    {\n        result[i] = factors[i];\n    }\n  \
    \  return result;\n}\n/*\n Return \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfzxrfsqp.d(11): Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(11):
    Error: C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(13):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(13): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(28):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(28): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(30):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(30): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(45):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(45): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(47):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(47): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(62):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(62): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(64):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpfzxrfsqp.d(64): Error:
    C style cast illegal, use cast(int)std.math.ceiling(cast(double)n / 2)\n/tmp/tmpfzxrfsqp.d(71):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzxrfsqp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long factor = 1;\n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[(int)i] = factor;\n            n = n/i;\n        }\n    \
    \    else\n        {\n            factors[(int)i] = factor;\n            factor++;\n\
    \        }\n    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,java\
    \ |>\n<| c |>\nI like this solution, but I wonder why you use long for factors\
    \ and factor. Why not int?\n<|/ c |>\n<| c |>\nBecause I didn't want to use BigInteger.\
    \ Also, I didn't want to use any libraries. I wanted to write my own code from\
    \ scratch.\n<|/ c |>\n<| c |>\nI see. But I wonder why you use long for factors\
    \ and factor. Why not int?\n<|/ c |>\n<| c |>\nBecause I didn't want to use BigInteger.\
    \ Also, I didn't want to use any libraries. I wanted to write my own code from\
    \ scratch.\n<|/ c |>\n<| c |>\nI see. But I wonder why you use long for factors\
    \ and factor. Why not int?\n<|/ c |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpypl9f7y7.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpypl9f7y7.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpypl9f7y7.d(18):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpypl9f7y7.d(23): Error: C
    style cast illegal, use cast(int)i\n/tmp/tmpypl9f7y7.d(29): Error: Declaration
    expected, not \''<\''\n/tmp/tmpypl9f7y7.d(35): Error: unterminated character constant\n/tmp/tmpypl9f7y7.d(35):
    Error: unterminated character constant\n/tmp/tmpypl9f7y7.d(41): Error: unterminated
    character constant\n/tmp/tmpypl9f7y7.d(41): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypl9f7y7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[(int)i]++;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb_mpnrte.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpb_mpnrte.d(17):
    Error: C style cast illegal, use cast(int)i\n/tmp/tmpb_mpnrte.d(24): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_mpnrte.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n,2)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorCount++] = factor;\n                n /= factor;\n     \
    \       }\n            factor++;\n        }\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors) \n{\n    long[] factors = new long[maxFactors];\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        while(factor*factor <= n)\n        {\n            if(n % factor\
    \ == 0)\n            {\n                factors[factorCount++] = factor;\n   \
    \             n /= factor;\n            }\n            factor++;\n        }\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n\
    \    long[] factors = new long[maxFactors];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorCount++] = factor;\n                n /= factor;\n     \
    \       }\n            factor++;\n        }\n    }\n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCount, int maxFactorsCount2) \n{\n    long[]\
    \ factors = new long[maxFactors];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i=0;i<factors.length;i++)\n    {\n        while(factor*factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3x0pr9h9.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    2)\n/tmp/tmp3x0pr9h9.d(95): Error: found \''unittest\'' instead of statement\n/tmp/tmp3x0pr9h9.d(108):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp3x0pr9h9.d(108):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3x0pr9h9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n,2)];\n    for(int i=0;i<factors.length;i++)\n    {\n\
    \        long factor = 1;\n        for(int j=i;j<factors.length;j++)\n       \
    \ {\n            if(n%j==0)\n            {\n                factor *= j;\n   \
    \             break;\n            }\n        }\n        factors[i] = factor;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,long[] factors) \n{\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        long factor = 1;\n        for(int j=i;j<factors.length;j++)\n\
    \        {\n            if(n%j==0)\n            {\n                factor *= j;\n\
    \                break;\n            }\n        }\n        factors[i] = factor;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n,long[] factors,int start) \n{\n    for(int\
    \ i=start;i<factors.length;i++)\n    {\n        long factor = 1;\n        for(int\
    \ j=i;j<factors.length;j++)\n        {\n            if(n%j==0)\n            {\n\
    \                factor *= j;\n                break;\n            }\n       \
    \ }\n        factors[i] = factor;\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n,long[]\
    \ factors,int start,int end) \n{\n    for(int i=start;i<factors.length;i++)\n\
    \    {\n        long factor = 1;\n        for(int j=i;j<factors.length;j++)\n\
    \        {\n            if(n%j==0)\n            {\n                factor *= j;\n\
    \                break;\n            }\n        }\n        factors[i] = factor;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl8pm0bax.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    2)\n/tmp/tmpl8pm0bax.d(96): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpl8pm0bax.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.sqrt(n)];\n    long p = n;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(p % 2 == 0)\n        {\n            p /= 2;\n   \
    \         factors[i] = 2;\n        }\n        while(p % 3 == 0)\n        {\n \
    \           p /= 3;\n            factors[i] = 3;\n        }\n        while(p %\
    \ 5 == 0)\n        {\n            p /= 5;\n            factors[i] = 5;\n     \
    \   }\n        while(p % 7 == 0)\n        {\n            p /= 7;\n           \
    \ factors[i] = 7;\n        }\n        while(p % 11 == 0)\n        {\n        \
    \    p /= 11;\n            factors[i] = 11;\n        }\n        while(p % 13 ==\
    \ 0)\n        {\n            p /= 13;\n            factors[i] = 13;\n        }\n\
    \        while(p % 17 == 0)\n        {\n            p /= 17;\n            factors[i]\
    \ = 17;\n        }\n        while(p % 19 == 0)\n        {\n            p /= 19;\n\
    \            factors[i] = 19;\n        }\n        while(p % 23 == 0)\n       \
    \ {\n            p /= 23;\n            factors[i] = 23;\n        }\n        while(p\
    \ % 29 == 0)\n        {\n            p /= 29;\n            factors[i] = 29;\n\
    \        }\n        while(p % 31 == 0)\n        {\n            p /= 31;\n    \
    \        factors[i] = 31;\n        }\n        while(p % 37 == 0)\n        {\n\
    \            p /= 37;\n            factors[i] = 37;\n        }\n        while(p\
    \ % 41 == 0)\n        {\n            p /= 41;\n            factors[i] = 41;\n\
    \        }\n        while(p % 43 == 0)\n        {\n            p /= 43;\n    \
    \        factors[i] = 43;\n        }\n        while(p % 47 == 0)\n        {\n\
    \            p /= 47;\n            factors[i] = 47;\n        }\n        while(p\
    \ % 53 == 0)\n        {\n            p /= 53;\n            factors[i] = 53;\n\
    \        }\n        while(p % 59 == 0)\n        {\n            p /= 59;\n    \
    \        factors[i] = 59;\n        }\n        while(p % 61 == 0)\n        {\n\
    \            p /= 61;\n            factors[i] = 61;\n        }\n        while(p\
    \ % 67 == 0)\n        {\n            p /= 67;\n            factors[i] = 67;\n\
    \        }\n        while(p % 71 == 0)\n        {\n            p /= 71;\n    \
    \        factors[i] = 71;\n        }\n        while(p % 73 == 0)\n        {\n\
    \            p /= 73;\n            factor\nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprsd6ldbo.d(11): Error: C style cast illegal, use cast(int)std.math.sqrt(n)\n/tmp/tmprsd6ldbo.d(119):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmprsd6ldbo.d(132):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprsd6ldbo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014180
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    long p = 1;\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    \n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        factors[i] = 0;\n    }\n    \n    for(int i = 2; i <= n;\
    \ i++)\n    {\n        while(p <= n && n % p == 0)\n        {\n            factors[factorCount]++;\n\
    \            n /= p;\n            factor++;\n        }\n        p++;\n       \
    \ factorCount++;\n    }\n    \n    for(int i = 0; i < factors.length; i++)\n \
    \   {\n        factors[i] = factors[factors.length - i - 1];\n    }\n    \n  \
    \  return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n               \
    \ \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors = new\
    \ long[maxFactors];\n    long p = 1;\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    \n    for(int i = 0; i < factors.length; i++)\n    {\n        factors[i]\
    \ = 0;\n    }\n    \n    for(int i = 2; i <= n; i++)\n    {\n        while(p <=\
    \ n && n % p == 0)\n        {\n            factors[factorCount]++;\n         \
    \   n /= p;\n            factor++;\n        }\n        p++;\n        factorCount++;\n\
    \    }\n    \n    for(int i = 0; i < factors.length; i++)\n    {\n        factors[i]\
    \ = factors[factors.length - i - 1];\n    }\n    \n    return factors;\n}\n/*\n\
    \ Return list of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n, int maxFactors, int maxFactorsCount) \n{\n    long[] factors = new long[maxFactors];\n\
    \    long p = 1;\n    long factor = 1;\n    long factorCount = 0;\n    \n    for(int\
    \ i = 0; i < factors.length; i++)\n    {\n        factors[i] = 0;\n    }\n   \
    \ \n    for(int i = 2; i <= n; i++)\n    {\n        while(p <= n && n % p == 0)\n\
    \        {\n            factors[factorCount]++;\n            n /= p;\n       \
    \     factor++;\n        }\n        p++;\n        factorCount++;\n    }\n    \n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptmzwdt72.d(108): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptmzwdt72.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorization[] = new long[100];\n\
    \    long factorizationCount = 0;\n    long factorizationSum = 0;\n    long factorizationProduct\
    \ = 1;\n    long factorizationSumOfFactors = 0;\n    long factorizationProductOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactors = 0;\n    long factorizationProductOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactors = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactorsOfFactors = 0;\n \
    \   long factorizationProductOfFactorsOfFactorsOfFactorsOfFactors = 0;\n    long\
    \ factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactors = 0;\n    long\
    \ factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactors = 0;\n   \
    \ long factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0;\n    long factorizationProductOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOf\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjz3rkvms.d(37): Error: semicolon expected, not \''unittest\''\n/tmp/tmpjz3rkvms.d(37):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjz3rkvms.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long factorization = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            result[(int)Math.sqrt(n)-i-1]++;\n\
    \            n /= factor;\n        }\n        factorization *= factor;\n     \
    \   factor++;\n    }\n    result[(int)Math.sqrt(n)-i-1]++;\n    result[(int)Math.sqrt(n)-1]\
    \ = factorization;\n    return result;\n}\n</code>\n<|/ a tags=math,primes,java\
    \ |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmyo2irt.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnmyo2irt.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnmyo2irt.d(18):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnmyo2irt.d(24):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnmyo2irt.d(25):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpnmyo2irt.d(28):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnmyo2irt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)std.math.gcd(n,2)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    for(int i = 0; i <= (int)std.math.gcd(n,2); i++)\n    {\n        factorCount\
    \ = 1;\n        for(int j = 1; j <= (int)std.math.gcd(n,i); j++)\n        {\n\
    \            if(i%j == 0)\n            {\n                factorCount++;\n   \
    \         }\n        }\n        factors[i] = factorCount;\n        factor *= i;\n\
    \    }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmxiwtgpa.d(11): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    2)\n/tmp/tmpmxiwtgpa.d(14): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    2)\n/tmp/tmpmxiwtgpa.d(17): Error: C style cast illegal, use cast(int)std.math.gcd(n,
    i)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxiwtgpa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[std.math.nextPowerOfTwo(std.math.log2(n))];\n    long factor = 1;\n   \
    \ long factorCount = 1;\n    for(int i = 1; i <= std.math.log2(n); i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount] =\
    \ factor;\n            factor *= i;\n            factorCount++;\n        }\n \
    \       n /= factor;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize)\
    \ \n{\n    long[] factors = new long[factorizationSize];\n    long factor = 1;\n\
    \    long factorCount = 1;\n    for(int i = 1; i <= std.math.log2(n); i++)\n \
    \   {\n        while(n % factor == 0)\n        {\n            factors[factorCount]\
    \ = factor;\n            factor *= i;\n            factorCount++;\n        }\n\
    \        n /= factor;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize,\
    \ bool isPrime)\n{\n    long[] factors = new long[factorizationSize];\n    long\
    \ factor = 1;\n    long factorCount = 1;\n    for(int i = 1; i <= std.math.log2(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorCount]\
    \ = factor;\n            factor *= i;\n            factorCount++;\n        }\n\
    \        n /= factor;\n    }\n    return factors;\n}\n/*\n Return list of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n, int factorizationSize,\
    \ bool isPrime, bool isPrime2)\n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long factorCount = 1;\n    for(int i = 1; i <= std.math.log2(n);\
    \ i++)\n    {\n        while(n % factor == 0)\n\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbcwh1m58.d(87): Error: found \''unittest\'' instead of statement\n/tmp/tmpbcwh1m58.d(100):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcwh1m58.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n \
    \   {\n        factors[i]=1;\n    }\n    for(int i=2;i<=n;i++)\n    {\n      \
    \  for(int j=0;j<factors.length;j++)\n        {\n            if(factors[j]*i==n)\n\
    \            {\n                factors[j]=factors[j]*i;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n,int max) \n{\n\
    \    long factors[] = new long[(int)std.math.factorial(n)];\n    for(int i=0;i<factors.length;i++)\n\
    \    {\n        factors[i]=1;\n    }\n    for(int i=2;i<=n;i++)\n    {\n     \
    \   for(int j=0;j<factors.length;j++)\n        {\n            if(factors[j]*i==n)\n\
    \            {\n                factors[j]=factors[j]*i;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return list of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be listed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n                \n*/\nlong[] factorize(long n,int max,int min)\
    \ \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n    for(int\
    \ i=0;i<factors.length;i++)\n    {\n        factors[i]=1;\n    }\n    for(int\
    \ i=2;i<=n;i++)\n    {\n        for(int j=0;j<factors.length;j++)\n        {\n\
    \            if(factors[j]*i==n)\n            {\n                factors[j]=factors[j]*i;\n\
    \                break;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n                \n*/\nlong[] factorize(long\
    \ n,int max,int min,int max2) \n{\n    long factors[] = new long[(int)std.math.factorial(n)];\n\
    \    for(int i=0;i<factors.length;i++)\n    {\n        factors[i]=1;\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9wi7fab.d(11): Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmph9wi7fab.d(37):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmph9wi7fab.d(63):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmph9wi7fab.d(89):
    Error: C style cast illegal, use cast(int)std.math.factorial(n)\n/tmp/tmph9wi7fab.d(94):
    Error: found \''unittest\'' instead of statement\n/tmp/tmph9wi7fab.d(107): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph9wi7fab.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorProduct = 1;\n    long factorSum = 0;\n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n\
    \        factorProduct *= factor;\n        factorSum += factor;\n        factor++;\n\
    \    }\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i]\
    \ = factors[i];\n        factorCount *= factors[i];\n        factorProduct *=\
    \ factors[i];\n        factorSum += factors[i];\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factorCount;\n    factors[(int)Math.sqrt(n)] = factorProduct;\n    factors[(int)Math.sqrt(n)]\
    \ = factorSum;\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long factorization[]) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    long factorProduct = 1;\n    long factorSum = 0;\n    for(int i = 0;\
    \ i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n        factorCount++;\n\
    \        factorProduct *= factor;\n        factorSum += factor;\n        factor++;\n\
    \    }\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i]\
    \ = factors[i];\n        factorCount *= factors[i];\n        factorProduct *=\
    \ factors[i];\n        factorSum += factors[i];\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factorCount;\n    factors[(int)Math.sqrt(n)] = factorProduct;\n    factors[(int)Math.sqrt(n)]\
    \ = factorSum;\n    return factors;\n}\n/*\n Return list of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be listed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, long[] factorization) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    long factorProduct = 1;\n    long factorSum = 0;\n    for(int i = 0;\
    \ i <= (int)Math.sqrt(\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp13wmpms8.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(16):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(24):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(31):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(32):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(33):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(44):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(49):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(57):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(64):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(65):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(66):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(77):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp13wmpms8.d(83):
    Error: expression expected, not \''unittest\''\n/tmp/tmp13wmpms8.d(84): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp13wmpms8.d(85): Error: expression
    expected, not \''alias\''\n/tmp/tmp13wmpms8.d(85): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmp13wmpms8.d(85): Error: expression expected, not
    \''=\''\n/tmp/tmp13wmpms8.d(85): Error: found \''factorize\'' when expecting \'',\''\n/tmp/tmp13wmpms8.d(85):
    Error: expression expected, not \'';\''\n/tmp/tmp13wmpms8.d(87): Error: found
    \''assert\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp13wmpms8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[std.math.nextpow2(n) + 1];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long factorCount2 = 0;\n    long factorCount3 = 0;\n    long factorCount4\
    \ = 0;\n    long factorCount5 = 0;\n    long factorCount6 = 0;\n    long factorCount7\
    \ = 0;\n    long factorCount8 = 0;\n    long factorCount9 = 0;\n    long factorCount10\
    \ = 0;\n    long factorCount11 = 0;\n    long factorCount12 = 0;\n    long factorCount13\
    \ = 0;\n    long factorCount14 = 0;\n    long factorCount15 = 0;\n    long factorCount16\
    \ = 0;\n    long factorCount17 = 0;\n    long factorCount18 = 0;\n    long factorCount19\
    \ = 0;\n    long factorCount20 = 0;\n    long factorCount21 = 0;\n    long factorCount22\
    \ = 0;\n    long factorCount23 = 0;\n    long factorCount24 = 0;\n    long factorCount25\
    \ = 0;\n    long factorCount26 = 0;\n    long factorCount27 = 0;\n    long factorCount28\
    \ = 0;\n    long factorCount29 = 0;\n    long factorCount30 = 0;\n    long factorCount31\
    \ = 0;\n    long factorCount32 = 0;\n    long factorCount33 = 0;\n    long factorCount34\
    \ = 0;\n    long factorCount35 = 0;\n    long factorCount36 = 0;\n    long factorCount37\
    \ = 0;\n    long factorCount38 = 0;\n    long factorCount39 = 0;\n    long factorCount40\
    \ = 0;\n    long factorCount41 = 0;\n    long factorCount42 = 0;\n    long factorCount43\
    \ = 0;\n    long factorCount44 = 0;\n    long factorCount45 = 0;\n    long factorCount46\
    \ = 0;\n    long factorCount47 = 0;\n    long factorCount48 = 0;\n    long factorCount49\
    \ = 0;\n    long factorCount50 = 0;\n    long factorCount51 = 0;\n    long factorCount52\
    \ = 0;\n    long factorCount53 = 0;\n    long factorCount54 = 0;\n    long factorCount55\
    \ = 0;\n    long factorCount56 = 0;\n    long factorCount57 = 0;\n    long factorCount58\
    \ = 0;\n    long factorCount59 = 0;\n    long factorCount60 = 0;\n    long factorCount61\
    \ = 0;\n    long factorCount62 = 0;\n    long factorCount63 = 0;\n    long factorCount64\
    \ = 0;\n    long factorCount65 = 0;\n    long factorCount66 = 0;\n    long factorCount67\
    \ = 0;\n    long factorCount68 = 0;\n    long factorCount69 = 0;\n    long factorCount70\
    \ = 0;\n    long \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqcwbu6a9.d(84): Error: no identifier for declarator long\n/tmp/tmpqcwbu6a9.d(84):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqcwbu6a9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    long factorsSum = 0;\n    long factorsSum2 = 0;\n    long factorsSum3 = 0;\n\
    \    long factorsSum4 = 0;\n    long factorsSum5 = 0;\n    long factorsSum6 =\
    \ 0;\n    long factorsSum7 = 0;\n    long factorsSum8 = 0;\n    long factorsSum9\
    \ = 0;\n    long factorsSum10 = 0;\n    long factorsSum11 = 0;\n    long factorsSum12\
    \ = 0;\n    long factorsSum13 = 0;\n    long factorsSum14 = 0;\n    long factorsSum15\
    \ = 0;\n    long factorsSum16 = 0;\n    long factorsSum17 = 0;\n    long factorsSum18\
    \ = 0;\n    long factorsSum19 = 0;\n    long factorsSum20 = 0;\n    long factorsSum21\
    \ = 0;\n    long factorsSum22 = 0;\n    long factorsSum23 = 0;\n    long factorsSum24\
    \ = 0;\n    long factorsSum25 = 0;\n    long factorsSum26 = 0;\n    long factorsSum27\
    \ = 0;\n    long factorsSum28 = 0;\n    long factorsSum29 = 0;\n    long factorsSum30\
    \ = 0;\n    long factorsSum31 = 0;\n    long factorsSum32 = 0;\n    long factorsSum33\
    \ = 0;\n    long factorsSum34 = 0;\n    long factorsSum35 = 0;\n    long factorsSum36\
    \ = 0;\n    long factorsSum37 = 0;\n    long factorsSum38 = 0;\n    long factorsSum39\
    \ = 0;\n    long factorsSum40 = 0;\n    long factorsSum41 = 0;\n    long factorsSum42\
    \ = 0;\n    long factorsSum43 = 0;\n    long factorsSum44 = 0;\n    long factorsSum45\
    \ = 0;\n    long factorsSum46 = 0;\n    long factorsSum47 = 0;\n    long factorsSum48\
    \ = 0;\n    long factorsSum49 = 0;\n    long factorsSum50 = 0;\n    long factorsSum51\
    \ = 0;\n    long factorsSum52 = 0;\n    long factorsSum53 = 0;\n    long factorsSum54\
    \ = 0;\n    long factorsSum55 = 0;\n    long factorsSum56 = 0;\n    long factorsSum57\
    \ = 0;\n    long factorsSum58 = 0;\n    long factorsSum59 = 0;\n    long factorsSum60\
    \ = 0;\n    long factorsSum61 = 0;\n    long factor\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdztdxwiz.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmpdztdxwiz.d(76):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmpdztdxwiz.d(76): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdztdxwiz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factors[] = new\
    \ long[100];\n    long factor = 1;\n    long factorCount = 0;\n    long factorProduct\
    \ = 1;\n    long factorSum = 0;\n    long factorProductSum = 0;\n    long factorProductSum2\
    \ = 0;\n    long factorProductSum3 = 0;\n    long factorProductSum4 = 0;\n   \
    \ long factorProductSum5 = 0;\n    long factorProductSum6 = 0;\n    long factorProductSum7\
    \ = 0;\n    long factorProductSum8 = 0;\n    long factorProductSum9 = 0;\n   \
    \ long factorProductSum10 = 0;\n    long factorProductSum11 = 0;\n    long factorProductSum12\
    \ = 0;\n    long factorProductSum13 = 0;\n    long factorProductSum14 = 0;\n \
    \   long factorProductSum15 = 0;\n    long factorProductSum16 = 0;\n    long factorProductSum17\
    \ = 0;\n    long factorProductSum18 = 0;\n    long factorProductSum19 = 0;\n \
    \   long factorProductSum20 = 0;\n    long factorProductSum21 = 0;\n    long factorProductSum22\
    \ = 0;\n    long factorProductSum23 = 0;\n    long factorProductSum24 = 0;\n \
    \   long factorProductSum25 = 0;\n    long factorProductSum26 = 0;\n    long factorProductSum27\
    \ = 0;\n    long factorProductSum28 = 0;\n    long factorProductSum29 = 0;\n \
    \   long factorProductSum30 = 0;\n    long factorProductSum31 = 0;\n    long factorProductSum32\
    \ = 0;\n    long factorProductSum33 = 0;\n    long factorProductSum34 = 0;\n \
    \   long factorProductSum35 = 0;\n    long factorProductSum36 = 0;\n    long factorProductSum37\
    \ = 0;\n    long factorProductSum38 = 0;\n    long factorProductSum39 = 0;\n \
    \   long factorProductSum40 = 0;\n    long factorProductSum41 = 0;\n    long factorProductSum42\
    \ = 0;\n    long factorProductSum43 = 0;\n    long factorProductSum44 = 0;\n \
    \   long factorProductSum45 = 0;\n    long factorProductSum46 = 0;\n    long factorProductSum47\
    \ = 0;\n    long factorProductSum48 = 0;\n    long factorProductSum49 = 0;\n \
    \   long factorProductSum50 = 0;\n    long factorProductSum51 = 0;\n    long factorProductSum52\
    \ = 0;\n    long factorProductSum53 = 0;\n    long factorProductSum54 = 0;\n \
    \   long factorProductSum55 = 0;\n    long factorProductSum56 = 0;\n    long factorProductSum57\
    \ = 0;\n    long factorProductSum58 = 0;\n    long factorProductSum59 = 0;\n \
    \   long factorProductSum60 = 0;\n    \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp01t71754.d(77): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01t71754.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long factorization[]\
    \ = new long[(int)Math.sqrt(n)];\n    long factorizationCount[] = new long[(int)Math.sqrt(n)];\n\
    \    long factorizationCountSum = 0;\n    long factorizationSum = 0;\n    long\
    \ factorizationSumCount = 0;\n    long factorizationSumCountSum = 0;\n    long\
    \ factorizationSumCountSumCount = 0;\n    long factorizationSumCountSumCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCount = 0;\n    long factorizationSumCountSumCountSumCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCount = 0;\n    long\
    \ factorizationSumCountSumCountSumCountSumCountSum = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCount\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountCount =\
    \ 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountCountSum =\
    \ 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountCount\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountCountSum\
    \ = 0;\n    long factorizationSumCountSumCountSumCount\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0if678rx.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0if678rx.d(12):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmp0if678rx.d(40):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmp0if678rx.d(40): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0if678rx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n    for(int\
    \ i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        while(n % i == 0)\n    \
    \    {\n            n /= i;\n            factors[counter] = i;\n            counter++;\n\
    \        }\n    }\n    factors[counter] = n;\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n                \n*/\nlong[] factorize(long n, int\
    \ factorizationOrder) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    long factor = 1;\n    long counter = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n   \
    \         factors[counter] = i;\n            counter++;\n        }\n    }\n  \
    \  factors[counter] = n;\n    return factors;\n}\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \                \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        while(n % i == 0)\n        {\n            n /= i;\n            factors[counter]\
    \ = i;\n            counter++;\n        }\n    }\n    factors[counter] = n;\n\
    \    return factors;\n}\n/*\n Return list of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n            \
    \    \n*/\nlong[] factorize(long n, int factorizationOrder, bool isPrime, bool\
    \ isPrimeOnly) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long\
    \ factor = 1;\n    long counter = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n   \
    \         factors[counter] = i;\n            counter++;\n        }\n    }\n  \
    \  factors[counter] = \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptatumleg.d(11): Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(14):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(34):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(37):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(57):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(60):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(80):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(83):
    Error: C style cast illegal, use cast(int)Math.sqrt(n)\n/tmp/tmptatumleg.d(93):
    Error: expression expected, not \''unittest\''\n/tmp/tmptatumleg.d(94): Error:
    found \''{\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptatumleg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660014181
