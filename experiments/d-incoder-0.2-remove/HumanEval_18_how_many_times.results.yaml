language: d
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); ++j)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(string[j+1] == substring[1])\n    \
    \                {\n                        count += 1;\n                    \
    \    i += 2;\n                    }\n                    else\n              \
    \      {\n                        break;\n                    }\n            \
    \    }\n                else\n                {\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      break;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start) \n{\n    long count = 0;\n    for(int i = start; i < string.size(); ++i)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = i; j < string.size(); ++j)\n            {\n                if(string[j]\
    \ == substring[0])\n                {\n                    if(string[j+1] == substring[1])\n\
    \                    {\n                        count += 1;\n                \
    \        i += 2;\n                    }\n                    else\n          \
    \          {\n                        break;\n                    }\n        \
    \        }\n                else\n                {\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      break;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n    long count = 0;\n    for(int i = start; i < string.size();\
    \ ++i)\n    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = i; j < string.size(); ++j)\n            {\n                if(string[j]\
    \ == substring[0])\n                {\n                    if(string[j+1] == substring[1])\n\
    \                    {\n                        count += 1;\n                \
    \        i += 2;\n                    }\n                    else\n          \
    \          {\n                        break;\n                    }\n        \
    \        }\n                else\n                {\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      break;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < string.size(); ++i)\n    {\n        if(string[i] == substring[0])\n      \
    \  {\n            for(int j = i; j < string.size(); ++j)\n            {\n    \
    \            if(string[j] == substring[0])\n                {\n              \
    \      if(string[j+1] == substring[1])\n                    {\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4z1od1of.d(134): Error: found \''unittest\'' instead of statement\n/tmp/tmp4z1od1of.d(143):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4z1od1of.d(143):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4z1od1of.d(143):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4z1od1of.d(143):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4z1od1of.d(143):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4z1od1of.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end;\
    \ i += step) {\n\t\tif (string.substr(i, substring.length(), case_sensitive) ==\
    \ substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\tif (string.substr(i,\
    \ substring.length(), case_sensitive) == substring) {\n\t\t\tcount++;\n\t\t}\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive, int start, \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxh45orrq.d(92): Error: basic type expected, not unittest\n/tmp/tmpxh45orrq.d(92):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpxh45orrq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnd1gftu4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogkwgulx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string.substr(i,\
    \ j) == substring)\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_5cqeb_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.find(substring, i) != string::npos)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start) \n{\n\
    \    long count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n\
    \        if(string.find(substring, i) != string::npos)\n        {\n          \
    \  count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n\
    \    {\n        if(string.find(substring, i) != string::npos)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.find(substring, i) != string::npos)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.find(substring,\
    \ i) != string::npos)\n        {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, string pattern, string\
    \ pattern2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n\
    \    {\n        if(string.find(substring, i) != string::npos)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl_6t3kl5.d(12): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpl_6t3kl5.d(12):
    Error: found \'':\'' instead of statement\n/tmp/tmpl_6t3kl5.d(17): Error: Declaration
    expected, not \''return\''\n/tmp/tmpl_6t3kl5.d(18): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_6t3kl5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb93r628.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), case_sensitive) == 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string case_sensitive, int start2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length(),\
    \ case_sensitive, start2) == 0)\n        {\n            count++;\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg_2c_8nz.d(95): Error: found \''unittest\'' instead of statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_2c_8nz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length; j++)\n\t\t\
    \t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\
    \t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqd9jgdro.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpet__e3o6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) {\n        foreach(char\
    \ c2 in substring) {\n            if (c == c2) {\n                count++;\n \
    \           }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    foreach(char c in string) {\n\
    \        foreach(char c2 in substring) {\n            if (c == c2) {\n       \
    \         count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    \n   \
    \ foreach(char c in string) {\n        foreach(char c2 in substring) {\n     \
    \       if (c == c2) {\n                count++;\n            }\n        }\n \
    \   }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step) \n{\n    long count = 0;\n    \n    foreach(char c in string)\
    \ {\n        foreach(char c2 in substring) {\n            if (c == c2) {\n   \
    \             count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2) \n{\n    long\
    \ count = 0;\n    \n    foreach(char c in string) {\n        foreach(char c2 in\
    \ substring) {\n            if (c == c2) {\n                count++;\n       \
    \     }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step, long step2, long step3) \n{\n    long count = 0;\n\
    \    \n    foreach(char c in string) {\n        foreach(char c2 in substring)\
    \ {\n            if (c == c2) {\n                count++;\n            }\n   \
    \     }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given sub\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpni29wsnd.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(12):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(29): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(30): Error: found \''in\''
    when expecting \'';\''\n/tmp/tmpni29wsnd.d(47): Error: found \''in\'' when expecting
    \'';\''\n/tmp/tmpni29wsnd.d(48): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(65):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(66): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(83): Error: found \''in\''
    when expecting \'';\''\n/tmp/tmpni29wsnd.d(84): Error: found \''in\'' when expecting
    \'';\''\n/tmp/tmpni29wsnd.d(101): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(102):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpni29wsnd.d(111): Error:
    unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni29wsnd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7us_dkq4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); j++)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    count++;\n                    i = j;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpncbj1zd5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn87xpa7u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyotz6elu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, string\
    \ substring2, string substring3) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2,\
    \ string substring3, string substring4, string substring5) \n{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3, string substring4,\
    \ string substring5, string substring6) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwka_kil_.d(110): Error: found \''unittest\'' instead of statement\n/tmp/tmpwka_kil_.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpwka_kil_.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwka_kil_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), case_sensitive) == 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string case_sensitive, int start2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length(),\
    \ case_sensitive, start2) == 0)\n        {\n            count++;\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg_2c_8nz.d(95): Error: found \''unittest\'' instead of statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_2c_8nz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string caseSensitive) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length(), caseSensitive)\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, string caseSensitive,\
    \ int startIndex) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n\
    \    {\n        if(string.substr(i, substring.length(), caseSensitive, startIndex)\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be \nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3cm_tlgl.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3cm_tlgl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\
    \t\tif (string[i] == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\
    \t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step, string pattern) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i+=step)\n\t{\n\t\tif (string[i] == substring[0] && string[i + 1] ==\
    \ substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, string pattern2)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif\
    \ (string[i] == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\t\
    count += 1;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaac1apnz.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpaac1apnz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in substring) \n    {\n       \
    \ foreach(char c2 in string) \n        {\n            if(c == c2) \n         \
    \   {\n                count++;\n            }\n        }\n    }\n    \n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6mjlii0a.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmp6mjlii0a.d(13):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp6mjlii0a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, start2+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int start2, int end2) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step, start2+=step, end2+=step)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2jkd7o0u.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp2jkd7o0u.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp2jkd7o0u.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2jkd7o0u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int step2) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < end; i+=step, i+=step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbr3srau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprbr3srau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int step2, int step3) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, int step2, int step3, int step4) \n\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo4ito0d_.d(93): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo4ito0d_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string.charAt(i)\
    \ == substring.charAt(j))\n            {\n                count++;\n         \
    \   }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < string.length(); i++)\n\
    \    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n     \
    \       if(string.charAt(i) == substring.charAt(j))\n            {\n         \
    \       count++;\n            }\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string.charAt(i) == substring.charAt(j))\n \
    \           {\n                count++;\n            }\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        for(int j = 0;\
    \ j < substring.length(); j++)\n        {\n            if(string.charAt(i) ==\
    \ substring.charAt(j))\n            {\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int step2) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < end; i+=step, j+=step2)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string.charAt(i) == substring.charAt(j))\n \
    \           {\n                count++;\n            }\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n    long \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx3ipa89z.d(105): Error: no identifier for declarator long\n/tmp/tmpx3ipa89z.d(105):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpx3ipa89z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhqgs0og.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int step2) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < end; i+=step, i+=step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbr3srau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprbr3srau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0] && string[i+1] == substring[1])\n        {\n\
    \            count += 1;\n            i += 2;\n        }\n        else\n     \
    \   {\n            if(string[i] == substring[0])\n            {\n            \
    \    count += 1;\n                i += 1;\n            }\n        }\n    }\n \
    \   return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, char delimiter) \n{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n        if(string[i]\
    \ == substring[0] && string[i+1] == substring[1])\n        {\n            count\
    \ += 1;\n            i += 2;\n        }\n        else\n        {\n           \
    \ if(string[i] == substring[0])\n            {\n                count += 1;\n\
    \                i += 1;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, char delimiter, char delimiter2) \n{\n    long count = 0;\n\
    \    for(int i = 0; i < string.size(); ++i)\n    {\n        if(string[i] == substring[0]\
    \ && string[i+1] == substring[1])\n        {\n            count += 1;\n      \
    \      i += 2;\n        }\n        else\n        {\n            if(string[i] ==\
    \ substring[0])\n            {\n                count += 1;\n                i\
    \ += 1;\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ char delimiter, char delimiter2, char delimiter3) \n{\n    long count = 0;\n\
    \    for(int i = 0; i < string.size(); ++i)\n    {\n        if(string[i] == substring[0]\
    \ && string[i+1] == substring[1])\n        {\n            count += 1;\n      \
    \      i += 2;\n        }\n        else\n        {\n            if(string[i] ==\
    \ substring[0])\n            {\n                count += 1;\n                i\
    \ += 1;\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ char delimiter, char delimiter2, char delimiter3, char delimiter4) \n{\n   \
    \ long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n       \
    \ if(string[i] == substring[0] && string[i+1] == substring[1])\n        {\n  \
    \          count += 1;\n            i += 2;\n        }\n        else\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqmxzzc4x.d(118): Error: found \''unittest\'' instead of statement\n/tmp/tmpqmxzzc4x.d(127):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmxzzc4x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        for(int j = start; j < end; j++)\n\
    \        {\n            if(string[i] == substring[j])\n            {\n       \
    \         count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step) \n{\n    long count = 0;\n\
    \    \n    for(int i = start; i < string.length(); i++)\n    {\n        for(int\
    \ j = start; j < end; j += step)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end, long step,\
    \ long step2) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = start; j < end; j += step)\n        {\n   \
    \         if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step, long step2, long step3) \n{\n    long count\
    \ = 0;\n    \n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpirrvpbid.d(117): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpirrvpbid.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, bool case_sensitive) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(case_sensitive ? string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0 : \n            string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), SubstringCase::Ignore)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, SubstringCase::Type case_sensitive) \n{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(case_sensitive\
    \ == SubstringCase::Ignore ? string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0 : \n            string.compare(i, substring.length(),\
    \ substring, 0, substring.length(), SubstringCase::Ignore) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ SubstringCase::Type case_sensitive, bool case_sensitive) \n{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(case_sensitive\
    \ == SubstringCase::Ignore ? string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0 : \n            string.compare(i, substring.length(),\
    \ substring, 0, substring.length(), SubstringCase::Ignore) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ SubstringCase::Type case_sensitive, SubstringCase::Type case_sensitive) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(case_sensitive == SubstringCase::Ignore ? string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0 : \n            string.compare(i, substring.length(),\
    \ substring, 0, substring\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5g5ln5q_.d(29): Error: found \'':\'' when expecting \'',\''\n/tmp/tmp5g5ln5q_.d(29):
    Error: expression expected, not \'':\''\n/tmp/tmp5g5ln5q_.d(29): Error: found
    \''Ignore\'' when expecting \'',\''\n/tmp/tmp5g5ln5q_.d(40): Error: found \'':\''
    when expecting \'')\''\n/tmp/tmp5g5ln5q_.d(40): Error: semicolon expected following
    function declaration\n/tmp/tmp5g5ln5q_.d(40): Error: Declaration expected, not
    \'':\''\n/tmp/tmp5g5ln5q_.d(43): Error: Declaration expected, not \''for\''\n/tmp/tmp5g5ln5q_.d(43):
    Error: no identifier for declarator i\n/tmp/tmp5g5ln5q_.d(43): Error: Declaration
    expected, not \''<\''\n/tmp/tmp5g5ln5q_.d(43): Error: no identifier for declarator
    i\n/tmp/tmp5g5ln5q_.d(43): Error: Declaration expected, not \''++\''\n/tmp/tmp5g5ln5q_.d(49):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5g5ln5q_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogkwgulx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string.compare(i,\
    \ j, substring, 0, substring.length()) == 0)\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpry__t9_x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, bool case_insensitive) \n{\n\tlong count = 0;\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\tif (case_insensitive == true)\
    \ {\n\t\t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\t\t\
    \tcount++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (string.compare(i, substring.length(),\
    \ substring, true) == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, bool case_insensitive, bool ignore_case) \n{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (case_insensitive\
    \ == true) {\n\t\t\tif (ignore_case == true) {\n\t\t\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\
    } else {\n\t\t\t\tif (string.compare(i, substring.length(), substring, true) ==\
    \ 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ignore_case\
    \ == true) {\n\t\t\t\tif (string.compare(i, substring.length(), substring, true)\
    \ == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (string.compare(i,\
    \ substring.length(), substring, true) == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, bool case_insensitive,\
    \ bool ignore_case, bool ignore_whitespace) \n{\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (case_insensitive == true) {\n\t\t\
    \tif (ignore_case == true) {\n\t\t\t\tif (ignore_whitespace == true) {\n\t\t\t\
    \t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\t\t\t\t\t\
    count++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (string.compare(i, substring.length(),\
    \ substring, true) == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\
    \t} else {\n\t\t\t\tif (ignore_whitespace == true) {\n\t\t\t\t\tif (string.compare(i,\
    \ substring.length(), substring, true) == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\
    \t}\n\t\t\t\t} else {\n\t\t\t\t\tif (string.compare(i, substring.length(), substring,\
    \ true) == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\
    \ else {\n\t\t\tif (ignore_case == true) {\n\t\t\t\tif (ignore_whitespace == true)\
    \ {\n\t\t\t\t\tif (string.compare(i, \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc270ckt1.d(103): Error: expression expected, not \''unittest\''\n/tmp/tmpc270ckt1.d(104):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(105): Error: expression
    expected, not \''alias\''\n/tmp/tmpc270ckt1.d(105): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmpc270ckt1.d(105): Error: expression expected, not
    \''=\''\n/tmp/tmpc270ckt1.d(105): Error: found \''how_many_times\'' when expecting
    \'',\''\n/tmp/tmpc270ckt1.d(105): Error: expression expected, not \'';\''\n/tmp/tmpc270ckt1.d(107):
    Error: found \''assert\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(107): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(108): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpc270ckt1.d(109): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpc270ckt1.d(110): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(111):
    Error: expression expected, not \''}\''\n/tmp/tmpc270ckt1.d(112): Error: found
    \''void\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(112): Error: found \''{\''
    when expecting \'',\''\n/tmp/tmpc270ckt1.d(112): Error: expression expected, not
    \''}\''\n/tmp/tmpc270ckt1.d(112): Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmpc270ckt1.d(112):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpc270ckt1.d(112): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmpc270ckt1.d(112): Error: found
    \''EOF\'' instead of statement\n/tmp/tmpc270ckt1.d(112): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpc270ckt1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(j))\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zjp85aj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3) \n{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n        if(string.substr(i, substring2.length()) == substring2)\n       \
    \ {\n            count++;\n        }\n        if(string.substr(i, substring3.length())\
    \ == substring3)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3, string substring4)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.substr(i, substring.length()) == substring)\n        {\n\
    \            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\n        {\n            count++;\n        }\n        if(string.substr(i,\
    \ substring3.length()) == substring3)\n        {\n            count++;\n     \
    \   }\n        if(string.substr(i, substring4.length()) == substring4)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4, string\
    \ substring5) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp035x0l37.d(105): Error: found \''unittest\'' instead of statement\n/tmp/tmp035x0l37.d(114):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp035x0l37.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ for(int j = 0; j < substring.length(); j++) {\n            if(string[i] == substring[j])\
    \ {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(string[i] == substring[j]) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\
    \ {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i += step) {\n   \
    \     for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ string pattern) \n{\n    long count = 0;\n    for(int i = start; i < end; i\
    \ += step) {\n        for(int j = 0; j < substring.length(); j++) {\n        \
    \    if(string[i] == substring[j]) {\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string replacement) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i += step) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(string[i] == substring[j]) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoc1x8tv5.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpoc1x8tv5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7us_dkq4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, string pattern) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j] && pattern == substring)\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step, string pattern, string pattern2) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7k2h03h4.d(113): Error: found \''unittest\'' instead of statement\n/tmp/tmp7k2h03h4.d(122):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7k2h03h4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshde1sqg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int min) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int min, int max) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zty7ex0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int step2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step,\
    \ i+=step2)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2, int step3) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5vf1l7_d.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5vf1l7_d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.compare(i, substring.length(), substring) == 0)\n     \
    \   {\n            count++;\n        }\n    }\n    \n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6mv27qh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int start2, int end2) \n{\n    long count = 0;\n    for(int i\
    \ = start; i < end; i += step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5c7rcedl.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5c7rcedl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string pattern) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i+=step)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, string pattern2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.substr(i, substring.length()) == substring)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnw_bblwn.d(104): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnw_bblwn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\
    \t\t\ti += 2;\n\t\t}\n\t\telse if (string[i] == substring[0] && string[i + 1]\
    \ != substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\t\t}\n\t\telse if\
    \ (string[i] != substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\t\
    count += 1;\n\t\t\ti += 1;\n\t\t}\n\t\telse if (string[i] != substring[0] && string[i\
    \ + 1] != substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\t\t}\n\t\t\
    else if (string[i] == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\
    \t\tcount += 1;\n\t\t\ti += 2;\n\t\t}\n\t\telse if (string[i] == substring[0]\
    \ && string[i + 1] != substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\
    \t\t}\n\t\telse if (string[i] != substring[0] && string[i + 1] == substring[1])\n\
    \t\t{\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\t\t}\n\t\telse if (string[i] != substring[0]\
    \ && string[i + 1] != substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogtt940j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm0oqlan.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwpfd15zf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start) \n{\n\
    \    long count = 0;\n    for(int i = start; i < string.length(); i++) {\n   \
    \     if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++) {\n    \
    \    if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end; i +=\
    \ step) {\n        if(string.substr(i, substring.length()) == substring) {\n \
    \           count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i += step) {\n        if(string.substr(i, substring.length())\
    \ == substring) {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, string replacement)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i += step) {\n   \
    \     if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string replacement, int startIndex) \n{\n\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn9chfny9.d(94): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn9chfny9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.size(); ++i)\n    {\n\
    \        if(string[i] == substring[0])\n        {\n            for(int j = i;\
    \ j < string.size(); ++j)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    for(int k = j; k < string.size(); ++k)\n\
    \                    {\n                        if(string[k] == substring[0])\n\
    \                        {\n                            for(int l = k; l < string.size();\
    \ ++l)\n                            {\n                                if(string[l]\
    \ == substring[0])\n                                {\n                      \
    \              for(int m = l; m < string.size(); ++m)\n                      \
    \              {\n                                        if(string[m] == substring[0])\n\
    \                                        {\n                                 \
    \           for(int n = m; n < string.size(); ++n)\n                         \
    \                   {\n                                                if(string[n]\
    \ == substring[0])\n                                                {\n      \
    \                                              for(int o = n; o < string.size();\
    \ ++o)\n                                                    {\n              \
    \                                          if(string[o] == substring[0])\n   \
    \                                                     {\n                    \
    \                                        for(int p = o; p < string.size(); ++p)\n\
    \                                                            {\n             \
    \                                                   if(string[p] == substring[0])\n\
    \                                                                {\n         \
    \                                                           for(int q = p; q <\
    \ string.size(); ++q)\n                                                      \
    \              {\n                                                           \
    \             if(string[q] == substring[0])\n                                \
    \                                        {\n                                 \
    \                                           for(int r = q; r < string.size();\
    \ ++r)\n                                                                     \
    \       {\n                                                                  \
    \              if(string[r] == substring[0])\n                               \
    \                                                 {\n                        \
    \                                                            for(int s = r; s\
    \ < string.size(); ++s)\n                                                    \
    \                                {\n                                         \
    \                                               if(string[s] == substring[0])\n\
    \                                                                            \
    \            {\n                                                             \
    \                               for(int t = s; t < string.size(); ++t)\n     \
    \                                                                            \
    \           {\n                                                              \
    \                                  if(string[t] == substring[0])\n           \
    \                                                                            \
    \         {\n                                                                \
    \                                    for(int u = t; u < string.size(); ++u)\n\
    \                                                                            \
    \                        {\n                                                 \
    \                                                       if(string[u] == substring[0])\n\
    \                                                                            \
    \                            {\n                                             \
    \                                                               for(int v = u;\
    \ v < string.size(); ++v)\n                                                  \
    \                                                          {\n               \
    \                                                                            \
    \                     if(string[v] == substring[0])\n                        \
    \                                                                            \
    \            {\n                                                             \
    \                                                       for(int w = v; w < string.size();\
    \ ++w)\n                                                                     \
    \                                               {\n                          \
    \                                                                            \
    \                  if(string[w] == substring[0])\n                           \
    \                                                                            \
    \                 {\n                                                        \
    \                                                                    for(int x\
    \ = w; x < string.size(); ++x)\n                                             \
    \                                                                            \
    \   {\n                                                                      \
    \                                                          if(string[x] == substring[0])\n\
    \                                                                            \
    \                                                    {\n                     \
    \                                                                            \
    \                                   for(int y = x; y < string.size(); ++y)\n \
    \                                                                            \
    \                                                       {\n                  \
    \                                                                            \
    \                                          if(string[y] == substring[0])\n   \
    \                                                                            \
    \                                                         {\n                \
    \                                                                            \
    \                                                for(int z = y; z < string.size();\
    \ ++z)\n                                                                     \
    \                                                                       {\n  \
    \                                                                            \
    \                                                                  if(string[z]\
    \ == substring[0])\n                                                         \
    \                                                                            \
    \           {\n                                                              \
    \                                                                            \
    \          for(int aa = z; aa < \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptpmp9nqn.d(84): Error: expression expected, not \''unittest\''\n/tmp/tmptpmp9nqn.d(85):
    Error: found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmptpmp9nqn.d(86):
    Error: expression expected, not \''alias\''\n/tmp/tmptpmp9nqn.d(86): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmptpmp9nqn.d(86): Error: found \''=\''
    instead of statement\n/tmp/tmptpmp9nqn.d(93): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmptpmp9nqn.d(93):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptpmp9nqn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm0oqlan.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, bool case_insensitive) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(case_insensitive ? string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0 : string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int startIndex, int endIndex) \n{\n    long count = 0;\n    for(int i = startIndex;\
    \ i < endIndex; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int startIndex,\
    \ int endIndex, bool case_insensitive) \n{\n    long count = 0;\n    for(int i\
    \ = startIndex; i < endIndex; i++)\n    {\n        if(case_insensitive ? string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0 : string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int startIndex, int endIndex, bool case_insensitive, int startIndexInclusive,\
    \ int endIndexInclusive) \n{\n    long count = 0;\n    for(int i = startIndex;\
    \ i < endIndex; i++)\n    {\n        if(case_insensitive ? string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0 : string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjpcyjyta.d(88): Error: no identifier for declarator long\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjpcyjyta.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int min) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int min, int max) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zty7ex0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end) \n{\n    long count = 0;\n    \n    for(int i = start; i < end; i++)\n\
    \    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n     \
    \       if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step) \n{\n    long count = 0;\n\
    \    \n    for(int i = start; i < end; i+=step)\n    {\n        for(int j = 0;\
    \ j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step, long step2) \n{\n    long count = 0;\n    \n   \
    \ for(int i = start; i < end; i+=step, j+=step2)\n    {\n        for(int j = 0;\
    \ j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step, long step2, long step3) \nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvl515xeq.d(118): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvl515xeq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) \n    {\n        if(string.find(substring)\
    \ != string::npos) \n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplrsou9vk.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmplrsou9vk.d(13):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmplrsou9vk.d(13): Error: found
    \'':\'' instead of statement\n/tmp/tmplrsou9vk.d(19): Error: Declaration expected,
    not \''return\''\n/tmp/tmplrsou9vk.d(20): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrsou9vk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) {\n        if(string.find(substring,\
    \ c) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph12yhjnn.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmph12yhjnn.d(12):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmph12yhjnn.d(12): Error: found
    \'':\'' instead of statement\n/tmp/tmph12yhjnn.d(16): Error: Declaration expected,
    not \''return\''\n/tmp/tmph12yhjnn.d(17): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph12yhjnn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, long start, long end,\
    \ long step, long step2) \n{\n    long count = 0;\n    for(int i = start; i <\
    \ end; i+=step, i+=step2)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step, long step2, long\
    \ step3) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg4alrpau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg4alrpau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy45r70fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++)\n\t{\n\t\tif (string.substr(i, substring.length()) ==\
    \ substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\
    \t{\n\t\tif (string.substr(i, substring.length()) == substring)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif\
    \ (string.substr(i, substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < end; i+=step, i+=step2)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2, int step3) \n{\n\t\
    long count = 0;\n\tfor (int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \t{\n\t\tif (string.substr(i, substring.length()) == substring)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, \nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_y2h0zja.d(92): Error: basic type expected, not unittest\n/tmp/tmp_y2h0zja.d(92):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_y2h0zja.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb93r628.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpan4s1ejy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()).equals(substring))\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()).equals(substring))\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step, i+=step2)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2, long step3) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \    {\n        if(string.substr(i, substring.length()).equals(substring))\n \
    \       {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp92yixjl6.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp92yixjl6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, string\
    \ substring2, string substring3) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2,\
    \ string substring3, string substring4, string substring5) \n{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3, string substring4,\
    \ string substring5, string substring6) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwka_kil_.d(110): Error: found \''unittest\'' instead of statement\n/tmp/tmpwka_kil_.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpwka_kil_.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwka_kil_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfjb5unng.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.substr(i, substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\t\
    \n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7b2k9y5b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnd1gftu4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), case_sensitive) == 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string case_sensitive, int start)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length(),\
    \ case_sensitive) == 0)\n        {\n            count++;\n        }\n\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwa99zs74.d(97): Error: found \''unittest\'' instead of statement\n/tmp/tmpwa99zs74.d(106):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa99zs74.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb93r628.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int len) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        if(string.compare(i, len, substring,\
    \ 0, len) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int len, int start2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i += step)\n    {\n\
    \        if(string.compare(i, len, substring, start2, len) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given sub\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdvoo86fx.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpdvoo86fx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0]) \n        {\n            for(int j = 1; j <\
    \ substring.size(); ++j)\n            {\n                if(string[i + j] != substring[j])\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            count += j - 1;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis code doesn't work. `string` doesn't have `size()`\
    \ method. Also `string` doesn't have `operator[]` method. `string` doesn't have\
    \ `operator==` method. `string` doesn't have `operator+=` method. `string` doesn't\
    \ have `operator-=` method. `string` doesn't have `operator*=` method. `string`\
    \ doesn't have `operator/=` method. `string` doesn't have `operator%=` method.\
    \ `string` doesn't have `operator++` method. `string` doesn't have `operator--`\
    \ method. `string` doesn't have `operator<` method. `string` doesn't have `operator>`\
    \ method. `string` doesn't have `operator<=` method. `string` doesn't have `operator>=`\
    \ method. `string` doesn't have `operator+` method. `string` doesn't have `operator-`\
    \ method. `string` doesn't have `operator*` method. `string` doesn't have `operator/`\
    \ method. `string` doesn't have `operator%` method. `string` doesn't have `operator++`\
    \ method. `string` doesn't have `operator--` method. `string` doesn't have `operator<`\
    \ method. `string` doesn't have `operator>` method. `string` doesn't have `operator<=`\
    \ method. `string` doesn't have `operator>=` method. `string` doesn't have `operator+`\
    \ method. `string` doesn't have `operator-` method. `string` doesn't have `operator*`\
    \ method. `string` doesn't have `operator/` method. `string` doesn't have `operator%`\
    \ method. `string` doesn't have `operator++` method. `string` doesn't have `operator--`\
    \ method. `string` doesn't have `operator<` method. `string` doesn't have `operator>`\
    \ method. `string` doesn't have `operator<=` method. `string` doesn't have `operator>=`\
    \ method. `string` doesn't have `operator+` method. `string` doesn't have `operator-`\
    \ method. \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpou0c516r.d(26): Error: Declaration expected, not \''<\''\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated character constant\n/tmp/tmpou0c516r.d(29):
    Error: unterminated character constant\n/tmp/tmpou0c516r.d(29): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpou0c516r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int min) \n{\n    long count = 0;\n    for(int i = start; i <\
    \ end; i += step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int min, int max) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong ho\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyio391p4.d(104): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyio391p4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmua5g2co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, long start, long end, long\
    \ step, long step2) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i += step, i += step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step, long step2, long\
    \ step3) \n{\n    long count = 0;\n    for(int i = start; i < end; i += step,\
    \ i += step2, i += step3)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqslbx6sp.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpqslbx6sp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpan4s1ejy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshde1sqg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmua5g2co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); j++)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    count++;\n                    i = j;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, bool case_sensitive) \n{\n \
    \   long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n     \
    \   if(case_sensitive)\n        {\n            if(string[i] == substring[0])\n\
    \            {\n                for(int j = i; j < string.size(); j++)\n     \
    \           {\n                    if(string[j] == substring[0])\n           \
    \         {\n                        count++;\n                        i = j;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        else\n        {\n            if(string[i] ==\
    \ substring[0])\n            {\n                for(int j = i; j < string.size();\
    \ j++)\n                {\n                    if(string[j] == substring[0])\n\
    \                    {\n                        count++;\n                   \
    \     i = j;\n                        break;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++)\n    {\n        if(case_sensitive)\n        {\n\
    \            if(string[i] == substring[0])\n            {\n                for(int\
    \ j = i; j < string.size(); j++)\n                {\n                    if(string[j]\
    \ == substring[0])\n                    {\n                        count++;\n\
    \                        i = j;\n                        break;\n            \
    \        }\n                }\n            }\n        }\n        else\n      \
    \  {\n            if(string[i] == substring[0])\n            {\n             \
    \   for(int j = i; j < string.size(); j++)\n                {\n              \
    \      if(string[j] == substring[0])\n                    {\n                \
    \        count++;\n                        i = j;\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, bool case_sensitive, bool ignore_case,\
    \ bool ignore_whitespace) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ i++)\n    {\n        if(case_sensitive)\n        {\n            if(string[i]\
    \ == substring[0])\n            {\n                for(int j = i; j < string.size();\
    \ j\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppjjc68ui.d(125): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmppjjc68ui.d(134): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmppjjc68ui.d(134): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmppjjc68ui.d(134):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmppjjc68ui.d(134):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppjjc68ui.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsxe20zg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4y2pz48v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshde1sqg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.substr(i, substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\t\
    \n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7b2k9y5b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif\
    \ (string[i] == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\t\
    count += 1;\n\t\t}\n\t\telse if (string[i] == substring[0] && string[i + 1] !=\
    \ substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t\telse if (string[i] != substring[0]\
    \ && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t\telse\
    \ if (string[i] != substring[0] && string[i + 1] != substring[1])\n\t\t{\n\t\t\
    \tcount += 1;\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvn50wkb6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor\
    \ (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwhpchj5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length; j++)\n\t\t\
    \t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\
    \t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\t\t\t\
    for (int j = i; j < string.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\
    \t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\t{\n\t\t\
    if (string[i] == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length;\
    \ j++)\n\t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\t\
    count++;\n\t\t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n\tlong count =\
    \ 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif (string[i] == substring[0])\n\
    \t\t{\n\t\t\tfor (int j = i; j < string.Length; j+=step)\n\t\t\t{\n\t\t\t\tif\
    \ (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\ti = j;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length; j+=step)\n\
    \t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\t\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjhuhlq0z.d(115): Error: found \''unittest\'' instead of statement\n/tmp/tmpjhuhlq0z.d(124):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpjhuhlq0z.d(124):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpjhuhlq0z.d(124):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpjhuhlq0z.d(124):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjhuhlq0z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0] && string[i+1] == substring[1])\n        {\n\
    \            count += 1;\n            i += 2;\n        }\n        else if(string[i]\
    \ == substring[0])\n        {\n            count += 1;\n            i += 1;\n\
    \        }\n        else if(string[i] == substring[1])\n        {\n          \
    \  count += 1;\n            i += 1;\n        }\n        else\n        {\n    \
    \        count += 0;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string[i] == substring[0] && string[i+1] == substring[1])\n\
    \        {\n            count += 1;\n            i += 2;\n        }\n        else\
    \ if(string[i] == substring[0])\n        {\n            count += 1;\n        \
    \    i += 1;\n        }\n        else if(string[i] == substring[1])\n        {\n\
    \            count += 1;\n            i += 1;\n        }\n        else if(string[i]\
    \ == substring2[0] && string[i+1] == substring2[1])\n        {\n            count\
    \ += 1;\n            i += 2;\n        }\n        else if(string[i] == substring2[0])\n\
    \        {\n            count += 1;\n            i += 1;\n        }\n        else\
    \ if(string[i] == substring2[1])\n        {\n            count += 1;\n       \
    \     i += 1;\n        }\n        else\n        {\n            count += 0;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2,\
    \ string substring3) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string[i] == substring[0] && string[i+1] == substring[1])\n\
    \        {\n            count += 1;\n            i += 2;\n        }\n        else\
    \ if(string[i] == substring[0])\n        {\n            count += 1;\n        \
    \    i += 1;\n        }\n        else if(string[i] == substring[1])\n        {\n\
    \            count += 1;\n            i += 1;\n        }\n        else if(string[i]\
    \ == substring2[0] && string[i+1] == substring2[1])\n        {\n            count\
    \ += 1;\n            i += 2;\n        }\n        else if(string[i] == substring2[0])\n\
    \        {\n            count += 1;\n            i += 1;\n        }\n        else\
    \ if(string[i] == substring2[1])\n        {\n            count += 1;\n       \
    \     i += 1;\n        }\n        else if(string[i] == substring3[0] && string[i+1]\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfl_o6cg1.d(120): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpfl_o6cg1.d(129): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmpfl_o6cg1.d(129): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpfl_o6cg1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); ++j)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(string[j+1] == substring[1])\n    \
    \                {\n                        count += 1;\n                    }\n\
    \                    else\n                    {\n                        break;\n\
    \                    }\n                }\n                else\n            \
    \    {\n                    break;\n                }\n            }\n       \
    \ }\n        else\n        {\n            break;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.size(); ++i)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = i; j < string.size(); ++j)\n            {\n\
    \                if(string[j] == substring[0])\n                {\n          \
    \          if(string[j+1] == substring[1])\n                    {\n          \
    \              if(string[j+2] == substring[2])\n                        {\n  \
    \                          count += 1;\n                        }\n          \
    \              else\n                        {\n                            break;\n\
    \                        }\n                    }\n                    else\n\
    \                    {\n                        break;\n                    }\n\
    \                }\n                else\n                {\n                \
    \    break;\n                }\n            }\n        }\n        else\n     \
    \   {\n            break;\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.size(); ++i)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = i; j < string.size(); ++j)\n            {\n\
    \                if(string[j] == substring[0])\n                {\n          \
    \          if(string[j+1] == substring[1])\n                    {\n          \
    \              if(string[j+2] == substring[2])\n                        {\n  \
    \                          if(string[j+3] == substring[3])\n                 \
    \           {\n                                count += 1;\n                 \
    \           }\n                            else\n                            {\n\
    \                                break;\n                            }\n     \
    \                   }\n                        else\n                        {\n\
    \                            break;\n                        }\n             \
    \       }\n                    else\n                    {\n                 \
    \       break;\n                    }\n                }\n                else\n\
    \                {\n                    break;\n                }\n          \
    \  }\n        }\n        else\n        {\n            break;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, string substring2, \nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpngxthmc1.d(140): Error: basic type expected, not unittest\n/tmp/tmpngxthmc1.d(140):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpngxthmc1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), case_sensitive) == 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string case_sensitive, int start2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length(),\
    \ case_sensitive, start2) == 0)\n        {\n            count++;\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg_2c_8nz.d(95): Error: found \''unittest\'' instead of statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpg_2c_8nz.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_2c_8nz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string pattern) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i+=step)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, string pattern2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.substr(i, substring.length()) == substring)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnw_bblwn.d(104): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnw_bblwn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.size(); ++i)\n\t{\n\t\tfor\
    \ (int j = 0; j < substring.size(); ++j)\n\t\t{\n\t\t\tif (string[i] == substring[j])\n\
    \t\t\t{\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxtyhlo6x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.find(substring, i) != string::npos)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start) \n\
    {\n    long count = 0;\n    for(int i = start; i < string.length(); i++)\n   \
    \ {\n        if(string.find(substring, i) != string::npos)\n        {\n      \
    \      count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n\
    \    {\n        if(string.find(substring, i) != string::npos)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step)\n    {\n        if(string.find(substring, i) != string::npos)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i += step, i += step2)\n    {\n\
    \        if(string.find(substring, i) != string::npos)\n        {\n          \
    \  count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step, long step2, long step3) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i += step, i += step2, i += step3)\n    {\n \
    \       if(string.find(substring, i) != string::npos)\n        {\n           \
    \ count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count \nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpet99uvjn.d(12): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpet99uvjn.d(12):
    Error: found \'':\'' instead of statement\n/tmp/tmpet99uvjn.d(17): Error: Declaration
    expected, not \''return\''\n/tmp/tmpet99uvjn.d(18): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpet99uvjn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb93r628.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int end2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int end2, int end3) \n{\n    long count = 0;\n    for(int i =\
    \ start; i < end; i+=step, i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvbptjw6p.d(98): Error: expression expected, not \''unittest\''\n/tmp/tmpvbptjw6p.d(99):
    Error: found \''{\'' when expecting \'';\'' following return statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbptjw6p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) \n    {\n        if(string.find(substring)\
    \ != string::npos) \n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplrsou9vk.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmplrsou9vk.d(13):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmplrsou9vk.d(13): Error: found
    \'':\'' instead of statement\n/tmp/tmplrsou9vk.d(19): Error: Declaration expected,
    not \''return\''\n/tmp/tmplrsou9vk.d(20): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrsou9vk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int i\
    \ = start; i < end; i+=step, j+=step2)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2, int step3) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i+=step, j+=step\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpctpv4w60.d(111): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpctpv4w60.d(120): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctpv4w60.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhqgs0og.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length; j++)\n\t\t\
    \t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\tfor (int k =\
    \ j + 1; k < string.Length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string[k] == substring[0])\n\
    \t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\
    \t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, char delimiter) \n{\n\tlong count = 0;\n\tfor (int i = 0;\
    \ i < string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\t\t\
    \tfor (int j = i; j < string.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\
    \t\t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < string.Length; k++)\n\t\t\t\t\t{\n\
    \t\t\t\t\t\tif (string[k] == substring[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\
    \t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, char delimiter,\
    \ char delimiter2) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.Length;\
    \ i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\t\t\tfor (int j = i;\
    \ j < string.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\t\
    \t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < string.Length; k++)\n\t\t\t\t\t{\n\t\
    \t\t\t\t\tif (string[k] == substring[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\
    \t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, char delimiter,\
    \ char delimiter2, char delimiter3) \n{\n\tlong count = 0;\n\tfor (int i = 0;\
    \ i < string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\t\t\
    \tfor (int j = i; j < string.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[j] == substring[0])\n\
    \t\t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < string.Length; k++)\n\t\t\t\t\t{\n\
    \t\t\t\t\t\tif (string[k] == substring[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\
    \t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\
    \t\t\t}\n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgey290ny.d(120): Error: found \''unittest\'' instead of statement\n/tmp/tmpgey290ny.d(129):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpgey290ny.d(129):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgey290ny.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn87xpa7u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm\
    \ |>\n<| c |>\nThis doesn't work if `substring` is longer than `string`.\n<|/\
    \ c |>\n<| c |>\nIt does work if `substring` is longer than `string`.  It just\
    \ doesn't work if `substring` is shorter than `string`.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work if `substring` is shorter than `string`.  It just doesn't work\
    \ if `substring` is longer than `string`.\n<|/ c |>\n<| c |>\nIt does work if\
    \ `substring` is longer than `string`.  It just doesn't work if `substring` is\
    \ shorter than `string`.\n<|/ c |>\n<| c |>\nIt does work if `substring` is longer\
    \ than `string`.  It just doesn't work if `substring` is shorter than `string`.\n\
    <|/ c |>\n<| a |>\nThis solution doesn't require any extra memory and doesn't\
    \ require any extra loops. It's also very fast.\n<code>\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphf989e3f.d(19): Error: Declaration expected, not \''<\''\n/tmp/tmphf989e3f.d(22):
    Error: unterminated character constant\n/tmp/tmphf989e3f.d(25): Error: unterminated
    character constant\n/tmp/tmphf989e3f.d(28): Error: unterminated character constant\n/tmp/tmphf989e3f.d(28):
    Error: unterminated character constant\n/tmp/tmphf989e3f.d(31): Error: unterminated
    character constant\n/tmp/tmphf989e3f.d(34): Error: unterminated character constant\n/tmp/tmphf989e3f.d(37):
    Error: unterminated character constant\n/tmp/tmphf989e3f.d(37): Error: unterminated
    character constant\n/tmp/tmphf989e3f.d(37): Error: unterminated character constant\n/tmp/tmphf989e3f.d(43):
    Error: Declaration expected, not \''assert\''\n/tmp/tmphf989e3f.d(44): Error:
    Declaration expected, not \''assert\''\n/tmp/tmphf989e3f.d(45): Error: Declaration
    expected, not \''assert\''\n/tmp/tmphf989e3f.d(46): Error: Declaration expected,
    not \''assert\''\n/tmp/tmphf989e3f.d(47): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphf989e3f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, bool case_sensitive)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n \
    \       if(case_sensitive ? string.substr(i, substring.length()) == substring\
    \ : string.IndexOf(substring, i) != -1) {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive, bool\
    \ ignore_case) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(ignore_case ? string.substr(i, substring.length()) == substring\
    \ : string.IndexOf(substring, i) != -1) {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive, bool\
    \ ignore_case, bool ignore_whitespace) \n{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(ignore_case ? string.substr(i,\
    \ substring.length()) == substring : string.IndexOf(substring, i) != -1) {\n \
    \           count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case, bool ignore_whitespace, bool ignore_newlines)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n \
    \       if(ignore_case ? string.substr(i, substring.length()) == substring : string.IndexOf(substring,\
    \ i) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, bool case_sensitive, bool ignore_case, bool ignore_whitespace,\
    \ bool ignore_newlines, bool ignore_case) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(ignore_case ? string.substr(i,\
    \ substring.length()) == substring : string.IndexOf(sub\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv8lljjsy.d(82): Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmpv8lljjsy.d(91):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmpv8lljjsy.d(91): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmpv8lljjsy.d(91): Error: expression
    expected, not \''}\''\n/tmp/tmpv8lljjsy.d(91): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpv8lljjsy.d(91): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpv8lljjsy.d(91):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpv8lljjsy.d(91): Error:
    found \''EOF\'' instead of statement\n/tmp/tmpv8lljjsy.d(91): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpv8lljjsy.d(91): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpv8lljjsy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.substr(i, substring.length()) == substring)\n\t\t{\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntxj10lh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()).equals(substring))\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()).equals(substring))\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step, i+=step2)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2, long step3) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \    {\n        if(string.substr(i, substring.length()).equals(substring))\n \
    \       {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp92yixjl6.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp92yixjl6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=step2)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2, int step3) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n    {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ua1us7d.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ua1us7d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) \n    {\n        if(string.find(substring)\
    \ != string::npos) \n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\n\
    This is not the most efficient solution, since it does a linear search for each\
    \ character in the string. Also it does a linear search for each character in\
    \ the substring.\n<|/ c |>\n<| c |>\nI agree with you, my solution is more efficient\
    \ than yours. But I wanted to give an alternative solution. Anyway, thanks for\
    \ your comment.\n<|/ c |>\n<| c |>\nI agree with you that your solution is more\
    \ efficient, but I wanted to give an alternative solution that is more efficient\
    \ than yours. I agree with you that your solution is more efficient than mine,\
    \ but I wanted to give an alternative solution that is more efficient than yours.\
    \ I agree with you that your solution is more efficient than mine, but I wanted\
    \ to give an alternative solution that is more efficient than yours. I agree with\
    \ you that your solution is more efficient than mine, but I wanted to give an\
    \ alternative solution that is more efficient than yours. I agree with you that\
    \ your solution is more efficient than mine, but I wanted to give an alternative\
    \ solution that is more efficient than yours. I agree with you that your solution\
    \ is more efficient than mine, but I wanted to give an alternative solution that\
    \ is more efficient than yours.\n<|/ c |>\n<| c |>\nI agree with you that your\
    \ solution is more efficient than mine, but I wanted to give an alternative solution\
    \ that is more efficient than yours. I agree with you that your solution is more\
    \ efficient than mine, but I wanted to give an alternative solution that is more\
    \ efficient than yours. I agree with you that your solution is more efficient\
    \ than mine, but I wanted to give an alternative solution that is more efficient\
    \ than yours. I agree with you that your solution is more efficient than mine,\
    \ but I wanted to give an alternative solution that is more efficient than yours.\
    \ I agree with you that your solution is more efficient than mine, but I wanted\
    \ to give an alternative solution that is more efficient than yours.\n<|/ c |>\n\
    <| c |>\nI agree with you that your solution is more efficient than mine, but\
    \ I wanted to give an alternative solution that is more efficient than yours.\
    \ I agree with you that your solution is more efficient than mine, but I wanted\
    \ to give an alternative solution that is more efficient than \nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7iwfhlia.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmp7iwfhlia.d(13):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmp7iwfhlia.d(13): Error: found
    \'':\'' instead of statement\n/tmp/tmp7iwfhlia.d(19): Error: Declaration expected,
    not \''return\''\n/tmp/tmp7iwfhlia.d(20): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7iwfhlia.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length(); j++)\
    \ {\n\t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\tfor\
    \ (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\tfor (int j = 0;\
    \ j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tif (string.charAt(i) == pattern.charAt(j)) {\n\t\t\t\t\tcount++;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, int start2)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i \nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb_46mxmq.d(98): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpb_46mxmq.d(107):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_46mxmq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.find(substring, i) != string::npos)\n\t\t\tcount++;\n\t}\n\t\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9vl3y78.d(13): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpe9vl3y78.d(13):
    Error: found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpe9vl3y78.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step, i+=step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step, long step2, long\
    \ step3) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc7qmfz06.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc7qmfz06.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start) \n{\n\
    \    long count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < string.length(); i++)\n\
    \    {\n        for(int j = start; j < substring.length(); j++)\n        {\n \
    \           if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < string.length(); i++)\n    {\n        for(int j = start; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  for(int j = start; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2) \n{\n    long count = 0;\n \
    \   for(int i = start; i < string.length(); i++)\n    {\n        for(int j = start;\
    \ j < substring\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphjissybi.d(108): Error: found \''unittest\'' when expecting
    \'';\'' following for condition\n/tmp/tmphjissybi.d(117): Error: found \''void\''
    when expecting \'')\''\n/tmp/tmphjissybi.d(117): Error: found \''{\'' when expecting
    \'';\'' following statement\n/tmp/tmphjissybi.d(117): Error: found \''EOF\'' when
    expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmphjissybi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring))\n\t\t\tcount++;\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++)\n\t{\n\t\tif (string.substr(i, substring.length()).equals(substring))\n\
    \t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\t{\n\t\t\
    if (string.substr(i, substring.length()).equals(substring))\n\t\t\tcount++;\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif\
    \ (string.substr(i, substring.length()).equals(substring))\n\t\t\tcount++;\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ int min) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t\
    {\n\t\tif (string.substr(i, substring.length()).equals(substring))\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ int min, int max) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\
    \t{\n\t\tif (string.substr(i, substring.length()).equals(substring))\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ int min, int max, int step2) \n{\n\t\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcwgxltwa.d(94): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwgxltwa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.find(substring,\
    \ i) != string::npos)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.find(substring, i) != string::npos)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n\t\
    long count = 0;\n\tfor (int i = start; i < end; i++)\n\t{\n\t\tif (string.find(substring,\
    \ i) != string::npos)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i+=step)\n\t{\n\t\tif (string.find(substring, i) != string::npos)\n\
    \t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i+=step)\n\t{\n\t\tif (string.find(substring, i) != string::npos)\n\
    \t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = start; i < end; i+=step)\n\t{\n\t\tif (string.find(substring, i) !=\
    \ string::npos)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, string pattern, string pattern2, \nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgcvj67bu.d(12): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(12):
    Error: found \'':\'' instead of statement\n/tmp/tmpgcvj67bu.d(26): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(26): Error: found \'':\'' instead
    of statement\n/tmp/tmpgcvj67bu.d(40): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(40):
    Error: found \'':\'' instead of statement\n/tmp/tmpgcvj67bu.d(54): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(54): Error: found \'':\'' instead
    of statement\n/tmp/tmpgcvj67bu.d(68): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(68):
    Error: found \'':\'' instead of statement\n/tmp/tmpgcvj67bu.d(82): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpgcvj67bu.d(82): Error: found \'':\'' instead
    of statement\n/tmp/tmpgcvj67bu.d(92): Error: basic type expected, not unittest\n/tmp/tmpgcvj67bu.d(92):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpgcvj67bu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif\
    \ (string[i] == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\t\
    count++;\n\t\t}\n\t\telse if (string[i] == substring[0] && string[i + 1] != substring[1])\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] != substring[0] && string[i\
    \ + 1] == substring[1])\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i]\
    \ != substring[0] && string[i + 1] != substring[1])\n\t\t{\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0o53g60.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0] && string[i+1] == substring[1])\n        {\n\
    \            count += 1;\n            i += 2;\n        }\n        else\n     \
    \   {\n            count = 0;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2) \n{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.size(); ++i)\n    {\n        if(string[i] == substring[0] &&\
    \ string[i+1] == substring[1])\n        {\n            count += 1;\n         \
    \   i += 2;\n        }\n        else\n        {\n            count = 0;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2,\
    \ string substring3) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string[i] == substring[0] && string[i+1] == substring[1])\n\
    \        {\n            count += 1;\n            i += 2;\n        }\n        else\n\
    \        {\n            count = 0;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n  \
    \      if(string[i] == substring[0] && string[i+1] == substring[1])\n        {\n\
    \            count += 1;\n            i += 2;\n        }\n        else\n     \
    \   {\n            count = 0;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4, string\
    \ substring5) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string[i] == substring[0] && string[i+1] == substring[1])\n\
    \        {\n            count += 1;\n            i += 2;\n        }\n        else\n\
    \        {\n            count = 0;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4, string\
    \ substring5, string \nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe8nnl380.d(113): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8nnl380.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhqgs0og.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int start2) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step, start2+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int start2, int end2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, start2+=step,\
    \ end2+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp95aomvx3.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp95aomvx3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhqgs0og.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = 1; j <\
    \ substring.size(); j++)\n            {\n                if(string[i + j] == substring[j])\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < string.size(); i++)\n \
    \   {\n        if(string[i] == substring[0])\n        {\n            for(int j\
    \ = 1; j < substring.size(); j++)\n            {\n                if(string[i\
    \ + j] == substring[j])\n                {\n                    count++;\n   \
    \             }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.size(); i++)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = 1; j < substring.size(); j++)\n          \
    \  {\n                if(string[i + j] == substring[j])\n                {\n \
    \                   count++;\n                }\n            }\n        }\n  \
    \  }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < string.size(); i += step)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < substring.size(); j++)\n            {\n                if(string[i\
    \ + j] == substring[j])\n                {\n                    count++;\n   \
    \             }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < string.size(); i += step)\n    {\n        if(string[i]\
    \ == substring[0])\n        {\n            for(int j = 1; j < substring.size();\
    \ j += step2)\n            {\n                if(string[i + j] == substring[j])\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be \nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl1p181iw.d(113): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl1p181iw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshde1sqg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) \n    {\n        if(string.find(substring)\
    \ != string::npos) \n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplrsou9vk.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmplrsou9vk.d(13):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmplrsou9vk.d(13): Error: found
    \'':\'' instead of statement\n/tmp/tmplrsou9vk.d(19): Error: Declaration expected,
    not \''return\''\n/tmp/tmplrsou9vk.d(20): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplrsou9vk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int step2) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < end; i+=step, i+=step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbr3srau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprbr3srau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string.charAt(i)\
    \ == substring.charAt(j))\n            {\n                count++;\n         \
    \   }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, long\
    \ start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string.charAt(i) == substring.charAt(j))\n            {\n    \
    \            count++;\n            }\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string.charAt(i) == substring.charAt(j))\n \
    \           {\n                count++;\n            }\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string.charAt(i)\
    \ == substring.charAt(j))\n            {\n                count++;\n         \
    \   }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step, long step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string.charAt(i) == substring.charAt(j))\n \
    \           {\n                count++;\n            }\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step, long step2, long\
    \ step3) \n{\n    long count = 0;\n    for(int \nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ervavgx.d(106): Error: no identifier for declarator int\n/tmp/tmp_ervavgx.d(106):
    Error: expression expected, not \''unittest\''\n/tmp/tmp_ervavgx.d(107): Error:
    found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmp_ervavgx.d(108):
    Error: expression expected, not \''alias\''\n/tmp/tmp_ervavgx.d(108): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmp_ervavgx.d(108): Error: found
    \''=\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ervavgx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int start2) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i+=step, start2+=step)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int start2, int end2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, start2+=step,\
    \ end2+=step)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg2i7_2ae.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg2i7_2ae.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = 1; j < substring.Length; j++)\n\t\
    \t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ 0; i < string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\
    \t\t\tfor (int j = 1; j < substring.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, string\
    \ substring2, string substring3) \n{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\t\t\t\
    for (int j = 1; j < substring.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[i + j]\
    \ != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, string substring2,\
    \ string substring3, string substring4) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ 0; i < string.Length; i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t{\n\
    \t\t\tfor (int j = 1; j < substring.Length; j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, string\
    \ substring2, string substring3, string substring4, string substring5) \n{\n\t\
    long count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = 1; j < substring.Length; j++)\n\t\
    \t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_xel1lpn.d(118): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xel1lpn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, int step2) \n{\n    long count = 0;\n    for(int i = start; i\
    \ < end; i+=step, i+=step2)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbr3srau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprbr3srau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int step2, int step3) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, int step2, int step3, int step4) \n\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo4ito0d_.d(93): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo4ito0d_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=step2)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2, int step3) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n    {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ua1us7d.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ua1us7d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.compare(i, substring.length(), substring) == 0)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1j1qzsyp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ start; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()).equals(substring))\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()).equals(substring)) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step)\
    \ {\n\t\tif (string.substr(i, substring.length()).equals(substring)) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string case_sensitive) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ start; i < end; i += step) {\n\t\tif (string.substr(i, substring.length()).equals(substring,\
    \ case_sensitive)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string case_sensitive, int start2)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\tif\
    \ (string.substr(i, substring.length()).equals(substring, case_sensitive)) {\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step, string case_sensitive\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3pfj7uze.d(92): Error: found \''unittest\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3pfj7uze.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring))\n\t\t\tcount++;\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvkk1i6tz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tfor (int\
    \ j = 0; j < substring.size(); j++)\n\t\t{\n\t\t\tif (string[i] == substring[j])\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < string.size(); i++)\n\t{\n\t\tfor (int j = 0; j < substring.size(); j++)\n\
    \t\t{\n\t\t\tif (string[i] == substring[j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.size();\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < substring.size(); j++)\n\t\t{\n\t\t\tif (string[i]\
    \ == substring[j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end, long step)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.size(); i += step)\n\
    \t{\n\t\tfor (int j = 0; j < substring.size(); j++)\n\t\t{\n\t\t\tif (string[i]\
    \ == substring[j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end, long step,\
    \ long step2) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.size();\
    \ i += step)\n\t{\n\t\tfor (int j = 0; j < substring.size(); j += step2)\n\t\t\
    {\n\t\t\tif (string[i] == substring[j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2, long step3) \n{\n\tlong count = 0;\n\tfor (int i\
    \ = start; i < string.size(); i += step)\n\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi19zgcru.d(112): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi19zgcru.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsxe20zg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy45r70fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphj4u33q_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.size(); i++)\n    {\n\
    \        if(string[i] == substring[0]) \n        {\n            for(int j = 1;\
    \ j < substring.size(); j++)\n            {\n                if(string[i + j]\
    \ != substring[j])\n                {\n                    break;\n          \
    \      }\n            }\n            \n            if(j == substring.size())\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n    long count\
    \ = 0;\n    \n    for(int i = start; i < string.size(); i++)\n    {\n        if(string[i]\
    \ == substring[0]) \n        {\n            for(int j = 1; j < substring.size();\
    \ j++)\n            {\n                if(string[i + j] != substring[j])\n   \
    \             {\n                    break;\n                }\n            }\n\
    \            \n            if(j == substring.size())\n            {\n        \
    \        count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    \n   \
    \ for(int i = start; i < string.size(); i++)\n    {\n        if(string[i] == substring[0])\
    \ \n        {\n            for(int j = 1; j < substring.size(); j++)\n       \
    \     {\n                if(string[i + j] != substring[j])\n                {\n\
    \                    break;\n                }\n            }\n            \n\
    \            if(j == substring.size())\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    \n    for(int\
    \ i = start; i < string.size(); i += step)\n    {\n        if(string[i] == substring[0])\
    \ \n        {\n            for(int j = 1; j < substring.size(); j++)\n       \
    \     {\n                if(string[i + j] != substring[j])\n                {\n\
    \                    break;\n                }\n            }\n            \n\
    \            if(j == substring.size())\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step, long step2) \n\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp75rdg90y.d(125): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75rdg90y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy45r70fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int step2, int step3) \n{\n\tlong count = 0;\n\tfor (int i = start; i\
    \ < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, int step2, int step3, int step4) \n\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo4ito0d_.d(93): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo4ito0d_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in substring) \n    {\n       \
    \ foreach(char c2 in string) \n        {\n            if(c == c2) \n         \
    \   {\n                count++;\n                break;\n            }\n     \
    \   }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start) \n\
    {\n    long count = 0;\n    \n    foreach(char c in substring) \n    {\n     \
    \   foreach(char c2 in string) \n        {\n            if(c == c2) \n       \
    \     {\n                count++;\n                break;\n            }\n   \
    \     }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end) \n{\n    long count = 0;\n    \n    foreach(char c in substring) \n   \
    \ {\n        foreach(char c2 in string) \n        {\n            if(c == c2) \n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step) \n{\n    long count = 0;\n    \n    foreach(char\
    \ c in substring) \n    {\n        foreach(char c2 in string) \n        {\n  \
    \          if(c == c2) \n            {\n                count++;\n           \
    \     break;\n            }\n        }\n    }\n    \n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2) \n{\n    long\
    \ count = 0;\n    \n    foreach(char c in substring) \n    {\n        foreach(char\
    \ c2 in string) \n        {\n            if(c == c2) \n            {\n       \
    \         count++;\n                break;\n            }\n        }\n    }\n\
    \    \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, long start, long end, long\
    \ step, long step2, long step3) \n{\n    long count = 0;\n\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmv0jxiah.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(13):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(33): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(35): Error: found \''in\''
    when expecting \'';\''\n/tmp/tmpmv0jxiah.d(55): Error: found \''in\'' when expecting
    \'';\''\n/tmp/tmpmv0jxiah.d(57): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(77):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(79): Error: found
    \''in\'' when expecting \'';\''\n/tmp/tmpmv0jxiah.d(99): Error: found \''in\''
    when expecting \'';\''\n/tmp/tmpmv0jxiah.d(101): Error: found \''in\'' when expecting
    \'';\''\n/tmp/tmpmv0jxiah.d(121): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmv0jxiah.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=step2)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2, int step3) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n    {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ua1us7d.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp_ua1us7d.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ua1us7d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.find(substring, i) != string::npos)\n\t\t\tcount++;\n\t}\n\t\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9vl3y78.d(13): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpe9vl3y78.d(13):
    Error: found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpe9vl3y78.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpan4s1ejy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, long start, long end,\
    \ long step, long step2) \n{\n    long count = 0;\n    for(int i = start; i <\
    \ end; i+=step, i+=step2)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step, long step2, long\
    \ step3) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2,\
    \ i+=step3)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg4alrpau.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg4alrpau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include\
    \ <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyoye_s9t.d(17): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoye_s9t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, bool caseSensitive) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length(), caseSensitive) == 0)\n\
    \        {\n            count++;\n        }\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0m193k_o.d(96): Error: found \''unittest\'' instead of statement\n/tmp/tmp0m193k_o.d(105):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m193k_o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfscadn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2zyoacic.d(19): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zyoacic.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n\tlong count = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2) \n{\n\tlong count = 0;\n\tfor (int\
    \ i = start; i < end; i += step) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, int step2, int step3)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\tif\
    \ (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnj15cdgw.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnj15cdgw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\t\
    if (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphj4u33q_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.size(); ++i)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = 1; j < substring.size(); ++j)\n\t\
    \t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2w5y4s9k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0])\n\t\t{\n\t\t\tfor (int j = i; j < string.Length; j++)\n\t\t\
    \t{\n\t\t\t\tif (string[j] == substring[0])\n\t\t\t\t{\n\t\t\t\t\tfor (int k =\
    \ j + 1; k < string.Length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string[k] == substring[0])\n\
    \t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\
    \t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j7ru77l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    \n    for(int i =\
    \ start; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end) \n{\n    long count = 0;\n    \n    for(int i = start; i < end; i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   \n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string case_sensitive) \n{\n    long count = 0;\n\
    \    \n    if(case_sensitive == \"upper\")\n    {\n        for(int i = start;\
    \ i < end; i+=step)\n        {\n            if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n            {\n                count++;\n\
    \            }\n        }\n    }\n    else if(case_sensitive == \"lower\")\n \
    \   {\n        for(int i = start; i < end; i+=step)\n        {\n            if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n            {\n\
    \                count++;\n            }\n        }\n    }\n    else if(case_sensitive\
    \ == \"both\")\n    {\n        for(int i = start; i < end; i+=step)\n\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiydgd965.d(107): Error: found \''unittest\'' instead of statement\n/tmp/tmpiydgd965.d(116):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiydgd965.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()).equals(substring))\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()).equals(substring))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()).contains(pattern))\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()).contains(pattern)\
    \ && string.substr(i, substring.length()).contains(pattern2))\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2lbc4rir.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2lbc4rir.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = 1; j <\
    \ substring.size(); j++)\n            {\n                if(string[i + j] != substring[j])\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            count += j - 1;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsgjsgjl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.substr(i, substring.length()) == substring)\n        {\n\
    \            count++;\n        }\n    }\n    \n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0n3owi_2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.find(substring, i) != string::npos)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start) \n\
    {\n    long count = 0;\n    for(int i = start; i < string.length(); i++)\n   \
    \ {\n        if(string.find(substring, i) != string::npos)\n        {\n      \
    \      count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n\
    \    {\n        if(string.find(substring, i) != string::npos)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.find(substring, i) != string::npos)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i+=step, i+=step2)\n    {\n    \
    \    if(string.find(substring, i) != string::npos)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2, long step3) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=step2, i+=step3)\n    {\n        if(string.find(substring,\
    \ i) != string::npos)\n        {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring \nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxgx6tvk0.d(12): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpxgx6tvk0.d(12):
    Error: found \'':\'' instead of statement\n/tmp/tmpxgx6tvk0.d(17): Error: Declaration
    expected, not \''return\''\n/tmp/tmpxgx6tvk0.d(18): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxgx6tvk0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step, long step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=step2)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step, long step2, long step3) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp47whgzjz.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp47whgzjz.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp47whgzjz.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp47whgzjz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++) {\n \
    \       if(string.substr(i, substring.length()).equals(substring)) {\n       \
    \     count++;\n        }\n    }\n    \n    return count;\n}\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd8eohmsb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int end2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step,\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int end2, int end3) \n{\n  \
    \  long count = 0;\n    for(int i = start; i < end; i+=step, i++)\n    {\n   \
    \     if(string.substr(i, substring.length()) == substring)\n        {\n     \
    \       count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong ho\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1uqyyjl8.d(104): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1uqyyjl8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end; i +=\
    \ step) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < end; i += step) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string replacement) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i += step) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdi3evcd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount += 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpws1upm43.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = 1; j <\
    \ substring.size(); j++)\n            {\n                if(string[i + j] != substring[j])\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            count += j - 1;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.size(); i++)\n    {\n        if(string[i] == substring[0])\n    \
    \    {\n            for(int j = 1; j < substring.size(); j++)\n            {\n\
    \                if(string[i + j] != substring[j])\n                {\n      \
    \              break;\n                }\n            }\n            count +=\
    \ j - 1;\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end) \n{\n    long count = 0;\n    for(int i = start; i < string.size();\
    \ i++)\n    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < substring.size(); j++)\n            {\n                if(string[i\
    \ + j] != substring[j])\n                {\n                    break;\n     \
    \           }\n            }\n            count += j - 1;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < string.size(); i += step)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < substring.size(); j++)\n            {\n                if(string[i\
    \ + j] != substring[j])\n                {\n                    break;\n     \
    \           }\n            }\n            count += j - 1;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2) \n{\n    long count = 0;\n    for(int i = start; i < string.size();\
    \ i += step)\n    {\n        if(string[i] == substring[0])\n        {\n      \
    \      for(int j = 1; j < substring.size(); j++)\n            {\n            \
    \    if(string[i + j] != substring[j])\n                {\n                  \
    \  break;\n                }\n            }\n            count += j\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxtrhd2ik.d(114): Error: found \''unittest\'' when expecting
    \'';\'' following statement\n/tmp/tmpxtrhd2ik.d(123): Error: found \''EOF\'' when
    expecting \''}\'' following compound statement\n/tmp/tmpxtrhd2ik.d(123): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpxtrhd2ik.d(123):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxtrhd2ik.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n                \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, int step2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step,\
    \ i+=step2)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2, int step3) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5vf1l7_d.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5vf1l7_d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsxe20zg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    long length\
    \ = 0;\n    \n    foreach(char c in string) {\n        end = start + length;\n\
    \        \n        if(string.find(substring, start, end) != string::npos) {\n\
    \            count++;\n        }\n        \n        start = end + 1;\n       \
    \ length = end - start;\n    }\n    \n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpto7wel14.d(14): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpto7wel14.d(17):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmpto7wel14.d(17): Error: found
    \'':\'' instead of statement\n/tmp/tmpto7wel14.d(25): Error: Declaration expected,
    not \''return\''\n/tmp/tmpto7wel14.d(26): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpto7wel14.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start) \n{\n\
    \    long count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n\
    \    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n     \
    \       if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, int\
    \ start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int i\
    \ = start; i < end; i+=step, j+=step2)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2, int step3) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i+=step, j+=step2, k+=step3)\n\
    \    {\n        for(int \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0294giy9.d(108): Error: no identifier for declarator int\n/tmp/tmp0294giy9.d(108):
    Error: expression expected, not \''unittest\''\n/tmp/tmp0294giy9.d(109): Error:
    found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmp0294giy9.d(110):
    Error: expression expected, not \''alias\''\n/tmp/tmp0294giy9.d(110): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmp0294giy9.d(110): Error: found
    \''=\'' instead of statement\n/tmp/tmp0294giy9.d(117): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0294giy9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string case_sensitive) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step, string case_sensitive,\
    \ int start2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n\
    \    {\n        if(string.compare(i, substring.length(), substring) == 0)\n  \
    \      {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1ebigdpq.d(104): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ebigdpq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); ++j)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(j+1 < string.size() && string[j+1]\
    \ == substring[0])\n                    {\n                        ++count;\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, char\
    \ delimiter) \n{\n    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = i; j < string.size(); ++j)\n            {\n                if(string[j]\
    \ == substring[0])\n                {\n                    if(j+1 < string.size()\
    \ && string[j+1] == substring[0])\n                    {\n                   \
    \     ++count;\n                    }\n                    break;\n          \
    \      }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ char delimiter, char delimiter2) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.size(); ++i)\n    {\n        if(string[i] == substring[0])\n    \
    \    {\n            for(int j = i; j < string.size(); ++j)\n            {\n  \
    \              if(string[j] == substring[0])\n                {\n            \
    \        if(j+1 < string.size() && string[j+1] == substring[0])\n            \
    \        {\n                        ++count;\n                    }\n        \
    \            break;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, char delimiter, char delimiter2, char delimiter3)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.size(); ++i)\n    {\n\
    \        if(string[i] == substring[0])\n        {\n            for(int j = i;\
    \ j < string.size(); ++j)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(j+1 < string.size() && string[j+1]\
    \ == substring[0])\n                    {\n                        ++count;\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, char\
    \ delimiter, char delimiter2, char delimiter3, char delimiter\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5194zj25.d(112): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5194zj25.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    \n    foreach(char\
    \ c in string) {\n        if(string.find(substring, start) == string::npos) {\n\
    \            count++;\n            start = end;\n        }\n        end = string.find(substring,\
    \ start);\n    }\n    \n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn0zncra1.d(13): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpn0zncra1.d(14):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmpn0zncra1.d(14): Error: found
    \'':\'' instead of statement\n/tmp/tmpn0zncra1.d(21): Error: Declaration expected,
    not \''return\''\n/tmp/tmpn0zncra1.d(22): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0zncra1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(j))\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zjp85aj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwpfd15zf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    \n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4d1sodgm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string\
    \ |>\n<| c |>\nI guess you meant `substring.length()` instead of `substring.length()+1`\n\
    <|/ c |>\n<| c |>\nYes, I did mean substring.length(). Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\nI did mean substring.length(). Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI did mean substring.length(). Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI did mean substring.length(). Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg6dz36kj.d(19): Error: Declaration expected, not \''<\''\n/tmp/tmpg6dz36kj.d(45):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpg6dz36kj.d(46): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpg6dz36kj.d(47): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpg6dz36kj.d(48): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpg6dz36kj.d(49): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg6dz36kj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, bool case_insensitive) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(case_insensitive ? string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0 : \n            string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n  \
    \  long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, bool case_insensitive) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(case_insensitive ? string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0 : \n            string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, bool case_insensitive, int start2) \n{\n    long count =\
    \ 0;\n    for(int i = start; i < end; i++)\n    {\n        if(\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp11rhcpga.d(95): Error: expression expected, not \''unittest\''\n/tmp/tmp11rhcpga.d(96):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp11rhcpga.d(104): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp11rhcpga.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy45r70fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start) \n{\n\
    \    long count = 0;\n    for(int i = start; i < string.length(); i++) {\n   \
    \     if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++) {\n    \
    \    if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end; i +=\
    \ step) {\n        if(string.substr(i, substring.length()) == substring) {\n \
    \           count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i += step) {\n        if(string.substr(i, substring.length())\
    \ == substring) {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, string pattern, string pattern2)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i += step) {\n   \
    \     if(string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2, string pattern3) \n{\n\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsq1s1n9e.d(94): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsq1s1n9e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3) \n{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n        if(string.substr(i, substring2.length()) == substring2)\n       \
    \ {\n            count++;\n        }\n        if(string.substr(i, substring3.length())\
    \ == substring3)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, string substring2, string substring3, string substring4)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.substr(i, substring.length()) == substring)\n        {\n\
    \            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\n        {\n            count++;\n        }\n        if(string.substr(i,\
    \ substring3.length()) == substring3)\n        {\n            count++;\n     \
    \   }\n        if(string.substr(i, substring4.length()) == substring4)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, string substring2, string substring3, string substring4, string\
    \ substring5) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n        if(string.substr(i, substring2.length())\
    \ == substring2)\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp035x0l37.d(105): Error: found \''unittest\'' instead of statement\n/tmp/tmp035x0l37.d(114):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp035x0l37.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int stride) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, i+=stride)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int stride, int offset) \n{\n    long count =\
    \ 0;\n    for(int i = start; i < end; i+=step, i+=stride, i+=offset)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppejy5_0l.d(95): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmppejy5_0l.d(104): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmppejy5_0l.d(104): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmppejy5_0l.d(104):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppejy5_0l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.substr(i, substring.length()) == substring)\n        {\n\
    \            count++;\n        }\n    }\n    \n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0n3owi_2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start) \n\
    {\n    long count = 0;\n    for(int i = start; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \                \n*/\nlong how_many_times(string string, string substring, long\
    \ start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long step, long step2) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, long start, long\
    \ end, long step, long step2, long step3) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa6au61ga.d(110): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpa6au61ga.d(119): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmpa6au61ga.d(119): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpa6au61ga.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa6au61ga.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.size(); ++i)\n\t{\n\t\tif\
    \ (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size();\
    \ ++j)\n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\
    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (j == substring.size())\n\t\t\
    \t{\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ggsf912.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshde1sqg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string.charAt(i) == substring.charAt(j))\n            {\n            \
    \    count++;\n            }\n        }\n    }\n    \n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsg2nm4r8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif\
    \ (string[i] == substring[0])\n\t\t{\n\t\t\tfor (int j = 1; j < substring.size();\
    \ j++)\n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\
    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (j == substring.size())\n\t\t\
    \t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7y5zkaa7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n            count++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ int step2) \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step,\
    \ i+=step2)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2, int step3) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i+=step, i+=step2, i+=step3)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwwqf3v8e.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwwqf3v8e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end, int step, string pattern, string pattern2) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpet__e3o6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb93r628.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i,\
    \ substring.length()) == substring)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnd1gftu4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    \n    foreach(char c in string) {\n        if(string.find(substring)\
    \ != string::npos) {\n            count++;\n        }\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n                \n*/\nlong how_many_times(string\
    \ string, string substring, long start) \n{\n    long count = 0;\n    \n    foreach(char\
    \ c in string) {\n        if(string.find(substring, start) != string::npos) {\n\
    \            count++;\n        }\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end) \n{\n    long count = 0;\n    \n   \
    \ foreach(char c in string) {\n        if(string.find(substring, start, end) !=\
    \ string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long offset) \n{\n    long count = 0;\n\
    \    \n    foreach(char c in string) {\n        if(string.find(substring, start,\
    \ end, offset) != string::npos) {\n            count++;\n        }\n    }\n  \
    \  \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end, long offset,\
    \ long startOffset) \n{\n    long count = 0;\n    \n    foreach(char c in string)\
    \ {\n        if(string.find(substring, start, end, offset, startOffset) != string::npos)\
    \ {\n            count++;\n        }\n    }\n    \n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, long start, long end, long offset, long startOffset, long\
    \ endOffset) \n{\n    long count = 0;\n    \n    foreach(char c in string) {\n\
    \        if(string.find(substring, start, end, offset, startOffset, endOffset)\
    \ != string::npos) {\n            count++;\n        }\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmvu4t2pw.d(11): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmvu4t2pw.d(12):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmpmvu4t2pw.d(12): Error: found
    \'':\'' instead of statement\n/tmp/tmpmvu4t2pw.d(17): Error: Declaration expected,
    not \''return\''\n/tmp/tmpmvu4t2pw.d(18): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmvu4t2pw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start) \n{\n\tlong count\
    \ = 0;\n\tfor (int i = start; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n\t\
    long count = 0;\n\tfor (int i = start; i < end; i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\t\tif\
    \ (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step, string case_sensitive) \n{\n\tlong count = 0;\n\tfor (int\
    \ i = start; i < end; i+=step)\n\t{\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length(), case_sensitive) == 0)\n\t\t\tcount++;\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive, int start2) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i+=step)\n\t{\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length(), case_sensitive, start2) == 0)\n\t\t\tcount++;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy_dcygsm.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpy_dcygsm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int start2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step, start2+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int start2, int end2) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i+=step, start2+=step, end2+=step)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2jkd7o0u.d(94): Error: found \''unittest\'' instead of statement\n/tmp/tmp2jkd7o0u.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp2jkd7o0u.d(103):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2jkd7o0u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n             \
    \   \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n                \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i += step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i += step, i += step2)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n                \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, int step2, int step3) \n{\n    long count = 0;\n\
    \    for(int i = start; i < end; i += step, i += step2, i += step3)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvz4xx69o.d(96): Error: found \''unittest\'' instead of statement\n/tmp/tmpvz4xx69o.d(105):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvz4xx69o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n    \
    \    if(string[i] == substring[0])\n        {\n            for(int j = i; j <\
    \ string.size(); j++)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(string[j + 1] == substring[1])\n  \
    \                  {\n                        count += 1;\n                  \
    \  }\n                    else\n                    {\n                      \
    \  break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, char delimiter) \n{\n   \
    \ long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n       \
    \ if(string[i] == substring[0])\n        {\n            for(int j = i; j < string.size();\
    \ j++)\n            {\n                if(string[j] == substring[0])\n       \
    \         {\n                    if(string[j + 1] == substring[1])\n         \
    \           {\n                        count += 1;\n                    }\n  \
    \                  else\n                    {\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n                \n*/\nlong\
    \ how_many_times(string string, string substring, char delimiter, char delimiter2)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n    {\n\
    \        if(string[i] == substring[0])\n        {\n            for(int j = i;\
    \ j < string.size(); j++)\n            {\n                if(string[j] == substring[0])\n\
    \                {\n                    if(string[j + 1] == substring[1])\n  \
    \                  {\n                        count += 1;\n                  \
    \  }\n                    else\n                    {\n                      \
    \  break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n                \n*/\n\
    long how_many_times(string string, string substring, char delimiter, char delimiter2,\
    \ char delimiter3) \n{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ i++)\n    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = i; j < string.size(); j++)\n            {\n                if(string[j]\
    \ == substring[0])\n                {\n                    if(string[j + 1] ==\
    \ substring[1])\n                    {\n                        count += 1;\n\
    \                    }\n                    else\n                    {\n    \
    \                    break;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring, char\
    \ delimiter, \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbrlnfzbn.d(124): Error: basic type expected, not unittest\n/tmp/tmpbrlnfzbn.d(124):
    Error: found \''unittest\'' when expecting \'')\''\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbrlnfzbn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013975
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \             \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy45r70fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660013974
