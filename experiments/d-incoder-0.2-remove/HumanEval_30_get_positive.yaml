name: HumanEval_30_get_positive
language: d
prompt: "import std.math;\n/*\nReturn only positive numbers in the list.\n       \
  \     \n*/\nlong[] get_positive(long[] l) \n"
tests: "unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
  \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L,\
  \ 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
  \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
completions: ["{\n\tlong[] r = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[i] = l[i];\n\t}\n\treturn r;\n}", "{\n\
    \tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\
    {\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n\t\
    long[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n\
    }", "{\n\tlong[] r = {0};\n\tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i]\
    \ > 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0\
    \ ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are even numbers.\n   \
    \         \n*/\nlong[] get_even(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 2 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[] l)\
    \ \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 2 != 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn ", "{\n\tlong[] r = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn r;\n}\n\
    /*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t\tr[i] = l[i] < 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only zeros in\
    \ the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] == 0\
    \ ? 0 : l[i];\n\treturn r;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[]\
    \ r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i]\
    \ % n == 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers in the list that\
    \ are not divisible by n.\n            \n*/\nlong[] get_not_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] < n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] > n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] <= n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than or equal to n.\n            \n*/\nlong[] get_greater_than_or_equal_",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}", "{\n    long[] res = new long[l.length];\n    for(int i = 0; i\
    \ < l.length; i++) \n    {\n        if(l[i] > 0) \n        {\n            res[i]\
    \ = l[i];\n        }\n    }\n    return res;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] < 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n \
    \   long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] == 0) \n        {\n            res[i] = l[i];\n      \
    \  }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are\
    \ not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n     \
    \   if(l[i] != 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not negative.\n\
    \            \n*/\nlong[] get_not_negative(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i]\
    \ < 0) \n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not positive.\n            \n\
    */\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not even.\n            \n*/\nlong[] get_not_even(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] % 2 == 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not odd.\n            \n*/\nlong[] get_not_odd(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ > 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}",
  "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\t\
    long[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n\
    \            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only ones in the list.\n            \n*/\nlong[] get_one(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % n == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len) \n{\n\tlong[] res = new\
    \ long[len];\n\tfor (int i = 0; i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ?\
    \ 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] n, int\
    \ len, int offset) \n{\n\tlong[] res = new long[len];\n\tfor (int i = offset;\
    \ i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len, int offset, int step) ",
  "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tresult[i] = std.math.max(l[i], 0);\n\treturn result;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] =\
    \ l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 5 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] ", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only ones in the list.\n            \n*/\nlong[] get_one(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] % n == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are in the range [a, b].\n \
    \           \n*/\nlong[] get_divisible_by_range(long[] l, long a, long b, long\
    \ n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] % n == 0 && (l[i] >= a && l[i] <= b) ? 1 : 0;\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by n and are in the\
    \ range [a, b] and are in the range [c, d].\n            \n*/\nlong[] get_divisible_by_range_2(long[]\
    \ l, long a, long b, long c, long d, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % n == 0 && (l[i] >= a\
    \ && l[i] <= b) && (l[i] >= c && l[i] <= d) ? 1 : 0;\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by n and are in the range [a, b]\
    \ and are in the range [c, d] and are in the range [e, f].\n            \n*/\n\
    long[] ", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}",
  "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\t\
    return result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are not negative.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] =\
    \ l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not positive.\n            \n*/\nlong[] get_not_positive(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not even.\n       \
    \     \n*/\nlong[] get_not_even(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t{\n\t\t\
    \tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n\
    \            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by n.\n    \
    \        \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % n\
    \ == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by n and are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are greater than n.\n      \
    \      \n*/\nlong[] get_greater_than(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % n\
    \ != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by n and are less than or equal to n.\n            \n*/\nlong[]\
    \ get_less_than_or_equal_to(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by n and\
    \ are greater than or equal to n.\n            \n*/\nlong[] get_greater_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn res;", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return result;\n}",
  "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\
    \tresult[i] = std.math.getPositive(l[i]);\n\treturn result;\n}\n/*\nReturn only\
    \ negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tresult[i] = std.math.getNegative(l[i]);\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\
    \t\tresult[i] = std.math.getZero(l[i]);\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are greater than or equal to zero.\n            \n\
    */\nlong[] get_greater_or_equal(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getGreaterOrEqual(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than or\
    \ equal to zero.\n            \n*/\nlong[] get_less_or_equal(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\t\
    result[i] = std.math.getLessOrEqual(l[i]);\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are greater than zero.\n            \n*/\nlong[] get_greater(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tresult[i] = std.math.getGreater(l[i]);\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are less than zero.\n            \n*/\nlong[]\
    \ get_less(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getLess(l[i]);\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are equal to zero.\n            \n\
    */\nlong[] get_equal(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getEqual(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than or\
    \ equal to zero.\n            \n*/\nlong[] get_less_or_equal_zero(long[] l) \n\
    {\n\tlong[] result = ", "{\n\tlong[] r = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn r;\n}", "{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t\tresult[i] = l[i];\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by given number.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are less than given number.\n\
    \            \n*/\nlong[] get_less_than(long[] l, long d) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ < d) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal given number.\n            \n*/\nlong[]\
    \ get_less_than_or_equal_to(long[] l, long d) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] <= d) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are greater than given number.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\t}\n\treturn\
    \ r;\n}", "{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn r;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] >\
    \ 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 11.\n            \n*/\n\
    long[] get_divisible_by_11(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 13 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 17.\n            \n*/\n\
    long[] get_divisible_by_17(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \t", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n\
    \            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not zero.\n          \
    \  \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not negative.\n      \
    \      \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not positive.\n      \
    \      \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not in the list.\n   \
    \         \n*/\nlong[] get_not_in(long[] l, long[] l2) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] != l2\
    \ ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list.\n            \n*/\nlong[] get_not_in_2(long[] l, long[] l2)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != l2 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not in the list.\n            \n*/\nlong[] get_not_in_3(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i]\
    \ > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n     \
    \   if(l[i] > 0) \n        {\n            result[i] = l[i];\n        }\n    }\n\
    \    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] =\
    \ l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n        {\n      \
    \      result[i] = l[i];\n        }\n    }\n    return result;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0\
    \ ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n\
    }", "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] > 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n    long[] res =\
    \ new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n       \
    \ if(l[i] < 0) \n        {\n            res[i] = l[i];\n        }\n    }\n   \
    \ return res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++) \n    {\n        if(l[i] == 0) \n        {\n       \
    \     res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] != 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n       \
    \ }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not\
    \ positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] % 2 == 0) \n \
    \       {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t\
    }\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n      \
    \      \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not positive.\n            \n\
    */\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not even.\n            \n*/\nlong[] get_not_even(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not ", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0\
    \ ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0\
    \ ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than the number in the second argument.\n        \
    \    \n*/\nlong[] get_less_than(long[] l, long r) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < r ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are greater than the number\
    \ in the second argument.\n            \n*/\nlong[] get_greater_than(long[] l,\
    \ long r) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] > r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to the number in the second argument.\n\
    \            \n*/\nlong[] get_less_than_or_equal_to(long[] l, long r) \n{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = l[i] <= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are greater than or equal to the number in the second argument.\n     \
    \       \n*/\nlong[] get_greater_than_or_equal_to(long[] l, long r) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] >= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are equal to the ", "{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % n == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] < n) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by n\
    \ and are greater than n.\n            \n*/\nlong[] get_greater_than(long[] l,\
    \ long n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] > n) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by n\
    \ and are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] <= n) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by n\
    \ and are greater than or equal to n.\n", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 3 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 5 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 7 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 11 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 13 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 17.\n           \
    \ \n*/\nlong[] get_divisible_by_17(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zeros or negative.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0 && l[i] < 0) \n\t\t\
    {\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2\
    \ == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are odd.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t\
    }\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new ", "{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\t}\n\treturn r;\n}", "{\n\
    \tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }", "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n  \
    \  return result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\
    \tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n\
    \            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only ones in the list.\n            \n*/\nlong[] get_one(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos\
    \ in the list.\n            \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 2 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only threes in the list.\n     \
    \       \n*/\nlong[] get_three(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only fours in the list.\n            \n*/\nlong[] get_four(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives\
    \ in the list.\n            \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 5 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sixes in the list.\n      \
    \      \n*/\nlong[] get_six(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sevens in the list.\n            \n*/\nlong[] get_seven(long[]\
    \ l) \n{\n\tlong[] res = new long[", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\n\
    long[] get_negative(long[] l) \n{\n    long[] result = new long[l.length];\n \
    \   for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] < 0)\n         \
    \   result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only zeros in\
    \ the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] == 0)\n            result[i] = l[i];\n    }\n    return result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 3.\n            \n*/\n\
    long[] get_divisible_by_3(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 3 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 5 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 11 == 0)\n  \
    \          result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 13 == 0)\n            result[i] = l[i];\n   \
    \ }\n    return result;\n}\n/*\nReturn only ", "{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i =\
    \ 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t\
    }\n\treturn r;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\
    \t{\n\t\tif (l[i] == 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not the given value.\n            \n*/\nlong[]\
    \ get_not_equal_to(long[] l, long value) \n{\n\tlong[] r = {0};\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] != value)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are not the given\
    \ value.\n            \n*/\nlong[] get_not_equal_to(long[] l, double value) \n\
    {\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ != value)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only number",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\n\
    long[] get_negative(long[] l) \n{\n    long[] result = new long[l.length];\n \
    \   for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] < 0)\n         \
    \   result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only zeros in\
    \ the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] == 0)\n            result[i] = l[i];\n    }\n    return result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 3.\n            \n*/\n\
    long[] get_divisible_by_3(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 3 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 5 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 11 == 0)\n  \
    \          result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 13 == 0)\n            result[i] = l[i];\n   \
    \ }\n    return result;\n}\n/*\nReturn only ", "{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] =\
    \ l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l,\
    \ long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % n == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by n.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long n) \n{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % n != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are less than n.\n    \
    \        \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] <\
    \ n) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are greater than n.\n            \n*/\nlong[]\
    \ get_greater_than(long[] l, long n) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > n) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in\
    \ the list that are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n   \
    \ return res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    long[] res = new long[l.length];\n \
    \   for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 2 ==\
    \ 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\
    \t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by 3.\n            \n*/\nlong[]\
    \ get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n", "{\n    long[] res = new long[l.length];\n   \
    \ for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n   \
    \         \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] != 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not even.\n            \n*/\n\
    long[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 2 == 0)\n        {\n   \
    \         res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn only\
    \ numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.", "{\n\
    \tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\
    {\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\t\
    return result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ not zero, negative or positive.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_negative_and_not_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n    long[] res =\
    \ new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] == 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n  \
    \      if(l[i] != 0)\n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not negative.\n\
    \            \n*/\nlong[] get_not_negative(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not positive.\n            \n\
    */\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not the given value.\n            \n*/\nlong[]\
    \ get_not_equal_to(long[] l, long value) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] != value)\n   \
    \     {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\n\
    Return only numbers in the list that are not the given value.\n            \n\
    */\nlong[] get_not_equal_to(long[] l, double value) \n{\n    long[] res = new\
    \ long[l.length", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i <\
    \ l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n \
    \   long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\n\
    long[] get_negative(long[] l) \n{\n    long[] result = new long[l.length];\n \
    \   for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] < 0)\n         \
    \   result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only zeros in\
    \ the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] == 0)\n            result[i] = l[i];\n    }\n    return result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 3.\n            \n*/\n\
    long[] get_divisible_by_3(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 3 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 5 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 11 == 0)\n  \
    \          result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 13 == 0)\n            result[i] = l[i];\n   \
    \ }\n", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}",
  "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] result = new\
    \ long[l.length];\n    int i = 0;\n    for(; i < l.length; ++i)\n    {\n     \
    \   if(l[i] > 0)\n        {\n            result[i] = l[i];\n        }\n    }\n\
    \    return result;\n}\n/*\nReturn only negative numbers in the list.\n      \
    \      \n*/\nlong[] get_negative(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] < 0)\n \
    \       {\n            result[i] = l[i];\n        }\n    }\n    return result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 3 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 7 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 11 == 0)\n        {\n           \
    \ result[i] = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 13.\n            \n*/\nlong", "{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not negative.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not odd.\n            \n*/\nlong[] get_not_odd(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 2 != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn ", "{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n     \
    \   if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n \
    \   return res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\t\
    return res;\n}", "{\n    long[] result = new long[l.length];\n    for(int i =\
    \ 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n        {\n          \
    \  result[i] = l[i];\n        }\n    }\n    return result;\n}", "{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\
    \t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\t\
    long[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif (l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list.\n            \n*/\nlong[] get_number(long[] l) \n{\n\t\
    long[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif (l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list.\n            \n*/\nlong[] get_number_positive(long[] l)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list.\n            \n*/\nlong[] get_number_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list.\n            \n*/\nlong[] get_number_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list.\n            \n*/\nlong[] get_number_number(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list.\n            \n*/\nlong[] get_number_number_positive(long[]\
    \ l) \n{\n\tlong[] ", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n            result[i]\
    \ = l[i];\n    }\n    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n", "{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos in the list.\n       \
    \     \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 2 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only threes in the list.\n            \n*/\nlong[] get_three(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fours\
    \ in the list.\n            \n*/\nlong[] get_four(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives in the list.\n      \
    \      \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 5 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sixes in the list.\n            \n*/\nlong[] get_six(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sevens\
    \ in the list.\n            \n*/\nlong[] get_seven(long[] l) \n", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}",
  "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++)\
    \ \n    {\n        if(l[i] > 0) \n        {\n            res[i] = l[i];\n    \
    \    }\n    }\n    return res;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_zero_and_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0 && l[i] != 0)\n\t\
    \t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_zero_and_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (", "{\n\tlong[] res = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}",
  "{\n\tlong[] r = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\t}\n\treturn r;\n}", "{\n\tlong[]\
    \ r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t\tif (l[i] > 0)\n\t\t\tr[r.length]\
    \ = l[i];\n\treturn r;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t\
    }\n\treturn result;\n}", "{\n    long[] result = new long[l.length];\n    int\
    \ i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] > 0)\n      \
    \      result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    int i = 0;\n    for (; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n    long[] result = new long[l.length];\n    int\
    \ i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] == 0)\n     \
    \       result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for (;\
    \ i < l.length; ++i)\n    {\n        if (l[i] != 0)\n            result[i] = l[i];\n\
    \    }\n    return result;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n\
    \    {\n        if (l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] result = new\
    \ long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n    {\n    \
    \    if (l[i] > 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are not in the list.\n           \
    \ \n*/\nlong[] get_not_in(long[] l, long[] l2) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are not in the list 2.\n            \n*/\nlong[] get_not_in_2(long[]\
    \ l, long[] l2) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n\
    \    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n          \
    \  result[i] = l[i];\n    }", "{\n\tlong[] result = new long[l.length];\n\tfor\
    \ (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] > 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n   \
    \ long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n  \
    \  {\n        if(l[i] > 0)\n            res[i] = l[i];\n    }\n    return res;\n\
    }", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\
    \t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] < 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by(long[] l, long n) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % n == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by n and are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t{\n\t\tif (l[i] % n != 0 && l[i] < n)\n\t\t\tresult[i] = l[i];\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n and are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t{\n\t\tif (l[i] % n != 0 && l[i] > n)\n\t\t\tresult[i] = l[i];\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n and are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t{\n\t\tif (l[i] % n != 0 && l[i] <= n)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are greater than or equal to n.\n            \n*/\nlong[]\
    \ get_greater_", "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i\
    \ < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn\
    \ result;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i\
    \ < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the\
    \ list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] ==\
    \ 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by given number.\n            \n\
    */\nlong[] get_divisible_by(long[] l, long d) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not divisible by given number.\n            \n*/\nlong[]\
    \ get_not_divisible_by(long[] l, long d) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than given number.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] < d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\
    \t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are greater\
    \ than given number.\n            \n*/\nlong[] get_greater_than(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than or\
    \ equal to given number.\n            \n*/\nlong[] get_less_than_or_equal_to(long[] ",
  "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\
    \tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n\
    \            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only ones in the list.\n            \n*/\nlong[] get_one(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_2(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long d) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_4(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < ", "{\n\tlong[] res = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}",
  "{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n  \
    \  return result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] > 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\
    \t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 3.\n \
    \           \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] %\
    \ 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 5.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] ", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\t\
    return res;\n}\n/*\nReturn only negative numbers in the list.\n            \n\
    */\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 7.\n            \n\
    */\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 13.\n            \n*/\n\
    long[] get_divisible_by_13(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l", "{\n\tlong[] result =\
    \ new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\
    \tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\t}\n\treturn r;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ > 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}", "{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = std.math.rem(l[i],\
    \ 1);\n\treturn res;\n}", "{\n\tlong[] r = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\
    \t}\n\t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the list.\n    \
    \        \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tr[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only zeros in the list.\n  \
    \          \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tr[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 3 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn only numbers in the list that are divisible by 11.\n     \
    \       \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 11 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] ",
  "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] > 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only zeros in\
    \ the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 0\
    \ ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] != 0\
    \ ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] < 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that\
    \ are not positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] > 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 != 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not divisible by 2.\n            \n*/\nlong[] get_not_divisible_by_2(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % 2 != 0 ? 1 : 0;\n\treturn ", "{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n        if(l[i] > 0)\n            res[i] = l[i];\n    return res;\n}",
  "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\t\
    long[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\t\
    result[i] = l[i] > 0 ? l[i] : 0;\n\treturn result;\n}", "{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }", "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] > 0)\n            result[i] = l[i];\n    }\n  \
    \  return result;\n}", "{\n    long[] res = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n            res[i] = l[i];\n\
    \    }\n    return res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\t\
    return result;\n}", "{\n    long[] result = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n            result[i]\
    \ = l[i];\n    }\n    return result;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i] = l[i];\n\
    \t}\n\treturn result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n\
    }", "{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif\
    \ (l[i] > 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n\
    /*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] < 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n\
    /*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l)\
    \ \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by 3.\n            \n*/\nlong[]\
    \ get_divisible_by_3(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 3 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t\
    }\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] r\
    \ = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\
    \t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] % 7 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tr[r.length]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l)\
    \ \n{\n\tlong", "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i\
    \ < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\
    \t}\n\t}\n\treturn result;\n}", "{\n    long[] res = new long[l.length];\n   \
    \ for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = std.math.max(l[i], 0);\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\t}\n\treturn\
    \ r;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }", "{\n\tlong[] r = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\t}\n\treturn r;\n}", "{\n\t\
    long[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] > 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n  \
    \  return result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n            result[i]\
    \ = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 5.\n \
    \           \n*/\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result =\
    \ new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ % 5 == 0)\n            result[i] = l[i];\n    }\n    return result;\n}\n/*\n\
    Return only numbers in the list that are divisible by 7.\n            \n*/\nlong[]\
    \ get_divisible_by_7(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 7 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 11 == 0)\n            result[i] = l[i];\n   \
    \ }\n    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i]\
    \ = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n        \
    \    res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\t\
    return result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are not negative.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] =\
    \ l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not positive.\n            \n*/\nlong[] get_not_positive(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not odd.\n        \
    \    \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t{\n\t\t\
    \tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not even.\n            \n*/\nlong[] get_even(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) ",
  "{\n\tlong[] r = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    r[i] = std.math.min(l[i], 0L);\n\treturn r;\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] % d == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_array(long[] l, long[] d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] d, long[] m) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by given number.\n\
    \            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d, long[] m,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n", "{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] > 0)\n            res[i] = l[i];\n    }\n    return res;\n}", "{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not negative.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not odd.\n\
    \            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2\
    \ == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only number",
  "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by(long[] l, long d) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by_2(long[] l, long d)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_4(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_di", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 15.\n            \n*/\n\
    long[] get_divisible_by_15(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 15 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 17.\n            \n*/\nlong[] get_divisible_by_17(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\t", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}", "{\n    long[] res = new long[l.length];\n  \
    \  for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}", "{\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tresult[i]\
    \ = std.math.get_positive(l[i]);\n\treturn result;\n}", "{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0\
    \ ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len) \n{\n\tlong[] res = new long[len.length];\n\tfor(int i = 0; i\
    \ < len.length; i++)\n\t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not zero in the list.\n            \n\
    */\nlong[] get_not_zero(long[] l, long[] len, int len2) \n{\n\tlong[] res = new\
    \ long[len2];\n\tfor(int i = 0; i < len2; i++)\n\t\tres[i] = l[i] != 0 ? l[i]\
    \ : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero\
    \ in the list.\n            \n*/\nlong[] get_not_zero(long[] l, long[] len, long[]\
    \ len2) \n{\n\tlong[] res = new long[len2];\n\tfor(int i = 0; i < len2; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len, long[] len2, int len3) ", "{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\t}\n\t\
    return res;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] = l[i];\n\t}\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are not zero in the list.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list in the list.\n            \n*/\nlong[] get_not_in(long[] l,\
    \ long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not in the list\
    \ in the list.\n            \n*/\nlong[] get_not_in_long(long[] l, long[] l2)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i] = l[i];\n\t}\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are not in the list in\
    \ the list.\n            \n*/\nlong[] get_not_in_double(long[] l, long[] l2) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i] = l[i];\n\t}\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not in the list in the\
    \ list.\n            \n*/\nlong[] get_not_in_string(long[] l, long[] l2) \n{\n\
    \tlong[] res = new long", "{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only negative numbers in the list.\n            \n\
    */\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are even.\n  \
    \          \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif(l[i] % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by 5.\n            \n*/\nlong[]\
    \ get_divisible_by_5(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 7 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(", "{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i\
    \ < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn\
    \ res;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
