language: d
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.lenght-1)\
    \ {\n        foreach(j : 0..lst[i].lenght-1) {\n            if(lst[i][j] == x)\
    \ {\n                res = append(res, Tuple!(i, j));\n            }\n       \
    \ }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphpmmcajo.d(20): Error: no identifier for declarator i\n/tmp/tmphpmmcajo.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmphpmmcajo.d(21): Error: no
    identifier for declarator j\n/tmp/tmphpmmcajo.d(21): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphpmmcajo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy2ibjtn7.d(21): Error: no identifier for declarator row\n/tmp/tmpy2ibjtn7.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpy2ibjtn7.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpy2ibjtn7.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpy2ibjtn7.d(23): Error: no identifier
    for declarator column\n/tmp/tmpy2ibjtn7.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpy2ibjtn7.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpy2ibjtn7.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpy2ibjtn7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    \n    foreach(row: lst, row: row) \n\
    \    {\n        foreach(col: row, col: col) \n        {\n            if(col ==\
    \ x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, row),\
    \ Tuple!(1, row)];\n                break;\n            }\n        }\n    }\n\
    \    \n    sort(res);\n    sort(res[1], res[1]);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeva1o4fv.d(21): Error: no identifier for declarator row\n/tmp/tmpeva1o4fv.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpeva1o4fv.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpeva1o4fv.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpeva1o4fv.d(23): Error: no identifier
    for declarator col\n/tmp/tmpeva1o4fv.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpeva1o4fv.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpeva1o4fv.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpeva1o4fv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n \
    \   {\n        foreach(col: row, col: col) \n        {\n            if(col ==\
    \ x) \n            {\n                result = Tuple!(long, long)[](row, col);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc3fachr8.d(20): Error: no identifier for declarator row\n/tmp/tmpc3fachr8.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpc3fachr8.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpc3fachr8.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpc3fachr8.d(22): Error: no identifier
    for declarator col\n/tmp/tmpc3fachr8.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpc3fachr8.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpc3fachr8.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc3fachr8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[](res,\
    \ n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp59vl0swt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n\
    \        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1]\
    \ == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res\
    \ = Tuple!(long, long)[(0, 0)];\n    for(long i = 0; i < lst.length; i++){\n \
    \       if(lst[i][0] == x){\n            res[rows] = Tuple!(long, long)[lst[i][1],\
    \ lst[i][0]];\n            rows++;\n        }\n        if(lst[i][1] == x){\n \
    \           res[rows] = Tuple!(long, long)[lst[i][0], lst[i][1]];\n          \
    \  cols--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds_g4fc8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, m, n;\n\
    \    long[][] coords = new long[n][2];\n    \n    for(i = 0; i < n; i++)\n   \
    \ {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                coords[i][0] = 0;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == 0)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == i)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn1eag7p9.d(153): Error: found \''unittest\'' instead of statement\n/tmp/tmpn1eag7p9.d(164):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn1eag7p9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(res);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk24zhb3n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i\
    \ : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                result.push(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b)\
    \ -> a.first < b.first ? -1 : a.first > b.first ? 1 : 0);\n    result.sort(function(a,\
    \ b) -> a.second > b.second ? -1 : a.second < b.second ? 1 : 0);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6oizgreh.d(21): Error: no identifier for declarator i\n/tmp/tmp6oizgreh.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp6oizgreh.d(23): Error: no
    identifier for declarator j\n/tmp/tmp6oizgreh.d(23): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmp6oizgreh.d(32): Error: missing { ... } for function
    literal\n/tmp/tmp6oizgreh.d(32): Error: expression expected, not \''>\''\n/tmp/tmp6oizgreh.d(32):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmp6oizgreh.d(33): Error: missing
    { ... } for function literal\n/tmp/tmp6oizgreh.d(33): Error: expression expected,
    not \''>\''\n/tmp/tmp6oizgreh.d(33): Error: found \''a\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6oizgreh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzvyv0d6k.d(98): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvyv0d6k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1] + 1);\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] <\
    \ x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n      \
    \      result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1]\
    \ > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i]\
    \ = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i =\
    \ 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n      \
    \      result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1]\
    \ < lst[i][0])\n        {\n            result[i] = new Tuple\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7iq125q7.d(114): Error: found \''unittest\'' when expecting
    \'';\'' following statement\n/tmp/tmp7iq125q7.d(125): Error: found \''EOF\'' when
    expecting \''}\'' following compound statement\n/tmp/tmp7iq125q7.d(125): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp7iq125q7.d(125):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7iq125q7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm43fvxfj.d(22): Error: no identifier for declarator long\n/tmp/tmpm43fvxfj.d(22):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpm43fvxfj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long row = 0;\n    long col = 0;\n    \n    for(long i\
    \ = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                result[row][col]\
    \ = i;\n                result[row][col + 1] = j;\n                row++;\n  \
    \              col++;\n            }\n        }\n    }\n    \n    for(long i =\
    \ 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n    \
    \        if(lst[i][j] > x)\n            {\n                result[row][col] =\
    \ i;\n                result[row][col + 1] = j;\n                row++;\n    \
    \            col++;\n            }\n        }\n    }\n    \n    for(long i = 0;\
    \ i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n       \
    \     if(lst[i][j] < x)\n            {\n                result[row][col] = i;\n\
    \                result[row][col + 1] = j;\n                row++;\n         \
    \       col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i <\
    \ n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n           \
    \ if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n \
    \               result[row][col + 1] = j;\n                row++;\n          \
    \      col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i <\
    \ n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n           \
    \ if(lst[i][j] > x)\n            {\n                result[row][col] = i;\n  \
    \              result[row][col + 1] = j;\n                row++;\n           \
    \     col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ < x)\n            {\n                result[row][col] = i;\n               \
    \ result[row][col + 1] = j;\n                row++;\n                col++;\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n\
    \        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                result[row][col] = i;\n                result[row][col\
    \ + 1] = j;\n                row++;\n                col++;\n            }\n \
    \       }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                result[row][col] = i;\n                result[row][col + 1] =\
    \ j;\n                row++;\n                col++;\n            }\n        }\n\
    \    }\n    \n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9_g2cg2r.d(138): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_g2cg2r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(row: lst, i: 0)\n    {\n   \
    \     foreach(col: row, j: 0)\n        {\n            if(col == x)\n         \
    \   {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i\
    \ + 1, j));\n            }\n        }\n    }\n    \n    foreach(row: lst, i: 0)\n\
    \    {\n        foreach(col: row, j: 0)\n        {\n            if(col != x)\n\
    \            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1),\
    \ Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return ans;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwclyz2b3.d(21): Error: no identifier for declarator row\n/tmp/tmpwclyz2b3.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpwclyz2b3.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpwclyz2b3.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpwclyz2b3.d(23): Error: no identifier
    for declarator col\n/tmp/tmpwclyz2b3.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpwclyz2b3.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpwclyz2b3.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpwclyz2b3.d(32):
    Error: no identifier for declarator row\n/tmp/tmpwclyz2b3.d(32): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmpwclyz2b3.d(32): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmpwclyz2b3.d(32): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpwclyz2b3.d(34): Error: no identifier for
    declarator col\n/tmp/tmpwclyz2b3.d(34): Error: found \'':\'' when expecting \'';\''\n/tmp/tmpwclyz2b3.d(34):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmpwclyz2b3.d(34): Error: found
    \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwclyz2b3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n     \
    \   {\n            if(lst[i][j] == x)\n            {\n                return Tuple!(long,\
    \ long)[Tuple!(i-1, j), Tuple!(i, j-1)];\n            }\n        }\n    }\n  \
    \  return Tuple!(long, long)[Tuple!(n, m)];\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hpci8v8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23l8t3di.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i =\
    \ 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n    }\n    \n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n      \
    \  {\n            if(lst[i][j] == x)\n            {\n                result[i]\
    \ = Tuple!(long, long)[i, j];\n                break;\n            }\n       \
    \ }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     result[i] = Tuple!(long, long)[i, j];\n                break;\n        \
    \    }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                result[i] = Tuple!(long, long)[i, j];\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3x6vd6az.d(149): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmp3x6vd6az.d(160): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmp3x6vd6az.d(160): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmp3x6vd6az.d(160):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3x6vd6az.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                ans = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col > x)\n            {\n                ans = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1l_gqlce.d(21): Error: no identifier for declarator lst\n/tmp/tmp1l_gqlce.d(21):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp1l_gqlce.d(23): Error: no
    identifier for declarator row\n/tmp/tmp1l_gqlce.d(23): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp1l_gqlce.d(31): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp1l_gqlce.d(33): Error: no identifier for declarator lst\n/tmp/tmp1l_gqlce.d(33):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp1l_gqlce.d(35): Error: no
    identifier for declarator row\n/tmp/tmp1l_gqlce.d(35): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp1l_gqlce.d(43): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp1l_gqlce.d(47): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp1l_gqlce.d(58):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp1l_gqlce.d(58):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp1l_gqlce.d(58): Error:
    found \''EOF\'' instead of statement\n/tmp/tmp1l_gqlce.d(58): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1l_gqlce.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmwui0sbu.d(20): Error: no identifier for declarator lst\n/tmp/tmpmwui0sbu.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpmwui0sbu.d(22): Error: no
    identifier for declarator row\n/tmp/tmpmwui0sbu.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpmwui0sbu.d(30): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpmwui0sbu.d(33): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpmwui0sbu.d(44):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwui0sbu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75uwbe9u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(i, j);\n             \
    \   break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] >\
    \ x)\n            {\n                res[i] = Tuple!(i, j);\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wjc3gmr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(int j = 0; j < lst[i].length; ++j)\n            {\n             \
    \   row[j] = (lst[i][0], lst[i][1]);\n            }\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0dvbklh2.d(78): Error: expression expected, not \''unittest\''\n/tmp/tmp0dvbklh2.d(79):
    Error: found \''{\'' when expecting \'')\'' following template argument list\n/tmp/tmp0dvbklh2.d(80):
    Error: found \''alias\'' when expecting \'';\'' following statement\n/tmp/tmp0dvbklh2.d(89):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp0dvbklh2.d(89):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dvbklh2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = lst.length;\n    long cols = lst[0].length;\n    long[] res =\
    \ new long[rows*cols];\n    for(int i = 0; i < rows; i++)\n    {\n        for(int\
    \ j = 0; j < cols; j++)\n        {\n            if(lst[i][j] == x)\n         \
    \   {\n                res[i*cols + j] = i;\n                res[i*cols + j +\
    \ 1] = j;\n            }\n        }\n    }\n    Arrays.sort(res);\n    return\
    \ Tuple!(long, long)[](res, rows);\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9n3c_jnr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(res,\
    \ (a, b) -> {\n        if(a[0] > b[0])\n            return 1;\n        if(a[0]\
    \ < b[0])\n            return -1;\n        return 0;\n    });\n    \n    Arrays.sort(res,\
    \ (a, b) -> {\n        if(a[1] > b[1])\n            return 1;\n        if(a[1]\
    \ < b[1])\n            return -1;\n        return 0;\n    });\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphylyu_qa.d(34): Error: expression expected, not \''>\''\n/tmp/tmphylyu_qa.d(34):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(35): Error: expression
    expected, not \''if\''\n/tmp/tmphylyu_qa.d(36): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmphylyu_qa.d(36): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmphylyu_qa.d(37): Error: expression expected, not \''if\''\n/tmp/tmphylyu_qa.d(38):
    Error: found \''return\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(38): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(39): Error: expression
    expected, not \''return\''\n/tmp/tmphylyu_qa.d(39): Error: found \''0\'' when
    expecting \'',\''\n/tmp/tmphylyu_qa.d(39): Error: expression expected, not \'';\''\n/tmp/tmphylyu_qa.d(40):
    Error: found \''}\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(42): Error: expression
    expected, not \''>\''\n/tmp/tmphylyu_qa.d(42): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmphylyu_qa.d(43): Error: expression expected, not \''if\''\n/tmp/tmphylyu_qa.d(44):
    Error: found \''return\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(44): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmphylyu_qa.d(45): Error: expression
    expected, not \''if\''\n/tmp/tmphylyu_qa.d(46): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmphylyu_qa.d(46): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmphylyu_qa.d(47): Error: expression expected, not \''return\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphylyu_qa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row)\
    \ \n    {\n        foreach(column: row, column: column) \n        {\n        \
    \    if(column == x) \n            {\n                result = Tuple!(long, long)[](row,\
    \ column);\n                break;\n            }\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg6q_9hmv.d(21): Error: no identifier for declarator row\n/tmp/tmpg6q_9hmv.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpg6q_9hmv.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpg6q_9hmv.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpg6q_9hmv.d(23): Error: no identifier
    for declarator column\n/tmp/tmpg6q_9hmv.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpg6q_9hmv.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpg6q_9hmv.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg6q_9hmv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long,\
    \ long)[] res = null;\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j\
    \ = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n            {\n\
    \                res = new Tuple!(long, long)[](i, j);\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwvzgdavi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    \n  \
    \  for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n  \
    \      {\n            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    Arrays.sort(ret);\n    \n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqwes4gx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjj89182e.d(20): Error: no identifier for declarator row\n/tmp/tmpjj89182e.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpjj89182e.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpjj89182e.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpjj89182e.d(22): Error: no identifier
    for declarator col\n/tmp/tmpjj89182e.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpjj89182e.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpjj89182e.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpjj89182e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n      \
    \  if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpifttznrd.d(20): Error: no identifier for declarator lst\n/tmp/tmpifttznrd.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpifttznrd.d(22): Error: no
    identifier for declarator row\n/tmp/tmpifttznrd.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpifttznrd.d(30): Error: found \''if\'' when expecting
    \'')\''\n/tmp/tmpifttznrd.d(31): Error: found \''break\'' when expecting \'';\''
    following statement\n/tmp/tmpifttznrd.d(33): Error: found \''return\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifttznrd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(long j = 0; j < lst[i].length; ++j)\n            {\n            \
    \    row[j] = (i, lst[i][j]);\n            }\n            sort(row, true);\n \
    \           sort(row, false);\n            for(long j = 0; j < row.length; ++j)\n\
    \            {\n                res[res.length] = row[j];\n            }\n   \
    \     }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2djk8bo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; i++){\n        if(lst[i][1] < x){\n            for(int j = i;\
    \ j < lst.length; j++){\n                if(lst[j][1] > x){\n                \
    \    swap(lst[i], lst[j]);\n                }\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][1] < x){\n\
    \            for(int j = i; j < lst.length; j++){\n                if(lst[j][1]\
    \ > x){\n                    swap(lst[i], lst[j]);\n                }\n      \
    \      }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n \
    \       for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaxpd3ip4.d(111): Error: found \''unittest\'' instead of statement\n/tmp/tmpaxpd3ip4.d(122):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxpd3ip4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp = i;\n                i = j;\n                j = temp;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                long temp = i;\n                i = j;\n              \
    \  j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n;\
    \ i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                long temp =\
    \ i;\n                i = j;\n                j = temp;\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                long temp = i;\n                i = j;\n                j = temp;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] ==\
    \ 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                long temp =\
    \ i;\n                i = j;\n                j = temp;\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                long temp = i;\n                i = j;\n                j = temp;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] ==\
    \ 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprs389xdf.d(154): Error: found \''unittest\'' instead of statement\n/tmp/tmprs389xdf.d(165):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprs389xdf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.len)\
    \ \n    {\n        foreach(j : 0..lst[i].len) \n        {\n            if(lst[i][j]\
    \ == x) \n            {\n                res = append(res, Tuple!(i, j));\n  \
    \          }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6w36jxt1.d(20): Error: no identifier for declarator i\n/tmp/tmp6w36jxt1.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp6w36jxt1.d(22): Error: no
    identifier for declarator j\n/tmp/tmp6w36jxt1.d(22): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6w36jxt1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        if(lst[i][0] == x)\n        {\n            res = lst[i];\n          \
    \  break;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmarednmv.d(20): Error: no identifier for declarator i\n/tmp/tmpmarednmv.d(20):
    Error: found \'':\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmarednmv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n            }\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_abp2fis.d(20): Error: no identifier for declarator lst\n/tmp/tmp_abp2fis.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp_abp2fis.d(22): Error: no
    identifier for declarator row\n/tmp/tmp_abp2fis.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp_abp2fis.d(29): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp_abp2fis.d(32): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp_abp2fis.d(43):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_abp2fis.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: 0)\
    \ \n    {\n        foreach(column: row, column_index: 0) \n        {\n       \
    \     if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!((row_index, column_index)), Tuple!((row_index, column_index + 1))];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0rvg15u4.d(20): Error: no identifier for declarator row\n/tmp/tmp0rvg15u4.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp0rvg15u4.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp0rvg15u4.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmp0rvg15u4.d(22): Error: no identifier
    for declarator column\n/tmp/tmp0rvg15u4.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp0rvg15u4.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp0rvg15u4.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp0rvg15u4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n   \
    \         if(lst[i][j] == x)\n            {\n                res[i] = j;\n   \
    \             break;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) => b - a);\n    \n    Tuple!(long, long)[] res =\
    \ new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        res[i] = new Tuple!(long, long)(i, res[i]);\n    }\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp59kieh6l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j;\n    \n    for(i = 0; i < n; i++)\n    {\n \
    \       for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n  \
    \          {\n                result[i][j] = 1;\n                break;\n    \
    \        }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n      \
    \  for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n       \
    \     {\n                for(k = j; k < m; k++)\n                {\n         \
    \           lst[i][k] = lst[i][k - 1];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k + 1];\n                }\n                \n        \
    \        for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n\
    \                }\n                \n                for(k = j; k < m; k++)\n\
    \                {\n                    lst[i][k] = lst[i][k];\n             \
    \   }\n                \n                for(k = j; k < m; k++)\n            \
    \    {\n                    lst[i][k] = lst[i][k];\n                }\n      \
    \          \n                for(k = j; k < m; k++)\n                {\n     \
    \               lst[i][k] = lst[i][k];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k];\n                }\n                \n            \
    \    for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n\
    \                }\n                \n                for(k = j; k < m; k++)\n\
    \                {\n                    lst[i][k] = lst[i][k];\n             \
    \   }\n                \n                for(k = j; k < m; k++)\n            \
    \    {\n                    lst[i][k] = lst[i][k];\n                }\n      \
    \          \n                for(k = j; k < m; k++)\n                {\n     \
    \               lst[i][k] = lst[i][k];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k];\n                }\n                \n            \
    \    for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpau2akui7.d(118): Error: expression expected, not \''unittest\''\n/tmp/tmpau2akui7.d(119):
    Error: found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmpau2akui7.d(120):
    Error: expression expected, not \''alias\''\n/tmp/tmpau2akui7.d(120): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmpau2akui7.d(120): Error: found
    \''=\'' instead of statement\n/tmp/tmpau2akui7.d(129): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpau2akui7.d(129):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpau2akui7.d(129):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpau2akui7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n  \
    \          if(col == x) \n            {\n                foreach(coord: row, coord:\
    \ coord) \n                {\n                    result.push(Tuple!(coord, row));\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row:\
    \ coord, row: row) \n        {\n            foreach(col: row, col: col) \n   \
    \         {\n                if(col > x) \n                {\n               \
    \     result.push(Tuple!(col, row));\n                }\n            }\n     \
    \   }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n       \
    \ foreach(row: coord, row: row) \n        {\n            foreach(col: row, col:\
    \ col) \n            {\n                if(col < x) \n                {\n    \
    \                result.push(Tuple!(col, row));\n                }\n         \
    \   }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n   \
    \ {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col == x) \n            \
    \    {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col > x) \n             \
    \   {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col < x) \n             \
    \   {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col == x) \n            \
    \    {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0hgc3jh.d(21): Error: no identifier for declarator row\n/tmp/tmpg0hgc3jh.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpg0hgc3jh.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpg0hgc3jh.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpg0hgc3jh.d(23): Error: no identifier
    for declarator col\n/tmp/tmpg0hgc3jh.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpg0hgc3jh.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpg0hgc3jh.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpg0hgc3jh.d(27):
    Error: no identifier for declarator coord\n/tmp/tmpg0hgc3jh.d(27): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmpg0hgc3jh.d(27): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmpg0hgc3jh.d(27): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpg0hgc3jh.d(36): Error: no identifier for
    declarator coord\n/tmp/tmpg0hgc3jh.d(36): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpg0hgc3jh.d(36): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpg0hgc3jh.d(36):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpg0hgc3jh.d(38):
    Error: no identifier for declarator row\n/tmp/tmpg0hgc3jh.d(38): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmpg0hgc3jh.d(38): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmpg0hgc3jh.d(38): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpg0hgc3jh.d(40): Error: no identifier for
    declarator col\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0hgc3jh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  long[][] result = new long[n][m];\n    \n    for (i = 0; i < n; i++)\n    {\n\
    \        for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n\
    \            {\n                result[i][j] = 1;\n                break;\n  \
    \          }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => b[0] -\
    \ a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpft54y9lr.d(91): Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmpft54y9lr.d(102):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmpft54y9lr.d(102): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmpft54y9lr.d(102): Error: expression
    expected, not \''}\''\n/tmp/tmpft54y9lr.d(102): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpft54y9lr.d(102): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpft54y9lr.d(102):
    Error: found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmpft54y9lr.d(102):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpft54y9lr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n \
    \   {\n        foreach(column: row, column: column) \n        {\n            if(column\
    \ == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpihxj4r2y.d(20): Error: no identifier for declarator row\n/tmp/tmpihxj4r2y.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpihxj4r2y.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpihxj4r2y.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpihxj4r2y.d(22): Error: no identifier
    for declarator column\n/tmp/tmpihxj4r2y.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpihxj4r2y.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpihxj4r2y.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpihxj4r2y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res = Tuple!(long, long)[i, j];\n       \
    \         break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk4jmisqy.d(20): Error: no identifier for declarator i\n/tmp/tmpk4jmisqy.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpk4jmisqy.d(22): Error: no
    identifier for declarator j\n/tmp/tmpk4jmisqy.d(22): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4jmisqy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm43fvxfj.d(22): Error: no identifier for declarator long\n/tmp/tmpm43fvxfj.d(22):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpm43fvxfj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjj89182e.d(20): Error: no identifier for declarator row\n/tmp/tmpjj89182e.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpjj89182e.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpjj89182e.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpjj89182e.d(22): Error: no identifier
    for declarator col\n/tmp/tmpjj89182e.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpjj89182e.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpjj89182e.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpjj89182e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  Arrays.sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxt2mxgx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  \n    Arrays.sort(res, (a, b) -> {\n        if(a.first > b.first)\n       \
    \     return 1;\n        if(a.first < b.first)\n            return -1;\n     \
    \   return 0;\n    });\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a.second\
    \ > b.second)\n            return 1;\n        if(a.second < b.second)\n      \
    \      return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkqn19anb.d(28): Error: expression expected, not \''>\''\n/tmp/tmpkqn19anb.d(28):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(29): Error: expression
    expected, not \''if\''\n/tmp/tmpkqn19anb.d(30): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmpkqn19anb.d(30): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpkqn19anb.d(31): Error: expression expected, not \''if\''\n/tmp/tmpkqn19anb.d(32):
    Error: found \''return\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(32): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(33): Error: expression
    expected, not \''return\''\n/tmp/tmpkqn19anb.d(33): Error: found \''0\'' when
    expecting \'',\''\n/tmp/tmpkqn19anb.d(33): Error: expression expected, not \'';\''\n/tmp/tmpkqn19anb.d(34):
    Error: found \''}\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(36): Error: expression
    expected, not \''>\''\n/tmp/tmpkqn19anb.d(36): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpkqn19anb.d(37): Error: expression expected, not \''if\''\n/tmp/tmpkqn19anb.d(38):
    Error: found \''return\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(38): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmpkqn19anb.d(39): Error: expression
    expected, not \''if\''\n/tmp/tmpkqn19anb.d(40): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmpkqn19anb.d(40): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpkqn19anb.d(41): Error: expression expected, not \''return\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkqn19anb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: long\
    \ in\n        enumerate(row))\n    {\n        foreach(col: row, col_index: long\
    \ in\n            enumerate(col))\n        {\n            if(col_index == x)\n\
    \            {\n                result = Tuple!(long, long)[Tuple!(0, row_index)];\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchvexuvy.d(20): Error: no identifier for declarator row\n/tmp/tmpchvexuvy.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpchvexuvy.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpchvexuvy.d(20): Error: no identifier for
    declarator long\n/tmp/tmpchvexuvy.d(20): Error: found \''in\'' instead of statement\n/tmp/tmpchvexuvy.d(31):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchvexuvy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    sort(res);\n    for(i\
    \ = 0; i < n; i++)\n    {\n        res[i] = res[i].swap;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpru5oehso.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i\
    \ < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) =>\
    \ a[0] - b[0]);\n    Arrays.sort(res, (a, b) => a[1] - b[1]);\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpavx41_80.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n         \
    \   \n            for(long j = 0; j < lst[i].Length; j++)\n            {\n   \
    \             if(lst[i][j] > x)\n                {\n                    row.Add(lst[i][j],\
    \ j);\n                }\n            }\n            \n            row.Sort();\n\
    \            \n            for(long j = 0; j < row.Length; j++)\n            {\n\
    \                result.Add(row[j], i);\n            }\n        }\n    }\n   \
    \ \n    result.Sort();\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ijhhww0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                res[i] = j;\n          \
    \      break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res,\
    \ lst.length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrpfw291.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23l8t3di.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfrevpfm9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n\
    \        foreach(long x, y)\n        {\n            if(x != x)\n            {\n\
    \                cols++;\n            }\n            else\n            {\n   \
    \             rows++;\n            }\n        }\n    }\n    \n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[rows];\n    \n    foreach(long y, lst)\n\
    \    {\n        foreach(long x, y)\n        {\n            if(x != x)\n      \
    \      {\n                result[rows] = new Tuple!(long, long)(x, y);\n     \
    \       }\n        }\n    }\n    \n    foreach(long y, lst)\n    {\n        foreach(long\
    \ x, y)\n        {\n            if(x != x)\n            {\n                result[rows]\
    \ = new Tuple!(long, long)(x, y);\n            }\n        }\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4gx6bzte.d(22): Error: no identifier for declarator lst\n/tmp/tmp4gx6bzte.d(22):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4gx6bzte.d(24): Error: no
    identifier for declarator y\n/tmp/tmp4gx6bzte.d(24): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4gx6bzte.d(35): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp4gx6bzte.d(39): Error: no identifier for declarator lst\n/tmp/tmp4gx6bzte.d(39):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4gx6bzte.d(41): Error: no
    identifier for declarator y\n/tmp/tmp4gx6bzte.d(41): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4gx6bzte.d(48): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp4gx6bzte.d(50): Error: no identifier for declarator lst\n/tmp/tmp4gx6bzte.d(50):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4gx6bzte.d(52): Error: no
    identifier for declarator y\n/tmp/tmp4gx6bzte.d(52): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4gx6bzte.d(59): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp4gx6bzte.d(63): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp4gx6bzte.d(74):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4gx6bzte.d(74):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp4gx6bzte.d(74): Error:
    found \''EOF\'' instead of statement\n/tmp/tmp4gx6bzte.d(74): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmp4gx6bzte.d(74): Error:
    found \''EOF\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4gx6bzte.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long\
    \ row = 0;\n    long col = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n     \
    \   for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n      \
    \      {\n                return Tuple!(long, long)[](row, col);\n           \
    \ }\n        }\n    }\n    return Tuple!(long, long)[](row, col);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqevpsrk5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (int)i;\n                  \
    \  temp[k][1] = (int)j;\n                }\n                Arrays.sort(temp,\
    \ (x, y) -> {\n                    return y[0] - x[0];\n                });\n\
    \                \n                Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[temp.length];\n                for(int k = 0; k < temp.length; k++)\n\
    \                {\n                    res[k] = new Tuple!(long, long)[temp[k].length];\n\
    \                    res[k][0] = (long)temp[k][0];\n                    res[k][1]\
    \ = (long)temp[k][1];\n                }\n                return res;\n      \
    \      }\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkjj4ueng.d(42): Error: C style cast illegal, use cast(int)i\n/tmp/tmpkjj4ueng.d(43):
    Error: C style cast illegal, use cast(int)j\n/tmp/tmpkjj4ueng.d(45): Error: expression
    expected, not \''>\''\n/tmp/tmpkjj4ueng.d(45): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpkjj4ueng.d(46): Error: expression expected, not \''return\''\n/tmp/tmpkjj4ueng.d(46):
    Error: found \''y\'' when expecting \'',\''\n/tmp/tmpkjj4ueng.d(46): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmpkjj4ueng.d(47): Error: expression expected,
    not \''}\''\n/tmp/tmpkjj4ueng.d(53): Error: C style cast illegal, use cast(long)temp[k][0]\n/tmp/tmpkjj4ueng.d(54):
    Error: C style cast illegal, use cast(long)temp[k][1]\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkjj4ueng.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpadihedf_.d(33): Error: expression expected, not \''>\''\n/tmp/tmpadihedf_.d(33):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpadihedf_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long[], long[])[](res);\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr69s1ufk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] row = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length;\
    \ i++)\n    {\n        row[i] = lst[0][i];\n    }\n    \n    for(int i = 0; i\
    \ < lst[0].Length; i++)\n    {\n        if(row[i] == x)\n        {\n         \
    \   Tuple!(long, long)[] res = new Tuple!(long, long)[lst[0].Length];\n      \
    \      for(int j = 0; j < lst[0].Length; j++)\n            {\n               \
    \ res[j] = (i, j);\n            }\n            return res;\n        }\n    }\n\
    \    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfuhwjg6_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpln7wroes.d(129): Error: no identifier for declarator int\n/tmp/tmpln7wroes.d(129):
    Error: expression expected, not \''unittest\''\n/tmp/tmpln7wroes.d(130): Error:
    found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmpln7wroes.d(131):
    Error: expression expected, not \''alias\''\n/tmp/tmpln7wroes.d(131): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmpln7wroes.d(131): Error: found
    \''=\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpln7wroes.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rey6jy7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n    \
    \    for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n     \
    \       {\n                result[i][j] = 1;\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n            {\n \
    \               k = j;\n                break;\n            }\n        }\n   \
    \     for(j = k - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j\
    \ + 1];\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] - 1;\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            result[i][j] = result[i][j] + 1;\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(result[i][j] == 0)\n            {\n                result[i][j]\
    \ = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n            {\n                k = j;\n                break;\n     \
    \       }\n        }\n        for(j = k - 1; j >= 0; j--)\n        {\n       \
    \     result[i][j] = result[i][j + 1];\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j]\
    \ = result[i][j] - 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n \
    \       for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j]\
    \ + 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n \
    \               result[i][j] = 1;\n                break;\n            }\n   \
    \     }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n\
    \        {\n            if(result[i][j] == 1)\n            {\n               \
    \ k = j;\n                break;\n            }\n        }\n        for(j = k\
    \ - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j + 1];\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            result[i][j] = result[i][j] - 1;\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            result[i][j] = result[i][j] + 1;\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxfl9g0ls.d(144): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfl9g0ls.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n            }\n        }\n    }\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_rz8ge9v.d(21): Error: no identifier for declarator row\n/tmp/tmp_rz8ge9v.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp_rz8ge9v.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp_rz8ge9v.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmp_rz8ge9v.d(23): Error: no identifier
    for declarator column\n/tmp/tmp_rz8ge9v.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp_rz8ge9v.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp_rz8ge9v.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_rz8ge9v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n \
    \           {\n                result[i][j] = 1;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n     \
    \   for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n   \
    \         {\n                k = j;\n                break;\n            }\n \
    \       }\n        \n        if(k == m)\n        {\n            k = j;\n     \
    \   }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j]\
    \ = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n           \
    \ {\n                k = j;\n                break;\n            }\n        }\n\
    \        \n        if(k == m)\n        {\n            k = j;\n        }\n    \
    \    \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqx6qoy6x.d(162): Error: found \''unittest\'' instead of statement\n/tmp/tmpqx6qoy6x.d(173):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqx6qoy6x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res[res.length] = Tuple!(row,col);\n            }\n\
    \        }\n    }\n    sort(res,fun(x1,x2)->x1.1 > x2.1);\n    sort(res,fun(x1,x2)->x1.2\
    \ > x2.2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpba64ix5a.d(20): Error: no identifier for declarator lst\n/tmp/tmpba64ix5a.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpba64ix5a.d(22): Error: no
    identifier for declarator row\n/tmp/tmpba64ix5a.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpba64ix5a.d(29): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpba64ix5a.d(30): Error: expression expected, not \''>\''\n/tmp/tmpba64ix5a.d(30):
    Error: found \''x1\'' when expecting \'',\''\n/tmp/tmpba64ix5a.d(30): Error: found
    \''0.1\'' when expecting \'',\''\n/tmp/tmpba64ix5a.d(31): Error: expression expected,
    not \''>\''\n/tmp/tmpba64ix5a.d(31): Error: found \''x1\'' when expecting \'',\''\n/tmp/tmpba64ix5a.d(31):
    Error: found \''0.2\'' when expecting \'',\''\n/tmp/tmpba64ix5a.d(34): Error:
    found \''unittest\'' when expecting \'')\''\n/tmp/tmpba64ix5a.d(45): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpba64ix5a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0knvmom.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n  \
    \  long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1\
    \ = m;\n    long m2 = m;\n    long m3 = m;\n    long m4 = m;\n    long m5 = m;\n\
    \    long m6 = m;\n    long m7 = m;\n    long m8 = m;\n    long m9 = m;\n    long\
    \ m10 = m;\n    long m11 = m;\n    long m12 = m;\n    long m13 = m;\n    long\
    \ m14 = m;\n    long m15 = m;\n    long m16 = m;\n    long m17 = m;\n    long\
    \ m18 = m;\n    long m19 = m;\n    long m20 = m;\n    long m21 = m;\n    long\
    \ m22 = m;\n    long m23 = m;\n    long m24 = m;\n    long m25 = m;\n    long\
    \ m26 = m;\n    long m27 = m;\n    long m28 = m;\n    long m29 = m;\n    long\
    \ m30 = m;\n    long m31 = m;\n    long m32 = m;\n    long m33 = m;\n    long\
    \ m34 = m;\n    long m35 = m;\n    long m36 = m;\n    long m37 = m;\n    long\
    \ m38 = m;\n    long m39 = m;\n    long m40 = m;\n    long m41 = m;\n    long\
    \ m42 = m;\n    long m43 = m;\n    long m44 = m;\n    long m45 = m;\n    long\
    \ m46 = m;\n    long m47 = m;\n    long m48 = m;\n    long m49 = m;\n    long\
    \ m50 = m;\n    long m51 = m;\n    long m52 = m;\n    long m53 = m;\n    long\
    \ m54 = m;\n    long m55 = m;\n    long m56 = m;\n    long m57 = m;\n    long\
    \ m58 = m;\n    long m59 = m;\n    long m60 = m;\n    long m61 = m;\n    long\
    \ m62 = m;\n    long m63 = m;\n    long m64 = m;\n    long m65 = m;\n    long\
    \ m66 = m;\n    long m67 = m;\n    long m68 = m;\n    long m69 = m;\n    long\
    \ m70\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf5nttor3.d(96): Error: semicolon expected, not \''unittest\''\n/tmp/tmpf5nttor3.d(96):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpf5nttor3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_oxzzbt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(res[i][j] == 1)\n            {\n                res[i][j] = j;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n\
    \            {\n                res[i][j] = i;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == i)\n            {\n           \
    \     res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == j)\n            {\n                res[i][j] = i;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n\
    \            {\n                res[i][j] = j;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == j)\n            {\n           \
    \     res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == i)\n            {\n                res[i][j] = j;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n\
    \            {\n                res[i][j] = i;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == i)\n            {\n           \
    \     res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == j)\n            {\n                res[i][j] = i;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n\
    \            {\n                res[i][j] = j;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        \nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1w9nn2hf.d(158): Error: found \''unittest\'' instead of statement\n/tmp/tmp1w9nn2hf.d(169):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1w9nn2hf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(int j = 0; j < lst[i].length; ++j)\n            {\n         \
    \       result.push((lst[i][0], lst[i][j]));\n            }\n        }\n    }\n\
    \    \n    result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a,\
    \ b){return b[1] - a[1]});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoqvswrxi.d(32): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmpoqvswrxi.d(32): Error: found \'')\'' instead
    of statement\n/tmp/tmpoqvswrxi.d(33): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmpoqvswrxi.d(33): Error: found \'')\'' instead
    of statement\n/tmp/tmpoqvswrxi.d(37): Error: found \''unittest\'' when expecting
    \'',\''\n/tmp/tmpoqvswrxi.d(48): Error: found \''void\'' when expecting \'',\''\n/tmp/tmpoqvswrxi.d(48):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpoqvswrxi.d(48): Error: expression
    expected, not \''}\''\n/tmp/tmpoqvswrxi.d(48): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpoqvswrxi.d(48): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpoqvswrxi.d(48):
    Error: found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmpoqvswrxi.d(48):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpoqvswrxi.d(48):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmpoqvswrxi.d(48): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmpoqvswrxi.d(48): Error: found \''EOF\''
    when expecting \'';\'' following statement\n/tmp/tmpoqvswrxi.d(48): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpoqvswrxi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[m];\n\
    \    for(int i = 0; i < m; i++)\n    {\n        res[i] = 0;\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[j]++;\n   \
    \         }\n        }\n    }\n    for(int i = 0; i < m; i++)\n    {\n       \
    \ res[i] = res[i] / n;\n    }\n    return Tuple!(long, long)[](res, m);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxyhublf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy2ibjtn7.d(21): Error: no identifier for declarator row\n/tmp/tmpy2ibjtn7.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpy2ibjtn7.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpy2ibjtn7.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpy2ibjtn7.d(23): Error: no identifier
    for declarator column\n/tmp/tmpy2ibjtn7.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpy2ibjtn7.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpy2ibjtn7.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpy2ibjtn7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long\
    \ min = 0;\n    long max = 0;\n    long sum = 0;\n    long count = 0;\n    long[][]\
    \ res = new long[n][m];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            sum += lst[i][j];\n            if(sum ==\
    \ x)\n            {\n                res[i][j] = 1;\n                count++;\n\
    \            }\n            else if(sum > x)\n            {\n                min\
    \ = j;\n                break;\n            }\n            else\n            {\n\
    \                max = j;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(res[i][j] == 1)\n            {\n                res[i][j]\
    \ = count;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n\
    \            {\n                max = res[i][j];\n            }\n            if(res[i][j]\
    \ < min)\n            {\n                min = res[i][j];\n            }\n   \
    \     }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n\
    \        {\n            if(res[i][j] > max)\n            {\n                max\
    \ = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n\
    \                min = res[i][j];\n            }\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(res[i][j] > max)\n            {\n                max = res[i][j];\n \
    \           }\n            if(res[i][j] < min)\n            {\n              \
    \  min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] >\
    \ max)\n            {\n                max = res[i][j];\n            }\n     \
    \       if(res[i][j] < min)\n            {\n                min = res[i][j];\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n\
    \                max = res[i][j];\n            }\n            if(res[i][j] < min)\n\
    \            {\n                min = res[i][j];\n            }\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(res[i][j] > max)\n            {\n                max =\
    \ res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n\
    \                min = res[i][j];\n            }\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(res[i][j] > max)\n            {\n                max = res[i][j\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt52q1ubj.d(150): Error: found \''unittest\'' when expecting
    \'']\''\n/tmp/tmpt52q1ubj.d(151): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpt52q1ubj.d(161): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpt52q1ubj.d(161): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpt52q1ubj.d(161):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt52q1ubj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i =\
    \ 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n    }\n    \n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n\
    \            if(lst[i][j] > x)\n            {\n                k = j;\n      \
    \          for(; k < m; k++)\n                {\n                    if(lst[i][k]\
    \ > x)\n                    {\n                        break;\n              \
    \      }\n                }\n                \n                result[i] = Tuple!(long,\
    \ long)[i, k];\n                break;\n            }\n        }\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gt00z4h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjhhuw68b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     ret.push(new Tuple!(lst[i][0], lst[i][1]));\n        }\n    }\n    \n  \
    \  sort(ret, (x, y) => y._1 - x._1);\n    sort(ret, (x, y) => y._2 - x._2);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5aeudgzn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result.add(new Tuple!(lst[i][1], i));\n        }\n    }\n    \n \
    \   result.sort(function(a, b) {\n        return a.1 < b.1;\n    });\n    \n \
    \   result.sort(function(a, b) {\n        return b.1 < a.1;\n    });\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpswfcqaos.d(30): Error: found \''0.1\'' when expecting \'';\''
    following return statement\n/tmp/tmpswfcqaos.d(30): Error: found \''<\'' instead
    of statement\n/tmp/tmpswfcqaos.d(34): Error: found \''0.1\'' when expecting \'';\''
    following return statement\n/tmp/tmpswfcqaos.d(34): Error: found \''<\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswfcqaos.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i\
    \ < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n   \
    \         if(res[i][j] == 0)\n            {\n                res[i][j] = -1;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n \
    \   {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n           \
    \ if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n      \
    \      }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n  \
    \  {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j]\
    \ == -1)\n            {\n                res[i][j] = -1;\n            }\n    \
    \    }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n\
    \            {\n                res[i][j] = -1;\n            }\n        }\n  \
    \  }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j\
    \ = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n \
    \           {\n                res[i][j] = -1;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j =\
    \ 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n   \
    \         {\n                res[i][j] = -1;\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n      \
    \      {\n                res[i][j] = -1;\n            }\n        }\n    }\n \
    \   \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j\
    \ < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n        \
    \    {\n                res[i][j] = -1;\n            }\n        }\n    }\n   \
    \ \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j <\
    \ lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n          \
    \  {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(res[i][j] == -1)\n            {\n          \
    \      res[i][j] = \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdi1w0snd.d(148): Error: expression expected, not \''unittest\''\n/tmp/tmpdi1w0snd.d(149):
    Error: found \''{\'' when expecting \'';\'' following statement\n/tmp/tmpdi1w0snd.d(159):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpdi1w0snd.d(159):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpdi1w0snd.d(159):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdi1w0snd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    long i = 0, j = 0, k = 0;\n    \n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[k] = Tuple!(i, j);\n             \
    \   k++;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n\
    \    Arrays.sort(res, (a, b) => Tuple!(b[0], a[0]));\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxynw6aol.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ \n    Arrays.sort(result, (a, b) => (a.0 < b.0) ? 1 : ((b.0 < a.0) ? -1 : 0));\n\
    \    Arrays.sort(result, (a, b) => (a.1 < b.1) ? 1 : ((b.1 < a.1) ? -1 : 0));\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplmtrvyac.d(28): Error: found \''0.00000\'' when expecting \'')\''\n/tmp/tmplmtrvyac.d(28):
    Error: found \''0.00000\'' when expecting \'',\''\n/tmp/tmplmtrvyac.d(28): Error:
    found \''0.00000\'' when expecting \'')\''\n/tmp/tmplmtrvyac.d(28): Error: found
    \''0.00000\'' when expecting \'')\''\n/tmp/tmplmtrvyac.d(28): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmplmtrvyac.d(28): Error: found
    \''?\'' instead of statement\n/tmp/tmplmtrvyac.d(29): Error: found \''0.1\'' when
    expecting \'')\''\n/tmp/tmplmtrvyac.d(29): Error: found \''0.1\'' when expecting
    \'',\''\n/tmp/tmplmtrvyac.d(29): Error: found \''0.1\'' when expecting \'')\''\n/tmp/tmplmtrvyac.d(29):
    Error: found \''0.1\'' when expecting \'')\''\n/tmp/tmplmtrvyac.d(29): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmplmtrvyac.d(29):
    Error: found \''?\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplmtrvyac.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i\
    \ : 0..lst.len())\n    {\n        if(lst[i][0] == x)\n        {\n            result\
    \ = append(result, Tuple!(long, long)[lst[i][1], lst[i][2]]);\n        }\n   \
    \ }\n    \n    sort(result);\n    sort(result, 1, 2);\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx7pz8xd8.d(21): Error: no identifier for declarator i\n/tmp/tmpx7pz8xd8.d(21):
    Error: found \'':\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpx7pz8xd8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n      \
    \  if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpifttznrd.d(20): Error: no identifier for declarator lst\n/tmp/tmpifttznrd.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpifttznrd.d(22): Error: no
    identifier for declarator row\n/tmp/tmpifttznrd.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpifttznrd.d(30): Error: found \''if\'' when expecting
    \'')\''\n/tmp/tmpifttznrd.d(31): Error: found \''break\'' when expecting \'';\''
    following statement\n/tmp/tmpifttznrd.d(33): Error: found \''return\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifttznrd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (int)i;\n                  \
    \  temp[k][1] = (int)j;\n                }\n                \n               \
    \ Arrays.sort(temp, (a, b) -> {\n                    if(a[0] > b[0])\n       \
    \             {\n                        return 1;\n                    }\n  \
    \                  if(a[0] == b[0])\n                    {\n                 \
    \       if(a[1] > b[1])\n                        {\n                         \
    \   return 1;\n                        }\n                        if(a[1] == b[1])\n\
    \                        {\n                            return 0;\n          \
    \              }\n                    }\n                    return -1;\n    \
    \            });\n                \n                for(int k = 0; k < m; k++)\n\
    \                {\n                    result[i][k] = temp[k][0];\n         \
    \           result[j][k] = temp[k][1];\n                }\n            }\n   \
    \     }\n    }\n    \n    Arrays.sort(result, (a, b) -> {\n        if(a[0] > b[0])\n\
    \        {\n            return 1;\n        }\n        if(a[0] == b[0])\n     \
    \   {\n            if(a[1] > b[1])\n            {\n                return 1;\n\
    \            }\n            if(a[1] == b[1])\n            {\n                return\
    \ 0;\n            }\n        }\n        return -1;\n    });\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                return Tuple!((long)i,\
    \ (long)j);\n            }\n        }\n    }\n    return Tuple!();\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplumw2352.d(42): Error: C style cast illegal, use cast(int)i\n/tmp/tmplumw2352.d(43):
    Error: C style cast illegal, use cast(int)j\n/tmp/tmplumw2352.d(46): Error: expression
    expected, not \''>\''\n/tmp/tmplumw2352.d(46): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmplumw2352.d(47): Error: expression expected, not \''if\''\n/tmp/tmplumw2352.d(48):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmplumw2352.d(49): Error: expression
    expected, not \''return\''\n/tmp/tmplumw2352.d(49): Error: found \''1\'' when
    expecting \'',\''\n/tmp/tmplumw2352.d(49): Error: expression expected, not \'';\''\n/tmp/tmplumw2352.d(50):
    Error: found \''}\'' when expecting \'',\''\n/tmp/tmplumw2352.d(51): Error: expression
    expected, not \''if\''\n/tmp/tmplumw2352.d(52): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmplumw2352.d(53): Error: expression expected, not \''if\''\n/tmp/tmplumw2352.d(54):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmplumw2352.d(55): Error: expression
    expected, not \''return\''\n/tmp/tmplumw2352.d(55): Error: found \''1\'' when
    expecting \'',\''\n/tmp/tmplumw2352.d(55): Error: expression expected, not \'';\''\n/tmp/tmplumw2352.d(56):
    Error: found \''}\'' when expecting \'',\''\n/tmp/tmplumw2352.d(57): Error: expression
    expected, not \''if\''\n/tmp/tmplumw2352.d(58): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmplumw2352.d(59): Error: expression expected, not \''return\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplumw2352.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23l8t3di.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = lst[i];\n   \
    \         break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_lym59i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n\
    \    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a,\
    \ b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpti575ujg.d(33): Error: expression expected, not \''>\''\n/tmp/tmpti575ujg.d(33):
    Error: found \''b\'' when expecting \'',\''\n/tmp/tmpti575ujg.d(34): Error: expression
    expected, not \''>\''\n/tmp/tmpti575ujg.d(34): Error: found \''b\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpti575ujg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n       \
    \     break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new\
    \ Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcidc2t75.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n  \
    \  \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                ans\
    \ += 1;\n                break;\n            }\n        }\n    }\n    \n    Tuple!(long,\
    \ long)[] ans = new Tuple!(long, long)[ans];\n    \n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                ans[ans].0 = i;\n                ans[ans].1\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4h62ak7q.d(43): Error: found \''0.00000\'' when expecting \'';\''
    following statement\n/tmp/tmp4h62ak7q.d(43): Error: found \''=\'' instead of statement\n/tmp/tmp4h62ak7q.d(44):
    Error: found \''0.1\'' when expecting \'';\'' following statement\n/tmp/tmp4h62ak7q.d(44):
    Error: found \''=\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4h62ak7q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                result[i][j] = 1;\n                break;\n     \
    \       }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n       \
    \ for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n     \
    \       {\n                k = j;\n                while(k >= 0 && lst[i][k] ==\
    \ x)\n                {\n                    result[i][k] = 2;\n             \
    \       k--;\n                }\n                k = j;\n                while(k\
    \ >= 0 && lst[i][k] == x)\n                {\n                    result[i][k]\
    \ = 1;\n                    k--;\n                }\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                k = j;\n                while(k >= 0 && lst[i][k]\
    \ == x)\n                {\n                    result[i][k] = 2;\n          \
    \          k--;\n                }\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n   \
    \             k = j;\n                while(k >= 0 && lst[i][k] == x)\n      \
    \          {\n                    result[i][k] = 1;\n                    k--;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(result[i][j] == 2)\n            {\n                k =\
    \ j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n   \
    \                 result[i][k] = 1;\n                    k--;\n              \
    \  }\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(result[i][j] == 2)\n            {\n                k = j;\n         \
    \       while(k >= 0 && lst[i][k] == x)\n                {\n                 \
    \   result[i][k] = 1;\n                    k--;\n                }\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                k = j;\n                while(k >= 0 &&\
    \ lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n\
    \                    k--;\n                }\n                break;\n       \
    \     }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp61tm1txu.d(146): Error: found \''unittest\'' instead of statement\n/tmp/tmp61tm1txu.d(157):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61tm1txu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long,\
    \ long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n   \
    \ \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn8_ju_5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = null;\n    \n    for(i = 0; i < n; i++) {\n    \
    \    for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n            \
    \    res = new Tuple!(long, long)[new Tuple!(i, j)]; \n                break;\n\
    \            }\n        }\n    }\n    \n    if(res == null) {\n        throw new\
    \ Exception(\"Invalid coordinate\");\n    }\n    \n    for(i = 0; i < n; i++)\
    \ {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] > x) {\n     \
    \           k = j;\n                break;\n            }\n        }\n       \
    \ \n        if(k > m) {\n            k = m;\n        }\n        \n        for(;\
    \ k < m; k++) {\n            res[new Tuple!(i, k)] = new Tuple!(i, k);\n     \
    \   }\n    }\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++)\
    \ {\n            if(lst[i][j] < x) {\n                k = j;\n               \
    \ break;\n            }\n        }\n        \n        if(k > m) {\n          \
    \  k = m;\n        }\n        \n        for(; k < m; k++) {\n            res[new\
    \ Tuple!(i, k)] = new Tuple!(i, k);\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0x_gjua.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[(i * m) + j] = (i * m) + j;\n            }\n        }\n \
    \   }\n    \n    Arrays.sort(res);\n    \n    for(int i = 0; i < n; i++)\n   \
    \ {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[(i * m)\
    \ + j] != (i * m) + j)\n            {\n                res[(i * m) + j] = (i *\
    \ m) + j;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b)\
    \ -> b - a);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[(n +\
    \ 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(res[(i * m) + j] != (i * m) +\
    \ j)\n            {\n                res[(i * m) + j] = (i * m) + j;\n       \
    \     }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2p1gs40y.d(47): Error: expression expected, not \''>\''\n/tmp/tmp2p1gs40y.d(47):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2p1gs40y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9fw1_iv.d(20): Error: no identifier for declarator row\n/tmp/tmpe9fw1_iv.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpe9fw1_iv.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpe9fw1_iv.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpe9fw1_iv.d(22): Error: no identifier
    for declarator col\n/tmp/tmpe9fw1_iv.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpe9fw1_iv.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpe9fw1_iv.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpe9fw1_iv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvno4i0e.d(20): Error: no identifier for declarator row\n/tmp/tmpsvno4i0e.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpsvno4i0e.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpsvno4i0e.d(22): Error: no identifier
    for declarator col\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsvno4i0e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res, lst.length);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd7tbrv3v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23l8t3di.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!<long,\
    \ long>[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp99w133lg.d(33): Error: found \'',\'' when expecting \''.\''
    following long\n/tmp/tmp99w133lg.d(33): Error: found \''long\'' when expecting
    identifier following \''long.\''\n/tmp/tmp99w133lg.d(33): Error: found \''>\''
    when expecting \'';\'' following return statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp99w133lg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4xumlh0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!((row_index, column_index), Tuple!((row_index, column_index))];\n\
    \            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5uirx6mw.d(21): Error: no identifier for declarator row\n/tmp/tmp5uirx6mw.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp5uirx6mw.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp5uirx6mw.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmp5uirx6mw.d(23): Error: no identifier
    for declarator column\n/tmp/tmp5uirx6mw.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp5uirx6mw.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp5uirx6mw.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmp5uirx6mw.d(27):
    Error: found \'']\'' when expecting \'')\'' following template argument list\n/tmp/tmp5uirx6mw.d(27):
    Error: found \'';\'' when expecting \'']\''\n/tmp/tmp5uirx6mw.d(28): Error: found
    \''}\'' when expecting \'';\'' following statement\n/tmp/tmp5uirx6mw.d(34): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp5uirx6mw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n            else\n            {\n  \
    \              res[i][j] = 0;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](sort(res), sort(res));\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0gehlqlr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0mdy339f.d(20): Error: no identifier for declarator lst\n/tmp/tmp0mdy339f.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp0mdy339f.d(22): Error: no
    identifier for declarator row\n/tmp/tmp0mdy339f.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp0mdy339f.d(30): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp0mdy339f.d(33): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp0mdy339f.d(44):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mdy339f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeq_959th.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n           \
    \ {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n         \
    \   }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n\
    \        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp34ui4b1o.d(130): Error: found \''unittest\'' when expecting
    \'';\'' following for condition\n/tmp/tmp34ui4b1o.d(141): Error: found \''void\''
    when expecting \'')\''\n/tmp/tmp34ui4b1o.d(141): Error: found \''{\'' when expecting
    \'';\'' following statement\n/tmp/tmp34ui4b1o.d(141): Error: found \''EOF\'' when
    expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp34ui4b1o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0knvmom.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9fw1_iv.d(20): Error: no identifier for declarator row\n/tmp/tmpe9fw1_iv.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpe9fw1_iv.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpe9fw1_iv.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpe9fw1_iv.d(22): Error: no identifier
    for declarator col\n/tmp/tmpe9fw1_iv.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpe9fw1_iv.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpe9fw1_iv.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpe9fw1_iv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long row = 0;\n    long col = 0;\n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[row][col] = i;\n              \
    \  result[row][col + 1] = j;\n                row++;\n                col = 0;\n\
    \            }\n            else\n            {\n                col++;\n    \
    \        }\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3xew955.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwv_2v909.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfrevpfm9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; i++)\n\
    \    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0;\
    \ j < cols; j++)\n        {\n            res[i][j] = new Tuple!(long, long)[i,\
    \ j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpspp0vt4b.d(38): Error: found \'',\'' when expecting \'']\''\n/tmp/tmpspp0vt4b.d(38):
    Error: found \''j\'' when expecting \'';\'' following statement\n/tmp/tmpspp0vt4b.d(38):
    Error: found \'']\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpspp0vt4b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n\
    \    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a,\
    \ b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpti575ujg.d(33): Error: expression expected, not \''>\''\n/tmp/tmpti575ujg.d(33):
    Error: found \''b\'' when expecting \'',\''\n/tmp/tmpti575ujg.d(34): Error: expression
    expected, not \''>\''\n/tmp/tmpti575ujg.d(34): Error: found \''b\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpti575ujg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = append(res, Tuple!(i, j));\n   \
    \         }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxcae24az.d(20): Error: no identifier for declarator i\n/tmp/tmpxcae24az.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpxcae24az.d(22): Error: no
    identifier for declarator j\n/tmp/tmpxcae24az.d(22): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcae24az.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n    \
    \    for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n     \
    \       {\n                result[i][j] = 1;\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      for(j = k; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                result[i][j] = 2;\n                break;\n  \
    \          }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n           \
    \ {\n                result[i][j] = 0;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 0)\n            {\n        \
    \        result[i][j] = 1;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(result[i][j] == 1)\n            {\n                result[i][j]\
    \ = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                result[i][j] = 0;\n                break;\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n           \
    \ {\n                result[i][j] = 1;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        result[i][j] = 2;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(result[i][j] == 2)\n            {\n                result[i][j]\
    \ = 0;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 0)\n            {\n                result[i][j] = 1;\n                break;\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n           \
    \ {\n                result[i][j] = 2;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 2)\n            {\n        \
    \        result[i][j] = 0;\n                break;\n            }\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5s1qz7sl.d(162): Error: found \''unittest\'' instead of statement\n/tmp/tmp5s1qz7sl.d(173):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp5s1qz7sl.d(173):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5s1qz7sl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row)\
    \ \n    {\n        foreach(column: row, column: column) \n        {\n        \
    \    if(column == x) \n            {\n                result = Tuple!(long, long)[](row,\
    \ column);\n                break;\n            }\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg6q_9hmv.d(21): Error: no identifier for declarator row\n/tmp/tmpg6q_9hmv.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpg6q_9hmv.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpg6q_9hmv.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpg6q_9hmv.d(23): Error: no identifier
    for declarator column\n/tmp/tmpg6q_9hmv.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpg6q_9hmv.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpg6q_9hmv.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg6q_9hmv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzvyv0d6k.d(98): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvyv0d6k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3es8lynf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = 0;\n    long m2 = 0;\n\
    \    long m3 = 0;\n    long m4 = 0;\n    long m5 = 0;\n    long m6 = 0;\n    long\
    \ m7 = 0;\n    long m8 = 0;\n    long m9 = 0;\n    long m10 = 0;\n    long m11\
    \ = 0;\n    long m12 = 0;\n    long m13 = 0;\n    long m14 = 0;\n    long m15\
    \ = 0;\n    long m16 = 0;\n    long m17 = 0;\n    long m18 = 0;\n    long m19\
    \ = 0;\n    long m20 = 0;\n    long m21 = 0;\n    long m22 = 0;\n    long m23\
    \ = 0;\n    long m24 = 0;\n    long m25 = 0;\n    long m26 = 0;\n    long m27\
    \ = 0;\n    long m28 = 0;\n    long m29 = 0;\n    long m30 = 0;\n    long m31\
    \ = 0;\n    long m32 = 0;\n    long m33 = 0;\n    long m34 = 0;\n    long m35\
    \ = 0;\n    long m36 = 0;\n    long m37 = 0;\n    long m38 = 0;\n    long m39\
    \ = 0;\n    long m40 = 0;\n    long m41 = 0;\n    long m42 = 0;\n    long m43\
    \ = 0;\n    long m44 = 0;\n    long m45 = 0;\n    long m46 = 0;\n    long m47\
    \ = 0;\n    long m48 = 0;\n    long m49 = 0;\n    long m50 = 0;\n    long m51\
    \ = 0;\n    long m52 = 0;\n    long m53 = 0;\n    long m54 = 0;\n    long m55\
    \ = 0;\n    long m56 = 0;\n    long m57 = 0;\n    long m58 = 0;\n    long m59\
    \ = 0;\n    long m60 = 0;\n    long m61 = 0;\n    long m62 = 0;\n    long m63\
    \ = 0;\n    long m64 = 0;\n    long m65 = 0;\n    long m66 = 0;\n    long m67\
    \ = 0;\n    long m68 = 0;\n    long m69 = 0;\n    long m70 = 0;\n    long m71\
    \ = 0;\n    long m72 = 0;\n    long m73 = 0;\n    long m74 = 0;\n    long m75\
    \ = 0;\n    long m76 = 0;\n    long m77 = 0;\n    long m78 = 0;\n    long m79\
    \ = 0;\n    long m80 = 0;\n\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0l09rvjn.d(106): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0l09rvjn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n                break;\n            }\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        k = j;\n                while(k >= 0 && lst[i][k] == x)\n           \
    \     {\n                    result[i][k] = 2;\n                    k--;\n   \
    \             }\n                k = j;\n                while(k >= 0 && lst[i][k]\
    \ == x)\n                {\n                    result[i][k] = 1;\n          \
    \          k--;\n                }\n                break;\n            }\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        k = j;\n                while(k >= 0 && lst[i][k] == x)\n           \
    \     {\n                    result[i][k] = 2;\n                    k--;\n   \
    \             }\n                break;\n            }\n        }\n    }\n   \
    \ for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 2)\n            {\n                k = j;\n   \
    \             while(k >= 0 && lst[i][k] == x)\n                {\n           \
    \         result[i][k] = 1;\n                    k--;\n                }\n   \
    \             break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                k = j;\n                while(k >= 0 &&\
    \ lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n\
    \                    k--;\n                }\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                k = j;\n                while(k >= 0 && lst[i][k] == x)\n   \
    \             {\n                    result[i][k] = 2;\n                    k--;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n\
    \            if(result[i][j] == 2)\n            {\n                k = j;\n  \
    \              while(k >= 0 && lst[i][k] == x)\n                {\n          \
    \          result[i][k] = 1;\n                    k--;\n                }\n  \
    \              break;\n            }\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo3j8pizv.d(142): Error: found \''unittest\'' instead of statement\n/tmp/tmpo3j8pizv.d(153):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpo3j8pizv.d(153):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3j8pizv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long\
    \ j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j]\
    \ > x)\n                {\n                    row.Add(lst[i][j], j);\n      \
    \          }\n            }\n            res.Add(row);\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjfhsgh2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0;\
    \ i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(int j = 0; j < lst[i].length; j++)\n            {\n             \
    \   row[j] = (lst[i][0], lst[i][1]);\n            }\n            sort(row);\n\
    \            sort(res);\n            res = new Tuple!(long, long)[res.length +\
    \ 1];\n            res[res.length - 1] = row;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrt5pmoq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] result = new long[lst.length][];\n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        if(lst[i][x] != 0)\n        {\n            result[i] =\
    \ new long[] {lst[i][x], i};\n        }\n    }\n    Arrays.sort(result);\n   \
    \ Arrays.sort(result, (a, b) => b[0] - a[0]);\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpii59b8r2.d(24): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpii59b8r2.d(24): Error: found \''}\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpii59b8r2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] result = new\
    \ long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j <\
    \ m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n        \
    \        result[i] = j;\n                break;\n            }\n        }\n  \
    \  }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) -> b - a);\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjuuv_41r.d(34): Error: expression expected, not \''>\''\n/tmp/tmpjuuv_41r.d(34):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpjuuv_41r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.Length-1)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            foreach(j : 0..lst[i][1]-1)\n\
    \            {\n                res.Add(Tuple!(i, j));\n            }\n      \
    \  }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwk04z1xg.d(20): Error: no identifier for declarator i\n/tmp/tmpwk04z1xg.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpwk04z1xg.d(24): Error: no
    identifier for declarator j\n/tmp/tmpwk04z1xg.d(24): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwk04z1xg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long result[][] =\
    \ new long[n][m];\n    long j = 0;\n    for(long i = 0; i < n; i++)\n    {\n \
    \       for(long k = 0; k < m; k++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                result[i][j] = k;\n                break;\n  \
    \          }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => (a[0]\
    \ - b[0]) * (a[1] - b[1]));\n    Arrays.sort(result, (a, b) => (b[0] - a[0]) *\
    \ (b[1] - a[1]));\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplj2s_2nw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1,\
    \ row)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpicn6y987.d(20): Error: no identifier for declarator row\n/tmp/tmpicn6y987.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpicn6y987.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpicn6y987.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpicn6y987.d(22): Error: no identifier
    for declarator col\n/tmp/tmpicn6y987.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpicn6y987.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpicn6y987.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpicn6y987.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i\
    \ : 0..lst.len) \n    {\n        foreach(j : 0..lst[i].len) \n        {\n    \
    \        if(lst[i][j] == x) \n            {\n                result.add(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(byRow);\n    result.sort(byCol);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_q5pd81d.d(21): Error: no identifier for declarator i\n/tmp/tmp_q5pd81d.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp_q5pd81d.d(23): Error: no
    identifier for declarator j\n/tmp/tmp_q5pd81d.d(23): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_q5pd81d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n            }\n        }\n    }\n    \n  \
    \  for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(long k = 0; k < m; k++)\n  \
    \              {\n                    temp[k][0] = (int)i;\n                 \
    \   temp[k][1] = (int)j;\n                }\n                \n              \
    \  sort(temp, (a, b) => b[0] - a[0]);\n                \n                for(long\
    \ k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n\
    \                    {\n                        swap(temp[k], temp[k - 1]);\n\
    \                    }\n                    if(temp[k][1] > j)\n             \
    \       {\n                        swap(temp[k], temp[k - 1]);\n             \
    \       }\n                }\n                \n                for(long k = 0;\
    \ k < m; k++)\n                {\n                    if(temp[k][0] > i)\n   \
    \                 {\n                        swap(temp[k], temp[k - 1]);\n   \
    \                 }\n                    if(temp[k][1] > j)\n                \
    \    {\n                        swap(temp[k], temp[k - 1]);\n                \
    \    }\n                }\n                \n                for(long k = 0; k\
    \ < m; k++)\n                {\n                    if(temp[k][0] > i)\n     \
    \               {\n                        swap(temp[k], temp[k - 1]);\n     \
    \               }\n                    if(temp[k][1] > j)\n                  \
    \  {\n                        swap(temp[k], temp[k - 1]);\n                  \
    \  }\n                }\n                \n                for(long k = 0; k <\
    \ m; k++)\n                {\n                    if(temp[k][0] > i)\n       \
    \             {\n                        swap(temp[k], temp[k - 1]);\n       \
    \             }\n                    if(temp[k][1] > j)\n                    {\n\
    \                        swap(temp[k], temp[k - 1]);\n                    }\n\
    \                }\n                \n                for(long k = 0; k < m; k++)\n\
    \                {\n                    if(temp[k][0] > i)\n                 \
    \   {\n                        swap(temp[k], temp[k - 1]);\n                 \
    \   }\n                    if(temp[k][1] > j)\n                    {\n       \
    \                 swap(temp[k], temp[k - 1]);\n                    }\n       \
    \         }\n                \n                for(long k = 0; k < m; k++)\n \
    \               {\n                    if(temp[k][0] > i)\n                  \
    \  {\n                        swap(temp[k], temp[k - 1]);\n                  \
    \  }\n                    if(temp[k][1] > j)\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk56g_2jp.d(43): Error: C style cast illegal, use cast(int)i\n/tmp/tmpk56g_2jp.d(44):
    Error: C style cast illegal, use cast(int)j\n/tmp/tmpk56g_2jp.d(116): Error: found
    \''unittest\'' instead of statement\n/tmp/tmpk56g_2jp.d(127): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpk56g_2jp.d(127):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpk56g_2jp.d(127):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpk56g_2jp.d(127):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk56g_2jp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu7b55zhu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n\
    \        if(y == x)\n        {\n            return Tuple!(long, long[])[](rows,\
    \ cols);\n        }\n        \n        foreach(long x, lst)\n        {\n     \
    \       if(y == x)\n            {\n                cols++;\n            }\n  \
    \      }\n        rows++;\n        cols = 0;\n    }\n    \n    return Tuple!(long,\
    \ long[])[](rows, cols);\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4rkwbwd6.d(22): Error: no identifier for declarator lst\n/tmp/tmp4rkwbwd6.d(22):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4rkwbwd6.d(29): Error: no
    identifier for declarator lst\n/tmp/tmp4rkwbwd6.d(29): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4rkwbwd6.d(36): Error: found \''rows\'' when expecting
    \'')\''\n/tmp/tmp4rkwbwd6.d(36): Error: expression expected, not \'';\''\n/tmp/tmp4rkwbwd6.d(37):
    Error: found \''cols\'' when expecting \'';\'' following statement\n/tmp/tmp4rkwbwd6.d(37):
    Error: found \''=\'' instead of statement\n/tmp/tmp4rkwbwd6.d(40): Error: found
    \''return\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4rkwbwd6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] result = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        result[i] =\
    \ new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n    \
    \    {\n            result[i][j] = new Tuple!(long, long)(i, j);\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb52qa5_n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row: row) \n    {\n        foreach(column: row, column: column) \n    \
    \    {\n            if(column == x) \n            {\n                result.push((row,\
    \ column));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwzt1zwv8.d(21): Error: no identifier for declarator row\n/tmp/tmpwzt1zwv8.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpwzt1zwv8.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpwzt1zwv8.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpwzt1zwv8.d(23): Error: no identifier
    for declarator column\n/tmp/tmpwzt1zwv8.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpwzt1zwv8.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpwzt1zwv8.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpwzt1zwv8.d(32):
    Error: missing { ... } for function literal\n/tmp/tmpwzt1zwv8.d(32): Error: expression
    expected, not \''>\''\n/tmp/tmpwzt1zwv8.d(32): Error: found \''a\'' when expecting
    \'',\''\n/tmp/tmpwzt1zwv8.d(33): Error: missing { ... } for function literal\n/tmp/tmpwzt1zwv8.d(33):
    Error: expression expected, not \''>\''\n/tmp/tmpwzt1zwv8.d(33): Error: found
    \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwzt1zwv8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = new Tuple!(i, j);\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = m-1; j >= 0; j--)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = new Tuple!(i, j);\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplv_rjxtf.d(151): Error: basic type expected, not unittest\n/tmp/tmplv_rjxtf.d(151):
    Error: found \''unittest\'' when expecting \'';\'' following statement\n/tmp/tmplv_rjxtf.d(162):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmplv_rjxtf.d(162):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmplv_rjxtf.d(162):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmplv_rjxtf.d(162):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplv_rjxtf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    foreach(long y, lst)\n    {\n   \
    \     foreach(long x, y)\n        {\n            if(x != x)\n            {\n \
    \               cols++;\n            }\n            else\n            {\n    \
    \            rows++;\n            }\n        }\n    }\n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[rows];\n    foreach(long y, lst)\n    {\n     \
    \   foreach(long x, y)\n        {\n            if(x != x)\n            {\n   \
    \             res[rows] = new Tuple!(long, long)(x, y);\n                rows++;\n\
    \            }\n            else\n            {\n                res[rows] = new\
    \ Tuple!(long, long)(x, y);\n                cols--;\n            }\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpap3lspx6.d(21): Error: no identifier for declarator lst\n/tmp/tmpap3lspx6.d(21):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpap3lspx6.d(23): Error: no
    identifier for declarator y\n/tmp/tmpap3lspx6.d(23): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpap3lspx6.d(34): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpap3lspx6.d(36): Error: no identifier for declarator lst\n/tmp/tmpap3lspx6.d(36):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpap3lspx6.d(38): Error: no
    identifier for declarator y\n/tmp/tmpap3lspx6.d(38): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpap3lspx6.d(51): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpap3lspx6.d(54): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpap3lspx6.d(65):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpap3lspx6.d(65):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpap3lspx6.d(65): Error:
    found \''EOF\'' instead of statement\n/tmp/tmpap3lspx6.d(65): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpap3lspx6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] > lst[i][0])\n\
    \            {\n                Tuple!(long, long)[] temp = new Tuple!(long, long)[lst[i].length];\n\
    \                for(int k = 0; k < lst[i].length; k++)\n                {\n \
    \                   temp[k] = new Tuple!(lst[i][j], k);\n                }\n \
    \               Arrays.sort(temp, (x, y) => y._1 > x._1);\n                for(int\
    \ k = 0; k < temp.length; k++)\n                {\n                    result[i]\
    \ = result[i].__append(temp[k]);\n                }\n            }\n        }\n\
    \    }\n    \n    Arrays.sort(result, (x, y) => y._1 > x._1);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedciugkk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long x1;\n    long x2;\n    long y1;\n    long y2;\n    long z = 0;\n   \
    \ long z1 = 0;\n    long z2 = 0;\n    long z3 = 0;\n    long z4 = 0;\n    long\
    \ z5 = 0;\n    long z6 = 0;\n    long z7 = 0;\n    long z8 = 0;\n    long z9 =\
    \ 0;\n    long z10 = 0;\n    long z11 = 0;\n    long z12 = 0;\n    long z13 =\
    \ 0;\n    long z14 = 0;\n    long z15 = 0;\n    long z16 = 0;\n    long z17 =\
    \ 0;\n    long z18 = 0;\n    long z19 = 0;\n    long z20 = 0;\n    long z21 =\
    \ 0;\n    long z22 = 0;\n    long z23 = 0;\n    long z24 = 0;\n    long z25 =\
    \ 0;\n    long z26 = 0;\n    long z27 = 0;\n    long z28 = 0;\n    long z29 =\
    \ 0;\n    long z30 = 0;\n    long z31 = 0;\n    long z32 = 0;\n    long z33 =\
    \ 0;\n    long z34 = 0;\n    long z35 = 0;\n    long z36 = 0;\n    long z37 =\
    \ 0;\n    long z38 = 0;\n    long z39 = 0;\n    long z40 = 0;\n    long z41 =\
    \ 0;\n    long z42 = 0;\n    long z43 = 0;\n    long z44 = 0;\n    long z45 =\
    \ 0;\n    long z46 = 0;\n    long z47 = 0;\n    long z48 = 0;\n    long z49 =\
    \ 0;\n    long z50 = 0;\n    long z51 = 0;\n    long z52 = 0;\n    long z53 =\
    \ 0;\n    long z54 = 0;\n    long z55 = 0;\n    long z56 = 0;\n    long z57 =\
    \ 0;\n    long z58 = 0;\n    long z59 = 0;\n    long z60 = 0;\n    long z61 =\
    \ 0;\n    long z62 = 0;\n    long z63 = 0;\n    long z64 = 0;\n    long z65 =\
    \ 0;\n    long z66 = 0;\n    long z67 = 0;\n    long z68 = 0;\n    long z69 =\
    \ 0;\n    long z70 = 0;\n    long z71 = 0;\n    long z72 = 0;\n    long z73 =\
    \ 0;\n    long z74 = 0;\n    long \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_wynovwf.d(107): Error: no identifier for declarator long\n/tmp/tmp_wynovwf.d(107):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_wynovwf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1),\
    \ Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    foreach(i : 0..lst.len())\n\
    \    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1,\
    \ j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzp8s6bd7.d(21): Error: no identifier for declarator i\n/tmp/tmpzp8s6bd7.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzp8s6bd7.d(23): Error: no
    identifier for declarator j\n/tmp/tmpzp8s6bd7.d(23): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmpzp8s6bd7.d(32): Error: no identifier for declarator
    i\n/tmp/tmpzp8s6bd7.d(32): Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzp8s6bd7.d(34):
    Error: no identifier for declarator j\n/tmp/tmpzp8s6bd7.d(34): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzp8s6bd7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                ret = new Tuple!(long, long)[ret.length + 1];\n    \
    \            ret[ret.length] = Tuple!(row, col);\n            }\n        }\n \
    \   }\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj7d38q5r.d(20): Error: no identifier for declarator lst\n/tmp/tmpj7d38q5r.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpj7d38q5r.d(22): Error: no
    identifier for declarator row\n/tmp/tmpj7d38q5r.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpj7d38q5r.d(30): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpj7d38q5r.d(34): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpj7d38q5r.d(45):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj7d38q5r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] > x)\n        \
    \    {\n                for(int k = j; k < lst[i].length; k++)\n             \
    \   {\n                    lst[i][k] = lst[i][k - 1];\n                }\n   \
    \             lst[i][0] = x;\n                break;\n            }\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] < x)\n \
    \           {\n                for(int k = j; k < lst[i].length; k++)\n      \
    \          {\n                    lst[i][k] = lst[i][k + 1];\n               \
    \ }\n                lst[i][1] = x;\n                break;\n            }\n \
    \       }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n     \
    \   for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] > x)\n            {\n                for(int k = j; k < lst[i].length;\
    \ k++)\n                {\n                    lst[i][k] = lst[i][k - 1];\n  \
    \              }\n                lst[i][0] = x;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] < x)\n            {\n                for(int k = j; k < lst[i].length;\
    \ k++)\n                {\n                    lst[i][k] = lst[i][k + 1];\n  \
    \              }\n                lst[i][1] = x;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n            }\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_gd0ljh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n\
    \    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new Tuple!(long,\
    \ long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n          \
    \  res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtq_va6b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ Arrays.sort(result, (x, y) => y._1 - x._1);\n    Arrays.sort(result, (x, y)\
    \ => y._2 - x._2);\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pxuzzn8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) {\n        foreach(col: row, j: 0) {\n            if(col == x) {\n   \
    \             ret.add((i, j));\n            }\n        }\n    }\n    sort(ret);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb5scj3xe.d(20): Error: no identifier for declarator row\n/tmp/tmpb5scj3xe.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpb5scj3xe.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpb5scj3xe.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpb5scj3xe.d(21): Error: no identifier
    for declarator col\n/tmp/tmpb5scj3xe.d(21): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpb5scj3xe.d(21): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpb5scj3xe.d(21):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpb5scj3xe.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                for(k = 0; k < m; k++)\n                {\n                 \
    \   result[i][k] = j;\n                }\n            }\n        }\n    }\n  \
    \  \n    Arrays.sort(result, (a, b) => (a[0] > b[0]) ? 1 : ((b[0] > a[0]) ? -1\
    \ : 0));\n    Arrays.sort(result, (a, b) => (a[1] > b[1]) ? 1 : ((b[1] > a[1])\
    \ ? -1 : 0));\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ysf9ibs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length;\
    \ i++)\n    {\n        res[i] = lst[0][i];\n    }\n    for(int i = 1; i < lst.Length;\
    \ i++)\n    {\n        for(int j = 0; j < lst[i].Length; j++)\n        {\n   \
    \         if(res[j] == x)\n            {\n                Tuple!(long, long)[]\
    \ ret = new Tuple!(long, long)[lst[i].Length];\n                for(int k = 0;\
    \ k < lst[i].Length; k++)\n                {\n                    ret[k] = Tuple!(long,\
    \ long)[i, k];\n                }\n                return ret;\n            }\n\
    \        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaff5wvya.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n                break;\n            }\n        }\n\
    \    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) -> {\n        if(a[0]\
    \ == b[0])\n            return a[1] - b[1];\n        return a[0] - b[0];\n   \
    \ });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprg2b3dnp.d(34): Error: expression expected, not \''>\''\n/tmp/tmprg2b3dnp.d(34):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmprg2b3dnp.d(35): Error: expression
    expected, not \''if\''\n/tmp/tmprg2b3dnp.d(36): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmprg2b3dnp.d(36): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmprg2b3dnp.d(37): Error: expression expected, not \''return\''\n/tmp/tmprg2b3dnp.d(37):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmprg2b3dnp.d(37): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmprg2b3dnp.d(38): Error: expression expected,
    not \''}\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg2b3dnp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzvyv0d6k.d(98): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvyv0d6k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res[res.length] = Tuple!(i, j);\n   \
    \         }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprj8cbq6y.d(20): Error: no identifier for declarator row\n/tmp/tmprj8cbq6y.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmprj8cbq6y.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmprj8cbq6y.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmprj8cbq6y.d(22): Error: no identifier
    for declarator col\n/tmp/tmprj8cbq6y.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmprj8cbq6y.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmprj8cbq6y.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprj8cbq6y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0mdy339f.d(20): Error: no identifier for declarator lst\n/tmp/tmp0mdy339f.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp0mdy339f.d(22): Error: no
    identifier for declarator row\n/tmp/tmp0mdy339f.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp0mdy339f.d(30): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp0mdy339f.d(33): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp0mdy339f.d(44):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mdy339f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1] + 1);\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfk7ww0ra.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n\
    \        {\n            if(column_index == x) \n            {\n              \
    \  foreach(coor: row, coor_index: 0) \n                {\n                   \
    \ if(coor_index == row_index) \n                    {\n                      \
    \  result.push(Tuple!(long, long)((row_index, column_index)));\n             \
    \       }\n                }\n            }\n        }\n    }\n    \n    sort(result,\
    \ (a, b) => a.1 < b.1);\n    sort(result, (a, b) => a.2 < b.2);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdsnick_k.d(21): Error: no identifier for declarator row\n/tmp/tmpdsnick_k.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpdsnick_k.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpdsnick_k.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpdsnick_k.d(23): Error: no identifier
    for declarator column\n/tmp/tmpdsnick_k.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpdsnick_k.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpdsnick_k.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpdsnick_k.d(27):
    Error: no identifier for declarator coor\n/tmp/tmpdsnick_k.d(27): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmpdsnick_k.d(27): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmpdsnick_k.d(27): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpdsnick_k.d(38): Error: found \''0.1\'' when
    expecting \'',\''\n/tmp/tmpdsnick_k.d(38): Error: expression expected, not \''<\''\n/tmp/tmpdsnick_k.d(38):
    Error: found \''b\'' when expecting \'',\''\n/tmp/tmpdsnick_k.d(39): Error: found
    \''0.2\'' when expecting \'',\''\n/tmp/tmpdsnick_k.d(39): Error: expression expected,
    not \''<\''\n/tmp/tmpdsnick_k.d(39): Error: found \''b\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdsnick_k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n\
    \    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    Arrays.sort(res, (a, b) -> {\n  \
    \      if(a[0] == b[0])\n        {\n            return a[1] - b[1];\n        }\n\
    \        return a[0] - b[0];\n    });\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz3bw8pel.d(32): Error: expression expected, not \''>\''\n/tmp/tmpz3bw8pel.d(32):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpz3bw8pel.d(33): Error: expression
    expected, not \''if\''\n/tmp/tmpz3bw8pel.d(34): Error: found \''{\'' when expecting
    \'',\''\n/tmp/tmpz3bw8pel.d(35): Error: expression expected, not \''return\''\n/tmp/tmpz3bw8pel.d(35):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmpz3bw8pel.d(35): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmpz3bw8pel.d(36): Error: expression expected,
    not \''}\''\n/tmp/tmpz3bw8pel.d(37): Error: found \''return\'' when expecting
    \'',\''\n/tmp/tmpz3bw8pel.d(37): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpz3bw8pel.d(38):
    Error: expression expected, not \''}\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpz3bw8pel.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[rows];\n\
    \    for(long i = 0; i < rows; ++i)\n    {\n        ret[i] = new Tuple!(long,\
    \ long)[cols];\n    }\n    for(long i = 0; i < rows; ++i)\n    {\n        for(long\
    \ j = 0; j < cols; ++j)\n        {\n            ret[i][j] = new Tuple!(long, long)();\n\
    \        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            for(long j = 0; j < cols; ++j)\n            {\n\
    \                ret[i][j] = new Tuple!(long, long)();\n            }\n      \
    \  }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw04s23rz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpftpl8hm4.d(141): Error: found \''unittest\'' when expecting
    \'']\''\n/tmp/tmpftpl8hm4.d(142): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpftpl8hm4.d(152): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpftpl8hm4.d(152): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpftpl8hm4.d(152):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpftpl8hm4.d(152):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpftpl8hm4.d(152):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftpl8hm4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(m\
    \ * n) + 1];\n    long i = 0, j = 0;\n    for(i = 0; i < n; i++) {\n        for(j\
    \ = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n                res[i\
    \ * m + j] = i;\n                res[i * m + j + 1] = j;\n            }\n    \
    \    }\n    }\n    sort(res, 0, res.length);\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfap8z4hi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfowz5z1_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!(row_index, column_index)];\n            }\n        }\n    }\n \
    \   \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmzs9bj5d.d(21): Error: no identifier for declarator row\n/tmp/tmpmzs9bj5d.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpmzs9bj5d.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpmzs9bj5d.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpmzs9bj5d.d(23): Error: no identifier
    for declarator column\n/tmp/tmpmzs9bj5d.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpmzs9bj5d.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpmzs9bj5d.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmzs9bj5d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res = Tuple!(long, long)[](Tuple!(i + 1,\
    \ j), Tuple!(i + 1, j + 1));\n            }\n        }\n    }\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqn6fl996.d(20): Error: no identifier for declarator i\n/tmp/tmpqn6fl996.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpqn6fl996.d(22): Error: no
    identifier for declarator j\n/tmp/tmpqn6fl996.d(22): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqn6fl996.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long\
    \ j = 0; j < lst[i][1]; ++j)\n            {\n                row.push(new Tuple!(long,\
    \ long)[lst[i][j]]);\n            }\n            res.push(row);\n        }\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpehxj8syf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvno4i0e.d(20): Error: no identifier for declarator row\n/tmp/tmpsvno4i0e.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpsvno4i0e.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpsvno4i0e.d(22): Error: no identifier
    for declarator col\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsvno4i0e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoeorlhy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    \n    for(int\
    \ i = 0; i < lst.length; i++) \n    {\n        if(lst[i][0] == x) \n        {\n\
    \            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n\
    \            for(int j = 0; j < lst[i].length; j++) \n            {\n        \
    \        row[j] = (lst[i][j], j);\n            }\n            \n            Arrays.sort(row);\n\
    \            \n            for(int j = 0; j < row.length; j++) \n            {\n\
    \                res[res.length] = row[j];\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgme4mia7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] result = new long[lst.Length];\n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        result[i] = lst[i][0];\n    }\n    Array.Sort(result);\n\
    \    Array.Sort(result, (x, y) => { return y - x; });\n    Array.Sort(result,\
    \ (x, y) => { return x - y; });\n    for(int i = 0; i < lst.Length; i++)\n   \
    \ {\n        if(result[i] == x)\n        {\n            return Tuple!(long[],\
    \ long[])[](Tuple!(long[], long[])[](Tuple!(0, i), Tuple!(0, i + 1)), Tuple!(0,\
    \ i + 1));\n        }\n    }\n    return Tuple!(long[], long[])[](Tuple!(0, 0),\
    \ Tuple!(0, 0));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0t6xxs0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] >\
    \ x)\n        {\n            for(int j = i; j < lst.length; ++j)\n           \
    \ {\n                if(lst[j][1] > x)\n                {\n                  \
    \  result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n        {\n        \
    \    for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1]\
    \ < x)\n                {\n                    result[i] = new Tuple!(lst[i][0],\
    \ lst[j][1]);\n                    break;\n                }\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n    \
    \    if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length;\
    \ ++j)\n            {\n                if(lst[j][1] > x)\n                {\n\
    \                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n         \
    \           break;\n                }\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n \
    \       {\n            for(int j = i; j < lst.length; ++j)\n            {\n  \
    \              if(lst[j][1] < x)\n                {\n                    result[i]\
    \ = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n          \
    \      }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i;\
    \ j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n   \
    \             {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = i; j < lst.length; ++j)\n         \
    \   {\n                if(lst[j][1] < x)\n                {\n                \
    \    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n        \
    \    for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1]\
    \ > x)\n                {\n                    result[i] = new Tuple!(lst[i][0],\
    \ lst[j][1]);\n                    break;\n                }\n            }\n\
    \        }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9c72j_1h.d(131): Error: found \''unittest\'' instead of statement\n/tmp/tmp9c72j_1h.d(142):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9c72j_1h.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (long)i;\n                 \
    \   temp[k][1] = (long)j;\n                }\n                sort(temp, false);\n\
    \                for(int k = 0; k < m; k++)\n                {\n             \
    \       result[i][k] = temp[k][0] * m + temp[k][1];\n                }\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                long temp[][] = new long[m][2];\n            \
    \    for(int k = 0; k < m; k++)\n                {\n                    temp[k][0]\
    \ = (long)i;\n                    temp[k][1] = (long)j;\n                }\n \
    \               sort(temp, true);\n                for(int k = 0; k < m; k++)\n\
    \                {\n                    result[i][j] = temp[k][0] * m + temp[k][1];\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(result[i][j] == 1)\n            {\n                long temp[][] = new\
    \ long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n\
    \                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n\
    \                }\n                sort(temp, true);\n                for(int\
    \ k = 0; k < m; k++)\n                {\n                    result[i][j] = temp[k][0]\
    \ * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (long)i;\n                 \
    \   temp[k][1] = (long)j;\n                }\n                sort(temp, true);\n\
    \                for(int k = 0; k < m; k++)\n                {\n             \
    \       result[i][j] = temp[k][0] * m + temp[k][1];\n                }\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmljki_v.d(42): Error: C style cast illegal, use cast(long)i\n/tmp/tmpnmljki_v.d(43):
    Error: C style cast illegal, use cast(long)j\n/tmp/tmpnmljki_v.d(63): Error: C
    style cast illegal, use cast(long)i\n/tmp/tmpnmljki_v.d(64): Error: C style cast
    illegal, use cast(long)j\n/tmp/tmpnmljki_v.d(84): Error: C style cast illegal,
    use cast(long)i\n/tmp/tmpnmljki_v.d(85): Error: C style cast illegal, use cast(long)j\n/tmp/tmpnmljki_v.d(105):
    Error: C style cast illegal, use cast(long)i\n/tmp/tmpnmljki_v.d(106): Error:
    C style cast illegal, use cast(long)j\n/tmp/tmpnmljki_v.d(122): Error: found \''unittest\''
    instead of statement\n/tmp/tmpnmljki_v.d(133): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpnmljki_v.d(133): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnmljki_v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(int j = 0; j < lst[i].length; ++j)\n            {\n         \
    \       if(lst[i][j] == x)\n                {\n                    result.add(new\
    \ Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n \
    \   result.sort(function(a, b){return b._1 - a._1});\n    result.sort(function(a,\
    \ b){return a._2 - b._2});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6gpghtuz.d(35): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmp6gpghtuz.d(35): Error: found \'')\'' instead
    of statement\n/tmp/tmp6gpghtuz.d(36): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmp6gpghtuz.d(36): Error: found \'')\'' instead
    of statement\n/tmp/tmp6gpghtuz.d(40): Error: found \''unittest\'' when expecting
    \'',\''\n/tmp/tmp6gpghtuz.d(51): Error: found \''void\'' when expecting \'',\''\n/tmp/tmp6gpghtuz.d(51):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmp6gpghtuz.d(51): Error: expression
    expected, not \''}\''\n/tmp/tmp6gpghtuz.d(51): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp6gpghtuz.d(51): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp6gpghtuz.d(51):
    Error: found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmp6gpghtuz.d(51):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp6gpghtuz.d(51):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp6gpghtuz.d(51): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmp6gpghtuz.d(51): Error: found \''EOF\''
    when expecting \'';\'' following statement\n/tmp/tmp6gpghtuz.d(51): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp6gpghtuz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, m);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaiog3fza.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[res];\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_ivg5ic.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmcolyda.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                ans = Tuple!(long, long)[i, j];\n            \
    \    break;\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5ojkw4u9.d(21): Error: no identifier for declarator i\n/tmp/tmp5ojkw4u9.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp5ojkw4u9.d(23): Error: no
    identifier for declarator j\n/tmp/tmp5ojkw4u9.d(23): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ojkw4u9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j;\n    \n    for (i = 0; i < n; i++)\n    {\n    \
    \    for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n   \
    \         {\n                result[i][j] = 1;\n                break;\n     \
    \       }\n        }\n    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[result.len()];\n    \n    for (i = 0; i < result.len(); i++)\n    {\n\
    \        res[i] = new Tuple!(long, long)[result[i].len()];\n        for (j = 0;\
    \ j < result[i].len(); j++)\n        {\n            res[i][j] = new Tuple!(long,\
    \ long)(0, 0);\n        }\n    }\n    \n    for (i = 0; i < n; i++)\n    {\n \
    \       for (j = 0; j < m; j++)\n        {\n            if (result[i][j] == 1)\n\
    \            {\n                res[i][j] = new Tuple!(long, long)(i, j);\n  \
    \          }\n        }\n    }\n    \n    sort!(res, (a, b) => (a.1, b.1), (a,\
    \ b) => (a.2, b.2), (a, b) => (a.3, b.3));\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdy5df10a.d(58): Error: found \''0.1\'' when expecting \'')\''\n/tmp/tmpdy5df10a.d(58):
    Error: found \''0.1\'' when expecting \'')\'' following template argument list\n/tmp/tmpdy5df10a.d(58):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpdy5df10a.d(58):
    Error: found \'',\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdy5df10a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n        if(res\
    \ != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn12kfgti.d(20): Error: no identifier for declarator row\n/tmp/tmpn12kfgti.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpn12kfgti.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpn12kfgti.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpn12kfgti.d(22): Error: no identifier
    for declarator col\n/tmp/tmpn12kfgti.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpn12kfgti.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpn12kfgti.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn12kfgti.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length;\
    \ i++) \n    {\n        for(int j = 0; j < lst[i].length; j++) \n        {\n \
    \           if(lst[i][j] == x) \n            {\n                res[i] = j;\n\
    \                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpai547f7f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i][1]; j++)\n        {\n            if(lst[i][0] == j)\n           \
    \ {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n         \
    \   }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n\
    \        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k\
    \ = 0; k < lst[i][1]; k++)\n            {\n                if(lst[i][0] == k)\n\
    \                {\n                    result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n  \
    \      {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n    \
    \            for(int l = 0; l < lst[i][1]; l++)\n                {\n         \
    \           if(lst[i][0] == l)\n                    {\n                      \
    \  result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                    }\n    \
    \            }\n            }\n        }\n    }\n    \n    for(int i = 0; i <\
    \ lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n      \
    \  {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n        \
    \        for(int l = 0; l < lst[i][1]; l++)\n                {\n             \
    \       for(int m = 0; m < lst[i][1]; m++)\n                    {\n          \
    \              if(lst[i][0] == m)\n                        {\n               \
    \             result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1];\
    \ k++)\n            {\n                for(int l = 0; l < lst[i][1]; l++)\n  \
    \              {\n                    for(int m = 0; m < lst[i][1]; m++)\n   \
    \                 {\n                        for(int n = 0; n < lst[i][1]; n++)\n\
    \                        {\n                            if(lst[i][0] == n)\n \
    \                           {\n                                result[i] = new\
    \ Tuple!(lst[i][0], lst[i][1]);\n                            }\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1];\
    \ k++)\n            {\n                for(int l = 0; l < lst[i][1]; l\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps0sjp8pr.d(120): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmps0sjp8pr.d(131): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmps0sjp8pr.d(131): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmps0sjp8pr.d(131):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmps0sjp8pr.d(131):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0sjp8pr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[(i * m) + j] = i;\n                res[(i * m) + j + 1] =\
    \ j;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n   \
    \ Tuple!(long, long)[] res = new Tuple!(long, long)[(res.length / 2) * (res.length\
    \ / 2)];\n    \n    for(int i = 0; i < res.length / 2; i++)\n    {\n        for(int\
    \ j = 0; j < res.length / 2; j++)\n        {\n            res[(i * res.length\
    \ / 2) + j] = new Tuple!(long, long)((res[i + j * res.length / 2]), res[i + j\
    \ * res.length / 2 + 1]);\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ejez8o4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col\
    \ == x) \n            {\n                Tuple!(long, long)[] rowRes = new Tuple!(long,\
    \ long)[row.Length];\n                foreach(colRes: row, k: 0) \n          \
    \      {\n                    rowRes[k] = Tuple!(long, long)[i, k];\n        \
    \        }\n                res = append(res, rowRes);\n            }\n      \
    \  }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuje337aa.d(20): Error: no identifier for declarator row\n/tmp/tmpuje337aa.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpuje337aa.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpuje337aa.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpuje337aa.d(22): Error: no identifier
    for declarator col\n/tmp/tmpuje337aa.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpuje337aa.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpuje337aa.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpuje337aa.d(27):
    Error: no identifier for declarator colRes\n/tmp/tmpuje337aa.d(27): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmpuje337aa.d(27): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmpuje337aa.d(27): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuje337aa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvno4i0e.d(20): Error: no identifier for declarator row\n/tmp/tmpsvno4i0e.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpsvno4i0e.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpsvno4i0e.d(22): Error: no identifier
    for declarator col\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpsvno4i0e.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpsvno4i0e.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsvno4i0e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpadihedf_.d(33): Error: expression expected, not \''>\''\n/tmp/tmpadihedf_.d(33):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpadihedf_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    for(i = 0; i\
    \ < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ < x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla0tp6fa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0glopzon.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n        if(res != null)\n            break;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1tcl4_pa.d(20): Error: no identifier for declarator lst\n/tmp/tmp1tcl4_pa.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp1tcl4_pa.d(22): Error: no
    identifier for declarator row\n/tmp/tmp1tcl4_pa.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp1tcl4_pa.d(30): Error: found \''if\'' when expecting
    \'')\''\n/tmp/tmp1tcl4_pa.d(31): Error: found \''break\'' when expecting \'';\''
    following statement\n/tmp/tmp1tcl4_pa.d(33): Error: found \''return\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tcl4_pa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ \n    Arrays.sort(result, (a, b) => a.first > b.first);\n    Arrays.sort(result,\
    \ (a, b) => a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvsgin4i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long,\
    \ long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n   \
    \ \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn8_ju_5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) => b[0] - a[0]);\n    \n    for(int i = 0; i < n;\
    \ i++)\n    {\n        Arrays.sort(res[i], (a, b) => b[1] - a[1]);\n    }\n  \
    \  \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5fq648ek.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n     \
    \   {\n            if(col == x) \n            {\n                ret[ret.length]\
    \ = Tuple!(row_index, col_index);\n            }\n        }\n    }\n    \n   \
    \ sort(ret, (x, y) => Tuple!(x._1, y._1));\n    sort(ret, (x, y) => Tuple!(y._1,\
    \ x._1));\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc3j8w67e.d(21): Error: no identifier for declarator row\n/tmp/tmpc3j8w67e.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpc3j8w67e.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpc3j8w67e.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpc3j8w67e.d(23): Error: no identifier
    for declarator col\n/tmp/tmpc3j8w67e.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpc3j8w67e.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpc3j8w67e.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc3j8w67e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    for(int i =\
    \ 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n    \
    \        Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(int\
    \ j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j]\
    \ > x)\n                {\n                    Tuple!(long, long)[] col = new\
    \ Tuple!(long, long)[j];\n                    row.Add(col);\n                }\n\
    \            }\n            result.Add(row);\n        }\n    }\n    result.Sort();\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwg8m2zf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       if(lst[i][0] == x)\n        {\n            ans = Tuple!(long, long)[Tuple!(i\
    \ + 1, lst[i][1])];\n            break;\n        }\n    }\n    \n    return ans;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgarr_fas.d(21): Error: no identifier for declarator i\n/tmp/tmpgarr_fas.d(21):
    Error: found \'':\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpgarr_fas.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result.push((lst[i][1], lst[i][2]));\n        }\n    }\n    \n  \
    \  result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a,\
    \ b){return a[1] - b[1]});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpebdzrrse.d(29): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmpebdzrrse.d(29): Error: found \'')\'' instead
    of statement\n/tmp/tmpebdzrrse.d(30): Error: found \''}\'' when expecting \'';\''
    following return statement\n/tmp/tmpebdzrrse.d(30): Error: found \'')\'' instead
    of statement\n/tmp/tmpebdzrrse.d(34): Error: found \''unittest\'' when expecting
    \'',\''\n/tmp/tmpebdzrrse.d(45): Error: found \''void\'' when expecting \'',\''\n/tmp/tmpebdzrrse.d(45):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpebdzrrse.d(45): Error: expression
    expected, not \''}\''\n/tmp/tmpebdzrrse.d(45): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpebdzrrse.d(45): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpebdzrrse.d(45):
    Error: found \''EOF\'' when expecting \'';\'' following statement\n/tmp/tmpebdzrrse.d(45):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpebdzrrse.d(45):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmpebdzrrse.d(45): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmpebdzrrse.d(45): Error: found \''EOF\''
    when expecting \'';\'' following statement\n/tmp/tmpebdzrrse.d(45): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpebdzrrse.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n     \
    \   {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[(n*m)];\n                for(k = 0; k <\
    \ n*m; k++)\n                {\n                    res[k] = new Tuple!(long,\
    \ long)(i, j);\n                }\n                return res;\n            }\n\
    \        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvs7ksjos.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n       \
    \     break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new\
    \ Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcidc2t75.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[rows];\n    long row = 0;\n    long col\
    \ = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[row][0] = row;\n            res[row][1] =\
    \ col;\n            row++;\n        }\n        else\n        {\n            res[row][0]\
    \ = row;\n            res[row][1] = col;\n            col++;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8n7m6qel.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res, lst.Length);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplv1m2ysp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n\
    \        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1]\
    \ == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res\
    \ = new Tuple!(long, long)[rows];\n    for(int i = 0; i < rows; i++){\n      \
    \  res[i] = new Tuple!(long, long)[cols];\n        for(int j = 0; j < cols; j++){\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[lst[i][0]][lst[i][1]]\
    \ = new Tuple!(long, long)();\n            res[lst[i][0]][lst[i][1]][0] = i;\n\
    \            res[lst[i][0]][lst[i][1]][1] = lst[i][1];\n        }\n        if(lst[i][1]\
    \ == x){\n            res[lst[i][0]][lst[i][1]][2] = i;\n            res[lst[i][0]][lst[i][1]][3]\
    \ = lst[i][0];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5j0n0qj8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \      }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa9eq4ytv.d(20): Error: no identifier for declarator row\n/tmp/tmpa9eq4ytv.d(20):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpa9eq4ytv.d(20): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpa9eq4ytv.d(20): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpa9eq4ytv.d(22): Error: no identifier
    for declarator col\n/tmp/tmpa9eq4ytv.d(22): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpa9eq4ytv.d(22): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpa9eq4ytv.d(22):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpa9eq4ytv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(ret);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_9loxh8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9xmfluw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result,\
    \ (a, b) -> {\n        return a[0] - b[0];\n    });\n    Arrays.sort(result, (a,\
    \ b) -> {\n        return b[1] - a[1];\n    });\n    \n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[result.length];\n    for(int i = 0; i < result.length;\
    \ i++)\n    {\n        res[i] = new Tuple!(long, long)[result[i].length];\n  \
    \      for(int j = 0; j < result[i].length; j++)\n        {\n            res[i][j]\
    \ = new Tuple!(long, long)();\n            res[i][j].first = 0;\n            res[i][j].second\
    \ = result[i][j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxgw15aac.d(32): Error: expression expected, not \''>\''\n/tmp/tmpxgw15aac.d(32):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpxgw15aac.d(33): Error: expression
    expected, not \''return\''\n/tmp/tmpxgw15aac.d(33): Error: found \''a\'' when
    expecting \'',\''\n/tmp/tmpxgw15aac.d(33): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpxgw15aac.d(34): Error: expression expected, not \''}\''\n/tmp/tmpxgw15aac.d(35):
    Error: expression expected, not \''>\''\n/tmp/tmpxgw15aac.d(35): Error: found
    \''{\'' when expecting \'',\''\n/tmp/tmpxgw15aac.d(36): Error: expression expected,
    not \''return\''\n/tmp/tmpxgw15aac.d(36): Error: found \''b\'' when expecting
    \'',\''\n/tmp/tmpxgw15aac.d(36): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpxgw15aac.d(37):
    Error: expression expected, not \''}\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxgw15aac.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzvyv0d6k.d(98): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvyv0d6k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015733
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row,lst)\n    {\n      \
    \  foreach(column,row)\n        {\n            if(column == x)\n            {\n\
    \                result = Tuple!(long, long)[](row,column);\n                break;\n\
    \            }\n        }\n        if(result != null)\n            break;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7q8vtcdt.d(20): Error: no identifier for declarator lst\n/tmp/tmp7q8vtcdt.d(20):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp7q8vtcdt.d(22): Error: no
    identifier for declarator row\n/tmp/tmp7q8vtcdt.d(22): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp7q8vtcdt.d(30): Error: found \''if\'' when expecting
    \'')\''\n/tmp/tmp7q8vtcdt.d(31): Error: found \''break\'' when expecting \'';\''
    following statement\n/tmp/tmp7q8vtcdt.d(33): Error: found \''return\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7q8vtcdt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n\
    \        {\n            if(column_index == x) \n            {\n              \
    \  foreach(tuple: result, tuple_index: 0) \n                {\n              \
    \      tuple.item1 = row_index;\n                    tuple.item2 = column_index;\n\
    \                }\n            }\n        }\n    }\n    \n    foreach(tuple:\
    \ result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 * -1;\n \
    \       tuple.item2 = tuple.item2 * -1;\n    }\n    \n    foreach(tuple: result,\
    \ tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2\
    \ = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0)\
    \ \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2\
    \ + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n    \
    \    tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n\
    \    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1\
    \ = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n  \
    \  foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1\
    \ + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple:\
    \ result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n  \
    \      tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result,\
    \ tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2\
    \ = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0)\
    \ \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2\
    \ + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n    \
    \    tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n\
    \    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1\
    \ = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n  \
    \  foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1\
    \ + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8jn6z61t.d(21): Error: no identifier for declarator row\n/tmp/tmp8jn6z61t.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp8jn6z61t.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp8jn6z61t.d(21): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmp8jn6z61t.d(23): Error: no identifier
    for declarator column\n/tmp/tmp8jn6z61t.d(23): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp8jn6z61t.d(23): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp8jn6z61t.d(23):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmp8jn6z61t.d(27):
    Error: no identifier for declarator tuple\n/tmp/tmp8jn6z61t.d(27): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmp8jn6z61t.d(27): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmp8jn6z61t.d(27): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp8jn6z61t.d(36): Error: no identifier for
    declarator tuple\n/tmp/tmp8jn6z61t.d(36): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp8jn6z61t.d(36): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp8jn6z61t.d(36):
    Error: found \'')\'' when expecting \'';\'' following statement\n/tmp/tmp8jn6z61t.d(42):
    Error: no identifier for declarator tuple\n/tmp/tmp8jn6z61t.d(42): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmp8jn6z61t.d(42): Error: found \'':\'' when
    expecting \'')\''\n/tmp/tmp8jn6z61t.d(42): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp8jn6z61t.d(48): Error: no identifier for
    declarator tuple\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8jn6z61t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows;\
    \ i++)\n    {\n        result[i] = new Tuple!(long, long)[cols];\n        for(long\
    \ j = 0; j < cols; j++)\n        {\n            result[i][j] = new Tuple!(long,\
    \ long)(i, j);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpix_mrriq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ long in  0 .. row.length - 1)\n    {\n        foreach(column: row[0..row.length\
    \ - 1], column_index: long in  0 .. row.length - 1 - row_index)\n        {\n \
    \           if(column_index == x)\n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl6o17ucs.d(21): Error: no identifier for declarator row\n/tmp/tmpl6o17ucs.d(21):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpl6o17ucs.d(21): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpl6o17ucs.d(21): Error: no identifier for
    declarator long\n/tmp/tmpl6o17ucs.d(21): Error: found \''in\'' instead of statement\n/tmp/tmpl6o17ucs.d(30):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl6o17ucs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(long j = 0; j < lst[i].length; ++j)\n            {\n        \
    \        result.add((i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b){return a.0 < b.0;});\n    result.sort(function(a, b){return b.1 < a.1;});\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzx7c6g9a.d(32): Error: found \''0.00000\'' when expecting \'';\''
    following return statement\n/tmp/tmpzx7c6g9a.d(32): Error: found \''<\'' instead
    of statement\n/tmp/tmpzx7c6g9a.d(33): Error: found \''0.1\'' when expecting \'';\''
    following return statement\n/tmp/tmpzx7c6g9a.d(33): Error: found \''<\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzx7c6g9a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015734
